B, 0x31, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 
	0x2B, 0x31, 0x15, 0x28, 0x29, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2F, 0x39, 0x37, 0x37, 0x2E, 0x1B, 0x2F, 0x39, 0x1A, 0x32, 0x3B, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x44, 0x1D, 
	0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x20, 0x46, 0x49, 0x1C, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x2E, 
	0x38, 0x1D, 0x3C, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3B, 0x40, 0x1B, 0x3C, 0x3C, 0x23, 0x49, 0x4E, 
	0x30, 0x40, 0x40, 0x35, 0x3C, 0x39, 0x1E, 0x42, 0x44, 0x1D, 0x4C, 0x55, 0x11, 0x33, 0x3C, 0x15, 
	0x37, 0x39, 0x2B, 0x4C, 0x56, 0x19, 0x43, 0x48, 0x15, 0x3F, 0x4A, 0x22, 0x3C, 0x3B, 0x56, 0x50, 
	0x4C, 0x5A, 0x55, 0x4E, 0x4F, 0x51, 0x4B, 0x1B, 0x43, 0x4B, 0x1B, 0x42, 0x42, 0x26, 0x4A, 0x54, 
	0x29, 0x4B, 0x51, 0x69, 0x59, 0x4E, 0x5A, 0x53, 0x4E, 0x1F, 0x3C, 0x3F, 0x27, 0x4A, 0x53, 0x2E, 
	0x4F, 0x52, 0x29, 0x4E, 0x52, 0x3C, 0x4D, 0x4C, 0x2B, 0x4E, 0x52, 0x28, 0x4B, 0x52, 0x24, 0x47, 
	0x52, 0x28, 0x4B, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x2C, 0x4E, 0x52, 0x1C, 0x49, 0x53, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x75, 0x7E, 0x29, 
	0x4E, 0x57, 0x31, 0x53, 0x51, 0x30, 0x52, 0x52, 0x31, 0x53, 0x52, 0x2B, 0x4D, 0x52, 0x15, 0x48, 
	0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x32, 0x54, 0x52, 0x26, 0x49, 0x52, 
	0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4B, 0x54, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x25, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 
	0x1B, 0x3D, 0x39, 0x1B, 0x4C, 0x56, 0x1B, 0x3B, 0x3B, 0x27, 0x4B, 0x52, 0x1A, 0x3B, 0x3C, 0x20, 
	0x3E, 0x3D, 0x3B, 0x43, 0x43, 0x19, 0x40, 0x3F, 0x18, 0x3C, 0x40, 0x1E, 0x32, 0x3B, 0x1A, 0x26, 
	0x2C, 0x1D, 0x3E, 0x43, 0x1D, 0x39, 0x3F, 0x1D, 0x2B, 0x35, 0x1D, 0x3B, 0x42, 0x1D, 0x3D, 0x42, 
	0x1A, 0x2A, 0x35, 0x1C, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x20, 0x12, 0x25, 0x23, 0x1B, 
	0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x18, 0x3D, 0x44, 0x4A, 0x3D, 0x33, 0x54, 0x4B, 0x42, 0x45, 0x3C, 
	0x33, 0x15, 0x2B, 0x34, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x1A, 0x2C, 0x32, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x1F, 
	0x31, 0x3B, 0x18, 0x28, 0x2B, 0x18, 0x37, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x1B, 0x30, 0x3A, 0x1C, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2F, 0x39, 0x1C, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x3C, 0x40, 0x1C, 0x34, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x37, 0x40, 0x18, 0x3F, 0x3D, 
	0x35, 0x3C, 0x39, 0x2B, 0x3D, 0x3B, 0x1A, 0x46, 0x4A, 0x1D, 0x4B, 0x54, 0x18, 0x3E, 0x47, 0x1E, 
	0x4E, 0x56, 0x1E, 0x48, 0x4D, 0x28, 0x4C, 0x54, 0x1A, 0x4C, 0x55, 0x27, 0x40, 0x44, 0x5F, 0x59, 
	0x52, 0x62, 0x58, 0x4F, 0x58, 0x54, 0x50, 0x27, 0x40, 0x42, 0x19, 0x4A, 0x51, 0x29, 0x49, 0x4F, 
	0x3B, 0x44, 0x43, 0x48, 0x4C, 0x4A, 0x43, 0x55, 0x53, 0x1D, 0x48, 0x4F, 0x28, 0x4A, 0x53, 0x18, 
	0x4A, 0x53, 0x2C, 0x4F, 0x53, 0x31, 0x55, 0x53, 0x2B, 0x4E, 0x52, 0x30, 0x51, 0x52, 0x32, 0x54, 
	0x52, 0x2B, 0x4D, 0x52, 0x2C, 0x4E, 0x52, 0x2B, 0x4D, 0x51, 0x2F, 0x53, 0x57, 0x2E, 0x59, 0x5F, 
	0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x20, 0x25, 0x3B, 0x7C, 0x88, 0x30, 
	0x54, 0x5B, 0x2A, 0x4C, 0x50, 0x31, 0x54, 0x53, 0x2E, 0x4F, 0x51, 0x2E, 0x50, 0x52, 0x2C, 0x4E, 
	0x51, 0x2C, 0x4E, 0x52, 0x29, 0x4B, 0x52, 0x29, 0x4B, 0x52, 0x2C, 0x50, 0x53, 0x26, 0x4A, 0x53, 
	0x27, 0x4A, 0x53, 0x27, 0x4C, 0x55, 0x23, 0x39, 0x36, 0x31, 0x55, 0x55, 0x26, 0x4A, 0x53, 0x27, 
	0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x28, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4A, 
	0x53, 0x27, 0x4B, 0x53, 0x28, 0x4C, 0x54, 0x1C, 0x44, 0x46, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x53, 
	0x28, 0x4B, 0x54, 0x25, 0x47, 0x4D, 0x1D, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x26, 
	0x4A, 0x54, 0x37, 0x4F, 0x4D, 0x2E, 0x3F, 0x3E, 0x0E, 0x35, 0x40, 0x1A, 0x3C, 0x3F, 0x22, 0x42, 
	0x49, 0x1C, 0x3E, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3B, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x28, 0x14, 
	0x27, 0x27, 0x1B, 0x2C, 0x33, 0x19, 0x3C, 0x44, 0x3B, 0x3A, 0x33, 0x54, 0x4B, 0x40, 0x48, 0x3E, 
	0x34, 0x1E, 0x33, 0x3B, 0x16, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1C, 0x2E, 0x36, 0x18, 
	0x35, 0x3D, 0x18, 0x35, 0x3E, 0x1E, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x14, 0x27, 0x27, 0x16, 0x29, 0x2C, 0x23, 0x2F, 0x33, 0x1C, 0x37, 0x3F, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x42, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x2F, 
	0x3A, 0x1B, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x1C, 0x3F, 0x3F, 0x1B, 0x3F, 0x3D, 0x29, 0x4E, 0x59, 
	0x2B, 0x44, 0x47, 0x50, 0x3C, 0x30, 0x19, 0x49, 0x52, 0x1C, 0x4B, 0x54, 0x1E, 0x4C, 0x51, 0x16, 
	0x43, 0x4D, 0x1E, 0x3E, 0x48, 0x1A, 0x42, 0x4B, 0x1A, 0x46, 0x4C, 0x50, 0x5E, 0x61, 0x69, 0x5B, 
	0x4A, 0x55, 0x4C, 0x3F, 0x49, 0x4B, 0x46, 0x22, 0x48, 0x50, 0x24, 0x3E, 0x48, 0x23, 0x3E, 0x49, 
	0x24, 0x46, 0x4B, 0x43, 0x44, 0x3D, 0x40, 0x47, 0x44, 0x22, 0x3F, 0x48, 0x31, 0x4E, 0x4E, 0x22, 
	0x3D, 0x47, 0x25, 0x40, 0x48, 0x26, 0x43, 0x4B, 0x1C, 0x49, 0x53, 0x1C, 0x47, 0x52, 0x29, 0x53, 
	0x58, 0x28, 0x53, 0x57, 0x28, 0x53, 0x57, 0x28, 0x52, 0x57, 0x2B, 0x56, 0x5D, 0x30, 0x54, 0x5F, 
	0x03, 0x08, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x12, 0x24, 0x25, 0x39, 0x71, 0x7F, 0x2E, 
	0x56, 0x5D, 0x27, 0x53, 0x57, 0x27, 0x46, 0x4B, 0x2A, 0x57, 0x5F, 0x34, 0x51, 0x55, 0x2A, 0x56, 
	0x5D, 0x27, 0x52, 0x56, 0x28, 0x52, 0x56, 0x28, 0x54, 0x58, 0x24, 0x3E, 0x46, 0x25, 0x43, 0x4A, 
	0x29, 0x50, 0x4D, 0x25, 0x43, 0x4A, 0x28, 0x45, 0x4A, 0x28, 0x43, 0x47, 0x23, 0x44, 0x4D, 0x24, 
	0x3E, 0x48, 0x23, 0x3E, 0x48, 0x27, 0x45, 0x4B, 0x18, 0x42, 0x4B, 0x27, 0x40, 0x48, 0x29, 0x4D, 
	0x4D, 0x25, 0x44, 0x4A, 0x23, 0x3E, 0x48, 0x24, 0x3E, 0x49, 0x23, 0x40, 0x4A, 0x23, 0x40, 0x4A, 
	0x28, 0x4C, 0x54, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x47, 0x4E, 0x35, 0x3F, 0x3E, 0x1B, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1C, 0x3E, 
	0x3F, 0x1D, 0x35, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1B, 0x31, 0x3B, 0x2B, 0x3C, 0x3D, 0x4E, 0x40, 0x37, 0x4E, 0x40, 
	0x37, 0x28, 0x42, 0x46, 0x0E, 0x22, 0x1F, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1A, 0x2C, 0x32, 0x11, 0x24, 0x22, 0x15, 0x27, 0x28, 0x19, 
	0x36, 0x40, 0x19, 0x35, 0x3D, 0x16, 0x35, 0x3E, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x29, 0x2C, 0x1B, 0x39, 0x45, 0x37, 0x35, 0x2A, 0x1A, 0x2C, 0x37, 0x1C, 0x2F, 0x37, 
	0x1A, 0x2A, 0x31, 0x1D, 0x3F, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3F, 0x43, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x38, 
	0x3E, 0x28, 0x4D, 0x54, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1D, 0x3F, 0x3E, 0x1A, 0x3D, 0x3B, 
	0x24, 0x3F, 0x40, 0x4D, 0x3D, 0x33, 0x37, 0x44, 0x44, 0x1E, 0x48, 0x4C, 0x1A, 0x2B, 0x32, 0x13, 
	0x12, 0x0E, 0x07, 0x03, 0x00, 0x07, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x06, 0x03, 0x09, 0x0B, 
	0x09, 0x07, 0x00, 0x00, 0x00, 0x08, 0x07, 0x06, 0x09, 0x06, 0x0B, 0x07, 0x02, 0x0B, 0x03, 0x00, 
	0x06, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x06, 0x06, 0x02, 0x14, 0x09, 0x0D, 0x03, 0x08, 0x03, 0x14, 
	0x09, 0x0D, 0x0F, 0x06, 0x06, 0x09, 0x02, 0x00, 0x07, 0x09, 0x04, 0x07, 0x08, 0x04, 0x06, 0x07, 
	0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x09, 0x0B, 0x0B, 0x06, 0x03, 0x00, 
	0x0E, 0x0D, 0x11, 0x0B, 0x0B, 0x0E, 0x09, 0x0B, 0x0E, 0x0F, 0x09, 0x0D, 0x08, 0x0C, 0x08, 0x06, 
	0x06, 0x02, 0x06, 0x07, 0x03, 0x06, 0x08, 0x04, 0x06, 0x06, 0x02, 0x0C, 0x0E, 0x12, 0x08, 0x09, 
	0x08, 0x0C, 0x0D, 0x0F, 0x0C, 0x0D, 0x0F, 0x0C, 0x0E, 0x11, 0x13, 0x08, 0x0B, 0x13, 0x08, 0x0B, 
	0x0B, 0x0F, 0x12, 0x13, 0x08, 0x09, 0x13, 0x08, 0x0C, 0x0F, 0x0C, 0x0E, 0x0D, 0x11, 0x13, 0x06, 
	0x06, 0x00, 0x0E, 0x03, 0x00, 0x06, 0x02, 0x00, 0x07, 0x07, 0x03, 0x09, 0x00, 0x00, 0x08, 0x0C, 
	0x0C, 0x14, 0x09, 0x0C, 0x0F, 0x06, 0x04, 0x0C, 0x08, 0x07, 0x0B, 0x0E, 0x12, 0x04, 0x0C, 0x08, 
	0x24, 0x47, 0x4D, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x18, 0x3D, 0x3C, 0x1F, 0x43, 0x45, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 
	0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x14, 0x27, 0x27, 0x1B, 0x2B, 0x33, 0x16, 0x3F, 0x45, 0x3C, 0x3C, 0x34, 0x4D, 0x40, 
	0x37, 0x44, 0x47, 0x44, 0x15, 0x2B, 0x34, 0x14, 0x27, 0x28, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3D, 0x14, 0x27, 0x27, 0x15, 
	0x27, 0x28, 0x19, 0x2A, 0x2E, 0x1B, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x16, 0x29, 0x2B, 0x1D, 0x2F, 0x38, 0x1B, 0x2E, 0x38, 0x1C, 0x3D, 0x40, 0x27, 0x31, 0x34, 
	0x1C, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x44, 0x42, 0x1D, 
	0x2B, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x43, 0x40, 0x1B, 0x3A, 
	0x3D, 0x1B, 0x37, 0x3D, 0x1C, 0x3A, 0x3E, 0x25, 0x48, 0x4C, 0x1B, 0x48, 0x4F, 0x1C, 0x4C, 0x56, 
	0x1F, 0x44, 0x46, 0x37, 0x36, 0x2E, 0x36, 0x3A, 0x34, 0x1A, 0x49, 0x4E, 0x1B, 0x28, 0x32, 0x33, 
	0x66, 0x71, 0x3A, 0x95, 0xA7, 0x3B, 0x95, 0xA6, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x94, 
	0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 
	0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x93, 0xA3, 0x3B, 0x93, 0xA4, 0x3A, 
	0x94, 0xA4, 0x3A, 0x93, 0xA4, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 
	0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x94, 0xA5, 
	0x3A, 0x93, 0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x94, 0xA4, 0x3A, 0x94, 0xA4, 0x3A, 0x92, 0xA3, 0x3B, 
	0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x92, 0xA3, 0x3A, 0x91, 
	0xA2, 0x3D, 0x97, 0xAC, 0x3A, 0x92, 0xA2, 0x3A, 0x92, 0xA3, 0x3A, 0x93, 0xA3, 0x39, 0x92, 0xA2, 
	0x3A, 0x91, 0xA1, 0x3D, 0x99, 0xAD, 0x39, 0x92, 0xA2, 0x3A, 0x93, 0xA3, 0x3A, 0x92, 0xA3, 0x3A, 
	0x92, 0xA3, 0x3A, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x91, 0xA2, 0x42, 0xA3, 0xB0, 0x3A, 0x91, 
	0xA2, 0x3A, 0x93, 0xA3, 0x39, 0x91, 0xA2, 0x43, 0x9C, 0xB0, 0x5C, 0xB6, 0xC5, 0x0B, 0x0F, 0x12, 
	0x24, 0x40, 0x4A, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 
	0x48, 0x4E, 0x27, 0x4A, 0x53, 0x22, 0x45, 0x49, 0x28, 0x4C, 0x56, 0x24, 0x47, 0x4B, 0x1C, 0x3C, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2E, 0x1C, 0x31, 0x3A, 0x1E, 0x31, 0x37, 0x4A, 0x3F, 
	0x35, 0x4F, 0x40, 0x39, 0x1F, 0x2F, 0x34, 0x1A, 0x2C, 0x34, 0x1B, 0x2E, 0x35, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 0x23, 0x1F, 0x31, 0x3B, 0x1C, 0x35, 0x3F, 0x15, 
	0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1A, 0x33, 0x3C, 0x1E, 0x31, 0x3A, 0x1A, 0x2A, 0x31, 0x1D, 0x3E, 0x44, 0x1C, 0x2E, 0x37, 
	0x1A, 0x2B, 0x31, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2C, 0x35, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x2A, 0x4F, 
	0x59, 0x1E, 0x40, 0x43, 0x1C, 0x37, 0x3E, 0x1F, 0x3D, 0x44, 0x29, 0x4C, 0x56, 0x1D, 0x49, 0x53, 
	0x1D, 0x42, 0x43, 0x35, 0x49, 0x4C, 0x33, 0x3D, 0x3A, 0x1B, 0x46, 0x4D, 0x19, 0x29, 0x32, 0x3B, 
	0x77, 0x84, 0x3C, 0xA1, 0xBB, 0x40, 0xA4, 0xBD, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBB, 0x40, 0xA2, 
	0xBC, 0x40, 0xA2, 0xBC, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBC, 0x3F, 0xA1, 0xBB, 0x44, 0xAA, 0xC2, 
	0x44, 0xAA, 0xC2, 0x3F, 0xA0, 0xBA, 0x44, 0xA9, 0xC1, 0x46, 0xB1, 0xC5, 0x47, 0xB2, 0xC6, 0x3E, 
	0x9F, 0xB9, 0x47, 0xB3, 0xC7, 0x3F, 0xA0, 0xBA, 0x3F, 0xA0, 0xBA, 0x47, 0xB2, 0xC5, 0x46, 0xB1, 
	0xC5, 0x43, 0xA8, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 0xB1, 0xC5, 0x43, 0xA8, 0xC0, 0x43, 0xA8, 0xC0, 
	0x47, 0xB2, 0xC5, 0x43, 0xA8, 0xC0, 0x44, 0xA9, 0xC1, 0x43, 0xA9, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 
	0xB1, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB1, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 
	0xCD, 0x49, 0xBA, 0xCC, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 0xCD, 
	0x49, 0xBB, 0xCD, 0x45, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x45, 0xAF, 0xC4, 0x4A, 
	0xBC, 0xCE, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC4, 0x45, 0xB5, 0xC9, 0x4C, 0xC0, 0xCF, 0x45, 0xB2, 
	0xC6, 0x46, 0xAF, 0xC4, 0x4A, 0xBE, 0xCF, 0x40, 0xA3, 0xBE, 0x43, 0xA7, 0xBB, 0x0C, 0x0E, 0x11, 
	0x23, 0x3D, 0x47, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 
	0x35, 0x38, 0x28, 0x4C, 0x55, 0x1D, 0x40, 0x42, 0x2A, 0x4A, 0x51, 0x1E, 0x3C, 0x45, 0x1C, 0x40, 
	0x3F, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x44, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1E, 0x2F, 0x39, 0x13, 0x25, 0x25, 0x1D, 0x32, 0x3B, 0x18, 0x3E, 0x44, 0x3C, 0x3B, 
	0x33, 0x57, 0x4B, 0x3F, 0x30, 0x3F, 0x44, 0x1A, 0x2E, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2A, 0x2F, 0x18, 
	0x2A, 0x2F, 0x1B, 0x2E, 0x34, 0x1E, 0x30, 0x39, 0x13, 0x26, 0x25, 0x1C, 0x30, 0x39, 0x28, 0x33, 
	0x35, 0x1A, 0x2C, 0x34, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 
	0x30, 0x39, 0x1D, 0x37, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x1E, 0x43, 
	0x43, 0x2A, 0x4E, 0x59, 0x1B, 0x3F, 0x3D, 0x1B, 0x3D, 0x3F, 0x27, 0x39, 0x3B, 0x34, 0x57, 0x56, 
	0x1B, 0x42, 0x44, 0x1A, 0x3E, 0x3E, 0x37, 0x3A, 0x34, 0x12, 0x40, 0x48, 0x1A, 0x2A, 0x33, 0x3A, 
	0x75, 0x81, 0x3B, 0x9D, 0xB6, 0x47, 0xB3, 0xC5, 0x4B, 0xC3, 0xD2, 0x4B, 0xC0, 0xCF, 0x48, 0xB5, 
	0xC6, 0x48, 0xB5, 0xC6, 0x4B, 0xC0, 0xCF, 0x4B, 0xBC, 0xCB, 0x4B, 0xC0, 0xCF, 0x4A, 0xBC, 0xCB, 
	0x4A, 0xBB, 0xCA, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4A, 0xBF, 0xCF, 0x4B, 
	0xC0, 0xCF, 0x4A, 0xC3, 0xD3, 0x4B, 0xC0, 0xCF, 0x4B, 0xC0, 0xCF, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 
	0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 0xD2, 0x4A, 0xBD, 0xCC, 0x4A, 0xBD, 0xCC, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4A, 0xC4, 0xD3, 0x4F, 0xC5, 0xD9, 
	0x4D, 0xC4, 0xD5, 0x49, 0xC4, 0xD3, 0x4D, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4C, 
	0xC3, 0xD5, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4D, 0xC4, 0xD5, 0x49, 0xC3, 0xD3, 0x4A, 0xC4, 
	0xD3, 0x4A, 0xC5, 0xD4, 0x4B, 0xC3, 0xD1, 0x3A, 0x98, 0xB2, 0x3B, 0x94, 0xA4, 0x06, 0x08, 0x03, 
	0x28, 0x48, 0x4E, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4B, 0x54, 0x27, 0x4A, 0x53, 0x1C, 0x42, 0x42, 0x35, 0x3E, 0x3D, 0x20, 0x3F, 0x3D, 0x1C, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3F, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x3E, 0x43, 0x1C, 0x42, 0x3F, 0x1D, 0x3A, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x3D, 0x44, 0x1D, 0x3B, 0x42, 0x1D, 0x2C, 0x36, 0x1B, 0x3C, 0x44, 0x25, 0x33, 
	0x36, 0x53, 0x48, 0x3D, 0x4D, 0x42, 0x36, 0x1A, 0x28, 0x28, 0x18, 0x2A, 0x30, 0x1A, 0x2C, 0x32, 
	0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 
	0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x2F, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x43, 0x1D, 0x2A, 0x34, 0x1D, 0x38, 0x3F, 0x1D, 
	0x3D, 0x42, 0x1D, 0x44, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x40, 0x3E, 0x20, 0x45, 0x46, 0x1C, 0x33, 
	0x3E, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 0x3F, 0x3E, 0x25, 0x43, 0x46, 0x32, 0x50, 0x4F, 
	0x2B, 0x40, 0x44, 0x48, 0x4C, 0x4D, 0x4D, 0x3D, 0x34, 0x1D, 0x34, 0x3D, 0x14, 0x29, 0x2F, 0x3A, 
	0x75, 0x82, 0x3B, 0x9C, 0xB5, 0x49, 0xBB, 0xCC, 0x4A, 0xBF, 0xCF, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xB9, 0xC9, 
	0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x49, 0xBE, 0xD0, 0x46, 0xB5, 0xCB, 0x4B, 0xC6, 0xD5, 0x4A, 
	0xC4, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC4, 0xD4, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x4A, 0xC4, 0xD2, 0x52, 0xBE, 0xD9, 
	0x48, 0xBE, 0xD0, 0x4C, 0xC3, 0xD4, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4C, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 
	0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC3, 0xD1, 0x34, 0x8C, 0xA6, 0x3B, 0x95, 0xA4, 0x0E, 0x11, 0x14, 
	0x1C, 0x44, 0x4D, 0x28, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1B, 0x40, 0x40, 0x2A, 0x4D, 0x59, 0x1B, 0x3F, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3E, 0x43, 0x1C, 0x29, 0x34, 0x20, 0x45, 0x49, 0x1C, 0x43, 0x40, 0x1E, 0x30, 0x39, 0x1D, 
	0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x16, 0x2B, 
	0x37, 0x4C, 0x42, 0x36, 0x5C, 0x51, 0x4B, 0x2A, 0x3E, 0x3F, 0x0E, 0x22, 0x20, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2F, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1A, 0x2A, 0x30, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x1D, 
	0x3B, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x1C, 0x47, 0x4C, 0x25, 0x47, 0x4C, 0x1C, 0x40, 
	0x3E, 0x1C, 0x3F, 0x3E, 0x22, 0x45, 0x4A, 0x20, 0x46, 0x4B, 0x19, 0x3A, 0x3C, 0x26, 0x48, 0x50, 
	0x38, 0x40, 0x3E, 0x2B, 0x51, 0x51, 0x45, 0x47, 0x44, 0x32, 0x31, 0x29, 0x1F, 0x1E, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 
	0x4A, 0xC5, 0xD4, 0x49, 0xC0, 0xD4, 0x37, 0x82, 0x93, 0x31, 0x69, 0x78, 0x46, 0xB8, 0xD0, 0x4B, 
	0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 
	0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x50, 0xC5, 0xD7, 0x4D, 0xB8, 0xD0, 0x00, 0x00, 0x00, 
	0x3B, 0x9C, 0xB1, 0x59, 0xCD, 0xE4, 0x48, 0xC5, 0xD4, 0x4F, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB1, 0x42, 0xA1, 0xB7, 0x06, 0x08, 0x03, 
	0x28, 0x42, 0x48, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x1B, 0x3B, 
	0x3D, 0x1D, 0x40, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2E, 0x37, 0x1E, 0x3E, 0x42, 0x0F, 0x39, 0x43, 0x1B, 
	0x31, 0x39, 0x1B, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x12, 0x35, 
	0x3F, 0x3C, 0x36, 0x2A, 0x4F, 0x44, 0x39, 0x3F, 0x42, 0x44, 0x1B, 0x31, 0x36, 0x19, 0x2E, 0x35, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3D, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1A, 0x32, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1C, 0x3A, 0x3E, 0x1D, 0x39, 0x3D, 0x1D, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 
	0x3F, 0x1E, 0x42, 0x44, 0x28, 0x4E, 0x56, 0x3D, 0x4C, 0x4B, 0x22, 0x43, 0x45, 0x16, 0x48, 0x4F, 
	0x23, 0x48, 0x4F, 0x20, 0x48, 0x50, 0x23, 0x4D, 0x57, 0x25, 0x39, 0x40, 0x14, 0x28, 0x2E, 0x3A, 
	0x75, 0x82, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC6, 0xD5, 
	0x4F, 0xC0, 0xD7, 0x36, 0x6E, 0x7B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x2C, 0x52, 0x58, 0x46, 
	0xB9, 0xD0, 0x4B, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xBA, 0xCA, 
	0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 0x4A, 0xBC, 0xCC, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 
	0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC3, 0xD2, 0x4B, 0xC2, 0xD4, 0x2F, 0x76, 0x82, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x24, 0x51, 0x5B, 0x4F, 0xBF, 0xD5, 0x50, 0xC8, 0xD9, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x54, 0xC2, 0xDC, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3E, 0x9B, 0xAE, 0x07, 0x09, 0x04, 
	0x24, 0x45, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x53, 0x1F, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x2A, 0x4D, 
	0x58, 0x1A, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x38, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x43, 0x1D, 0x2B, 0x35, 0x18, 0x34, 0x3C, 0x1B, 
	0x31, 0x39, 0x11, 0x3B, 0x44, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 
	0x36, 0x25, 0x34, 0x38, 0x4D, 0x40, 0x37, 0x4D, 0x40, 0x36, 0x31, 0x3B, 0x36, 0x2B, 0x2E, 0x30, 
	0x1D, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x39, 0x1A, 0x2B, 0x31, 0x1D, 0x36, 0x3F, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3D, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1C, 
	0x3A, 0x3E, 0x28, 0x4B, 0x52, 0x1B, 0x4C, 0x56, 0x1C, 0x47, 0x4B, 0x20, 0x44, 0x46, 0x1B, 0x3E, 
	0x3D, 0x20, 0x45, 0x49, 0x29, 0x45, 0x4A, 0x49, 0x3E, 0x39, 0x2E, 0x3B, 0x39, 0x39, 0x50, 0x53, 
	0x28, 0x48, 0x4B, 0x37, 0x35, 0x2A, 0x36, 0x43, 0x45, 0x1A, 0x46, 0x4C, 0x19, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC4, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC8, 0xD7, 0x4C, 0xB5, 0xCE, 
	0x0B, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x07, 0x04, 0x04, 0x06, 0x03, 0x03, 0x03, 0x04, 0x00, 0x42, 
	0x98, 0xAB, 0x49, 0xC0, 0xD2, 0x4A, 0xC3, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBD, 0xCD, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD4, 0x51, 0xC7, 0xDC, 0x40, 0xA7, 0xBB, 0x02, 0x03, 0x02, 0x07, 0x03, 0x03, 
	0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x0E, 0x29, 0x2E, 0x4B, 0xB2, 0xC9, 0x4B, 0xC6, 0xD6, 0x4C, 
	0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4D, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD0, 0x3A, 0x98, 0xB2, 0x3B, 0x95, 0xA5, 0x07, 0x09, 0x06, 
	0x24, 0x44, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1B, 0x3E, 0x3D, 0x23, 0x46, 
	0x4B, 0x1B, 0x3F, 0x3D, 0x1B, 0x3B, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x40, 0x40, 0x1D, 0x2F, 0x38, 0x1B, 0x31, 0x39, 0x1E, 
	0x2F, 0x37, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3D, 
	0x43, 0x15, 0x3B, 0x44, 0x50, 0x42, 0x37, 0x52, 0x49, 0x3E, 0x34, 0x3A, 0x33, 0x27, 0x31, 0x31, 
	0x18, 0x32, 0x3B, 0x1E, 0x30, 0x39, 0x14, 0x27, 0x28, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x18, 
	0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x3A, 
	0x43, 0x1D, 0x31, 0x39, 0x1D, 0x2C, 0x36, 0x1D, 0x43, 0x43, 0x1A, 0x2E, 0x38, 0x1D, 0x38, 0x42, 
	0x1D, 0x3D, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 
	0x36, 0x40, 0x1B, 0x3C, 0x3D, 0x24, 0x46, 0x4B, 0x1C, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4B, 0x27, 0x4B, 0x55, 0x27, 0x46, 0x4B, 0x4F, 0x3F, 0x35, 0x4D, 0x3E, 0x34, 0x3E, 0x3A, 0x36, 
	0x54, 0x53, 0x4F, 0x46, 0x3A, 0x39, 0x45, 0x48, 0x48, 0x3C, 0x50, 0x51, 0x1E, 0x1B, 0x1D, 0x3A, 
	0x76, 0x83, 0x3B, 0x9C, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC7, 0xD6, 0x4C, 0xB5, 0xCE, 0x0C, 0x0D, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x0F, 
	0x25, 0x27, 0x50, 0xBE, 0xD5, 0x4A, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC5, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 0xC2, 0xD7, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x4B, 0xC3, 0xD4, 0x4E, 0xC4, 0xD8, 0x30, 0x6C, 0x79, 0x02, 0x03, 0x00, 0x07, 0x06, 0x06, 
	0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x07, 0x00, 0x00, 0x00, 0x13, 0x22, 0x23, 0x47, 0xB1, 0xC8, 0x54, 
	0xC6, 0xDF, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4F, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x09, 0x06, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x43, 0x1A, 0x3D, 
	0x3C, 0x23, 0x46, 0x4B, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1B, 
	0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 
	0x39, 0x19, 0x2C, 0x37, 0x3D, 0x37, 0x2A, 0x4D, 0x42, 0x39, 0x36, 0x35, 0x2F, 0x38, 0x2E, 0x27, 
	0x18, 0x32, 0x3C, 0x1B, 0x2B, 0x31, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x1A, 
	0x2C, 0x32, 0x1D, 0x35, 0x3D, 0x1D, 0x38, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 
	0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1A, 0x45, 0x43, 0x3B, 0x35, 0x2B, 0x1A, 0x38, 0x43, 
	0x1D, 0x31, 0x3A, 0x1D, 0x40, 0x40, 0x1A, 0x39, 0x40, 0x1D, 0x39, 0x40, 0x1D, 0x44, 0x40, 0x1D, 
	0x35, 0x40, 0x1D, 0x43, 0x40, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4A, 0x28, 0x4B, 0x54, 0x29, 0x46, 0x4B, 0x44, 0x3B, 0x30, 0x50, 0x52, 0x53, 0x20, 0x19, 0x15, 
	0x4F, 0x49, 0x3E, 0x50, 0x45, 0x3D, 0x47, 0x4B, 0x49, 0x2E, 0x5A, 0x5C, 0x15, 0x28, 0x32, 0x3B, 
	0x76, 0x82, 0x3B, 0x9D, 0xB6, 0x46, 0xAE, 0xC3, 0x4A, 0xBB, 0xCB, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 
	0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC5, 0xD4, 0x4E, 0xBB, 0xD1, 0x0B, 0x0B, 0x08, 0x00, 0x00, 0x00, 
	0x0C, 0x0F, 0x0F, 0x0B, 0x0E, 0x0E, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x08, 0x09, 0x09, 0x00, 
	0x00, 0x00, 0x2F, 0x68, 0x76, 0x4B, 0xC3, 0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC1, 
	0xD5, 0x54, 0xCC, 0xE0, 0x3A, 0x8C, 0x9C, 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x07, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x12, 0x18, 0x15, 0x4A, 
	0xB5, 0xCB, 0x51, 0xC6, 0xDC, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xDC, 0x51, 0xC2, 
	0xD3, 0x47, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x0D, 0x02, 0x00, 
	0x29, 0x4A, 0x4E, 0x2E, 0x50, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x19, 0x43, 0x45, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x23, 0x46, 
	0x4A, 0x29, 0x4C, 0x56, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1D, 0x2E, 0x36, 0x1B, 0x33, 0x3C, 0x53, 0x44, 0x39, 0x37, 0x32, 0x2F, 0x2B, 0x2F, 0x2B, 
	0x16, 0x32, 0x3D, 0x15, 0x39, 0x43, 0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x3F, 0x43, 0x1A, 0x31, 0x3B, 0x1D, 0x39, 0x42, 
	0x1D, 0x31, 0x3A, 0x1A, 0x3C, 0x40, 0x38, 0x44, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x36, 0x40, 0x1D, 
	0x44, 0x40, 0x1D, 0x37, 0x40, 0x1C, 0x40, 0x3E, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 0x3E, 0x24, 0x46, 
	0x4A, 0x18, 0x4B, 0x55, 0x1C, 0x46, 0x4C, 0x45, 0x3B, 0x31, 0x90, 0x89, 0x82, 0x54, 0x4E, 0x42, 
	0x43, 0x3B, 0x33, 0x4F, 0x46, 0x3C, 0x61, 0x52, 0x48, 0x4E, 0x75, 0x82, 0x1A, 0x1E, 0x22, 0x34, 
	0x70, 0x7B, 0x3B, 0x9D, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 
	0xCB, 0x4A, 0xC5, 0xD5, 0x4B, 0xC5, 0xD8, 0x26, 0x53, 0x5E, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x03, 0x03, 0x06, 0x09, 0x09, 0x43, 0xAB, 0xC0, 0x4C, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x49, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC5, 
	0xD8, 0x55, 0xC1, 0xDA, 0x03, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 
	0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x13, 
	0x18, 0x15, 0x47, 0xB0, 0xC7, 0x51, 0xC5, 0xDA, 0x4B, 0xC2, 0xD4, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 
	0xD1, 0x4F, 0xC2, 0xD7, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x28, 
	0x46, 0x4D, 0x2E, 0x44, 0x47, 0x1A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x29, 0x4B, 0x54, 0x19, 0x3C, 
	0x38, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x42, 0x42, 0x1D, 0x2F, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1E, 0x32, 0x3A, 0x19, 0x2E, 0x38, 0x38, 0x3B, 0x32, 0x38, 0x3A, 0x2F, 0x3B, 0x2F, 0x31, 
	0x29, 0x28, 0x25, 0x13, 0x26, 0x27, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2B, 0x35, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3D, 0x42, 0x1C, 0x3E, 0x3F, 0x1A, 0x35, 0x40, 0x1D, 0x37, 0x40, 0x1D, 0x37, 0x40, 0x1D, 
	0x3B, 0x40, 0x1B, 0x40, 0x3D, 0x23, 0x46, 0x4A, 0x20, 0x43, 0x4B, 0x18, 0x38, 0x3D, 0x23, 0x44, 
	0x46, 0x30, 0x46, 0x49, 0x47, 0x45, 0x3F, 0x28, 0x29, 0x1F, 0x65, 0x62, 0x5D, 0x61, 0x57, 0x4D, 
	0x32, 0x2E, 0x2C, 0x36, 0x36, 0x2C, 0x51, 0x48, 0x3E, 0x5B, 0x52, 0x4A, 0x1F, 0x28, 0x27, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4A, 0xBB, 0xCB, 0x4A, 0xB8, 0xC8, 0x4A, 0xC5, 
	0xD4, 0x4C, 0xC4, 0xD7, 0x2F, 0x74, 0x80, 0x07, 0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x02, 0x00, 0x1D, 0x43, 0x49, 0x47, 0xBA, 0xD1, 0x4B, 0xC0, 0xCF, 0x4A, 0xB6, 
	0xC6, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD6, 0x4F, 0xC3, 
	0xDB, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 
	0x00, 0x00, 0x15, 0x29, 0x2E, 0x4F, 0xBC, 0xD3, 0x4F, 0xC5, 0xD9, 0x4A, 0xC2, 0xD3, 0x4C, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC1, 0xD4, 0x3C, 0x9D, 0xB6, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x43, 0x4A, 0x27, 0x4B, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x49, 0x52, 0x38, 
	0x54, 0x52, 0x2B, 0x44, 0x48, 0x1D, 0x4B, 0x54, 0x1A, 0x4A, 0x53, 0x1E, 0x47, 0x4D, 0x2A, 0x4D, 
	0x57, 0x19, 0x3C, 0x39, 0x1C, 0x3F, 0x3F, 0x20, 0x44, 0x46, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3D, 0x42, 0x1D, 0x3F, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1E, 0x2F, 0x37, 0x1B, 0x32, 
	0x3A, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1E, 0x3A, 0x43, 0x38, 0x31, 0x2B, 0x38, 0x2E, 0x30, 
	0x3D, 0x3C, 0x30, 0x19, 0x2F, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x31, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x43, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x36, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x3C, 0x3F, 0x20, 0x44, 0x46, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1C, 0x3A, 0x3F, 0x1C, 
	0x40, 0x3E, 0x23, 0x47, 0x4B, 0x27, 0x4C, 0x57, 0x35, 0x4F, 0x4E, 0x3A, 0x47, 0x47, 0x29, 0x39, 
	0x35, 0x51, 0x42, 0x37, 0x47, 0x3F, 0x38, 0x34, 0x30, 0x2B, 0x69, 0x5F, 0x4F, 0x6F, 0x69, 0x58, 
	0x6A, 0x62, 0x54, 0x45, 0x3E, 0x37, 0x48, 0x3C, 0x34, 0x58, 0x4D, 0x43, 0x1F, 0x29, 0x28, 0x39, 
	0x75, 0x82, 0x3B, 0x9D, 0xB6, 0x45, 0xAB, 0xC0, 0x4A, 0xC5, 0xD5, 0x4A, 0xBA, 0xCA, 0x4C, 0xC8, 
	0xD8, 0x42, 0x9A, 0xAE, 0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x00, 0x00, 0x00, 0x42, 0x9B, 0xAE, 0x49, 0xC0, 0xD3, 0x4A, 0xC4, 
	0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x4A, 0xC0, 0xD0, 0x4A, 0xBC, 0xCC, 
	0x4A, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC6, 0xDA, 0x48, 0xB2, 
	0xC5, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x00, 0x00, 0x00, 0x25, 0x52, 0x5C, 0x52, 0xC6, 0xDE, 0x55, 0xC3, 0xDA, 0x47, 0xC2, 
	0xD0, 0x4F, 0xC2, 0xD6, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3B, 0x95, 0xA5, 0x0D, 0x00, 0x00, 
	0x29, 0x57, 0x5A, 0x26, 0x48, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x25, 0x4A, 0x54, 0x31, 
	0x3B, 0x39, 0x2E, 0x40, 0x43, 0x2C, 0x44, 0x47, 0x2B, 0x48, 0x4F, 0x1E, 0x42, 0x43, 0x20, 0x44, 
	0x47, 0x29, 0x4C, 0x57, 0x1A, 0x3D, 0x3A, 0x25, 0x48, 0x4D, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2A, 0x34, 0x18, 0x32, 0x3B, 0x1E, 0x3A, 0x43, 0x1D, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x1E, 0x30, 
	0x38, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x38, 0x13, 0x35, 0x3F, 0x33, 0x2B, 0x22, 0x39, 0x30, 0x31, 
	0x34, 0x2E, 0x29, 0x23, 0x2F, 0x2F, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x3B, 0x45, 0x1A, 
	0x29, 0x30, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x2E, 0x38, 0x22, 0x49, 0x4D, 0x37, 0x3F, 0x3D, 0x20, 0x46, 0x4B, 0x20, 0x44, 0x46, 0x1A, 
	0x3F, 0x3E, 0x23, 0x43, 0x45, 0x13, 0x38, 0x3B, 0x42, 0x3C, 0x34, 0x50, 0x40, 0x3D, 0x3E, 0x39, 
	0x30, 0x54, 0x4B, 0x43, 0x78, 0x73, 0x6E, 0x4E, 0x45, 0x3C, 0x68, 0x5F, 0x4F, 0x61, 0x5F, 0x5F, 
	0x73, 0x6A, 0x59, 0x62, 0x58, 0x4E, 0x40, 0x46, 0x44, 0x4E, 0x45, 0x39, 0x1A, 0x1D, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC1, 0xD0, 0x4A, 0xB9, 0xC9, 0x4A, 0xC6, 0xD5, 0x51, 0xBF, 
	0xD6, 0x03, 0x04, 0x03, 0x02, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x13, 0x25, 0x27, 0x4A, 0xB9, 0xCE, 0x4B, 0xC0, 
	0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x55, 0xCB, 0xE2, 0x29, 0x56, 
	0x60, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x07, 0x08, 0x08, 0x00, 0x00, 0x00, 0x36, 0x86, 0x92, 0x51, 0xCA, 0xDF, 0x4E, 0xC2, 
	0xD3, 0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x39, 0x96, 0xB0, 0x3C, 0x96, 0xA6, 0x06, 0x0B, 0x07, 
	0x26, 0x45, 0x4D, 0x26, 0x49, 0x53, 0x33, 0x55, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4C, 0x52, 0x23, 
	0x49, 0x54, 0x29, 0x50, 0x54, 0x25, 0x4A, 0x54, 0x2A, 0x48, 0x4E, 0x1A, 0x3D, 0x3B, 0x28, 0x4B, 
	0x55, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3E, 0x3C, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1E, 
	0x3D, 0x42, 0x11, 0x38, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x3F, 0x42, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x39, 0x30, 0x2B, 0x38, 0x2F, 0x30, 
	0x39, 0x3B, 0x31, 0x3B, 0x3A, 0x31, 0x1C, 0x30, 0x38, 0x16, 0x2E, 0x33, 0x1E, 0x2C, 0x35, 0x1D, 
	0x3E, 0x44, 0x1D, 0x39, 0x43, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x34, 0x3D, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x19, 0x3C, 0x3D, 0x2A, 0x4E, 0x59, 0x19, 0x3E, 0x3D, 0x25, 
	0x3E, 0x3E, 0x4C, 0x4E, 0x4D, 0x2E, 0x3F, 0x3F, 0x52, 0x3F, 0x37, 0x38, 0x37, 0x2E, 0x4D, 0x3F, 
	0x36, 0x51, 0x4A, 0x3D, 0x84, 0x7C, 0x74, 0x4F, 0x47, 0x3F, 0x54, 0x4C, 0x44, 0x4E, 0x45, 0x3F, 
	0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4B, 0x5C, 0x52, 0x4A, 0x47, 0x43, 0x37, 0x1B, 0x1E, 0x24, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC4, 0xD4, 0x4A, 0xC0, 0xD3, 0x2F, 0x75, 
	0x81, 0x02, 0x00, 0x00, 0x07, 0x06, 0x06, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x00, 0x00, 0x32, 0x66, 0x73, 0x4B, 0xC4, 
	0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x49, 0xBF, 0xCE, 0x4C, 0xC2, 0xD4, 0x54, 0xCC, 0xE0, 0x3A, 0x8B, 0x9B, 0x00, 0x00, 
	0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x08, 0x07, 0x13, 0x1A, 0x1C, 0x4B, 0xB9, 0xD0, 0x51, 0xC5, 
	0xDB, 0x54, 0xC2, 0xDC, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x31, 0x54, 0x52, 0x35, 
	0x52, 0x51, 0x48, 0x49, 0x48, 0x29, 0x4A, 0x4E, 0x27, 0x4B, 0x56, 0x1A, 0x42, 0x43, 0x28, 0x4A, 
	0x53, 0x27, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1A, 0x3D, 0x3B, 0x1C, 0x40, 0x3F, 0x1E, 0x40, 0x3E, 
	0x1D, 0x49, 0x4D, 0x1D, 0x39, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 
	0x3C, 0x40, 0x1E, 0x36, 0x40, 0x1F, 0x3E, 0x40, 0x1D, 0x38, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x12, 0x35, 0x3E, 0x3C, 0x2F, 0x2F, 0x33, 0x30, 0x2A, 
	0x2E, 0x2F, 0x25, 0x2F, 0x2F, 0x26, 0x20, 0x2E, 0x32, 0x12, 0x3C, 0x44, 0x15, 0x36, 0x3E, 0x1B, 
	0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x1A, 0x37, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3C, 0x3D, 0x1B, 0x40, 0x3D, 0x1F, 0x40, 0x40, 0x32, 
	0x42, 0x43, 0x20, 0x3F, 0x40, 0x22, 0x3D, 0x3E, 0x33, 0x57, 0x58, 0x32, 0x37, 0x31, 0x30, 0x44, 
	0x49, 0x4E, 0x40, 0x39, 0x56, 0x4C, 0x3D, 0x51, 0x49, 0x3E, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3A, 
	0x4B, 0x42, 0x3F, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4A, 0x48, 0x3A, 0x32, 0x1C, 0x1E, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4D, 0xB8, 0xD0, 0x04, 0x09, 
	0x08, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 
	0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x09, 0x43, 0xAC, 
	0xC1, 0x4B, 0xC5, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC5, 0xD3, 0x55, 0xC1, 0xDB, 0x03, 0x06, 0x04, 0x03, 0x00, 
	0x00, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x2E, 0x63, 0x70, 0x53, 0xC7, 
	0xDF, 0x48, 0xC3, 0xD1, 0x4D, 0xC1, 0xD2, 0x3C, 0x9C, 0xB5, 0x3E, 0x9B, 0xAE, 0x06, 0x08, 0x06, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x52, 0x33, 0x55, 0x52, 0x2B, 0x48, 0x4D, 0x28, 
	0x43, 0x48, 0x40, 0x47, 0x46, 0x29, 0x44, 0x49, 0x28, 0x40, 0x42, 0x19, 0x3D, 0x3B, 0x27, 0x4D, 
	0x57, 0x1C, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x2C, 0x4F, 0x57, 0x1A, 0x3F, 0x44, 0x0D, 0x34, 0x3F, 
	0x18, 0x3A, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 
	0x35, 0x40, 0x1F, 0x40, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 
	0x36, 0x1D, 0x3B, 0x44, 0x1B, 0x2C, 0x37, 0x1F, 0x33, 0x3B, 0x3A, 0x31, 0x2E, 0x39, 0x2F, 0x31, 
	0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x3D, 0x31, 0x2E, 0x23, 0x42, 0x3D, 0x0F, 0x38, 0x42, 0x18, 
	0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x48, 
	0x44, 0x1B, 0x2E, 0x38, 0x19, 0x2B, 0x36, 0x27, 0x3E, 0x43, 0x0E, 0x38, 0x3F, 0x0F, 0x34, 0x3E, 
	0x1E, 0x42, 0x40, 0x1C, 0x3C, 0x3D, 0x2B, 0x50, 0x5A, 0x18, 0x33, 0x3E, 0x2E, 0x40, 0x3E, 0x38, 
	0x35, 0x2A, 0x36, 0x38, 0x31, 0x3F, 0x45, 0x44, 0x25, 0x45, 0x4C, 0x34, 0x50, 0x50, 0x20, 0x40, 
	0x44, 0x3E, 0x40, 0x42, 0x3B, 0x3E, 0x3B, 0x4C, 0x42, 0x42, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 
	0x50, 0x48, 0x3D, 0x5C, 0x53, 0x4B, 0x5F, 0x56, 0x4F, 0x24, 0x43, 0x47, 0x16, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD1, 0x4A, 0xC2, 0xD4, 0x39, 0x8A, 0x97, 0x00, 0x00, 
	0x00, 0x03, 0x02, 0x02, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0F, 0x0F, 
	0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x15, 0x35, 
	0x38, 0x4E, 0xBF, 0xD9, 0x4D, 0xC5, 0xD6, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x4E, 0xC3, 0xD6, 0x50, 0xC3, 0xDC, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 
	0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x07, 0x06, 0x07, 0x02, 0x43, 0xA1, 
	0xB2, 0x4D, 0xC7, 0xD9, 0x50, 0xC5, 0xD8, 0x39, 0x96, 0xAF, 0x3E, 0x9B, 0xAF, 0x06, 0x09, 0x06, 
	0x26, 0x45, 0x4C, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x1F, 0x4A, 0x53, 0x29, 
	0x46, 0x4D, 0x35, 0x52, 0x50, 0x28, 0x4E, 0x53, 0x3E, 0x4F, 0x4E, 0x1E, 0x46, 0x4B, 0x33, 0x3D, 
	0x3C, 0x2B, 0x43, 0x46, 0x20, 0x46, 0x4B, 0x33, 0x51, 0x4F, 0x39, 0x50, 0x4F, 0x32, 0x3C, 0x38, 
	0x14, 0x44, 0x4F, 0x1D, 0x3A, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 0x40, 0x1E, 
	0x36, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x31, 
	0x39, 0x18, 0x30, 0x39, 0x2E, 0x34, 0x32, 0x2C, 0x43, 0x40, 0x39, 0x39, 0x2E, 0x36, 0x37, 0x2E, 
	0x2C, 0x2E, 0x24, 0x37, 0x2F, 0x2F, 0x33, 0x2E, 0x29, 0x3B, 0x39, 0x33, 0x15, 0x30, 0x3B, 0x18, 
	0x36, 0x3F, 0x1A, 0x43, 0x42, 0x1D, 0x35, 0x3E, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 
	0x35, 0x35, 0x45, 0x43, 0x33, 0x3F, 0x3C, 0x42, 0x44, 0x3D, 0x45, 0x4C, 0x4C, 0x1B, 0x4D, 0x55, 
	0x12, 0x3A, 0x40, 0x16, 0x3E, 0x42, 0x15, 0x3F, 0x3F, 0x22, 0x43, 0x44, 0x37, 0x34, 0x29, 0x50, 
	0x44, 0x3B, 0x36, 0x36, 0x2E, 0x35, 0x35, 0x2B, 0x38, 0x34, 0x28, 0x40, 0x4C, 0x4B, 0x3A, 0x4D, 
	0x4E, 0x32, 0x38, 0x37, 0x2B, 0x23, 0x1B, 0x46, 0x3E, 0x35, 0x4F, 0x47, 0x3C, 0x5D, 0x55, 0x4D, 
	0x52, 0x4A, 0x42, 0x62, 0x57, 0x4D, 0x3E, 0x57, 0x58, 0x2C, 0x50, 0x52, 0x1B, 0x22, 0x28, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4C, 0xB6, 0xCE, 0x03, 0x07, 0x06, 0x07, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0E, 0x0E, 0x0B, 0x09, 0x09, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x08, 0x08, 0x00, 0x00, 
	0x00, 0x3B, 0x8E, 0x9E, 0x4A, 0xC3, 0xD4, 0x4A, 0xC3, 0xD2, 0x49, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 
	0x54, 0xC2, 0xDC, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x52, 0xC6, 0xDB, 0x48, 0xB2, 0xC6, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00, 0x04, 0x04, 
	0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x02, 0x00, 0x2A, 0x67, 
	0x74, 0x56, 0xC8, 0xDF, 0x4F, 0xC1, 0xD4, 0x3F, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x2B, 0x58, 0x5F, 0x2C, 0x4E, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x1B, 
	0x49, 0x52, 0x32, 0x54, 0x52, 0x31, 0x53, 0x52, 0x30, 0x53, 0x53, 0x1D, 0x47, 0x4F, 0x33, 0x3F, 
	0x3E, 0x18, 0x3E, 0x3D, 0x19, 0x3F, 0x3E, 0x1C, 0x3E, 0x44, 0x22, 0x3F, 0x46, 0x38, 0x3C, 0x38, 
	0x1A, 0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x34, 0x40, 0x1E, 
	0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1E, 0x2B, 0x35, 0x19, 0x31, 
	0x39, 0x1E, 0x38, 0x3F, 0x39, 0x2E, 0x2A, 0x39, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x36, 0x34, 0x2E, 
	0x39, 0x3A, 0x31, 0x38, 0x30, 0x30, 0x31, 0x2F, 0x28, 0x3A, 0x35, 0x32, 0x34, 0x2F, 0x25, 0x33, 
	0x2C, 0x2C, 0x15, 0x35, 0x42, 0x1E, 0x3E, 0x40, 0x1E, 0x43, 0x42, 0x1D, 0x30, 0x39, 0x1A, 0x2F, 
	0x38, 0x1F, 0x42, 0x43, 0x36, 0x3B, 0x3A, 0x2F, 0x24, 0x1C, 0x35, 0x35, 0x2A, 0x3B, 0x37, 0x2B, 
	0x3C, 0x37, 0x2C, 0x33, 0x3C, 0x39, 0x4B, 0x3D, 0x34, 0x4E, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x33, 0x35, 0x2C, 0x4F, 0x43, 0x3A, 0x39, 0x38, 0x2F, 0x38, 0x39, 0x35, 0x5E, 0x59, 
	0x55, 0x6C, 0x61, 0x54, 0x31, 0x2C, 0x27, 0x3F, 0x3B, 0x38, 0x4E, 0x46, 0x42, 0x51, 0x49, 0x3E, 
	0x51, 0x49, 0x3F, 0x4E, 0x44, 0x3B, 0x2B, 0x40, 0x42, 0x2E, 0x40, 0x3F, 0x1A, 0x25, 0x2B, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4D, 0xC5, 0xD4, 0x3D, 0x9B, 0xA9, 0x03, 0x03, 0x00, 0x03, 0x02, 
	0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x09, 0x08, 
	0x08, 0x0C, 0x0F, 0x0D, 0x47, 0xAB, 0xC2, 0x4D, 0xC7, 0xD9, 0x4C, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4E, 
	0xC3, 0xD4, 0x51, 0xC3, 0xDB, 0x26, 0x4D, 0x53, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x0B, 0x09, 0x0D, 0x0E, 
	0x0F, 0x4E, 0xB7, 0xCD, 0x50, 0xC6, 0xDA, 0x3F, 0xA1, 0xBB, 0x3B, 0x95, 0xA5, 0x04, 0x09, 0x06, 
	0x28, 0x53, 0x57, 0x2C, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2E, 0x4F, 0x52, 0x19, 
	0x49, 0x52, 0x29, 0x4B, 0x52, 0x2A, 0x4D, 0x52, 0x32, 0x54, 0x52, 0x25, 0x4A, 0x54, 0x33, 0x3C, 
	0x39, 0x26, 0x4D, 0x58, 0x34, 0x3D, 0x3B, 0x26, 0x48, 0x4D, 0x19, 0x3B, 0x3D, 0x1D, 0x48, 0x4D, 
	0x24, 0x46, 0x4B, 0x1C, 0x40, 0x3E, 0x1D, 0x3A, 0x40, 0x1D, 0x3A, 0x40, 0x1E, 0x43, 0x40, 0x1C, 
	0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1F, 0x44, 0x40, 0x1D, 0x38, 0x3E, 0x15, 0x34, 
	0x3E, 0x3E, 0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x30, 0x2E, 0x30, 0x2E, 0x27, 
	0x39, 0x37, 0x31, 0x39, 0x3A, 0x31, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x3A, 
	0x37, 0x30, 0x33, 0x2F, 0x2B, 0x0F, 0x36, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x3A, 0x2F, 0x46, 
	0x44, 0x13, 0x2E, 0x3B, 0x39, 0x31, 0x2A, 0x36, 0x32, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x2C, 0x30, 
	0x34, 0x30, 0x2B, 0x3D, 0x3A, 0x31, 0x4E, 0x43, 0x3A, 0x4B, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x31, 
	0x34, 0x2B, 0x3A, 0x39, 0x31, 0x4B, 0x40, 0x38, 0x4A, 0x3F, 0x37, 0x54, 0x49, 0x3F, 0x6C, 0x77, 
	0x7A, 0x75, 0x6A, 0x5D, 0x48, 0x43, 0x38, 0x44, 0x3C, 0x33, 0x4E, 0x46, 0x43, 0x52, 0x4A, 0x3F, 
	0x5B, 0x53, 0x4B, 0x4D, 0x45, 0x40, 0x51, 0x45, 0x3D, 0x54, 0x46, 0x3D, 0x1A, 0x1D, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD6, 0x33, 0x72, 0x83, 0x02, 0x02, 0x00, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 0x09, 
	0x09, 0x04, 0x07, 0x06, 0x28, 0x56, 0x60, 0x4F, 0xC5, 0xD9, 0x4F, 0xC3, 0xD7, 0x48, 0xC2, 0xD1, 
	0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 
	0xC6, 0xDB, 0x3F, 0x9D, 0xAA, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x03, 0x06, 
	0x03, 0x37, 0x86, 0x98, 0x4D, 0xCD, 0xDB, 0x3D, 0x9C, 0xB5, 0x3B, 0x96, 0xA6, 0x0D, 0x00, 0x00, 
	0x2B, 0x57, 0x5E, 0x2B, 0x4D, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4E, 0x52, 0x18, 
	0x49, 0x52, 0x29, 0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4B, 
	0x54, 0x26, 0x4A, 0x52, 0x28, 0x4A, 0x51, 0x33, 0x3D, 0x3C, 0x2E, 0x40, 0x40, 0x19, 0x3E, 0x3C, 
	0x1C, 0x46, 0x4B, 0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3C, 0x3E, 0x22, 
	0x48, 0x4D, 0x1C, 0x39, 0x3E, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3E, 0x42, 0x22, 0x33, 
	0x38, 0x37, 0x2F, 0x2B, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2E, 0x2F, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x27, 0x34, 0x31, 0x2B, 0x38, 
	0x39, 0x30, 0x3A, 0x39, 0x2F, 0x28, 0x2B, 0x2F, 0x16, 0x43, 0x4B, 0x16, 0x45, 0x4A, 0x37, 0x3A, 
	0x38, 0x3C, 0x37, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 0x36, 0x38, 0x2F, 0x38, 0x3A, 0x30, 
	0x38, 0x2C, 0x30, 0x37, 0x38, 0x2F, 0x34, 0x36, 0x2E, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x4D, 
	0x42, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x46, 0x3C, 0x34, 0x5A, 0x51, 0x48, 0x6F, 0x7C, 
	0x79, 0x5D, 0x56, 0x50, 0x40, 0x39, 0x37, 0x4A, 0x3F, 0x36, 0x4C, 0x43, 0x39, 0x4D, 0x45, 0x3A, 
	0x53, 0x4B, 0x42, 0x4A, 0x42, 0x38, 0x51, 0x49, 0x3F, 0x4E, 0x47, 0x3B, 0x1A, 0x1E, 0x23, 0x39, 
	0x75, 0x81, 0x3E, 0xA4, 0xBB, 0x49, 0xC0, 0xD5, 0x2B, 0x57, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 
	0x07, 0x07, 0x04, 0x03, 0x00, 0x02, 0x00, 0x37, 0x89, 0x99, 0x50, 0xC3, 0xD6, 0x4E, 0xC2, 0xD4, 
	0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD0, 0x4A, 
	0xC2, 0xD4, 0x53, 0xC7, 0xDF, 0x31, 0x5D, 0x66, 0x00, 0x00, 0x00, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x03, 0x02, 
	0x00, 0x2A, 0x54, 0x5B, 0x4A, 0xC0, 0xD5, 0x3D, 0x9E, 0xB7, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x28, 0x52, 0x57, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x2B, 
	0x4C, 0x52, 0x18, 0x49, 0x52, 0x27, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x26, 0x4B, 0x55, 0x1C, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x34, 0x3E, 0x3C, 0x29, 0x47, 0x4C, 
	0x1B, 0x4A, 0x52, 0x1D, 0x3F, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3B, 0x40, 0x36, 
	0x40, 0x3F, 0x1B, 0x42, 0x40, 0x1E, 0x43, 0x40, 0x1C, 0x37, 0x40, 0x1E, 0x35, 0x3D, 0x3C, 0x33, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x30, 0x26, 0x38, 0x30, 0x30, 0x30, 0x30, 0x27, 0x2F, 0x28, 0x1F, 0x33, 0x35, 0x2B, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x2F, 0x38, 0x2B, 0x2B, 0x33, 0x29, 0x20, 0x3C, 0x39, 0x2F, 0x30, 0x2C, 
	0x25, 0x36, 0x2F, 0x2E, 0x35, 0x2E, 0x2C, 0x36, 0x38, 0x2F, 0x51, 0x45, 0x3B, 0x35, 0x38, 0x2F, 
	0x39, 0x31, 0x2C, 0x39, 0x37, 0x2C, 0x3D, 0x39, 0x31, 0x48, 0x3F, 0x36, 0x4B, 0x40, 0x38, 0x3D, 
	0x3A, 0x32, 0x4B, 0x40, 0x38, 0x3D, 0x39, 0x31, 0x5B, 0x52, 0x4A, 0x56, 0x4E, 0x43, 0x71, 0x6C, 
	0x5E, 0x5F, 0x57, 0x4F, 0x4A, 0x40, 0x39, 0x4C, 0x44, 0x44, 0x49, 0x3F, 0x35, 0x4C, 0x44, 0x44, 
	0x48, 0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x47, 0x3D, 0x43, 0x39, 0x32, 0x1B, 0x1F, 0x23, 0x39, 
	0x78, 0x87, 0x43, 0xAE, 0xC2, 0x4E, 0xBB, 0xD2, 0x02, 0x02, 0x00, 0x07, 0x08, 0x07, 0x0C, 0x0F, 
	0x0F, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 
	0x0B, 0x00, 0x00, 0x00, 0x15, 0x19, 0x1A, 0x40, 0xA9, 0xB9, 0x52, 0xC5, 0xDD, 0x50, 0xC2, 0xD8, 
	0x51, 0xC4, 0xD7, 0x4F, 0xC6, 0xDC, 0x52, 0xC4, 0xD8, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x53, 
	0xC2, 0xD2, 0x54, 0xC5, 0xDF, 0x4E, 0xBA, 0xD1, 0x11, 0x2B, 0x30, 0x03, 0x00, 0x00, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x04, 
	0x04, 0x06, 0x06, 0x02, 0x4A, 0xB5, 0xC8, 0x40, 0xA5, 0xBF, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x32, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 
	0x49, 0x52, 0x27, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4D, 0x53, 0x2C, 0x44, 
	0x48, 0x34, 0x3C, 0x39, 0x26, 0x4B, 0x55, 0x27, 0x4B, 0x54, 0x20, 0x46, 0x4B, 0x1B, 0x3F, 0x3D, 
	0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x12, 0x36, 0x40, 0x34, 
	0x3C, 0x3A, 0x19, 0x38, 0x40, 0x0F, 0x36, 0x40, 0x22, 0x3A, 0x42, 0x32, 0x34, 0x2E, 0x39, 0x3A, 
	0x30, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x30, 0x30, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x31, 0x2F, 0x28, 0x36, 0x31, 0x2E, 0x38, 
	0x35, 0x2F, 0x31, 0x3F, 0x3C, 0x2E, 0x27, 0x1D, 0x31, 0x2F, 0x28, 0x39, 0x3A, 0x31, 0x35, 0x31, 
	0x2C, 0x38, 0x2E, 0x30, 0x38, 0x3A, 0x2F, 0x37, 0x2E, 0x2E, 0x3C, 0x35, 0x32, 0x39, 0x30, 0x2A, 
	0x2E, 0x47, 0x4B, 0x1D, 0x42, 0x4A, 0x37, 0x3C, 0x36, 0x32, 0x38, 0x32, 0x4C, 0x42, 0x38, 0x4A, 
	0x40, 0x37, 0x4E, 0x44, 0x42, 0x2F, 0x33, 0x29, 0x4C, 0x43, 0x3F, 0x4F, 0x47, 0x3F, 0x55, 0x4C, 
	0x44, 0x55, 0x4D, 0x45, 0x4D, 0x45, 0x3A, 0x4C, 0x44, 0x39, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 
	0x49, 0x3F, 0x37, 0x4C, 0x43, 0x3A, 0x52, 0x4A, 0x3F, 0x42, 0x39, 0x32, 0x1C, 0x1D, 0x22, 0x34, 
	0x8B, 0x9C, 0x43, 0xA8, 0xC3, 0x3A, 0x92, 0xA1, 0x03, 0x04, 0x02, 0x07, 0x04, 0x04, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 
	0x07, 0x0F, 0x16, 0x14, 0x4A, 0xB5, 0xCB, 0x51, 0xC6, 0xDB, 0x4E, 0xC4, 0xD7, 0x51, 0xC4, 0xDA, 
	0x53, 0xBF, 0xD7, 0x3C, 0x9B, 0xA4, 0x53, 0xBF, 0xD8, 0x53, 0xC6, 0xDE, 0x52, 0xC5, 0xD8, 0x4D, 
	0xC2, 0xD6, 0x4D, 0xC2, 0xD2, 0x4C, 0xC7, 0xD9, 0x4F, 0xBD, 0xD2, 0x04, 0x07, 0x06, 0x06, 0x06, 
	0x06, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 
	0x00, 0x07, 0x07, 0x08, 0x45, 0x9E, 0xB1, 0x42, 0xA8, 0xC2, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x29, 0x53, 0x58, 0x2A, 0x4C, 0x52, 0x2E, 0x50, 0x52, 0x31, 0x53, 0x52, 0x28, 0x4B, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x1E, 0x4B, 0x52, 0x1A, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x1F, 0x48, 0x4E, 0x26, 0x4B, 0x54, 0x29, 0x48, 0x4E, 0x1E, 0x46, 0x4A, 0x16, 0x3A, 0x3E, 
	0x1D, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 
	0x3B, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x36, 0x40, 0x26, 0x3C, 0x42, 0x4F, 0x43, 0x37, 0x33, 0x2F, 
	0x2B, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x37, 0x30, 0x2F, 0x2E, 0x2F, 0x25, 
	0x30, 0x31, 0x27, 0x26, 0x1C, 0x1D, 0x33, 0x30, 0x28, 0x3C, 0x34, 0x30, 0x38, 0x30, 0x30, 0x36, 
	0x32, 0x2F, 0x4B, 0x42, 0x37, 0x2E, 0x2C, 0x27, 0x36, 0x2F, 0x2E, 0x36, 0x31, 0x2E, 0x38, 0x3A, 
	0x30, 0x39, 0x32, 0x2E, 0x36, 0x37, 0x33, 0x33, 0x3E, 0x39, 0x39, 0x30, 0x2A, 0x32, 0x40, 0x3E, 
	0x15, 0x42, 0x40, 0x36, 0x40, 0x3F, 0x13, 0x34, 0x42, 0x32, 0x3B, 0x36, 0x48, 0x3E, 0x36, 0x4A, 
	0x3F, 0x37, 0x52, 0x4A, 0x43, 0x4E, 0x44, 0x42, 0x49, 0x3E, 0x35, 0x4E, 0x46, 0x3B, 0x4C, 0x44, 
	0x39, 0x5B, 0x53, 0x4B, 0x4E, 0x46, 0x3C, 0x44, 0x3C, 0x34, 0x4B, 0x40, 0x38, 0x4C, 0x44, 0x3A, 
	0x49, 0x3F, 0x37, 0x48, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x4E, 0x47, 0x3B, 0x1B, 0x1C, 0x20, 0x34, 
	0x89, 0x9A, 0x43, 0xA9, 0xC3, 0x3D, 0x9B, 0xAB, 0x04, 0x06, 0x03, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x09, 0x08, 0x00, 0x00, 
	0x00, 0x3F, 0x9A, 0xAD, 0x52, 0xC9, 0xDE, 0x48, 0xC5, 0xD3, 0x53, 0xC8, 0xDE, 0x2E, 0x6E, 0x77, 
	0x00, 0x02, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x28, 0x51, 0x59, 0x44, 0xA3, 0xB8, 0x56, 
	0xC9, 0xE1, 0x4E, 0xC3, 0xD7, 0x4E, 0xC3, 0xD5, 0x52, 0xC4, 0xDB, 0x31, 0x6F, 0x7D, 0x04, 0x06, 
	0x04, 0x0B, 0x09, 0x09, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 
	0x09, 0x04, 0x08, 0x06, 0x3A, 0x7A, 0x88, 0x3C, 0xA0, 0xBA, 0x42, 0x99, 0xA8, 0x0D, 0x00, 0x00, 
	0x28, 0x53, 0x58, 0x31, 0x53, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x2A, 0x4F, 0x52, 0x3B, 0x4D, 0x4D, 0x3D, 0x4F, 0x4D, 0x18, 0x4A, 0x53, 0x1C, 0x4A, 
	0x52, 0x19, 0x4A, 0x53, 0x2E, 0x44, 0x47, 0x36, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x0D, 0x34, 0x3E, 
	0x1E, 0x46, 0x47, 0x1D, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3D, 0x43, 0x38, 0x32, 0x2C, 0x32, 0x2F, 
	0x29, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x3A, 0x3B, 0x32, 
	0x37, 0x32, 0x2F, 0x2F, 0x31, 0x26, 0x1E, 0x22, 0x29, 0x1C, 0x3B, 0x42, 0x3A, 0x38, 0x2E, 0x35, 
	0x37, 0x2F, 0x4F, 0x43, 0x3A, 0x36, 0x38, 0x2F, 0x39, 0x37, 0x31, 0x2C, 0x2E, 0x24, 0x3A, 0x32, 
	0x2F, 0x32, 0x42, 0x3E, 0x30, 0x43, 0x43, 0x2F, 0x40, 0x42, 0x30, 0x43, 0x43, 0x36, 0x3E, 0x39, 
	0x18, 0x30, 0x39, 0x2E, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x44, 0x48, 0x49, 0x33, 0x34, 0x2A, 0x48, 
	0x3F, 0x37, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x40, 0x4F, 0x47, 0x42, 0x4B, 0x42, 
	0x38, 0x4E, 0x45, 0x3A, 0x64, 0x5A, 0x4F, 0x34, 0x34, 0x2B, 0x3E, 0x3A, 0x32, 0x50, 0x47, 0x3D, 
	0x4D, 0x45, 0x3B, 0x4C, 0x44, 0x3A, 0x47, 0x3C, 0x42, 0x54, 0x4A, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x42, 0xA8, 0xC3, 0x2F, 0x65, 0x6D, 0x02, 0x03, 0x02, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x04, 0x03, 0x1B, 0x3E, 
	0x43, 0x56, 0xC9, 0xE1, 0x4E, 0xC5, 0xD8, 0x4F, 0xC5, 0xDB, 0x28, 0x50, 0x5A, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 
	0x67, 0x70, 0x4F, 0xC8, 0xDE, 0x51, 0xC4, 0xD9, 0x54, 0xC6, 0xDD, 0x49, 0xAE, 0xBE, 0x06, 0x04, 
	0x04, 0x07, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x08, 
	0x08, 0x02, 0x04, 0x02, 0x29, 0x66, 0x6F, 0x3D, 0xA2, 0xBD, 0x44, 0x9D, 0xB0, 0x04, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x2F, 0x51, 0x52, 0x2C, 0x4E, 0x52, 0x2C, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x35, 0x4C, 0x4A, 0x42, 0x47, 0x46, 0x29, 0x44, 0x47, 0x1A, 0x4A, 
	0x53, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x54, 0x43, 0x48, 0x46, 0x4B, 0x4C, 0x4B, 0x20, 0x3A, 0x3E, 
	0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x43, 0x40, 0x26, 0x3C, 0x43, 0x3A, 0x31, 0x2E, 0x35, 0x2E, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x37, 0x34, 0x30, 0x34, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 
	0x37, 0x2F, 0x2F, 0x39, 0x30, 0x31, 0x3B, 0x33, 0x27, 0x15, 0x2C, 0x39, 0x3A, 0x38, 0x2E, 0x34, 
	0x36, 0x2E, 0x49, 0x3F, 0x37, 0x35, 0x36, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2E, 0x24, 0x38, 0x36, 
	0x30, 0x1D, 0x33, 0x3B, 0x1E, 0x32, 0x39, 0x34, 0x43, 0x40, 0x1D, 0x37, 0x3E, 0x20, 0x42, 0x4D, 
	0x20, 0x48, 0x4C, 0x1F, 0x42, 0x4D, 0x23, 0x3E, 0x3D, 0x42, 0x48, 0x47, 0x3C, 0x38, 0x30, 0x31, 
	0x34, 0x2B, 0x4B, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x49, 0x3F, 0x36, 0x48, 0x3E, 0x3E, 0x4D, 0x43, 
	0x3E, 0x44, 0x48, 0x45, 0x79, 0x77, 0x6F, 0x4F, 0x49, 0x43, 0x43, 0x3C, 0x36, 0x48, 0x3C, 0x33, 
	0x57, 0x4F, 0x49, 0x6A, 0x62, 0x4E, 0x51, 0x49, 0x3F, 0x4C, 0x45, 0x39, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3E, 0xA2, 0xBD, 0x2C, 0x6B, 0x77, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 0x09, 0x06, 0x07, 0x08, 0x47, 0xA1, 
	0xB5, 0x4A, 0xC5, 0xD4, 0x52, 0xC8, 0xDD, 0x36, 0x82, 0x93, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x02, 
	0x02, 0x03, 0x2C, 0x71, 0x7D, 0x51, 0xC3, 0xD9, 0x53, 0xC5, 0xDC, 0x53, 0xC3, 0xDE, 0x03, 0x08, 
	0x06, 0x07, 0x07, 0x06, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x14, 
	0x14, 0x03, 0x02, 0x02, 0x25, 0x4C, 0x4E, 0x44, 0xA1, 0xBA, 0x4E, 0xA6, 0xBD, 0x06, 0x02, 0x00, 
	0x28, 0x52, 0x58, 0x25, 0x49, 0x4C, 0x15, 0x44, 0x4D, 0x1D, 0x49, 0x52, 0x2E, 0x4F, 0x51, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4C, 0x53, 0x29, 0x43, 0x47, 0x29, 0x47, 0x4E, 0x19, 0x4A, 
	0x52, 0x29, 0x4A, 0x52, 0x19, 0x4A, 0x52, 0x28, 0x47, 0x4E, 0x25, 0x45, 0x49, 0x1A, 0x38, 0x3C, 
	0x28, 0x4B, 0x53, 0x1B, 0x3F, 0x3D, 0x1C, 0x3A, 0x3E, 0x1C, 0x39, 0x3F, 0x0F, 0x35, 0x3F, 0x19, 
	0x3C, 0x40, 0x0F, 0x34, 0x3E, 0x1C, 0x3B, 0x3F, 0x24, 0x40, 0x43, 0x38, 0x2B, 0x2C, 0x38, 0x3B, 
	0x30, 0x38, 0x2C, 0x30, 0x37, 0x3A, 0x30, 0x3C, 0x3A, 0x32, 0x4A, 0x42, 0x38, 0x2E, 0x2C, 0x26, 
	0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x1A, 0x34, 0x3E, 0x18, 0x34, 0x3B, 0x3E, 0x38, 0x33, 0x48, 
	0x3E, 0x36, 0x3D, 0x39, 0x31, 0x3E, 0x39, 0x34, 0x40, 0x38, 0x35, 0x2E, 0x29, 0x22, 0x15, 0x3A, 
	0x47, 0x20, 0x42, 0x4B, 0x1F, 0x42, 0x4B, 0x23, 0x39, 0x3D, 0x24, 0x39, 0x3E, 0x20, 0x40, 0x45, 
	0x35, 0x3F, 0x3C, 0x2A, 0x3C, 0x39, 0x28, 0x40, 0x43, 0x43, 0x3A, 0x30, 0x3D, 0x39, 0x31, 0x4A, 
	0x43, 0x3A, 0x4A, 0x40, 0x3B, 0x47, 0x3C, 0x3B, 0x4A, 0x40, 0x37, 0x4D, 0x44, 0x3A, 0x39, 0x36, 
	0x30, 0x49, 0x3F, 0x38, 0x37, 0x42, 0x46, 0x4F, 0x45, 0x3E, 0x71, 0x6A, 0x5D, 0x3A, 0x48, 0x4A, 
	0x4E, 0x44, 0x39, 0x4E, 0x46, 0x3C, 0x58, 0x50, 0x46, 0x56, 0x4B, 0x3E, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x42, 0xA8, 0xC3, 0x2C, 0x64, 0x6C, 0x00, 0x00, 0x00, 0x07, 0x08, 0x07, 0x07, 0x06, 
	0x04, 0x00, 0x00, 0x00, 0x08, 0x06, 0x04, 0x07, 0x04, 0x04, 0x04, 0x00, 0x00, 0x07, 0x06, 0x04, 
	0x03, 0x00, 0x00, 0x07, 0x04, 0x04, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x03, 
	0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x09, 0x08, 0x00, 0x00, 0x00, 0x08, 0x09, 0x09, 0x45, 0xB4, 
	0xC7, 0x4A, 0xC6, 0xD5, 0x46, 0xB5, 0xCB, 0x2A, 0x65, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0B, 0x0B, 0x0B, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x06, 
	0x02, 0x00, 0x0C, 0x16, 0x19, 0x4F, 0xB9, 0xD2, 0x54, 0xC5, 0xDD, 0x51, 0xC3, 0xD9, 0x2F, 0x6A, 
	0x77, 0x00, 0x00, 0x00, 0x07, 0x03, 0x03, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x06, 0x06, 0x03, 0x02, 0x00, 0x04, 0x00, 0x00, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x03, 
	0x02, 0x00, 0x07, 0x04, 0x04, 0x09, 0x07, 0x07, 0x09, 0x0F, 0x0E, 0x09, 0x06, 0x06, 0x09, 0x0D, 
	0x0D, 0x08, 0x06, 0x04, 0x0E, 0x22, 0x20, 0x4D, 0xA2, 0xBA, 0x43, 0xA1, 0xAE, 0x0C, 0x03, 0x02, 
	0x4E, 0x5D, 0x5B, 0x24, 0x3C, 0x47, 0x16, 0x3B, 0x42, 0x1E, 0x46, 0x4E, 0x2B, 0x50, 0x59, 0x2A, 
	0x4C, 0x4E, 0x2A, 0x4C, 0x4F, 0x2A, 0x4C, 0x4F, 0x2A, 0x4D, 0x50, 0x2A, 0x4D, 0x4F, 0x26, 0x4A, 
	0x4F, 0x1E, 0x47, 0x50, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x50, 0x14, 0x43, 0x4D, 0x1E, 0x44, 0x47, 
	0x1D, 0x43, 0x46, 0x22, 0x43, 0x47, 0x1E, 0x45, 0x48, 0x1B, 0x3C, 0x43, 0x27, 0x3D, 0x44, 0x11, 
	0x36, 0x3C, 0x1D, 0x40, 0x4A, 0x1B, 0x3C, 0x45, 0x3C, 0x3D, 0x39, 0x43, 0x37, 0x33, 0x31, 0x30, 
	0x2A, 0x35, 0x38, 0x2F, 0x32, 0x31, 0x2B, 0x37, 0x36, 0x2C, 0x4B, 0x40, 0x3A, 0x3F, 0x38, 0x35, 
	0x30, 0x31, 0x28, 0x30, 0x32, 0x28, 0x1B, 0x32, 0x36, 0x2A, 0x54, 0x58, 0x32, 0x52, 0x56, 0x58, 
	0x4A, 0x42, 0x59, 0x50, 0x46, 0x68, 0x5E, 0x53, 0x65, 0x5C, 0x53, 0x59, 0x4E, 0x42, 0x4D, 0x4E, 
	0x4E, 0x2B, 0x51, 0x55, 0x2C, 0x50, 0x55, 0x45, 0x54, 0x53, 0x45, 0x53, 0x52, 0x30, 0x51, 0x51, 
	0x45, 0x42, 0x3C, 0x48, 0x42, 0x40, 0x70, 0x69, 0x65, 0x6C, 0x61, 0x55, 0x5D, 0x53, 0x4A, 0x66, 
	0x5D, 0x4F, 0x67, 0x5E, 0x50, 0x67, 0x5E, 0x50, 0x66, 0x5D, 0x52, 0x73, 0x6A, 0x5B, 0x67, 0x5E, 
	0x56, 0x67, 0x5E, 0x4F, 0x65, 0x5A, 0x4E, 0x6A, 0x60, 0x54, 0x68, 0x62, 0x56, 0x70, 0x6B, 0x65, 
	0x6C, 0x62, 0x53, 0x63, 0x5B, 0x54, 0x6E, 0x65, 0x54, 0x6C, 0x5E, 0x52, 0x1C, 0x22, 0x24, 0x36, 
	0x84, 0x94, 0x43, 0xAB, 0xC1, 0x4B, 0xBB, 0xCF, 0x12, 0x29, 0x2A, 0x00, 0x02, 0x02, 0x09, 0x07, 
	0x0B, 0x0B, 0x07, 0x0B, 0x06, 0x09, 0x0D, 0x02, 0x0D, 0x11, 0x03, 0x0D, 0x11, 0x07, 0x09, 0x0D, 
	0x02, 0x0E, 0x12, 0x06, 0x09, 0x0D, 0x06, 0x09, 0x0D, 0x03, 0x0E, 0x12, 0x09, 0x06, 0x09, 0x06, 
	0x0B, 0x0E, 0x09, 0x07, 0x0B, 0x08, 0x06, 0x09, 0x04, 0x06, 0x09, 0x12, 0x2C, 0x2B, 0x51, 0xBE, 
	0xDA, 0x54, 0xC3, 0xD4, 0x58, 0xD1, 0xE4, 0x2A, 0x5E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0C, 0x00, 0x04, 0x03, 0x02, 0x04, 0x04, 0x0C, 
	0x09, 0x09, 0x00, 0x00, 0x00, 0x43, 0xA4, 0xB3, 0x4F, 0xC6, 0xDA, 0x4F, 0xC5, 0xD7, 0x3E, 0xA0, 
	0xB3, 0x14, 0x32, 0x35, 0x07, 0x04, 0x07, 0x04, 0x09, 0x0C, 0x09, 0x07, 0x0B, 0x08, 0x07, 0x0B, 
	0x08, 0x06, 0x09, 0x09, 0x07, 0x09, 0x00, 0x0E, 0x12, 0x09, 0x04, 0x07, 0x04, 0x0B, 0x0E, 0x09, 
	0x07, 0x09, 0x08, 0x06, 0x09, 0x08, 0x0C, 0x0E, 0x04, 0x08, 0x0C, 0x08, 0x0D, 0x0F, 0x08, 0x0C, 
	0x0F, 0x07, 0x06, 0x08, 0x0F, 0x16, 0x1A, 0x44, 0xA6, 0xB9, 0x38, 0x93, 0xA4, 0x11, 0x12, 0x09, 
	0xC3, 0xB1, 0xA3, 0xD5, 0xBD, 0xAB, 0x59, 0x74, 0x77, 0x38, 0x70, 0x7A, 0x38, 0x77, 0x81, 0x38, 
	0x65, 0x6E, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x67, 0x70, 0x39, 0x67, 
	0x71, 0x33, 0x5F, 0x65, 0x39, 0x62, 0x65, 0x39, 0x68, 0x73, 0x35, 0x5D, 0x60, 0x32, 0x5B, 0x61, 
	0x32, 0x5E, 0x67, 0x35, 0x64, 0x6C, 0x33, 0x61, 0x6B, 0x22, 0x53, 0x5B, 0x34, 0x5F, 0x65, 0x2A, 
	0x4E, 0x58, 0x34, 0x5E, 0x65, 0x2E, 0x55, 0x59, 0x38, 0x53, 0x56, 0x58, 0x4B, 0x43, 0x56, 0x4C, 
	0x43, 0x57, 0x4D, 0x43, 0x51, 0x47, 0x3C, 0x4C, 0x46, 0x3B, 0x5F, 0x56, 0x4C, 0x69, 0x60, 0x54, 
	0x52, 0x48, 0x44, 0x54, 0x4A, 0x42, 0x08, 0x09, 0x09, 0x11, 0x20, 0x23, 0x13, 0x12, 0x11, 0x15, 
	0x0D, 0x0F, 0x16, 0x1B, 0x1A, 0x18, 0x19, 0x14, 0x1B, 0x19, 0x14, 0x1A, 0x22, 0x1D, 0x19, 0x1B, 
	0x18, 0x19, 0x11, 0x11, 0x19, 0x12, 0x12, 0x1E, 0x0C, 0x0B, 0x0E, 0x23, 0x29, 0x18, 0x13, 0x13, 
	0x1F, 0x12, 0x0E, 0x1A, 0x1E, 0x19, 0x1D, 0x24, 0x1E, 0x1D, 0x24, 0x1F, 0x1B, 0x1F, 0x1E, 0x16, 
	0x18, 0x13, 0x1D, 0x1E, 0x20, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1F, 0x1A, 0x1B, 0x1D, 0x1E, 
	0x1F, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1C, 0x1D, 0x1F, 0x27, 0x24, 0x22, 0x1B, 0x23, 0x1D, 
	0x1B, 0x23, 0x1E, 0x31, 0x2A, 0x26, 0x25, 0x26, 0x22, 0x25, 0x25, 0x1F, 0x13, 0x13, 0x14, 0x3B, 
	0x81, 0x92, 0x39, 0x96, 0xB1, 0x4C, 0xC6, 0xD4, 0x46, 0xB4, 0xC7, 0x46, 0xAA, 0xBC, 0x45, 0xAF, 
	0xC0, 0x46, 0xAE, 0xC0, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 
	0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 0x45, 0xAE, 0xBF, 0x45, 0xAE, 0xBE, 0x4B, 0xAE, 0xBF, 0x45, 
	0xAE, 0xC0, 0x48, 0xAE, 0xC0, 0x4B, 0xAE, 0xC0, 0x44, 0xAD, 0xBD, 0x4B, 0xB3, 0xCB, 0x4F, 0xC4, 
	0xD4, 0x50, 0xC2, 0xD6, 0x53, 0xC9, 0xDE, 0x2B, 0x66, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x02, 0x02, 0x0B, 0x0C, 0x0C, 0x12, 0x1F, 0x1E, 0x43, 0x57, 0x62, 0x13, 0x1F, 0x1E, 0x06, 
	0x06, 0x06, 0x03, 0x03, 0x00, 0x3C, 0x97, 0xA5, 0x4F, 0xC7, 0xDB, 0x53, 0xC2, 0xDB, 0x50, 0xC5, 
	0xD9, 0x4A, 0xB8, 0xD3, 0x49, 0xAB, 0xC0, 0x50, 0xBB, 0xD2, 0x49, 0xAD, 0xC3, 0x4D, 0xB2, 0xC4, 
	0x4F, 0xB5, 0xC4, 0x49, 0xAE, 0xC4, 0x49, 0xAB, 0xC1, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x49, 
	0xAE, 0xC4, 0x4F, 0xB3, 0xC3, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x4A, 0xAE, 0xC3, 0x49, 0xAE, 
	0xC4, 0x4C, 0xB0, 0xC2, 0x4C, 0xBB, 0xD3, 0x39, 0x99, 0xB3, 0x3E, 0x9B, 0xAF, 0x09, 0x0E, 0x14, 
	0x49, 0x42, 0x36, 0x44, 0x39, 0x33, 0x36, 0x27, 0x24, 0x0C, 0x27, 0x26, 0x11, 0x20, 0x25, 0x11, 
	0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x1F, 0x24, 0x11, 0x1C, 0x20, 0x11, 0x24, 
	0x28, 0x12, 0x1D, 0x22, 0x11, 0x1D, 0x23, 0x11, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x12, 0x1E, 0x23, 
	0x12, 0x1E, 0x23, 0x12, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x14, 0x1F, 0x25, 0x0C, 0x19, 0x16, 0x0D, 
	0x1A, 0x19, 0x0C, 0x19, 0x18, 0x0C, 0x1A, 0x19, 0x0D, 0x1E, 0x22, 0x1B, 0x14, 0x12, 0x1A, 0x16, 
	0x0F, 0x16, 0x0E, 0x0F, 0x1B, 0x0F, 0x11, 0x18, 0x0E, 0x0F, 0x19, 0x1B, 0x16, 0x18, 0x1A, 0x15, 
	0x1B, 0x15, 0x13, 0x14, 0x15, 0x16, 0x00, 0x00, 0x00, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x03, 0x03, 0x02, 0x02, 0x03, 0x06, 0x06, 0x07, 0x02, 0x02, 0x02, 0x03, 0x02, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x04, 0x04, 0x04, 0x02, 0x00, 0x03, 0x03, 0x03, 
	0x02, 0x03, 0x04, 0x02, 0x02, 0x03, 0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x02, 0x02, 0x00, 0x02, 
	0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 
	0x81, 0x92, 0x48, 0xB7, 0xCA, 0x50, 0xC5, 0xD9, 0x50, 0xC5, 0xD6, 0x4A, 0xC5, 0xD4, 0x51, 0xC5, 
	0xD8, 0x4A, 0xC5, 0xD4, 0x4D, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4B, 0xC5, 0xD5, 0x4A, 0xC5, 0xD4, 
	0x51, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x55, 0xC5, 0xDF, 0x51, 0xC5, 0xDA, 0x4D, 
	0xC5, 0xD4, 0x49, 0xC5, 0xD5, 0x50, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x52, 0xC5, 0xD8, 0x47, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x52, 0xC6, 0xDB, 0x44, 0xA1, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x06, 0x0C, 0x0C, 0x31, 0x36, 0x34, 0xA1, 0xB4, 0xC4, 0x2A, 0x3A, 0x39, 0x00, 
	0x02, 0x00, 0x00, 0x03, 0x03, 0x46, 0xA6, 0xB4, 0x54, 0xC5, 0xDD, 0x4F, 0xC2, 0xD4, 0x4F, 0xC2, 
	0xD3, 0x53, 0xC4, 0xDD, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDC, 0x54, 0xC5, 0xDE, 0x4D, 0xC5, 0xD8, 
	0x54, 0xC5, 0xDE, 0x52, 0xC5, 0xDC, 0x5E, 0xD1, 0xE4, 0x5B, 0xCC, 0xE3, 0x53, 0xC5, 0xDD, 0x53, 
	0xC5, 0xDE, 0x53, 0xC5, 0xD2, 0x52, 0xC3, 0xDC, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDE, 0x53, 0xC5, 
	0xD2, 0x52, 0xC5, 0xDE, 0x5A, 0xCF, 0xE0, 0x49, 0x9F, 0xB8, 0x3A, 0x94, 0xA2, 0x09, 0x11, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x00, 
	0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 
	0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x02, 0x04, 
	0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02, 0x03, 
	0x04, 0x03, 0x04, 0x04, 0x02, 0x04, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 
	0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 
	0x82, 0x93, 0x3C, 0x9D, 0xB7, 0x4A, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x4E, 0xC2, 0xD1, 0x48, 
	0xC2, 0xD2, 0x55, 0xC2, 0xD2, 0x47, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD1, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD7, 0x51, 0xC5, 0xDC, 0x1E, 0x3E, 0x46, 0x03, 0x00, 0x00, 
	0x08, 0x06, 0x06, 0x09, 0x08, 0x08, 0x09, 0x12, 0x15, 0x24, 0x2E, 0x2C, 0x0E, 0x08, 0x08, 0x02, 
	0x00, 0x00, 0x18, 0x33, 0x37, 0x4E, 0xBC, 0xD6, 0x53, 0xC4, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD0, 0x52, 0xC2, 0xCF, 0x53, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x53, 0xC1, 0xDA, 0x57, 0xC6, 0xD8, 0x4B, 0xC0, 0xD4, 0x4C, 0xC2, 0xD1, 0x52, 
	0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 
	0xDA, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3C, 0xA1, 0xB9, 0x42, 0xA0, 0xB6, 0x09, 0x12, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0D, 0x0D, 0x03, 0x06, 0x06, 0x03, 0x07, 0x06, 0x03, 
	0x07, 0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x06, 0x07, 0x00, 0x07, 
	0x07, 0x00, 0x04, 0x04, 0x00, 0x04, 0x04, 0x03, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x04, 0x06, 
	0x00, 0x03, 0x04, 0x00, 0x04, 0x06, 0x00, 0x04, 0x06, 0x00, 0x03, 0x04, 0x12, 0x0B, 0x0C, 0x0F, 
	0x09, 0x0B, 0x0D, 0x07, 0x08, 0x08, 0x08, 0x09, 0x00, 0x03, 0x04, 0x14, 0x0B, 0x0C, 0x00, 0x03, 
	0x04, 0x13, 0x0C, 0x0C, 0x11, 0x0B, 0x0B, 0x0F, 0x09, 0x0B, 0x11, 0x0B, 0x0C, 0x0F, 0x09, 0x0B, 
	0x0F, 0x09, 0x0B, 0x0E, 0x08, 0x09, 0x0E, 0x08, 0x09, 0x13, 0x09, 0x09, 0x1A, 0x29, 0x2E, 0x35, 
	0x8B, 0x9B, 0x3B, 0x98, 0xB3, 0x4B, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x53, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDD, 0x4F, 0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x52, 0xC5, 0xD9, 0x50, 0xBD, 0xD4, 0x0D, 0x27, 0x2B, 
	0x00, 0x00, 0x00, 0x09, 0x06, 0x04, 0x06, 0x03, 0x02, 0x02, 0x00, 0x00, 0x03, 0x06, 0x04, 0x11, 
	0x15, 0x13, 0x49, 0xB2, 0xC8, 0x51, 0xC7, 0xDD, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x53, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x53, 0xC2, 0xDA, 0x49, 0xC2, 0xCE, 0x52, 0xC1, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x53, 0xC3, 
	0xD9, 0x5D, 0xCD, 0xD9, 0x52, 0xC7, 0xDB, 0x46, 0x99, 0xB2, 0x3D, 0x9B, 0xAD, 0x0D, 0x0B, 0x0E, 
	0x0E, 0x08, 0x09, 0x0F, 0x0F, 0x09, 0x06, 0x08, 0x09, 0x00, 0x09, 0x09, 0x02, 0x03, 0x02, 0x02, 
	0x03, 0x02, 0x04, 0x09, 0x08, 0x04, 0x08, 0x08, 0x08, 0x12, 0x12, 0x03, 0x02, 0x00, 0x02, 0x03, 
	0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x02, 0x04, 0x03, 0x02, 0x04, 0x03, 
	0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x02, 
	0x04, 0x03, 0x03, 0x04, 0x04, 0x02, 0x04, 0x03, 0x00, 0x03, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 
	0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 
	0x03, 0x07, 0x06, 0x03, 0x07, 0x06, 0x1A, 0x31, 0x35, 0x1B, 0x2F, 0x34, 0x1B, 0x2F, 0x33, 0x19, 
	0x31, 0x35, 0x1E, 0x36, 0x3C, 0x34, 0x39, 0x33, 0x39, 0x39, 0x2E, 0x3C, 0x3A, 0x33, 0x31, 0x26, 
	0x25, 0x4B, 0x46, 0x40, 0x2E, 0x40, 0x3F, 0x1A, 0x31, 0x3A, 0x32, 0x35, 0x2B, 0x49, 0x43, 0x38, 
	0x4D, 0x49, 0x3D, 0x48, 0x3D, 0x39, 0x47, 0x3C, 0x38, 0x4A, 0x46, 0x3A, 0x4A, 0x47, 0x3C, 0x4D, 
	0x43, 0x40, 0x70, 0x68, 0x57, 0x3C, 0x35, 0x2E, 0x44, 0x3E, 0x38, 0x4C, 0x49, 0x3D, 0x43, 0x3A, 
	0x3A, 0x45, 0x3D, 0x36, 0x48, 0x45, 0x3D, 0x4B, 0x48, 0x3C, 0x44, 0x39, 0x36, 0x4A, 0x47, 0x3C, 
	0x48, 0x45, 0x3B, 0x5B, 0x51, 0x48, 0x5B, 0x51, 0x48, 0x4C, 0x47, 0x3C, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3B, 0x99, 0xB3, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD4, 0x48, 0xC2, 0xD0, 0x55, 0xC2, 
	0xDC, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x4E, 0xC5, 0xD7, 0x51, 0xBA, 0xD0, 
	0x2C, 0x67, 0x73, 0x0E, 0x16, 0x18, 0x03, 0x04, 0x07, 0x08, 0x13, 0x15, 0x26, 0x4C, 0x53, 0x4B, 
	0xB8, 0xCC, 0x52, 0xC5, 0xDC, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xCF, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x54, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x4C, 0xC2, 0xD2, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5D, 0xCD, 
	0xD9, 0x4F, 0xBE, 0xD9, 0x4E, 0xC5, 0xD8, 0x38, 0x96, 0xB0, 0x38, 0x93, 0xA2, 0x0F, 0x09, 0x08, 
	0x95, 0x86, 0x7C, 0x87, 0x86, 0x7F, 0x6B, 0x67, 0x60, 0x37, 0x4E, 0x52, 0x19, 0x46, 0x50, 0x1F, 
	0x48, 0x4F, 0x2E, 0x59, 0x61, 0x28, 0x4E, 0x4D, 0x2A, 0x4F, 0x4E, 0x15, 0x44, 0x4F, 0x28, 0x4E, 
	0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x4F, 0x50, 0x25, 0x3F, 0x4A, 0x1F, 0x45, 0x4F, 
	0x1F, 0x40, 0x4A, 0x20, 0x45, 0x4E, 0x1C, 0x3B, 0x46, 0x1F, 0x3E, 0x45, 0x26, 0x42, 0x4D, 0x23, 
	0x3E, 0x46, 0x1E, 0x3C, 0x40, 0x26, 0x3E, 0x47, 0x44, 0x4F, 0x4D, 0x20, 0x3E, 0x47, 0x1F, 0x3E, 
	0x42, 0x1F, 0x38, 0x42, 0x20, 0x39, 0x43, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 
	0x1A, 0x31, 0x35, 0x1A, 0x2F, 0x33, 0x1E, 0x31, 0x3A, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2E, 0x1A, 
	0x30, 0x3A, 0x3F, 0x2F, 0x2E, 0x3A, 0x2F, 0x31, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x3A, 0x38, 
	0x32, 0x3A, 0x38, 0x2C, 0x13, 0x34, 0x40, 0x0E, 0x39, 0x44, 0x28, 0x2F, 0x2F, 0x4C, 0x3F, 0x36, 
	0x4E, 0x40, 0x3A, 0x39, 0x46, 0x45, 0x40, 0x35, 0x32, 0x46, 0x3E, 0x36, 0x4A, 0x3F, 0x37, 0x50, 
	0x48, 0x42, 0x69, 0x60, 0x54, 0x42, 0x3B, 0x39, 0x4B, 0x40, 0x37, 0x4C, 0x40, 0x39, 0x4B, 0x42, 
	0x38, 0x4B, 0x40, 0x37, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 
	0x4F, 0x46, 0x3C, 0x4D, 0x44, 0x3B, 0x50, 0x48, 0x3E, 0x54, 0x49, 0x3E, 0x1A, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x51, 0xC6, 0xDB, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 
	0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x50, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x55, 0xBF, 0xCE, 0x4E, 0xC5, 0xDA, 0x50, 0xC2, 0xD5, 0x53, 0xC5, 0xDB, 
	0x53, 0xC6, 0xDC, 0x5A, 0xBD, 0xD6, 0x4D, 0xB7, 0xCF, 0x4E, 0xB5, 0xCC, 0x56, 0xCB, 0xE1, 0x4D, 
	0xCB, 0xDD, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x4D, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 0x54, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xDA, 0x51, 0xC0, 0xCE, 0x5E, 0xCE, 0xDA, 0x51, 0xC0, 0xDA, 0x4B, 0xC1, 0xCE, 0x55, 0xC5, 
	0xDA, 0x5D, 0xCD, 0xD9, 0x53, 0xC7, 0xDA, 0x3D, 0xA1, 0xB9, 0x4F, 0xA6, 0xBD, 0x02, 0x04, 0x03, 
	0x7F, 0x70, 0x61, 0x8F, 0x7C, 0x6C, 0x75, 0x6E, 0x66, 0x63, 0x5D, 0x58, 0x1C, 0x3C, 0x45, 0x12, 
	0x3D, 0x48, 0x34, 0x56, 0x53, 0x2B, 0x4E, 0x53, 0x32, 0x54, 0x53, 0x2E, 0x4F, 0x53, 0x26, 0x49, 
	0x53, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x54, 0x22, 0x46, 0x49, 0x1C, 0x43, 0x44, 
	0x1D, 0x4A, 0x51, 0x1C, 0x4C, 0x55, 0x1D, 0x43, 0x43, 0x19, 0x49, 0x53, 0x20, 0x44, 0x44, 0x1C, 
	0x49, 0x4D, 0x1B, 0x3A, 0x3F, 0x25, 0x3E, 0x40, 0x31, 0x40, 0x40, 0x1A, 0x40, 0x40, 0x1D, 0x30, 
	0x39, 0x1A, 0x31, 0x39, 0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 0x44, 
	0x1D, 0x32, 0x3B, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1C, 
	0x2F, 0x38, 0x24, 0x30, 0x30, 0x2F, 0x30, 0x24, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x31, 0x2E, 
	0x28, 0x3A, 0x31, 0x2E, 0x30, 0x43, 0x3E, 0x11, 0x3A, 0x42, 0x22, 0x30, 0x36, 0x27, 0x3C, 0x38, 
	0x42, 0x37, 0x2B, 0x24, 0x42, 0x43, 0x44, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x43, 
	0x3C, 0x33, 0x43, 0x3B, 0x36, 0x4A, 0x3F, 0x36, 0x4D, 0x43, 0x40, 0x31, 0x34, 0x2B, 0x4D, 0x42, 
	0x38, 0x4A, 0x40, 0x40, 0x49, 0x3F, 0x36, 0x4F, 0x47, 0x43, 0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x40, 
	0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x3B, 0x51, 0x48, 0x3E, 0x46, 0x42, 0x37, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB1, 0x4E, 0xC7, 0xD8, 0x49, 0xBC, 0xCB, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x4E, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x53, 0xC2, 0xDD, 0x4E, 0xC2, 
	0xD0, 0x4C, 0xC5, 0xD6, 0x42, 0xAD, 0xC3, 0x46, 0xA7, 0xB7, 0x56, 0xCB, 0xE2, 0x52, 0xC7, 0xDB, 
	0x51, 0xCA, 0xDE, 0x57, 0xCE, 0xE4, 0x5A, 0xCF, 0xE4, 0x57, 0xD1, 0xE3, 0x51, 0xC5, 0xDD, 0x39, 
	0x8E, 0x9C, 0x53, 0xC8, 0xDD, 0x50, 0xC3, 0xD9, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xD0, 0x49, 0xC2, 
	0xCF, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC0, 0xD7, 0x5C, 0xCC, 
	0xD9, 0x4E, 0xBE, 0xD9, 0x5A, 0xCC, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x93, 0xA3, 0x00, 0x06, 0x04, 
	0x68, 0x5C, 0x54, 0x91, 0x80, 0x6E, 0x81, 0x6F, 0x62, 0x85, 0x77, 0x68, 0x36, 0x47, 0x47, 0x18, 
	0x4B, 0x54, 0x2A, 0x46, 0x4C, 0x25, 0x49, 0x52, 0x28, 0x4B, 0x52, 0x2B, 0x4E, 0x52, 0x29, 0x4B, 
	0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x48, 0x4F, 0x1B, 0x3B, 0x3C, 
	0x1D, 0x3B, 0x3C, 0x1D, 0x4A, 0x51, 0x1D, 0x3E, 0x3C, 0x1D, 0x3A, 0x3E, 0x1D, 0x3B, 0x3F, 0x1C, 
	0x3A, 0x3E, 0x20, 0x40, 0x3E, 0x39, 0x3B, 0x35, 0x39, 0x3B, 0x35, 0x1A, 0x3A, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x16, 
	0x36, 0x40, 0x2B, 0x30, 0x29, 0x36, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2E, 
	0x24, 0x36, 0x42, 0x3C, 0x3D, 0x30, 0x2A, 0x13, 0x39, 0x42, 0x1D, 0x46, 0x48, 0x19, 0x3F, 0x3F, 
	0x23, 0x45, 0x48, 0x26, 0x45, 0x49, 0x45, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4C, 0x42, 0x39, 0x4D, 
	0x42, 0x39, 0x31, 0x34, 0x2B, 0x50, 0x47, 0x3D, 0x61, 0x58, 0x4D, 0x32, 0x34, 0x2B, 0x3F, 0x3B, 
	0x32, 0x4A, 0x3F, 0x40, 0x49, 0x3F, 0x36, 0x4B, 0x43, 0x3E, 0x51, 0x49, 0x3E, 0x58, 0x50, 0x47, 
	0x4E, 0x43, 0x3E, 0x54, 0x4C, 0x42, 0x53, 0x4B, 0x42, 0x54, 0x49, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x89, 0x99, 0x45, 0xAD, 0xC4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4B, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x52, 0xC2, 0xCF, 0x4C, 0xC1, 
	0xD4, 0x55, 0xCD, 0xE1, 0x31, 0x78, 0x87, 0x00, 0x00, 0x00, 0x29, 0x53, 0x5B, 0x38, 0x87, 0x9B, 
	0x40, 0xA2, 0xAF, 0x3E, 0xA0, 0xAB, 0x47, 0xA9, 0xB8, 0x32, 0x82, 0x94, 0x27, 0x52, 0x58, 0x00, 
	0x00, 0x00, 0x31, 0x7B, 0x85, 0x54, 0xCC, 0xE3, 0x53, 0xC3, 0xDB, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4E, 0xC1, 0xD1, 0x4E, 
	0xC1, 0xD1, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD8, 0x5A, 0xCA, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x5D, 0xCD, 0xDA, 0x52, 0xC7, 0xDA, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x68, 0x5B, 0x50, 0x90, 0x7E, 0x70, 0x8E, 0x7D, 0x6F, 0x84, 0x75, 0x68, 0x4D, 0x54, 0x53, 0x18, 
	0x49, 0x53, 0x28, 0x47, 0x4C, 0x29, 0x4C, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4B, 0x52, 0x33, 0x55, 
	0x52, 0x27, 0x4B, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x50, 
	0x1B, 0x3E, 0x3C, 0x1D, 0x43, 0x45, 0x1D, 0x46, 0x4B, 0x1E, 0x3D, 0x3D, 0x0E, 0x35, 0x3F, 0x1C, 
	0x3B, 0x3D, 0x2A, 0x4E, 0x59, 0x1F, 0x3C, 0x3E, 0x20, 0x3D, 0x40, 0x1C, 0x3D, 0x42, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x32, 0x3B, 0x16, 0x28, 0x2A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x1F, 
	0x2F, 0x35, 0x31, 0x29, 0x1D, 0x31, 0x30, 0x28, 0x34, 0x2F, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x30, 
	0x24, 0x11, 0x2C, 0x3C, 0x3D, 0x37, 0x2E, 0x34, 0x3F, 0x3B, 0x38, 0x43, 0x43, 0x1C, 0x45, 0x47, 
	0x19, 0x36, 0x3E, 0x2B, 0x3B, 0x34, 0x3B, 0x33, 0x30, 0x4B, 0x40, 0x38, 0x3E, 0x38, 0x33, 0x49, 
	0x40, 0x37, 0x34, 0x36, 0x2E, 0x47, 0x3F, 0x37, 0x5E, 0x56, 0x4A, 0x37, 0x36, 0x2E, 0x46, 0x3D, 
	0x35, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x3C, 0x3B, 0x37, 0x2E, 0x5B, 0x4F, 0x47, 
	0x33, 0x4D, 0x50, 0x4A, 0x3C, 0x36, 0x4F, 0x47, 0x3C, 0x4D, 0x46, 0x3A, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9D, 0xB6, 0x4B, 0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD1, 0x4B, 0xC2, 0xD3, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xD9, 0x53, 0xC3, 
	0xD4, 0x54, 0xC5, 0xE1, 0x04, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x04, 
	0x04, 0x03, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x06, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x32, 0x76, 0x85, 0x51, 0xC5, 0xDC, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD9, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4C, 0xC2, 0xCE, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x57, 0xC7, 0xD9, 0x5A, 
	0xCA, 0xDC, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xD8, 0x5D, 0xCD, 0xE4, 0x4F, 0xBE, 0xD8, 0x51, 0xC0, 
	0xD7, 0x51, 0xC0, 0xCF, 0x4F, 0xC5, 0xD8, 0x49, 0x9E, 0xB7, 0x3A, 0x96, 0xA6, 0x04, 0x00, 0x00, 
	0x62, 0x54, 0x47, 0x71, 0x6C, 0x5E, 0x8F, 0x7C, 0x6B, 0x88, 0x75, 0x69, 0x63, 0x5C, 0x4F, 0x23, 
	0x42, 0x48, 0x18, 0x4A, 0x53, 0x31, 0x52, 0x53, 0x2C, 0x4E, 0x52, 0x16, 0x49, 0x52, 0x29, 0x4B, 
	0x53, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x28, 0x4A, 0x53, 
	0x26, 0x49, 0x50, 0x1C, 0x3E, 0x3C, 0x1D, 0x4A, 0x51, 0x1C, 0x49, 0x50, 0x23, 0x43, 0x46, 0x1C, 
	0x38, 0x3F, 0x1F, 0x44, 0x45, 0x1B, 0x40, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3D, 0x40, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x16, 0x32, 0x3C, 0x3B, 
	0x2F, 0x2B, 0x2E, 0x30, 0x25, 0x3A, 0x35, 0x32, 0x39, 0x37, 0x31, 0x30, 0x2E, 0x27, 0x34, 0x2F, 
	0x2B, 0x35, 0x30, 0x26, 0x27, 0x26, 0x24, 0x2A, 0x3E, 0x42, 0x3D, 0x4E, 0x4D, 0x34, 0x3E, 0x3D, 
	0x22, 0x49, 0x4D, 0x27, 0x45, 0x49, 0x42, 0x39, 0x2F, 0x61, 0x58, 0x4A, 0x31, 0x2C, 0x24, 0x33, 
	0x2F, 0x2C, 0x37, 0x38, 0x2F, 0x46, 0x3D, 0x34, 0x48, 0x3E, 0x36, 0x4D, 0x42, 0x39, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x49, 0x3E, 0x35, 0x56, 0x4D, 0x40, 0x46, 0x40, 0x42, 0x60, 0x56, 0x46, 
	0x46, 0x4C, 0x4B, 0x48, 0x42, 0x40, 0x48, 0x3D, 0x34, 0x54, 0x4A, 0x3E, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xB9, 0xC9, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x48, 0xC2, 0xD1, 0x4D, 0xC1, 0xD5, 0x53, 0xCB, 
	0xDF, 0x3A, 0x8D, 0x9D, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x0C, 0x0B, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x04, 0x00, 0x00, 0x0F, 0x1E, 0x20, 0x4E, 0xBC, 0xD2, 0x53, 0xC5, 0xDA, 0x52, 0xC2, 
	0xDA, 0x4D, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4F, 0xC0, 0xD6, 0x5E, 0xCE, 0xE4, 0x51, 0xC0, 0xD6, 
	0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5A, 
	0xCA, 0xD8, 0x50, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 
	0xD9, 0x51, 0xC1, 0xD7, 0x59, 0xCC, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x5E, 0x54, 0x47, 0x62, 0x5A, 0x48, 0x74, 0x6E, 0x66, 0x81, 0x71, 0x66, 0x6D, 0x5F, 0x51, 0x4C, 
	0x5C, 0x5D, 0x11, 0x43, 0x4C, 0x28, 0x44, 0x47, 0x2E, 0x50, 0x54, 0x29, 0x4A, 0x53, 0x22, 0x44, 
	0x47, 0x27, 0x4D, 0x53, 0x27, 0x49, 0x52, 0x28, 0x4B, 0x54, 0x1D, 0x43, 0x45, 0x19, 0x4A, 0x53, 
	0x2A, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3C, 0x3C, 0x1D, 0x4D, 0x56, 0x13, 0x34, 0x3C, 0x1D, 
	0x2E, 0x38, 0x1D, 0x44, 0x40, 0x1E, 0x3A, 0x42, 0x0F, 0x36, 0x3F, 0x1E, 0x38, 0x42, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x2E, 0x37, 0x3C, 
	0x32, 0x30, 0x30, 0x2F, 0x27, 0x30, 0x2E, 0x27, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x3A, 0x35, 
	0x31, 0x29, 0x2F, 0x29, 0x19, 0x31, 0x3C, 0x23, 0x1E, 0x22, 0x1E, 0x45, 0x4F, 0x19, 0x33, 0x3D, 
	0x1B, 0x3D, 0x3F, 0x1C, 0x3B, 0x3E, 0x45, 0x3C, 0x33, 0x76, 0x6C, 0x5B, 0x4C, 0x46, 0x3D, 0x30, 
	0x30, 0x26, 0x29, 0x33, 0x32, 0x51, 0x4A, 0x49, 0x4F, 0x40, 0x36, 0x3A, 0x37, 0x2E, 0x4E, 0x40, 
	0x36, 0x4E, 0x43, 0x42, 0x48, 0x42, 0x40, 0x49, 0x4B, 0x46, 0x3F, 0x40, 0x42, 0x53, 0x4A, 0x46, 
	0x49, 0x4C, 0x4A, 0x40, 0x47, 0x49, 0x55, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x49, 0xB5, 0xCA, 0x4A, 0xBF, 0xCF, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x55, 0xC2, 0xDD, 0x4E, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4D, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 0xD1, 0x51, 0xC4, 0xD7, 0x54, 0xC5, 
	0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 
	0x0C, 0x0C, 0x0B, 0x13, 0x13, 0x03, 0x02, 0x00, 0x31, 0x65, 0x72, 0x55, 0xC9, 0xE0, 0x52, 0xC2, 
	0xDA, 0x4C, 0xC2, 0xD1, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD6, 0x52, 0xC2, 0xDA, 
	0x51, 0xC1, 0xDA, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x50, 
	0xC0, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xCA, 0xD9, 0x53, 0xC3, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 0xC1, 
	0xD9, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x08, 0x07, 
	0x63, 0x57, 0x49, 0x5B, 0x53, 0x48, 0x6B, 0x62, 0x52, 0x6E, 0x6E, 0x66, 0x74, 0x60, 0x4D, 0x60, 
	0x64, 0x61, 0x1E, 0x3F, 0x49, 0x13, 0x3C, 0x47, 0x18, 0x40, 0x40, 0x19, 0x49, 0x50, 0x0D, 0x31, 
	0x3B, 0x19, 0x46, 0x4F, 0x1F, 0x49, 0x4F, 0x1F, 0x3B, 0x42, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x55, 
	0x19, 0x3C, 0x39, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3D, 0x1D, 0x4E, 0x57, 0x18, 0x43, 0x4B, 0x1E, 
	0x2A, 0x33, 0x11, 0x39, 0x43, 0x1F, 0x2A, 0x34, 0x12, 0x38, 0x42, 0x1E, 0x3F, 0x42, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x24, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x16, 0x30, 0x3A, 0x3B, 
	0x3A, 0x2E, 0x38, 0x31, 0x31, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x29, 0x36, 0x32, 0x2E, 0x39, 0x32, 
	0x31, 0x34, 0x2F, 0x25, 0x16, 0x32, 0x3C, 0x1A, 0x2C, 0x36, 0x3B, 0x46, 0x43, 0x20, 0x48, 0x4C, 
	0x1F, 0x40, 0x3F, 0x24, 0x34, 0x38, 0x30, 0x2C, 0x25, 0x4E, 0x48, 0x3F, 0x5C, 0x52, 0x4A, 0x46, 
	0x3A, 0x2F, 0x13, 0x3B, 0x3F, 0x2A, 0x39, 0x33, 0x23, 0x40, 0x42, 0x1B, 0x3A, 0x42, 0x29, 0x40, 
	0x42, 0x46, 0x4A, 0x4A, 0x34, 0x46, 0x47, 0x4F, 0x4D, 0x4A, 0x29, 0x4B, 0x4B, 0x1E, 0x3B, 0x3A, 
	0x30, 0x51, 0x53, 0x3C, 0x4A, 0x4B, 0x54, 0x4A, 0x3F, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD1, 0x54, 0xC2, 0xDD, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x53, 0xC6, 0xD8, 0x3A, 0x8D, 
	0x9D, 0x04, 0x06, 0x03, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 
	0x15, 0x15, 0x0B, 0x14, 0x14, 0x09, 0x0F, 0x0E, 0x04, 0x08, 0x06, 0x46, 0xAB, 0xC2, 0x54, 0xCA, 
	0xDF, 0x52, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xDA, 0x52, 0xC2, 0xCF, 0x51, 0xC1, 0xD4, 
	0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 
	0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5C, 0xCC, 0xD8, 0x52, 0xC3, 0xD9, 0x53, 0xC3, 
	0xD8, 0x59, 0xC9, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x07, 0x06, 
	0x68, 0x5C, 0x4F, 0x63, 0x5B, 0x4C, 0x65, 0x5C, 0x4A, 0x65, 0x5E, 0x56, 0x70, 0x66, 0x59, 0x90, 
	0x7E, 0x6E, 0x62, 0x58, 0x4E, 0x38, 0x5B, 0x5E, 0x2E, 0x45, 0x4C, 0x38, 0x4F, 0x4F, 0x22, 0x3C, 
	0x3F, 0x1B, 0x40, 0x49, 0x19, 0x44, 0x4A, 0x0F, 0x34, 0x3E, 0x12, 0x37, 0x3C, 0x27, 0x49, 0x4F, 
	0x29, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x3C, 0x1A, 0x49, 0x53, 0x1F, 
	0x3D, 0x3F, 0x11, 0x37, 0x40, 0x1F, 0x3A, 0x43, 0x12, 0x38, 0x40, 0x1D, 0x36, 0x3D, 0x1B, 0x31, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x13, 0x33, 0x3D, 0x39, 
	0x3B, 0x32, 0x42, 0x36, 0x33, 0x2C, 0x2C, 0x27, 0x2F, 0x26, 0x1C, 0x2F, 0x32, 0x26, 0x3A, 0x2F, 
	0x32, 0x36, 0x2F, 0x29, 0x16, 0x32, 0x3C, 0x13, 0x39, 0x44, 0x33, 0x40, 0x3F, 0x20, 0x4B, 0x54, 
	0x31, 0x40, 0x42, 0x35, 0x35, 0x30, 0x35, 0x33, 0x2C, 0x3A, 0x35, 0x2F, 0x52, 0x4B, 0x44, 0x34, 
	0x44, 0x48, 0x22, 0x48, 0x4E, 0x1A, 0x3F, 0x3F, 0x1E, 0x44, 0x47, 0x26, 0x40, 0x40, 0x48, 0x3A, 
	0x2F, 0x48, 0x40, 0x43, 0x2E, 0x38, 0x31, 0x25, 0x4C, 0x53, 0x49, 0x4A, 0x48, 0x1D, 0x4B, 0x56, 
	0x23, 0x47, 0x4E, 0x42, 0x40, 0x40, 0x54, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9B, 0xB5, 0x4D, 0xC6, 0xD7, 0x4C, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x47, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x54, 
	0xC2, 0xDD, 0x47, 0xC2, 0xD1, 0x53, 0xC2, 0xCF, 0x52, 0xC2, 0xD9, 0x56, 0xCB, 0xE2, 0x29, 0x53, 
	0x5A, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x0B, 0x09, 0x24, 0x4B, 0x52, 0x56, 0xCC, 
	0xE2, 0x52, 0xC2, 0xDA, 0x53, 0xC4, 0xD8, 0x5A, 0xCB, 0xD9, 0x51, 0xC1, 0xD7, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xC9, 0xD9, 0x5D, 
	0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x53, 0xC3, 0xD8, 0x5B, 0xCB, 0xE4, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3D, 0xA0, 0xB8, 0x49, 0xA3, 0xBA, 0x00, 0x06, 0x03, 
	0x6B, 0x5D, 0x4F, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x6D, 0x64, 0x50, 0x4E, 0x47, 0x40, 0x73, 
	0x63, 0x54, 0x73, 0x6A, 0x58, 0x64, 0x5D, 0x5A, 0x6E, 0x67, 0x5D, 0x67, 0x5A, 0x4F, 0x69, 0x5C, 
	0x4E, 0x61, 0x58, 0x4E, 0x3F, 0x49, 0x4A, 0x3C, 0x47, 0x43, 0x0F, 0x37, 0x3F, 0x1D, 0x40, 0x44, 
	0x2A, 0x4D, 0x57, 0x1B, 0x40, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x3B, 0x40, 0x1B, 0x3B, 0x3E, 0x0F, 
	0x36, 0x40, 0x1D, 0x3C, 0x42, 0x1E, 0x2B, 0x34, 0x0F, 0x38, 0x42, 0x23, 0x47, 0x47, 0x0F, 0x36, 
	0x40, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1C, 0x3A, 0x44, 0x23, 
	0x34, 0x38, 0x61, 0x57, 0x4A, 0x4C, 0x43, 0x3B, 0x29, 0x23, 0x1C, 0x25, 0x1C, 0x1C, 0x35, 0x31, 
	0x2C, 0x34, 0x32, 0x29, 0x22, 0x23, 0x29, 0x26, 0x2F, 0x2E, 0x32, 0x3B, 0x36, 0x35, 0x3B, 0x36, 
	0x33, 0x3D, 0x39, 0x39, 0x32, 0x2E, 0x38, 0x39, 0x30, 0x38, 0x31, 0x2E, 0x32, 0x32, 0x2C, 0x1E, 
	0x3B, 0x42, 0x1B, 0x3D, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3F, 0x19, 0x3D, 0x42, 0x37, 0x3B, 
	0x36, 0x33, 0x3D, 0x3B, 0x1E, 0x40, 0x42, 0x24, 0x3E, 0x3D, 0x45, 0x4B, 0x4B, 0x1C, 0x47, 0x4E, 
	0x1A, 0x4A, 0x55, 0x48, 0x44, 0x45, 0x50, 0x47, 0x3F, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB5, 0xC9, 0x4F, 0xC4, 0xD8, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 
	0xCC, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x4A, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD1, 0x50, 0xC2, 0xD1, 0x52, 0xC2, 0xDC, 0x54, 0xC6, 0xD6, 0x46, 0xAF, 0xC4, 0x02, 0x04, 
	0x03, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x06, 0x08, 0x03, 0x47, 0xA4, 
	0xBC, 0x53, 0xCA, 0xE0, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 
	0x50, 0xBF, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x52, 
	0xC3, 0xD9, 0x53, 0xC3, 0xD9, 0x5D, 0xCD, 0xD9, 0x4E, 0xBD, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x4E, 0xBE, 0xD8, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x04, 0x03, 
	0x69, 0x57, 0x4A, 0x61, 0x5B, 0x4B, 0x47, 0x3D, 0x36, 0x4A, 0x42, 0x39, 0x4C, 0x45, 0x3C, 0x69, 
	0x5E, 0x4B, 0x66, 0x63, 0x5E, 0x60, 0x5A, 0x56, 0x5E, 0x56, 0x4F, 0x60, 0x58, 0x52, 0x6A, 0x61, 
	0x52, 0x6A, 0x60, 0x53, 0x54, 0x4F, 0x49, 0x5C, 0x4C, 0x45, 0x14, 0x3B, 0x3E, 0x0E, 0x34, 0x3E, 
	0x1E, 0x42, 0x45, 0x1B, 0x3C, 0x3D, 0x2A, 0x4E, 0x58, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1C, 
	0x3C, 0x40, 0x0F, 0x37, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x20, 0x45, 0x48, 0x22, 0x46, 
	0x48, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1E, 0x31, 0x3A, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 0x39, 0x23, 
	0x39, 0x3E, 0x5D, 0x52, 0x47, 0x7E, 0x6D, 0x5C, 0x48, 0x43, 0x3D, 0x2F, 0x27, 0x1F, 0x35, 0x31, 
	0x2E, 0x2B, 0x1E, 0x18, 0x11, 0x24, 0x25, 0x31, 0x29, 0x24, 0x36, 0x33, 0x2C, 0x38, 0x38, 0x2F, 
	0x38, 0x39, 0x2F, 0x38, 0x2C, 0x2F, 0x33, 0x38, 0x31, 0x36, 0x3D, 0x38, 0x18, 0x39, 0x3F, 0x1C, 
	0x39, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1A, 0x40, 
	0x42, 0x1A, 0x40, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x39, 0x40, 0x57, 0x48, 0x3D, 0x4E, 0x44, 0x40, 
	0x33, 0x50, 0x51, 0x4D, 0x4C, 0x48, 0x59, 0x4F, 0x46, 0x54, 0x4A, 0x3F, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4D, 0xC6, 0xD7, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x52, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 0x55, 0xC2, 0xD9, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD2, 0x52, 0xC2, 0xD0, 0x53, 0xC3, 0xD6, 0x4F, 0xC2, 0xD9, 0x32, 0x70, 0x7D, 0x02, 0x03, 
	0x00, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x0B, 0x0D, 0x0D, 0x16, 0x33, 
	0x36, 0x54, 0xC9, 0xE1, 0x54, 0xC5, 0xDD, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x51, 0xC0, 0xD9, 
	0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD9, 0x50, 
	0xBF, 0xD9, 0x59, 0xC9, 0xD9, 0x51, 0xC1, 0xD9, 0x58, 0xC8, 0xD9, 0x5B, 0xCB, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x59, 0x53, 0x45, 0x73, 0x64, 0x52, 0x4A, 0x43, 0x3A, 0x4E, 0x46, 0x3C, 0x4C, 0x44, 0x3A, 0x59, 
	0x52, 0x49, 0x6A, 0x5E, 0x4B, 0x70, 0x65, 0x52, 0x7C, 0x6F, 0x62, 0x65, 0x5E, 0x52, 0x6F, 0x62, 
	0x51, 0x69, 0x5F, 0x53, 0x47, 0x4A, 0x48, 0x62, 0x59, 0x50, 0x60, 0x55, 0x4D, 0x1C, 0x3D, 0x42, 
	0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x3D, 0x29, 0x4D, 0x57, 0x1B, 0x3C, 0x3D, 0x1D, 0x3D, 0x40, 0x1D, 
	0x3D, 0x40, 0x1F, 0x43, 0x40, 0x1E, 0x3E, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x1C, 0x2B, 
	0x34, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 
	0x1E, 0x2F, 0x38, 0x14, 0x27, 0x28, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x16, 
	0x2B, 0x37, 0x3E, 0x38, 0x2F, 0x77, 0x69, 0x55, 0x42, 0x3F, 0x36, 0x38, 0x38, 0x32, 0x35, 0x33, 
	0x2C, 0x29, 0x23, 0x1E, 0x28, 0x1A, 0x18, 0x3B, 0x36, 0x33, 0x38, 0x3A, 0x30, 0x37, 0x39, 0x30, 
	0x35, 0x31, 0x2C, 0x39, 0x2E, 0x2F, 0x36, 0x35, 0x2F, 0x33, 0x44, 0x44, 0x1A, 0x42, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1B, 0x3F, 0x3E, 0x23, 0x38, 0x3E, 0x56, 0x57, 0x4D, 0x52, 0x48, 0x3D, 
	0x4F, 0x43, 0x3B, 0x50, 0x4D, 0x46, 0x51, 0x4F, 0x49, 0x57, 0x4D, 0x49, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x4B, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x4D, 
	0xC2, 0xD0, 0x52, 0xC2, 0xDB, 0x51, 0xC5, 0xD9, 0x46, 0xAE, 0xC2, 0x02, 0x04, 0x03, 0x08, 0x04, 
	0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x16, 0x16, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x04, 0x04, 
	0x04, 0x40, 0x97, 0xA9, 0x54, 0xC9, 0xDF, 0x5C, 0xCD, 0xDC, 0x5D, 0xCD, 0xD8, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x50, 0xBF, 0xD9, 0x53, 
	0xC3, 0xD9, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5B, 0xCB, 
	0xD7, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x95, 0xA4, 0x0E, 0x0B, 0x11, 
	0x48, 0x3D, 0x3A, 0x6F, 0x64, 0x51, 0x47, 0x3E, 0x37, 0x48, 0x3D, 0x36, 0x4F, 0x46, 0x3D, 0x4C, 
	0x44, 0x3A, 0x4E, 0x45, 0x3D, 0x53, 0x4C, 0x43, 0x82, 0x72, 0x65, 0x74, 0x6A, 0x5E, 0x69, 0x61, 
	0x50, 0x67, 0x5E, 0x53, 0x50, 0x4D, 0x48, 0x5C, 0x54, 0x4C, 0x64, 0x58, 0x4F, 0x2E, 0x46, 0x45, 
	0x0E, 0x35, 0x3F, 0x1D, 0x3D, 0x3E, 0x23, 0x45, 0x4C, 0x1C, 0x40, 0x3E, 0x1D, 0x40, 0x40, 0x1E, 
	0x42, 0x40, 0x11, 0x35, 0x40, 0x12, 0x38, 0x42, 0x1E, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x22, 0x45, 
	0x4A, 0x1D, 0x30, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 
	0x1D, 0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x31, 0x3A, 0x1D, 0x3A, 0x43, 0x1A, 
	0x39, 0x40, 0x36, 0x34, 0x29, 0x44, 0x38, 0x34, 0x46, 0x3E, 0x36, 0x28, 0x20, 0x19, 0x2F, 0x2E, 
	0x24, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x36, 0x34, 0x2C, 0x37, 0x2C, 0x2F, 0x3F, 0x35, 0x33, 
	0x35, 0x2C, 0x2B, 0x37, 0x33, 0x2F, 0x16, 0x38, 0x40, 0x1A, 0x33, 0x3D, 0x1A, 0x3B, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x23, 0x47, 0x4C, 0x20, 0x38, 0x3E, 0x5C, 0x4F, 0x46, 0x63, 0x5B, 0x4A, 
	0x4C, 0x44, 0x3A, 0x4D, 0x44, 0x3A, 0x55, 0x4C, 0x43, 0x57, 0x4D, 0x48, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC6, 0xD5, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 
	0xC2, 0xD4, 0x52, 0xC2, 0xDA, 0x53, 0xCA, 0xDD, 0x35, 0x7E, 0x8B, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x08, 0x08, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0B, 0x15, 
	0x14, 0x16, 0x2A, 0x2A, 0x4E, 0xBF, 0xDB, 0x54, 0xC5, 0xDE, 0x4F, 0xBF, 0xD8, 0x50, 0xC0, 0xD9, 
	0x57, 0xC6, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x59, 0xC9, 0xDC, 0x4F, 0xBE, 0xD7, 0x5D, 
	0xCE, 0xD9, 0x4E, 0xBD, 0xD9, 0x5B, 0xCB, 0xD9, 0x52, 0xC2, 0xD8, 0x52, 0xC3, 0xDA, 0x5A, 0xCA, 
	0xE3, 0x5A, 0xCA, 0xDC, 0x58, 0xCA, 0xE1, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x07, 0x02, 0x00, 
	0x4B, 0x47, 0x3C, 0x52, 0x4A, 0x43, 0x53, 0x4B, 0x40, 0x4D, 0x44, 0x3B, 0x49, 0x3E, 0x37, 0x4A, 
	0x40, 0x38, 0x3B, 0x32, 0x30, 0x47, 0x43, 0x3A, 0x72, 0x65, 0x58, 0x77, 0x67, 0x59, 0x73, 0x65, 
	0x55, 0x71, 0x63, 0x52, 0x5D, 0x54, 0x4D, 0x57, 0x4F, 0x47, 0x63, 0x58, 0x4C, 0x2E, 0x47, 0x4A, 
	0x0E, 0x34, 0x3E, 0x22, 0x46, 0x46, 0x1B, 0x2C, 0x37, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 
	0x42, 0x40, 0x1D, 0x3D, 0x40, 0x12, 0x37, 0x40, 0x1E, 0x3A, 0x3C, 0x1B, 0x30, 0x39, 0x0F, 0x38, 
	0x42, 0x1C, 0x3C, 0x42, 0x1D, 0x2F, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x15, 0x35, 0x3E, 0x2C, 0x2E, 0x29, 0x1B, 0x31, 0x3A, 0x1B, 
	0x36, 0x40, 0x2C, 0x2F, 0x29, 0x39, 0x31, 0x28, 0x5C, 0x54, 0x4B, 0x2C, 0x26, 0x24, 0x32, 0x2A, 
	0x24, 0x2F, 0x30, 0x26, 0x38, 0x34, 0x2E, 0x35, 0x3D, 0x39, 0x36, 0x39, 0x34, 0x37, 0x2C, 0x2F, 
	0x3A, 0x3A, 0x2E, 0x25, 0x3D, 0x44, 0x1B, 0x3C, 0x40, 0x1A, 0x3D, 0x42, 0x36, 0x43, 0x40, 0x1A, 
	0x34, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x39, 
	0x3F, 0x1F, 0x44, 0x45, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4D, 0x47, 0x43, 0x5C, 0x54, 0x46, 
	0x4D, 0x45, 0x3B, 0x48, 0x3D, 0x35, 0x58, 0x50, 0x48, 0x58, 0x4D, 0x4A, 0x1A, 0x1B, 0x1F, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC8, 0x4A, 0xBE, 0xCD, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 0x52, 
	0xC2, 0xDA, 0x53, 0xC3, 0xD8, 0x54, 0xC5, 0xE1, 0x03, 0x07, 0x06, 0x07, 0x03, 0x03, 0x0C, 0x0C, 
	0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x08, 0x08, 
	0x0B, 0x0C, 0x0C, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x12, 
	0x11, 0x0F, 0x11, 0x15, 0x3D, 0x89, 0x98, 0x5A, 0xCF, 0xE4, 0x5B, 0xCC, 0xDB, 0x59, 0xC9, 0xD7, 
	0x4F, 0xBF, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x4F, 0xBF, 0xD7, 0x5D, 0xCD, 0xE4, 0x4E, 
	0xBD, 0xD7, 0x59, 0xC9, 0xD8, 0x5B, 0xCB, 0xD8, 0x51, 0xC2, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 
	0xD9, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x58, 0x51, 0x43, 0x61, 0x59, 0x4A, 0x4D, 0x45, 0x3D, 0x5B, 0x53, 0x49, 0x47, 0x3D, 0x35, 0x4B, 
	0x42, 0x38, 0x4B, 0x40, 0x38, 0x43, 0x3D, 0x34, 0x69, 0x5E, 0x54, 0x6F, 0x61, 0x4F, 0x61, 0x5A, 
	0x49, 0x78, 0x67, 0x55, 0x60, 0x5E, 0x5E, 0x62, 0x5D, 0x56, 0x60, 0x55, 0x48, 0x3F, 0x53, 0x51, 
	0x0F, 0x37, 0x3D, 0x22, 0x4C, 0x52, 0x1F, 0x42, 0x45, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 
	0x3B, 0x40, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x1C, 0x32, 0x3B, 0x1E, 0x37, 0x3C, 0x1F, 0x2B, 
	0x35, 0x11, 0x39, 0x43, 0x1E, 0x2F, 0x37, 0x18, 0x2F, 0x35, 0x1B, 0x2B, 0x32, 0x16, 0x29, 0x2C, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x1D, 0x2E, 0x36, 0x1B, 
	0x37, 0x3F, 0x1E, 0x34, 0x3B, 0x6F, 0x61, 0x55, 0x71, 0x64, 0x56, 0x2B, 0x26, 0x24, 0x31, 0x26, 
	0x22, 0x30, 0x2B, 0x20, 0x2F, 0x2F, 0x29, 0x1F, 0x46, 0x4A, 0x35, 0x3C, 0x37, 0x38, 0x30, 0x2F, 
	0x3D, 0x32, 0x2C, 0x18, 0x3D, 0x43, 0x1D, 0x3D, 0x42, 0x1A, 0x29, 0x34, 0x35, 0x43, 0x42, 0x22, 
	0x42, 0x40, 0x1C, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1E, 0x44, 0x47, 0x30, 0x3F, 0x3F, 0x50, 0x44, 0x3E, 0x60, 0x58, 0x4A, 
	0x4D, 0x45, 0x3B, 0x3B, 0x38, 0x30, 0x58, 0x4F, 0x46, 0x4C, 0x45, 0x39, 0x1B, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC7, 0x4C, 0xC5, 0xD6, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD0, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD3, 0x4E, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 
	0xC1, 0xD9, 0x52, 0xCB, 0xDE, 0x3D, 0x90, 0xA0, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 
	0x13, 0x09, 0x15, 0x14, 0x18, 0x1F, 0x20, 0x4E, 0xBB, 0xD2, 0x5C, 0xCF, 0xE3, 0x5B, 0xCB, 0xE3, 
	0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD9, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xDB, 0x5A, 0xCA, 0xD6, 0x5B, 
	0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 
	0xD7, 0x5B, 0xCB, 0xD8, 0x51, 0xC4, 0xD7, 0x49, 0x9E, 0xB7, 0x3A, 0x95, 0xA5, 0x02, 0x06, 0x04, 
	0x5D, 0x52, 0x45, 0x64, 0x5C, 0x4B, 0x66, 0x5E, 0x4C, 0x5C, 0x54, 0x47, 0x4F, 0x47, 0x3C, 0x3D, 
	0x34, 0x32, 0x4B, 0x42, 0x38, 0x4A, 0x3F, 0x37, 0x43, 0x3D, 0x3C, 0x67, 0x5E, 0x51, 0x59, 0x52, 
	0x4A, 0x6E, 0x60, 0x4E, 0x5E, 0x57, 0x48, 0x6F, 0x65, 0x53, 0x63, 0x5B, 0x49, 0x53, 0x49, 0x42, 
	0x14, 0x2B, 0x37, 0x15, 0x3E, 0x45, 0x23, 0x48, 0x4C, 0x22, 0x40, 0x3F, 0x19, 0x38, 0x3E, 0x33, 
	0x3B, 0x3A, 0x13, 0x36, 0x40, 0x13, 0x38, 0x40, 0x12, 0x39, 0x42, 0x12, 0x39, 0x42, 0x19, 0x33, 
	0x3B, 0x12, 0x39, 0x42, 0x1F, 0x2C, 0x35, 0x0F, 0x3B, 0x44, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1B, 
	0x2E, 0x36, 0x20, 0x34, 0x38, 0x6C, 0x64, 0x5A, 0x8F, 0x7C, 0x6C, 0x5A, 0x52, 0x47, 0x4F, 0x4A, 
	0x47, 0x2B, 0x34, 0x31, 0x18, 0x30, 0x3C, 0x24, 0x4D, 0x55, 0x31, 0x3F, 0x3D, 0x3B, 0x38, 0x2C, 
	0x20, 0x32, 0x38, 0x1C, 0x3D, 0x42, 0x1C, 0x3B, 0x3E, 0x1B, 0x35, 0x38, 0x1A, 0x3D, 0x3F, 0x1C, 
	0x3F, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x28, 0x4C, 0x54, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4E, 0x48, 0x43, 0x5B, 0x52, 0x4A, 
	0x4D, 0x46, 0x3B, 0x4A, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 0x47, 0x43, 0x38, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9C, 0xB5, 0x50, 0xC5, 0xD9, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD1, 0x55, 0xC2, 
	0xDD, 0x47, 0xC2, 0xD0, 0x51, 0xC2, 0xD8, 0x4A, 0xC2, 0xD3, 0x49, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 
	0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x4F, 
	0xC3, 0xD8, 0x53, 0xC5, 0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 
	0x14, 0x08, 0x0F, 0x0E, 0x0D, 0x12, 0x13, 0x31, 0x6B, 0x77, 0x5B, 0xCC, 0xE1, 0x4E, 0xBF, 0xD8, 
	0x5C, 0xCD, 0xD8, 0x4F, 0xBE, 0xD9, 0x50, 0xBF, 0xD8, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xE2, 0x5B, 0xCB, 0xD6, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 0xDA, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x57, 0x50, 0x42, 0x66, 0x5E, 0x4C, 0x59, 0x51, 0x45, 0x4B, 0x43, 0x39, 0x4A, 0x3F, 0x37, 0x31, 
	0x30, 0x2C, 0x4C, 0x42, 0x39, 0x4C, 0x42, 0x39, 0x49, 0x3E, 0x36, 0x51, 0x49, 0x3F, 0x4C, 0x44, 
	0x3B, 0x57, 0x50, 0x47, 0x72, 0x66, 0x54, 0x62, 0x5A, 0x52, 0x66, 0x5D, 0x51, 0x51, 0x4C, 0x45, 
	0x16, 0x28, 0x34, 0x1A, 0x3F, 0x3F, 0x2B, 0x44, 0x46, 0x32, 0x42, 0x42, 0x26, 0x37, 0x3C, 0x36, 
	0x2E, 0x20, 0x18, 0x43, 0x4B, 0x12, 0x37, 0x3F, 0x1A, 0x32, 0x3A, 0x19, 0x33, 0x3B, 0x19, 0x34, 
	0x3C, 0x12, 0x3A, 0x43, 0x1B, 0x31, 0x39, 0x1E, 0x36, 0x3E, 0x1D, 0x3B, 0x45, 0x1D, 0x2F, 0x38, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3A, 0x44, 0x1D, 
	0x2E, 0x36, 0x18, 0x38, 0x42, 0x35, 0x3F, 0x40, 0x8A, 0x79, 0x67, 0x62, 0x58, 0x4D, 0x5D, 0x57, 
	0x50, 0x22, 0x3B, 0x42, 0x1B, 0x3D, 0x40, 0x1E, 0x35, 0x3D, 0x3B, 0x31, 0x2B, 0x3B, 0x38, 0x2E, 
	0x15, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x27, 0x4C, 0x52, 0x27, 0x4D, 0x58, 0x1E, 0x45, 0x49, 0x1C, 
	0x42, 0x44, 0x20, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 
	0x40, 0x1C, 0x36, 0x3E, 0x1B, 0x42, 0x40, 0x23, 0x3F, 0x40, 0x53, 0x47, 0x3E, 0x53, 0x4B, 0x40, 
	0x48, 0x3D, 0x36, 0x4A, 0x40, 0x38, 0x49, 0x3F, 0x37, 0x53, 0x47, 0x3C, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 
	0xD1, 0x4B, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x54, 0xC2, 0xDB, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 
	0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x53, 0xC2, 0xDB, 0x4C, 0xC1, 0xD4, 0x55, 
	0xC9, 0xDD, 0x40, 0x90, 0x9F, 0x03, 0x06, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x11, 
	0x11, 0x16, 0x2C, 0x2C, 0x09, 0x14, 0x13, 0x11, 0x0D, 0x0F, 0x4F, 0xBC, 0xD3, 0x5C, 0xCE, 0xE2, 
	0x51, 0xC1, 0xDB, 0x5C, 0xCC, 0xD8, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 0xD7, 0x5B, 
	0xCB, 0xD8, 0x4F, 0xBE, 0xD9, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD8, 0x50, 0xBF, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x54, 0x4D, 0x42, 0x54, 0x4C, 0x46, 0x62, 0x5A, 0x4A, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3D, 0x40, 
	0x36, 0x33, 0x4D, 0x43, 0x39, 0x2F, 0x34, 0x2B, 0x4B, 0x3F, 0x38, 0x54, 0x4C, 0x43, 0x53, 0x4A, 
	0x40, 0x57, 0x4F, 0x46, 0x6A, 0x5E, 0x4D, 0x5F, 0x57, 0x51, 0x6C, 0x63, 0x50, 0x67, 0x59, 0x4E, 
	0x18, 0x31, 0x3A, 0x0F, 0x37, 0x40, 0x1E, 0x3B, 0x42, 0x36, 0x3C, 0x37, 0x3B, 0x39, 0x2E, 0x32, 
	0x2E, 0x25, 0x20, 0x35, 0x3C, 0x16, 0x3B, 0x42, 0x11, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1E, 0x2F, 
	0x38, 0x1B, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x37, 0x16, 0x28, 0x2A, 0x18, 0x2A, 0x2E, 
	0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3E, 0x44, 0x1D, 
	0x2E, 0x36, 0x1B, 0x2F, 0x38, 0x25, 0x3D, 0x43, 0x68, 0x5B, 0x4F, 0x3E, 0x45, 0x46, 0x49, 0x3B, 
	0x38, 0x12, 0x28, 0x35, 0x19, 0x3D, 0x43, 0x28, 0x42, 0x3F, 0x39, 0x37, 0x2E, 0x3B, 0x38, 0x2E, 
	0x14, 0x36, 0x42, 0x0F, 0x37, 0x40, 0x1A, 0x31, 0x3B, 0x3A, 0x44, 0x40, 0x26, 0x49, 0x51, 0x1A, 
	0x4B, 0x55, 0x20, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x0F, 0x35, 0x40, 0x1E, 0x42, 0x40, 0x1D, 0x3D, 
	0x40, 0x1B, 0x40, 0x3D, 0x1B, 0x3D, 0x40, 0x1E, 0x3B, 0x3E, 0x62, 0x56, 0x4D, 0x4A, 0x42, 0x38, 
	0x4F, 0x47, 0x3D, 0x49, 0x3F, 0x37, 0x4A, 0x3F, 0x38, 0x40, 0x3B, 0x31, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD0, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 
	0x4B, 0xC2, 0xD0, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x54, 
	0xC8, 0xDF, 0x28, 0x51, 0x58, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0C, 0x16, 
	0x16, 0x15, 0x29, 0x29, 0x09, 0x1D, 0x1D, 0x1A, 0x18, 0x19, 0x2C, 0x58, 0x65, 0x53, 0xC7, 0xDF, 
	0x5D, 0xCD, 0xDC, 0x52, 0xC2, 0xD8, 0x50, 0xC0, 0xD9, 0x52, 0xC2, 0xD7, 0x5A, 0xCA, 0xE3, 0x5B, 
	0xCB, 0xD7, 0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD9, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDD, 0x58, 0xCA, 0xDF, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x63, 0x59, 0x4B, 0x54, 0x4C, 0x42, 0x50, 0x48, 0x3E, 0x4A, 0x40, 0x42, 0x4A, 0x40, 0x37, 0x38, 
	0x30, 0x30, 0x4B, 0x42, 0x38, 0x4D, 0x43, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x34, 0x50, 0x48, 0x3C, 0x78, 0x6D, 0x5A, 0x66, 0x63, 0x5D, 0x61, 0x58, 0x4F, 0x64, 0x58, 0x4A, 
	0x2A, 0x39, 0x39, 0x0C, 0x37, 0x42, 0x35, 0x39, 0x35, 0x36, 0x3D, 0x38, 0x38, 0x2F, 0x2E, 0x3A, 
	0x30, 0x33, 0x32, 0x2E, 0x20, 0x20, 0x36, 0x3C, 0x1A, 0x40, 0x40, 0x1B, 0x32, 0x3D, 0x14, 0x25, 
	0x25, 0x14, 0x2B, 0x30, 0x1D, 0x40, 0x44, 0x1D, 0x40, 0x43, 0x1D, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x19, 0x31, 0x39, 0x1C, 0x32, 0x39, 0x60, 0x53, 0x48, 0x44, 0x3A, 0x30, 0x3F, 0x44, 
	0x47, 0x38, 0x3E, 0x39, 0x34, 0x3D, 0x39, 0x2E, 0x2A, 0x1F, 0x39, 0x39, 0x31, 0x38, 0x38, 0x2F, 
	0x36, 0x2E, 0x2E, 0x1B, 0x46, 0x43, 0x1A, 0x37, 0x42, 0x2F, 0x40, 0x40, 0x33, 0x3D, 0x39, 0x24, 
	0x42, 0x42, 0x1D, 0x4B, 0x55, 0x35, 0x3E, 0x3C, 0x1B, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x18, 0x39, 0x3D, 0x39, 0x3B, 0x3E, 0x63, 0x5A, 0x4B, 0x5A, 0x52, 0x48, 
	0x4C, 0x44, 0x3A, 0x4B, 0x42, 0x39, 0x4F, 0x47, 0x3C, 0x57, 0x4C, 0x43, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9A, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xDA, 0x54, 0xC2, 0xDB, 
	0x4C, 0xC2, 0xD2, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xCF, 0x4D, 0xC2, 0xD0, 0x4D, 0xC4, 0xD6, 0x51, 
	0xBD, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x09, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x11, 0x11, 0x16, 0x2B, 
	0x2B, 0x12, 0x29, 0x29, 0x2E, 0x1B, 0x1B, 0x22, 0x15, 0x14, 0x0D, 0x16, 0x18, 0x44, 0xA4, 0xB5, 
	0x5A, 0xCD, 0xE2, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x5C, 0xCD, 0xDB, 0x5B, 0xCB, 0xE0, 0x5B, 
	0xCB, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5B, 0xCB, 
	0xDA, 0x5A, 0xCA, 0xE2, 0x58, 0xCA, 0xDE, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x70, 0x5F, 0x54, 0x65, 0x5C, 0x4D, 0x51, 0x49, 0x42, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x3D, 
	0x35, 0x32, 0x4C, 0x42, 0x39, 0x39, 0x33, 0x30, 0x3C, 0x3A, 0x31, 0x35, 0x36, 0x2E, 0x34, 0x36, 
	0x2E, 0x45, 0x3D, 0x35, 0x66, 0x5D, 0x52, 0x72, 0x63, 0x50, 0x61, 0x59, 0x52, 0x5B, 0x55, 0x4F, 
	0x35, 0x48, 0x47, 0x1B, 0x35, 0x3F, 0x22, 0x3F, 0x42, 0x1D, 0x3D, 0x43, 0x3A, 0x37, 0x34, 0x2E, 
	0x23, 0x15, 0x30, 0x31, 0x27, 0x2E, 0x28, 0x23, 0x1B, 0x49, 0x52, 0x1D, 0x44, 0x40, 0x1E, 0x31, 
	0x3C, 0x16, 0x29, 0x2B, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x37, 0x1B, 0x2E, 0x37, 0x19, 
	0x2A, 0x31, 0x18, 0x35, 0x3E, 0x11, 0x3A, 0x45, 0x33, 0x3A, 0x3A, 0x4E, 0x40, 0x37, 0x51, 0x48, 
	0x42, 0x4E, 0x43, 0x39, 0x49, 0x3F, 0x35, 0x37, 0x2F, 0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2F, 
	0x31, 0x3C, 0x39, 0x1B, 0x2A, 0x36, 0x19, 0x30, 0x39, 0x44, 0x44, 0x40, 0x40, 0x31, 0x2B, 0x24, 
	0x48, 0x4E, 0x1D, 0x4B, 0x54, 0x37, 0x52, 0x52, 0x24, 0x3F, 0x45, 0x1C, 0x3D, 0x3E, 0x1B, 0x3D, 
	0x3D, 0x2A, 0x4E, 0x58, 0x18, 0x3A, 0x3D, 0x39, 0x3C, 0x3F, 0x66, 0x5C, 0x4B, 0x56, 0x4E, 0x43, 
	0x50, 0x48, 0x3F, 0x50, 0x48, 0x42, 0x47, 0x3D, 0x35, 0x53, 0x49, 0x3D, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x39, 0x98, 0xB2, 0x50, 0xC1, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 
	0x54, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC1, 0xD9, 0x57, 
	0xCE, 0xE2, 0x4D, 0xBB, 0xCF, 0x12, 0x2E, 0x32, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x0B, 0x08, 
	0x08, 0x0B, 0x0F, 0x0F, 0x0B, 0x15, 0x15, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x18, 0x2F, 0x2F, 0x07, 0x0E, 0x0E, 0x0E, 0x1D, 
	0x1C, 0x0B, 0x1A, 0x19, 0x19, 0x15, 0x16, 0x0F, 0x12, 0x14, 0x2A, 0x4F, 0x55, 0x44, 0xAB, 0xBE, 
	0x5A, 0xCC, 0xDF, 0x4F, 0xBF, 0xD8, 0x51, 0xC0, 0xD9, 0x50, 0xBF, 0xD8, 0x50, 0xBF, 0xD8, 0x4F, 
	0xBE, 0xD8, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 
	0xE2, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDB, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x71, 0x62, 0x59, 0x66, 0x5E, 0x4D, 0x64, 0x5D, 0x4B, 0x53, 0x4B, 0x43, 0x4E, 0x46, 0x3E, 0x4A, 
	0x40, 0x37, 0x4E, 0x46, 0x3B, 0x39, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x37, 0x37, 0x2F, 0x36, 0x36, 
	0x2F, 0x43, 0x3E, 0x35, 0x62, 0x59, 0x4C, 0x76, 0x6C, 0x59, 0x6A, 0x60, 0x52, 0x51, 0x4B, 0x47, 
	0x1B, 0x31, 0x39, 0x19, 0x3D, 0x40, 0x1C, 0x3E, 0x40, 0x1B, 0x36, 0x40, 0x20, 0x39, 0x3C, 0x33, 
	0x26, 0x1D, 0x30, 0x30, 0x27, 0x2B, 0x30, 0x2A, 0x16, 0x2F, 0x3A, 0x18, 0x3E, 0x42, 0x1D, 0x33, 
	0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1A, 0x2E, 0x37, 0x1F, 0x35, 0x39, 0x24, 0x36, 0x3B, 0x20, 
	0x34, 0x37, 0x15, 0x29, 0x2B, 0x13, 0x24, 0x25, 0x1E, 0x37, 0x42, 0x40, 0x39, 0x2C, 0x46, 0x3C, 
	0x3C, 0x55, 0x4D, 0x43, 0x46, 0x3D, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x3B, 0x3E, 0x11, 0x36, 0x3F, 0x19, 0x2B, 0x36, 0x33, 0x3D, 0x39, 0x39, 0x37, 0x2C, 0x2B, 
	0x3D, 0x3B, 0x12, 0x38, 0x43, 0x20, 0x4C, 0x56, 0x31, 0x43, 0x45, 0x19, 0x42, 0x47, 0x1D, 0x34, 
	0x3E, 0x1B, 0x3B, 0x3D, 0x1C, 0x3B, 0x42, 0x1B, 0x35, 0x3E, 0x4C, 0x3D, 0x33, 0x4F, 0x47, 0x3E, 
	0x6A, 0x62, 0x4E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x40, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9B, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xD7, 0x53, 0xC2, 0xDB, 
	0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4E, 
	0xC1, 0xD1, 0x56, 0xCA, 0xDF, 0x40, 0xA2, 0xB5, 0x2A, 0x67, 0x73, 0x0D, 0x0D, 0x0F, 0x02, 0x00, 
	0x00, 0x06, 0x07, 0x06, 0x07, 0x09, 0x08, 0x09, 0x06, 0x04, 0x09, 0x0E, 0x0D, 0x0B, 0x0D, 0x0D, 
	0x09, 0x0D, 0x0D, 0x09, 0x0D, 0x0D, 0x11, 0x0D, 0x0D, 0x08, 0x0F, 0x0F, 0x09, 0x13, 0x12, 0x09, 
	0x12, 0x12, 0x09, 0x12, 0x12, 0x08, 0x11, 0x11, 0x0D, 0x1B, 0x1A, 0x0E, 0x19, 0x1A, 0x14, 0x0F, 
	0x14, 0x1F, 0x19, 0x16, 0x29, 0x61, 0x6D, 0x3F, 0xA5, 0xBC, 0x56, 0xC9, 0xE1, 0x5A, 0xCD, 0xDD, 
	0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 0xD8, 0x5B, 
	0xCB, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x75, 0x67, 0x56, 0x61, 0x5A, 0x49, 0x53, 0x4C, 0x40, 0x4D, 0x45, 0x40, 0x49, 
	0x3F, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x46, 0x3B, 0x42, 0x39, 0x34, 0x3C, 0x3A, 0x32, 0x3E, 0x3B, 
	0x33, 0x2E, 0x29, 0x27, 0x3D, 0x36, 0x31, 0x6B, 0x61, 0x52, 0x60, 0x5B, 0x57, 0x57, 0x4B, 0x43, 
	0x12, 0x2C, 0x37, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3E, 0x40, 0x25, 0x43, 0x46, 0x38, 
	0x2B, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x25, 0x31, 0x2E, 0x2A, 0x11, 0x39, 0x44, 0x1B, 0x36, 
	0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x14, 0x27, 0x27, 0x19, 0x2A, 0x2F, 0x1E, 0x34, 0x3A, 0x7A, 0x68, 0x59, 0x7D, 0x78, 0x6E, 0x89, 
	0x77, 0x63, 0x60, 0x5D, 0x55, 0x0F, 0x28, 0x2F, 0x12, 0x25, 0x25, 0x1F, 0x39, 0x43, 0x33, 0x38, 
	0x35, 0x57, 0x4D, 0x43, 0x3F, 0x3A, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x38, 0x3B, 0x19, 0x3A, 0x42, 0x2F, 0x3A, 0x39, 0x3F, 0x3A, 0x30, 0x34, 0x36, 0x2E, 0x54, 
	0x42, 0x3A, 0x1D, 0x3C, 0x45, 0x1F, 0x47, 0x4B, 0x36, 0x3B, 0x37, 0x34, 0x44, 0x44, 0x13, 0x3F, 
	0x47, 0x1D, 0x3C, 0x40, 0x1D, 0x29, 0x34, 0x1B, 0x3D, 0x40, 0x1D, 0x45, 0x4A, 0x44, 0x38, 0x2C, 
	0x52, 0x47, 0x42, 0x54, 0x4C, 0x44, 0x5D, 0x55, 0x46, 0x52, 0x4A, 0x42, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x50, 0xC2, 0xD0, 0x52, 0xC2, 0xD0, 0x53, 0xC2, 0xD9, 
	0x4D, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x49, 0xC2, 0xCE, 0x53, 
	0xC2, 0xDB, 0x49, 0xC1, 0xCF, 0x58, 0xCA, 0xDD, 0x54, 0xC7, 0xDE, 0x4C, 0xB5, 0xCB, 0x44, 0x9C, 
	0xAE, 0x29, 0x5D, 0x6A, 0x1A, 0x28, 0x29, 0x07, 0x07, 0x09, 0x06, 0x04, 0x06, 0x02, 0x04, 0x02, 
	0x0C, 0x0E, 0x0C, 0x0C, 0x0F, 0x0D, 0x0B, 0x0F, 0x0D, 0x0E, 0x11, 0x11, 0x0D, 0x13, 0x13, 0x11, 
	0x11, 0x14, 0x0E, 0x0D, 0x11, 0x14, 0x0F, 0x0F, 0x14, 0x23, 0x20, 0x28, 0x56, 0x61, 0x3E, 0x89, 
	0x9A, 0x49, 0xB5, 0xCB, 0x5C, 0xCC, 0xE2, 0x5A, 0xCE, 0xE0, 0x5C, 0xCD, 0xDF, 0x5B, 0xCB, 0xDB, 
	0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xDA, 0x5A, 
	0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD5, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x71, 0x67, 0x55, 0x60, 0x58, 0x48, 0x69, 0x60, 0x4E, 0x4B, 0x43, 0x3F, 0x48, 
	0x3E, 0x38, 0x4F, 0x47, 0x3C, 0x4F, 0x48, 0x3D, 0x3E, 0x35, 0x32, 0x3B, 0x33, 0x31, 0x35, 0x37, 
	0x2E, 0x37, 0x38, 0x2F, 0x3F, 0x3B, 0x33, 0x65, 0x5C, 0x50, 0x5F, 0x57, 0x4F, 0x51, 0x45, 0x38, 
	0x0F, 0x30, 0x3B, 0x18, 0x3D, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x43, 0x31, 0x2F, 0x26, 0x3B, 
	0x30, 0x33, 0x31, 0x30, 0x28, 0x2E, 0x30, 0x25, 0x37, 0x2F, 0x2A, 0x25, 0x37, 0x3B, 0x0F, 0x39, 
	0x42, 0x1B, 0x34, 0x3D, 0x1E, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x15, 0x27, 0x28, 0x12, 0x2A, 0x2B, 0x24, 0x33, 0x35, 0x5B, 0x4F, 0x44, 0x49, 0x50, 0x51, 0x6A, 
	0x66, 0x5D, 0x54, 0x56, 0x55, 0x15, 0x30, 0x35, 0x14, 0x27, 0x2C, 0x0E, 0x3A, 0x44, 0x18, 0x32, 
	0x3B, 0x56, 0x4A, 0x40, 0x3F, 0x3B, 0x34, 0x36, 0x2E, 0x2F, 0x37, 0x38, 0x2F, 0x40, 0x3C, 0x33, 
	0x2B, 0x29, 0x27, 0x22, 0x3D, 0x47, 0x2F, 0x43, 0x43, 0x3F, 0x39, 0x2F, 0x3A, 0x39, 0x31, 0x42, 
	0x3A, 0x31, 0x47, 0x4F, 0x4F, 0x25, 0x45, 0x49, 0x1B, 0x49, 0x4F, 0x33, 0x28, 0x1B, 0x1B, 0x3A, 
	0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x36, 0x42, 0x1B, 0x3A, 0x3D, 0x1A, 0x3F, 0x3D, 0x1C, 0x42, 0x43, 
	0x31, 0x39, 0x3A, 0x4E, 0x44, 0x3F, 0x5B, 0x53, 0x4B, 0x4B, 0x44, 0x38, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 
	0xDB, 0x4D, 0xC2, 0xD0, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDD, 0x50, 0xC2, 0xD0, 0x49, 0xC2, 0xD0, 
	0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x53, 
	0xC2, 0xDA, 0x4C, 0xC1, 0xD4, 0x52, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x53, 0xC5, 0xDD, 0x54, 0xC8, 
	0xDB, 0x54, 0xC7, 0xDD, 0x50, 0xC0, 0xDA, 0x4A, 0xAE, 0xC0, 0x3E, 0x9F, 0xB0, 0x3D, 0x82, 0x94, 
	0x31, 0x6D, 0x7D, 0x27, 0x62, 0x6F, 0x2B, 0x62, 0x6E, 0x31, 0x74, 0x86, 0x33, 0x76, 0x87, 0x38, 
	0x86, 0x97, 0x3E, 0x9E, 0xAF, 0x45, 0xA9, 0xBA, 0x4F, 0xBF, 0xDA, 0x5C, 0xC9, 0xE0, 0x55, 0xCB, 
	0xDF, 0x5A, 0xCD, 0xDF, 0x51, 0xC2, 0xDA, 0x5C, 0xCC, 0xE3, 0x4E, 0xBD, 0xD7, 0x59, 0xC9, 0xD8, 
	0x4F, 0xBE, 0xD7, 0x5B, 0xCB, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x57, 0xCA, 0xDB, 0x3E, 0xA0, 0xB9, 0x3A, 0x94, 0xA3, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x58, 0x71, 0x62, 0x52, 0x5F, 0x58, 0x48, 0x67, 0x5F, 0x4D, 0x4D, 0x45, 0x3E, 0x4D, 
	0x44, 0x40, 0x4D, 0x45, 0x40, 0x4E, 0x45, 0x3E, 0x4D, 0x45, 0x3A, 0x4D, 0x43, 0x39, 0x48, 0x3F, 
	0x37, 0x32, 0x34, 0x2C, 0x48, 0x42, 0x38, 0x6C, 0x62, 0x52, 0x5E, 0x56, 0x4F, 0x53, 0x47, 0x3F, 
	0x18, 0x35, 0x3E, 0x0F, 0x35, 0x3F, 0x1E, 0x43, 0x40, 0x1D, 0x3B, 0x42, 0x15, 0x31, 0x3D, 0x31, 
	0x25, 0x15, 0x3A, 0x30, 0x33, 0x35, 0x30, 0x2C, 0x30, 0x30, 0x25, 0x27, 0x2E, 0x2E, 0x0F, 0x3A, 
	0x44, 0x16, 0x31, 0x37, 0x14, 0x25, 0x25, 0x1B, 0x2E, 0x35, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 
	0x18, 0x30, 0x36, 0x1E, 0x30, 0x3A, 0x1C, 0x32, 0x39, 0x50, 0x44, 0x3E, 0x57, 0x4E, 0x45, 0x58, 
	0x4F, 0x48, 0x5A, 0x51, 0x47, 0x53, 0x44, 0x3D, 0x3D, 0x36, 0x2E, 0x19, 0x33, 0x3D, 0x1C, 0x3C, 
	0x3F, 0x60, 0x54, 0x4B, 0x47, 0x3F, 0x39, 0x3A, 0x33, 0x30, 0x37, 0x38, 0x2F, 0x37, 0x37, 0x2F, 
	0x39, 0x3B, 0x34, 0x30, 0x43, 0x43, 0x2E, 0x3C, 0x3A, 0x30, 0x3C, 0x39, 0x4F, 0x43, 0x39, 0x39, 
	0x38, 0x2F, 0x3B, 0x3A, 0x33, 0x28, 0x44, 0x47, 0x18, 0x49, 0x4E, 0x36, 0x31, 0x26, 0x1A, 0x31, 
	0x3C, 0x1D, 0x3C, 0x40, 0x1B, 0x40, 0x3D, 0x2A, 0x4E, 0x58, 0x29, 0x4C, 0x56, 0x19, 0x3A, 0x3E, 
	0x1E, 0x35, 0x3C, 0x55, 0x4A, 0x40, 0x51, 0x49, 0x3F, 0x58, 0x4E, 0x45, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB0, 0x50, 0xC6, 0xDA, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDB, 0x4E, 0xC2, 0xD4, 0x47, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x4D, 0xC2, 0xD6, 0x54, 0xC2, 0xDC, 
	0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4F, 
	0xC1, 0xD6, 0x59, 0xC7, 0xDD, 0x51, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 
	0xDA, 0x52, 0xC3, 0xDB, 0x53, 0xC4, 0xDC, 0x53, 0xC5, 0xDE, 0x57, 0xCD, 0xE0, 0x54, 0xC9, 0xDD, 
	0x55, 0xCB, 0xE0, 0x56, 0xCD, 0xE1, 0x55, 0xCD, 0xE1, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xDE, 0x54, 
	0xC8, 0xDC, 0x56, 0xCC, 0xE0, 0x5B, 0xCD, 0xE0, 0x5C, 0xCD, 0xE2, 0x5B, 0xCC, 0xDF, 0x5B, 0xCB, 
	0xDB, 0x5A, 0xCA, 0xDD, 0x5B, 0xCB, 0xE3, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xDE, 0x54, 0xC5, 0xDD, 
	0x5C, 0xCC, 0xE3, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 
	0xCA, 0xDA, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xDC, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 
	0xDC, 0x5A, 0xCA, 0xE2, 0x5A, 0xCD, 0xDF, 0x3E, 0x9F, 0xB5, 0x48, 0xA2, 0xBA, 0x00, 0x04, 0x02, 
	0x70, 0x60, 0x57, 0x73, 0x6A, 0x57, 0x65, 0x5D, 0x50, 0x62, 0x5A, 0x49, 0x55, 0x4D, 0x42, 0x57, 
	0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4C, 0x44, 0x40, 0x4A, 0x3F, 0x36, 0x30, 0x34, 0x2B, 0x48, 0x3F, 
	0x36, 0x4D, 0x42, 0x39, 0x4C, 0x44, 0x39, 0x67, 0x62, 0x5B, 0x60, 0x58, 0x50, 0x5A, 0x4F, 0x46, 
	0x48, 0x3D, 0x33, 0x16, 0x3D, 0x48, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x34, 0x1B, 0x38, 0x42, 0x27, 
	0x2F, 0x32, 0x3B, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x26, 0x1C, 0x2C, 0x30, 0x2A, 0x19, 0x37, 
	0x42, 0x12, 0x39, 0x43, 0x1D, 0x33, 0x3C, 0x14, 0x26, 0x26, 0x19, 0x2A, 0x2F, 0x14, 0x2C, 0x31, 
	0x19, 0x36, 0x3F, 0x1A, 0x2B, 0x32, 0x1B, 0x2F, 0x38, 0x1A, 0x2C, 0x32, 0x5C, 0x51, 0x46, 0x67, 
	0x5F, 0x4B, 0x56, 0x4C, 0x44, 0x37, 0x4A, 0x4D, 0x52, 0x46, 0x3E, 0x40, 0x38, 0x30, 0x37, 0x48, 
	0x4A, 0x5E, 0x54, 0x4B, 0x50, 0x48, 0x3D, 0x4F, 0x44, 0x3A, 0x34, 0x35, 0x2C, 0x3A, 0x38, 0x2F, 
	0x25, 0x2F, 0x30, 0x35, 0x3E, 0x3A, 0x36, 0x2E, 0x29, 0x36, 0x37, 0x2E, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x34, 0x35, 0x2A, 0x2B, 0x3B, 0x3C, 0x23, 0x3E, 0x47, 0x18, 0x35, 0x39, 0x1D, 0x3A, 
	0x3E, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1A, 0x3B, 0x3B, 0x29, 0x4E, 0x58, 0x1D, 0x3A, 0x40, 
	0x35, 0x35, 0x2F, 0x4E, 0x43, 0x40, 0x50, 0x48, 0x3D, 0x56, 0x4C, 0x42, 0x1C, 0x20, 0x23, 0x32, 
	0x87, 0x98, 0x45, 0xAE, 0xC5, 0x52, 0xC5, 0xD5, 0x4A, 0xC1, 0xD0, 0x4D, 0xC1, 0xD2, 0x4F, 0xC2, 
	0xD4, 0x50, 0xC2, 0xD5, 0x51, 0xC3, 0xD6, 0x50, 0xC3, 0xD6, 0x50, 0xC2, 0xD4, 0x4F, 0xC1, 0xD4, 
	0x4F, 0xC1, 0xD4, 0x4F, 0xC2, 0xD4, 0x4F, 0xC0, 0xD3, 0x4F, 0xC4, 0xD6, 0x4F, 0xC1, 0xD4, 0x4F, 
	0xC3, 0xD6, 0x51, 0xC3, 0xD5, 0x55, 0xC8, 0xDA, 0x4F, 0xC2, 0xD4, 0x52, 0xC5, 0xD7, 0x4E, 0xC0, 
	0xD3, 0x4F, 0xC2, 0xD4, 0x4E, 0xC0, 0xD3, 0x51, 0xC6, 0xD8, 0x54, 0xC5, 0xD8, 0x56, 0xC8, 0xDB, 
	0x59, 0xCB, 0xDE, 0x57, 0xC6, 0xD9, 0x53, 0xC5, 0xD8, 0x53, 0xC6, 0xD9, 0x59, 0xCB, 0xDE, 0x53, 
	0xCA, 0xDD, 0x59, 0xCA, 0xDD, 0x52, 0xC9, 0xDC, 0x59, 0xCA, 0xDC, 0x4F, 0xC5, 0xD7, 0x52, 0xC5, 
	0xD7, 0x58, 0xCA, 0xDD, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCA, 0xDC, 
	0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 
	0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 
	0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCB, 0xDE, 0x5C, 0xD3, 0xE7, 0x3B, 0x98, 0xA6, 0x00, 0x04, 0x03, 
	0x6F, 0x60, 0x57, 0x75, 0x6C, 0x5A, 0x72, 0x67, 0x56, 0x62, 0x5A, 0x4C, 0x50, 0x48, 0x40, 0x58, 
	0x50, 0x49, 0x4E, 0x46, 0x3D, 0x5E, 0x56, 0x46, 0x4F, 0x47, 0x42, 0x46, 0x3D, 0x34, 0x38, 0x37, 
	0x32, 0x37, 0x37, 0x2E, 0x49, 0x43, 0x38, 0x66, 0x5D, 0x52, 0x67, 0x60, 0x5B, 0x43, 0x49, 0x47, 
	0x1E, 0x33, 0x39, 0x1C, 0x3A, 0x40, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1B, 0x32, 0x3C, 0x2B, 
	0x33, 0x31, 0x2F, 0x26, 0x1A, 0x36, 0x32, 0x30, 0x30, 0x28, 0x1D, 0x31, 0x31, 0x27, 0x29, 0x2E, 
	0x2C, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x34, 0x19, 0x2A, 0x2E, 0x15, 0x25, 0x25, 
	0x19, 0x37, 0x42, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x39, 0x47, 0x3D, 0x31, 0x5D, 
	0x55, 0x48, 0x54, 0x4C, 0x44, 0x57, 0x4D, 0x44, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x46, 0x5A, 0x50, 
	0x47, 0x5E, 0x56, 0x4D, 0x4F, 0x46, 0x3D, 0x4C, 0x4F, 0x4C, 0x48, 0x3C, 0x36, 0x34, 0x37, 0x2F, 
	0x12, 0x2C, 0x3B, 0x3C, 0x36, 0x2E, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x3E, 
	0x3B, 0x33, 0x50, 0x44, 0x3B, 0x3C, 0x37, 0x2C, 0x35, 0x45, 0x45, 0x27, 0x4E, 0x5A, 0x1B, 0x40, 
	0x3D, 0x1B, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x19, 0x3D, 0x3E, 0x36, 0x3B, 0x35, 
	0x4F, 0x40, 0x39, 0x3E, 0x4A, 0x4C, 0x50, 0x47, 0x42, 0x40, 0x34, 0x30, 0x1F, 0x25, 0x26, 0x46, 
	0x90, 0xA5, 0x3A, 0x9A, 0xB3, 0x33, 0x8A, 0xA4, 0x3C, 0x9B, 0xB5, 0x3F, 0xA1, 0xBA, 0x39, 0x96, 
	0xAF, 0x37, 0x92, 0xAB, 0x34, 0x8A, 0xA3, 0x33, 0x89, 0xA2, 0x39, 0x94, 0xAD, 0x3E, 0xA0, 0xB8, 
	0x3E, 0xA0, 0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x38, 0x92, 0xAB, 0x3E, 
	0x9F, 0xB7, 0x3E, 0xA0, 0xB8, 0x35, 0x8E, 0xA7, 0x33, 0x89, 0xA2, 0x36, 0x8E, 0xA7, 0x3F, 0xA1, 
	0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x37, 0x92, 0xAB, 0x3E, 0x9F, 0xB8, 
	0x3D, 0x9F, 0xB8, 0x37, 0x92, 0xAC, 0x3E, 0xA0, 0xB8, 0x37, 0x92, 0xAB, 0x3D, 0x9E, 0xB6, 0x3D, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3E, 0x9E, 0xB6, 0x3D, 0x9E, 
	0xB6, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 
	0x3C, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB6, 0x3C, 0x9D, 0xB6, 0x3D, 0x9D, 0xB5, 0x3C, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 
	0xB5, 0x3C, 0x9E, 0xB6, 0x45, 0x98, 0xB2, 0x31, 0x71, 0x80, 0x3A, 0x95, 0xA9, 0x00, 0x04, 0x03, 
	0x71, 0x62, 0x5A, 0x70, 0x65, 0x54, 0x5D, 0x56, 0x46, 0x63, 0x5B, 0x49, 0x59, 0x51, 0x4A, 0x60, 
	0x58, 0x49, 0x66, 0x5E, 0x4B, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x4D, 0x44, 0x3A, 0x53, 0x4A, 
	0x43, 0x4B, 0x40, 0x45, 0x3B, 0x37, 0x2F, 0x5B, 0x52, 0x46, 0x5F, 0x53, 0x47, 0x27, 0x44, 0x48, 
	0x1E, 0x45, 0x47, 0x1C, 0x42, 0x3F, 0x1D, 0x40, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x19, 
	0x31, 0x3D, 0x33, 0x28, 0x1C, 0x30, 0x26, 0x1B, 0x23, 0x18, 0x1C, 0x32, 0x28, 0x1D, 0x28, 0x2F, 
	0x2F, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1E, 0x2F, 0x38, 0x18, 0x36, 0x3E, 0x19, 0x37, 0x40, 
	0x11, 0x22, 0x1E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x15, 0x28, 0x2A, 0x1A, 0x32, 0x3C, 0x53, 
	0x49, 0x3E, 0x67, 0x5F, 0x4C, 0x5E, 0x56, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5F, 0x57, 
	0x4F, 0x60, 0x58, 0x4F, 0x4F, 0x45, 0x40, 0x3A, 0x4A, 0x4B, 0x4E, 0x4C, 0x4A, 0x28, 0x42, 0x44, 
	0x36, 0x35, 0x30, 0x2F, 0x2B, 0x25, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 0x3B, 0x32, 
	0x32, 0x2C, 0x3A, 0x39, 0x31, 0x50, 0x44, 0x3B, 0x3C, 0x36, 0x2B, 0x26, 0x44, 0x47, 0x26, 0x42, 
	0x47, 0x0E, 0x35, 0x3E, 0x1E, 0x3A, 0x40, 0x1D, 0x32, 0x3C, 0x1A, 0x36, 0x42, 0x34, 0x3B, 0x36, 
	0x4C, 0x3F, 0x36, 0x4F, 0x45, 0x3D, 0x4C, 0x43, 0x39, 0x49, 0x45, 0x39, 0x1C, 0x23, 0x24, 0x6B, 
	0xB4, 0xCC, 0x45, 0xBC, 0xD2, 0x3D, 0x98, 0xAE, 0x46, 0xB3, 0xC5, 0x43, 0xA2, 0xB5, 0x3F, 0x9B, 
	0xB1, 0x3F, 0x9A, 0xB0, 0x47, 0xB8, 0xCE, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB0, 0xC3, 
	0x45, 0xA8, 0xB8, 0x46, 0xB6, 0xCC, 0x45, 0xB4, 0xC9, 0x44, 0xB5, 0xCA, 0x45, 0xB5, 0xCA, 0x45, 
	0xB4, 0xC9, 0x45, 0xB4, 0xC9, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB4, 
	0xC9, 0x46, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x44, 0xB4, 0xC9, 0x45, 0xB6, 0xCC, 0x47, 0xAF, 0xC0, 
	0x4A, 0xB0, 0xC1, 0x46, 0xB3, 0xC5, 0x44, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x43, 0xB4, 0xC9, 0x43, 
	0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB3, 
	0xC9, 0x46, 0xB3, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB5, 0xCC, 
	0x49, 0xB5, 0xCC, 0x42, 0xB4, 0xC9, 0x4F, 0xB4, 0xC6, 0x52, 0xB3, 0xC6, 0x40, 0xB3, 0xC9, 0x49, 
	0xB3, 0xC9, 0x46, 0xB3, 0xC9, 0x42, 0xB3, 0xC9, 0x49, 0xB5, 0xCC, 0x48, 0xB8, 0xCF, 0x48, 0xB3, 
	0xC8, 0x42, 0xB4, 0xC9, 0x48, 0xB5, 0xC9, 0x49, 0xB7, 0xD1, 0x53, 0xC1, 0xDB, 0x00, 0x03, 0x07, 
	0x7F, 0x70, 0x58, 0x71, 0x6A, 0x59, 0x6E, 0x62, 0x52, 0x60, 0x58, 0x47, 0x56, 0x4E, 0x48, 0x6C, 
	0x60, 0x4F, 0x5C, 0x54, 0x46, 0x5A, 0x52, 0x4B, 0x53, 0x4B, 0x42, 0x4F, 0x47, 0x3D, 0x53, 0x4B, 
	0x40, 0x48, 0x3D, 0x37, 0x4C, 0x40, 0x37, 0x3F, 0x3F, 0x3D, 0x57, 0x4A, 0x42, 0x1B, 0x38, 0x3E, 
	0x19, 0x3E, 0x3F, 0x1D, 0x38, 0x3E, 0x1C, 0x2A, 0x34, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x43, 0x1B, 
	0x33, 0x3D, 0x27, 0x20, 0x1F, 0x31, 0x27, 0x1B, 0x27, 0x1D, 0x1C, 0x31, 0x29, 0x1E, 0x28, 0x30, 
	0x30, 0x0F, 0x3A, 0x44, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x32, 0x1E, 0x2F, 0x37, 0x1B, 0x33, 0x3C, 
	0x1F, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x14, 0x28, 0x2B, 0x1C, 
	0x2B, 0x31, 0x5D, 0x52, 0x44, 0x62, 0x5A, 0x53, 0x51, 0x4E, 0x49, 0x52, 0x4F, 0x4A, 0x5D, 0x54, 
	0x4C, 0x5F, 0x57, 0x4F, 0x57, 0x4E, 0x45, 0x46, 0x48, 0x44, 0x50, 0x51, 0x4D, 0x48, 0x3C, 0x35, 
	0x3C, 0x39, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x4C, 
	0x42, 0x39, 0x35, 0x30, 0x2E, 0x3A, 0x39, 0x31, 0x51, 0x43, 0x39, 0x2F, 0x3D, 0x3C, 0x33, 0x3F, 
	0x3E, 0x1E, 0x45, 0x45, 0x1B, 0x3B, 0x3C, 0x12, 0x22, 0x26, 0x1A, 0x40, 0x45, 0x2F, 0x3F, 0x40, 
	0x4C, 0x3E, 0x37, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x36, 0x45, 0x40, 0x37, 0x1F, 0x1D, 0x1F, 0x1C, 
	0x2A, 0x28, 0x20, 0x20, 0x24, 0x22, 0x2E, 0x33, 0x18, 0x28, 0x2A, 0x19, 0x2A, 0x2C, 0x19, 0x2B, 
	0x2C, 0x19, 0x2C, 0x2F, 0x16, 0x28, 0x2B, 0x18, 0x28, 0x2A, 0x19, 0x29, 0x2B, 0x19, 0x29, 0x2B, 
	0x19, 0x2A, 0x2E, 0x19, 0x29, 0x2B, 0x18, 0x2A, 0x2C, 0x27, 0x24, 0x26, 0x1F, 0x28, 0x2A, 0x18, 
	0x29, 0x2B, 0x19, 0x29, 0x2B, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x1C, 0x2B, 
	0x2A, 0x15, 0x28, 0x2A, 0x1E, 0x1E, 0x22, 0x1A, 0x2B, 0x2A, 0x1D, 0x22, 0x23, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x0F, 0x16, 0x1A, 0x25, 0x30, 0x31, 0x29, 0x30, 0x29, 0x22, 0x29, 0x2B, 0x26, 
	0x2E, 0x2B, 0x27, 0x2E, 0x28, 0x28, 0x2F, 0x2A, 0x29, 0x33, 0x2B, 0x29, 0x33, 0x2B, 0x28, 0x32, 
	0x2A, 0x28, 0x32, 0x2A, 0x27, 0x2A, 0x31, 0x27, 0x2F, 0x2E, 0x28, 0x32, 0x2A, 0x29, 0x33, 0x2B, 
	0x27, 0x32, 0x29, 0x25, 0x28, 0x2F, 0x25, 0x2E, 0x2C, 0x25, 0x31, 0x29, 0x28, 0x32, 0x2A, 0x28, 
	0x32, 0x2A, 0x27, 0x31, 0x2A, 0x28, 0x32, 0x2A, 0x28, 0x32, 0x2A, 0x27, 0x31, 0x29, 0x29, 0x31, 
	0x2C, 0x24, 0x29, 0x2E, 0x23, 0x28, 0x2E, 0x27, 0x2C, 0x2C, 0x22, 0x2E, 0x2F, 0x0F, 0x0B, 0x0B, 
	0x7E, 0x71, 0x5E, 0x72, 0x6A, 0x5C, 0x76, 0x6E, 0x5F, 0x71, 0x65, 0x54, 0x5F, 0x58, 0x52, 0x71, 
	0x65, 0x53, 0x5F, 0x58, 0x49, 0x59, 0x51, 0x4A, 0x57, 0x4F, 0x47, 0x4C, 0x43, 0x3B, 0x50, 0x4D, 
	0x46, 0x4D, 0x4A, 0x48, 0x46, 0x3F, 0x35, 0x33, 0x2F, 0x2B, 0x45, 0x3A, 0x30, 0x29, 0x46, 0x48, 
	0x18, 0x3E, 0x40, 0x1D, 0x2C, 0x37, 0x22, 0x44, 0x49, 0x1C, 0x39, 0x3E, 0x1C, 0x2A, 0x34, 0x20, 
	0x47, 0x4A, 0x19, 0x32, 0x3E, 0x33, 0x27, 0x1B, 0x30, 0x27, 0x1C, 0x30, 0x28, 0x1C, 0x20, 0x27, 
	0x2B, 0x16, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x11, 0x23, 0x1F, 
	0x1B, 0x2E, 0x35, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1C, 0x33, 0x3C, 0x1D, 
	0x2B, 0x2E, 0x4E, 0x45, 0x3A, 0x66, 0x5E, 0x54, 0x5B, 0x52, 0x47, 0x4C, 0x49, 0x44, 0x4E, 0x4C, 
	0x47, 0x5A, 0x51, 0x4A, 0x51, 0x4E, 0x48, 0x59, 0x4F, 0x45, 0x4F, 0x4B, 0x49, 0x46, 0x3D, 0x34, 
	0x4A, 0x40, 0x38, 0x36, 0x31, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x35, 
	0x37, 0x2F, 0x38, 0x39, 0x30, 0x35, 0x33, 0x2E, 0x3C, 0x3A, 0x31, 0x3E, 0x37, 0x2C, 0x23, 0x44, 
	0x48, 0x27, 0x4B, 0x56, 0x2E, 0x51, 0x55, 0x3D, 0x4D, 0x4B, 0x49, 0x4C, 0x4B, 0x42, 0x4C, 0x4C, 
	0x48, 0x43, 0x46, 0x49, 0x3E, 0x34, 0x49, 0x3F, 0x40, 0x4B, 0x40, 0x37, 0x42, 0x3E, 0x34, 0x45, 
	0x36, 0x32, 0x42, 0x3D, 0x3A, 0x1E, 0x50, 0x57, 0x1C, 0x43, 0x48, 0x1C, 0x3F, 0x49, 0x22, 0x45, 
	0x4C, 0x1E, 0x34, 0x39, 0x39, 0x3F, 0x3A, 0x22, 0x40, 0x4B, 0x1C, 0x36, 0x39, 0x1C, 0x3D, 0x42, 
	0x1C, 0x36, 0x3A, 0x1C, 0x37, 0x3B, 0x1C, 0x37, 0x3A, 0x14, 0x25, 0x28, 0x16, 0x28, 0x30, 0x20, 
	0x3D, 0x44, 0x1C, 0x3C, 0x3F, 0x23, 0x48, 0x4B, 0x23, 0x43, 0x49, 0x1F, 0x40, 0x49, 0x1B, 0x40, 
	0x4A, 0x24, 0x45, 0x4A, 0x5F, 0x56, 0x4C, 0x73, 0x65, 0x57, 0x73, 0x64, 0x59, 0x7A, 0x6D, 0x5F, 
	0x0F, 0x0C, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x2F, 0x2A, 0x9D, 0x8A, 0x7F, 0x67, 
	0x5A, 0x52, 0x47, 0x3E, 0x35, 0x3A, 0x33, 0x2C, 0x59, 0x4E, 0x48, 0x50, 0x44, 0x39, 0x55, 0x49, 
	0x47, 0x57, 0x4B, 0x3F, 0x65, 0x57, 0x48, 0x5F, 0x54, 0x45, 0x54, 0x48, 0x43, 0x4E, 0x3F, 0x38, 
	0x5B, 0x50, 0x47, 0x7D, 0x6D, 0x58, 0x69, 0x5C, 0x4E, 0x66, 0x5B, 0x4E, 0x59, 0x4E, 0x45, 0x53, 
	0x47, 0x45, 0x61, 0x56, 0x4B, 0x54, 0x48, 0x45, 0x54, 0x48, 0x45, 0x59, 0x4E, 0x45, 0x63, 0x58, 
	0x4A, 0x79, 0x69, 0x58, 0x82, 0x72, 0x5B, 0x75, 0x66, 0x5D, 0x6E, 0x62, 0x54, 0x82, 0x74, 0x61, 
	0x7F, 0x6D, 0x5E, 0x5A, 0x53, 0x45, 0x63, 0x5D, 0x56, 0x73, 0x6C, 0x58, 0x63, 0x5A, 0x51, 0x60, 
	0x59, 0x53, 0x5B, 0x53, 0x49, 0x5A, 0x52, 0x4B, 0x50, 0x47, 0x3C, 0x4A, 0x4C, 0x49, 0x49, 0x4B, 
	0x48, 0x64, 0x5A, 0x4B, 0x5C, 0x53, 0x49, 0x39, 0x37, 0x2E, 0x33, 0x3C, 0x38, 0x1D, 0x3F, 0x48, 
	0x1E, 0x43, 0x3F, 0x18, 0x32, 0x3B, 0x0F, 0x38, 0x40, 0x1B, 0x33, 0x3C, 0x1D, 0x2E, 0x36, 0x1C, 
	0x3F, 0x43, 0x1B, 0x31, 0x3A, 0x27, 0x31, 0x31, 0x31, 0x25, 0x19, 0x32, 0x32, 0x2C, 0x4D, 0x43, 
	0x39, 0x18, 0x22, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1E, 0x33, 0x3C, 0x18, 
	0x2C, 0x37, 0x3A, 0x3F, 0x42, 0x66, 0x5C, 0x4B, 0x5B, 0x52, 0x47, 0x5C, 0x53, 0x4B, 0x5D, 0x54, 
	0x4D, 0x67, 0x5E, 0x4A, 0x44, 0x46, 0x44, 0x51, 0x4D, 0x4A, 0x46, 0x3D, 0x36, 0x31, 0x31, 0x2A, 
	0x36, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x3F, 
	0x3C, 0x34, 0x36, 0x34, 0x2F, 0x4A, 0x40, 0x38, 0x33, 0x36, 0x2E, 0x50, 0x43, 0x3A, 0x4A, 0x3F, 
	0x38, 0x1E, 0x47, 0x4C, 0x15, 0x4B, 0x55, 0x27, 0x47, 0x4F, 0x18, 0x3C, 0x3B, 0x3E, 0x45, 0x45, 
	0x50, 0x42, 0x39, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3F, 0x49, 0x3F, 0x3F, 0x4C, 0x42, 0x38, 0x40, 
	0x3A, 0x31, 0x43, 0x4C, 0x4C, 0x1F, 0x49, 0x53, 0x1C, 0x4A, 0x53, 0x1B, 0x4B, 0x53, 0x2A, 0x49, 
	0x50, 0x35, 0x40, 0x3E, 0x1C, 0x40, 0x3F, 0x1F, 0x3C, 0x46, 0x1C, 0x39, 0x3F, 0x1D, 0x3E, 0x40, 
	0x1D, 0x42, 0x40, 0x1B, 0x3A, 0x3E, 0x29, 0x4E, 0x57, 0x27, 0x49, 0x4D, 0x2E, 0x40, 0x3D, 0x1E, 
	0x4F, 0x58, 0x19, 0x2B, 0x35, 0x28, 0x4B, 0x51, 0x1A, 0x4C, 0x55, 0x2B, 0x4C, 0x56, 0x19, 0x45, 
	0x48, 0x31, 0x48, 0x4E, 0x72, 0x5F, 0x52, 0x70, 0x6A, 0x58, 0x83, 0x71, 0x65, 0x89, 0x7B, 0x69, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x04, 0x06, 0x38, 0x2E, 0x2A, 0xA1, 0x91, 0x84, 0x7A, 
	0x6B, 0x58, 0x72, 0x67, 0x5A, 0x32, 0x32, 0x2A, 0x4C, 0x42, 0x39, 0x50, 0x48, 0x3D, 0x5D, 0x55, 
	0x4D, 0x51, 0x49, 0x40, 0x63, 0x5C, 0x4B, 0x5B, 0x53, 0x49, 0x64, 0x5A, 0x52, 0x33, 0x45, 0x49, 
	0x5F, 0x55, 0x4E, 0x73, 0x68, 0x55, 0x63, 0x5B, 0x53, 0x67, 0x5F, 0x4B, 0x59, 0x51, 0x4A, 0x5C, 
	0x53, 0x4A, 0x5D, 0x53, 0x4A, 0x5C, 0x54, 0x4B, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x56, 0x4E, 
	0x47, 0x5C, 0x54, 0x48, 0x75, 0x65, 0x50, 0x90, 0x7E, 0x6E, 0x72, 0x67, 0x57, 0x7E, 0x6D, 0x64, 
	0x75, 0x6A, 0x5E, 0x6E, 0x66, 0x58, 0x71, 0x67, 0x54, 0x7F, 0x6E, 0x68, 0x66, 0x5D, 0x51, 0x66, 
	0x5D, 0x4A, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x59, 0x50, 0x48, 0x4C, 0x4E, 0x4B, 0x43, 0x3D, 
	0x40, 0x54, 0x4C, 0x46, 0x5B, 0x53, 0x4B, 0x4B, 0x42, 0x38, 0x3A, 0x36, 0x2B, 0x12, 0x33, 0x3E, 
	0x11, 0x38, 0x42, 0x1C, 0x30, 0x38, 0x18, 0x34, 0x3C, 0x1A, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x31, 0x3C, 0x29, 0x1D, 0x16, 0x3F, 0x35, 0x2B, 0x47, 0x5A, 
	0x5C, 0x11, 0x26, 0x2B, 0x19, 0x2A, 0x30, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x12, 0x25, 0x23, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x22, 0x16, 0x29, 0x2C, 0x20, 
	0x35, 0x3C, 0x43, 0x3A, 0x32, 0x57, 0x4D, 0x44, 0x3D, 0x42, 0x46, 0x4F, 0x46, 0x3C, 0x56, 0x54, 
	0x4F, 0x5B, 0x52, 0x4A, 0x4B, 0x4E, 0x4B, 0x54, 0x4B, 0x47, 0x3F, 0x36, 0x31, 0x37, 0x2C, 0x30, 
	0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x35, 0x2C, 0x2C, 0x37, 0x33, 0x30, 0x2E, 0x2C, 0x26, 0x2B, 
	0x2C, 0x23, 0x33, 0x32, 0x2C, 0x51, 0x44, 0x3B, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x3D, 0x3A, 
	0x31, 0x37, 0x37, 0x30, 0x31, 0x43, 0x40, 0x39, 0x51, 0x51, 0x2E, 0x4F, 0x4F, 0x0C, 0x2A, 0x33, 
	0x22, 0x28, 0x29, 0x49, 0x40, 0x37, 0x4A, 0x40, 0x3A, 0x4A, 0x40, 0x3F, 0x47, 0x3C, 0x35, 0x3A, 
	0x32, 0x2A, 0x3D, 0x4E, 0x4E, 0x20, 0x4A, 0x53, 0x1C, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 0x2C, 0x45, 
	0x4A, 0x1D, 0x3F, 0x3E, 0x35, 0x40, 0x40, 0x18, 0x38, 0x3F, 0x1D, 0x36, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1B, 0x39, 0x3D, 0x28, 0x4C, 0x56, 0x2B, 0x45, 0x49, 0x36, 0x40, 0x3F, 0x1C, 
	0x4C, 0x55, 0x1A, 0x3E, 0x45, 0x1C, 0x3F, 0x3D, 0x1B, 0x3D, 0x3B, 0x1B, 0x3E, 0x3C, 0x19, 0x48, 
	0x4F, 0x28, 0x47, 0x4D, 0x74, 0x63, 0x55, 0x6E, 0x68, 0x55, 0x81, 0x6F, 0x60, 0x81, 0x74, 0x64, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x6E, 
	0x62, 0x57, 0x73, 0x68, 0x55, 0x50, 0x48, 0x40, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x57, 0x4F, 
	0x47, 0x5A, 0x52, 0x4A, 0x50, 0x48, 0x40, 0x5D, 0x56, 0x49, 0x79, 0x6A, 0x56, 0x61, 0x57, 0x50, 
	0x61, 0x59, 0x52, 0x60, 0x58, 0x52, 0x62, 0x5A, 0x54, 0x57, 0x4F, 0x48, 0x5B, 0x52, 0x4A, 0x49, 
	0x4A, 0x47, 0x39, 0x48, 0x4B, 0x52, 0x48, 0x3C, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x58, 0x50, 
	0x48, 0x4A, 0x49, 0x43, 0x55, 0x4D, 0x48, 0x84, 0x73, 0x5D, 0x75, 0x6A, 0x64, 0x88, 0x78, 0x65, 
	0x7F, 0x6E, 0x5B, 0x72, 0x6A, 0x5E, 0x72, 0x6B, 0x58, 0x66, 0x5F, 0x51, 0x5D, 0x55, 0x4E, 0x67, 
	0x5E, 0x51, 0x4F, 0x47, 0x40, 0x59, 0x51, 0x48, 0x5A, 0x52, 0x4A, 0x5D, 0x53, 0x4A, 0x56, 0x53, 
	0x4D, 0x49, 0x3F, 0x3E, 0x53, 0x4A, 0x44, 0x34, 0x33, 0x2C, 0x3B, 0x38, 0x2F, 0x28, 0x3E, 0x44, 
	0x0F, 0x37, 0x40, 0x1B, 0x39, 0x42, 0x1D, 0x2B, 0x35, 0x1D, 0x48, 0x44, 0x1D, 0x30, 0x39, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1B, 0x30, 0x3A, 0x32, 0x27, 0x19, 0x39, 0x2E, 0x24, 0x77, 0x6F, 
	0x6B, 0x1C, 0x28, 0x24, 0x13, 0x33, 0x3A, 0x1B, 0x33, 0x3C, 0x1A, 0x2C, 0x33, 0x14, 0x27, 0x28, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1D, 0x31, 0x3B, 0x14, 
	0x2A, 0x32, 0x46, 0x3C, 0x32, 0x51, 0x49, 0x3E, 0x4E, 0x45, 0x3F, 0x4F, 0x44, 0x3F, 0x4F, 0x46, 
	0x3A, 0x55, 0x4D, 0x45, 0x5C, 0x52, 0x48, 0x53, 0x4B, 0x48, 0x40, 0x36, 0x32, 0x2E, 0x2E, 0x26, 
	0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x39, 0x2F, 0x4A, 0x40, 0x38, 0x4B, 0x42, 0x39, 0x37, 
	0x35, 0x30, 0x36, 0x34, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x33, 0x2C, 0x36, 0x36, 
	0x2C, 0x38, 0x38, 0x30, 0x3D, 0x38, 0x2F, 0x4B, 0x44, 0x3C, 0x67, 0x5C, 0x54, 0x22, 0x42, 0x48, 
	0x0D, 0x24, 0x2A, 0x3B, 0x38, 0x2E, 0x47, 0x3F, 0x36, 0x4D, 0x3E, 0x3A, 0x39, 0x50, 0x54, 0x43, 
	0x4A, 0x49, 0x33, 0x50, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4B, 0x54, 0x13, 0x3A, 0x40, 0x40, 0x40, 
	0x3E, 0x1E, 0x40, 0x40, 0x2C, 0x40, 0x40, 0x36, 0x42, 0x40, 0x1A, 0x38, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x46, 0x49, 0x2A, 0x4A, 0x4F, 0x46, 0x4A, 0x49, 0x29, 
	0x4C, 0x50, 0x15, 0x40, 0x4B, 0x1C, 0x42, 0x43, 0x2A, 0x4C, 0x57, 0x19, 0x3C, 0x39, 0x28, 0x4B, 
	0x55, 0x28, 0x42, 0x45, 0x8C, 0x7B, 0x6C, 0x7D, 0x6E, 0x66, 0x81, 0x76, 0x69, 0x7B, 0x6D, 0x60, 
	0x0F, 0x12, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0C, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x75, 
	0x6A, 0x57, 0x67, 0x5E, 0x52, 0x5B, 0x4F, 0x44, 0x55, 0x4D, 0x45, 0x4B, 0x44, 0x3C, 0x49, 0x40, 
	0x38, 0x4F, 0x47, 0x3D, 0x55, 0x4D, 0x45, 0x57, 0x4F, 0x48, 0x64, 0x5C, 0x53, 0x60, 0x59, 0x46, 
	0x71, 0x65, 0x54, 0x61, 0x59, 0x48, 0x64, 0x5C, 0x49, 0x5A, 0x51, 0x4A, 0x5C, 0x53, 0x4A, 0x4E, 
	0x4F, 0x4B, 0x3B, 0x4A, 0x4B, 0x4D, 0x42, 0x3A, 0x5C, 0x54, 0x4C, 0x4F, 0x47, 0x3C, 0x59, 0x51, 
	0x49, 0x59, 0x51, 0x49, 0x4A, 0x43, 0x3B, 0x7A, 0x6A, 0x54, 0x6E, 0x64, 0x55, 0x8C, 0x7A, 0x6C, 
	0x90, 0x7F, 0x6E, 0x8B, 0x79, 0x6A, 0x67, 0x60, 0x56, 0x4E, 0x46, 0x3D, 0x4B, 0x42, 0x3E, 0x4F, 
	0x46, 0x3E, 0x46, 0x42, 0x43, 0x4F, 0x46, 0x3F, 0x63, 0x5B, 0x53, 0x53, 0x4B, 0x42, 0x51, 0x48, 
	0x42, 0x4B, 0x40, 0x3A, 0x48, 0x3F, 0x36, 0x2F, 0x2C, 0x27, 0x2F, 0x2E, 0x23, 0x26, 0x38, 0x3B, 
	0x1A, 0x34, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x2C, 0x35, 0x1A, 0x30, 0x39, 0x1D, 0x31, 0x39, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x24, 0x2F, 0x30, 0x40, 0x34, 0x31, 0x7C, 0x75, 
	0x6B, 0x1B, 0x2F, 0x30, 0x14, 0x2B, 0x30, 0x1A, 0x33, 0x3C, 0x25, 0x30, 0x32, 0x1E, 0x32, 0x3C, 
	0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x19, 0x2C, 0x34, 0x2B, 0x30, 0x2B, 0x19, 
	0x2E, 0x39, 0x28, 0x35, 0x33, 0x50, 0x46, 0x42, 0x51, 0x47, 0x3E, 0x39, 0x4A, 0x4D, 0x4D, 0x48, 
	0x44, 0x5F, 0x55, 0x4B, 0x44, 0x48, 0x46, 0x58, 0x4F, 0x44, 0x3F, 0x3B, 0x38, 0x32, 0x2E, 0x2A, 
	0x39, 0x36, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 
	0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x25, 0x28, 
	0x28, 0x33, 0x33, 0x29, 0x35, 0x37, 0x2F, 0x51, 0x47, 0x3C, 0x5B, 0x51, 0x48, 0x51, 0x57, 0x52, 
	0x25, 0x3F, 0x44, 0x3C, 0x33, 0x2F, 0x33, 0x2B, 0x2B, 0x3B, 0x40, 0x3B, 0x30, 0x5B, 0x64, 0x27, 
	0x51, 0x55, 0x18, 0x3D, 0x45, 0x0F, 0x32, 0x3A, 0x23, 0x4C, 0x55, 0x1C, 0x49, 0x4F, 0x16, 0x39, 
	0x3E, 0x1B, 0x3E, 0x40, 0x1A, 0x37, 0x40, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3E, 0x23, 0x47, 0x4B, 0x28, 0x50, 0x55, 0x4F, 0x4D, 0x4A, 0x23, 
	0x37, 0x3C, 0x19, 0x3D, 0x3D, 0x1F, 0x47, 0x4B, 0x2B, 0x4E, 0x54, 0x27, 0x4B, 0x55, 0x24, 0x4B, 
	0x54, 0x26, 0x40, 0x46, 0x7F, 0x6D, 0x53, 0x80, 0x6E, 0x5F, 0x76, 0x70, 0x6A, 0x86, 0x76, 0x62, 
	0x0F, 0x13, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x77, 
	0x6B, 0x57, 0x56, 0x50, 0x4C, 0x2C, 0x4C, 0x4F, 0x70, 0x60, 0x54, 0x7C, 0x67, 0x55, 0x65, 0x5B, 
	0x4F, 0x63, 0x5C, 0x49, 0x60, 0x58, 0x49, 0x62, 0x5A, 0x54, 0x61, 0x5A, 0x53, 0x61, 0x5A, 0x53, 
	0x68, 0x60, 0x51, 0x59, 0x51, 0x48, 0x57, 0x4E, 0x47, 0x4F, 0x4D, 0x48, 0x53, 0x4B, 0x42, 0x4F, 
	0x45, 0x3C, 0x47, 0x49, 0x45, 0x4F, 0x4C, 0x46, 0x5C, 0x54, 0x4B, 0x4E, 0x46, 0x3F, 0x4D, 0x45, 
	0x3E, 0x59, 0x51, 0x49, 0x5F, 0x57, 0x4C, 0x48, 0x40, 0x38, 0x4C, 0x44, 0x3F, 0x57, 0x4E, 0x43, 
	0x5A, 0x52, 0x4B, 0x80, 0x71, 0x64, 0x6D, 0x62, 0x4F, 0x3D, 0x37, 0x30, 0x4C, 0x43, 0x3E, 0x51, 
	0x48, 0x40, 0x31, 0x34, 0x2A, 0x47, 0x3D, 0x35, 0x4C, 0x43, 0x3C, 0x4D, 0x44, 0x3A, 0x47, 0x3E, 
	0x35, 0x35, 0x34, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2F, 0x25, 0x2F, 0x2E, 0x24, 0x2F, 0x38, 0x36, 
	0x13, 0x3B, 0x43, 0x1D, 0x37, 0x40, 0x1D, 0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x2E, 0x39, 0x30, 0x29, 0x5C, 0x55, 
	0x4B, 0x16, 0x2B, 0x2F, 0x14, 0x27, 0x29, 0x1B, 0x2C, 0x33, 0x1A, 0x2E, 0x34, 0x13, 0x26, 0x26, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1C, 0x30, 0x3A, 0x1D, 
	0x32, 0x39, 0x4A, 0x44, 0x3D, 0x52, 0x49, 0x3E, 0x58, 0x4F, 0x45, 0x49, 0x4B, 0x47, 0x4B, 0x4E, 
	0x4B, 0x52, 0x4E, 0x48, 0x53, 0x49, 0x3D, 0x4D, 0x44, 0x40, 0x47, 0x3E, 0x3D, 0x2C, 0x25, 0x1D, 
	0x32, 0x31, 0x2A, 0x38, 0x39, 0x30, 0x36, 0x37, 0x2F, 0x49, 0x3F, 0x37, 0x3D, 0x3A, 0x32, 0x35, 
	0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x24, 0x28, 
	0x27, 0x3B, 0x3B, 0x32, 0x34, 0x2F, 0x2C, 0x3F, 0x3A, 0x32, 0x54, 0x4B, 0x40, 0x51, 0x48, 0x40, 
	0x6C, 0x60, 0x54, 0x6F, 0x66, 0x5B, 0x40, 0x3C, 0x32, 0x3B, 0x3A, 0x37, 0x6D, 0x6B, 0x6B, 0x5B, 
	0x6F, 0x77, 0x33, 0x5F, 0x6A, 0x12, 0x37, 0x3F, 0x1A, 0x47, 0x4F, 0x1E, 0x4C, 0x56, 0x35, 0x3F, 
	0x3D, 0x1E, 0x3E, 0x3E, 0x20, 0x40, 0x3F, 0x1D, 0x44, 0x46, 0x25, 0x43, 0x4D, 0x1C, 0x3A, 0x3E, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1A, 0x3C, 0x3E, 0x2E, 0x44, 0x46, 0x4E, 0x4E, 0x4B, 0x29, 
	0x44, 0x43, 0x1B, 0x3F, 0x40, 0x1F, 0x3E, 0x46, 0x20, 0x43, 0x4A, 0x25, 0x46, 0x4A, 0x35, 0x3E, 
	0x3C, 0x4B, 0x57, 0x53, 0x88, 0x73, 0x61, 0x8A, 0x78, 0x6B, 0x65, 0x62, 0x55, 0x69, 0x61, 0x53, 
	0x0C, 0x04, 0x07, 0x00, 0x00, 0x00, 0x04, 0x06, 0x06, 0x38, 0x2F, 0x2A, 0xA3, 0x92, 0x82, 0x74, 
	0x66, 0x59, 0x51, 0x50, 0x4D, 0x18, 0x40, 0x47, 0x25, 0x4B, 0x50, 0x69, 0x5D, 0x4F, 0x64, 0x5C, 
	0x53, 0x62, 0x5A, 0x52, 0x62, 0x5A, 0x47, 0x69, 0x60, 0x54, 0x60, 0x58, 0x47, 0x61, 0x57, 0x4F, 
	0x5F, 0x57, 0x47, 0x67, 0x5E, 0x55, 0x56, 0x4F, 0x47, 0x54, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x5D, 
	0x55, 0x4C, 0x57, 0x4E, 0x45, 0x57, 0x4E, 0x46, 0x5D, 0x55, 0x4C, 0x4B, 0x43, 0x38, 0x52, 0x4A, 
	0x3F, 0x50, 0x48, 0x3E, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x5F, 0x56, 0x48, 0x46, 0x48, 0x47, 
	0x25, 0x37, 0x37, 0x74, 0x65, 0x5A, 0x72, 0x69, 0x58, 0x46, 0x3C, 0x34, 0x44, 0x42, 0x3F, 0x4A, 
	0x3F, 0x36, 0x3B, 0x39, 0x31, 0x33, 0x36, 0x2E, 0x34, 0x36, 0x2E, 0x3C, 0x39, 0x31, 0x34, 0x37, 
	0x2E, 0x30, 0x2C, 0x27, 0x34, 0x2F, 0x2B, 0x2F, 0x2F, 0x26, 0x35, 0x32, 0x2C, 0x3C, 0x3A, 0x2F, 
	0x22, 0x35, 0x3B, 0x1C, 0x38, 0x42, 0x1D, 0x38, 0x40, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x39, 0x42, 0x1B, 0x31, 0x39, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x30, 0x33, 0x33, 0x27, 0x4E, 0x4C, 
	0x4B, 0x13, 0x2A, 0x34, 0x11, 0x24, 0x20, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 
	0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x13, 0x26, 0x27, 0x25, 
	0x38, 0x3C, 0x52, 0x53, 0x4F, 0x5D, 0x54, 0x4B, 0x5C, 0x53, 0x4A, 0x5B, 0x52, 0x4A, 0x5D, 0x53, 
	0x4A, 0x45, 0x48, 0x45, 0x54, 0x51, 0x4A, 0x4D, 0x43, 0x3E, 0x4C, 0x50, 0x4C, 0x43, 0x39, 0x36, 
	0x37, 0x30, 0x2F, 0x38, 0x30, 0x30, 0x34, 0x37, 0x2E, 0x4F, 0x43, 0x3A, 0x31, 0x34, 0x2B, 0x51, 
	0x44, 0x3B, 0x33, 0x36, 0x2E, 0x52, 0x45, 0x3C, 0x36, 0x37, 0x2C, 0x36, 0x31, 0x2E, 0x35, 0x32, 
	0x2B, 0x2C, 0x2E, 0x24, 0x32, 0x2C, 0x29, 0x3C, 0x3A, 0x34, 0x4D, 0x44, 0x3C, 0x47, 0x3D, 0x3F, 
	0x51, 0x49, 0x3F, 0x77, 0x6E, 0x5C, 0x3C, 0x35, 0x33, 0x34, 0x32, 0x2B, 0x43, 0x3F, 0x38, 0x57, 
	0x49, 0x3E, 0x32, 0x54, 0x55, 0x18, 0x46, 0x4E, 0x13, 0x38, 0x40, 0x1F, 0x43, 0x49, 0x39, 0x43, 
	0x42, 0x39, 0x51, 0x50, 0x32, 0x3F, 0x3E, 0x35, 0x42, 0x3F, 0x1A, 0x35, 0x3E, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3E, 0x3E, 0x1D, 0x2F, 0x3A, 0x1C, 0x3B, 0x3F, 0x1E, 0x47, 0x4C, 0x49, 0x4C, 0x4B, 0x2B, 
	0x40, 0x3F, 0x1B, 0x2A, 0x35, 0x1C, 0x30, 0x39, 0x1A, 0x3B, 0x3F, 0x35, 0x3F, 0x3D, 0x29, 0x4B, 
	0x50, 0x29, 0x4A, 0x4F, 0x67, 0x5E, 0x4F, 0x89, 0x77, 0x65, 0x7A, 0x6A, 0x58, 0x5F, 0x56, 0x49, 
	0x0D, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x2B, 0x2A, 0x87, 0x78, 0x68, 0x65, 
	0x5E, 0x4E, 0x5D, 0x51, 0x46, 0x32, 0x42, 0x46, 0x2B, 0x49, 0x4E, 0x6A, 0x5E, 0x53, 0x69, 0x60, 
	0x50, 0x56, 0x4F, 0x48, 0x5D, 0x55, 0x4E, 0x63, 0x5B, 0x54, 0x57, 0x52, 0x49, 0x2A, 0x3F, 0x42, 
	0x5B, 0x55, 0x4F, 0x6C, 0x63, 0x55, 0x58, 0x50, 0x45, 0x4E, 0x43, 0x39, 0x51, 0x49, 0x3E, 0x4D, 
	0x4B, 0x46, 0x57, 0x4F, 0x46, 0x4B, 0x43, 0x3B, 0x52, 0x4A, 0x44, 0x52, 0x4A, 0x3F, 0x57, 0x4F, 
	0x47, 0x51, 0x49, 0x3F, 0x51, 0x47, 0x3F, 0x39, 0x40, 0x3F, 0x5E, 0x55, 0x48, 0x76, 0x6B, 0x59, 
	0x34, 0x44, 0x49, 0x72, 0x66, 0x59, 0x85, 0x72, 0x69, 0x62, 0x57, 0x48, 0x5A, 0x52, 0x47, 0x4F, 
	0x47, 0x3C, 0x40, 0x3B, 0x33, 0x4E, 0x43, 0x3A, 0x3B, 0x39, 0x31, 0x34, 0x36, 0x2E, 0x53, 0x45, 
	0x3C, 0x32, 0x33, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x29, 0x1F, 0x31, 0x2F, 0x28, 
	0x3C, 0x31, 0x2B, 0x1A, 0x33, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x44, 0x16, 0x2E, 0x33, 0x18, 0x32, 0x3C, 0x35, 0x31, 0x23, 0x28, 0x23, 0x1F, 0x51, 0x47, 
	0x46, 0x29, 0x4D, 0x4E, 0x14, 0x2A, 0x2F, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x16, 0x29, 0x2C, 0x1E, 
	0x33, 0x3B, 0x4C, 0x40, 0x34, 0x5A, 0x51, 0x47, 0x4B, 0x4E, 0x4C, 0x5D, 0x53, 0x4A, 0x57, 0x4F, 
	0x47, 0x4D, 0x4A, 0x42, 0x4F, 0x43, 0x3E, 0x55, 0x4B, 0x3F, 0x58, 0x4E, 0x45, 0x4A, 0x43, 0x38, 
	0x36, 0x39, 0x2F, 0x33, 0x2C, 0x27, 0x4C, 0x44, 0x3A, 0x47, 0x3E, 0x36, 0x50, 0x45, 0x3B, 0x3A, 
	0x39, 0x31, 0x37, 0x37, 0x2F, 0x36, 0x36, 0x2C, 0x2F, 0x42, 0x42, 0x39, 0x32, 0x2E, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x39, 0x3A, 0x31, 0x32, 0x30, 0x2A, 0x4C, 0x42, 0x38, 0x49, 0x3F, 0x42, 
	0x45, 0x3B, 0x37, 0x6A, 0x61, 0x53, 0x5B, 0x52, 0x4B, 0x2A, 0x2A, 0x22, 0x44, 0x3B, 0x3B, 0x33, 
	0x4B, 0x4C, 0x43, 0x4D, 0x4B, 0x18, 0x4A, 0x54, 0x1B, 0x4C, 0x55, 0x1E, 0x49, 0x50, 0x18, 0x39, 
	0x3A, 0x18, 0x42, 0x4C, 0x22, 0x3B, 0x3E, 0x22, 0x39, 0x40, 0x1C, 0x37, 0x40, 0x1D, 0x3B, 0x3E, 
	0x1A, 0x4A, 0x54, 0x1D, 0x3C, 0x3E, 0x1D, 0x3F, 0x40, 0x1B, 0x3B, 0x3F, 0x23, 0x3F, 0x47, 0x22, 
	0x42, 0x42, 0x1B, 0x2A, 0x34, 0x25, 0x4C, 0x50, 0x1A, 0x3D, 0x3E, 0x1A, 0x39, 0x3E, 0x24, 0x48, 
	0x4F, 0x2B, 0x55, 0x5A, 0x42, 0x45, 0x45, 0x73, 0x6E, 0x62, 0x84, 0x73, 0x65, 0x58, 0x52, 0x47, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x09, 0x09, 0x0B, 0x35, 0x2A, 0x27, 0x8F, 0x80, 0x70, 0x52, 
	0x4B, 0x45, 0x59, 0x51, 0x4A, 0x60, 0x55, 0x49, 0x5D, 0x52, 0x49, 0x5D, 0x55, 0x4E, 0x63, 0x5C, 
	0x4B, 0x58, 0x50, 0x48, 0x64, 0x5C, 0x55, 0x62, 0x59, 0x4B, 0x4D, 0x4D, 0x4A, 0x30, 0x42, 0x43, 
	0x38, 0x47, 0x4A, 0x59, 0x4F, 0x46, 0x4F, 0x4C, 0x49, 0x2E, 0x38, 0x34, 0x5A, 0x50, 0x48, 0x53, 
	0x4B, 0x42, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3B, 0x4A, 0x40, 0x39, 0x4D, 0x44, 0x3F, 0x58, 0x50, 
	0x47, 0x53, 0x4A, 0x3F, 0x4D, 0x45, 0x3C, 0x09, 0x25, 0x34, 0x55, 0x4A, 0x40, 0x6F, 0x63, 0x53, 
	0x53, 0x48, 0x40, 0x5A, 0x55, 0x4D, 0x7C, 0x6C, 0x5B, 0x74, 0x69, 0x56, 0x53, 0x4B, 0x3F, 0x45, 
	0x3C, 0x38, 0x33, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x43, 0x3C, 0x34, 0x36, 0x37, 0x2F, 0x36, 0x37, 
	0x2F, 0x34, 0x35, 0x2B, 0x28, 0x22, 0x1F, 0x30, 0x32, 0x28, 0x30, 0x29, 0x1F, 0x2F, 0x30, 0x27, 
	0x31, 0x2F, 0x24, 0x18, 0x31, 0x3D, 0x16, 0x36, 0x40, 0x16, 0x3A, 0x45, 0x1A, 0x2E, 0x38, 0x1B, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x1B, 0x31, 0x3A, 0x1E, 0x23, 0x2B, 0x31, 0x31, 0x26, 0x34, 0x32, 
	0x27, 0x1F, 0x36, 0x3E, 0x13, 0x39, 0x43, 0x14, 0x26, 0x25, 0x1E, 0x31, 0x3B, 0x1C, 0x2F, 0x37, 
	0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x18, 
	0x2E, 0x38, 0x37, 0x38, 0x34, 0x43, 0x3C, 0x35, 0x33, 0x3B, 0x3B, 0x4E, 0x4E, 0x4C, 0x68, 0x5F, 
	0x4B, 0x50, 0x45, 0x42, 0x34, 0x48, 0x48, 0x3D, 0x42, 0x40, 0x4D, 0x42, 0x36, 0x3D, 0x37, 0x31, 
	0x3A, 0x35, 0x2C, 0x15, 0x31, 0x3E, 0x2F, 0x1F, 0x1C, 0x2E, 0x36, 0x30, 0x37, 0x2B, 0x2F, 0x37, 
	0x36, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x32, 0x3D, 0x3A, 0x38, 0x32, 0x2F, 0x38, 0x39, 
	0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 0x36, 0x37, 0x2F, 0x47, 0x3E, 0x36, 0x53, 0x4B, 0x3F, 
	0x47, 0x3D, 0x42, 0x58, 0x50, 0x45, 0x6A, 0x62, 0x54, 0x5A, 0x52, 0x46, 0x60, 0x55, 0x4C, 0x32, 
	0x3E, 0x40, 0x2C, 0x3F, 0x3F, 0x26, 0x47, 0x4C, 0x2C, 0x42, 0x44, 0x28, 0x46, 0x4C, 0x2C, 0x3E, 
	0x40, 0x0E, 0x35, 0x3E, 0x1B, 0x3D, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 0x3C, 0x40, 
	0x1E, 0x3E, 0x3E, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 0x2B, 0x35, 0x1C, 
	0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1A, 0x3D, 0x40, 0x38, 0x42, 0x40, 0x1A, 0x3E, 0x3F, 0x1F, 0x43, 
	0x45, 0x20, 0x47, 0x49, 0x43, 0x4A, 0x4B, 0x4C, 0x4C, 0x49, 0x66, 0x62, 0x60, 0x43, 0x45, 0x3D, 
	0x12, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x0D, 0x0E, 0x38, 0x2B, 0x28, 0x8B, 0x79, 0x6B, 0x5C, 
	0x54, 0x47, 0x58, 0x50, 0x49, 0x64, 0x5C, 0x55, 0x59, 0x51, 0x49, 0x59, 0x51, 0x49, 0x59, 0x51, 
	0x49, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x47, 0x4E, 0x4B, 0x45, 0x60, 0x54, 0x4B, 
	0x5D, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x51, 0x48, 0x39, 0x4A, 0x4D, 0x57, 0x4D, 0x45, 0x58, 
	0x50, 0x47, 0x4D, 0x45, 0x3D, 0x5F, 0x57, 0x4E, 0x4D, 0x44, 0x3F, 0x44, 0x40, 0x44, 0x50, 0x48, 
	0x3F, 0x4E, 0x45, 0x40, 0x4D, 0x3F, 0x35, 0x1C, 0x43, 0x45, 0x51, 0x3F, 0x35, 0x3F, 0x3A, 0x33, 
	0x37, 0x37, 0x2F, 0x36, 0x47, 0x48, 0x37, 0x42, 0x40, 0x53, 0x48, 0x3D, 0x4D, 0x43, 0x3A, 0x3A, 
	0x38, 0x30, 0x35, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x3B, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x2F, 0x31, 0x27, 0x30, 0x29, 0x20, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 
	0x2F, 0x2F, 0x26, 0x3A, 0x32, 0x2E, 0x3A, 0x31, 0x2C, 0x37, 0x34, 0x29, 0x37, 0x35, 0x29, 0x2F, 
	0x33, 0x2E, 0x26, 0x23, 0x24, 0x22, 0x2A, 0x2F, 0x32, 0x32, 0x27, 0x30, 0x2A, 0x20, 0x30, 0x31, 
	0x27, 0x27, 0x23, 0x22, 0x1B, 0x32, 0x3C, 0x1C, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x19, 0x2E, 0x35, 0x23, 
	0x30, 0x34, 0x27, 0x2A, 0x27, 0x2E, 0x20, 0x23, 0x31, 0x35, 0x2C, 0x3A, 0x46, 0x45, 0x67, 0x5C, 
	0x4B, 0x5B, 0x4E, 0x42, 0x18, 0x2E, 0x34, 0x12, 0x26, 0x2C, 0x23, 0x38, 0x3C, 0x26, 0x30, 0x31, 
	0x1E, 0x24, 0x20, 0x18, 0x2B, 0x31, 0x14, 0x2B, 0x30, 0x1A, 0x27, 0x2E, 0x36, 0x31, 0x2A, 0x39, 
	0x2E, 0x32, 0x35, 0x36, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 
	0x30, 0x39, 0x38, 0x2E, 0x25, 0x45, 0x49, 0x39, 0x37, 0x2E, 0x34, 0x36, 0x2E, 0x4B, 0x40, 0x38, 
	0x4A, 0x40, 0x36, 0x45, 0x3E, 0x3B, 0x5A, 0x52, 0x46, 0x58, 0x50, 0x48, 0x47, 0x3F, 0x36, 0x36, 
	0x35, 0x2C, 0x38, 0x36, 0x2C, 0x3E, 0x38, 0x31, 0x4F, 0x40, 0x37, 0x4E, 0x3F, 0x36, 0x48, 0x3B, 
	0x30, 0x0F, 0x37, 0x42, 0x12, 0x36, 0x40, 0x1E, 0x44, 0x40, 0x1D, 0x37, 0x40, 0x1E, 0x3D, 0x40, 
	0x0F, 0x36, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x43, 0x1A, 
	0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2A, 0x34, 0x1A, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 
	0x3F, 0x19, 0x37, 0x3F, 0x30, 0x3C, 0x39, 0x3A, 0x45, 0x45, 0x5F, 0x53, 0x49, 0x39, 0x48, 0x47, 
	0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0F, 0x07, 0x08, 0x16, 0x1F, 0x1C, 0x86, 0x79, 0x67, 0x55, 
	0x4E, 0x48, 0x59, 0x51, 0x49, 0x65, 0x5D, 0x55, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x4F, 0x45, 0x3C, 0x4E, 0x4F, 0x4C, 
	0x59, 0x4E, 0x44, 0x5C, 0x52, 0x49, 0x57, 0x4C, 0x42, 0x52, 0x48, 0x3D, 0x65, 0x5D, 0x4D, 0x49, 
	0x40, 0x3A, 0x4C, 0x43, 0x3F, 0x51, 0x49, 0x3E, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3F, 0x51, 0x48, 
	0x3F, 0x45, 0x43, 0x43, 0x4C, 0x40, 0x36, 0x31, 0x3A, 0x36, 0x2B, 0x3D, 0x3E, 0x1B, 0x28, 0x2A, 
	0x15, 0x31, 0x3C, 0x1A, 0x2A, 0x35, 0x18, 0x37, 0x3F, 0x49, 0x3D, 0x34, 0x38, 0x37, 0x30, 0x36, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 0x33, 0x35, 0x2C, 0x38, 0x38, 0x30, 0x36, 0x31, 
	0x2F, 0x39, 0x38, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x32, 0x27, 0x22, 0x13, 0x18, 0x32, 0x34, 0x29, 
	0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x29, 0x1F, 0x2F, 0x30, 0x27, 0x30, 
	0x31, 0x27, 0x31, 0x2B, 0x20, 0x32, 0x33, 0x28, 0x30, 0x28, 0x1E, 0x30, 0x25, 0x1B, 0x30, 0x33, 
	0x29, 0x28, 0x1E, 0x1D, 0x27, 0x19, 0x18, 0x29, 0x26, 0x24, 0x1B, 0x34, 0x3F, 0x14, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x18, 0x2B, 0x31, 0x1A, 0x2E, 0x35, 0x2A, 0x30, 0x2E, 0x1E, 
	0x32, 0x38, 0x2B, 0x24, 0x1E, 0x2B, 0x26, 0x20, 0x28, 0x33, 0x34, 0x18, 0x32, 0x3B, 0x53, 0x52, 
	0x4E, 0x44, 0x47, 0x42, 0x13, 0x27, 0x2C, 0x13, 0x26, 0x25, 0x12, 0x25, 0x25, 0x11, 0x25, 0x25, 
	0x12, 0x27, 0x27, 0x12, 0x25, 0x23, 0x20, 0x33, 0x3E, 0x0D, 0x25, 0x24, 0x33, 0x2A, 0x25, 0x2E, 
	0x2C, 0x22, 0x39, 0x31, 0x32, 0x36, 0x33, 0x2E, 0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 
	0x30, 0x38, 0x2F, 0x30, 0x39, 0x32, 0x2E, 0x37, 0x38, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 
	0x48, 0x3F, 0x37, 0x32, 0x35, 0x2B, 0x46, 0x3D, 0x38, 0x4C, 0x40, 0x37, 0x38, 0x37, 0x30, 0x37, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x32, 0x1D, 0x37, 0x3E, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x3C, 0x40, 
	0x1C, 0x3A, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x40, 0x40, 0x1E, 0x3D, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 
	0x44, 0x43, 0x1D, 0x29, 0x34, 0x1D, 0x3C, 0x45, 0x1D, 0x2A, 0x34, 0x1E, 0x3D, 0x43, 0x0E, 0x37, 
	0x40, 0x23, 0x42, 0x42, 0x32, 0x3B, 0x36, 0x60, 0x54, 0x46, 0x5F, 0x55, 0x4A, 0x43, 0x4A, 0x46, 
	0x00, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x57, 
	0x50, 0x42, 0x5A, 0x52, 0x4B, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5C, 0x53, 0x4B, 0x53, 0x4E, 0x4A, 0x27, 0x40, 0x42, 
	0x3E, 0x3D, 0x3E, 0x34, 0x3E, 0x3E, 0x2B, 0x42, 0x44, 0x4F, 0x49, 0x43, 0x64, 0x5C, 0x4B, 0x58, 
	0x50, 0x49, 0x54, 0x4C, 0x43, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 
	0x42, 0x49, 0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x24, 0x38, 0x3E, 0x19, 0x32, 0x3C, 
	0x1A, 0x32, 0x3A, 0x1A, 0x32, 0x3A, 0x13, 0x2F, 0x3A, 0x51, 0x43, 0x38, 0x4D, 0x42, 0x39, 0x35, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x50, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 
	0x38, 0x31, 0x2C, 0x29, 0x33, 0x33, 0x2A, 0x37, 0x2F, 0x2F, 0x33, 0x34, 0x2A, 0x22, 0x13, 0x18, 
	0x31, 0x32, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x28, 0x30, 0x29, 0x1F, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x23, 0x16, 0x1B, 0x31, 0x28, 0x1C, 0x30, 0x27, 0x1C, 0x30, 0x28, 
	0x1F, 0x31, 0x2F, 0x24, 0x25, 0x1A, 0x1C, 0x27, 0x1B, 0x1B, 0x28, 0x1A, 0x19, 0x25, 0x1E, 0x1E, 
	0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x24, 0x25, 0x29, 0x15, 0x38, 0x44, 0x28, 0x32, 0x31, 0x2F, 
	0x23, 0x1C, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1D, 0x27, 0x25, 0x24, 0x1D, 0x34, 0x3C, 0x51, 0x42, 
	0x3A, 0x2F, 0x47, 0x47, 0x0F, 0x30, 0x35, 0x14, 0x26, 0x25, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 0x28, 0x2A, 0x0F, 0x26, 0x26, 0x26, 0x31, 0x33, 0x30, 
	0x2F, 0x25, 0x37, 0x38, 0x2F, 0x2C, 0x2C, 0x24, 0x39, 0x3A, 0x31, 0x2F, 0x2C, 0x26, 0x35, 0x34, 
	0x2C, 0x38, 0x3A, 0x30, 0x37, 0x2C, 0x2F, 0x3F, 0x3C, 0x33, 0x37, 0x37, 0x2F, 0x35, 0x37, 0x2F, 
	0x34, 0x36, 0x2E, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x3A, 0x3A, 0x31, 0x50, 0x44, 0x3B, 0x35, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x49, 0x3E, 
	0x34, 0x26, 0x3C, 0x42, 0x11, 0x36, 0x40, 0x19, 0x40, 0x40, 0x37, 0x42, 0x3F, 0x1B, 0x3C, 0x40, 
	0x1D, 0x36, 0x40, 0x1E, 0x3F, 0x40, 0x1E, 0x3D, 0x40, 0x0F, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1D, 
	0x31, 0x3A, 0x1D, 0x45, 0x44, 0x1E, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x18, 0x34, 
	0x3C, 0x1A, 0x29, 0x34, 0x2B, 0x3B, 0x44, 0x65, 0x5A, 0x4B, 0x67, 0x5E, 0x57, 0x52, 0x4B, 0x42, 
	0x11, 0x08, 0x09, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x1A, 0x22, 0x1E, 0x84, 0x72, 0x63, 0x4B, 
	0x44, 0x43, 0x55, 0x4D, 0x44, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x5B, 0x53, 0x4B, 0x4C, 0x44, 0x3D, 0x58, 0x4F, 0x47, 0x4E, 0x3D, 0x34, 0x1C, 0x3F, 0x3F, 
	0x20, 0x49, 0x4E, 0x16, 0x37, 0x3F, 0x34, 0x3E, 0x39, 0x3F, 0x42, 0x44, 0x56, 0x4D, 0x45, 0x5C, 
	0x54, 0x4C, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x51, 0x49, 
	0x3F, 0x49, 0x3F, 0x37, 0x4B, 0x40, 0x37, 0x44, 0x3D, 0x33, 0x1C, 0x2A, 0x2C, 0x13, 0x2C, 0x30, 
	0x1E, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x19, 0x2E, 0x38, 0x44, 0x3C, 0x32, 0x4D, 0x43, 0x39, 0x36, 
	0x35, 0x2F, 0x37, 0x30, 0x30, 0x3C, 0x3B, 0x32, 0x33, 0x35, 0x2C, 0x35, 0x37, 0x2F, 0x51, 0x45, 
	0x3B, 0x33, 0x30, 0x2B, 0x38, 0x2F, 0x30, 0x39, 0x2F, 0x31, 0x38, 0x31, 0x30, 0x30, 0x32, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x29, 0x20, 0x30, 0x27, 0x1D, 0x30, 0x32, 0x29, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x31, 0x28, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x20, 0x1D, 0x30, 0x27, 
	0x1C, 0x30, 0x2A, 0x1F, 0x28, 0x22, 0x20, 0x25, 0x1A, 0x1C, 0x2A, 0x24, 0x20, 0x27, 0x1B, 0x1C, 
	0x25, 0x1E, 0x1E, 0x0F, 0x28, 0x28, 0x29, 0x27, 0x27, 0x0C, 0x27, 0x25, 0x28, 0x1E, 0x23, 0x08, 
	0x28, 0x29, 0x27, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x28, 0x1A, 0x19, 0x14, 0x2F, 0x38, 0x2E, 0x37, 
	0x33, 0x1F, 0x33, 0x3D, 0x0F, 0x24, 0x23, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 0x1A, 0x1B, 0x2A, 0x31, 0x2C, 0x2F, 
	0x2F, 0x25, 0x35, 0x35, 0x2C, 0x2E, 0x2E, 0x25, 0x39, 0x37, 0x31, 0x35, 0x2F, 0x2C, 0x38, 0x2F, 
	0x30, 0x38, 0x35, 0x30, 0x38, 0x2F, 0x30, 0x34, 0x30, 0x2B, 0x37, 0x38, 0x30, 0x35, 0x37, 0x2F, 
	0x51, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 0x38, 0x30, 0x29, 0x2A, 0x44, 0x3D, 0x35, 0x36, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x36, 0x2E, 0x3A, 0x39, 0x31, 0x4D, 0x42, 0x39, 0x50, 0x42, 
	0x38, 0x25, 0x42, 0x42, 0x11, 0x37, 0x40, 0x16, 0x30, 0x3A, 0x27, 0x45, 0x48, 0x0F, 0x36, 0x3F, 
	0x1E, 0x37, 0x40, 0x1D, 0x45, 0x42, 0x1B, 0x2C, 0x37, 0x1B, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x0F, 0x3B, 0x44, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 
	0x38, 0x1A, 0x3B, 0x44, 0x2B, 0x39, 0x33, 0x51, 0x46, 0x3C, 0x59, 0x51, 0x49, 0x5E, 0x56, 0x4A, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x75, 0x6F, 0x60, 0x50, 
	0x47, 0x43, 0x58, 0x50, 0x48, 0x59, 0x51, 0x49, 0x66, 0x5E, 0x56, 0x58, 0x50, 0x48, 0x50, 0x47, 
	0x3C, 0x57, 0x4F, 0x46, 0x50, 0x48, 0x3D, 0x5C, 0x54, 0x4D, 0x19, 0x3D, 0x47, 0x1B, 0x3A, 0x3F, 
	0x1C, 0x40, 0x3E, 0x1C, 0x3B, 0x40, 0x1D, 0x35, 0x3D, 0x3B, 0x3E, 0x3F, 0x5E, 0x54, 0x46, 0x55, 
	0x4D, 0x46, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x42, 0x48, 0x3E, 
	0x35, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x45, 0x46, 0x3D, 0x32, 0x12, 0x29, 0x30, 0x18, 0x2A, 0x2E, 
	0x16, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x38, 0x46, 0x3D, 0x33, 0x48, 0x3F, 0x37, 0x31, 
	0x2C, 0x29, 0x33, 0x2F, 0x2A, 0x35, 0x35, 0x2F, 0x53, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x33, 0x33, 0x2A, 0x24, 0x1B, 0x1B, 0x30, 0x32, 0x28, 
	0x30, 0x30, 0x27, 0x30, 0x32, 0x29, 0x30, 0x27, 0x1D, 0x30, 0x28, 0x1E, 0x30, 0x27, 0x1E, 0x31, 
	0x34, 0x2A, 0x23, 0x16, 0x1B, 0x32, 0x2A, 0x1D, 0x26, 0x1D, 0x1D, 0x32, 0x29, 0x1D, 0x30, 0x27, 
	0x1D, 0x30, 0x26, 0x1C, 0x31, 0x28, 0x1C, 0x32, 0x29, 0x1C, 0x25, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x27, 0x1C, 0x1C, 0x2B, 0x1A, 0x1A, 0x29, 0x23, 0x1F, 0x28, 0x1A, 0x1B, 0x2B, 0x20, 0x1D, 0x31, 
	0x2E, 0x25, 0x28, 0x22, 0x1F, 0x28, 0x22, 0x1F, 0x26, 0x1B, 0x1C, 0x2B, 0x20, 0x1C, 0x29, 0x2B, 
	0x29, 0x26, 0x31, 0x32, 0x28, 0x22, 0x1D, 0x0E, 0x27, 0x27, 0x14, 0x2A, 0x2E, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1C, 0x33, 0x3E, 0x32, 0x27, 0x20, 0x39, 0x33, 0x30, 0x35, 
	0x2F, 0x2C, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 
	0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x34, 0x30, 0x3E, 0x3C, 0x33, 0x36, 0x38, 0x2F, 
	0x3C, 0x3A, 0x32, 0x35, 0x37, 0x2E, 0x4E, 0x43, 0x3A, 0x40, 0x3C, 0x34, 0x39, 0x38, 0x30, 0x3C, 
	0x3A, 0x32, 0x35, 0x36, 0x2E, 0x4E, 0x43, 0x3A, 0x4E, 0x43, 0x3A, 0x39, 0x38, 0x30, 0x3E, 0x38, 
	0x2F, 0x26, 0x43, 0x43, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x11, 0x39, 0x42, 
	0x1B, 0x30, 0x38, 0x1B, 0x2E, 0x38, 0x38, 0x48, 0x44, 0x1B, 0x2B, 0x35, 0x1A, 0x33, 0x3B, 0x1D, 
	0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1E, 0x31, 0x39, 0x1D, 0x3B, 0x44, 0x1C, 0x2F, 0x38, 0x18, 0x3D, 
	0x42, 0x1B, 0x39, 0x3B, 0x3F, 0x48, 0x49, 0x4F, 0x45, 0x3F, 0x4F, 0x47, 0x3F, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x76, 0x6C, 0x5D, 0x58, 
	0x50, 0x45, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x57, 0x4F, 0x47, 0x4F, 0x46, 0x3A, 0x47, 0x4A, 
	0x4A, 0x4A, 0x40, 0x3C, 0x5D, 0x53, 0x4B, 0x3E, 0x42, 0x3C, 0x0E, 0x38, 0x3F, 0x1D, 0x3D, 0x3F, 
	0x1D, 0x47, 0x48, 0x1D, 0x40, 0x3F, 0x18, 0x39, 0x42, 0x43, 0x44, 0x3F, 0x66, 0x5C, 0x4B, 0x53, 
	0x4B, 0x43, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x49, 0x3E, 
	0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x37, 0x45, 0x42, 0x3A, 0x0B, 0x20, 0x1E, 0x1E, 0x31, 0x3B, 
	0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1A, 0x2E, 0x38, 0x37, 0x37, 0x2C, 0x4B, 0x42, 0x38, 0x32, 
	0x2E, 0x2A, 0x2C, 0x30, 0x24, 0x39, 0x2E, 0x31, 0x30, 0x33, 0x29, 0x3A, 0x34, 0x32, 0x38, 0x36, 
	0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x39, 0x35, 0x32, 0x2F, 0x28, 0x1D, 0x30, 0x24, 0x1A, 
	0x30, 0x28, 0x1F, 0x30, 0x27, 0x1E, 0x30, 0x33, 0x2A, 0x30, 0x2C, 0x24, 0x30, 0x26, 0x1C, 0x31, 
	0x27, 0x1B, 0x32, 0x29, 0x1D, 0x23, 0x18, 0x1D, 0x33, 0x2A, 0x1C, 0x26, 0x1D, 0x1D, 0x30, 0x27, 
	0x1C, 0x31, 0x2F, 0x25, 0x23, 0x16, 0x1B, 0x2C, 0x2A, 0x25, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x2B, 0x1A, 0x1A, 0x0B, 0x29, 0x29, 0x26, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x32, 
	0x2F, 0x26, 0x2A, 0x1E, 0x1D, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x26, 0x19, 
	0x1A, 0x31, 0x2C, 0x23, 0x1E, 0x34, 0x3C, 0x2C, 0x1E, 0x1B, 0x2A, 0x27, 0x27, 0x12, 0x2A, 0x2E, 
	0x14, 0x2A, 0x2E, 0x0F, 0x26, 0x25, 0x1D, 0x2A, 0x35, 0x31, 0x2E, 0x23, 0x2F, 0x30, 0x26, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3A, 0x35, 0x32, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x31, 0x39, 0x38, 
	0x31, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x31, 0x2F, 0x38, 0x32, 0x30, 
	0x37, 0x39, 0x2F, 0x36, 0x2F, 0x2F, 0x48, 0x40, 0x37, 0x4D, 0x43, 0x39, 0x4E, 0x43, 0x3A, 0x48, 
	0x3F, 0x37, 0x32, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x39, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x38, 0x37, 
	0x2E, 0x2C, 0x3D, 0x37, 0x11, 0x37, 0x42, 0x12, 0x39, 0x42, 0x1B, 0x30, 0x38, 0x1E, 0x3A, 0x43, 
	0x1D, 0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1A, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1C, 0x30, 0x38, 0x1D, 0x3E, 0x43, 0x42, 0x42, 
	0x3E, 0x3F, 0x4B, 0x4E, 0x54, 0x48, 0x3E, 0x4E, 0x45, 0x40, 0x4D, 0x45, 0x3F, 0x5A, 0x52, 0x48, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1E, 0x6F, 0x6B, 0x63, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x55, 0x4D, 0x45, 0x4C, 0x43, 0x3B, 0x4C, 0x4F, 
	0x4C, 0x5E, 0x55, 0x4C, 0x57, 0x4E, 0x46, 0x40, 0x3C, 0x35, 0x0E, 0x34, 0x3F, 0x1D, 0x44, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x45, 0x42, 0x1C, 0x2E, 0x38, 0x1B, 0x30, 0x38, 0x4B, 0x3F, 0x35, 0x53, 
	0x4B, 0x40, 0x50, 0x48, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x40, 0x4B, 0x42, 0x3F, 0x49, 0x3F, 
	0x36, 0x4A, 0x40, 0x37, 0x4D, 0x42, 0x38, 0x2C, 0x3A, 0x38, 0x18, 0x32, 0x3D, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x2E, 0x38, 0x40, 0x3B, 0x31, 0x36, 0x37, 0x2F, 0x35, 
	0x32, 0x2C, 0x39, 0x2F, 0x31, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x27, 0x20, 0x1E, 0x31, 0x30, 
	0x28, 0x37, 0x31, 0x2F, 0x33, 0x34, 0x2A, 0x37, 0x32, 0x2F, 0x2F, 0x31, 0x27, 0x30, 0x32, 0x2A, 
	0x31, 0x26, 0x1B, 0x30, 0x27, 0x1C, 0x29, 0x1E, 0x1A, 0x26, 0x1B, 0x1B, 0x32, 0x2A, 0x1D, 0x23, 
	0x18, 0x1D, 0x31, 0x28, 0x1D, 0x31, 0x28, 0x1C, 0x29, 0x23, 0x1F, 0x27, 0x1C, 0x1B, 0x32, 0x29, 
	0x1C, 0x27, 0x1C, 0x1B, 0x32, 0x30, 0x24, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 
	0x0B, 0x29, 0x29, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x2A, 
	0x18, 0x19, 0x08, 0x29, 0x2A, 0x2E, 0x27, 0x22, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 
	0x1C, 0x28, 0x22, 0x1F, 0x2C, 0x26, 0x1F, 0x28, 0x22, 0x1F, 0x2C, 0x29, 0x23, 0x27, 0x19, 0x1A, 
	0x2F, 0x20, 0x1A, 0x23, 0x23, 0x22, 0x2F, 0x2A, 0x22, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 
	0x30, 0x27, 0x30, 0x30, 0x27, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x2C, 0x2E, 
	0x24, 0x36, 0x31, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x38, 0x39, 0x30, 
	0x37, 0x32, 0x2F, 0x36, 0x30, 0x2F, 0x30, 0x2C, 0x28, 0x36, 0x32, 0x2F, 0x37, 0x38, 0x2C, 0x45, 
	0x37, 0x34, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x3A, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x39, 0x38, 
	0x2F, 0x2A, 0x37, 0x36, 0x0F, 0x38, 0x42, 0x13, 0x39, 0x42, 0x18, 0x34, 0x3C, 0x1E, 0x31, 0x39, 
	0x1D, 0x3A, 0x43, 0x1D, 0x3A, 0x43, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2B, 0x31, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2C, 0x35, 0x1A, 0x3B, 0x44, 0x14, 0x33, 0x3C, 0x2A, 0x34, 0x37, 0x68, 0x5C, 
	0x4A, 0x5B, 0x51, 0x45, 0x4D, 0x45, 0x3F, 0x48, 0x3D, 0x40, 0x50, 0x47, 0x3F, 0x4C, 0x48, 0x3D, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x75, 0x6B, 0x5B, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x4E, 0x45, 0x3D, 0x4E, 0x4B, 
	0x45, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4B, 0x45, 0x3C, 0x31, 0x18, 0x28, 0x35, 0x1D, 0x44, 0x44, 
	0x1A, 0x2F, 0x39, 0x1E, 0x3E, 0x42, 0x1E, 0x32, 0x3A, 0x0C, 0x39, 0x43, 0x2A, 0x31, 0x32, 0x57, 
	0x4D, 0x42, 0x47, 0x3C, 0x40, 0x54, 0x4C, 0x40, 0x48, 0x3E, 0x3F, 0x49, 0x3F, 0x36, 0x4A, 0x40, 
	0x37, 0x4A, 0x40, 0x45, 0x47, 0x3E, 0x34, 0x28, 0x31, 0x32, 0x1C, 0x2F, 0x39, 0x1D, 0x30, 0x38, 
	0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x33, 0x3B, 0x4C, 0x40, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2E, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x2F, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x30, 0x32, 0x27, 0x31, 0x28, 0x1E, 0x31, 0x2A, 0x1F, 
	0x23, 0x18, 0x1C, 0x32, 0x2B, 0x1F, 0x31, 0x34, 0x2A, 0x31, 0x2E, 0x24, 0x23, 0x18, 0x1C, 0x33, 
	0x2B, 0x1D, 0x27, 0x1D, 0x1C, 0x31, 0x2A, 0x1F, 0x31, 0x34, 0x29, 0x32, 0x34, 0x29, 0x27, 0x1E, 
	0x1E, 0x25, 0x1A, 0x1B, 0x32, 0x35, 0x29, 0x2B, 0x28, 0x24, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x0D, 0x28, 0x28, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x28, 0x19, 0x1A, 0x35, 0x35, 0x29, 0x2A, 
	0x25, 0x22, 0x2A, 0x1F, 0x1E, 0x2A, 0x1E, 0x1D, 0x33, 0x37, 0x2B, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 
	0x25, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x24, 0x25, 0x19, 0x1B, 0x29, 0x23, 0x20, 0x27, 0x1C, 0x1B, 
	0x31, 0x29, 0x1E, 0x30, 0x32, 0x27, 0x38, 0x30, 0x30, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3B, 0x35, 0x33, 0x2C, 0x2F, 0x24, 0x3A, 0x35, 0x32, 0x39, 0x37, 
	0x31, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x31, 0x2E, 0x37, 0x39, 0x30, 
	0x3D, 0x3B, 0x32, 0x4A, 0x42, 0x38, 0x30, 0x2C, 0x28, 0x3C, 0x35, 0x2F, 0x15, 0x2E, 0x3A, 0x1D, 
	0x2E, 0x34, 0x30, 0x34, 0x2F, 0x4F, 0x43, 0x39, 0x47, 0x3E, 0x36, 0x36, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x3C, 0x38, 0x2C, 0x14, 0x37, 0x42, 0x19, 0x2C, 0x32, 0x1E, 0x30, 0x38, 0x16, 0x29, 0x2B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x42, 0x1A, 0x2A, 0x30, 0x1D, 0x38, 0x42, 0x1D, 
	0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2C, 0x35, 0x1B, 0x2C, 0x36, 0x2C, 0x32, 0x36, 0x65, 0x5B, 
	0x4D, 0x58, 0x50, 0x46, 0x49, 0x40, 0x3F, 0x49, 0x3F, 0x3B, 0x65, 0x5C, 0x53, 0x3F, 0x4A, 0x47, 
	0x12, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x74, 0x6D, 0x68, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4A, 0x58, 0x50, 0x48, 0x5C, 0x53, 
	0x4B, 0x5C, 0x54, 0x4C, 0x5C, 0x53, 0x4B, 0x52, 0x51, 0x4E, 0x1E, 0x3F, 0x42, 0x15, 0x26, 0x2E, 
	0x1E, 0x2C, 0x36, 0x12, 0x38, 0x42, 0x1A, 0x38, 0x43, 0x12, 0x37, 0x42, 0x32, 0x3A, 0x3A, 0x53, 
	0x49, 0x3E, 0x4B, 0x42, 0x3B, 0x54, 0x4C, 0x42, 0x42, 0x3A, 0x32, 0x4A, 0x40, 0x38, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x37, 0x4D, 0x40, 0x38, 0x33, 0x3E, 0x39, 0x12, 0x27, 0x2B, 0x1B, 0x33, 0x3C, 
	0x1B, 0x33, 0x3C, 0x15, 0x28, 0x2C, 0x2A, 0x33, 0x34, 0x4A, 0x3F, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x30, 
	0x27, 0x31, 0x32, 0x28, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1C, 0x28, 0x1E, 0x1C, 
	0x33, 0x2B, 0x1D, 0x24, 0x19, 0x1C, 0x27, 0x1E, 0x1E, 0x32, 0x29, 0x1C, 0x28, 0x1E, 0x1D, 0x24, 
	0x1A, 0x1C, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x24, 0x18, 0x1A, 0x28, 0x1F, 0x1E, 0x32, 0x35, 
	0x29, 0x25, 0x1A, 0x1B, 0x28, 0x20, 0x1F, 0x32, 0x2B, 0x1F, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x11, 0x28, 0x28, 0x0E, 0x27, 0x28, 0x28, 0x1B, 0x1B, 0x09, 0x2A, 0x2B, 0x2A, 0x1E, 0x1D, 0x32, 
	0x35, 0x29, 0x2C, 0x25, 0x20, 0x08, 0x29, 0x2A, 0x27, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x29, 0x23, 
	0x1F, 0x29, 0x23, 0x20, 0x24, 0x18, 0x1A, 0x2C, 0x2A, 0x25, 0x25, 0x19, 0x1A, 0x32, 0x36, 0x2A, 
	0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2E, 0x2F, 0x25, 0x3A, 0x38, 0x32, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x39, 0x37, 
	0x31, 0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x2F, 0x2E, 0x2B, 0x2E, 0x23, 0x36, 0x31, 0x2E, 
	0x35, 0x35, 0x2F, 0x50, 0x45, 0x3B, 0x37, 0x33, 0x2F, 0x30, 0x2E, 0x2F, 0x1B, 0x31, 0x3B, 0x15, 
	0x29, 0x2C, 0x1E, 0x34, 0x3E, 0x3B, 0x3D, 0x35, 0x4E, 0x42, 0x39, 0x33, 0x36, 0x2E, 0x51, 0x44, 
	0x3B, 0x3F, 0x3A, 0x30, 0x1A, 0x2B, 0x36, 0x16, 0x3C, 0x45, 0x1F, 0x30, 0x39, 0x14, 0x2C, 0x30, 
	0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x38, 0x42, 0x1D, 
	0x2E, 0x36, 0x1D, 0x37, 0x3F, 0x1D, 0x3A, 0x43, 0x1B, 0x39, 0x43, 0x27, 0x2F, 0x2E, 0x5F, 0x53, 
	0x4A, 0x5B, 0x53, 0x45, 0x4F, 0x47, 0x3F, 0x4E, 0x46, 0x3B, 0x5F, 0x57, 0x4F, 0x53, 0x4D, 0x43, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x19, 0x20, 0x1D, 0x86, 0x7A, 0x68, 0x56, 
	0x4E, 0x47, 0x58, 0x50, 0x48, 0x4C, 0x44, 0x3C, 0x53, 0x4B, 0x45, 0x5B, 0x53, 0x4B, 0x52, 0x4A, 
	0x40, 0x50, 0x48, 0x3D, 0x51, 0x49, 0x3E, 0x50, 0x46, 0x3E, 0x51, 0x4F, 0x4B, 0x2C, 0x3E, 0x42, 
	0x14, 0x39, 0x42, 0x1A, 0x32, 0x38, 0x4A, 0x3C, 0x30, 0x24, 0x31, 0x31, 0x3F, 0x49, 0x4B, 0x4F, 
	0x46, 0x3A, 0x47, 0x3C, 0x35, 0x53, 0x4B, 0x42, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x1F, 0x31, 0x38, 0x16, 0x29, 0x2C, 
	0x1C, 0x34, 0x3E, 0x15, 0x29, 0x2E, 0x2F, 0x33, 0x2E, 0x4F, 0x43, 0x3A, 0x35, 0x37, 0x2F, 0x35, 
	0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x32, 
	0x27, 0x23, 0x13, 0x18, 0x32, 0x34, 0x29, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x26, 0x1A, 0x1B, 0x32, 0x35, 0x2A, 0x23, 0x18, 0x1B, 0x32, 0x29, 0x1C, 0x32, 
	0x2B, 0x1F, 0x32, 0x35, 0x2A, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x32, 0x34, 
	0x29, 0x25, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 0x32, 0x28, 0x1B, 0x25, 0x1B, 0x1C, 0x2B, 0x1A, 0x1A, 
	0x0C, 0x28, 0x29, 0x25, 0x1E, 0x1E, 0x29, 0x23, 0x1F, 0x28, 0x1B, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 
	0x1F, 0x1E, 0x33, 0x36, 0x2A, 0x29, 0x16, 0x19, 0x34, 0x31, 0x24, 0x28, 0x20, 0x1F, 0x26, 0x1B, 
	0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x28, 0x20, 0x1F, 0x26, 0x1C, 0x1C, 0x25, 0x18, 0x1A, 
	0x32, 0x34, 0x29, 0x30, 0x32, 0x27, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x2E, 0x30, 0x25, 0x2F, 0x2F, 0x26, 0x36, 0x31, 
	0x2E, 0x38, 0x39, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x38, 0x31, 0x3A, 0x38, 0x32, 0x2F, 0x2C, 0x26, 
	0x36, 0x34, 0x2E, 0x36, 0x38, 0x2F, 0x39, 0x31, 0x30, 0x31, 0x32, 0x30, 0x15, 0x2A, 0x30, 0x19, 
	0x2A, 0x2E, 0x14, 0x28, 0x2C, 0x2F, 0x2B, 0x2C, 0x4F, 0x44, 0x3A, 0x33, 0x36, 0x2E, 0x35, 0x36, 
	0x2E, 0x3E, 0x3E, 0x37, 0x16, 0x31, 0x3B, 0x1C, 0x2B, 0x31, 0x14, 0x27, 0x27, 0x14, 0x2B, 0x30, 
	0x1E, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2B, 0x1B, 
	0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 0x1C, 0x39, 0x42, 0x1D, 0x31, 0x38, 0x42, 0x49, 
	0x47, 0x69, 0x5E, 0x4C, 0x4E, 0x46, 0x3D, 0x59, 0x51, 0x4A, 0x5C, 0x54, 0x4B, 0x58, 0x50, 0x4A, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x56, 
	0x4F, 0x47, 0x5B, 0x53, 0x4B, 0x53, 0x4B, 0x45, 0x4D, 0x45, 0x3D, 0x5C, 0x54, 0x4C, 0x56, 0x4E, 
	0x45, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3F, 0x50, 0x48, 0x40, 0x56, 0x4D, 0x43, 0x53, 0x48, 0x3F, 
	0x50, 0x49, 0x44, 0x4F, 0x4A, 0x45, 0x50, 0x46, 0x42, 0x43, 0x3F, 0x43, 0x4A, 0x3D, 0x33, 0x50, 
	0x48, 0x42, 0x53, 0x4B, 0x42, 0x53, 0x4B, 0x42, 0x48, 0x3D, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x3B, 0x36, 0x2A, 0x11, 0x27, 0x29, 
	0x15, 0x28, 0x29, 0x15, 0x2A, 0x30, 0x33, 0x38, 0x33, 0x50, 0x44, 0x3A, 0x3A, 0x39, 0x31, 0x33, 
	0x30, 0x2B, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x36, 0x30, 0x2E, 0x2C, 0x30, 0x24, 0x35, 0x30, 
	0x2C, 0x30, 0x32, 0x27, 0x30, 0x32, 0x28, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1B, 0x33, 0x36, 0x2A, 
	0x33, 0x36, 0x2A, 0x25, 0x18, 0x1A, 0x32, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x25, 0x1B, 0x1C, 0x26, 
	0x1B, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1F, 0x1E, 0x28, 0x22, 0x1F, 0x32, 0x36, 0x2A, 0x2A, 0x20, 0x1E, 0x0B, 0x28, 0x29, 
	0x35, 0x2F, 0x25, 0x28, 0x1A, 0x1A, 0x2B, 0x28, 0x23, 0x26, 0x1B, 0x1C, 0x28, 0x1B, 0x1B, 0x28, 
	0x1E, 0x1C, 0x29, 0x1E, 0x1E, 0x09, 0x29, 0x2A, 0x26, 0x1F, 0x1D, 0x33, 0x2F, 0x23, 0x28, 0x1A, 
	0x1B, 0x09, 0x2A, 0x2B, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x25, 0x19, 0x1B, 0x24, 0x16, 0x1A, 0x2F, 0x32, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x25, 0x31, 0x2E, 
	0x28, 0x39, 0x3A, 0x31, 0x2F, 0x2E, 0x26, 0x30, 0x2E, 0x27, 0x36, 0x31, 0x2E, 0x39, 0x37, 0x31, 
	0x35, 0x2C, 0x2C, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x30, 0x31, 0x36, 0x31, 0x0E, 0x23, 0x20, 0x19, 
	0x37, 0x43, 0x1A, 0x33, 0x3C, 0x1C, 0x34, 0x3C, 0x4A, 0x3F, 0x35, 0x4E, 0x43, 0x3A, 0x3A, 0x39, 
	0x31, 0x39, 0x36, 0x2B, 0x0F, 0x36, 0x42, 0x19, 0x35, 0x3E, 0x15, 0x25, 0x25, 0x1C, 0x34, 0x3D, 
	0x14, 0x2B, 0x2F, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x14, 
	0x27, 0x27, 0x1F, 0x31, 0x3B, 0x1A, 0x2A, 0x30, 0x1D, 0x3A, 0x43, 0x1B, 0x2C, 0x36, 0x1A, 0x39, 
	0x3E, 0x4B, 0x46, 0x42, 0x62, 0x59, 0x49, 0x54, 0x4C, 0x45, 0x4F, 0x47, 0x3D, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x61, 0x57, 
	0x50, 0x48, 0x58, 0x50, 0x48, 0x5D, 0x55, 0x4D, 0x51, 0x48, 0x3E, 0x56, 0x4E, 0x46, 0x50, 0x48, 
	0x3E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x3F, 0x46, 0x3C, 0x3A, 0x53, 0x4B, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x51, 0x48, 0x40, 0x50, 0x48, 0x42, 0x52, 
	0x4A, 0x40, 0x52, 0x4A, 0x40, 0x4B, 0x42, 0x39, 0x49, 0x3F, 0x36, 0x4A, 0x40, 0x45, 0x4A, 0x40, 
	0x37, 0x44, 0x3D, 0x35, 0x4E, 0x42, 0x38, 0x4B, 0x42, 0x38, 0x45, 0x3D, 0x34, 0x13, 0x29, 0x31, 
	0x12, 0x25, 0x23, 0x18, 0x2C, 0x33, 0x23, 0x1D, 0x1A, 0x3C, 0x39, 0x2E, 0x50, 0x45, 0x3B, 0x4A, 
	0x42, 0x38, 0x34, 0x2F, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x37, 0x30, 
	0x2F, 0x2F, 0x31, 0x27, 0x30, 0x2A, 0x20, 0x31, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x25, 0x18, 0x1A, 
	0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x32, 0x35, 0x29, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x32, 
	0x28, 0x32, 0x2F, 0x23, 0x25, 0x1A, 0x1C, 0x25, 0x18, 0x1B, 0x2A, 0x1D, 0x1A, 0x0D, 0x29, 0x29, 
	0x26, 0x1C, 0x1C, 0x13, 0x26, 0x26, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0B, 0x29, 0x2A, 0x34, 
	0x27, 0x1E, 0x32, 0x2B, 0x1F, 0x27, 0x20, 0x1D, 0x0C, 0x27, 0x28, 0x34, 0x34, 0x28, 0x26, 0x1A, 
	0x1B, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1C, 0x31, 0x27, 0x1B, 0x2F, 0x31, 0x27, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2E, 0x2F, 
	0x25, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x34, 0x31, 0x2B, 0x2C, 0x2E, 0x24, 0x39, 0x3A, 0x31, 
	0x35, 0x34, 0x2C, 0x35, 0x2C, 0x2C, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x29, 0x15, 0x2B, 0x32, 0x11, 
	0x29, 0x2A, 0x15, 0x29, 0x2E, 0x1D, 0x2E, 0x35, 0x37, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4F, 0x43, 
	0x39, 0x4B, 0x3F, 0x36, 0x1E, 0x32, 0x37, 0x18, 0x35, 0x3E, 0x18, 0x36, 0x3E, 0x1B, 0x33, 0x3C, 
	0x15, 0x27, 0x27, 0x11, 0x24, 0x20, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x12, 
	0x24, 0x22, 0x11, 0x2A, 0x2A, 0x1B, 0x32, 0x3B, 0x1D, 0x39, 0x42, 0x1D, 0x2F, 0x37, 0x15, 0x2B, 
	0x33, 0x34, 0x43, 0x44, 0x6B, 0x60, 0x4C, 0x5F, 0x57, 0x4B, 0x58, 0x50, 0x48, 0x5A, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x78, 0x69, 0x4B, 
	0x44, 0x42, 0x4B, 0x43, 0x3B, 0x51, 0x49, 0x3E, 0x4B, 0x49, 0x44, 0x56, 0x4E, 0x45, 0x55, 0x4D, 
	0x44, 0x5C, 0x54, 0x4C, 0x57, 0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 
	0x4B, 0x42, 0x54, 0x4C, 0x43, 0x48, 0x3E, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x22, 0x31, 0x33, 0x4C, 0x3D, 0x36, 0x50, 0x44, 0x3A, 0x1A, 0x2A, 0x2A, 
	0x1B, 0x2F, 0x36, 0x13, 0x26, 0x26, 0x1C, 0x32, 0x3C, 0x16, 0x2F, 0x3B, 0x39, 0x2C, 0x2A, 0x37, 
	0x36, 0x30, 0x4C, 0x43, 0x39, 0x33, 0x33, 0x2B, 0x36, 0x2F, 0x2E, 0x39, 0x36, 0x31, 0x31, 0x30, 
	0x29, 0x30, 0x29, 0x1E, 0x30, 0x26, 0x1B, 0x31, 0x29, 0x1E, 0x32, 0x35, 0x2A, 0x33, 0x36, 0x2A, 
	0x25, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1E, 0x1E, 0x28, 0x19, 0x1A, 0x31, 0x30, 0x27, 0x32, 0x2F, 0x24, 0x26, 0x20, 0x1D, 
	0x09, 0x29, 0x2A, 0x35, 0x26, 0x20, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0E, 0x29, 0x29, 0x0C, 
	0x27, 0x29, 0x32, 0x25, 0x1B, 0x20, 0x1C, 0x1E, 0x0E, 0x27, 0x28, 0x32, 0x2F, 0x26, 0x26, 0x1B, 
	0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2A, 0x27, 0x1E, 0x1E, 
	0x31, 0x2F, 0x25, 0x30, 0x25, 0x1B, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 
	0x2E, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x2E, 0x28, 0x39, 0x37, 0x31, 0x36, 0x35, 0x2E, 0x2C, 0x2F, 0x24, 0x39, 0x33, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x36, 0x30, 0x2A, 0x16, 0x23, 0x26, 0x1A, 
	0x2F, 0x36, 0x24, 0x29, 0x2B, 0x39, 0x31, 0x2B, 0x38, 0x38, 0x30, 0x39, 0x38, 0x2E, 0x2A, 0x37, 
	0x36, 0x4E, 0x42, 0x36, 0x2C, 0x34, 0x33, 0x12, 0x25, 0x26, 0x1F, 0x30, 0x39, 0x1A, 0x2B, 0x31, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1F, 
	0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1A, 0x2B, 0x31, 0x1A, 0x2B, 
	0x31, 0x18, 0x39, 0x43, 0x4D, 0x3F, 0x35, 0x63, 0x5B, 0x4B, 0x5A, 0x52, 0x4B, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x62, 0x58, 
	0x51, 0x49, 0x53, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x50, 0x47, 0x3D, 0x58, 0x50, 0x48, 0x5B, 0x53, 
	0x4B, 0x56, 0x4E, 0x46, 0x50, 0x48, 0x3E, 0x58, 0x50, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 
	0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x47, 0x3D, 0x40, 0x49, 0x3D, 0x36, 0x4C, 0x43, 0x39, 0x48, 
	0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x45, 0x3D, 0x33, 0x11, 0x29, 0x34, 0x1B, 0x2E, 0x32, 0x50, 0x43, 0x37, 0x32, 0x31, 0x2F, 
	0x1B, 0x30, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 0x2B, 0x2B, 0x22, 
	0x1E, 0x1C, 0x38, 0x37, 0x30, 0x39, 0x34, 0x31, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x30, 0x32, 
	0x28, 0x24, 0x18, 0x1B, 0x32, 0x28, 0x1B, 0x24, 0x19, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x25, 0x18, 0x1A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x32, 0x34, 
	0x29, 0x2F, 0x26, 0x22, 0x0D, 0x28, 0x28, 0x15, 0x23, 0x25, 0x30, 0x25, 0x1B, 0x2C, 0x23, 0x1C, 
	0x20, 0x1C, 0x1E, 0x31, 0x33, 0x29, 0x29, 0x23, 0x1F, 0x26, 0x1C, 0x1C, 0x2A, 0x1B, 0x1B, 0x1B, 
	0x23, 0x23, 0x26, 0x19, 0x1B, 0x32, 0x2E, 0x25, 0x0B, 0x28, 0x29, 0x28, 0x1A, 0x1B, 0x26, 0x1C, 
	0x1C, 0x2A, 0x24, 0x20, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1E, 0x1F, 0x33, 0x30, 0x24, 
	0x23, 0x18, 0x1B, 0x31, 0x26, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x26, 
	0x1B, 0x1C, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2F, 0x30, 
	0x26, 0x2F, 0x30, 0x26, 0x31, 0x30, 0x28, 0x37, 0x30, 0x2F, 0x39, 0x2F, 0x31, 0x38, 0x33, 0x30, 
	0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x36, 0x2E, 0x2C, 0x30, 0x33, 0x2C, 0x15, 
	0x2E, 0x3B, 0x31, 0x34, 0x2F, 0x39, 0x39, 0x30, 0x3A, 0x39, 0x30, 0x1D, 0x2F, 0x32, 0x18, 0x2F, 
	0x39, 0x2B, 0x2E, 0x32, 0x1E, 0x35, 0x3D, 0x16, 0x29, 0x2C, 0x16, 0x36, 0x3E, 0x1E, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 
	0x29, 0x2C, 0x14, 0x27, 0x27, 0x1B, 0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 
	0x38, 0x1B, 0x36, 0x3F, 0x1B, 0x35, 0x3C, 0x48, 0x3D, 0x32, 0x5A, 0x52, 0x4A, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x71, 0x63, 0x55, 
	0x4E, 0x40, 0x5A, 0x52, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x4F, 0x47, 0x3D, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x53, 0x4A, 0x3F, 
	0x53, 0x4B, 0x42, 0x52, 0x4A, 0x40, 0x4F, 0x46, 0x3F, 0x3E, 0x4A, 0x4D, 0x4B, 0x3D, 0x33, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x3C, 0x39, 0x30, 0x2A, 0x32, 0x32, 0x0D, 0x23, 0x22, 0x23, 0x30, 0x3A, 0x2C, 0x2C, 0x20, 
	0x19, 0x2E, 0x36, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x15, 0x2A, 0x2E, 0x13, 
	0x2F, 0x39, 0x3B, 0x3A, 0x2F, 0x38, 0x2E, 0x30, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x26, 0x31, 0x29, 
	0x1E, 0x25, 0x19, 0x1B, 0x32, 0x36, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 0x1B, 0x1C, 0x29, 0x20, 
	0x1E, 0x27, 0x24, 0x22, 0x12, 0x27, 0x27, 0x0D, 0x28, 0x28, 0x2C, 0x1D, 0x1B, 0x29, 0x1F, 0x1D, 
	0x26, 0x1B, 0x1C, 0x32, 0x2B, 0x1F, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x32, 0x36, 0x2A, 0x2A, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 
	0x1C, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x28, 0x1F, 0x1C, 0x32, 0x28, 0x1C, 0x29, 0x20, 0x1C, 
	0x27, 0x1D, 0x1C, 0x30, 0x28, 0x1E, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x30, 
	0x31, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x30, 0x2E, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x32, 0x28, 0x29, 0x24, 0x20, 0x30, 0x2B, 0x27, 0x37, 0x33, 0x2F, 0x39, 0x3A, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x3A, 0x30, 0x2C, 0x32, 0x30, 0x3C, 
	0x39, 0x2F, 0x39, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x34, 0x2C, 0x14, 0x20, 0x24, 0x1D, 0x31, 
	0x3A, 0x15, 0x2B, 0x32, 0x34, 0x3A, 0x36, 0x15, 0x2B, 0x34, 0x1B, 0x33, 0x3C, 0x14, 0x2C, 0x30, 
	0x1F, 0x30, 0x3A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2C, 0x36, 0x1A, 0x36, 0x3F, 0x39, 0x3E, 0x40, 0x59, 0x50, 0x46, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1B, 0x22, 0x1E, 0x7E, 0x70, 0x61, 0x5C, 
	0x54, 0x4E, 0x58, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5C, 0x54, 0x4C, 0x50, 0x48, 0x3E, 0x5B, 0x53, 0x4B, 0x4E, 0x44, 0x3E, 0x4F, 0x4B, 0x44, 
	0x4A, 0x3D, 0x34, 0x54, 0x4C, 0x43, 0x4B, 0x42, 0x38, 0x4D, 0x40, 0x3E, 0x3B, 0x4E, 0x51, 0x4B, 
	0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4C, 0x42, 
	0x39, 0x45, 0x3D, 0x34, 0x2B, 0x35, 0x36, 0x0F, 0x24, 0x23, 0x14, 0x28, 0x29, 0x16, 0x2B, 0x32, 
	0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 0x18, 0x2A, 0x2F, 0x1A, 0x2E, 0x34, 0x1F, 0x2C, 0x35, 0x2F, 
	0x1E, 0x13, 0x36, 0x38, 0x2F, 0x37, 0x32, 0x2F, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x20, 
	0x1F, 0x26, 0x1B, 0x1C, 0x28, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1A, 0x1B, 0x32, 0x2B, 0x1F, 0x2A, 0x1F, 
	0x1E, 0x0C, 0x28, 0x28, 0x11, 0x27, 0x27, 0x33, 0x27, 0x20, 0x11, 0x27, 0x27, 0x28, 0x1B, 0x1C, 
	0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1B, 0x1C, 0x2A, 0x1C, 0x1A, 0x33, 0x29, 0x1C, 0x27, 0x1D, 0x1C, 0x29, 0x23, 
	0x20, 0x25, 0x1A, 0x1B, 0x28, 0x22, 0x20, 0x28, 0x20, 0x1F, 0x31, 0x2A, 0x1F, 0x31, 0x28, 0x1C, 
	0x31, 0x27, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x31, 
	0x2E, 0x27, 0x1F, 0x1E, 0x26, 0x1B, 0x1C, 0x25, 0x1A, 0x1B, 0x2A, 0x26, 0x20, 0x2F, 0x29, 0x26, 
	0x39, 0x37, 0x31, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x39, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x2F, 0x2F, 0x37, 0x35, 0x14, 0x31, 
	0x3D, 0x16, 0x2C, 0x38, 0x43, 0x3C, 0x31, 0x2E, 0x2A, 0x27, 0x18, 0x2E, 0x36, 0x11, 0x23, 0x1E, 
	0x18, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x12, 0x25, 0x24, 0x1D, 0x30, 
	0x3A, 0x25, 0x38, 0x3D, 0x4E, 0x40, 0x34, 0x4F, 0x44, 0x3F, 0x4F, 0x47, 0x44, 0x5D, 0x54, 0x48, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x64, 0x59, 
	0x52, 0x4C, 0x65, 0x5D, 0x49, 0x59, 0x51, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x4A, 0x66, 0x5E, 
	0x4A, 0x5A, 0x52, 0x4B, 0x51, 0x49, 0x3E, 0x54, 0x4B, 0x40, 0x39, 0x34, 0x28, 0x22, 0x33, 0x37, 
	0x33, 0x39, 0x37, 0x50, 0x44, 0x3A, 0x49, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x49, 0x3D, 0x34, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4B, 0x40, 0x38, 0x3A, 0x39, 
	0x31, 0x38, 0x38, 0x2F, 0x26, 0x30, 0x31, 0x1D, 0x32, 0x3D, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 
	0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x18, 0x2A, 0x2F, 0x16, 0x2B, 0x30, 0x1E, 0x24, 0x1F, 0x3C, 
	0x34, 0x33, 0x39, 0x35, 0x31, 0x31, 0x2F, 0x28, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x25, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x36, 0x2A, 0x28, 0x19, 0x1A, 0x12, 0x25, 0x26, 0x33, 0x34, 0x29, 0x2A, 0x25, 
	0x20, 0x26, 0x23, 0x20, 0x0C, 0x29, 0x29, 0x28, 0x1A, 0x1B, 0x28, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1B, 0x1C, 0x32, 0x2F, 0x26, 0x08, 0x27, 0x29, 0x26, 0x1F, 0x1D, 0x32, 0x2F, 0x24, 0x27, 0x1F, 
	0x1F, 0x32, 0x30, 0x24, 0x32, 0x2B, 0x1F, 0x27, 0x1E, 0x1E, 0x2B, 0x29, 0x24, 0x25, 0x1A, 0x1C, 
	0x2A, 0x20, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x32, 
	0x27, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x29, 0x26, 0x20, 
	0x3A, 0x34, 0x32, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x30, 0x35, 0x31, 
	0x25, 0x2A, 0x3B, 0x3D, 0x4C, 0x40, 0x37, 0x40, 0x3C, 0x32, 0x28, 0x2F, 0x32, 0x1E, 0x31, 0x3C, 
	0x18, 0x34, 0x3C, 0x19, 0x36, 0x40, 0x12, 0x24, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x1D, 0x30, 
	0x3A, 0x23, 0x37, 0x3B, 0x5A, 0x4E, 0x48, 0x5C, 0x54, 0x49, 0x4F, 0x47, 0x3F, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x20, 0x1D, 0x84, 0x78, 0x68, 0x63, 
	0x59, 0x4C, 0x57, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5B, 0x53, 0x4B, 0x52, 0x49, 0x3E, 0x4E, 0x49, 0x45, 0x1F, 0x37, 0x3E, 0x1A, 0x2E, 0x37, 
	0x13, 0x2F, 0x3A, 0x3E, 0x3D, 0x34, 0x48, 0x3E, 0x35, 0x4E, 0x46, 0x3C, 0x4F, 0x47, 0x40, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x33, 0x36, 
	0x2E, 0x37, 0x38, 0x30, 0x40, 0x39, 0x2F, 0x13, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 
	0x19, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2E, 0x35, 0x14, 0x27, 0x24, 0x3B, 
	0x30, 0x31, 0x33, 0x2E, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x35, 0x29, 0x1B, 0x1F, 0x20, 0x16, 0x24, 0x25, 0x33, 0x25, 0x19, 0x33, 0x32, 
	0x2B, 0x32, 0x34, 0x28, 0x2B, 0x1D, 0x1A, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x32, 0x35, 0x29, 0x33, 0x2B, 0x24, 0x08, 0x27, 0x2A, 0x34, 0x2A, 0x1E, 0x25, 0x1B, 
	0x1C, 0x25, 0x1A, 0x1C, 0x28, 0x20, 0x1F, 0x33, 0x36, 0x2A, 0x27, 0x1F, 0x1F, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1B, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2B, 0x27, 0x23, 0x26, 0x19, 0x1A, 0x29, 0x23, 0x20, 0x26, 0x1B, 0x1C, 0x2A, 0x26, 0x22, 
	0x34, 0x35, 0x2B, 0x38, 0x39, 0x30, 0x38, 0x2C, 0x30, 0x38, 0x3A, 0x30, 0x35, 0x30, 0x2C, 0x38, 
	0x30, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x4D, 0x42, 
	0x39, 0x34, 0x39, 0x33, 0x3D, 0x39, 0x31, 0x32, 0x3B, 0x35, 0x31, 0x24, 0x22, 0x0D, 0x24, 0x20, 
	0x1C, 0x34, 0x3D, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1F, 
	0x32, 0x3C, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 0x32, 0x16, 0x29, 
	0x2C, 0x15, 0x2B, 0x37, 0x53, 0x4D, 0x4A, 0x67, 0x5E, 0x4B, 0x53, 0x4B, 0x43, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1E, 0x24, 0x1F, 0x7D, 0x75, 0x68, 0x58, 
	0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 
	0x4B, 0x59, 0x51, 0x49, 0x4F, 0x47, 0x3F, 0x52, 0x47, 0x42, 0x29, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x16, 0x3A, 0x43, 0x14, 0x2F, 0x3A, 0x27, 0x31, 0x31, 0x54, 0x4A, 0x3E, 0x4F, 0x47, 0x3C, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x4A, 0x40, 0x37, 0x49, 0x3F, 
	0x37, 0x36, 0x37, 0x2E, 0x4B, 0x40, 0x35, 0x13, 0x29, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x30, 0x20, 0x2A, 0x33, 0x31, 0x32, 0x2F, 0x39, 
	0x2F, 0x30, 0x39, 0x38, 0x31, 0x2F, 0x2F, 0x26, 0x31, 0x32, 0x28, 0x25, 0x19, 0x1B, 0x27, 0x1D, 
	0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 
	0x1A, 0x1B, 0x2B, 0x1F, 0x1D, 0x0F, 0x28, 0x28, 0x11, 0x27, 0x28, 0x27, 0x22, 0x1D, 0x31, 0x32, 
	0x28, 0x2A, 0x25, 0x22, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x25, 0x19, 0x1B, 0x30, 0x30, 0x27, 0x28, 0x18, 0x19, 0x32, 0x2B, 0x1F, 0x25, 0x1B, 
	0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x2A, 0x1C, 0x26, 0x1B, 0x1D, 
	0x25, 0x19, 0x1B, 0x25, 0x19, 0x1B, 0x31, 0x2B, 0x22, 0x30, 0x29, 0x20, 0x2F, 0x31, 0x27, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2A, 0x24, 0x1F, 0x25, 0x34, 0x34, 0x2C, 0x27, 0x22, 0x25, 0x18, 0x1A, 0x2A, 0x26, 0x22, 
	0x35, 0x33, 0x2C, 0x38, 0x39, 0x30, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x2C, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 
	0x2E, 0x36, 0x36, 0x2E, 0x35, 0x36, 0x2E, 0x50, 0x43, 0x39, 0x3C, 0x3F, 0x38, 0x13, 0x28, 0x2F, 
	0x1F, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x12, 0x25, 0x23, 0x1C, 0x35, 0x40, 0x15, 0x28, 0x29, 0x12, 0x25, 0x23, 0x1F, 0x32, 
	0x3D, 0x0D, 0x25, 0x29, 0x56, 0x4A, 0x47, 0x62, 0x5A, 0x4A, 0x5B, 0x53, 0x4C, 0x53, 0x4D, 0x44, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x2E, 0x2A, 0x8D, 0x7B, 0x6C, 0x59, 
	0x51, 0x47, 0x58, 0x50, 0x49, 0x4F, 0x47, 0x3C, 0x50, 0x48, 0x3E, 0x50, 0x48, 0x3E, 0x50, 0x48, 
	0x3E, 0x52, 0x49, 0x3E, 0x4C, 0x44, 0x3C, 0x51, 0x47, 0x43, 0x27, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x1D, 0x3A, 0x43, 0x1A, 0x31, 0x39, 0x14, 0x31, 0x3C, 0x3C, 0x34, 0x2A, 0x4C, 0x42, 0x39, 0x49, 
	0x3F, 0x37, 0x4B, 0x40, 0x38, 0x49, 0x3F, 0x36, 0x33, 0x36, 0x2B, 0x51, 0x43, 0x3E, 0x45, 0x3A, 
	0x33, 0x2C, 0x36, 0x34, 0x28, 0x31, 0x32, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 0x26, 0x25, 0x24, 0x20, 0x1C, 0x3A, 
	0x31, 0x32, 0x39, 0x32, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 
	0x37, 0x2A, 0x27, 0x23, 0x20, 0x12, 0x27, 0x27, 0x12, 0x26, 0x27, 0x23, 0x29, 0x25, 0x32, 0x32, 
	0x28, 0x31, 0x33, 0x28, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x18, 0x1A, 0x11, 0x26, 0x27, 0x31, 0x2F, 0x27, 0x28, 0x1D, 
	0x1B, 0x34, 0x37, 0x2B, 0x27, 0x20, 0x1D, 0x09, 0x29, 0x2A, 0x28, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x24, 0x16, 0x1A, 0x32, 0x34, 0x29, 0x31, 0x33, 0x29, 0x29, 0x24, 0x20, 0x34, 
	0x31, 0x2B, 0x37, 0x30, 0x2F, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 
	0x26, 0x32, 0x31, 0x26, 0x1D, 0x32, 0x3A, 0x2F, 0x2A, 0x23, 0x32, 0x33, 0x27, 0x2A, 0x24, 0x1F, 
	0x28, 0x24, 0x1F, 0x3A, 0x38, 0x32, 0x38, 0x37, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x3A, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 
	0x3B, 0x4E, 0x43, 0x3A, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x4B, 0x40, 0x36, 0x1C, 0x2B, 0x2E, 
	0x18, 0x2B, 0x30, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x16, 
	0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x25, 0x24, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 0x27, 
	0x28, 0x27, 0x35, 0x39, 0x5F, 0x55, 0x46, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x09, 0x20, 0x23, 0x1F, 0x82, 0x75, 0x63, 0x56, 
	0x4F, 0x48, 0x4E, 0x46, 0x3B, 0x5C, 0x54, 0x4D, 0x52, 0x4A, 0x40, 0x59, 0x51, 0x49, 0x5B, 0x52, 
	0x4A, 0x4D, 0x4F, 0x4D, 0x53, 0x4A, 0x3F, 0x53, 0x4A, 0x3E, 0x35, 0x3A, 0x37, 0x1A, 0x2C, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x19, 0x32, 0x3B, 0x1F, 0x2E, 0x36, 0x45, 0x36, 0x32, 0x53, 
	0x4B, 0x42, 0x4A, 0x3F, 0x35, 0x2C, 0x38, 0x36, 0x27, 0x2F, 0x2F, 0x22, 0x3F, 0x45, 0x28, 0x30, 
	0x2F, 0x16, 0x2C, 0x35, 0x16, 0x2A, 0x30, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 
	0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x1A, 0x33, 0x3F, 0x3A, 
	0x2E, 0x29, 0x39, 0x30, 0x31, 0x34, 0x30, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x19, 0x1A, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x1E, 0x20, 0x22, 0x2B, 0x22, 
	0x1D, 0x32, 0x33, 0x29, 0x1C, 0x16, 0x18, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x38, 0x2B, 0x26, 0x16, 0x19, 0x25, 0x1A, 0x1C, 0x25, 0x1A, 
	0x1B, 0x27, 0x16, 0x19, 0x09, 0x28, 0x29, 0x27, 0x20, 0x1D, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x25, 0x24, 0x18, 0x1B, 0x24, 0x18, 0x1A, 0x27, 0x1E, 0x1D, 0x2F, 
	0x31, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x39, 0x30, 
	0x31, 0x30, 0x32, 0x27, 0x27, 0x1B, 0x1A, 0x32, 0x32, 0x27, 0x23, 0x2F, 0x32, 0x26, 0x35, 0x36, 
	0x29, 0x23, 0x1E, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x31, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x50, 0x44, 0x3B, 0x33, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x48, 0x3E, 0x35, 0x1D, 0x30, 0x38, 
	0x11, 0x25, 0x26, 0x13, 0x26, 0x29, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x1A, 0x2C, 0x32, 0x13, 
	0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x11, 0x25, 
	0x25, 0x1D, 0x2C, 0x2A, 0x6C, 0x5A, 0x4D, 0x60, 0x59, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x20, 0x1D, 0x87, 0x78, 0x67, 0x5C, 
	0x54, 0x4D, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x53, 0x4B, 0x5A, 0x52, 0x49, 0x4B, 0x42, 
	0x37, 0x33, 0x46, 0x47, 0x55, 0x4D, 0x49, 0x52, 0x44, 0x39, 0x30, 0x3C, 0x36, 0x1A, 0x3D, 0x45, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2F, 0x38, 0x25, 0x31, 0x32, 0x5A, 
	0x4E, 0x43, 0x20, 0x2B, 0x29, 0x16, 0x31, 0x3C, 0x1C, 0x2F, 0x39, 0x1B, 0x31, 0x3A, 0x1C, 0x30, 
	0x3A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 
	0x1E, 0x1A, 0x38, 0x2E, 0x2B, 0x31, 0x30, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x32, 0x27, 0x25, 0x19, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x28, 0x2F, 0x24, 
	0x1D, 0x32, 0x35, 0x2A, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x29, 0x1E, 0x1B, 0x26, 
	0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x28, 0x1C, 0x1A, 0x32, 0x37, 0x2B, 0x32, 0x27, 0x1A, 0x32, 0x35, 
	0x2A, 0x32, 0x34, 0x29, 0x34, 0x33, 0x28, 0x32, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x25, 0x19, 0x1B, 0x32, 0x29, 0x1C, 0x32, 0x28, 0x1C, 0x32, 0x2F, 0x24, 0x31, 0x33, 0x28, 0x2F, 
	0x30, 0x26, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x33, 
	0x27, 0x29, 0x23, 0x20, 0x32, 0x32, 0x26, 0x31, 0x30, 0x26, 0x30, 0x2F, 0x24, 0x39, 0x2F, 0x2F, 
	0x2F, 0x32, 0x26, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x39, 0x2F, 0x38, 0x2C, 0x30, 0x38, 
	0x39, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 
	0x2F, 0x35, 0x37, 0x2F, 0x36, 0x37, 0x2F, 0x48, 0x3F, 0x37, 0x50, 0x45, 0x3B, 0x4D, 0x3F, 0x34, 
	0x28, 0x42, 0x46, 0x32, 0x42, 0x45, 0x11, 0x25, 0x28, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x11, 0x24, 
	0x24, 0x22, 0x37, 0x3E, 0x66, 0x57, 0x48, 0x63, 0x5C, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x54, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x75, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x4D, 0x4B, 0x45, 0x57, 0x4D, 0x4B, 0x2B, 0x26, 
	0x1C, 0x15, 0x2F, 0x3A, 0x23, 0x38, 0x3C, 0x2A, 0x32, 0x32, 0x19, 0x31, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x29, 0x33, 0x33, 0x53, 
	0x45, 0x3A, 0x13, 0x22, 0x25, 0x1B, 0x34, 0x3E, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x18, 0x2A, 
	0x2F, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 
	0x15, 0x28, 0x29, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x11, 0x27, 0x26, 0x18, 
	0x26, 0x2A, 0x3A, 0x31, 0x30, 0x2E, 0x30, 0x25, 0x38, 0x30, 0x30, 0x35, 0x31, 0x2C, 0x29, 0x24, 
	0x1F, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0C, 
	0x2A, 0x2A, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x24, 0x1D, 
	0x1E, 0x26, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2B, 0x28, 
	0x1E, 0x1B, 0x26, 0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x25, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 0x1A, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x19, 0x1B, 0x30, 0x26, 0x1B, 0x25, 0x1A, 0x1B, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1D, 0x26, 0x1B, 0x1D, 0x24, 0x19, 0x1B, 0x2B, 0x26, 0x22, 0x30, 
	0x31, 0x27, 0x2E, 0x30, 0x25, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x30, 0x33, 0x27, 0x23, 0x13, 
	0x18, 0x33, 0x34, 0x27, 0x1C, 0x31, 0x39, 0x24, 0x2F, 0x31, 0x2C, 0x33, 0x2F, 0x30, 0x30, 0x25, 
	0x28, 0x22, 0x1E, 0x34, 0x30, 0x2B, 0x38, 0x31, 0x30, 0x35, 0x3C, 0x36, 0x38, 0x39, 0x2F, 0x38, 
	0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 
	0x3C, 0x33, 0x36, 0x2E, 0x39, 0x36, 0x30, 0x35, 0x32, 0x2A, 0x39, 0x40, 0x3F, 0x42, 0x3B, 0x30, 
	0x31, 0x35, 0x2C, 0x57, 0x55, 0x51, 0x2B, 0x31, 0x30, 0x0E, 0x24, 0x24, 0x13, 0x26, 0x26, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x28, 
	0x2A, 0x24, 0x37, 0x3C, 0x51, 0x4C, 0x4A, 0x64, 0x5C, 0x49, 0x5B, 0x53, 0x4B, 0x5C, 0x54, 0x45, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x87, 0x79, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4A, 0x4D, 0x49, 0x46, 0x4C, 0x3F, 0x36, 0x1D, 0x2F, 
	0x36, 0x1C, 0x2F, 0x38, 0x1C, 0x2F, 0x38, 0x15, 0x29, 0x2E, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 
	0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x38, 0x2A, 0x33, 0x33, 0x48, 
	0x40, 0x36, 0x1B, 0x1C, 0x1C, 0x18, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 
	0x2F, 0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x19, 0x2E, 0x34, 0x1F, 0x1E, 0x1E, 0x14, 
	0x28, 0x26, 0x34, 0x30, 0x29, 0x2F, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 
	0x28, 0x30, 0x2A, 0x20, 0x32, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x28, 
	0x28, 0x30, 0x24, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x28, 0x1B, 0x1B, 0x28, 0x22, 0x1F, 0x2B, 
	0x1E, 0x1B, 0x28, 0x1B, 0x1B, 0x29, 0x1E, 0x1B, 0x34, 0x37, 0x2A, 0x24, 0x25, 0x23, 0x12, 0x27, 
	0x27, 0x29, 0x1B, 0x1B, 0x19, 0x24, 0x24, 0x26, 0x19, 0x1B, 0x33, 0x36, 0x2A, 0x33, 0x36, 0x2A, 
	0x24, 0x19, 0x1B, 0x33, 0x2A, 0x1C, 0x25, 0x1A, 0x1D, 0x33, 0x2A, 0x1C, 0x24, 0x18, 0x1B, 0x32, 
	0x34, 0x29, 0x30, 0x2E, 0x24, 0x2E, 0x30, 0x26, 0x36, 0x32, 0x2E, 0x28, 0x23, 0x1F, 0x33, 0x36, 
	0x2A, 0x27, 0x1E, 0x1D, 0x2C, 0x25, 0x1F, 0x32, 0x32, 0x27, 0x33, 0x2F, 0x28, 0x28, 0x30, 0x2C, 
	0x32, 0x30, 0x28, 0x36, 0x30, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x2F, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x31, 0x2C, 0x38, 0x3A, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x53, 0x45, 0x3C, 0x2E, 0x33, 0x2E, 0x23, 0x28, 0x2B, 0x1A, 0x30, 0x3B, 0x11, 0x29, 0x30, 
	0x2C, 0x28, 0x29, 0x5E, 0x52, 0x45, 0x51, 0x47, 0x3A, 0x19, 0x30, 0x38, 0x12, 0x25, 0x24, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 
	0x24, 0x1F, 0x34, 0x3D, 0x4F, 0x43, 0x39, 0x68, 0x5F, 0x55, 0x65, 0x5D, 0x4A, 0x5C, 0x54, 0x4C, 
	0x0D, 0x07, 0x08, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x08, 0x19, 0x22, 0x1D, 0x8B, 0x7C, 0x6A, 0x5C, 
	0x54, 0x4D, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x52, 0x52, 0x4D, 0x06, 0x23, 0x2B, 0x0F, 0x24, 
	0x20, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x38, 0x23, 0x32, 0x38, 0x3F, 
	0x3A, 0x2C, 0x14, 0x2B, 0x32, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 
	0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 0x26, 0x26, 0x20, 0x26, 0x24, 0x3E, 
	0x30, 0x2E, 0x2F, 0x30, 0x26, 0x30, 0x2C, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x28, 0x27, 0x1C, 0x1B, 0x25, 0x1A, 0x1B, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x11, 0x28, 
	0x28, 0x28, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x11, 0x28, 0x28, 0x15, 0x26, 0x26, 0x2A, 0x1A, 0x1A, 0x0E, 
	0x28, 0x29, 0x0E, 0x29, 0x29, 0x28, 0x1B, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1C, 0x1C, 0x28, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 
	0x29, 0x23, 0x20, 0x28, 0x22, 0x20, 0x26, 0x1B, 0x1C, 0x28, 0x22, 0x20, 0x29, 0x23, 0x20, 0x25, 
	0x19, 0x1B, 0x27, 0x1F, 0x1E, 0x31, 0x32, 0x28, 0x29, 0x23, 0x1F, 0x32, 0x34, 0x29, 0x25, 0x18, 
	0x1A, 0x26, 0x1C, 0x1C, 0x26, 0x1B, 0x1C, 0x27, 0x1E, 0x1E, 0x30, 0x31, 0x27, 0x2F, 0x2F, 0x25, 
	0x37, 0x32, 0x2F, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2F, 0x2C, 0x38, 0x3B, 0x30, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x30, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x38, 
	0x30, 0x38, 0x37, 0x2C, 0x1E, 0x34, 0x3E, 0x13, 0x27, 0x29, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x29, 0x30, 0x34, 0x36, 0x32, 0x4D, 0x40, 0x38, 0x46, 0x42, 0x39, 0x14, 0x29, 0x31, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x27, 0x18, 0x33, 0x3D, 0x52, 0x46, 0x42, 0x58, 0x50, 0x49, 0x59, 0x51, 0x45, 
	0x1A, 0x15, 0x13, 0x08, 0x09, 0x09, 0x07, 0x07, 0x07, 0x1B, 0x1F, 0x1D, 0x57, 0x4E, 0x46, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x51, 0x4D, 0x49, 0x47, 0x3B, 0x35, 0x14, 0x2A, 
	0x30, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 
	0x30, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x27, 0x23, 
	0x22, 0x20, 0x31, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x29, 0x1F, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x28, 0x20, 0x1F, 0x25, 0x1B, 0x1C, 0x33, 0x2A, 0x1D, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x19, 0x25, 
	0x25, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x28, 0x1C, 0x1C, 0x15, 0x26, 0x26, 

};

static UINT g_sizeofTexture = sizeof(g_texture);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

namespace Media4 {

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
}
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\Camera.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Camera.cpp

Abstract:

	Camera for D3D viewing

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Camera.h"

using namespace Media4;

namespace Media4 {

//------------------------------------------------------------------------------
//	CCamera::CCamera
//------------------------------------------------------------------------------
CCamera::CCamera(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	D3DLIGHT8	light;

	// Default viewport
	m_viewport.X		= 0;
	m_viewport.Y		= 0;
	m_viewport.Width	= 640;
	m_viewport.Height	= 480;
	m_viewport.MinZ		= 0.0f;
	m_viewport.MaxZ		= 1.0f;

	// View matrix
	XGMatrixIdentity(&m_viewMatrix);

	// Projection matrix
	XGMatrixIdentity(&m_projectionMatrix);

	// light
	light.Type			= D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r		= 1.0f;
    light.Diffuse.g		= 1.0f;
    light.Diffuse.b		= 1.0f;
    light.Diffuse.a		= 1.0f;
    light.Specular.r	= 1.0f;
    light.Specular.g	= 1.0f;
    light.Specular.b	= 1.0f;
    light.Specular.a	= 1.0f;
    light.Ambient.r		= 1.0f;
    light.Ambient.g		= 1.0f;
    light.Ambient.b		= 1.0f;
    light.Ambient.a		= 1.0f;
    light.Direction.x	= 0.0f;
    light.Direction.y	= 0.0f;
    light.Direction.z	= 1.0f;
    light.Range			= 1000.0f;
	SetLight(0, light);

	// Other parameters
	m_focalPoint		= XGVECTOR3(0.0f, 0.0f, 0.0f);
	m_position			= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_viewUp			= XGVECTOR3(0.0f, 1.0f, 0.0f);
	m_vpn				= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_lightPosition		= m_position;
	m_lightNum			= 5;
	m_lightOn			= TRUE;
	m_fixedLight		= TRUE;
	m_drawAxis			= FALSE;

	// Axis color
	m_axis[0].color	= 0xffff0000;
	m_axis[1].color	= 0xffff0000;
	m_axis[2].color	= 0xff00ff00;
	m_axis[3].color	= 0xff00ff00;
	m_axis[4].color	= 0xff0000ff;
	m_axis[5].color	= 0xff0000ff;

	m_lightNormal[0].color	= 0xffffffff;
	m_lightNormal[1].color	= 0xffffffff;
}

//------------------------------------------------------------------------------
//	CCamera::~CCamera
//------------------------------------------------------------------------------
CCamera::~CCamera(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CCamera::Render
//------------------------------------------------------------------------------
void 
CCamera::Render(
				IN IDirect3DDevice8* pD3DDevice
				)
/*++

Routine Description:

	Render the scene

Arguments:

	IN pD3DDevice -	Device to draw to

Return Value:

	None

--*/
{
	// View matrix
	pD3DDevice->SetTransform(D3DTS_VIEW, &m_viewMatrix);

	// Projection matrix
	pD3DDevice->SetTransform(D3DTS_PROJECTION, &m_projectionMatrix);

	pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);

	// Draw the axis?
	if(m_drawAxis)
	{
		DWORD oldState;
		
		pD3DDevice->GetRenderState(D3DRS_LIGHTING, &oldState);
		pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

		// Draw the axis?
		pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
		pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 3, m_axis, 
									sizeof(CCamera::Vertex));

		if(m_lightOn)
		{
			pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
			pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_lightNormal, 
										sizeof(CCamera::Vertex));
		}

		if(oldState)
			pD3DDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	}

	// light
	pD3DDevice->SetLight(m_lightNum, &m_light);
	pD3DDevice->LightEnable(m_lightNum, m_lightOn);

}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN DWORD	x, 
					 IN DWORD	y, 
					 IN DWORD	w, 
					 IN DWORD	h, 
					 IN float	minZ, 
					 IN float	maxZ
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN x -			X coordinate
	IN y -			Y coordinate
	IN w -			Width
	IN h -			Height
	IN minZ -		Z coordinate of fron clipping plane (0.0 - 1.0)
	IN maxZ -		Z coordinate of back clipping plane (0.0 - 1.0)
	IN vieport -	Complete viewport structure

Return Value:

	None

--*/
{
	m_viewport.X		= x;
	m_viewport.Y		= y;
	m_viewport.Width	= w;
	m_viewport.Height	= h;
	m_viewport.MinZ		= minZ;
	m_viewport.MaxZ		= maxZ;
}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN const D3DVIEWPORT8& viewport
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN viewport -	Viewport

Return Value:

	None

--*/
{
	m_viewport.X		= viewport.X;
	m_viewport.Y		= viewport.Y;
	m_viewport.Width	= viewport.Width;
	m_viewport.Height	= viewport.Height;
	m_viewport.MinZ		= viewport.MinZ;
	m_viewport.MaxZ		= viewport.MaxZ;
}

//------------------------------------------------------------------------------
//	CCamera::GetViewport
//------------------------------------------------------------------------------
const D3DVIEWPORT8& 
CCamera::GetViewport(void)
/*++

Routine Description:

	Returns the viewport

Arguments:

	None

Return Value:

	The current viewport

--*/
{
	return m_viewport;
}

//------------------------------------------------------------------------------
//	CCamera::LookAt
//------------------------------------------------------------------------------
void 
CCamera::LookAt(
				IN const XGVECTOR3& position, 
				IN const XGVECTOR3& focalPoint, 
				IN const XGVECTOR3& viewUp
				)
/*++

Routine Description:

	Sets the (initial) orientation of the camera

Arguments:

	IN position -	Position of camera
	IN focalPoint -	Focal point of camera
	IN viewUp -		View up vector

Return Value:

	None

--*/
{
	float	length;

	m_focalPoint	= focalPoint;
	m_position		= position;
	m_viewUp		= viewUp;
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);
	XGVec3Subtract(&m_vpn, &m_focalPoint, &m_position);

	length	= XGVec3Length(&m_vpn);
	m_vpn	/= length;
	length	/= 4.0f;

	// Calculate the axis
	m_axis[0].x	= m_focalPoint.x;
	m_axis[0].y	= m_focalPoint.y;
	m_axis[0].z	= m_focalPoint.z;
	m_axis[1].x	= m_axis[0].x + length;
	m_axis[1].y	= m_axis[0].y;
	m_axis[1].z	= m_axis[0].z;
	m_axis[2].x	= m_axis[0].x;
	m_axis[2].y	= m_axis[0].y;
	m_axis[2].z	= m_axis[0].z;
	m_axis[3].x	= m_axis[0].x;
	m_axis[3].y	= m_axis[0].y + length;
	m_axis[3].z	= m_axis[0].z;
	m_axis[4].x	= m_axis[0].x;
	m_axis[4].y	= m_axis[0].y;
	m_axis[4].z	= m_axis[0].z;
	m_axis[5].x	= m_axis[0].x;
	m_axis[5].y	= m_axis[0].y;
	m_axis[5].z	= m_axis[0].z + length;

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetFieldOfView
//------------------------------------------------------------------------------
void 
CCamera::SetPerspectiveFov(
						   IN float	fov,
						   IN float	aspect,
						   IN float	zNear,
						   IN float	zFar
						   )
/*++

Routine Description:

	Sets the field of view and the perspective projection

Arguments:

	IN fov -	Field of view in degrees.
	IN aspect -	Aspect ratio
	IN zNear -	Near clipping plane
	IN zFar -	Far clipping plane

Return Value:

	None

--*/
{
	m_aspect	= aspect;
	m_fov		= XGToRadian(fov);
	m_zNear		= zNear;
	m_zFar		= zFar;
	m_dz		= m_zFar - m_zNear;
	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, m_zNear, 
							   m_zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Zoom
//------------------------------------------------------------------------------
void 
CCamera::Zoom(
			  IN float amount
			  )
/*++

Routine Description:

	Zooms the camera in or out

Arguments:

	IN amount -	Amount to zoom in world coordinates

Return Value:

	None

--*/
{
	float		length;
	float		zFar;
	float		zNear;
	XGVECTOR3	oldPosition = m_position;

	// Make sure user doesn't zoom past focal point
	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	if((length <= 0.01) && (amount > 0.0f))
		return;
	if(amount >= length)
		amount = length - 0.01f;

	// Move the point
	m_position.x += m_vpn.x * amount;
	m_position.y += m_vpn.y * amount;
	m_position.z += m_vpn.z * amount;
	
	// Reproject
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	m_zNear = length - (m_dz / 2.0f) - 0.01f;
	m_zFar	= length + (m_dz / 2.0f) + 0.01f;

	if(m_zNear < 0.00001f)
		zNear = 0.00001f;
	else
		zNear = m_zNear;
	if(m_zFar < 0.00001f)
		zFar = 0.00001f;
	else
		zFar = m_zFar;

	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, zNear, zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Rotate
//------------------------------------------------------------------------------
void 
CCamera::Rotate(
				IN float				degrees, 
				IN const XGVECTOR3&	axis
				)
/*++

Routine Description:

	Rotates the scene around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about

Return Value:

	None

--*/
{
	XGMATRIX	rotate;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, m_viewMatrix, rotate);

	// Transform the position
	XGVec3TransformCoord(&m_position, &m_position, &m_viewMatrix);

	// Recalculate the view plane normal
	XGVec3Normalize(&m_vpn, &XGVECTOR3(m_focalPoint - m_position));

	// Transform the view up vector
	XGVec3TransformCoord(&m_viewUp, &m_viewUp, &rotate);

	// Reset the view matrix
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateX
//------------------------------------------------------------------------------
void 
CCamera::RotateX(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the X axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	axis;

	XGVec3Cross(&axis, &m_vpn, &m_viewUp);
	Rotate(degrees, axis);
}

//------------------------------------------------------------------------------
//	CCamera::RotateY
//------------------------------------------------------------------------------
void 
CCamera::RotateY(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Y axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::RotateZ
//------------------------------------------------------------------------------
void 
CCamera::RotateZ(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Z axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_vpn);
}

//------------------------------------------------------------------------------
//	CCamera::EnableLight
//------------------------------------------------------------------------------
void 
CCamera::EnableLight(
					 IN BOOL	turnOn,
					 IN BOOL	fixedLight
					 )
/*++

Routine Description:

	Enables the headlight

Arguments:

	IN turnOn -		TRUE to enable, FALSE to disable
	IN fixedLight -	TRUE to follow camera position, FALSE to float

Return Value:

	None

--*/
{
	m_lightOn		= turnOn;
	m_fixedLight	= fixedLight;
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetLight
//------------------------------------------------------------------------------
void 
CCamera::SetLight(
				  IN DWORD				lightNum, 
				  IN const D3DLIGHT8&	lightParams
				  )
/*++

Routine Description:

	Sets the parameters of the light

Arguments:

	IN lightNum -		Light number to use.
	IN lightParams -	Parameters of the light source

Return Value:

	None

--*/
{
	m_lightNum			= lightNum;

    m_light.Type		= lightParams.Type;
	m_light.Diffuse.r	= lightParams.Diffuse.r;	
	m_light.Diffuse.g	= lightParams.Diffuse.g;	
	m_light.Diffuse.b	= lightParams.Diffuse.b;	
    m_light.Specular.r	= lightParams.Specular.r;
	m_light.Specular.g	= lightParams.Specular.g;
	m_light.Specular.b	= lightParams.Specular.b;
    m_light.Ambient.r	= lightParams.Ambient.r;
	m_light.Ambient.g	= lightParams.Ambient.g;
	m_light.Ambient.b	= lightParams.Ambient.b;
    m_light.Range		= lightParams.Range;
}

//------------------------------------------------------------------------------
//	CCamera::RotateLight
//------------------------------------------------------------------------------
void 
CCamera::RotateLight(
					 IN float				degrees, 
					 IN const XGVECTOR3&	axis
					 )
/*++

Routine Description:

	Rotates the Light around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about.

Return Value:

	None

--*/
{
	XGMATRIX	matrix;
	XGMATRIX	temp;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, matrix, temp);

	// Transform the position
	XGVec3TransformCoord(&m_lightPosition, &m_lightPosition, &matrix);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightX
//------------------------------------------------------------------------------
void 
CCamera::RotateLightX(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	cross;

	XGVec3Cross(&cross, &m_vpn, &m_viewUp);
	RotateLight(degrees, cross);
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightY
//------------------------------------------------------------------------------
void 
CCamera::RotateLightY(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	RotateLight(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::SetDrawAxis
//------------------------------------------------------------------------------
void 
CCamera::SetDrawAxis(
					 IN BOOL draw
					 )
/*++

Routine Description:

	Enables and disbles the drawing of an axis

	Red == +X, Blue == +Y and Green == +Z

Arguments:

	IN draw -	TRUE to draw the axis, FALSE to hide the axis

Return Value:

	None

--*/
{
	m_drawAxis = draw;
}

//------------------------------------------------------------------------------
//	CCamera::SetHome
//------------------------------------------------------------------------------
void
CCamera::SetHome(void)
/*++

Routine Description:

	Sets the home position of the camera to the current position

Arguments:

	None

Return Value:

	None

--*/
{
	m_homePosition		= m_position;
	m_homeViewUp		= m_viewUp;
	m_homeFocalPoint	= m_focalPoint;
	m_homeVpn			= m_vpn;
	m_homeLightPosition	= m_lightPosition;
	m_homeLightOn		= m_lightOn;
	m_homeFixedLight	= m_fixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::GoHome
//------------------------------------------------------------------------------
void
CCamera::GoHome(void)
/*++

Routine Description:

	Moves the camera to its home position

Arguments:

	None

Return Value:

	None

--*/
{
	m_position		= m_homePosition;
	m_viewUp		= m_homeViewUp;
	m_focalPoint	= m_homeFocalPoint;
	m_vpn			= m_homeVpn;
	m_lightPosition	= m_homeLightPosition;
	m_lightOn		= m_homeLightOn;
	m_fixedLight	= m_homeFixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::UpdateLight
//------------------------------------------------------------------------------
void
CCamera::UpdateLight(void)
/*++

Routine Description:

	Updates the light direction based upon the movement of the camera
	so the light always points towards the focal point

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;

	if(m_fixedLight)
	{
		m_lightPosition		= m_position;
		m_light.Direction	= m_vpn;
	}
	else
	{
		XGVECTOR3	direction;
		XGVec3Normalize(&direction, &XGVECTOR3(m_focalPoint - m_lightPosition));
		m_light.Direction = direction;
	}

	m_lightNormal[0].x = m_focalPoint.x;
	m_lightNormal[0].y = m_focalPoint.y;
	m_lightNormal[0].z = m_focalPoint.z;

	XGVec3Lerp(&point, &m_focalPoint, &m_lightPosition, 0.5);

	m_lightNormal[1].x = point.x;
	m_lightNormal[1].y = point.y;
	m_lightNormal[1].z = point.z;
}

//------------------------------------------------------------------------------
//	CCamera::MakeRotationMatrices
//------------------------------------------------------------------------------
void
CCamera::MakeRotationMatrices(
							  IN float				degrees, 
							  IN const XGVECTOR3&	axis,
							  OUT XGMATRIX&			transform,
							  OUT XGMATRIX&			rotation
							  )
/*++

Routine Description:

	Create a transformation and rotation (only) matrix from the
	current focal point and a rotation about an arbitrary axis

Arguments:

	IN degrees -	Degrees to rotate about
	IN axis -		Axis to rotate about
	OUT transform -	Complete transormation matrix
	OUT rotation -	Rotation matrix only

Return Value:

	None

--*/
{
	if(degrees == 0.0f)
	{
		XGMatrixIdentity(&transform);
		XGMatrixIdentity(&rotation);
		return;
	}

	XGMATRIX	temp;
	
	XGMatrixTranslation(&transform, -m_focalPoint.x, -m_focalPoint.y, 
						-m_focalPoint.z);
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixRotationAxis(&rotation, &axis, 
										  XGToRadian(degrees)));
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixTranslation(&temp, m_focalPoint.x, 
										 m_focalPoint.y, m_focalPoint.z));
}

//------------------------------------------------------------------------------
//	CCamera::GetPosition
//------------------------------------------------------------------------------
void 
CCamera::GetPosition(XGVECTOR3* pvPosition)
{
    if (pvPosition) {
        *pvPosition = m_position;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

using namespace Media4;

namespace Media4 {

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\Ball.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __BALL_H__
#define __BALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media4 {

//------------------------------------------------------------------------------
//	CAudioData
//------------------------------------------------------------------------------
class CAudioData
{
protected:
    LPWAVEFORMATEX          m_pwfxFormat;
    LPVOID                  m_pvAudioData;
    DWORD                   m_dwAudioDataSize;
    DWORD                   m_dwRefCount;

public:
    CAudioData(void);
    virtual ~CAudioData(void);

public:
    HRESULT CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize);
    HRESULT CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize);
    DWORD AddRef(void);
    DWORD Release(void);
};

__inline DWORD CAudioData::AddRef(void)
{
    return ++m_dwRefCount;
}

__inline DWORD CAudioData::Release(void)
{
    if(m_dwRefCount)
    {
        return --m_dwRefCount;
    }
    else
    {
        return 0;
    }
}

//------------------------------------------------------------------------------
//	CBall
//------------------------------------------------------------------------------
class CBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		float		tu, tv;
        XGVECTOR3   vTangent;
        XGVECTOR3   vBinormal;
        XGVECTOR3   vNormal;
	};

public:

	CBall(void);
	virtual ~CBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, float, int, int, BOOL, DWORD);
	void SetPosition(const XGVECTOR3&);
	void SetDirection(const XGVECTOR3&);
	void SetSpeed(float);
	float GetSpeed(void) const;
	const XGVECTOR3& GetDirection(void) const;
	void Move(float);
	void Render(IDirect3DDevice8*, XGMATRIX*, XGVECTOR3*, D3DLIGHT8*, D3DCOLORVALUE*, UINT);

	void DrawSolid(void);
	void DrawReduced(void);
	void DrawWireframe(void);
	void DrawPoints(void);

	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;
	const XGVECTOR3& GetLocation(void) const;

    D3DLIGHT8* GetLight(void);
    void PlaceLightInRange(UINT uLight, BOOL bInRange);
	BOOL IsLightSource(void) const;

	void PlayBuffer(float volume /* 0.0-1.0 */, float pitch /* 0.0-1.0 */);
    void DisableAmbientAudio( void );

	float GetMass(void) const { return m_mass; };

private:

	void Release(void);

    HRESULT CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, 
                            LPCSTR szImage, IDirect3DTexture8** ppd3dt);
    HRESULT CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, 
                            IDirect3DTexture8** ppd3dt);

    BOOL ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);
    BOOL CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                            Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);

	HRESULT InitAudio(void);
    HRESULT CreateSubMixDestination(void);
    HRESULT CreateCollisionSound(void);
    HRESULT CreateAmbientSound(void);
    void RenderAudio(void);

    LONG CalculatePitch(DWORD dwFrequency);

private:

	D3DMATERIAL8			m_material;
    D3DLIGHT8               m_light;
    D3DLIGHT8               m_lightDark;
	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;
	BOOL					m_dontDraw;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_direction;
	float					m_speed;
	float					m_radius;
	XGVECTOR3				m_location;
	DWORD					m_fillMode;
	LPDIRECTSOUNDBUFFER     m_pCollisionSound;
    LPDIRECTSOUNDBUFFER     m_pAmbientSound;
    LPDIRECTSOUNDBUFFER     m_pSubMix;
    static CAudioData       m_CollisionSoundData;
    CAudioData *            m_pCollisionSoundData;
    static CAudioData       m_AmbientSoundData;
    CAudioData *            m_pAmbientSoundData;
	int						m_detail;
    BOOL                    m_bLightSource;
    DWORD                   m_dwInLightRange[4];
	float					m_mass;
    DWORD                   m_dwID;
    DWORD                   m_dwCollisionFrequency;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
    static IDirect3DTexture8* m_pd3dtBump;
    static IDirect3DTexture8* m_pd3dtLight;
    static IDirect3DTexture8* m_pd3dtWhite;
    static IDirect3DTexture8* m_pd3dtFlat;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\Ball.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

    28-April-2001 danrose
	    Added sound

    21-June-2001 danhaff
        Made lights flash with beat of music.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "Ball.h"
#include "helpers.h"

using namespace Media4;

namespace Media4 {
//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL (D3DFVF_XYZ | D3DFVF_NORMAL)
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f

#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

#define AMBIENT_SOUND_FREQUENCY 26000

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CBall::m_uRef = 0;
IDirect3DTexture8* CBall::m_pd3dtBase = NULL;
IDirect3DTexture8* CBall::m_pd3dtBump = NULL;
IDirect3DTexture8* CBall::m_pd3dtLight = NULL;
IDirect3DTexture8* CBall::m_pd3dtWhite = NULL;
IDirect3DTexture8* CBall::m_pd3dtFlat = NULL;
CAudioData CBall::m_CollisionSoundData;
CAudioData CBall::m_AmbientSoundData;

//------------------------------------------------------------------------------
//	CBall::CBall
//------------------------------------------------------------------------------
CBall::CBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	            = TRUE;
	m_pVB		            = NULL;
	m_pIB		            = NULL;
	m_pSubMix               = NULL;
	m_pAmbientSound         = NULL;
	m_pAmbientSoundData     = NULL;
	m_pCollisionSound	    = NULL;
	m_pCollisionSoundData   = NULL;
	m_fillMode	            = D3DFILL_SOLID;
	m_mass		            = 0;
    m_dwCollisionFrequency  = 0;
    m_uRef++;

    ZeroMemory( &m_dwInLightRange, 4 * sizeof(DWORD));
}

//------------------------------------------------------------------------------
//	CBall::~CBall
//------------------------------------------------------------------------------
CBall::~CBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
        if (m_pd3dtBump) {
            m_pd3dtBump->Release();
            m_pd3dtBump = NULL;
        }
        if (m_pd3dtLight) {
            m_pd3dtLight->Release();
            m_pd3dtLight = NULL;
        }
        if (m_pd3dtWhite) {
            m_pd3dtWhite->Release();
            m_pd3dtWhite = NULL;
        }
        if (m_pd3dtFlat) {
            m_pd3dtFlat->Release();
            m_pd3dtFlat = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CBall::Create
//------------------------------------------------------------------------------
HRESULT
CBall::Create(
			  IN IDirect3DDevice8*	pDevice,
			  IN float				radius,
			  IN float				mass,
			  IN int				numLong,
			  IN int				numLat,
              IN BOOL               bLight,
              IN DWORD              dwID
			  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	UINT		index       = 0;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;
    int         i, j;
    float       fX, fY, fTX, fSinY, fCosY;
    Vertex*     pr;


	// Release previous buffers
	Release();

	// Setup
    m_dwID      = dwID;
	m_radius	= radius;
	m_detail	= numLat;
	m_mass		= mass; // 4.0f / 3.0f * PI * m_radius * m_radius * m_radius;

    m_bLightSource = bLight;

    if (bLight) {

        XGVECTOR3 vColor, vSpecular;

        if (g_TestParams.bTextureBalls) {
            XGVec3Normalize(&vColor, &XGVECTOR3((float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX));
            XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));
        }
        else {
            vColor = XGVECTOR3(1.0f, 1.0f, 1.0f);
            vSpecular = XGVECTOR3(1.0f, 1.0f, 1.0f);
        }

        memset(&m_light, 0, sizeof(D3DLIGHT8));
        m_light.Type = D3DLIGHT_POINT;
        m_light.Diffuse.r = vColor.x;
        m_light.Diffuse.g = vColor.y;
        m_light.Diffuse.b = vColor.z;
        m_light.Diffuse.a = 1.0f;//FRND(1.0f);
        m_light.Specular.r = vSpecular.x;
        m_light.Specular.g = vSpecular.y;
        m_light.Specular.b = vSpecular.z;
        m_light.Specular.a = 1.0f;
        m_light.Ambient.r = 0.0f;
        m_light.Ambient.g = 0.0f;
        m_light.Ambient.b = 0.0f;
        m_light.Ambient.a = 0.0f;
        m_light.Range = 1000.0f;
        m_light.Attenuation0 = 0.0f;
        m_light.Attenuation1 = 0.8f + (float)rand() / (float)RAND_MAX * 0.4f;
        m_light.Attenuation2 = 0.0f;
    }
    else {

        if (g_TestParams.bTextureBalls) {

	        m_material.Diffuse.r	= 0.5f;
	        m_material.Diffuse.g	= 0.5f;
	        m_material.Diffuse.b	= 0.5f;
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;
	        m_material.Ambient.g	= 0.25f;
	        m_material.Ambient.b	= 0.25f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
        else {

    	    // Create a random color for the material
	        do 
	        {
		        m_material.Diffuse.r	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.g	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.b	= (float)rand() / (float)RAND_MAX;
	        }
	        while ((m_material.Diffuse.r + m_material.Diffuse.g + m_material.Diffuse.b) < 1.0f);
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;//m_material.Diffuse.r * 0.4f;
	        m_material.Ambient.g	= 0.25f;//m_material.Diffuse.g * 0.4f;
	        m_material.Ambient.b	= 0.25f;//m_material.Diffuse.b * 0.4f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
    }

	// Num verts and tris
	m_numVertices	= (numLong + 1) * numLat;
	m_numTriangles	= numLong * (numLat - 1) * 2;

    // Create the sphere vertex buffer
    hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 0, D3DPOOL_DEFAULT, &m_pVB);
	if(FAILED(hr))
	{
		return hr;
	}

	hr = pDevice->CreateIndexBuffer(m_numTriangles * 3 * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
        m_pVB->Release();
		return hr;
	}

    m_pVB->Lock(0, 0, (LPBYTE*)&vertices, 0);
	m_pIB->Lock(0, 0, (LPBYTE*)&indices, 0);

    // Create the sphere
    for (j = 0; j < numLat; j++) {

        fY = (float)(j) / (float)(numLat - 1);
        fSinY = (float)(sin(fY * M_PI));
        fCosY = (float)(cos(fY * M_PI));

        for (i = 0; i <= numLong; i++) {

            pr = &vertices[(numLong + 1) * j + i];
            fX = (float)(i) / (float)(numLong);
            fTX = fX * M_2PI;

            pr->vNormal.x = (float)(cos(fTX)) * fSinY;
            pr->vNormal.y = fCosY;
            pr->vNormal.z = (float)(sin(fTX)) * fSinY;
            pr->position.x = pr->vNormal.x * m_radius;
            pr->position.y = pr->vNormal.y * m_radius;
            pr->position.z = pr->vNormal.z * m_radius;
            pr->tu = fX * 2.0f;
            pr->tv = fY * 1.0f;
        }
    }

    for (j = 0; j < numLat - 1; j++) {

        for (i = 0; i < numLong; i++) {

            indices[index++] = (j + 1) * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i + 1;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
        }
    }

    if (!bLight) {
        // Initialize the model to texture space transforms
        if (!ComputeTangentTransforms(vertices, indices, index, TRUE)) {
            m_pVB->Release();
            m_pIB->Release();
            return FALSE;
        }
    }

    m_pVB->Unlock();
    m_pIB->Unlock();

	m_dontDraw = FALSE;

	hr = InitAudio();
	if (FAILED( hr))
	{
		Release();
		delete [] indices;
		return hr;
	}

    // Create the base texture
    if (!m_pd3dtBase) {
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szBallBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the bump texture
    if (!m_pd3dtBump) {
        hr = CreateTextureFromHeightMap(pDevice, g_TestParams.szBallBumpTex, &m_pd3dtBump);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the light texture
    if (!m_pd3dtLight) {
        hr = CreateLightTexture(pDevice, 128, &m_pd3dtLight);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create a white texture
    if (!m_pd3dtWhite) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtWhite);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtWhite->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = 0xFFFFFFFF;
        m_pd3dtWhite->UnlockRect(0);
    }

    // Create a flat normal map
    if (!m_pd3dtFlat) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtFlat);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtFlat->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = VectorToColor(&XGVECTOR3(0.0f, 0.0f, -1.0f));
        m_pd3dtFlat->UnlockRect(0);
    }

	return S_OK;
}

//------------------------------------------------------------------------------
//	CBall::SetPosition
//------------------------------------------------------------------------------
void 
CBall::SetPosition(
				   IN const XGVECTOR3& position
				   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::SetDirection
//------------------------------------------------------------------------------
void 
CBall::SetDirection(
					IN const XGVECTOR3& direction
					)
/*++

Routine Description:

	Sets the direction of the ball

Arguments:

	IN direction -	Direction

Return Value:

	None

--*/
{
	m_direction = direction;
}

//------------------------------------------------------------------------------
//	CBall::SetSpeed
//------------------------------------------------------------------------------
void 
CBall::SetSpeed(
				IN float speed
				)
				/*++

Routine Description:

	Sets the speed of the ball

Arguments:

	IN speed -	Speed

Return Value:

	None

--*/
{
	m_speed = speed;
}

//------------------------------------------------------------------------------
//	CBall::GetSpeed
//------------------------------------------------------------------------------
float 
CBall::GetSpeed(void) const
/*++

Routine Description:

	Returns the speed of the ball

Arguments:

	None

Return Value:

	The speed of the ball

--*/
{
	return m_speed;
}

//------------------------------------------------------------------------------
//	CBall::GetDirection
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetDirection(void) const
/*++

Routine Description:

	Returns the direction of the ball

Arguments:

	None

Return Value:

	Direction of the ball

--*/
{
	return m_direction;
}

//------------------------------------------------------------------------------
//	CBall::Move
//------------------------------------------------------------------------------
void
CBall::Move(
			IN float amount
			)
/*++

Routine Description:

	Updates the position of the ball by moving it amount

Arguments:

	IN amount -	Amount to move

Return Value:

	None

--*/
{
	XGVECTOR3	da = m_direction * amount;

	m_location += da;
	m_worldMatrix(3,0) += da.x;
	m_worldMatrix(3,1) += da.y;
	m_worldMatrix(3,2) += da.z;
	m_min = XGVECTOR3(m_location.x - m_radius, m_location.y - m_radius, m_location.z - m_radius);
	m_max = XGVECTOR3(m_location.x + m_radius, m_location.y + m_radius, m_location.z + m_radius);
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::GetRadius
//------------------------------------------------------------------------------
float 
CBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CBall::Render
//------------------------------------------------------------------------------
void
CBall::Render(
			  IN IDirect3DDevice8*	pDevice,
              IN XGMATRIX*          pmViewProj,
              IN XGVECTOR3*         pvEyePos,
              IN D3DLIGHT8*         pLight,
              IN D3DCOLORVALUE*     pdcvAmbient,
              IN UINT               uPass
			  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    XGMATRIX mBackWorld, mTransform;
    XGVECTOR3 vEyePos, vLightPos;
    static XGVECTOR3 vOrigin = XGVECTOR3(0.0f, 0.0f, 0.0f);

	if(m_dontDraw)
		return;

	// Vertex shader type
//	pDevice->SetVertexShader(XYZ_NORMAL);

	// Set the material
//	pDevice->SetMaterial(&m_material);

    if (!m_bLightSource) {

        // Set the transform
        XGMatrixMultiply(&mTransform, &m_worldMatrix, pmViewProj);
        XGMatrixTranspose(&mTransform, &mTransform);
        pDevice->SetVertexShaderConstant(0, &mTransform, 4);

        XGMatrixInverse(&mBackWorld, NULL, &m_worldMatrix);

        // Transform the eye position into model space
        XGVec3TransformCoord(&vEyePos, pvEyePos, &mBackWorld);
        pDevice->SetVertexShaderConstant(5, &vEyePos, 1);

        // Transform the light position into model space
        vLightPos.x = pLight->Position.x;
        vLightPos.y = pLight->Position.y;
        vLightPos.z = pLight->Position.z;
        XGVec3TransformCoord(&vLightPos, &vLightPos, &mBackWorld);
        pDevice->SetVertexShaderConstant(4, &vLightPos, 1);

        // Set the ambient-emissive term for lighting
        if (uPass) {
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, 0);
        }
        else {
            D3DCOLORVALUE dcvAmbientEmissive;
            dcvAmbientEmissive.r = m_material.Emissive.r + m_material.Ambient.r * pdcvAmbient->r;
            dcvAmbientEmissive.g = m_material.Emissive.g + m_material.Ambient.g * pdcvAmbient->g;
            dcvAmbientEmissive.b = m_material.Emissive.b + m_material.Ambient.b * pdcvAmbient->b;
            dcvAmbientEmissive.a = m_material.Emissive.a + m_material.Ambient.a * pdcvAmbient->a;
            if (dcvAmbientEmissive.r > 1.0f) dcvAmbientEmissive.r = 1.0f;
            if (dcvAmbientEmissive.g > 1.0f) dcvAmbientEmissive.g = 1.0f;
            if (dcvAmbientEmissive.b > 1.0f) dcvAmbientEmissive.b = 1.0f;
            if (dcvAmbientEmissive.a > 1.0f) dcvAmbientEmissive.a = 1.0f;
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, (BYTE)(dcvAmbientEmissive.a * 255.0f) << 24 | 
                                                           (BYTE)(dcvAmbientEmissive.r * 255.0f) << 16 |
                                                           (BYTE)(dcvAmbientEmissive.g * 255.0f) << 8 |
                                                           (BYTE)(dcvAmbientEmissive.b * 255.0f));
        }

        pDevice->SetVertexShaderConstant(7, &pLight->Attenuation0, 1);
        pDevice->SetVertexShaderConstant(8, &XGVECTOR4(0.0f, 0.0f, 0.0f, pLight->Range), 1);
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_1, ModulateColors(&pLight->Diffuse, &m_material.Diffuse));
        pDevice->SetRenderState(D3DRS_PSCONSTANT1_1, ModulateColors(&pLight->Specular, &m_material.Specular));
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_2, ModulateColors(&pLight->Ambient, &m_material.Ambient));

        // Draw opaque on the first pass, translucent on all subsequent passes
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, uPass ? TRUE : FALSE);

        if (g_TestParams.bTextureBalls) {
            pDevice->SetTexture(0, m_pd3dtBase);
            pDevice->SetTexture(1, m_pd3dtBump);
        }
        else {
            pDevice->SetTexture(0, m_pd3dtWhite);
            pDevice->SetTexture(1, m_pd3dtFlat);
        }

	    // Set the vertex buffer stream source
	    pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	    // Fill mode
	    pDevice->SetRenderState(D3DRS_FILLMODE, m_fillMode);

	    // Draw the object
	    pDevice->SetIndices(m_pIB, 0);
	    pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
							          m_numTriangles);
    }
    else {

	    // Set the translation
    	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

        pDevice->SetVertexShader(D3DFVF_XYZ);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_TFACTOR);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

        //Render black if we're not on beat, otherwise the light's real color.
		pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA((BYTE)(255.0f * m_light.Diffuse.r), (BYTE)(255.0f * m_light.Diffuse.g), (BYTE)(255.0f * m_light.Diffuse.b), (BYTE)(255.0f * m_light.Diffuse.a)));

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

        pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

        pDevice->SetTexture(3, m_pd3dtLight);

        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3));

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    }

    RenderAudio();
}

//------------------------------------------------------------------------------
//	CBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CBall::GetNumTris
//------------------------------------------------------------------------------
int 
CBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CBall::GetLocation
//------------------------------------------------------------------------------
const XGVECTOR3&
CBall::GetLocation(void) const
/*++

Routine Description:

	Returns the location of the ball

Arguments:

	None

Return Value:

	The location of the ball

--*/
{
	return m_location;
}

//------------------------------------------------------------------------------
//	CBall::Release
//------------------------------------------------------------------------------
void
CBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}

	if ( m_pCollisionSound )
	{
		m_pCollisionSound->Release();
		m_pCollisionSound = NULL;
	}

	if ( m_pAmbientSound )
	{
		m_pAmbientSound->Release();
		m_pAmbientSound = NULL;
	}

	if ( m_pSubMix )
	{
		m_pSubMix->Release();
		m_pSubMix = NULL;
	}

    if(m_pCollisionSoundData)
    {
        m_pCollisionSoundData->Release();
        m_pCollisionSoundData = NULL;
    }

    if(m_pAmbientSoundData)
    {
        m_pAmbientSoundData->Release();
        m_pAmbientSoundData = NULL;
    }
}

//------------------------------------------------------------------------------
//	CBall::InitAudio
//------------------------------------------------------------------------------
HRESULT
CBall::InitAudio( void )
/*++

Routine Description:

	Init the sound buffer

Arguments:

	None

Return Value:

	S_OK, E_XXXX

--*/
{	
    HRESULT                 hr  = DS_OK;

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::CreateSubMixDestination
//------------------------------------------------------------------------------
HRESULT
CBall::CreateSubMixDestination( void )
{
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ASSERT(!m_pSubMix);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwFlags = DSBCAPS_MIXIN;

    if(g_TestParams.b3DSound)
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }

    return DirectSoundCreateBuffer(&dsbd, &m_pSubMix);
}

//------------------------------------------------------------------------------
//	CBall::CreateCollisionSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateCollisionSound( void )
{
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwAudioDataSize;
    HRESULT                 hr;

    ASSERT(!m_pCollisionSound);
    ASSERT(!m_pCollisionSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pCollisionSoundData = &m_CollisionSoundData;
    hr = m_pCollisionSoundData->CreateFile(g_TestParams.szBounceSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);

    if(SUCCEEDED(hr))
    {
        m_dwCollisionFrequency = dsbd.lpwfxFormat->nSamplesPerSec;
        
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pCollisionSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pCollisionSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pCollisionSound->SetOutputBuffer(m_pSubMix);
    }

    if(FAILED(hr) && m_pCollisionSound)
    {
        m_pCollisionSound->Release();
        m_pCollisionSound = NULL;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::CreateAmbientSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateAmbientSound( void )
{
    WAVEFORMATEX            wfx;
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwSampleCount;
    DWORD                   dwAudioDataSize;
    BOOL                    fInit;
    DSLFODESC               lfo;
    HRESULT                 hr;
    int                     i;

    ASSERT(!m_pAmbientSound);
    ASSERT(!m_pAmbientSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));
    ZeroMemory(&lfo, sizeof(lfo));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pAmbientSoundData = &m_AmbientSoundData;

    if(g_TestParams.szLightSound[0])
    {
        hr = m_pAmbientSoundData->CreateFile(g_TestParams.szLightSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);
    }
    else
    {
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = 1;
        wfx.nSamplesPerSec = AMBIENT_SOUND_FREQUENCY;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0;
    
        dsbd.lpwfxFormat = &wfx;

        dwSampleCount = 128;
        dwAudioDataSize = dwSampleCount * wfx.nBlockAlign;
    
        hr = m_pAmbientSoundData->CreateEmpty(&wfx, dwAudioDataSize, &pvAudioData, &fInit);

        if(SUCCEEDED(hr) && fInit)
        {
            for(i = 0; i < (int)dwSampleCount; i++)
            {
                *((short *)pvAudioData + i) = (short)(65536 * ((float)(i - (dwSampleCount / 2)) / (FLOAT)dwSampleCount));
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pAmbientSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pAmbientSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pAmbientSound->SetOutputBuffer(m_pSubMix);
    }

    if(SUCCEEDED(hr))
    {
        lfo.dwLFO = DSLFO_MULTI;
        lfo.dwDelta = 200;
        lfo.lPitchModulation = 64;
        lfo.lAmplitudeModulation = 48;

        hr = m_pAmbientSound->SetLFO(&lfo);
    }

    if(FAILED(hr) && m_pAmbientSound)
    {
        m_pAmbientSound->Release();
        m_pAmbientSound = NULL;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::GetLight
//------------------------------------------------------------------------------
D3DLIGHT8*
CBall::GetLight( void )
{
  
    return &m_light;
}

//------------------------------------------------------------------------------
//	CBall::PlayBuffer
//------------------------------------------------------------------------------
void
CBall::PlayBuffer(
				  IN float	volume,
				  IN float	pitch
				  )
/*++

Routine Description:

	Play the sound Buffer

Arguments:

	IN volume	- Volume (0.0 - 1.0)
	IN pitch	- Pitch (0.0 - 1.0)

Return Value:

	None

--*/
{
    static const DWORD      dwVolumeRange   = 3000; // 0-30dB
    static const DWORD      dwPitchRange    = 4; // +/-2 octaves
    const LONG              lGlobalVolume   = g_TestParams.lDSVolume;
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalVolume;
    LONG                    lLocalPitch;
    
    lLocalVolume = (LONG)-((1.0f - volume) * (FLOAT)dwVolumeRange);
    lLocalPitch = (LONG)((0.5f - pitch) * (FLOAT)dwPitchRange) << 12;

	if(m_pCollisionSound)
	{
        if(!m_pSubMix)
        {
		    lLocalVolume += lGlobalVolume;
            lLocalPitch += lGlobalPitch;
        }
            
        if(lLocalVolume > DSBVOLUME_MAX)
        {
            lLocalVolume = DSBVOLUME_MAX;
        }
        else if(lLocalVolume < DSBVOLUME_MIN)
        {
            lLocalVolume = DSBVOLUME_MIN;
        }
        
        m_pCollisionSound->SetVolume(lLocalVolume);

        if(lLocalPitch > DSBPITCH_MAX)
        {
            lLocalPitch = DSBPITCH_MAX;
        }
        else if(lLocalPitch < DSBPITCH_MIN)
        {
            lLocalPitch = DSBPITCH_MIN;
        }

		m_pCollisionSound->SetPitch(lLocalPitch);

        if(!m_pSubMix && g_TestParams.b3DSound)
        {
            m_pCollisionSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
        }

		m_pCollisionSound->Play(0, 0, DSBPLAY_FROMSTART);
	}
}

//------------------------------------------------------------------------------
//	CBall::RenderAudio
//------------------------------------------------------------------------------
void
CBall::RenderAudio(void)
{
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalPitch;
    
    if(m_pSubMix)
    {
        m_pSubMix->SetVolume(g_TestParams.lDSVolume);
        m_pSubMix->SetPitch(lGlobalPitch);

        if(g_TestParams.b3DSound)
        {
            m_pSubMix->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
            m_pSubMix->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
        }
    }

    if(m_pAmbientSound)
    {
        if(m_pSubMix)
        {
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume);
        }
        else
        {
            lLocalPitch = CalculatePitch(AMBIENT_SOUND_FREQUENCY);
            
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume + g_TestParams.lDSVolume);
            m_pAmbientSound->SetPitch(lLocalPitch + lGlobalPitch);

            if(g_TestParams.b3DSound)
            {
                m_pAmbientSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
                m_pAmbientSound->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
            }
        }

        m_pAmbientSound->Play(0, 0, DSBPLAY_LOOPING);
    }
}

//------------------------------------------------------------------------------
//	CBall::DisableAmbientAudio
//------------------------------------------------------------------------------
void
CBall::DisableAmbientAudio(void)
{
    if(m_pAmbientSound)
    {
        m_pAmbientSound->Stop();
    }
}

//------------------------------------------------------------------------------
//	CBall::DrawSolid
//------------------------------------------------------------------------------
void 
CBall::DrawSolid(void)
/*++

Routine Description:

	Sets the render state of the ball to render solid

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_SOLID;
}

//------------------------------------------------------------------------------
//	CBall::DrawWireframe
//------------------------------------------------------------------------------
void 
CBall::DrawWireframe(void)
/*++

Routine Description:

	Sets the render state of the ball to render wireframe

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_WIREFRAME;
}

//------------------------------------------------------------------------------
//	CBall::DrawPoints
//------------------------------------------------------------------------------
void 
CBall::DrawPoints(void)
/*++

Routine Description:

	Sets the render state of the ball to render as points

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_POINT;
}

//------------------------------------------------------------------------------
//	CBall::DrawReduced
//------------------------------------------------------------------------------
void
CBall::DrawReduced(void)
/*++

Routine Description:

	Draws in a reduced mode based on the level of detail

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_detail > 16)
		DrawPoints();
	else
		DrawWireframe();
}

//******************************************************************************
void CBall::PlaceLightInRange(UINT uLight, BOOL bInRange) {

    DWORD dwLight;
    UINT index;

    for (index = 0; uLight > 31; uLight -= 32, index++);

    if (index > 4) {
        // Light index exceeds the maximum
        __asm int 3;
        return;
    }

    if (bInRange) {
        m_dwInLightRange[index] |= (1 << uLight);
    }
    else {
        m_dwInLightRange[index] &= ~(1 << uLight);
    }
}

//******************************************************************************
HRESULT CBall::CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, LPCSTR szImage, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dtHeight, *pd3dt;
    D3DSURFACE_DESC d3dsd;
    D3DLOCKED_RECT d3dlr;
    float* pfHeightMap, *pfHeight;
    LPDWORD pdwPixel;
    UINT i, x, y, uCount;
    XGVECTOR3 v1, v2, n;
    HRESULT hr;

    if (!ppd3dt) {   
        return E_FAIL;
    }

    *ppd3dt = NULL;

    hr = D3DXCreateTextureFromFileEx(pDevice, szImage, D3DX_DEFAULT, D3DX_DEFAULT, 
                                D3DX_DEFAULT, 0, D3DFMT_X8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &pd3dtHeight);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dtHeight->GetLevelDesc(0, &d3dsd);

    // Create the bump map
    hr = pDevice->CreateTexture(d3dsd.Width, d3dsd.Height, 0, 0, D3DFMT_X8R8G8B8, 0, &pd3dt);
    if (!pd3dt) {
        pd3dtHeight->Release();
        return hr;
    }

    pfHeightMap = (float*)HeapAlloc(GetProcessHeap(), 0, d3dsd.Width * d3dsd.Height * sizeof(float));
    if (!pfHeightMap) {
        pd3dtHeight->Release();
        pd3dt->Release();
        return E_OUTOFMEMORY;
    }

    uCount = pd3dtHeight->GetLevelCount();

    for (i = 0; i < uCount; i++) {

        pd3dtHeight->GetLevelDesc(i, &d3dsd);

        // Convert the pixel intensities in the source image into height values
        // ranging from 0.0 to 1.0
        pd3dtHeight->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        Swizzler swz(d3dsd.Width, d3dsd.Height, 1);
        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                pfHeightMap[y * d3dsd.Width + x] = 
                       (float)(((pdwPixel[swz.Get2D()] >> 16) & 0xFF) +
                               ((pdwPixel[swz.Get2D()] >> 8)  & 0xFF) +
                               ((pdwPixel[swz.Get2D()])       & 0xFF)) / 3.0f / 255.0f;
                swz.IncU();
            }

//            pdwPixel += d3dlr.Pitch >> 2;
            swz.IncV();
        }

        pd3dtHeight->UnlockRect(i);

        // Calculate normal map vectors from the height map information
        pd3dt->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        v1 = XGVECTOR3(0.0f, 0.0f, 0.0f);
        v2 = XGVECTOR3(0.0f, 0.0f, 0.0f);

        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                // Tiled
                pfHeight = &pfHeightMap[y * d3dsd.Width + x];
                if (y == d3dsd.Height - 1) {
                    v2.z = -(pfHeightMap[x] - *pfHeight);
                }
                else {
                    v2.z = -(pfHeight[d3dsd.Width] - pfHeight[0]);
                }
                if (x == d3dsd.Width - 1) {
                    v1.z = -(*(pfHeight - x) - *pfHeight);
                }
                else {
                    v1.z = -(pfHeight[1] - pfHeight[0]);
                }
                v1.x = (float)sqrt(1.0f - v1.z * v1.z);
                v2.y = (float)sqrt(1.0f - v2.z * v2.z);
                XGVec3Cross(&n, &v2, &v1);
                XGVec3Normalize(&n, &n);
                pdwPixel[swz.Get2D()] = VectorToColor(&n);

                swz.IncU();
            }

            swz.IncV();
        }

        pd3dt->UnlockRect(i);
    }

    HeapFree(GetProcessHeap(), 0, pfHeightMap);
    pd3dtHeight->Release();

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
HRESULT CBall::CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dt;
    D3DLOCKED_RECT d3dlr;
    LPDWORD pdwTexel;
    D3DXVECTOR3 vNormal, vCenter, vUp;
    float fRadius, fRadiusSq;
    BYTE Intensity;
    UINT i, j;
    HRESULT hr;
    Swizzler swz(uLength, uLength, 1);

    if (!ppd3dt) {
        return FALSE;
    }

    *ppd3dt = NULL;

    hr = pDevice->CreateTexture(uLength, uLength, 0, 0, D3DFMT_A8R8G8B8, 0, &pd3dt);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dt->LockRect(0, &d3dlr, NULL, 0);
    pdwTexel = (LPDWORD)d3dlr.pBits;
    fRadius = (float)(uLength / 2);
    fRadiusSq = fRadius * fRadius;
    vCenter = D3DXVECTOR3(fRadius + 0.5f, fRadius + 0.5f, 0.0f);
    vUp = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    swz.SetU(0);
    swz.SetV(0);

    for (i = 0; i < uLength; i++) {

        for (j = 0; j < uLength; j++) {

            vNormal = D3DXVECTOR3((float)j, (float)i, 0.0f) - vCenter;
            if (D3DXVec3Length(&vNormal) < fRadius) {
                vNormal.z = (float)sqrt(fRadiusSq - vNormal.x * vNormal.x - vNormal.y * vNormal.y);
                D3DXVec3Normalize(&vNormal, &vNormal);
                Intensity = (BYTE)(D3DXVec3Dot(&vNormal, &vUp) * 255.0f);
                pdwTexel[swz.Get2D()] = D3DCOLOR_RGBA(Intensity, Intensity, Intensity, Intensity);
            }
            else {
                pdwTexel[swz.Get2D()] = 0;
            }

            swz.IncU();
        }

        swz.IncV();
    }

    pd3dt->UnlockRect(0);

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
// Calculate non-normalized tangent and binormal vector terms for use in
// constructing an othonormal basis transform to rotate a vector from model
// space to tangent space.
//******************************************************************************
BOOL CBall::CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                                            Vertex* prVertices, LPWORD pwIndices, 
                                            UINT uNumIndices, BOOL bInterpolate)
{
    XGVECTOR3       vEdge0, vEdge1, vTemp;
    XGVECTOR3       vPlane[3];
    WORD            w0, w1, w2;
    float           fTemp;
    UINT            i, j, k;

    memset(pvTangent, 0, uNumIndices * sizeof(XGVECTOR3));
    memset(pvBinormal, 0, uNumIndices * sizeof(XGVECTOR3));

    // Calculate the tangent and binormal vectors for each vertex.  If the vertex is
    // indexed by more than one triangle, add the vectors for each triangle together
    // to obtain an average of the vectors for all triangles formed by the vertex.
    for (i = 0; i < uNumIndices; i+=3) {

        w0 = pwIndices[i];
        w1 = pwIndices[i+1];
        w2 = pwIndices[i+2];

        vEdge0 = XGVECTOR3(prVertices[w1].position.x - prVertices[w0].position.x, prVertices[w1].tu - prVertices[w0].tu, prVertices[w1].tv - prVertices[w0].tv);
        vEdge1 = XGVECTOR3(prVertices[w2].position.x - prVertices[w0].position.x, prVertices[w2].tu - prVertices[w0].tu, prVertices[w2].tv - prVertices[w0].tv);
        XGVec3Cross(&vPlane[0], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.y - prVertices[w0].position.y;
        vEdge1.x = prVertices[w2].position.y - prVertices[w0].position.y;
        XGVec3Cross(&vPlane[1], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.z - prVertices[w0].position.z;
        vEdge1.x = prVertices[w2].position.z - prVertices[w0].position.z;
        XGVec3Cross(&vPlane[2], &vEdge0, &vEdge1);

        if (FABS(vPlane[0].x) < 0.000000001f || FABS(vPlane[1].x) < 0.000000001f || FABS(vPlane[2].x) < 0.000000001f) {
            return FALSE;
        }

        vTemp = XGVECTOR3(-vPlane[0].y / vPlane[0].x, -vPlane[1].y / vPlane[1].x, -vPlane[2].y / vPlane[1].x);
        pvTangent[w0] += vTemp;
        pvTangent[w1] += vTemp;
        pvTangent[w2] += vTemp;

        vTemp = XGVECTOR3(-vPlane[0].z / vPlane[0].x, -vPlane[1].z / vPlane[1].x, -vPlane[2].z / vPlane[1].x);
        pvBinormal[w0] += vTemp;
        pvBinormal[w1] += vTemp;
        pvBinormal[w2] += vTemp;
    }

    if (bInterpolate) {

        LPWORD          pwMerge, pwProcessed;
        UINT            uNumMerges, uNumProcessed = 0;

        pwMerge = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwMerge) {
            return FALSE;
        }

        pwProcessed = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwProcessed) {
            HeapFree(GetProcessHeap(), 0, pwMerge);
            return FALSE;
        }

        for (i = 0; i < uNumIndices; i++) {

            // Verify pwIndices[i] has to already been processed...if it has continue
            for (j = 0; j < uNumProcessed; j++) {
                if (pwIndices[i] == pwProcessed[j]) {
                    break;
                }
            }
            if (j < uNumProcessed) {
                continue;
            }

            pwMerge[0] = pwIndices[i];
            pwProcessed[uNumProcessed++] = pwIndices[i];
            uNumMerges = 1;

            // Traverse the vertex list, identifying all vertices whose positions are
            // equal to the current vertex position
            for (j = i + 1; j < uNumIndices; j++) {

                fTemp = XGVec3LengthSq(&(prVertices[pwIndices[i]].position - prVertices[pwIndices[j]].position));
                if (fTemp < 0.0000001f) {

                    // See whether the matching vertex has already been added to the merge list
                    for (k = 0; k < uNumMerges; k++) {
                        if (pwIndices[j] == pwMerge[k]) {
                            break;
                        }
                    }
                    if (k == uNumMerges) {
                        pwMerge[uNumMerges++] = pwIndices[j];
                        pwProcessed[uNumProcessed++] = pwIndices[j];
                    }
                }
            }

            if (uNumMerges > 1 && uNumMerges < 5) {
                w0 = pwMerge[0];
                XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
                XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);
                for (j = 1; j < uNumMerges; j++) {
                    w1 = pwMerge[j];
                    XGVec3Normalize(&pvTangent[w1], &pvTangent[w1]);
                    XGVec3Normalize(&pvBinormal[w1], &pvBinormal[w1]);
                    pvTangent[w0] += pvTangent[w1];
                    pvBinormal[w0] += pvBinormal[w1];
                }
                for (j = 1; j < uNumMerges; j++) {
                    pvTangent[pwMerge[j]] = pvTangent[w0];
                    pvBinormal[pwMerge[j]] = pvBinormal[w0];
                }
            }
        }

        HeapFree(GetProcessHeap(), 0, pwProcessed);
        HeapFree(GetProcessHeap(), 0, pwMerge);
    }

    return TRUE;
}

//******************************************************************************
BOOL CBall::ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, UINT uNumIndices, BOOL bInterpolate) {

    XGVECTOR3       vNormal, vTemp;
    XGVECTOR3       *pvTangent, *pvBinormal;
    WORD            w0;
    XGVECTOR3*      pmT;
    XGVECTOR3       mZero[3];
	UINT            i;

    memset(&mZero, 0, 3 * sizeof(XGVECTOR3));

    for (i = 0; i < uNumIndices; i++) {
        memcpy((LPBYTE)&prVertices[pwIndices[i]].vTangent.x, &mZero, 3 * sizeof(XGVECTOR3));
    }

    pvTangent = (XGVECTOR3*)HeapAlloc(GetProcessHeap(), 0, 2 * uNumIndices * sizeof(XGVECTOR3));
    if (!pvTangent) {
        return FALSE;
    }
    pvBinormal = pvTangent + uNumIndices;

    if (!CalculateTangentTerms(pvTangent, pvBinormal, prVertices, pwIndices, uNumIndices, bInterpolate)) {
        HeapFree(GetProcessHeap(), 0, pvTangent);
        return FALSE;
    }

    for (i = 0; i < uNumIndices; i++) {

        w0 = pwIndices[i];
        pmT = (XGVECTOR3*)((LPBYTE)&prVertices[w0].vTangent.x);
        if (!memcmp(pmT, &mZero, 3 * sizeof(XGVECTOR3))) {

            XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
            XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);

            XGVec3Cross(&vNormal, &pvTangent[w0], &pvBinormal[w0]);

            pmT[0].x = -pvTangent[w0].x;
            pmT[0].y = -pvTangent[w0].y;
            pmT[0].z = -pvTangent[w0].z;

            pmT[1].x = -pvBinormal[w0].x;
            pmT[1].y = -pvBinormal[w0].y;
            pmT[1].z = -pvBinormal[w0].z;

            pmT[2].x = vNormal.x;
            pmT[2].y = vNormal.y;
            pmT[2].z = vNormal.z;
        }
    }

    HeapFree(GetProcessHeap(), 0, pvTangent);

    return TRUE;
}

//------------------------------------------------------------------------------
//	CBall::IsLightSource
//------------------------------------------------------------------------------
BOOL 
CBall::IsLightSource(void) const
/*++

Routine Description:

	Returns TRUE if the ball is a light source, FALSE otherwise

Arguments:

	None

Return Value:

	TRUE if the ball is a light source, FALSE otherwise

--*/
{
	return m_bLightSource;
}
}

//------------------------------------------------------------------------------
//	CBall::CalculatePitch
//------------------------------------------------------------------------------

LONG
CBall::CalculatePitch
(
    DWORD                   dwFrequency
)
{
    static const DWORD      dwBaseFrequency = 48000;
    FLOAT                   fl4096          = 4096.0f;
    FLOAT                   flRatio         = (FLOAT)dwFrequency / (FLOAT)dwBaseFrequency;
    LONG                    lPitch;

    if(dwBaseFrequency == dwFrequency)
    {
        lPitch = 0;
    }
    else if(!dwFrequency)
    {
        lPitch = DSBPITCH_MIN;
    }
    else
    {
        __asm 
        {
            fld     fl4096
            fld     flRatio
            fyl2x
            fistp   lPitch
        }
    }

    return lPitch;
}

//------------------------------------------------------------------------------
//	CAudioData::CAudioData
//------------------------------------------------------------------------------

CAudioData::CAudioData(void)
{
    m_pwfxFormat = NULL;
    m_pvAudioData = NULL;
    m_dwAudioDataSize = NULL;
    m_dwRefCount = 0;
}

//------------------------------------------------------------------------------
//	CAudioData::~CAudioData
//------------------------------------------------------------------------------

CAudioData::~CAudioData(void)
{
    if(m_pwfxFormat)
    {
        delete [] m_pwfxFormat;
    }

    if(m_pvAudioData)
    {
        delete [] m_pvAudioData;
    }
}

//------------------------------------------------------------------------------
//	CAudioData::CreateFile
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize)
{
    LPXFILEMEDIAOBJECT      pFile       = NULL;
    HRESULT                 hr          = DS_OK;
    LPCWAVEFORMATEX         pwfxFormat;
    XMEDIAPACKET            xmp;

    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        hr = XWaveFileCreateMediaObject(pszFile, &pwfxFormat, &pFile);

        if(SUCCEEDED(hr))
        {
            if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            hr = pFile->GetLength(&m_dwAudioDataSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            ZeroMemory(&xmp, sizeof(xmp));

            xmp.pvBuffer = m_pvAudioData;
            xmp.dwMaxSize = m_dwAudioDataSize;
            
            hr = pFile->Process(NULL, &xmp);
        }

        if(pFile)
        {
            pFile->Release();
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppwfxFormat = m_pwfxFormat;
        *ppvAudioData = m_pvAudioData;
        *pdwAudioDataSize = m_dwAudioDataSize;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CAudioData::CreateEmpty
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize)
{
    HRESULT                 hr  = DS_OK;
    
    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        m_dwAudioDataSize = dwAudioDataSize;

        if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
        {
            hr = DSERR_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppvAudioData = m_pvAudioData;
        *pfInitialize = (1 == m_dwRefCount);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\Camera.h ===
// Camera.h: interface for the CCamera class.
//
//////////////////////////////////////////////////////////////////////

#ifndef CAMERA_H
#define CAMERA_H

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media4 {

//------------------------------------------------------------------------------
//	CCamera:
//------------------------------------------------------------------------------
class CCamera  
{
public:

	struct Vertex
	{
		FLOAT	x, y, z;
		DWORD	color;
	};

public:

	CCamera(void);
	virtual ~CCamera(void);
	void Render(IDirect3DDevice8*);
	void SetViewport(DWORD, DWORD, DWORD, DWORD, float, float);
	void SetViewport(const D3DVIEWPORT8&);
	const D3DVIEWPORT8& GetViewport(void);
	void LookAt(const XGVECTOR3&, const XGVECTOR3&, const XGVECTOR3&);
	void SetPerspectiveFov(float, float, float, float);
	void Zoom(float);
	void Rotate(float, const XGVECTOR3&);
	void RotateX(float);
	void RotateY(float);
	void RotateZ(float);
	void EnableLight(BOOL, BOOL fixedLight);
	void SetLight(DWORD, const D3DLIGHT8&);
	void RotateLight(float, const XGVECTOR3&);
	void RotateLightX(float);
	void RotateLightY(float);
	void SetDrawAxis(BOOL);
	void SetHome(void);
	void GoHome(void);
    void GetPosition(XGVECTOR3* pvPosition);

private:

	void UpdateLight(void);
	void MakeRotationMatrices(float, const XGVECTOR3&, XGMATRIX&, XGMATRIX&);

private:

	D3DVIEWPORT8	m_viewport;			// Viewport
	XGMATRIX		m_viewMatrix;		// View matrix
	XGMATRIX		m_projectionMatrix;	// Projection matrix
	D3DLIGHT8		m_light;			// Light parameters
	XGVECTOR3		m_focalPoint;		// Focal point of camera
	XGVECTOR3		m_position;			// Position of camera
	XGVECTOR3		m_viewUp;			// View up vector of camera
	XGVECTOR3		m_vpn;				// View plane normal of camera
	XGVECTOR3		m_lightPosition;	// Position of light
	DWORD			m_lightNum;			// Llight number
	BOOL			m_lightOn;			// TRUE to enable the light
	BOOL			m_fixedLight;		// TRUE to lock light to the camera position
	Vertex			m_axis[6];			// Axis for rendering
	BOOL			m_drawAxis;			// TRUE to draw axis
	Vertex			m_lightNormal[2];	// Light normal
	XGVECTOR3		m_homeFocalPoint;
	XGVECTOR3		m_homePosition;
	XGVECTOR3		m_homeViewUp;
	XGVECTOR3		m_homeVpn;
	XGVECTOR3		m_homeLightPosition;
	BOOL			m_homeLightOn;
	BOOL			m_homeFixedLight;
	float			m_aspect;
	float			m_fov;
	float			m_zNear;
	float			m_zFar;
	float			m_dz;

};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\media.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.h

Abstract:

	Media Stress - D3D, DSound, DMusic and others

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\helpers.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:
--*/


#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include <xgmath.h>
#include <dmusici.h>
#include "stdio.h"

namespace Media4 {

//TESTPARAMS STUFF
struct TESTPARAMS
{
    
    DWORD dwSeed;
    DWORD dwBallDetail;
    DWORD dwWallDetail;
    DWORD dwLightDetail;
    DWORD dwNumLayers;	
    DWORD dwNumBalls;	
    DWORD dwMaxBalls;
    DWORD dwNumLights;
    DWORD dwMaxLights;
    FLOAT fRadius;
    FLOAT fMaxSpeed;
    FLOAT fMinSpeed;
    BOOL  bTextureBalls;
    CHAR  szBallBaseTex[MAX_PATH];
    CHAR  szBallBumpTex[MAX_PATH];
    CHAR  szSphereBaseTex[MAX_PATH];
    CHAR  szLightVSH[MAX_PATH];
    CHAR  szSparkVSH[MAX_PATH];
    BOOL  bDMusic;
    BOOL  bDMDoWorkLocally;
    BOOL  bDMUseGM;
    DWORD dwDMVoiceCount;
    CHAR  szDMStressDir [MAX_PATH];
    CHAR  szDMSupportDir[MAX_PATH];
    CHAR  szDMAudioPath[MAX_PATH];
    CHAR  szDMHeap[MAX_PATH];
    DWORD dwDMFixedHeapSizeNorm;
    DWORD dwDMFixedHeapSizePhys;
    LPSTR *ppDMSegments;
    DWORD dwDMSegments;
    BOOL  bDMLoaderThread;
	BOOL  bDrawWireframe;
	BOOL  bRelativeSpeed;
	BOOL  bD3DPerf;
    DWORD dwMaxSparks;
    BOOL  bSparksAreLights;
    DWORD dwSparksPerCollision;
	DWORD dwSparkMaxAge;
    DWORD dwFileIOSize;
    LONG  lDMMasterVolume;
    float fDMMasterTempo;
    short lDMMasterTranspose;
    DWORD dwDMSelected;

    CHAR  szDSScratchImage[MAX_PATH];
    CHAR  szDSHRTF[MAX_PATH];

    CHAR szDSEnvironment[MAX_PATH];
    BOOL b3DSound;
    CHAR szLightSound[MAX_PATH];
    CHAR szBounceSound[MAX_PATH];
    BOOL bSubMixBallSound;
    BOOL bLightSound;
	LONG lDSVolume;
	DWORD dwDSFreq;
    LONG lAmbientVolume;
    BOOL bCopyMediaFromNetwork;

    DWORD dwMultiSampleType;
    DWORD dwBackBufferCount;
    BOOL bCycleDisplayModes;
    DWORD dwCycleTime;
};


extern TESTPARAMS g_TestParams;
HRESULT LoadTestParams(void);
HRESULT FreeTestParams(void);
HRESULT SanityCheckTestParams(void);
HRESULT SanityCheckFiles(void);
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile);


//OTHER STUFF
HRESULT Log(LPSTR szFormat, ...);
typedef HRESULT (*LOADPROC)(LPSTR szFullPath, LPVOID pVoid);
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid);
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut);

//DMusic segment playback stuff
HRESULT WaitForSegmentStop (IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT WaitForSegmentStart(IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);
HRESULT ExpectSegmentStop (IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);




inline DWORD F2DW(float f) { return *((LPDWORD)&f); }

inline D3DCOLOR VectorToColor(XGVECTOR3* pv) {
    
    return ((BYTE)((pv->x + 1.0f) / 2.0f * 255.0f) << 16) |
           ((BYTE)((pv->y + 1.0f) / 2.0f * 255.0f) << 8)  |
            (BYTE)((pv->z + 1.0f) / 2.0f * 255.0f);
}

D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2);

struct AUDIOPATHPAIR
{
    LPSTR szString;
    DWORD dwValue;
};

extern AUDIOPATHPAIR AudioPathPairs[4];

extern HANDLE g_hLogMedia;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\helpers.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:



--*/

//------------------------------------------------------------------------------
//	Includes:
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <stdio.h>
#include <io.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "media.h"
#include "helpers.h"
#include "macros.h"
#include "DSSTDFX.h"

#ifdef _DEBUG
    extern "C" DWORD g_dwDirectSoundDebugLevel;
    extern "C" DWORD g_dwDirectSoundDebugBreakLevel;
#endif

using namespace Media4;

namespace Media4 {

AUDIOPATHPAIR AudioPathPairs[4] = 
{
{"DMUS_APATH_SHARED_STEREOPLUSREVERB", DMUS_APATH_SHARED_STEREOPLUSREVERB},
{"DMUS_APATH_SHARED_STEREO", DMUS_APATH_SHARED_STEREO},
{"DMUS_APATH_DYNAMIC_MONO", DMUS_APATH_DYNAMIC_MONO},
{"DMUS_APATH_DYNAMIC_3D", DMUS_APATH_DYNAMIC_3D}
};


  
//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT Log
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    OutputDebugStringA(szBuffer);
    return S_OK;
};


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid)
{
	HRESULT hr = S_OK;
	WIN32_FIND_DATA findData;
	BOOL bMore = TRUE;
	HANDLE hFiles;
	CHAR szFullPath[MAX_PATH];
	CHAR szFiles[MAX_PATH];

	sprintf( szFiles, "%s\\*", szDir ); 

	hFiles = FindFirstFile( szFiles, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore && SUCCEEDED( hr ) )
	{
		sprintf( szFullPath, "%s\\%s", szDir, findData.cFileName );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CHECKRUN( RecurseDirectory( szFullPath, LoadFile, pVoid) );
		}

		else
		{
			CHECKRUN( LoadFile(szFullPath, pVoid) );
		}

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}



//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut)
{
LPSTR szFile = NULL;
DWORD dwLength;

if (!szFullString)
{
    szPathOut[0] = NULL;
    szFileOut[0] = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (LPSTR)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

strcpy(szFileOut, szFile);

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szPathOut, szFullString, dwLength);
szPathOut[dwLength] = NULL;

return S_OK;
}


TESTPARAMS g_TestParams = {0};

//------------------------------------------------------------------------------
//Print Test Params
//------------------------------------------------------------------------------
HRESULT PrintTestParams(void)
{
    Log("\n");
    Log("---------- STRESS PARAMETERS --------\n");
    Log("dwSeed:                %lu\n", g_TestParams.dwSeed);
    Log("dwBallDetail:          %lu\n", g_TestParams.dwBallDetail);
    Log("dwWallDetail:          %lu\n", g_TestParams.dwWallDetail);
    Log("dwLightDetail:         %lu\n", g_TestParams.dwLightDetail);
    Log("dwNumLayers:           %lu\n", g_TestParams.dwNumLayers);
    Log("dwNumBalls:            %lu\n", g_TestParams.dwNumBalls);
    Log("dwMaxBalls:            %lu\n", g_TestParams.dwMaxBalls);
    Log("dwNumLights:           %lu\n", g_TestParams.dwNumLights);
    Log("dwMaxLights:           %lu\n", g_TestParams.dwMaxLights);
    Log("fRadius:               %g\n", g_TestParams.fRadius);
    Log("fMaxSpeed:             %g\n", g_TestParams.fMaxSpeed);
    Log("fMinSpeed:             %g\n", g_TestParams.fMinSpeed);
    Log("bTextureBalls          %s\n", g_TestParams.bTextureBalls ? "TRUE" : "FALSE");
    Log("szBallBaseTex:         %s\n", g_TestParams.szBallBaseTex);
    Log("szBallBumpTex:         %s\n", g_TestParams.szBallBumpTex);
    Log("szSphereBaseTex:       %s\n", g_TestParams.szSphereBaseTex);
    Log("szLightVSH:            %s\n", g_TestParams.szLightVSH);
    Log("szSparkVSH:            %s\n", g_TestParams.szSparkVSH);
    Log("bDMusic:               %s\n", g_TestParams.bDMusic ? "TRUE" : "FALSE");
    Log("bDMDoWorkLocally:      %s\n", g_TestParams.bDMDoWorkLocally ? "TRUE" : "FALSE");
    Log("bDMUseGM:              %s\n", g_TestParams.bDMUseGM ? "TRUE" : "FALSE");
    Log("bDMLoaderThread:       %s\n", g_TestParams.bDMLoaderThread ? "TRUE" : "FALSE");
    Log("dwDMVoiceCount:        %d\n", g_TestParams.dwDMVoiceCount);
    Log("szDMStressDir:         %s\n", g_TestParams.szDMStressDir);
    Log("szDMSupportDir:        %s\n", g_TestParams.szDMSupportDir);
    Log("szDMAudioPath:         %s\n", g_TestParams.szDMAudioPath);
    Log("szDMHeap:              %s\n", g_TestParams.szDMHeap);
    Log("dwDMFixedHeapSizeNorm: %u\n", g_TestParams.dwDMFixedHeapSizeNorm);
    Log("dwDMFixedHeapSizePhys: %u\n", g_TestParams.dwDMFixedHeapSizePhys);
    Log("dwMaxSparks:           %lu\n", g_TestParams.dwMaxSparks);
    Log("bSparksAreLights:      %s\n", g_TestParams.bSparksAreLights ? "TRUE" : "FALSE");
    Log("dwSparksPerCollision:  %lu\n", g_TestParams.dwSparksPerCollision);
    Log("dwSparkMaxAge:         %lu\n", g_TestParams.dwSparkMaxAge);
    Log("bDrawWireframe:        %s\n", g_TestParams.bDrawWireframe ? "TRUE" : "FALSE");
    Log("bRelativeSpeed:        %s\n", g_TestParams.bRelativeSpeed ? "TRUE" : "FALSE");
    Log("dwFileIOSize:          %lu\n", g_TestParams.dwFileIOSize);
    Log("lDMMasterVolume:       %ld\n", g_TestParams.lDMMasterVolume);
    Log("lDMMasterTranspose:    %hd\n", g_TestParams.lDMMasterTranspose);
    Log("fDMMasterTempo:        %g\n", g_TestParams.fDMMasterTempo);
    Log("bD3DPerf:              %s\n", g_TestParams.bD3DPerf ? "TRUE" : "FALSE");
    Log("szDSScratchImage:      %s\n", g_TestParams.szDSScratchImage);
    Log("szDSEnvironment:       %s\n", g_TestParams.szDSEnvironment);
    Log("b3DSound:              %s\n", g_TestParams.b3DSound ? "TRUE" : "FALSE");
    Log("szLightSound:          %s\n", g_TestParams.szLightSound);
    Log("lDSVolume:             %ld\n", g_TestParams.lDSVolume);
    Log("dwDSFreq:              %lu\n", g_TestParams.dwDSFreq);
    Log("lAmbientVolume:        %ld\n", g_TestParams.lAmbientVolume);
    Log("bCopyMediaFromNetwork  %s\n", g_TestParams.bCopyMediaFromNetwork ? "TRUE" : "FALSE");
    Log("dwMultiSampleType:     %lu\n", g_TestParams.dwMultiSampleType);
    Log("dwBackBufferCount:     %lu\n", g_TestParams.dwBackBufferCount);
    Log("bCycleDisplayModes:    %s\n", g_TestParams.bCycleDisplayModes ? "TRUE" : "FALSE");
    Log("dwCycleTime:           %ld\n", g_TestParams.dwCycleTime);

    if (g_TestParams.dwDMSegments)
    {
        Log("ppDMSegments:  \n");
        for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
            Log("                                  %s\n", g_TestParams.ppDMSegments[i]);

    }
    else
    {
        Log("ppDMSegments:         NONE\n");
    }

#ifdef _DEBUG
    Log("g_dwDirectSoundDebugLevel:         %ld\n", g_dwDirectSoundDebugLevel);
    Log("g_dwDirectSoundDebugBreakLevel:    %ld\n", g_dwDirectSoundDebugBreakLevel);
#endif

    Log("-----------------------------------\n");
    return S_OK;
};

//------------------------------------------------------------------------------
//Read Test Params
//-----------------------------------------------------------------------------
static LPCSTR szAppName = "MEDIA";
static LPCSTR szDefaultININame =    "D:\\testini.ini";
static LPCSTR szSecondaryININame =  "T:\\testini.ini";
static LPCSTR szSectionName = "DMSEGMENTS";
#define MAXSIZE 0xFFFF

HRESULT LoadTestParams(void)
    {
    CHAR *szTemp;
    FLOAT fTemp = 0;
    DWORD dwTemp = 0;
    DWORD dwBufferSize=0;
    DWORD dwReturned = 0;
    LARGE_INTEGER liSeed = {0};
    DWORD i=0;
    CHAR szININame[MAX_PATH] = {0};

    //First look for testini's in the current directory, then on t:\    
    if (0 == _access(szDefaultININame, 0))
    {
        Log("Note: Found default ini file %s\n", szDefaultININame);
        strcpy(szININame, szDefaultININame);
    }
    else
    {
        Log("Note: Couldn't find %s; trying secondary INI file %s\n", szDefaultININame, szSecondaryININame);
        if (0 == _access(szSecondaryININame, 0))
        {
            Log("Note: Found secondary ini file %s\n", szSecondaryININame);            
            strcpy(szININame, szSecondaryININame);
        }
        else
        {            
            Log("Note: Couldn't find secondary file %s either; giving up!!\n", szSecondaryININame);
            return E_FAIL;
        }
    }

    //Allocate 0xFFFF- more than enough to hold all the file names
    szTemp = new CHAR[MAXSIZE];
    memset(szTemp, 0, MAXSIZE);
    memset(&g_TestParams, 0, sizeof(g_TestParams));

    //Randomize calls to rand() based on current time.
    g_TestParams.dwSeed = GetPrivateProfileIntA(szAppName, "dwseed", 0, szININame);
    if (g_TestParams.dwSeed == 0)
    {
        Log("Seed not specified; generating one.\n");
        QueryPerformanceCounter(&liSeed);
        g_TestParams.dwSeed = liSeed.LowPart;
    }
    srand(g_TestParams.dwSeed);    

    g_TestParams.dwBallDetail = GetPrivateProfileIntA(szAppName, "dwballdetail", 12, szININame);
    g_TestParams.dwWallDetail = GetPrivateProfileIntA(szAppName, "dwwalldetail", 20, szININame);
    g_TestParams.dwLightDetail = GetPrivateProfileIntA(szAppName, "dwlightdetail", 12, szININame);
    g_TestParams.dwNumLayers = GetPrivateProfileIntA(szAppName, "dwnumlayers", 0, szININame);
    g_TestParams.dwNumBalls = GetPrivateProfileIntA(szAppName, "dwnumballs", 20, szININame);
    g_TestParams.dwMaxBalls = GetPrivateProfileIntA(szAppName, "dwmaxballs", 50, szININame);
    g_TestParams.dwNumLights = GetPrivateProfileIntA(szAppName, "dwnumlights", 5, szININame);
    g_TestParams.dwMaxLights = GetPrivateProfileIntA(szAppName, "dwmaxlights", 10, szININame);

    g_TestParams.dwMaxSparks = GetPrivateProfileIntA(szAppName, "dwmaxsparks", 500, szININame);
    g_TestParams.bSparksAreLights =GetPrivateProfileIntA(szAppName, "bsparksarelights", 1, szININame);
    g_TestParams.dwSparksPerCollision =GetPrivateProfileIntA(szAppName, "dwsparkspercollision", 4, szININame);
    g_TestParams.dwSparkMaxAge =GetPrivateProfileIntA(szAppName, "dwsparkmaxage", 100, szININame);
    g_TestParams.bDrawWireframe =GetPrivateProfileIntA(szAppName, "bdrawwireframe", 1, szININame);
    g_TestParams.bRelativeSpeed =GetPrivateProfileIntA(szAppName, "brelativespeed", 1, szININame);

    g_TestParams.dwFileIOSize = GetPrivateProfileIntA(szAppName, "dwFileIOSize", 128, szININame);
    g_TestParams.lDMMasterVolume=    GetPrivateProfileIntA(szAppName, "lDMMasterVolume", 0, szININame);
    g_TestParams.lDMMasterTranspose = (short)GetPrivateProfileIntA(szAppName, "lDMMasterTranspose", 0, szININame);
    GetPrivateProfileStringA(szAppName, "fDMMasterTempo", "1",  szTemp, 49, szININame);
    g_TestParams.fDMMasterTempo = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName,   "fradius",   "5.5", szTemp, 49, szININame);
    fTemp = (float)atof(szTemp);
    if (fTemp != 0.0f)
        g_TestParams.fRadius = fTemp;    

    GetPrivateProfileStringA(szAppName, "fmaxspeed", "10",  szTemp, 49, szININame);
    g_TestParams.fMaxSpeed = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName, "fminspeed", "0.1", szTemp, 49, szININame);
    g_TestParams.fMinSpeed = (FLOAT)atof(szTemp);

    g_TestParams.bTextureBalls = GetPrivateProfileIntA(szAppName, "bTextureBalls", TRUE, szININame);
    g_TestParams.bD3DPerf = GetPrivateProfileIntA(szAppName, "bD3DPerf", TRUE, szININame);

    GetPrivateProfileStringA(szAppName, "szBallBaseTexture", "t:\\media\\graphics\\ballbase.bmp", g_TestParams.szBallBaseTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szBallBumpTexture", "t:\\media\\graphics\\ballbump.bmp", g_TestParams.szBallBumpTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSphereBaseTexture", "t:\\media\\graphics\\sphrbase.bmp", g_TestParams.szSphereBaseTex, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szLightVSH", "t:\\media\\graphics\\light.vsh", g_TestParams.szLightVSH, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSparkVSH", "t:\\media\\graphics\\spark.vsh", g_TestParams.szSparkVSH, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szBounceSound", "t:\\media\\audio\\pcm\\ball.wav", g_TestParams.szBounceSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szLightSound", "", g_TestParams.szLightSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSHRTF", "FULL", g_TestParams.szDSHRTF, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSEnvironment", "SewerPipe", g_TestParams.szDSEnvironment, MAX_PATH, szININame);

    g_TestParams.b3DSound = GetPrivateProfileIntA(szAppName, "b3DSound", TRUE, szININame);
    g_TestParams.bSubMixBallSound = GetPrivateProfileIntA(szAppName, "bSubMixBallSound", TRUE, szININame);
    g_TestParams.bLightSound = GetPrivateProfileIntA(szAppName, "bLightSound", TRUE, szININame);
    g_TestParams.lDSVolume = GetPrivateProfileIntA(szAppName, "lDSVolume", 0, szININame);
    g_TestParams.dwDSFreq = GetPrivateProfileIntA(szAppName, "dwDSFreq", 48000, szININame);
    g_TestParams.lAmbientVolume = GetPrivateProfileIntA(szAppName, "lAmbientVolume", -2200, szININame);

    g_TestParams.bDMusic            = GetPrivateProfileIntA(szAppName, "bDMusic",          TRUE, szININame);
    g_TestParams.bDMDoWorkLocally   = GetPrivateProfileIntA(szAppName, "bDMDoWorkLocally", FALSE, szININame);
    g_TestParams.bDMUseGM           = GetPrivateProfileIntA(szAppName, "bDMUseGM"       , FALSE, szININame);
    g_TestParams.bDMLoaderThread    = GetPrivateProfileIntA(szAppName, "bDMLoaderThread", TRUE, szININame);
    g_TestParams.dwDMVoiceCount     = GetPrivateProfileIntA(szAppName, "dwDMVoiceCount",   128, szININame);

    GetPrivateProfileStringA(szAppName, "szDMStressDir",  "t:\\media\\music\\default", g_TestParams.szDMStressDir,  MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDMSupportDir", "t:\\media\\music\\support", g_TestParams.szDMSupportDir, MAX_PATH, szININame);

    //If user specified random audiopath, choose a different one now.
    GetPrivateProfileStringA(szAppName, "szDMAudioPath", "Random", g_TestParams.szDMAudioPath, MAX_PATH, szININame);
    if (_strcmpi("random", g_TestParams.szDMAudioPath)==0)
    {
        strcpy(g_TestParams.szDMAudioPath, AudioPathPairs[rand() % NUMELEMS(AudioPathPairs)].szString);
        Log("Choosing random audiopath: %s", g_TestParams.szDMAudioPath);
    }



    //READ IN THE SEGMENT NAMES!!
    //===========================
    //Get our string; parse it out.
    dwReturned = GetPrivateProfileSectionA(szSectionName, szTemp, MAXSIZE, szININame);
    if (dwReturned == MAXSIZE - 2)
    {
        Log("ERROR: Filled up entire %d characters, need to increase MAXSIZE", MAXSIZE);
    }
    //Count the words in the string, if it exists.
    if (szTemp[0])
    {
        for (i=0;;i++)
        {
            if (szTemp[i]==0 && i)
                g_TestParams.dwDMSegments++;

            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }
    //If there's any strings, then allocate space and copy them.
    if (g_TestParams.dwDMSegments)
    {
        //Allocate that many LPSTR's
        g_TestParams.ppDMSegments = new LPSTR[g_TestParams.dwDMSegments];

        //Go through again and allocate each ptr, and copy the word into it.
        DWORD dwBaseIndex = 0;
        for (i=0; i<g_TestParams.dwDMSegments; i++)
        {
            //Get length + 1
            dwTemp = strlen(&szTemp[dwBaseIndex]) + 1;
            g_TestParams.ppDMSegments[i] = new CHAR[dwTemp];
            strcpy(g_TestParams.ppDMSegments[i], &szTemp[dwBaseIndex]);
            while (szTemp[dwBaseIndex++]);
        }
    }
    delete[]szTemp;


    //Scratch Image
    GetPrivateProfileStringA(szAppName, "szDSScratchImage", "Default", g_TestParams.szDSScratchImage, MAX_PATH, szININame);

    //Heap
    //Default size is 2 MB apiece for a fixed heap, and of course 0 for non-fixed heaps (they can grow as big as they want)
    GetPrivateProfileStringA(szAppName, "szDMHeap", "Tracking", g_TestParams.szDMHeap, MAX_PATH, szININame);
    BOOL bFixedSizeHeap = _strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0 || _strcmpi(g_TestParams.szDMHeap, "FixedDefault") == 0;
    g_TestParams.dwDMFixedHeapSizeNorm    = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizeNorm",     bFixedSizeHeap ? 4*1024*1024 : 0, szININame);
    g_TestParams.dwDMFixedHeapSizePhys  = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizePhys",   bFixedSizeHeap ? 1024*1024 / 2: 0, szININame);

    g_TestParams.bCopyMediaFromNetwork = GetPrivateProfileIntA(szAppName, "bCopyMediaFromNetwork", TRUE, szININame);

    //Dsound debug
#ifdef _DEBUG
    g_dwDirectSoundDebugLevel = GetPrivateProfileIntA(szAppName, "DirectSoundDebugLevel", 3, szININame);
    g_dwDirectSoundDebugBreakLevel = GetPrivateProfileIntA(szAppName, "DirectSoundDebugBreakLevel", 1, szININame);
#endif

    g_TestParams.dwMultiSampleType = GetPrivateProfileIntA(szAppName, "dwMultiSampleType", 0x0011, szININame);
    g_TestParams.dwBackBufferCount = GetPrivateProfileIntA(szAppName, "dwBackBufferCount", 0, szININame);
    g_TestParams.bCycleDisplayModes = GetPrivateProfileIntA(szAppName, "bCycleDisplayModes", FALSE, szININame);
    g_TestParams.dwCycleTime = GetPrivateProfileIntA(szAppName, "dwCycleTime", 1000, szININame);

    PrintTestParams();
    return S_OK;
};


//------------------------------------------------------------------------------
//Verify files exist.  This must be called AFTER the files are copied down.
//-----------------------------------------------------------------------------
HRESULT SanityCheckFiles(void)
{
HRESULT hr = S_OK;

    if (_strcmpi("Default", g_TestParams.szDSScratchImage))
    {
        if (_access(g_TestParams.szDSScratchImage, 0))
        {
            Log("Error: DSP image file (%s) is not found\n", g_TestParams.szDSScratchImage);
            hr = E_FAIL;
        }
    }


    return hr;

}


//------------------------------------------------------------------------------
//Print warning messages for things that aren't right.
//-----------------------------------------------------------------------------
HRESULT SanityCheckTestParams(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.ppDMSegments && g_TestParams.dwDMSegments == 0)
    {
        Log("Error: ppDMSegments is not NULL but dwDMSegments == 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments == 0 && g_TestParams.dwDMSegments > 0)
    {
        Log("Error: ppDMSegments is NULL but dwDMSegments > 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments && g_TestParams.szDMStressDir)
    {
        Log("Warning: szDMStressDir = %s but [DMSegments] section was specified.  Using [DMSegments] section\n", g_TestParams.szDMStressDir);
    }

    if (!g_TestParams.bDMusic && g_TestParams.ppDMSegments)
    {
        Log("Warning: bDMusic=FALSE but [DMSegments] section was specified.  Ignoring [DMSegments] section\n");
    }

    if (g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls)
    {
        Log("Error: dwNumBalls = %d; dwMaxBalls = %d\n", g_TestParams.dwNumBalls , g_TestParams.dwMaxBalls);
        hr = E_FAIL;
    }

    if (g_TestParams.dwNumLights > g_TestParams.dwMaxLights)
    {
        Log("Error: dwNumLights = %d; dwMaxLights = %d\n", g_TestParams.dwNumLights , g_TestParams.dwMaxLights);
        hr = E_FAIL;
    }
    if (g_TestParams.dwSparksPerCollision > g_TestParams.dwMaxSparks)
    {
        Log("Error: dwSparksPerCollision = %d; dwMaxSparks = %d\n", g_TestParams.dwSparksPerCollision , g_TestParams.dwMaxSparks);
        hr = E_FAIL;
    }

 

    if (_strcmpi(g_TestParams.szDSHRTF, "full") &&
        _strcmpi(g_TestParams.szDSHRTF, "light")
        )
    {
        Log("Error: Specified %s for g_TestParams.szDSHRTF; need to specify ""FULL"" or ""LIGHT""\n", g_TestParams.szDSHRTF);
        hr = E_FAIL;
    }

    if (_strcmpi(g_TestParams.szDMHeap, "Default") &&
        _strcmpi(g_TestParams.szDMHeap, "Tracking") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedUser") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedDefault")

        )
    {
        Log("Error: Specified %s for g_TestParams.szDMHeap; need to specify ""Default"", ""Tracking"", ""FixedUser"", or ""FixedDefault""\n", g_TestParams.szDMHeap);
        hr = E_FAIL;
    }

    if (!(_strcmpi(g_TestParams.szDMHeap, "FixedUser") || _strcmpi(g_TestParams.szDMHeap, "FixedDefault")))
    {
        if(g_TestParams.dwDMFixedHeapSizeNorm != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizeNorm.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizeNorm);
        }
        if(g_TestParams.dwDMFixedHeapSizePhys != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizePhys.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizePhys);
        }
    }

    switch (g_TestParams.dwMultiSampleType & 0xFFFF) {
        case D3DMULTISAMPLE_NONE:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN:
            break;
        default:
            Log("Warning: Invalid multisample type 0x%X specified. Using D3DMULTISAMPLE_NONE by default.\n", g_TestParams.dwMultiSampleType & 0xFFFF);
            g_TestParams.dwMultiSampleType = D3DMULTISAMPLE_NONE;
            break;
    }

    switch (g_TestParams.dwMultiSampleType & 0xF0000) {
        case D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8:
            break;
        default:
            Log("Warning: Invalid prefilter buffer format 0x%X specified, switching to the default.\n", g_TestParams.dwMultiSampleType & 0xF0000);
            g_TestParams.dwMultiSampleType &= 0xFFF0FFFF;
            break;
    }

    if (g_TestParams.dwBackBufferCount > 2) {
        Log("Error: Specified %d for g_TestParams.dwBackBufferCount\n", g_TestParams.dwBackBufferCount);
        hr = E_FAIL;
    }

    return hr;
};



//------------------------------------------------------------------------------
//Deallocate everything allocated by testparams.
//-----------------------------------------------------------------------------
HRESULT FreeTestParams(void)
{
DWORD i = 0;

for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
{
    if (g_TestParams.ppDMSegments)
    {
        delete []g_TestParams.ppDMSegments[i];
        g_TestParams.ppDMSegments[i] = NULL;
    }
    else
        Log("ERROR!!  Deleting string of ppDMSegments[%d] but it was already NULL!", i);

}

delete []g_TestParams.ppDMSegments;
g_TestParams.ppDMSegments = NULL;
return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    
    if (_strcmpi("Default", g_TestParams.szDSScratchImage) == 0)
    {
        CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));
    }
    else
    {
        CHECKRUN(XAudioDownloadEffectsImage(pszScratchFile, &EffectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, &pDesc));
    }

    return hr;
}

//------------------------------------------------------------------------------
// Multiply the given color values and convert the result to a 32 bit color
//-----------------------------------------------------------------------------
D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2) {

    D3DCOLORVALUE dcv;
    dcv.r = pdcv1->r * pdcv2->r;
    dcv.g = pdcv1->g * pdcv2->g;
    dcv.b = pdcv1->b * pdcv2->b;
    dcv.a = pdcv1->a * pdcv2->a;
    return (BYTE)(dcv.a * 255.0f) << 24 | (BYTE)(dcv.r * 255.0f) << 16 |
           (BYTE)(dcv.g * 255.0f) << 8 | (BYTE)(dcv.b * 255.0f);
}




//------------------------------------------------------------------------------
//  WaitForSegmentStop
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStop(
                   IN IDirectMusicPerformance8*   ptPerf8, 
                   IN IDirectMusicSegment8*       ptSegment8, 
                   IN IDirectMusicSegmentState8*  ptSegmentState8, 
                   IN DWORD                         dwTimeout
                   )
/*++

Routine Description:

    Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment stopped within the specified time; E_FAIL otherwise.

--*/
{
    return E_FAIL;
}

//------------------------------------------------------------------------------
//  WaitForSegmentStart
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStart(
                    IN IDirectMusicPerformance8*  ptPerf8, 
                    IN IDirectMusicSegment8*      ptSegment8, 
                    IN IDirectMusicSegmentState8* ptSegmentState8,
                    IN DWORD                        dwTimeout
                    )
/*++

Routine Description:

    Returns S_OK if the segment started within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment started within the specified time; E_FAIL otherwise.

--*/
{
    return E_FAIL;
};

/********************************************************************************
Returns S_OK if the segment started within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStart(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't start playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStop(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStop(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't stop playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
********************************************************************************/

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\input.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.h

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

namespace Media4 {

void CheckUserInput(void);
void InputDukeInsertions(DWORD add, DWORD remove=0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\media.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.cpp

Abstract:

	Media stress - D3D, DSound, DMusic and others.

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <time.h>
#include "media.h"
#include "helpers.h"
#include "scene.h"
#include "input.h"
#include <d3d8perf.h>

#ifndef NOLOGGING
#include <makeini.h>
#include <stressmon.h>
#endif // NOLOGGING

#include "medialoader.h"
#define MEDIA_FILES_INI_PATH	"D:\\MediaFiles.ini"

using namespace Media4;


extern HANDLE  g_hLog;

//------------------------------------------------------------------------------
//	Static Function Declarations:
//------------------------------------------------------------------------------
static HRESULT Initialize(void);
static HRESULT InitializeD3D(void);
static void Cleanup(void);
static HRESULT InitializeScene(void);

//------------------------------------------------------------------------------
//	Static Global Variables
//------------------------------------------------------------------------------
IDirect3D8*		    g_d3d			= NULL;
IDirect3DDevice8*	g_d3dDevice		= NULL;
BOOL                g_notDone		= TRUE;
CScene				g_scene;

//------------------------------------------------------------------------------
//	media4_BasicTest
//------------------------------------------------------------------------------
HRESULT
media4_BasicTest(void)
/*++

Routine Description:

    Basic Test for media

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT hr	= S_OK;

	// General initialization
	hr = Initialize();
	if(hr != S_OK)
	{
		__asm int 3;
		return hr;
	}

	// Enable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StartPerfProfile();
#endif 

	// Loop until done
	while(g_notDone)
	{
		// Draw the scene
		g_scene.Render(g_d3dDevice);

		// Next frame
		g_scene.NextFrame();

        // input
        CheckUserInput();
	}

	// Disable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StopPerfProfile();
#endif

    // Return the Hresult
    return hr;
}

//
// this function should only be linked in / defined if this is compiled as a lib
//

#ifndef NOLOGGING
DWORD WINAPI StartStressMon( LPVOID lpParameter )
{
	StressMONStartTest( (HANDLE) lpParameter );
	return 0;
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------
VOID
WINAPI 
media4_StartTest(
				IN HANDLE LogHandle 
				)
/*++

Routine Description:

    The harness entry into the media tests

Arguments:

    IN LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	//
	// decide if this is a lib or an exe, and generate an ini file if it is a lib
	//

#ifndef NOLOGGING

	EXECUTE( makeini_BasicTest() );
	if ( SUCCEEDED( hr ) )
	{
		CreateThread( NULL, 65536, StartStressMon, (LPVOID) LogHandle, 0, NULL );
	}

#endif // NOLOGGING

    EXECUTE( media4_BasicTest() );
}

//------------------------------------------------------------------------------
//	media4_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
media4_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
	Cleanup();
}

//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize USB Devices
    XInitDevices(0, NULL);
    InputDukeInsertions(XGetDevices(XDEVICE_TYPE_GAMEPAD));

    media4_StartTest(NULL);
    media4_EndTest();
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	InitializeD3D
//------------------------------------------------------------------------------
static HRESULT
InitializeD3D(void)
/*++

Routine Description:

	Initializes the d3d device

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_A8R8G8B8;
	d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
	d3dpp.Flags								= 0;
//	d3dpp.MultiSampleType					= D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN;
	d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_d3dDevice);
	if(hr != D3D_OK)
		return hr;
	
	// Enable antialiasing
//	g_d3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE); 

	return S_OK;
}


//------------------------------------------------------------------------------
//	InitializeDSound
//------------------------------------------------------------------------------
static HRESULT
InitializeDSound(void)
/*++
Routine Description:
	Downloads the scratch image to the DSP
Return Value:
	S_OK on success, any other value on failure
*/
{
    return S_OK;
}


//------------------------------------------------------------------------------
//	InitializeMedia
//------------------------------------------------------------------------------
HRESULT InitializeMedia(void)
{
    HRESULT hr = S_OK;

    //If we're instructed not to copy from the network (if we're running from a DVD, for example)
    //  then we'll skip this part.
    if (!g_TestParams.bCopyMediaFromNetwork)
        return S_OK;
	
    #define CREATE_FLAG COPY_IF_NEWER
    SETLOG( g_hLog, "robheit", "MCPX", "media", "Basic" );
	MLSetErrorLevel( 3 );
	MEDIAFILEDESC MediaFiles[] =
	{
		{"mediastress/graphics/", "T:\\media\\graphics\\", CREATE_FLAG},
		{"DSP/", "T:\\media\\DSPCode", CREATE_FLAG},
		{NULL, NULL, 0}
	};
	//EXECUTE( LoadMediaFromIni( MEDIA_FILES_INI_PATH ) );
	EXECUTE( LoadMedia( MediaFiles ) );
	if ( FAILED( hr ) )
	{
		//Log("LoadMedia failed!!!\n");
        //__asm int 3;
        hr = E_FAIL;
	}

    return hr;

}


//------------------------------------------------------------------------------
//	Initialize
//------------------------------------------------------------------------------
static HRESULT
Initialize(void)
/*++

Routine Description:

	General Intialization

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT			hr;
	LONGLONG		timer;
	unsigned int	seed;

	// Set the seed to randomize the runs
	// A variable is used so that the seed can be overrided at run time
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	seed = (unsigned int)timer;
	srand(seed);

    // Load user-defined parameters.    
    hr = LoadTestParams();
    if (FAILED(hr))
        return hr;

    // Check the parameters are in order..    
    hr = SanityCheckTestParams();
    if (FAILED(hr))
        return hr;

    // Copy down the media, if required.
    hr = InitializeMedia();
    //if (FAILED(hr))
    //    return hr;

    // Check that the files are present and accessible.
    hr = SanityCheckFiles();
    if (FAILED(hr))
        return hr;

	// Initialize D3D
	hr = InitializeD3D();
	if(hr != S_OK)
		return hr;

	// Create the graphic data
	hr = InitializeScene();
	if(hr != S_OK)
		return hr;

	return S_OK;
}

//------------------------------------------------------------------------------
//	Cleanup
//------------------------------------------------------------------------------
static void
Cleanup(void)
/*++

Routine Description:

	Free resources

Arguments:

	None

Return Value:

	None

--*/
{
	
    // IDirect3DDevice8
	if(g_d3dDevice)
	{
		g_d3dDevice->Release();
		g_d3dDevice = NULL;
	}

	// IDirect3D8
	if(g_d3d)
	{
		g_d3d->Release();
		g_d3d = NULL;
	}

    FreeTestParams();
}

//------------------------------------------------------------------------------
//	InitializeScene
//------------------------------------------------------------------------------
static HRESULT
InitializeScene(void)
/*++

Routine Description:

	Initializes all data for the scene

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT	hr;
	
	hr = g_scene.Initialize(g_d3dDevice);
	return hr;
}

//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( media4 )
#pragma data_seg()

BEGIN_EXPORT_TABLE( media4 )
    EXPORT_TABLE_ENTRY( "StartTest", media4_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", media4_EndTest )
END_EXPORT_TABLE( media4 )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\scene.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.cpp

Abstract:

	3D Scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "media.h"
#include "scene.h"
#include "helpers.h"
#include "dsstdfx.h"

void * g_hLog;

using namespace Media4;

extern IDirect3D8* g_d3d;
extern "C" DWORD g_dwDirectSoundDebugLevel; // = DPFLVL_DEFAULT;

namespace Media4 {
//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define ADJUST(A) (((-(A)) + 1.0f) / 2.0f)
#define MIN2(A,B) ((A) <= (B) ? (A) : (B))
#define MAX2(A,B) ((A) >= (B) ? (A) : (B))
#define MAX3(A,B,C) MAX2((A), MAX2((B), (C)))
#define FUDGE(A,B,C) (fabs((A) - (B)) < (C) ? (B) : (A))
#ifndef PI 
#	define PI 3.14159265359f
#endif

#define BALL_RADIUS		0.5f
#define LIGHT_RADIUS	0.125f
#define BALL_MASS		10.0f
#define LIGHT_MASS		1.0f

#define DRAWTEXT( a, b, c, d, e, f, g ) \
if ( m_bDrawText )						\
{										\
	m_font.DrawText( a, b, c, d, e, f, g ); \
}											

static const double cPi				= 3.1415926535;
static const double cDataScale		= 32767.0;
static const DWORD	cNum2DVoices	= 2000;
static const DWORD	cNum3DVoices	= 1000;

LPDIRECTSOUND8 g_pDSound = NULL;

struct Voice
{
	LPDIRECTSOUNDBUFFER	pBuffer;
	Voice*				pNext;
	Voice*				pPrev;
};

//------------------------------------------------------------------------------
//	::CreateBuffer
//------------------------------------------------------------------------------
static HRESULT 
CreateBuffer(
			 OUT LPDIRECTSOUNDBUFFER*	pBuffer,
			 IN BOOL					b3D
			 )
/*++

Routine Description:

	Plays a sine wave

Arguments:

	OUT pBuffer -		DSound buffer constructed
	IN b2D -			TRUE for 3D, FALSE for 2D

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DWORD			i;
    HRESULT			hr			= S_OK;
	unsigned char*	pData		= NULL;
	DWORD			dwBytes;
	DSBUFFERDESC	dsbd;
	WAVEFORMATEX	wfx;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));

	wfx.cbSize			= 0;
	wfx.wFormatTag		= WAVE_FORMAT_PCM;
	wfx.nChannels		= 1;
	wfx.nSamplesPerSec	= 8000;
	wfx.wBitsPerSample	= 8;
	wfx.nBlockAlign		= 1;
	wfx.nAvgBytesPerSec	= wfx.nSamplesPerSec * wfx.nBlockAlign;

	// setup the dsound buffer description with the waveformatex
	dsbd.dwBufferBytes	= (rand() % 8000 + 32) * wfx.nBlockAlign * wfx.nChannels;
	dsbd.dwFlags		= DSBCAPS_LOCDEFER;
	if(b3D)
		dsbd.dwFlags |= DSBCAPS_CTRL3D;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);
	dsbd.lpwfxFormat	= &wfx;
    dsbd.lpMixBins		= NULL;

	// Create the dsound buffer
	hr = g_pDSound->CreateSoundBuffer(&dsbd, pBuffer, NULL);

	// continue forever (or until an error occurs)
	if(SUCCEEDED(hr))
	{
		// Get a buffer from dsound using lock
		hr = (*pBuffer)->Lock(0, dsbd.dwBufferBytes, (LPVOID*)&pData, 
							  &dwBytes, NULL, NULL, 0);
		if(SUCCEEDED(hr))
		{
			for(i=0;  i<dsbd.dwBufferBytes; ++i)
				pData[i] = rand() % 256;
		}
    }
    
    return hr;
}

//------------------------------------------------------------------------------
//	::CreateMixinBuffer
//------------------------------------------------------------------------------
static HRESULT 
CreateMixinBuffer(
				  OUT LPDIRECTSOUNDBUFFER*	pBuffer,
				  IN BOOL					b3D
				  )
/*++

Routine Description:

	Plays a sine wave

Arguments:

	OUT pBuffer -		DSound buffer constructed

Return Value:

	S_OK on success, any other error on failure

--*/
{
	DSBUFFERDESC	dsbd;
		
	// It's always safe to zero out stack allocated structs
	ZeroMemory(&dsbd, sizeof(DSBUFFERDESC));

	// setup the dsound buffer description
	dsbd.dwBufferBytes	= 0;
	dsbd.dwFlags		= DSBCAPS_MIXIN;
	if(b3D)
		dsbd.dwFlags |= DSBCAPS_CTRL3D;
	dsbd.dwSize			= sizeof(DSBUFFERDESC);

	// Create the dsound buffer
	return g_pDSound->CreateSoundBuffer(&dsbd, pBuffer, NULL);
}

//------------------------------------------------------------------------------
//	WaitForVoiceOffThread2D
//------------------------------------------------------------------------------
static DWORD WINAPI
WaitForVoiceOffThread2D(LPVOID)
/*++

Routine Description:

    This it the test routine

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
	DSCAPS				dsCaps;
	DWORD				i;
	DWORD				ii;
	DWORD				dwStatus;
	DWORD				dwPlay			= 0;
	DWORD				dwStop			= 0;
	Voice*				pVoices			= NULL;
	Voice*				pVoice			= NULL;
	Voice*				pHead			= NULL;
	LPDIRECTSOUNDBUFFER	pMixinBuffer	= NULL;
	int					totalVoices		= 0;
	int					lostVoices		= 0;
	DWORD				dwStillPlaying	= 0;

	// Create the voices
	for(i=0; i<cNum2DVoices; ++i)
	{
		pVoice			= new Voice;
		pVoice->pBuffer	= NULL;
		pVoice->pNext	= NULL;
		pVoice->pPrev	= pVoices;

		if(pVoices)
			pVoices->pNext = pVoice;
		else
			pHead = pVoice;

		pVoices = pVoice;
	}
	pHead->pPrev	= pVoice;
	pVoice->pNext	= pHead;

	// Create the DSound object
	ASSERT(g_pDSound->GetCaps(&dsCaps) == DS_OK);
	totalVoices = (int)dsCaps.dwFree2DBuffers;

	// Create Mixin Buffer
//	ASSERT(CreateMixinBuffer(&pMixinBuffer, g_pDSound) == S_OK);

	// Create buffers
	while(pVoices->pBuffer == NULL)
	{
		ASSERT(CreateBuffer(&pVoices->pBuffer, FALSE) == S_OK);
//		pVoices->pBuffer->SetOutputBuffer(pMixinBuffer);
		pVoices = pVoices->pNext;
	}

	// Loop forever
	while(1)
	{
		ASSERT(g_pDSound->GetCaps(&dsCaps) == DS_OK);

		// Calculate the number of lost voices
		dwStillPlaying = dwPlay;
		if((totalVoices - (dsCaps.dwFree2DBuffers + dwStillPlaying)) != lostVoices)
		{
			lostVoices = totalVoices - (dsCaps.dwFree2DBuffers + dwStillPlaying);
			DbgPrint("Lost 2D Voices = %d\n", lostVoices);
		}

		// Generate a random number of buffers to play and stop
		if(dsCaps.dwFree2DBuffers > 0)
			dwPlay += rand() % dsCaps.dwFree2DBuffers;
		else
		{
			DirectSoundDoWork();
			Sleep(100);
		}
		if(dwPlay > dsCaps.dwFree2DBuffers)
			dwPlay = dsCaps.dwFree2DBuffers;

		if(dwPlay != 0)
			dwStop = rand() % (dwPlay + 1);
		else
			dwStop = dwStillPlaying;

		// Play the buffers	
		for(pVoice=pVoices, i=0; i<dwPlay; ++i, pVoice=pVoice->pNext)
		{
			ASSERT(pVoice->pBuffer->Play(0, 0, rand() % 2 ? DSBPLAY_LOOPING : 0) == DS_OK);
//			ASSERT(pVoice->pBuffer->SetCurrentPosition(0) == DS_OK);
		}

		DirectSoundDoWork();

		// Wait some amount of time
//		Sleep(10);

		// Stop the buffers
		for(pVoice=pVoices, i=0; i<dwStop; ++i, pVoice=pVoice->pNext)
		{
			switch(rand() % 4)
			{
			case 0: // Stop
				ASSERT(pVoice->pBuffer->Stop() == DS_OK);
				break;
			case 1: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_ENVELOPE) == DS_OK);
				break;
			case 2: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_IMMEDIATE) == DS_OK);
				break;
			case 3: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_RELEASEWAVEFORM) == DS_OK);
				break;
			}
		}

		// Reduce the number of playing buffers
		if(dwStop <= dwPlay)
			dwPlay -= dwStop;
		else 
			dwPlay = 0;

		DirectSoundDoWork();

		// Wait for them to be completed
		for(i=0; i<dwStop; )
		{
			ASSERT(pVoices->pBuffer->GetStatus(&dwStatus) == DS_OK);
			if(dwStatus == 0)
			{
				pVoices = pVoices->pNext;
				++i;
			}
			else
			{
				DirectSoundDoWork();
				Sleep(5);
			}
		}

		DirectSoundDoWork();
	}

	// Release DSound
	g_pDSound->Release();
	
	// This will never return
    return S_OK;
}

//------------------------------------------------------------------------------
//	WaitForVoiceOffThread3D
//------------------------------------------------------------------------------
static DWORD WINAPI
WaitForVoiceOffThread3D(LPVOID)
/*++

Routine Description:

    This it the test routine

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
	DSCAPS				dsCaps;
	DWORD				i;
	DWORD				ii;
	DWORD				dwStatus;
	DWORD				dwPlay			= 0;
	DWORD				dwStop			= 0;
	Voice*				pVoices			= NULL;
	Voice*				pVoice			= NULL;
	Voice*				pHead			= NULL;
	LPDIRECTSOUNDBUFFER	pMixinBuffer	= NULL;
	int					totalVoices		= 0;
	int					lostVoices		= 0;
	DWORD				dwStillPlaying	= 0;

	// Create the voices
	for(i=0; i<cNum3DVoices; ++i)
	{
		pVoice			= new Voice;
		pVoice->pBuffer	= NULL;
		pVoice->pNext	= NULL;
		pVoice->pPrev	= pVoices;

		if(pVoices)
			pVoices->pNext = pVoice;
		else
			pHead = pVoice;

		pVoices = pVoice;
	}
	pHead->pPrev	= pVoice;
	pVoice->pNext	= pHead;

	// Create the DSound object
	ASSERT(g_pDSound->GetCaps(&dsCaps) == DS_OK);
	totalVoices = (int)dsCaps.dwFree3DBuffers;

	// Create Mixin Buffer
//	ASSERT(CreateMixinBuffer(&pMixinBuffer, g_pDSound) == S_OK);

	// Create buffers
	while(pVoices->pBuffer == NULL)
	{
		ASSERT(CreateBuffer(&pVoices->pBuffer, TRUE) == S_OK);
//		pVoices->pBuffer->SetOutputBuffer(pMixinBuffer);
		pVoices = pVoices->pNext;
	}

	// Loop forever
	while(1)
	{
		ASSERT(g_pDSound->GetCaps(&dsCaps) == DS_OK);

		// Calculate the number of lost voices
		dwStillPlaying = dwPlay;
		if((totalVoices - (dsCaps.dwFree3DBuffers + dwStillPlaying)) != lostVoices)
		{
			lostVoices = totalVoices - (dsCaps.dwFree3DBuffers + dwStillPlaying);
			DbgPrint("Lost 3D Voices = %d\n", lostVoices);
		}

		dwStillPlaying = dwPlay;

		// Generate a random number of buffers to play and stop
		if(dsCaps.dwFree3DBuffers > 0)
			dwPlay += rand() % dsCaps.dwFree3DBuffers;
		else
		{
			DirectSoundDoWork();
			Sleep(100);
		}
		if(dwPlay > dsCaps.dwFree3DBuffers)
			dwPlay = dsCaps.dwFree3DBuffers;

		if(dwPlay != 0)
			dwStop = rand() % (dwPlay + 1);
		else
			dwStop = dwStillPlaying;

		// Play the buffers	
		for(pVoice=pVoices, i=0; i<dwPlay; ++i, pVoice=pVoice->pNext)
		{
			ASSERT(pVoice->pBuffer->Play(0, 0, rand() % 2 ? DSBPLAY_LOOPING : 0) == DS_OK);
//			ASSERT(pVoice->pBuffer->SetCurrentPosition(0) == DS_OK);
		}

		DirectSoundDoWork();

		// Wait some amount of time
//		Sleep(10);

		// Stop the buffers
		for(pVoice=pVoices, i=0; i<dwStop; ++i, pVoice=pVoice->pNext)
		{
			switch(rand() % 4)
			{
			case 0: // Stop
				ASSERT(pVoice->pBuffer->Stop() == DS_OK);
				break;
			case 1: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_ENVELOPE) == DS_OK);
				break;
			case 2: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_IMMEDIATE) == DS_OK);
				break;
			case 3: // StopEX
				ASSERT(pVoice->pBuffer->StopEx(0, DSBSTOPEX_RELEASEWAVEFORM) == DS_OK);
				break;
			}
		}

		// Adjust the count of the playing buffers
		if(dwStop <= dwPlay)
			dwPlay -= dwStop;
		else 
			dwPlay = 0;

		DirectSoundDoWork();

		// Wait for them to be completed
		for(i=0; i<dwStop; )
		{
			ASSERT(pVoices->pBuffer->GetStatus(&dwStatus) == DS_OK);
			if(dwStatus == 0)
			{
				pVoices = pVoices->pNext;
				++i;
			}
			else
			{
				DirectSoundDoWork();
				Sleep(5);
			}
		}

		DirectSoundDoWork();
	}

	// Release DSound
	g_pDSound->Release();
	
	// This will never return
    return S_OK;
}

//------------------------------------------------------------------------------
//	File IO handlers
//------------------------------------------------------------------------------
VOID CompleteIO(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
    {
    if(!lpOverlapped || !lpOverlapped->hEvent) 
        {
        // this is bad - memory is corrupt - and because of this we will leak
        return;
        }

    FileIOHandle *info = (FileIOHandle*)lpOverlapped->hEvent;

    if(dwNumberOfBytesTransfered != info->buffSize)
        {
        // error
        }

    // clean up all the handles and structs
    delete info->buffer;
    delete info;
    delete lpOverlapped;
    }


//------------------------------------------------------------------------------
//	CScene::CScene
//------------------------------------------------------------------------------
CScene::CScene(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
    m_pd3ddm = NULL;
}  

//------------------------------------------------------------------------------
//	CScene::~CScene
//------------------------------------------------------------------------------
CScene::~CScene(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	delete [] m_balls;
	delete [] m_backgroundTriangles;
    ReleaseShaders();
    if (m_pd3ddm) {
        delete [] m_pd3ddm;
    }
}

//------------------------------------------------------------------------------
//	CScene::Initialize
//------------------------------------------------------------------------------
HRESULT
CScene::Initialize(
				   IN IDirect3DDevice8*	pDevice
				   ) 
/*++

Routine Description:

	Intializes the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	S_OK on success, any other value on failure

--*/
{
	LONGLONG		timer;
	HRESULT			hr;
	UINT			i;
	UINT			ii;
	BOOL			goodLoc;
	XGVECTOR3		loc;
	XGVECTOR3		dir;
	float			speed;
	float			dxyz;
	double			phi;
	double			rho;
	LONGLONG		frequency;
    D3DLOCKED_RECT	d3dlr;
	DSCAPS			dsCaps;
    DSEFFECTIMAGELOC	effectLoc = {0};
    LPDSEFFECTIMAGEDESC pDesc;

    m_hFile                 = INVALID_HANDLE_VALUE;
	m_ballDetail			= g_TestParams.dwBallDetail;	// Default = 12
    m_lightDetail			= g_TestParams.dwLightDetail;   // Default = 12
	m_wallDetail			= g_TestParams.dwWallDetail;	// Default = 20
	m_numLayers				= g_TestParams.dwNumLayers;		// Default = 0
	m_numBalls				= g_TestParams.dwNumBalls;		// Default = 20
	m_maxBalls				= g_TestParams.dwMaxBalls;		// Default = 50
    m_numLights				= g_TestParams.dwNumLights;     // Default = 5
    m_maxLights				= g_TestParams.dwMaxLights;     // Default = 10
	m_radius				= g_TestParams.fRadius;	        // Default = 5.5f
	m_maxSpeed				= g_TestParams.fMaxSpeed;		// Default = 15.0f
	m_minSpeed				= g_TestParams.fMinSpeed;		// Default = 0.1f
	m_bDrawWireframe		= g_TestParams.bDrawWireframe;	// Default = TRUE
	m_bRelativeSpeed		= g_TestParams.bRelativeSpeed;	// Default = TRUE
	m_radius2				= m_radius * m_radius;
	m_elapsedTime			= 0.0;
	m_lastTime				= 0.0;
	m_lastCycle				= 0.0;
	m_avgFrameRate			= 0.0;
	m_currentFrameRate		= 0.0;
	m_frame					= 0;
	m_numTris				= 0;
	m_drawRate				= 60.0;

	// this is set by button state, not the ini

	m_bDrawText				= TRUE;

    // We need to store the device in order to delete our programmable shaders on exit
    m_pDevice = pDevice;

	// Cheesey error detection
	m_balls = new CBall [m_maxBalls + m_maxLights];
	ASSERT(m_balls != NULL);
	
	m_backgroundTriangles = new CScene::Vertex [m_numLayers * 3 * 2];
	ASSERT(m_backgroundTriangles != NULL);

	// Query the performance frequency
	QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);
	m_frequency = (double)frequency;

    // Build a display mode list
    m_uNumDisplayModes = g_d3d->GetAdapterModeCount(D3DADAPTER_DEFAULT);
    if (!m_uNumDisplayModes) {
        return E_FAIL;
    }

    m_pd3ddm = new D3DDISPLAYMODE[m_uNumDisplayModes];
    if (!m_pd3ddm) {
        return E_OUTOFMEMORY;
    }

    for (i = 0; i < m_uNumDisplayModes; i++) {
        hr = g_d3d->EnumAdapterModes(D3DADAPTER_DEFAULT, i, &m_pd3ddm[i]);
        if (FAILED(hr)) {
            return hr;
        }
    }
    m_uDisplayMode = 0;
	
	// Create the sphere
	hr = m_invertedSphere.Create(pDevice, m_radius, m_wallDetail * 2, m_wallDetail);
	if(hr != S_OK)
		return hr;
	m_numTris += m_invertedSphere.GetNumTris();

	m_invertedSphere.SetPosition(XGVECTOR3(0.0f, 0.0f, 0.0f));

	// Create the balls
	for(i=0; i<m_maxBalls; ++i)
	{
		hr = m_balls[i].Create(pDevice, BALL_RADIUS, BALL_MASS, m_ballDetail, 
							   (int)((float)m_ballDetail * 0.75f), FALSE, i);
		if(hr != S_OK)
			return hr;
	}

    // Create the lights
    for (; i < m_maxBalls + m_maxLights; i++) {
        hr = m_balls[i].Create(pDevice, LIGHT_RADIUS, LIGHT_MASS, m_lightDetail, 
							   (int)((float)m_lightDetail * 0.75f), TRUE, i);
		if(hr != S_OK)
			return hr;
    }

	m_sparks.Create(pDevice);

	//initialize the sparks


	// Create the background triangles
	for(ii=0, i=0; i<m_numLayers; ++i)
	{
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= RandomColor();
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;

		m_numTris += 2;
	}

    // Create the shaders
    hr = CreateShaders(pDevice);
    if (FAILED(hr)) {
        return hr;
    }

    // Create the cube texture renormalization map
    hr = CreateNormalMap(pDevice, 256, 0, &m_pd3dtcNormal);
    if (FAILED(hr)) {
        return hr;
    }

    // Create a buffer for the text
    hr = pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pd3dtText);
    if (FAILED(hr)) {
        return hr;
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    m_prText[0].x = 0.0f;
    m_prText[0].y = 480.0f;
    m_prText[0].u = 0.0f;
    m_prText[0].v = 240.0f;

    m_prText[1].x = 0.0f;
    m_prText[1].y = 0.0f;
    m_prText[1].u = 0.0f;
    m_prText[1].v = 0.0f;

    m_prText[2].x = 640.0f;
    m_prText[2].y = 0.0f;
    m_prText[2].u = 320.0f;
    m_prText[2].v = 0.0f;

    m_prText[3].x = 640.0f;
    m_prText[3].y = 480.0f;
    m_prText[3].u = 320.0f;
    m_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        m_prText[i].z = 0.0f; //0.000001f;
        m_prText[i].rhw = 1.0f; ///1000000.0f;
    }

	// Setup the camera (resuse some other vars)
	m_camera.SetViewport(0, 0, 640, 480, 0.0f, 1.0f);
	m_camera.LookAt(XGVECTOR3(0.0f, 0.0f, -2.0f * m_radius), 
					XGVECTOR3(0.0f, 0.0f, 0.0f), XGVECTOR3(0.0f, 1.0f, 0.0f));
	m_camera.SetPerspectiveFov(45.0f, 640.0f / 480.0f, 0.99f * m_radius, 3.01f * m_radius);
	m_camera.EnableLight(TRUE, FALSE);
	m_camera.RotateLightY(-30.0f);
	m_camera.RotateLightX(-30.0f);
	XGMatrixIdentity(&m_identityMatrix);

	// Set the position, speed and direction for the balls
	for(i=0; i<m_maxBalls + m_numLights; ++i) {

        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Make sure the new ball is not within 1 unit of another
		do {
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			XGVec3Normalize(&dir, &dir);
			speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;
			for(ii=0; goodLoc && ii<i; ++ii) {
                if (ii == m_numBalls) {
                    ii = m_maxBalls;
                }
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[ii].GetLocation())) <= m_balls[ii].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		} while(!goodLoc);

		m_balls[i].SetPosition(loc);
		m_balls[i].SetDirection(dir);
		m_balls[i].SetSpeed(speed);
		
		m_numTris += m_balls[i].GetNumTris();
	}

	RecalculateSpeeds();

    // Global scene ambient lighting
    m_dcvAmbient.r = 0.2f;
    m_dcvAmbient.g = 0.2f;
    m_dcvAmbient.b = 0.2f;
    m_dcvAmbient.a = 1.0f;

    pDevice->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_RGBA((BYTE)(m_dcvAmbient.r * 255.0f), (BYTE)(m_dcvAmbient.g * 255.0f), (BYTE)(m_dcvAmbient.b * 255.0f), (BYTE)(m_dcvAmbient.a * 255.0f)));

	// Get the backbuffer for the font
	hr = pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_backBuffer);
	if(hr != D3D_OK)
		return hr;

	// Setup the timer
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	m_lastTime	= (double)timer / m_frequency;
	m_startTime	= m_lastTime;
	m_lastCycle	= m_lastTime;

	XGVECTOR4 sparkcolor(1.0f, 0.25f, 0.0f, 0.6f/(float)g_TestParams.dwSparkMaxAge);
	pDevice->SetVertexShaderConstant(23, &sparkcolor, 1);


    //
    // audio variables
    //


    m_dwAudioReadPtr = 0;
    m_dwAudioWritePtr = 0;
    m_dwAudioReadTotal = 0;
    m_dwAudioWriteTotal = 0;
    m_dwAudioDelta = 100000;

//	g_dwDirectSoundDebugLevel = 3;

	ASSERT(DirectSoundCreate(NULL, &g_pDSound, NULL) == DS_OK);
    effectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    effectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
	ASSERT(XAudioDownloadEffectsImage("t:\\media\\DSPCode\\dsstdfx.bin", &effectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, &pDesc) == S_OK);
	DirectSoundUseFullHRTF();

	// Create the thread
	CreateThread(NULL, 0, WaitForVoiceOffThread2D, NULL, 0, NULL);
	CreateThread(NULL, 0, WaitForVoiceOffThread3D, NULL, 0, NULL);

    return S_OK;
}

//------------------------------------------------------------------------------
//	CScene::NextFrame
//------------------------------------------------------------------------------
void CScene::NextFrame(void)
/*++

Routine Description:

	Sets up for the next frame

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;
	float		distance;
	float		saveDistance;
	UINT		hit;
	float		moveLeft;
	float		moved;
	XGVECTOR3	normal;
	XGVECTOR3	inverse;
	XGVECTOR3	reflection;
	UINT		i;
	UINT		ii;
	CScene::Hit	hitWhat;
	XGVECTOR3	loc;
    static BOOL doUpdate = TRUE;
	XGVECTOR3	saveNormal;
	float		speed;
	XGVECTOR3	dirA;
	XGVECTOR3	dirB;
	float		speedA;
	float		speedB;
	long		lastBallHit;
	UINT		numObjects = m_maxBalls + m_numLights;
	UINT		hits;

	// To disable ball or test changes for debug purposes
	if(!doUpdate)
		return;

	//update sparks
	m_sparks.Update(1/(float)m_drawRate);

	// Move all the balls
	for(i=0; i<numObjects; ++i) 
	{
        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Generate a speed based on the framerate so changes to framerates do not
		// change the actual distance a ball moves
		speed		= m_balls[i].GetSpeed() / (float)m_drawRate;
		moveLeft	= speed;
		moved		= 0.0f;	
		lastBallHit	= -1;
		hits		= 0;

		while((moveLeft > 0.0) && (hits < numObjects))
		{
			++hits;
			saveDistance	= 1.0e30f;
			hitWhat			= CScene::HIT_NOTHING;
			hit				= i;

			// Get the intersection with the bounding sphere
			if(!IntersectRayInSphere(m_balls[i].GetLocation(), m_balls[i].GetDirection(), 
								     XGVECTOR3(0.0f, 0.0f, 0.0f), m_radius, point)) 
			{
				__asm int 3;	// This should never happen!
				doUpdate = FALSE;
				return;
			}

			distance = XGVec3Length(&XGVECTOR3(point - m_balls[i].GetLocation())) -
					   m_balls[i].GetRadius();
			if(distance < 0.0f)
				distance = 0.0f;

			// Will the bounding sphere be hit?
			if(distance <= moveLeft) 
			{
				saveDistance	= distance;
				hitWhat			= CScene::HIT_WALL;
			}

			// Check for intersection with all other balls
			for(ii=0; ii<numObjects; ++ii) 
			{
                if (ii == m_numBalls) {
					if(m_numLights == 0)
						break;
                    ii = m_maxBalls;
                }

				if(i != ii)
				{
					if(GetSphereIntersection(m_balls[i].GetLocation(),
											 m_balls[i].GetRadius(),
											 m_balls[i].GetDirection(),
											 m_balls[ii].GetLocation(),
											 m_balls[ii].GetRadius(),
											 distance)) 
					{
						distance = FUDGE(distance, moveLeft, 0.0001);
						if(distance < 0.0f)
							distance = 0.0f;
						if((distance <= moveLeft) && (distance < saveDistance))
						{
							normal.x = (m_balls[i].GetLocation().x + m_balls[i].GetDirection().x * distance) - 
										m_balls[ii].GetLocation().x;
							normal.y = (m_balls[i].GetLocation().y + m_balls[i].GetDirection().y * distance) -
										m_balls[ii].GetLocation().y;
							normal.z = (m_balls[i].GetLocation().z + m_balls[i].GetDirection().z * distance) -
										m_balls[ii].GetLocation().z;

							// Check for valid hit
							if(XGVec3Dot(&normal, &m_balls[i].GetDirection()) < 0.0f)
							{
								XGVec3Normalize(&saveNormal, &normal);
								saveDistance	= distance;
								hit				= ii;
								hitWhat			= CScene::HIT_BALL;
							}
						}
					}
				}
			}

			// What was hit?
			switch(hitWhat)
			{
			case CScene::HIT_WALL:	// Hit the wall

				// Normal at inner point on sphere
				normal = -point;
				XGVec3Normalize(&normal, &normal);

				// Callback
				BallHitWall(i, normal);

				// Move the ball
				m_balls[i].Move(saveDistance);
				moved = saveDistance;

				// Inverse of direction
				inverse = -m_balls[i].GetDirection();
				
				// Calculate the reflection
				reflection = normal * 2.0f * (XGVec3Dot(&normal, &inverse)) - inverse;

				// Callback
				BallDirectionChanged(i, m_balls[i].GetDirection(), reflection);

				// Change the ball's direction
				m_balls[i].SetDirection(reflection);
				break;

			case CScene::HIT_BALL:	// Hit another ball
			
				// Prevent a ball from running into the same ball multiple times, 
				// and make sure the colliding ball overtakes the target
				if(((long)hit != lastBallHit) &&
				   (m_balls[i].GetSpeed() > (m_balls[hit].GetSpeed() * 
											 XGVec3Dot(&m_balls[i].GetDirection(),
													   &m_balls[hit].GetDirection()))))
				{
					lastBallHit = (long)hit;

					// Move the ball
					m_balls[i].Move(saveDistance);
					moved = saveDistance;

					dirA	= m_balls[i].GetDirection();
					dirB	= m_balls[hit].GetDirection();
					speedA	= m_balls[i].GetSpeed();
					speedB	= m_balls[hit].GetSpeed();

					// If both balls are of the same type, collide as normal
					CollideBalls(m_balls[i].GetLocation(), dirA, speedA, m_balls[i].GetMass(),
								 m_balls[hit].GetLocation(), dirB, speedB, m_balls[hit].GetMass());

					// If the ball's speed changes so should moveLeft...
					moveLeft -= (m_balls[i].GetSpeed() - speedA) / (float)m_drawRate;
					
					// Callbacks
					BallHitBall(i, hit);
					BallDirectionChanged(i, m_balls[i].GetDirection(), dirA);
					BallDirectionChanged(hit, m_balls[hit].GetDirection(), dirB);
					BallSpeedChanged(i, m_balls[i].GetSpeed(), speedA);
					BallSpeedChanged(hit, m_balls[hit].GetSpeed(), speedB);
					
					m_balls[i].SetDirection(dirA);
					m_balls[hit].SetDirection(dirB);
					m_balls[i].SetSpeed(speedA);
					m_balls[hit].SetSpeed(speedB);

					RecalculateSpeeds();
				}
				else
					moveLeft = 0.0f;
				break;

			default:	// Otherwise, just move the ball forward

				m_balls[i].Move(moveLeft);
				moved = moveLeft;

				break;
			}
			moveLeft -= moved;
		}
	}
}

//------------------------------------------------------------------------------
//	CScene::Render
//------------------------------------------------------------------------------
void 
CScene::Render(
			   IN IDirect3DDevice8*	pDevice
			   ) 
/*++

Routine Description:

	Renders the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    DWORD				dwValue;
	LONGLONG			timer;
	LONGLONG			start;
	WCHAR				buffer[256];
	UINT				i;
	UINT				j;
	UINT				k;
	UINT				y;
    HRESULT				hr;
	double				currentTime;
	float				lineWidth = 1.0f;
    XGMATRIX			mView;
	XGMATRIX			mProj;
	XGMATRIX			mViewProj;
    XGVECTOR3			vEyePos;
    D3DLIGHT8			light;
    IDirect3DSurface8*	pd3ds;
	int					hours;
	int					minutes;
	int					seconds;
	int					fraction;
	BOOL				bCycle;
	double				dt;
    D3DLOCKED_RECT		d3dlr;
    DWORD				dwNormal;
    DWORD				dwPhysical;        

	// For draw rate
	QueryPerformanceCounter((LARGE_INTEGER*)&start);
	
	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
	pDevice->SetRenderState(D3DRS_LINEWIDTH, *(DWORD*)&lineWidth);

    for (i = 0; i < 2; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }
    for (i = 2; i < 4; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);

    pDevice->SetRenderState(D3DRS_POINTSIZE_MIN, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_A, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_B, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_C, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);

    pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Begin the scene
    pDevice->BeginScene();

    // Screen space offset
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        D3DFIELD_STATUS fstatus;
        pDevice->GetDisplayFieldStatus(&fstatus);
        pDevice->SetScreenSpaceOffset(0.0f, (fstatus.Field == D3DFIELD_EVEN) ? 0.0f : 0.5f);
    }

	// World matrix
	pDevice->SetTransform(D3DTS_WORLD, &m_identityMatrix);

	// Camera
	m_camera.Render(pDevice);

    // Get the view and projection matrices
    pDevice->GetTransform(D3DTS_VIEW, &mView);
    pDevice->GetTransform(D3DTS_PROJECTION, &mProj);

    XGMatrixMultiply(&mViewProj, &mView, &mProj);

    // Get the camera position
    m_camera.GetPosition(&vEyePos);

	// Draw the background triangles with depth write disabled to ensure all are written
	// without affecting other draws
    if(m_numLayers) {
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
        pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
        pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, m_numLayers * 2, m_backgroundTriangles,
                                 sizeof(CScene::Vertex));
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
    }
    
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetVertexShader(m_dwVShader);
    pDevice->SetPixelShader(m_dwPShader);

    pDevice->SetTexture(2, m_pd3dtcNormal);
    pDevice->SetTexture(3, m_pd3dtcNormal);

	// Draw balls
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        for (j = 0; j < m_numBalls; j++) {
            m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_balls[i].GetLight(), &m_dcvAmbient, i - m_maxBalls);
        }
    }
	if(g_TestParams.bSparksAreLights) {
		for(i=0, k=m_sparks.GetNumSparks(); i<k; ++i) {
			for (j = 0; j < m_numBalls; j++) {
    			m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_sparks.GetLight(i), &m_dcvAmbient, 1);
			}
		}
	}

    // Disable ambient audio for any balls not being drawn
    for (i = m_numBalls; i < m_maxBalls; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    for (i = m_maxBalls + m_numLights; i < m_maxBalls + m_maxLights; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

    pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
    pDevice->SetPixelShader(NULL);
    pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// Draw the sphere
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i += 8) {

        for (j = 0; j < 8 && j + i < m_maxBalls + m_numLights; j++) {
            memcpy(&light, m_balls[i+j].GetLight(), sizeof(D3DLIGHT8));
            light.Attenuation0 = 0.0f;
            light.Attenuation1 = 0.0f;
            light.Attenuation2 = 2.0f;
            m_pDevice->SetLight(j, &light);
            m_pDevice->LightEnable(j, TRUE);
        }
        for (; j < 8; j++) {
            m_pDevice->LightEnable(j, FALSE);
        }

        m_invertedSphere.Render(pDevice, i - m_maxBalls, m_bDrawWireframe);
    }

	pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	// Draw lights
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        m_balls[i].Render(pDevice, NULL, NULL, NULL, NULL, 0);
    }

	//draw sparks
    pDevice->SetVertexShader(m_dwVShader2);
	m_sparks.Render(pDevice, &mViewProj);

	// Init matrices
	pDevice->SetTransform(D3DTS_VIEW, &m_identityMatrix);
	pDevice->SetTransform(D3DTS_PROJECTION, &m_identityMatrix);

    WCHAR tempbuffer[256];
    DWORD dwColors[NUM_SELECTIONS];
    for (i=0; i<NUM_SELECTIONS; i++)
    {
        if (g_TestParams.dwDMSelected == i)
            dwColors[i] = 0xFFFFFF00;
        else
            dwColors[i] = 0xFFFFFFFF;
    }

    m_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // Commit 3D audio
    //

//	if(g_dsound)
//		g_dsound->CommitDeferredSettings();

	//
	// Info that does not get changed
	//
	y = 15;

//	swprintf(buffer, L"FPS: %.2lf (%.2lf)", m_avgFrameRate, m_currentFrameRate);
//	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
//	y += 10;
	swprintf(buffer, L"Seed: %u", g_TestParams.dwSeed);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Sparks: %u", m_sparks.GetNumSparks());
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Layers: %u", m_numLayers);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Triangles: %u", m_numTris);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 40;

    swprintf(buffer, L"bDMLoaderThread = %d", g_TestParams.bDMLoaderThread);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"bDMDoWorkLocally = %d", g_TestParams.bDMDoWorkLocally);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"dwFileIOSize = %d", g_TestParams.dwFileIOSize);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 60;

	swprintf(buffer, L"DirectSound Playing: %S", g_TestParams.szBounceSound);
	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0); 
	y += 10;


	//
	// Info that does get updated
	//
	y = 15;
	swprintf(buffer, L"Balls: %u / %u", g_TestParams.dwNumBalls, m_maxBalls);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[0], 0);
	y += 10;

	swprintf(buffer, L"Lights: %u / %u", g_TestParams.dwNumLights, m_maxLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[1], 0);
	y += 10;

	swprintf(buffer, L"bDrawWireframe=%u", g_TestParams.bDrawWireframe);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[2], 0);
	y += 10;

	swprintf(buffer, L"bRelativeSpeed=%u", g_TestParams.bRelativeSpeed);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[3], 0);
	y += 10;

	swprintf(buffer, L"bSparksAreLights=%u", g_TestParams.bSparksAreLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[4], 0);
	y += 10;

	swprintf(buffer, L"dwSparksPerCollision=%u", g_TestParams.dwSparksPerCollision);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[5], 0);
	y += 20;


    swprintf(buffer, L"Master Volume = %d", g_TestParams.lDMMasterVolume);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[7], 0);
	y += 10;

    swprintf(buffer, L"Master Tempo Factor = %.2f", g_TestParams.fDMMasterTempo);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[8], 0);
	y += 10;

    swprintf(buffer, L"Master Transpose = %d", g_TestParams.lDMMasterTranspose);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[9], 0);
	y += 10;


	swprintf(buffer, L"DirectSound Volume = %d", g_TestParams.lDSVolume);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[11], 0);
	y += 10;

	swprintf(buffer, L"DirectSound Frequency = %u", g_TestParams.dwDSFreq);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[12], 0);
	y += 10;

	// Display the current run time
	currentTime	= m_lastTime - m_startTime;
	hours		= (int)(currentTime / 3600.0);
	currentTime	-= (3600.0 * hours);
	minutes		= (int)(currentTime / 60.0);
	currentTime	-= (60.0 * minutes);
	seconds		= (int)currentTime;
	currentTime	-= (double)seconds;
	fraction	= (int)(currentTime * 100);

	swprintf (buffer,L"Time: %02d:%02d:%02d.%02d ", hours, minutes, seconds, fraction);
	m_font.DrawText(pd3ds, buffer, 25, 215, 0, 0xffffffff, 0);

	// Display the frame rate
	swprintf(buffer, L"FPS: %.2lf", m_avgFrameRate);
    m_font.DrawText(pd3ds, buffer, 240, 215, 0, 0xffffffff, 0);

	pd3ds->Release();

	pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

	pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_RGBA);
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYCOLOR, 0);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
#endif

	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	pDevice->SetTexture(0, m_pd3dtText);

	pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prText, sizeof(TVertex));

	pDevice->SetTexture(0, NULL);
	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
#endif

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    // End the scene
    pDevice->EndScene();

    // Update the screen
    pDevice->Present(NULL, NULL, NULL, NULL);

	// Calculate the frame rate
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	currentTime		= (double)timer / m_frequency;
	dt				= currentTime - m_lastTime;
	m_elapsedTime	+= dt;

	// Current frame rate
	m_currentFrameRate = 1.0 / dt;

	// Cycle flag
	bCycle = ((DWORD)((currentTime - m_lastCycle)  * 1000.0) >= g_TestParams.dwCycleTime) ? TRUE : FALSE;

	m_lastTime = currentTime;

	// Frame counter
	++m_frame;

	// Average frame rate calculations
	if(m_elapsedTime > 1.0)
	{
		m_avgFrameRate	= (double)m_frame / m_elapsedTime;
		m_frame			= 0;
		m_elapsedTime	= 0.0;
	}

	// Draw rate
	if(m_bRelativeSpeed)
		m_drawRate = 1.0 / (currentTime - ((double)start / m_frequency));

    if (g_TestParams.bCycleDisplayModes && bCycle) //!(m_frame % 480))
	{
		m_lastCycle = currentTime;
        CycleDisplayMode(); // Reset the display mode
	}
}

//------------------------------------------------------------------------------
//	CScene::CycleDisplayMode
//------------------------------------------------------------------------------
void
CScene::CycleDisplayMode()
{
    D3DPRESENT_PARAMETERS d3dpp;
    float fAspectWidth, fAspectHeight, fFieldOfView;
    HRESULT hr;

    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= m_pd3ddm[m_uDisplayMode].Width;
    d3dpp.BackBufferHeight					= m_pd3ddm[m_uDisplayMode].Height;
    d3dpp.BackBufferFormat					= m_pd3ddm[m_uDisplayMode].Format;
    d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
    d3dpp.Flags								= m_pd3ddm[m_uDisplayMode].Flags;
    d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_LIN_D24S8;
    d3dpp.FullScreen_RefreshRateInHz		= m_pd3ddm[m_uDisplayMode].RefreshRate;

    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    }
    else {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }

//    m_pDevice->PersistDisplay();

    Log("Resetting the device to mode %d:\n", m_uDisplayMode);
    Log("    %d x %d @ %d Hz\n", m_pd3ddm[m_uDisplayMode].Width, m_pd3ddm[m_uDisplayMode].Height, m_pd3ddm[m_uDisplayMode].RefreshRate);
    switch (m_pd3ddm[m_uDisplayMode].Format) {
        case D3DFMT_LIN_A8R8G8B8:
            Log("    D3DFMT_LIN_A8R8G8B8\n");
            break;
        case D3DFMT_LIN_X8R8G8B8:
            Log("    D3DFMT_LIN_X8R8G8B8\n");
            break;
        case D3DFMT_LIN_R5G6B5:
            Log("    D3DFMT_LIN_R5G6B5\n");
            break;
        case D3DFMT_LIN_X1R5G5B5:
            Log("    D3DFMT_LIN_X1R5G5B5\n");
            break;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        Log("    D3DPRESENTFLAG_WIDESCREEN\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_INTERLACED) {
        Log("    D3DPRESENTFLAG_INTERLACED\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_PROGRESSIVE) {
        Log("    D3DPRESENTFLAG_PROGRESSIVE\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        Log("    D3DPRESENTFLAG_FIELD\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        Log("    D3DPRESENTFLAG_10X11PIXELASPECTRATIO\n");
    }
    Log("\n");

    hr = m_pDevice->Reset(&d3dpp);
    if (FAILED(hr)) {
        __asm int 3;
    }

    fFieldOfView = 45.0f;
    fAspectWidth = (float)(m_pd3ddm[m_uDisplayMode].Width);
    fAspectHeight = (float)(m_pd3ddm[m_uDisplayMode].Height);
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        fAspectHeight *= 2.0f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        fFieldOfView *= 0.90909f;
        fAspectWidth *= 1.1f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        fFieldOfView *= 1.33333f;
    }
    if (m_pd3ddm[m_uDisplayMode].Width == 720) {
        fFieldOfView *= 1.125f;
    }

    // Update the projection matrix, etc. as specified by the display mode flags
	m_camera.SetPerspectiveFov(fFieldOfView, fAspectWidth / fAspectHeight, 0.99f * m_radius, 3.01f * m_radius);

    // Update the text quad
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        m_prText[0].y = 240.0f;
        m_prText[3].y = 240.0f;
    }
    else {
        m_prText[0].y = 480.0f;
        m_prText[3].y = 480.0f;
    }

    if (++m_uDisplayMode >= m_uNumDisplayModes) {
        m_uDisplayMode = 0;
    }
}

//------------------------------------------------------------------------------
//	CScene::IntersectRaySphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRaySphere(
						   IN const XGVECTOR3&	rayU, 
						   IN const XGVECTOR3&	rayV, 
						   IN const XGVECTOR3&	center,
						   IN float				radius,
						   OUT XGVECTOR3&		point
						   )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	uc(center - rayU);
	float		v = XGVec3Dot(&uc, &rayV);
	float		d = (radius * radius) - (XGVec3Dot(&uc, &uc) - (v * v));

	if(d < 0.0f)
		return FALSE;

	d = (float)sqrt(d);
	point = rayU + (rayV * (v - d));
	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::IntersectRayInSphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRayInSphere(
						     IN const XGVECTOR3&	rayU, 
						     IN const XGVECTOR3&	rayV, 
						     IN const XGVECTOR3&	center,
						     IN float				radius,
						     OUT XGVECTOR3&			point
						     )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment within the sphere

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	p;
	float		d;

	// Point on line closest to center of sphere
	p	= rayU + (rayV * (-(-XGVec3Dot(&center, &rayV) + XGVec3Dot(&rayU, &rayV)) / 
		  XGVec3Dot(&rayV, &rayV)));

	// Distance from center of sphere to point
	d	= XGVec3Length(&XGVECTOR3(center - p));
	
	// Is the point outside of the sphere?
	if(d > radius)
		return FALSE;

	// Distance from point to point on sphere edge
	d = (float)sqrt((radius * radius) - (d * d));

	// Point on sphere
	point = p + (rayV * d);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::GetSphereIntersection
//------------------------------------------------------------------------------
BOOL
CScene::GetSphereIntersection(
							  IN const XGVECTOR3&	s0,
							  IN float				s0r,
							  IN const XGVECTOR3&	v,
							  IN const XGVECTOR3&	s1,
							  IN float				s1r,
							  OUT float&			t
							  )
/*++

Routine Description:

	Calculates the intersection of two sphere. Sphere 0 is moving in the 
	direction v. Sphere 1 is stationary. For the complete derivation of
	this equation, see robheit

Arguments:

	IN s0 -		Starting location of sphere 0
	IN s0r -	Radius of sphere 0
	IN v -		Direction of travel for sphere 0
	IN s1 -		Location of sphere 1
	IN s1r -	Radius of sphere 1
	OUT t -		Distance along path the sphere touch

Return Value:

	TRUE if the spheres will touch, FALSE otherwise

--*/
{
	float	a;
	float	b;
	float	c;
	float	d;
//	float	t1;

	// Quick dot product check
	if(XGVec3Dot(&v, &XGVECTOR3(s1 - s0)) <= 0.0f)
		return FALSE;

	a = ((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
	b = 2.0f * ((s0.x * v.x) - (s1.x * v.x) + (s0.y * v.y) - 
		        (s1.y * v.y) + (s0.z * v.z) - (s1.z * v.z));
	c = ((s0r + s1r) * (s0r + s1r)) - (s0.x * s0.x) + 
		(2.0f * ((s1.x * s0.x) + (s1.y * s0.y) + (s1.z * s0.z))) - 
		(s1.x * s1.x) - (s0.y * s0.y) - (s1.y * s1.y) - (s0.z * s0.z) - 
		(s1.z * s1.z);

	if(a != 0.0f) {
		d = (b * b) + 4.0f * a * c;
		if(d >= 0.0f) {
			d = (float)sqrt(d);
			t = (-d - b) / (2.0f * a);
			if(t < 0.000001f)
				t = 0.0f;

			// Second solution to quadratic equation
			//t1 = (d - b) / (2.0f * a);
			return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CScene::RandomColor
//------------------------------------------------------------------------------
DWORD
CScene::RandomColor(void)
/*++

Routine Description:

	Returns a random color

Arguments:

	None

Return Value:

	A random color 0xaarrggbb

--*/
{
	DWORD	a = (DWORD)(rand() % 0xff);
	DWORD	r = (DWORD)(rand() % 0xff);
	DWORD	g = (DWORD)(rand() % 0xff);
	DWORD	b = (DWORD)(rand() % 0xff);

	return (a << 24) | (r << 16) | (g << 8) | b;
}

//------------------------------------------------------------------------------
//	CScene::BallHitBall
//------------------------------------------------------------------------------
void 
CScene::BallHitBall(
					IN UINT	ball0,
					IN UINT ball1
					)
/*++

Routine Description:

	Called whenever 2 balls touch

Arguments:

	IN ball0 -	First ball (0 - m_numBalls-1)
	IN ball1 -	Second ball (0 - m_numBalls-1)

Return Value:

	None

--*/
{
	//
	// play the audio buffer on one of the balls that was hit
	//
	for(UINT i = 0; i < g_TestParams.dwSparksPerCollision; i++) {
		m_sparks.AddSpark((m_balls[ball0].GetLocation() + m_balls[ball1].GetLocation()) / 2);
	}

    m_balls[ball0].PlayBuffer((MAX2(m_balls[ball0].GetSpeed(), m_balls[ball1].GetSpeed()) - m_currentMinSpeed) / m_dSpeed,
							   ADJUST(XGVec3Dot(&m_balls[ball0].GetDirection(), &m_balls[ball1].GetDirection())));


    //
    // Set up an async file write
    //
    if(g_TestParams.dwFileIOSize != 0)
        {
        FileIOHandle *info = new FileIOHandle;
        OVERLAPPED *overlapped = new OVERLAPPED;
        if(!info || !overlapped)
            {
            delete info;
            delete overlapped;
            return;
            }

        info->buffSize = g_TestParams.dwFileIOSize;
        info->buffer = new char[info->buffSize];
        if(!info->buffer)
            {
            delete info;
            delete overlapped;
            return;
            }

        // open the initial file if necessary
        if(m_hFile == INVALID_HANDLE_VALUE)
            {
            m_hFile = CreateFile("t:\\randomdata.dat", GENERIC_WRITE|GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
            SetFilePointer(m_hFile, (m_numBalls+1) * 4096, NULL, FILE_BEGIN);
            SetEndOfFile(m_hFile);
            }

        overlapped->Internal = 0;
        overlapped->InternalHigh = 0;
        overlapped->Offset = ball0*info->buffSize + ball1;
        overlapped->OffsetHigh = 0;
        overlapped->hEvent = info;

        for(unsigned i=0; i<info->buffSize; i++)
            {
            info->buffer[i] = (char)i;
            }

        if(WriteFileEx(m_hFile, info->buffer, info->buffSize, overlapped, CompleteIO) == 0)
            {
            // error
            }
        SleepEx(15000, true); // allows the CompleteIO function to be called
        }

}

//------------------------------------------------------------------------------
//	CScene::BallHitWall
//------------------------------------------------------------------------------
void 
CScene::BallHitWall(
					IN UINT				ball,
					IN const XGVECTOR3&	normal
					)
/*++

Routine Description:

	Called whenever a ball hits the wall

Arguments:

	IN ball -	Ball (0 - m_numBalls-1)
	IN normal -	Normal at point on wall that was hit

Return Value:

	None

--*/
{
	//
	// play the audio buffer on the ball that was hit
	//
    m_balls[ball].PlayBuffer((m_balls[ball].GetSpeed() - m_currentMinSpeed) / m_dSpeed,
							 ADJUST(XGVec3Dot(&m_balls[ball].GetDirection(), &normal)));
}

//------------------------------------------------------------------------------
//	CScene::BallSpeedChanged
//------------------------------------------------------------------------------
void 
CScene::BallSpeedChanged(
						 IN UINT	ball,
						 IN float	oldSpeed,
						 IN float	newSpeed
						 )
/*++

Routine Description:

	Called whenever a ball's speed changes

Arguments:

	IN ball -		Ball (0 - m_numBalls-1)
	IN oldSpeed -	Old speed
	IN newSpeed -	New speed

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::BallDirectionChanged
//------------------------------------------------------------------------------
void 
CScene::BallDirectionChanged(
							 IN UINT				ball,
							 IN const XGVECTOR3&	oldDirection,
							 IN const XGVECTOR3&	newDirection
							 )
/*++

Routine Description:

	Called whenever a ball's direction changes

Arguments:

	IN ball -			Ball (0 - m_numBalls-1)
	IN oldDirection -	Old direction
	IN newDirection -	New direction

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddBall(void)
/*++

Routine Description:

	Adds a ball to the scene (up to m_maxBalls)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numBalls < m_maxBalls)
	{
		// Find a good place to insert the ball
		// (Make sure the new ball is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_numBalls].SetPosition(loc);
		m_balls[m_numBalls].SetDirection(dir);
		m_balls[m_numBalls].SetSpeed(speed);

		m_numTris += m_balls[m_numBalls].GetNumTris();

		// Increase the number of balls
		++m_numBalls;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveBall
//------------------------------------------------------------------------------
void
CScene::RemoveBall(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numBalls > 0)
	{
		--m_numBalls;
		m_numTris -= m_balls[m_numBalls].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddLight(void)
/*++

Routine Description:

	Adds a light to the scene (up to m_maxLights)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numLights < m_maxLights)
	{
		// Find a good place to insert the light
		// (Make sure the new light is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_maxBalls + m_numLights].SetPosition(loc);
		m_balls[m_maxBalls + m_numLights].SetDirection(dir);
		m_balls[m_maxBalls + m_numLights].SetSpeed(speed);

		m_numTris += m_balls[m_maxBalls + m_numLights].GetNumTris();

		// Increase the number of balls
		++m_numLights;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveLight
//------------------------------------------------------------------------------
void
CScene::RemoveLight(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numLights > 0)
	{
		--m_numLights;
		m_numTris -= m_balls[m_maxBalls + m_numLights].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::CollideBalls
//------------------------------------------------------------------------------
void 
CScene::CollideBalls(
					 IN const XGVECTOR3&	locA,
					 IN OUT XGVECTOR3&		dirA, 
					 IN OUT float&			speedA, 
					 IN float				massA,
					 IN const XGVECTOR3&	locB,
					 IN OUT XGVECTOR3&		dirB, 
					 IN OUT float&			speedB,
					 IN float				massB
					 )
/*++

Routine Description:

	Collides two balls and adjusts their velocities

Arguments:

	IN locA -		Location of ball A
	IN OUT dirA -	Direction of Ball A
	IN OUT speedA -	Speed of Ball A
	IN massA -		Mass of Ball A
	IN locB -		Location of ball B
	IN OUT dirB -	Direction of Ball B
	IN OUT speedB -	Speed of Ball B
	IN massB -		Mass of Ball B
	
Return Value:

	None

--*/
{
	XGVECTOR3	AB;
	XGVECTOR3	BA;
	float		dot;
	XGVECTOR3	momentumAB;	// Momentum of A in the direction of B
	XGVECTOR3	momentumBA;	// Momentum of B in the direction of A
	float		totalMomentum = (speedA * massA) + (speedB * massB);
	float		mass = MIN2(massA, massB);

	// Vector of interection
	AB = locB - locA;
	XGVec3Normalize(&AB, &AB);
	BA = -AB;

	// Momentum of A in the direction of B
	dot = XGVec3Dot(&AB, &dirA);
	if(dot > 0.0f)
		momentumAB = AB * speedA * mass * dot;
	else
	{
		momentumAB.x = 0.0f;
		momentumAB.y = 0.0f;
		momentumAB.z = 0.0f;
	}

	// Momentum of B in the direction of A
	dot = XGVec3Dot(&BA, &dirB);
	if(dot > 0.0f)
		momentumBA = BA * speedB * mass * dot;
	else
	{
		momentumBA.x = 0.0f;
		momentumBA.y = 0.0f;
		momentumBA.z = 0.0f;
	}

	// Calculate the momentum of each ball
	dirA = (dirA * speedA * massA) - momentumAB + momentumBA;
	dirB = (dirB * speedB * massB) - momentumBA + momentumAB;

	// Calculate the speed (magnitude of the momentum vector)
	speedA = XGVec3Length(&dirA);
	speedB = XGVec3Length(&dirB);

	// Floating point error remover
	// At this point the following should be true: momentumA + momentumB == totalMomentum
	// but do to floating point error probably will not be
	speedA	= (speedA / (speedA + speedB)) * totalMomentum;
	speedB	= (totalMomentum - speedA) / massB;
	speedA	/= massA;

	// Normalize the direction vectors
	XGVec3Normalize(&dirA, &dirA);
	XGVec3Normalize(&dirB, &dirB);
}

//******************************************************************************
HRESULT CScene::CreateShaders(IDirect3DDevice8* pDevice) {

    LPXGBUFFER          pxgbufShader;
    HANDLE              hFile;
    DWORD               dwRead;
    D3DPIXELSHADERDEF   d3dpsd;
    DWORD               dwSize;
    LPBYTE              pData;
    HRESULT             hr;

    DWORD dwSDecl[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT2),
            D3DVSD_REG(2, D3DVSDT_FLOAT3),
            D3DVSD_REG(3, D3DVSDT_FLOAT3),
            D3DVSD_REG(4, D3DVSDT_FLOAT3),
            D3DVSD_END()
    };
    DWORD dwSDecl2[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT1),
            D3DVSD_END()
    };

    hFile = CreateFile(g_TestParams.szLightVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader, 0);
//	m_dwVShaderAddress = pDevice->GetVertexShaderSize(&dwVShader);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }


    hFile = CreateFile(g_TestParams.szSparkVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl2, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader2, 0);
//	m_dwVShaderAddress2 = m_dwVShaderAddress + pDevice->GetVertexShaderSize(&dwVShader2);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }

//	pDevice->LoadVertexShader(m_dwVShader, m_dwVShaderAddress);
//	pDevice->LoadVertexShader(m_dwVShader2, m_dwVShaderAddress2);


    // Complete light with specular power of 16
    memset(&d3dpsd, 0, sizeof(D3DPIXELSHADERDEF));
    d3dpsd.PSCombinerCount = PS_COMBINERCOUNT(4, PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    d3dpsd.PSTextureModes = PS_TEXTUREMODES(PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_CUBEMAP, 
                                            PS_TEXTUREMODES_CUBEMAP);

    d3dpsd.PSRGBInputs[0] = PS_COMBINERINPUTS(
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T2 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T3 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(PS_REGISTER_R0, PS_REGISTER_R1, PS_REGISTER_DISCARD,
                                PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT |
                                PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA);

    d3dpsd.PSRGBInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_T1, PS_REGISTER_T2, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSAlphaInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
                                PS_REGISTER_T2 | PS_CHANNEL_RGB, 
                                PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_T0 | PS_CHANNEL_ALPHA,
                                0);

    hr = pDevice->CreatePixelShader(&d3dpsd, &m_dwPShader);
    if (FAILED(hr)) {
        return hr;
    }

    return TRUE;
}

//******************************************************************************
void CScene::ReleaseShaders() {

    if (m_dwVShader) {
        m_pDevice->DeleteVertexShader(m_dwVShader);
    }
    if (m_dwPShader) {
        m_pDevice->DeletePixelShader(m_dwPShader);
    }
}

//******************************************************************************
//
// Function:
//
//     CreateNormalMap
//
// Description:
//
//     Create a cube map and populate it with normal vector information.
//
// Arguments:
//
//     IDirect3DDevice8* pDevice       - Pointer to the device object
//
//     UINT uLength                    - Dimensions of the map
//
//     float fBumpDelta                - Maximum component offset to randomly 
//                                       perturb the surface normals
//
//     D3DFORMAT fmt                   - Format of the texture
//
//     BOOL bMipmap                    - Indicates whether or not to
//                                       use a mip map
//
//     D3DPOOL pool                    - Memory pool in which to create the map
//
// Return Value:
//
//     A pointer to the created diffuse map on success, NULL on failure.
//
//******************************************************************************
HRESULT CScene::CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc)
{
    IDirect3DCubeTexture8* pd3dtc;
    Swizzler        swz(uLength, uLength, 1);
    D3DLOCKED_RECT  d3dlr;
    LPDWORD         pdwPixel;
    XGVECTOR3       vDir;
    float           fU, fV;
    UINT            i, j, u, v;
    HRESULT         hr;

    if (!ppd3dtc) {
        return E_FAIL;
    }

    *ppd3dtc = NULL;

    hr = pDevice->CreateCubeTexture(uLength, uLevels, 0, D3DFMT_X8R8G8B8, 0, &pd3dtc);
    if (FAILED(hr)) {
        return hr;
    }

    uLevels = pd3dtc->GetLevelCount();

    // Generate the normals
    for (i = 0; i < uLevels; i++) {

        for (j = 0; j < 6; j++) {

            pd3dtc->LockRect((D3DCUBEMAP_FACES)j, i, &d3dlr, NULL, 0);

            pdwPixel = (LPDWORD)d3dlr.pBits;

            if (uLevels > 1) {
                uLength = 0x1 << ((uLevels - 1) - i);
            }

            Swizzler swz(uLength, uLength, 1);
            swz.SetU(0);
            swz.SetV(0);

            for (v = 0; v < uLength; v++) {

                for (u = 0; u < uLength; u++) {

                    if (uLength > 1) {
                        fU = (float)u / (float)(uLength - 1);
                        fV = (float)v / (float)(uLength - 1);
                    }
                    else {
                        fU = 0.5f;
                        fV = 0.5f;
                    }

                    switch ((D3DCUBEMAP_FACES)j) {
                        case D3DCUBEMAP_FACE_POSITIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f, 1.0f - (fV * 2.0f), 1.0f - (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f, 1.0f - (fV * 2.0f), -1.0f + (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f, -1.0f + (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), -1.0f, 1.0f - (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f - (fV * 2.0f), 1.0f));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f - (fU * 2.0f), 1.0f - (fV * 2.0f), -1.0f));
                            break;
                    }
                    vDir = -vDir;
				    XGVec3Normalize(&vDir, &vDir);

                    pdwPixel[swz.Get2D()] = VectorToColor(&vDir);

                    swz.IncU();
                }

                swz.IncV();
            }

            pd3dtc->UnlockRect((D3DCUBEMAP_FACES)j, i);
        }
    }

    *ppd3dtc = pd3dtc;

    return D3D_OK;
}

//------------------------------------------------------------------------------
//	CScene::RecalculateSpeeds
//------------------------------------------------------------------------------
void
CScene::RecalculateSpeeds(void)
{
	UINT i;

	m_currentMinSpeed	= 1.0e30f;
	m_currentMaxSpeed	= -1.0e30f;
	for(i=0; i<m_numBalls; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	for(i=m_maxBalls; i<m_maxBalls+m_numLights; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	m_dSpeed = m_currentMaxSpeed - m_currentMinSpeed;
}



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\InvertedBall.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __INVERTEDBALL_H__
#define __INVERTEDBALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media4 {

//------------------------------------------------------------------------------
//	CInvertedBall
//------------------------------------------------------------------------------
class CInvertedBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		XGVECTOR3	normal;
		float		tu, tv;
	};

public:

	CInvertedBall(void);
	virtual ~CInvertedBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, int, int);
	void SetPosition(const XGVECTOR3&);
	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	void Render(IDirect3DDevice8*, UINT, BOOL);

	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;

private:

	void Release(void);

private:

	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	BOOL					m_dontDraw;
	float					m_radius;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_location;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\InvertedBall.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include "InvertedBall.h"
#include "helpers.h"

using namespace Media4;

namespace Media4 {

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#ifndef PI 
#	define PI 3.14159265359f
#endif

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CInvertedBall::m_uRef = 0;
IDirect3DTexture8* CInvertedBall::m_pd3dtBase = NULL;

//------------------------------------------------------------------------------
//	Globals
//------------------------------------------------------------------------------
D3DMATERIAL8 g_material = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.25f, 0.25f, 0.25f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

D3DMATERIAL8 g_material2 = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.0f, 0.0f, 0.0f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

//------------------------------------------------------------------------------
//	CInvertedBall::CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::CInvertedBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	= TRUE;
	m_pVB		= NULL;
	m_pIB		= NULL;
    m_uRef++;
}

//------------------------------------------------------------------------------
//	CInvertedBall::~CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::~CInvertedBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CInvertedBall::Create
//------------------------------------------------------------------------------
HRESULT
CInvertedBall::Create(
					  IN IDirect3DDevice8*	pDevice,
					  IN float				radius,
					  IN int				numLong,
					  IN int				numLat
					  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	int			index;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	Vertex*		newVerts	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;

	// Release previous buffers
	Release();

	// Setup
	m_radius = radius;

	// Num verts and tris
	m_numVertices	= latitude1 * numLong + 2;
	m_numTriangles	= (latitude1 * 2) * numLong;
	
	// Allocate vertices
	vertices = new Vertex [m_numVertices];
	ASSERT(vertices != NULL);

	// Increments
	phiInc	= (2.0f * PI) / (float)numLong;
	rhoInc	= PI / (float)numLat;

	// Calculate vertices
	vertices[0].normal		= XGVECTOR3(0.0f, -1.0f, 0.0f);
	vertices[0].position	= XGVECTOR3(0.0f, m_radius, 0.0f);
    vertices[0].tu          = 0.0f;
    vertices[0].tv          = 0.0f;
	for(index=1, phi=0.0f, p=0; p<numLong; ++p, phi += phiInc) 
	{
		for(rho=PI/2.0f - rhoInc, r=0; r<latitude1; ++r, rho-=rhoInc, ++index) 
		{
			vertices[index].normal		= XGVECTOR3((float)(cos(phi) * fabs(cos(rho))), 
													  (float)sin(rho), 
													  -(float)(sin(phi) * fabs(cos(rho))));
			vertices[index].position	= XGVECTOR3(vertices[index].normal.x * m_radius, 
													  vertices[index].normal.y * m_radius, 
													  vertices[index].normal.z * m_radius);
			vertices[index].normal		= -vertices[index].normal;
            vertices[index].tu          = (float)p / (float)(numLong - 1) * 4.0f;
            vertices[index].tv          = (float)r / (float)(latitude1 - 1) * 3.0f;
		}
	}
	vertices[index].normal		= XGVECTOR3(0.0f, 1.0f, 0.0f);
	vertices[index].position	= XGVECTOR3(0.0f, -m_radius, 0.0f);
    vertices[index].tu          = 0.0f;
    vertices[index].tv          = 3.0f;
	last = index;

	// Build the indices & real vertices
	m_numVertices	= m_numTriangles * 3;

	indices = new WORD [m_numVertices];
	ASSERT(indices != NULL);

	newVerts = new Vertex [m_numVertices];
	ASSERT(newVerts != NULL);

	for(index = 0, p=0; p<numLong; ++p) 
	{
		// Shortcuts
		pl = p * latitude1 + 1;
		if(p != longitude1)
			p1l = (p+1) * latitude1 + 1;
		else
			p1l = 1;

		// Top triangle
		newVerts[index].tu			= vertices[0].tu;//0.5f;
		newVerts[index].tv			= vertices[0].tv;//0.0f;
		newVerts[index].normal		= vertices[0].normal;
		newVerts[index++].position	= vertices[0].position;
		newVerts[index].tu			= vertices[p1l].tu;//0.0f;
		newVerts[index].tv			= vertices[p1l].tv;//1.0f;
		newVerts[index].normal		= vertices[p1l].normal;
		newVerts[index++].position	= vertices[p1l].position;
		newVerts[index].tu			= vertices[pl].tu;//1.0f;
		newVerts[index].tv			= vertices[pl].tv;//1.0f;
		newVerts[index].normal		= vertices[pl].normal;
		newVerts[index++].position	= vertices[pl].position;

		// Middle triangles
		for(r=0; r<latitude2; ++r) 
		{
			newVerts[index].tu			= vertices[pl + r].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r].tv;//0.0f;
			newVerts[index].normal		= vertices[pl + r].normal;
			newVerts[index++].position	= vertices[pl + r].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;

			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[p1l + r + 1].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[p1l + r + 1].normal;
			newVerts[index++].position	= vertices[p1l + r + 1].position;
		}

		// Bottom triangle
		newVerts[index].tu			= vertices[last].tu;//0.0f;
		newVerts[index].tv			= vertices[last].tv;//1.0f;
		newVerts[index].normal		= vertices[last].normal;
		newVerts[index++].position	= vertices[last].position;
		newVerts[index].tu			= vertices[pl + r].tu;//1.0f;
		newVerts[index].tv			= vertices[pl + r].tv;//1.0f;
		newVerts[index].normal		= vertices[pl + r].normal;
		newVerts[index++].position	= vertices[pl + r].position;
		newVerts[index].tu			= vertices[p1l + r].tu;//0.5f;
		newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
		newVerts[index].normal		= vertices[p1l + r].normal;
		newVerts[index++].position	= vertices[p1l + r].position;
	}
	delete [] vertices;
	for(p=0; p<m_numVertices; ++p)
		indices[p] = (WORD)p;

	// Setup the vertex buffer for the Ball
	hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 XYZ_NORMAL_TEX, D3DPOOL_DEFAULT, 
									 &m_pVB);
	if(FAILED(hr)) 
	{
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	hr = m_pVB->Lock(0, m_numVertices * sizeof(Vertex), (BYTE**)&pVoid, 0);
	if(FAILED(hr))
	{
		Release();
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, newVerts, m_numVertices * sizeof(Vertex));
	m_pVB->Unlock();
	delete [] newVerts;

	// Setup the index buffer for the Ball
	hr = pDevice->CreateIndexBuffer(m_numVertices * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	hr = m_pIB->Lock(0, m_numVertices * sizeof(WORD), (BYTE**)&pVoid, 0);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, indices, m_numVertices * sizeof(WORD));
	m_pIB->Unlock();
	delete [] indices;

	// Create the texture
    if (!m_pd3dtBase) {
#if 1
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szSphereBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
#else
        HANDLE hFile;
        DWORD dwSize, dwRead;
        LPBYTE pData;

        hFile = CreateFile(g_TestParams.szSphereBaseTex, GENERIC_READ, 
                                    FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            return E_FAIL;
        }

        // Get the size of the file
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0xFFFFFFFF) {
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Allocate a buffer for the file data
        pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (!pData) {
            CloseHandle(hFile);
            return E_OUTOFMEMORY;
        }                

        // Read the file into the buffer
        if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
            || dwSize != dwRead)
        {
            HeapFree(GetProcessHeap(), 0, pData);
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Close the file
        CloseHandle(hFile);

        hr = D3DXCreateTextureFromFileInMemory(pDevice, pData, dwSize, &m_pd3dtBase);

        HeapFree(GetProcessHeap(), 0, pData);
#endif

        if (FAILED(hr)) {
            return hr;
        }
    }

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

	m_dontDraw = FALSE;
	return S_OK;
}

//------------------------------------------------------------------------------
//	CInvertedBall::SetPosition
//------------------------------------------------------------------------------
void 
CInvertedBall::SetPosition(
						   IN const XGVECTOR3& position
						   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetRadius
//------------------------------------------------------------------------------
float 
CInvertedBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Render
//------------------------------------------------------------------------------
void
CInvertedBall::Render(
					  IN IDirect3DDevice8*	pDevice,
                      IN UINT               uPass,
					  IN BOOL				bDrawWireframe
					  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -		IDirect3DDevice8
	IN uPass -			Render Pass
	IN bDrawWireframe -	TRUE to render a wireframe shell

Return Value:

	None

--*/
{
	if(m_dontDraw)
		return;

	// Vertex shader type
	pDevice->SetVertexShader(XYZ_NORMAL_TEX);

	// Set the translation
	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

	// Enable texture
    pDevice->SetTexture(0, m_pd3dtBase);

	// Set the material
    if (uPass) {
    	pDevice->SetMaterial(&g_material2);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    }
    else {
    	pDevice->SetMaterial(&g_material);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    }

    pDevice->SetRenderState(D3DRS_WRAP0, D3DWRAP_U);

	// Set the vertex buffer stream source
	pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	// Make sure it draws solid
	pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	// Draw the object
	pDevice->SetIndices(m_pIB, 0);
	pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
								  m_numTriangles);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_WRAP0, 0);

	// Disable texture
    pDevice->SetTexture(0, NULL);

	if(bDrawWireframe)
	{
		// Draw backfacing wireframe
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

		// Draw the object
		pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
									  m_numTriangles);

		// Restore the modes
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	}
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumTris
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Release
//------------------------------------------------------------------------------
void
CInvertedBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\input.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.cpp

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "media.h"
#include "scene.h"
#include "input.h"
#include "helpers.h"

using namespace Media4;

extern CScene g_scene;


namespace Media4 {

#define STICK_DEAD_ZONE     7000
#define STICK_SCALE_FACTOR  16000.0f

HANDLE hDuke[XGetPortCount()];

static const DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };

#define MAXPORTS NUMELEMS(XIDMasks)

/* uncomment if we add support for sub devices (such as mus)
static const DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };
*/

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
static void HandleInput(unsigned port, XINPUT_STATE *state);


#define HOLDTIME 300  //.3 seconds
#define REPEATTIME 30 //once per frame, at 30 FPS
#define UP         0
#define HOLDING    1
#define DOWN       2


void CheckUserInput(void)
    {
    // check for device insertions and removals
    DWORD addDuke, removeDuke;
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    InputDukeInsertions(addDuke, removeDuke);

    // check for user input
    XINPUT_STATE state;
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port] == NULL) continue;

        XInputGetState(hDuke[port], &state);
        HandleInput(port, &state);
        }
    }

void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & XIDMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & XIDMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            }
        }
    }

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
void HandleInput(unsigned port, XINPUT_STATE *state)
    {
    //State of D-Pad
    static DWORD dwRightState[MAXPORTS]={UP};
    static DWORD dwLeftState[MAXPORTS]={UP};
    static DWORD dwStartTimeRight[MAXPORTS] = {0};
    static DWORD dwStartTimeLeft[MAXPORTS] = {0}; 

    //Needed to keep track not only of positions, but what has changed.    
    static XINPUT_STATE stateOld[MAXPORTS];
    static bFirstIteration[MAXPORTS] = {TRUE};

    BOOL bChange = FALSE;
    DWORD dwTemp = 0;


    //If the first time, make it appear that no changes were made.
    if (bFirstIteration[port])
    {
        stateOld[port] = *state;
        bFirstIteration[port] = FALSE;
    }

    //Log 
    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP))
    {
        if (--g_TestParams.dwDMSelected == 0xFFFFFFFF)
            g_TestParams.dwDMSelected = NUM_SELECTIONS - 1;
    }

    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN))
    {
        if (++g_TestParams.dwDMSelected == NUM_SELECTIONS)
            g_TestParams.dwDMSelected = 0;
    }

	//
	// set text state based on button state and previous scene text state
	//
	if ( state->Gamepad.wButtons & XINPUT_GAMEPAD_START && ! ( stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_START ) )
	{
		g_scene.SetDrawText( ! g_scene.DrawText() );
	}

    // ZOOM: trigger
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f);
        }
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / -255.0f);
        }

    // Rotate X Y: left thumb stick
    if(!(state->Gamepad.sThumbLX > -STICK_DEAD_ZONE && state->Gamepad.sThumbLX < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateY(state->Gamepad.sThumbLX/STICK_SCALE_FACTOR);
        }
    if(!(state->Gamepad.sThumbLY > -STICK_DEAD_ZONE && state->Gamepad.sThumbLY < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateX(state->Gamepad.sThumbLY/STICK_SCALE_FACTOR);
        }


	// process DMUSIC input only if text is displayed    
    if ( g_scene.DrawText() )
    {
        //Handle right side of the D-Pad
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
        {
            bChange = FALSE;
            if (UP == dwRightState[port])
            {
                bChange = TRUE;
                dwRightState[port] = HOLDING;
                dwStartTimeRight[port] = timeGetTime();
            }
            else if (HOLDING == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > HOLDTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                    dwRightState[port] = DOWN;
                }
            }
            else if (DOWN == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > REPEATTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                }
            }

            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			    case 0:
				    g_TestParams.dwNumBalls++;
				    if ( g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls )
					    g_TestParams.dwNumBalls = g_TestParams.dwMaxBalls;

				    g_scene.AddBall();
				    break;

			    case 1:
				    g_TestParams.dwNumLights++;
				    if ( g_TestParams.dwNumLights > g_TestParams.dwMaxLights )
					    g_TestParams.dwNumLights = g_TestParams.dwMaxLights;

				    g_scene.AddLight();
				    break;

			    case 2:
				    g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				    break;

			    case 3:
				    g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				    break;

			    case 4:
				    g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				    break;

			    case 5:
				    g_TestParams.dwSparksPerCollision++;
				    break;

                case 6:
                    break;
                case 7:
                    g_TestParams.lDMMasterVolume += 100;
                    if (g_TestParams.lDMMasterVolume > 0)
                        g_TestParams.lDMMasterVolume = 0;
                    break;
                case 8: 
                    g_TestParams.fDMMasterTempo += 0.1f;
                    if (g_TestParams.fDMMasterTempo > 100.f)
                        g_TestParams.fDMMasterTempo = 100.f;
                    break;
                case 9: 
                    if (g_TestParams.lDMMasterTranspose < 127)
                        g_TestParams.lDMMasterTranspose += 1;
                    break;
                case 10: 
                    break;
                case 11:
                    g_TestParams.lDSVolume += 100;

				    if ( g_TestParams.lDSVolume > 0 )
					    g_TestParams.lDSVolume = 0;

                    break;

                case 12:
                    g_TestParams.dwDSFreq += 100;

				    if ( g_TestParams.dwDSFreq > 96000 )
					    g_TestParams.dwDSFreq = 96000;

                    break;
                }
            }
        }
        else
        {
            dwRightState[port] = UP;
        }

        //Handle left side of the D-Pad.
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
        {
            bChange = FALSE;
            if (UP == dwLeftState[port])
            {
                bChange = TRUE;
                dwLeftState[port] = HOLDING;
                dwStartTimeLeft[port] = timeGetTime();
            }
            else if (HOLDING == dwLeftState[port])
            {
                DWORD dwTemp = timeGetTime();

                if (timeGetTime() - dwStartTimeLeft[port] > HOLDTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                    dwLeftState[port] = DOWN;
                }
            }
            else if (DOWN == dwLeftState[port])
            {
                if (timeGetTime() - dwStartTimeLeft[port] > REPEATTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                }
            }
 
            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			case 0:
				g_TestParams.dwNumBalls--;
				if ( g_TestParams.dwNumBalls == 0xFFFFFFFF )
					g_TestParams.dwNumBalls = 0;

				g_scene.RemoveBall();
				break;

			case 1:
				g_TestParams.dwNumLights--;
				if ( g_TestParams.dwNumLights == 0xFFFFFFFF )
					g_TestParams.dwNumLights = 0;

				g_scene.RemoveLight();
				break;

			case 2:
				g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				break;

			case 3:
				g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				break;

			case 4:
				g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				break;

			case 5:
				g_TestParams.dwSparksPerCollision--;
				if ( g_TestParams.dwSparksPerCollision == 0xFFFFFFFF )
					g_TestParams.dwSparksPerCollision = 0;
				break;

            case 6:
                break;
            case 7:
                g_TestParams.lDMMasterVolume -= 100;
                if (g_TestParams.lDMMasterVolume < -10000)
                    g_TestParams.lDMMasterVolume = -10000;
                break;
            case 8: 
                g_TestParams.fDMMasterTempo -= 0.1f;
                if (g_TestParams.fDMMasterTempo < 0.f)
                    g_TestParams.fDMMasterTempo = 0.f;
                break;
            case 9: 
                if (g_TestParams.lDMMasterTranspose > -128)
                    g_TestParams.lDMMasterTranspose -= 1;
                break;
            case 10: 
                break;

            case 11:
                g_TestParams.lDSVolume -= 100;

				if ( g_TestParams.lDSVolume < -10000 )
					g_TestParams.lDSVolume = -10000;

                break;

            case 12:
                g_TestParams.dwDSFreq -= 100;

				if ( g_TestParams.dwDSFreq < DSBFREQUENCY_MIN || g_TestParams.dwDSFreq > 96000 )
					g_TestParams.dwDSFreq = DSBFREQUENCY_MIN;

                break;
                }
            }
        }
        else
        {
            dwLeftState[port] = UP;
        }
    }


    //Store the last frame's joystick state.
    stateOld[port] = *state;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\spark.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Spark.cpp

Abstract:

	sparks

Author:

	Jason Gould (jgould) 19-May-2001

Revision History:

	19-May-2001	jgould
		Initial Version

--*/

#ifndef __SPARK_H__
#define __SPARK_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace Media4 {

class CSpark
{
public:
	struct Vertex {
		XGVECTOR3 location;
		float age;
	};


private:
	Vertex* m_pVertex;
	XGVECTOR3 *m_pDirection;
	float *m_pSpeed;

	static D3DVertexBuffer* m_pVB;
	UINT m_Next;
	UINT m_First;
	void RemoveSpark();
    D3DLIGHT8               m_light; //use GetLight to set this up
	UINT m_LastLight;

public:
	CSpark() {}
	~CSpark() { Release(); }

	HRESULT Create (IN D3DDevice* pDevice);
	void Release();
	void AddSpark(XGVECTOR3& loc);
	void Update(IN float amount);
	void Render(D3DDevice* pDevice, XGMATRIX* pmViewProj);
	int GetNumSparks();
    D3DLIGHT8* GetLight(int iSpark);
};
}


#endif //__SPARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\spark.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

Ball.cpp

Abstract:

spark (from ball collisions

Author:

Jason Gould (jgould) 18-May-2001

Revision History:

18-May-2001 jgould
	Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "spark.h"
#include "helpers.h"

using namespace Media4;

namespace Media4 {

//D3DFVF_XYZRHW
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f
#define SAFE_RELEASE(x) do { if (x != NULL) { x->Release(); x = NULL; } } while(0)
#define FRAND(Min, Max) ((float)rand() / (float)RAND_MAX * (Max - Min) + Min)
#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

D3DVertexBuffer* CSpark::m_pVB = NULL;

HRESULT CSpark::Create (IN D3DDevice* pDevice) {
	m_Next = 0;
	m_First = 0;
	HRESULT hr;

	if(m_pVB == NULL) {
		hr = pDevice->CreateVertexBuffer(g_TestParams.dwMaxSparks * 4*sizeof(float), 0, 0, D3DPOOL_DEFAULT, &m_pVB);
	}
	if(!FAILED(hr)) {
		//This gets us our pointer for adding new sparks. Note: nothing keeps track of what is locked...
		hr = m_pVB->Lock(0,0,(BYTE**)&m_pVertex,D3DLOCK_NOOVERWRITE); 
	}
	if(!FAILED(hr)) {
		m_pDirection = new XGVECTOR3[g_TestParams.dwMaxSparks];
		m_pSpeed = new float[g_TestParams.dwMaxSparks];
		if(!m_pDirection || !m_pSpeed) hr = E_OUTOFMEMORY;
	}
	if(FAILED(hr)) {
		Release();
	}

	return hr;
}

void CSpark::Release() {
	SAFE_RELEASE(m_pVB);
	delete[] m_pDirection;
	delete[] m_pSpeed;
}

void CSpark::AddSpark(XGVECTOR3& loc) {
	if(m_Next + 1 == m_First || m_Next + 1 - g_TestParams.dwMaxSparks == m_First) {
		return;
	}
	

	m_pVertex[m_Next].age = 0;
	m_pVertex[m_Next].location = loc;
	m_pDirection[m_Next].x = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].y = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].z = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	XGVec3Normalize(&m_pDirection[m_Next], &m_pDirection[m_Next]);
	m_pSpeed[m_Next] = FRAND(.001f, .01f);//g_TestParams.fMinSpeed, g_TestParams.fMaxSpeed);
	//(float)rand() / (float)RAND_MAX * (g_TestParams.fMaxSpeed - g_TestParams.fMinSpeed) + g_TestParams.fMinSpeed;
	m_Next = (m_Next + 1) % g_TestParams.dwMaxSparks;
}

//all sparks live the same length of time, so the first one created is the first one dead. 
//Just incriment "first", to point to the next living spark.
void CSpark::RemoveSpark() {
	m_First = (m_First + 1) % g_TestParams.dwMaxSparks;
}

void CSpark::Update(IN float amount) {
	UINT i;
	amount *= 200; //sparks will live about half a second, with maxage==100
	for(i = m_First; i != m_Next; i = (i + 1) % g_TestParams.dwMaxSparks) {
		m_pVertex[i].age += amount;
		if(m_pVertex[i].age > g_TestParams.dwSparkMaxAge) {
			RemoveSpark();
			continue;
		} 

		//no collision detection... they don't live that long anyway...
		m_pVertex[i].location += m_pDirection[i] * m_pSpeed[i] * amount;
	}
}

void CSpark::Render(
	D3DDevice* pDevice,
	XGMATRIX*  pmViewProj
	) 
{
	if(m_First == m_Next) {
		return;
	}
	XGMATRIX id;
   	pDevice->SetTransform(D3DTS_WORLD, XGMatrixIdentity(&id));
	XGMATRIX mtViewProj;
    XGMatrixTranspose(&mtViewProj, pmViewProj);

    pDevice->SetVertexShaderConstant(0, &mtViewProj, 4);

//    pDevice->SetVertexShader(D3DFVF_XYZ);


    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, rand()+ (rand() << 16));

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

	float m_radius = 0.04f;
    pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

//        pDevice->SetTexture(3, m_pd3dtLight);
	
	pDevice->SetStreamSource(0,m_pVB, sizeof(Vertex));

	if(m_First < m_Next) {
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, m_Next-m_First);
	} else {
		if(m_Next) pDevice->DrawPrimitive(D3DPT_POINTLIST, 0, m_Next);
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, g_TestParams.dwMaxSparks - m_First);
	}
//        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3)+sizeof(float));

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

}

int CSpark::GetNumSparks()
{
	int i = m_First>m_Next ? m_Next-m_First +g_TestParams.dwMaxSparks: m_Next-m_First;
	return i;
}


D3DLIGHT8* CSpark::GetLight(int iSpark)
{
	if(m_LastLight == iSpark) {
		return &m_light;
	}
	
	m_LastLight = iSpark;
	int index = (iSpark + m_First) % g_TestParams.dwMaxSparks;

	XGVECTOR3 vColor, vSpecular, vOrange (1.0f, 0.25f, 0.0f);

    XGVec3Normalize(&vColor, &(FRAND(0.6f, 1.0f) * vOrange));
    XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));

    memset(&m_light, 0, sizeof(D3DLIGHT8));
    m_light.Type = D3DLIGHT_POINT;
    m_light.Diffuse.r = vColor.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.g = vColor.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.b = vColor.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.a = 1.0f;//FRND(1.0f);
    m_light.Specular.r = vSpecular.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.g = vSpecular.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.b = vSpecular.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.a = 1.0f;
    m_light.Range = 100.0f;
//    m_light.Attenuation0 = 1.0f;
//    m_light.Attenuation1 = 1.0f;
//    m_light.Attenuation2 = 2.0f;
    m_light.Attenuation0 = 0.0f;
    m_light.Attenuation1 = 0.0f;
    m_light.Attenuation2 = 6.4f + (float)rand() / (float)RAND_MAX * 3.2f;

    m_light.Position = m_pVertex[index].location;
	
	return &m_light;

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\netstrm\netstream.h ===
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntos.h>

#ifdef __cplusplus
}
#endif // __cplusplus

#define  NODSOUND
#include <xtl.h>
#include <xdbg.h>
#include <dsoundp.h>

#include <winsockx.h>
#include "netxmo.h"
#include <xdbg.h>

#define NETSTRM_FAILED(Status) ((HRESULT)(Status)<0 && ((HRESULT)(Status)!=E_PENDING))

#define NETSTRM_VERIFY_PACKET_SIZE(xMediaInfo,dwPacketSize) ASSERT(xMediaInfo.dwOutputSize <= dwPacketSize);\
    if (xMediaInfo.dwOutputSize) ASSERT(dwPacketSize%xMediaInfo.dwOutputSize == 0);\
    ASSERT(dwPacketSize >= xMediaInfo.dwMaxLookahead);\

#if DBG


#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_NetStrmDebugLevel;
#define DBG_SPAM(_exp_) {if (g_NetStrmDebugLevel >= DEBUG_LEVEL_SPAM) DbgPrint _exp_;}
#define DBG_INFO(_exp) {if (g_NetStrmDebugLevel >= DEBUG_LEVEL_INFO) DbgPrint _exp;}
#define DBG_ERROR(_exp) {if (g_NetStrmDebugLevel >= DEBUG_LEVEL_ERROR) DbgPrint _exp;}
#define DBG_WARN(_exp) {if (g_NetStrmDebugLevel >= DEBUG_LEVEL_WARNING) DbgPrint _exp;}

#else
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)
#endif


#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

#define PACKET_CNT      10
#define PACKET_SIZE		320

#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

#define TESTPORT        600
#define TESTADDR_LEFT   "157.56.13.36" // left test box
#define TESTADDR_RIGHT   "157.56.13.40" // right test box
#define LOOPADDRESS       "127.0.0.1" // left test box
#define ANYADDRESS        "0.0.0.0" 


// #define TESTADDR        "157.56.10.165" // davidx3


#define BREAK_INTO_DEBUGGER __asm int 3
#define CALLFAILED(_apiname, err) \
        DbgPrint(#_apiname " failed: %d %d\n", err)

typedef struct _mediabuf {

    LIST_ENTRY ListEntry;
	DWORD dwStatus;
	DWORD dwCompletedSize;
    HANDLE hCompletionEvent;
    PUCHAR pBuffer;

} MEDIA_BUFFER_CTX, *PMEDIA_BUFFER_CTX;

#define TESTF_NET_SEND  	0x00000001
#define TESTF_NET_RECV  	0x00000002
#define TESTF_USE_HAWK_OUT	0x00000004
#define TESTF_USE_HAWK_IN	0x00000008
#define TESTF_USE_CODEC 	0x00000010

#define NET_RECV_CONTEXT      0x00000000
#define NET_SEND_CONTEXT      0x00000001

#define INVALID_PORT        0xFFFFFFFF

typedef struct _graphcontext {

    DWORD dwFlags;
	DWORD dwPlayerPort;
	XMediaObject *pSourceXmo;
	XMediaObject *pIntermediateXmo;
	XMediaObject *pSRCXmo;
	XMediaObject *pTargetXmo;

	DWORD	dwMinPacketSize;
	DWORD	dwPacketSize;
    DWORD   dwMaxBufferCount;

	WAVEFORMATEX wfxAudioFormat;

    LIST_ENTRY  AvailableList;
    LIST_ENTRY  SrcPendingList;
    LIST_ENTRY  DstPendingList;

	XMEDIAPACKET DstMediaBuffer;
	PUCHAR TransferBuffer;
    PUCHAR PacketContextPool;

} GRAPH_CONTEXT, *PGRAPH_CONTEXT;


typedef struct _globaldata {

	DWORD dwFlags;
    GRAPH_CONTEXT ContextArray[2];

} NETSTREAM_GLOBAL_DATA, *PNETSTREAM_GLOBAL_DATA;

//
// netstream.cpp
//
VOID
Cleanup();

HRESULT
TransferData(DWORD dwIndex,DWORD dwTimeout);

HRESULT
Init(DWORD dwIndex);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\texture.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	texture.h

Abstract:

	Texture data for test

Author:

	Robert Heitkamp (robheit) 13-Feb-2001

Revision History:

	13-Feb-2001	robheit
		Initial version

--*/

namespace Media4 {

static BYTE g_texture[] = {

	0x42, 0x4D, 0x36, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x27, 0x0F, 0x28, 0x28, 0x2C, 0x19, 0x19, 0x11, 
	0x28, 0x28, 0x11, 0x27, 0x28, 0x2E, 0x1E, 0x1B, 0x29, 0x1D, 0x1B, 0x30, 0x29, 0x20, 0x09, 0x27, 
	0x29, 0x34, 0x27, 0x1B, 0x1F, 0x1F, 0x20, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 0x1C, 
	0x2A, 0x27, 0x23, 0x32, 0x2F, 0x23, 0x25, 0x19, 0x1B, 0x26, 0x1C, 0x1C, 0x25, 0x1A, 0x1B, 0x2B, 
	0x27, 0x23, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x39, 0x32, 0x2F, 0x27, 0x34, 
	0x36, 0x2A, 0x24, 0x1F, 0x2B, 0x25, 0x20, 0x29, 0x25, 0x22, 0x35, 0x31, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x34, 0x2F, 0x27, 0x39, 0x37, 0x2E, 0x3B, 
	0x39, 0x30, 0x38, 0x39, 0x2F, 0x36, 0x2C, 0x2F, 0x36, 0x30, 0x2F, 0x38, 0x38, 0x30, 0x3B, 0x39, 
	0x2E, 0x22, 0x35, 0x3E, 0x18, 0x2A, 0x30, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x13, 0x2A, 0x30, 0x46, 0x38, 0x34, 0x59, 0x50, 0x45, 0x24, 0x27, 0x29, 0x11, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x13, 0x26, 0x25, 0x15, 0x28, 0x29, 0x18, 0x2B, 0x31, 0x1E, 0x1D, 0x1B, 0x19, 0x2C, 
	0x33, 0x12, 0x25, 0x23, 0x14, 0x29, 0x2F, 0x3F, 0x3A, 0x34, 0x52, 0x44, 0x3B, 0x5F, 0x53, 0x45, 
	0x11, 0x08, 0x0B, 0x00, 0x00, 0x00, 0x0D, 0x07, 0x08, 0x1F, 0x24, 0x1F, 0x81, 0x70, 0x62, 0x58, 
	0x51, 0x4A, 0x59, 0x51, 0x48, 0x55, 0x4C, 0x43, 0x4E, 0x46, 0x3F, 0x48, 0x42, 0x36, 0x13, 0x28, 
	0x2F, 0x15, 0x28, 0x2A, 0x12, 0x24, 0x22, 0x15, 0x2E, 0x32, 0x19, 0x29, 0x2E, 0x12, 0x25, 0x23, 
	0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x1D, 
	0x20, 0x20, 0x32, 0x26, 0x1A, 0x30, 0x32, 0x28, 0x2B, 0x26, 0x22, 0x28, 0x1D, 0x1C, 0x2A, 0x20, 
	0x1D, 0x30, 0x24, 0x1A, 0x30, 0x32, 0x27, 0x2A, 0x25, 0x22, 0x2A, 0x23, 0x1D, 0x26, 0x1B, 0x1C, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 0x0E, 0x29, 0x29, 0x29, 0x1B, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x13, 0x27, 0x27, 0x2C, 0x19, 0x19, 
	0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x22, 0x20, 0x20, 0x18, 0x25, 0x25, 0x13, 
	0x27, 0x27, 0x13, 0x27, 0x27, 0x16, 0x25, 0x25, 0x25, 0x24, 0x22, 0x37, 0x35, 0x2C, 0x27, 0x16, 
	0x18, 0x31, 0x28, 0x1D, 0x2A, 0x1D, 0x1B, 0x11, 0x27, 0x27, 0x27, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 
	0x33, 0x30, 0x24, 0x23, 0x16, 0x1A, 0x33, 0x37, 0x2B, 0x28, 0x20, 0x1F, 0x32, 0x2E, 0x22, 0x29, 
	0x23, 0x1F, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x23, 0x13, 0x18, 0x30, 0x32, 0x27, 0x29, 0x22, 
	0x1E, 0x31, 0x32, 0x28, 0x29, 0x30, 0x2C, 0x2F, 0x29, 0x1D, 0x3A, 0x30, 0x33, 0x2C, 0x2F, 0x24, 
	0x37, 0x31, 0x2F, 0x3A, 0x32, 0x32, 0x38, 0x30, 0x2A, 0x15, 0x2E, 0x38, 0x14, 0x29, 0x30, 0x1C, 
	0x2B, 0x30, 0x34, 0x37, 0x32, 0x46, 0x38, 0x34, 0x49, 0x40, 0x37, 0x35, 0x37, 0x2E, 0x30, 0x31, 
	0x30, 0x12, 0x27, 0x29, 0x16, 0x29, 0x2B, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x14, 0x2A, 0x32, 0x2E, 0x2A, 0x23, 0x52, 0x47, 0x46, 0x24, 0x2A, 0x27, 0x11, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x15, 0x28, 0x2A, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x32, 0x3B, 0x13, 0x26, 
	0x26, 0x1F, 0x32, 0x3D, 0x1E, 0x2F, 0x39, 0x19, 0x3F, 0x44, 0x1A, 0x3D, 0x43, 0x1C, 0x38, 0x42, 
	0x04, 0x0D, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x07, 0x07, 0x3A, 0x2F, 0x2A, 0x82, 0x73, 0x62, 0x62, 
	0x5A, 0x4A, 0x62, 0x5D, 0x59, 0x60, 0x5A, 0x55, 0x5F, 0x57, 0x4C, 0x5C, 0x50, 0x45, 0x0F, 0x25, 
	0x2C, 0x19, 0x2A, 0x2F, 0x1F, 0x3E, 0x49, 0x1E, 0x2F, 0x38, 0x1D, 0x3C, 0x46, 0x1B, 0x30, 0x37, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x15, 0x28, 0x2A, 0x15, 0x28, 
	0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x18, 0x2B, 0x2F, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 
	0x2B, 0x33, 0x2F, 0x2A, 0x23, 0x31, 0x31, 0x27, 0x25, 0x25, 0x26, 0x33, 0x24, 0x18, 0x16, 0x31, 
	0x3A, 0x13, 0x22, 0x22, 0x3D, 0x32, 0x31, 0x31, 0x31, 0x24, 0x3C, 0x32, 0x34, 0x27, 0x20, 0x1E, 
	0x25, 0x1A, 0x1B, 0x33, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x0F, 0x28, 0x28, 0x2B, 0x1A, 0x1A, 0x29, 0x1B, 0x1B, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2C, 0x19, 0x19, 0x0E, 0x29, 0x29, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x13, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x18, 0x24, 0x25, 0x1C, 0x1E, 0x1E, 0x23, 0x28, 
	0x30, 0x33, 0x27, 0x1A, 0x2C, 0x26, 0x1E, 0x2C, 0x25, 0x20, 0x31, 0x34, 0x28, 0x27, 0x1E, 0x1E, 
	0x2A, 0x25, 0x20, 0x28, 0x20, 0x1F, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x30, 0x32, 0x28, 0x35, 
	0x31, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x31, 0x32, 0x28, 0x2F, 0x2F, 0x26, 0x30, 0x29, 
	0x1F, 0x2F, 0x28, 0x1F, 0x35, 0x3B, 0x35, 0x33, 0x3B, 0x34, 0x38, 0x2F, 0x30, 0x37, 0x2F, 0x2F, 
	0x38, 0x3A, 0x30, 0x37, 0x37, 0x2E, 0x23, 0x2C, 0x2A, 0x11, 0x25, 0x25, 0x13, 0x26, 0x26, 0x11, 
	0x24, 0x23, 0x13, 0x29, 0x31, 0x33, 0x37, 0x31, 0x4E, 0x43, 0x39, 0x4F, 0x43, 0x39, 0x33, 0x36, 
	0x32, 0x0E, 0x24, 0x24, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x19, 0x2B, 0x30, 0x11, 0x25, 0x24, 
	0x1B, 0x2A, 0x2A, 0x44, 0x39, 0x32, 0x53, 0x45, 0x42, 0x27, 0x36, 0x3A, 0x0E, 0x25, 0x25, 0x13, 
	0x26, 0x26, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3B, 0x1B, 0x30, 
	0x37, 0x0F, 0x23, 0x1F, 0x18, 0x2A, 0x2E, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x37, 0x19, 0x30, 0x34, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x20, 0x1F, 0x78, 0x6B, 0x5C, 0x51, 
	0x49, 0x3E, 0x68, 0x61, 0x56, 0x66, 0x67, 0x62, 0x6A, 0x60, 0x50, 0x6E, 0x62, 0x54, 0x14, 0x32, 
	0x33, 0x11, 0x23, 0x20, 0x18, 0x29, 0x2E, 0x14, 0x26, 0x25, 0x1D, 0x32, 0x3B, 0x1E, 0x31, 0x3A, 
	0x14, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1B, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 
	0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x0C, 0x19, 0x19, 0x14, 0x27, 0x27, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x1C, 0x31, 0x3D, 0x36, 
	0x33, 0x26, 0x34, 0x30, 0x2B, 0x34, 0x31, 0x28, 0x19, 0x33, 0x3F, 0x1C, 0x1D, 0x1C, 0x1E, 0x33, 
	0x3E, 0x11, 0x26, 0x25, 0x1B, 0x1E, 0x1E, 0x14, 0x2F, 0x39, 0x3B, 0x31, 0x2E, 0x2A, 0x27, 0x22, 
	0x25, 0x18, 0x1A, 0x2A, 0x33, 0x2F, 0x31, 0x33, 0x27, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x23, 0x1F, 0x1F, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x34, 0x38, 
	0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x12, 0x27, 0x27, 0x0F, 0x27, 
	0x27, 0x25, 0x1F, 0x1C, 0x3D, 0x33, 0x35, 0x2E, 0x2A, 0x20, 0x3B, 0x31, 0x33, 0x2B, 0x2A, 0x23, 
	0x35, 0x31, 0x2C, 0x31, 0x33, 0x28, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x2F, 0x31, 0x26, 0x3B, 
	0x30, 0x33, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x32, 0x38, 0x32, 0x35, 0x3B, 
	0x36, 0x2E, 0x2F, 0x25, 0x30, 0x2E, 0x27, 0x36, 0x32, 0x2C, 0x39, 0x2F, 0x31, 0x2B, 0x2F, 0x23, 
	0x39, 0x31, 0x31, 0x37, 0x35, 0x29, 0x14, 0x2A, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x20, 
	0x33, 0x3F, 0x12, 0x25, 0x23, 0x0F, 0x28, 0x2F, 0x44, 0x3D, 0x33, 0x4E, 0x42, 0x38, 0x2C, 0x37, 
	0x35, 0x15, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3C, 0x14, 0x28, 0x2C, 
	0x2C, 0x42, 0x46, 0x5A, 0x4C, 0x40, 0x36, 0x49, 0x4B, 0x28, 0x3A, 0x3A, 0x2B, 0x1B, 0x18, 0x0F, 
	0x26, 0x26, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 
	0x45, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x37, 0x1B, 0x32, 0x3B, 0x1A, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x1A, 0x13, 0x11, 0x4E, 0x50, 0x50, 0x4B, 
	0x3F, 0x39, 0x57, 0x4D, 0x42, 0x7A, 0x6B, 0x5C, 0x74, 0x6B, 0x5A, 0x75, 0x66, 0x5A, 0x23, 0x25, 
	0x25, 0x15, 0x31, 0x38, 0x1E, 0x30, 0x39, 0x14, 0x32, 0x38, 0x1E, 0x2F, 0x38, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x15, 0x2C, 0x31, 0x15, 0x2C, 0x30, 0x13, 0x26, 0x25, 0x1E, 
	0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 0x15, 0x28, 
	0x29, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1C, 0x2F, 0x37, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x13, 0x29, 0x2F, 0x36, 
	0x32, 0x29, 0x3A, 0x33, 0x32, 0x2E, 0x20, 0x1D, 0x16, 0x2C, 0x32, 0x11, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x11, 0x27, 0x27, 0x2F, 0x18, 0x18, 0x0F, 0x28, 0x29, 0x31, 0x32, 0x30, 0x2C, 0x2B, 0x23, 
	0x2B, 0x25, 0x20, 0x29, 0x24, 0x1F, 0x37, 0x33, 0x2F, 0x25, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 
	0x1B, 0x27, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x2B, 0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x0D, 0x26, 0x27, 0x3C, 0x32, 0x2A, 0x0E, 0x2A, 0x33, 0x3C, 0x31, 0x2F, 0x2F, 0x31, 0x26, 
	0x3A, 0x30, 0x32, 0x32, 0x32, 0x29, 0x24, 0x16, 0x19, 0x31, 0x33, 0x28, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x34, 0x35, 
	0x2B, 0x37, 0x2F, 0x2F, 0x39, 0x36, 0x31, 0x38, 0x2F, 0x30, 0x35, 0x2F, 0x2C, 0x33, 0x31, 0x2A, 
	0x37, 0x31, 0x2C, 0x28, 0x33, 0x35, 0x16, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2B, 0x12, 0x25, 0x24, 0x15, 0x2B, 0x35, 0x45, 0x3D, 0x33, 0x4C, 0x40, 0x37, 0x3F, 0x44, 
	0x45, 0x15, 0x2A, 0x31, 0x1C, 0x30, 0x3B, 0x0F, 0x23, 0x20, 0x16, 0x2A, 0x2F, 0x1A, 0x2B, 0x30, 
	0x4A, 0x3E, 0x33, 0x5A, 0x52, 0x4A, 0x59, 0x4F, 0x45, 0x52, 0x46, 0x42, 0x3C, 0x38, 0x30, 0x0E, 
	0x25, 0x29, 0x12, 0x25, 0x23, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 0x36, 0x1D, 0x2C, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1E, 0x3B, 0x40, 0x11, 0x3A, 0x43, 0x1B, 0x37, 0x3E, 
	0x03, 0x06, 0x04, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x20, 0x14, 0x0F, 0x45, 0x4F, 0x50, 0x3E, 
	0x3E, 0x37, 0x2A, 0x2A, 0x28, 0x2B, 0x3D, 0x43, 0x58, 0x55, 0x50, 0x3F, 0x48, 0x45, 0x14, 0x30, 
	0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x11, 0x3A, 0x43, 0x1C, 0x32, 0x3B, 0x11, 0x24, 0x20, 
	0x1F, 0x32, 0x3C, 0x1E, 0x30, 0x38, 0x18, 0x35, 0x3D, 0x12, 0x3C, 0x47, 0x1E, 0x2F, 0x38, 0x1D, 
	0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x12, 0x25, 0x23, 0x18, 0x2A, 
	0x2F, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x30, 0x39, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3C, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x3A, 0x20, 0x30, 0x36, 0x3B, 
	0x3B, 0x30, 0x37, 0x36, 0x30, 0x2F, 0x24, 0x23, 0x0E, 0x25, 0x24, 0x16, 0x29, 0x2C, 0x12, 0x25, 
	0x24, 0x14, 0x27, 0x27, 0x0F, 0x26, 0x25, 0x1E, 0x32, 0x3D, 0x16, 0x27, 0x23, 0x39, 0x32, 0x2E, 
	0x23, 0x31, 0x33, 0x2E, 0x2A, 0x23, 0x33, 0x31, 0x2A, 0x29, 0x25, 0x20, 0x32, 0x2B, 0x1F, 0x26, 
	0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 
	0x1C, 0x23, 0x1F, 0x1F, 0x0F, 0x28, 0x28, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x12, 0x27, 0x26, 0x25, 0x25, 0x2B, 0x0F, 0x26, 0x25, 0x1F, 0x26, 0x23, 0x22, 0x22, 0x1F, 
	0x3A, 0x31, 0x32, 0x34, 0x31, 0x2B, 0x29, 0x25, 0x20, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x22, 0x1E, 0x2F, 0x2F, 
	0x26, 0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x3A, 0x30, 
	0x3A, 0x37, 0x31, 0x27, 0x26, 0x1F, 0x14, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2B, 0x31, 0x27, 0x3B, 0x42, 0x43, 0x3B, 0x32, 0x4C, 0x42, 0x39, 0x50, 0x42, 
	0x37, 0x1A, 0x32, 0x3C, 0x33, 0x39, 0x35, 0x1E, 0x34, 0x3E, 0x0F, 0x28, 0x33, 0x4D, 0x42, 0x39, 
	0x5F, 0x57, 0x4F, 0x5F, 0x56, 0x4D, 0x54, 0x52, 0x4D, 0x52, 0x48, 0x3D, 0x4E, 0x4F, 0x4C, 0x2C, 
	0x37, 0x3A, 0x0F, 0x23, 0x22, 0x1E, 0x36, 0x3F, 0x19, 0x30, 0x38, 0x22, 0x46, 0x49, 0x1D, 0x3E, 
	0x42, 0x1B, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 0x30, 0x18, 0x35, 0x3E, 0x1B, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x13, 0x1D, 0x24, 0x34, 0x5C, 0x5F, 0x46, 
	0x39, 0x34, 0x14, 0x2C, 0x38, 0x19, 0x2F, 0x38, 0x24, 0x3B, 0x3F, 0x18, 0x2E, 0x38, 0x19, 0x31, 
	0x39, 0x20, 0x34, 0x3B, 0x30, 0x2B, 0x27, 0x12, 0x39, 0x43, 0x16, 0x37, 0x40, 0x12, 0x24, 0x20, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 
	0x3A, 0x18, 0x29, 0x2C, 0x18, 0x29, 0x2E, 0x1D, 0x3E, 0x45, 0x1B, 0x2B, 0x33, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x11, 0x24, 0x20, 0x1B, 0x2F, 0x37, 0x1E, 0x23, 0x1D, 0x3C, 
	0x31, 0x30, 0x31, 0x23, 0x14, 0x32, 0x33, 0x30, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x20, 0x33, 
	0x3E, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x0E, 0x25, 0x26, 0x33, 0x24, 0x16, 
	0x2A, 0x31, 0x2E, 0x30, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x25, 
	0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 
	0x1C, 0x25, 0x1E, 0x1E, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x1F, 0x26, 0x23, 
	0x3B, 0x31, 0x32, 0x36, 0x30, 0x2E, 0x2F, 0x31, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 
	0x30, 0x2A, 0x2E, 0x30, 0x25, 0x36, 0x30, 0x2E, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x36, 0x38, 
	0x2E, 0x36, 0x32, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 
	0x3C, 0x3A, 0x2F, 0x1E, 0x2E, 0x2F, 0x14, 0x27, 0x29, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x13, 
	0x26, 0x25, 0x11, 0x25, 0x24, 0x1A, 0x29, 0x2E, 0x4B, 0x40, 0x37, 0x38, 0x38, 0x30, 0x4B, 0x40, 
	0x37, 0x36, 0x39, 0x30, 0x42, 0x3B, 0x31, 0x50, 0x43, 0x37, 0x38, 0x37, 0x2B, 0x57, 0x4D, 0x40, 
	0x67, 0x62, 0x54, 0x60, 0x5E, 0x5E, 0x61, 0x58, 0x4D, 0x53, 0x4B, 0x42, 0x66, 0x5B, 0x51, 0x47, 
	0x52, 0x54, 0x07, 0x19, 0x18, 0x18, 0x36, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x40, 0x18, 0x33, 
	0x3D, 0x11, 0x39, 0x42, 0x1E, 0x38, 0x3E, 0x1B, 0x34, 0x3C, 0x1E, 0x2C, 0x36, 0x1A, 0x31, 0x35, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0E, 0x1E, 0x20, 0x33, 0x4E, 0x51, 0x59, 
	0x45, 0x3A, 0x26, 0x39, 0x3D, 0x1B, 0x2C, 0x36, 0x1B, 0x40, 0x44, 0x1C, 0x2C, 0x35, 0x20, 0x39, 
	0x40, 0x2A, 0x40, 0x3E, 0x51, 0x40, 0x35, 0x1C, 0x3B, 0x44, 0x0F, 0x38, 0x42, 0x1C, 0x2B, 0x32, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x1B, 0x32, 
	0x3B, 0x15, 0x32, 0x38, 0x14, 0x25, 0x25, 0x1D, 0x3B, 0x42, 0x1D, 0x35, 0x3E, 0x18, 0x29, 0x2E, 
	0x19, 0x2B, 0x30, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x1D, 0x32, 0x3C, 0x13, 
	0x29, 0x2E, 0x11, 0x28, 0x2A, 0x15, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x1A, 0x2C, 
	0x32, 0x13, 0x26, 0x25, 0x15, 0x28, 0x2A, 0x1F, 0x32, 0x3D, 0x0F, 0x24, 0x24, 0x2F, 0x32, 0x2C, 
	0x2F, 0x2C, 0x20, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x27, 
	0x1D, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x23, 0x1F, 
	0x1F, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x26, 0x26, 
	0x38, 0x32, 0x2B, 0x39, 0x30, 0x32, 0x30, 0x30, 0x27, 0x34, 0x30, 0x2B, 0x2E, 0x2F, 0x25, 0x2E, 
	0x2F, 0x25, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x35, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 0x39, 0x32, 
	0x31, 0x38, 0x2E, 0x30, 0x38, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x38, 0x31, 0x30, 0x39, 0x39, 0x2F, 
	0x2A, 0x34, 0x37, 0x0D, 0x23, 0x22, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x14, 0x27, 0x27, 0x20, 
	0x32, 0x3C, 0x12, 0x26, 0x27, 0x2A, 0x34, 0x35, 0x4F, 0x43, 0x39, 0x43, 0x3C, 0x34, 0x2E, 0x32, 
	0x2C, 0x11, 0x27, 0x2E, 0x1D, 0x2C, 0x30, 0x24, 0x2C, 0x2C, 0x24, 0x2E, 0x2F, 0x2E, 0x31, 0x2E, 
	0x70, 0x5E, 0x4D, 0x74, 0x6D, 0x5C, 0x66, 0x5D, 0x50, 0x5A, 0x52, 0x4B, 0x65, 0x61, 0x5D, 0x71, 
	0x63, 0x53, 0x15, 0x24, 0x24, 0x16, 0x33, 0x3D, 0x1D, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x1F, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3F, 0x43, 0x19, 0x34, 0x35, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x2A, 0x53, 0x5B, 0x23, 
	0x3A, 0x3B, 0x1A, 0x2B, 0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x16, 0x31, 0x3A, 0x32, 0x37, 
	0x33, 0x3F, 0x39, 0x2E, 0x3D, 0x3A, 0x2F, 0x2A, 0x2A, 0x2C, 0x1C, 0x44, 0x44, 0x1D, 0x2F, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1E, 0x30, 0x38, 0x18, 0x34, 
	0x3D, 0x14, 0x42, 0x4A, 0x1E, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x15, 0x28, 0x2A, 0x1A, 0x31, 0x3E, 
	0x38, 0x31, 0x2B, 0x2E, 0x29, 0x1E, 0x35, 0x2F, 0x2C, 0x2F, 0x2F, 0x26, 0x35, 0x35, 0x2C, 0x33, 
	0x2C, 0x25, 0x25, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x2A, 0x23, 0x20, 0x25, 0x1D, 
	0x1D, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 
	0x25, 0x22, 0x1F, 0x3A, 0x2F, 0x2C, 0x38, 0x31, 0x2F, 0x39, 0x2F, 0x31, 0x36, 0x32, 0x2E, 0x36, 
	0x37, 0x2E, 0x3A, 0x3A, 0x31, 0x36, 0x38, 0x2E, 0x39, 0x2E, 0x31, 0x39, 0x3B, 0x31, 0x38, 0x2E, 
	0x30, 0x39, 0x34, 0x2E, 0x2F, 0x44, 0x43, 0x39, 0x34, 0x2C, 0x38, 0x39, 0x30, 0x39, 0x38, 0x2F, 
	0x33, 0x34, 0x2E, 0x16, 0x2A, 0x31, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 0x1C, 0x34, 0x3E, 0x18, 
	0x36, 0x3F, 0x15, 0x2F, 0x36, 0x31, 0x34, 0x2F, 0x4D, 0x42, 0x39, 0x4A, 0x3E, 0x34, 0x24, 0x38, 
	0x3E, 0x1B, 0x34, 0x3F, 0x13, 0x24, 0x24, 0x1D, 0x38, 0x40, 0x18, 0x2B, 0x34, 0x1A, 0x29, 0x29, 
	0x3F, 0x42, 0x3E, 0x81, 0x72, 0x60, 0x74, 0x68, 0x5B, 0x6D, 0x62, 0x57, 0x69, 0x67, 0x5E, 0x72, 
	0x62, 0x52, 0x12, 0x28, 0x2B, 0x16, 0x33, 0x3C, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 
	0x40, 0x1D, 0x32, 0x3C, 0x1E, 0x3D, 0x40, 0x1E, 0x36, 0x40, 0x1C, 0x3F, 0x3F, 0x24, 0x40, 0x49, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x55, 0x59, 0x22, 
	0x40, 0x4B, 0x1C, 0x3D, 0x3F, 0x1D, 0x3B, 0x42, 0x1B, 0x30, 0x38, 0x1B, 0x35, 0x3E, 0x31, 0x45, 
	0x43, 0x4B, 0x43, 0x43, 0x42, 0x43, 0x43, 0x14, 0x35, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x43, 
	0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x40, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x15, 0x25, 
	0x25, 0x19, 0x37, 0x3F, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x1E, 
	0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x12, 0x28, 0x2A, 
	0x34, 0x2A, 0x24, 0x2E, 0x29, 0x1E, 0x37, 0x38, 0x30, 0x2F, 0x2F, 0x26, 0x38, 0x39, 0x30, 0x35, 
	0x33, 0x2C, 0x27, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x2B, 0x23, 0x1F, 0x0E, 0x28, 
	0x28, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x0F, 0x27, 0x27, 0x1F, 0x26, 0x24, 0x23, 0x20, 0x1E, 0x39, 0x35, 0x30, 0x39, 0x30, 0x31, 0x3A, 
	0x2F, 0x31, 0x25, 0x2E, 0x29, 0x34, 0x2E, 0x2A, 0x2B, 0x2F, 0x23, 0x39, 0x31, 0x31, 0x38, 0x2F, 
	0x30, 0x35, 0x2E, 0x2C, 0x39, 0x2F, 0x2C, 0x32, 0x40, 0x3C, 0x39, 0x31, 0x2C, 0x38, 0x3C, 0x34, 
	0x1E, 0x35, 0x3F, 0x16, 0x29, 0x2C, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x23, 0x15, 0x27, 0x28, 0x18, 
	0x27, 0x2A, 0x14, 0x30, 0x3B, 0x40, 0x44, 0x43, 0x50, 0x42, 0x36, 0x40, 0x43, 0x44, 0x1F, 0x35, 
	0x3D, 0x0F, 0x20, 0x1C, 0x19, 0x35, 0x40, 0x1B, 0x40, 0x43, 0x1B, 0x2E, 0x34, 0x14, 0x27, 0x2B, 
	0x1D, 0x3B, 0x42, 0x66, 0x5D, 0x55, 0x95, 0x81, 0x73, 0x98, 0x83, 0x78, 0x86, 0x79, 0x70, 0x74, 
	0x6D, 0x69, 0x28, 0x38, 0x3D, 0x18, 0x30, 0x3A, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x3F, 0x22, 0x47, 0x48, 0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x40, 0x1C, 0x3B, 0x3E, 0x23, 0x3F, 0x46, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x54, 0x58, 0x22, 
	0x40, 0x4A, 0x1C, 0x3B, 0x3E, 0x1E, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3E, 0x42, 0x19, 0x28, 
	0x33, 0x1C, 0x32, 0x39, 0x37, 0x3F, 0x3A, 0x18, 0x3D, 0x42, 0x1A, 0x2E, 0x37, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x12, 0x22, 
	0x1E, 0x13, 0x3C, 0x47, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x1A, 0x2C, 
	0x33, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 
	0x19, 0x32, 0x3E, 0x37, 0x30, 0x2A, 0x3A, 0x3B, 0x32, 0x28, 0x22, 0x1E, 0x28, 0x23, 0x1F, 0x39, 
	0x36, 0x31, 0x31, 0x33, 0x28, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1D, 0x28, 0x1B, 0x1B, 0x13, 0x2B, 
	0x2F, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x12, 0x27, 0x27, 0x12, 0x26, 0x26, 0x0F, 0x27, 0x27, 0x25, 0x22, 0x1F, 0x30, 0x2B, 0x26, 0x37, 
	0x30, 0x2F, 0x3A, 0x3A, 0x31, 0x38, 0x3A, 0x30, 0x36, 0x2E, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x33, 
	0x30, 0x35, 0x34, 0x2C, 0x38, 0x31, 0x30, 0x39, 0x30, 0x2E, 0x30, 0x3B, 0x39, 0x32, 0x35, 0x2F, 
	0x28, 0x20, 0x1E, 0x1C, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1C, 0x2E, 0x35, 0x16, 
	0x3D, 0x46, 0x2E, 0x39, 0x38, 0x40, 0x39, 0x30, 0x23, 0x34, 0x37, 0x25, 0x3B, 0x3F, 0x1B, 0x3D, 
	0x44, 0x1E, 0x31, 0x3A, 0x18, 0x34, 0x3C, 0x14, 0x35, 0x3E, 0x1E, 0x3A, 0x44, 0x1D, 0x2F, 0x38, 
	0x1A, 0x2C, 0x36, 0x1F, 0x2C, 0x36, 0x4F, 0x4B, 0x42, 0x50, 0x55, 0x57, 0x50, 0x52, 0x4F, 0x28, 
	0x3B, 0x3C, 0x18, 0x29, 0x34, 0x20, 0x45, 0x48, 0x1B, 0x3F, 0x3D, 0x1D, 0x3D, 0x3E, 0x11, 0x35, 
	0x40, 0x1E, 0x3B, 0x3F, 0x1C, 0x40, 0x40, 0x0F, 0x34, 0x3E, 0x20, 0x4A, 0x4D, 0x1F, 0x45, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x64, 0x22, 
	0x40, 0x49, 0x1D, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x1E, 0x3A, 0x40, 0x1C, 0x3D, 0x3F, 0x24, 0x45, 
	0x4D, 0x1B, 0x2E, 0x37, 0x1A, 0x3F, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x36, 
	0x3F, 0x12, 0x3A, 0x43, 0x1F, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1A, 
	0x2B, 0x32, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x28, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x23, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x28, 0x2B, 0x32, 0x29, 0x23, 0x3A, 0x37, 0x31, 0x32, 0x39, 0x36, 0x28, 0x22, 0x1E, 0x2F, 
	0x30, 0x26, 0x2F, 0x29, 0x23, 0x08, 0x29, 0x2A, 0x2B, 0x1D, 0x1A, 0x27, 0x1B, 0x1C, 0x1E, 0x22, 
	0x20, 0x12, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x12, 0x27, 0x27, 
	0x1F, 0x20, 0x1F, 0x15, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x0E, 0x27, 0x27, 0x26, 0x23, 0x20, 0x31, 
	0x2A, 0x25, 0x35, 0x31, 0x29, 0x39, 0x3A, 0x30, 0x39, 0x2E, 0x31, 0x36, 0x38, 0x2E, 0x3A, 0x3A, 
	0x31, 0x3A, 0x39, 0x2F, 0x3A, 0x3A, 0x2F, 0x3C, 0x2F, 0x2C, 0x11, 0x28, 0x2F, 0x18, 0x2C, 0x35, 
	0x1C, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x0D, 0x22, 0x1F, 0x2C, 
	0x34, 0x31, 0x43, 0x4A, 0x4B, 0x47, 0x40, 0x39, 0x16, 0x2C, 0x37, 0x1D, 0x2E, 0x37, 0x16, 0x26, 
	0x28, 0x1E, 0x3B, 0x45, 0x1E, 0x2E, 0x36, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x37, 0x1D, 0x30, 0x37, 0x20, 0x3E, 0x46, 0x0E, 0x3C, 0x3F, 0x1B, 
	0x2B, 0x35, 0x1C, 0x2C, 0x36, 0x1F, 0x44, 0x46, 0x2A, 0x4E, 0x58, 0x20, 0x48, 0x4C, 0x0F, 0x35, 
	0x3E, 0x1C, 0x3D, 0x40, 0x1E, 0x39, 0x40, 0x1D, 0x3C, 0x3F, 0x25, 0x40, 0x45, 0x23, 0x46, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x63, 0x1F, 
	0x3F, 0x49, 0x0F, 0x36, 0x3E, 0x1E, 0x31, 0x3A, 0x1D, 0x37, 0x3C, 0x1D, 0x29, 0x33, 0x1C, 0x4F, 
	0x54, 0x1D, 0x2F, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3D, 0x42, 0x1D, 
	0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x15, 0x2C, 
	0x30, 0x19, 0x35, 0x3E, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x1E, 0x33, 0x3C, 0x1D, 
	0x3C, 0x42, 0x16, 0x28, 0x2B, 0x1E, 0x31, 0x3A, 0x1B, 0x34, 0x3D, 0x1F, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 
	0x11, 0x25, 0x24, 0x20, 0x32, 0x39, 0x39, 0x33, 0x2E, 0x39, 0x3A, 0x30, 0x34, 0x2F, 0x2B, 0x37, 
	0x38, 0x2F, 0x35, 0x34, 0x2E, 0x2B, 0x1C, 0x18, 0x32, 0x35, 0x2A, 0x28, 0x1C, 0x1A, 0x1F, 0x25, 
	0x28, 0x19, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 
	0x2F, 0x19, 0x19, 0x0F, 0x26, 0x25, 0x20, 0x33, 0x3E, 0x16, 0x29, 0x2B, 0x0F, 0x26, 0x25, 0x20, 
	0x2B, 0x35, 0x1F, 0x30, 0x36, 0x35, 0x37, 0x32, 0x37, 0x33, 0x29, 0x2A, 0x20, 0x1B, 0x28, 0x28, 
	0x25, 0x20, 0x33, 0x3A, 0x20, 0x35, 0x3E, 0x13, 0x29, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1F, 0x34, 0x3D, 0x4F, 
	0x43, 0x36, 0x3E, 0x40, 0x43, 0x1F, 0x34, 0x35, 0x1D, 0x2C, 0x36, 0x0F, 0x3B, 0x44, 0x1A, 0x34, 
	0x3C, 0x18, 0x33, 0x3B, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1E, 0x37, 0x40, 0x1D, 0x3A, 0x43, 
	0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1C, 0x2F, 0x37, 0x1C, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x31, 0x39, 0x1D, 0x31, 0x39, 0x1C, 0x2B, 0x36, 0x1B, 0x3E, 0x3E, 0x1C, 0x40, 0x3E, 0x1F, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x11, 0x36, 0x40, 0x12, 0x36, 0x40, 0x37, 0x42, 0x3E, 0x24, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x1F, 
	0x42, 0x48, 0x16, 0x43, 0x4D, 0x1D, 0x3F, 0x3E, 0x1C, 0x4D, 0x53, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 
	0x3F, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x40, 0x44, 0x1D, 0x29, 0x34, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x37, 0x1B, 0x2B, 0x33, 0x11, 0x22, 
	0x1E, 0x1F, 0x30, 0x3A, 0x13, 0x26, 0x26, 0x1E, 0x33, 0x3C, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x29, 0x2E, 0x1E, 
	0x36, 0x3F, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 
	0x3A, 0x19, 0x2B, 0x31, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x0E, 0x25, 0x24, 0x2A, 0x19, 0x15, 0x3B, 0x33, 0x33, 0x2B, 0x2E, 0x23, 0x39, 
	0x2E, 0x31, 0x33, 0x30, 0x2B, 0x30, 0x2A, 0x1F, 0x30, 0x31, 0x28, 0x32, 0x29, 0x1E, 0x23, 0x1C, 
	0x1D, 0x11, 0x27, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 
	0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x11, 0x27, 0x27, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 
	0x26, 0x24, 0x14, 0x28, 0x29, 0x1B, 0x30, 0x3B, 0x1A, 0x30, 0x3A, 0x1B, 0x31, 0x3B, 0x1A, 0x32, 
	0x3D, 0x32, 0x23, 0x19, 0x14, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x15, 0x2A, 0x35, 0x5A, 
	0x4C, 0x43, 0x46, 0x3D, 0x34, 0x0D, 0x39, 0x44, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x12, 0x39, 
	0x42, 0x12, 0x37, 0x40, 0x14, 0x36, 0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2C, 0x35, 0x1E, 0x35, 0x3D, 0x1D, 0x2E, 0x36, 0x18, 0x31, 0x3A, 0x1E, 0x2E, 0x36, 0x16, 
	0x39, 0x43, 0x1D, 0x3E, 0x40, 0x22, 0x45, 0x48, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 
	0x40, 0x1F, 0x43, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x36, 0x40, 0x23, 0x42, 0x3F, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x42, 0x49, 0x1C, 0x3A, 0x3C, 0x1C, 0x2B, 0x36, 0x28, 0x4D, 0x53, 0x1C, 0x3E, 0x3F, 0x1B, 0x39, 
	0x3D, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x29, 0x34, 0x1D, 0x3B, 0x43, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3C, 0x44, 0x1E, 0x38, 
	0x3D, 0x1D, 0x3C, 0x43, 0x1B, 0x2E, 0x35, 0x16, 0x28, 0x2B, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 0x14, 0x27, 0x27, 0x18, 
	0x29, 0x2E, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 
	0x13, 0x25, 0x24, 0x1D, 0x36, 0x42, 0x0C, 0x25, 0x24, 0x37, 0x33, 0x2B, 0x3A, 0x3B, 0x32, 0x37, 
	0x36, 0x2F, 0x36, 0x31, 0x2E, 0x2E, 0x30, 0x26, 0x30, 0x2A, 0x20, 0x31, 0x32, 0x28, 0x22, 0x29, 
	0x25, 0x12, 0x26, 0x27, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x15, 0x28, 0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 
	0x2F, 0x15, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x38, 0x14, 0x27, 0x28, 
	0x11, 0x24, 0x20, 0x1E, 0x31, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x39, 0x42, 0x11, 0x31, 0x3A, 0x54, 
	0x4C, 0x48, 0x18, 0x3C, 0x42, 0x1D, 0x2C, 0x35, 0x1B, 0x31, 0x39, 0x18, 0x38, 0x42, 0x12, 0x37, 
	0x40, 0x1F, 0x44, 0x40, 0x1E, 0x3C, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 
	0x1B, 0x3A, 0x43, 0x0F, 0x39, 0x42, 0x16, 0x33, 0x3B, 0x2E, 0x3A, 0x3C, 0x15, 0x34, 0x3D, 0x18, 
	0x33, 0x3B, 0x1E, 0x31, 0x3A, 0x0E, 0x35, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 
	0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x35, 0x40, 0x1D, 0x42, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x52, 0x1C, 0x28, 0x32, 0x1C, 0x37, 0x3A, 0x1B, 0x3A, 0x3E, 0x2B, 0x4E, 
	0x58, 0x1E, 0x3F, 0x43, 0x1C, 0x3B, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x12, 0x25, 0x24, 0x1F, 0x31, 0x3A, 0x12, 0x27, 0x29, 0x33, 0x2A, 0x24, 0x30, 0x2B, 0x27, 0x47, 
	0x42, 0x38, 0x37, 0x3A, 0x30, 0x34, 0x33, 0x2B, 0x25, 0x1B, 0x1C, 0x31, 0x32, 0x28, 0x28, 0x28, 
	0x24, 0x0F, 0x25, 0x24, 0x14, 0x29, 0x2C, 0x2B, 0x33, 0x33, 0x11, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x25, 0x19, 0x2B, 0x31, 0x1E, 0x33, 0x3D, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x15, 
	0x28, 0x2A, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 0x14, 0x27, 
	0x28, 0x18, 0x2A, 0x2F, 0x18, 0x29, 0x2C, 0x1D, 0x35, 0x3E, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x38, 
	0x1E, 0x30, 0x3A, 0x16, 0x29, 0x2B, 0x1A, 0x2B, 0x31, 0x1D, 0x39, 0x43, 0x19, 0x33, 0x3C, 0x26, 
	0x40, 0x40, 0x19, 0x37, 0x40, 0x1A, 0x31, 0x39, 0x1C, 0x2C, 0x38, 0x18, 0x43, 0x44, 0x13, 0x37, 
	0x42, 0x14, 0x3A, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1F, 0x32, 0x3B, 0x0F, 0x38, 0x42, 0x19, 0x2F, 0x38, 0x1E, 0x2E, 0x36, 0x18, 
	0x33, 0x3C, 0x1E, 0x42, 0x42, 0x1E, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x40, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x19, 0x18, 0x2F, 0x59, 0x62, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x56, 0x20, 0x45, 0x44, 0x1C, 0x4E, 0x59, 0x1D, 0x3B, 0x3C, 0x1A, 0x49, 
	0x50, 0x2B, 0x4D, 0x57, 0x1B, 0x30, 0x36, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 
	0x39, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1B, 0x2E, 0x35, 
	0x19, 0x2A, 0x2E, 0x18, 0x37, 0x42, 0x1B, 0x2E, 0x35, 0x1E, 0x2B, 0x35, 0x26, 0x22, 0x20, 0x30, 
	0x25, 0x1C, 0x38, 0x2E, 0x31, 0x39, 0x2F, 0x31, 0x2F, 0x31, 0x26, 0x30, 0x31, 0x27, 0x2E, 0x25, 
	0x1E, 0x1E, 0x34, 0x40, 0x0F, 0x25, 0x25, 0x34, 0x25, 0x1E, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 
	0x2C, 0x14, 0x28, 0x2A, 0x20, 0x1E, 0x1C, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x12, 0x25, 0x24, 0x19, 
	0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1B, 0x32, 0x3B, 0x1D, 0x3B, 0x44, 0x1B, 0x29, 0x2F, 0x1C, 
	0x2A, 0x34, 0x11, 0x39, 0x42, 0x15, 0x33, 0x3D, 0x30, 0x2E, 0x25, 0x40, 0x2E, 0x2A, 0x2A, 0x30, 
	0x2F, 0x12, 0x38, 0x43, 0x1B, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x42, 0x42, 0x1D, 0x43, 0x40, 0x1D, 0x42, 0x42, 0x1D, 0x30, 0x39, 0x18, 
	0x32, 0x3B, 0x14, 0x3A, 0x40, 0x1E, 0x3C, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x40, 0x3F, 0x27, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x0F, 0x23, 0x28, 0x32, 0x5D, 0x66, 0x22, 
	0x44, 0x47, 0x14, 0x3F, 0x49, 0x1D, 0x33, 0x3D, 0x1D, 0x48, 0x4B, 0x1C, 0x3C, 0x3D, 0x1D, 0x3B, 
	0x3C, 0x19, 0x48, 0x4E, 0x28, 0x4C, 0x52, 0x1C, 0x39, 0x3E, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x35, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x13, 0x25, 0x25, 0x18, 0x2A, 
	0x2E, 0x1D, 0x30, 0x39, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2F, 0x1B, 0x2E, 0x35, 0x1E, 0x31, 0x3A, 
	0x1C, 0x2F, 0x36, 0x12, 0x24, 0x20, 0x16, 0x29, 0x2B, 0x14, 0x28, 0x2A, 0x1F, 0x2B, 0x35, 0x32, 
	0x37, 0x32, 0x38, 0x3A, 0x2F, 0x38, 0x31, 0x30, 0x31, 0x2F, 0x28, 0x31, 0x32, 0x27, 0x26, 0x22, 
	0x20, 0x11, 0x26, 0x25, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x12, 0x25, 
	0x24, 0x20, 0x33, 0x3F, 0x11, 0x26, 0x25, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x19, 
	0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x2B, 0x32, 0x2E, 0x35, 0x32, 0x1C, 0x2C, 0x36, 0x0E, 0x3A, 0x43, 0x23, 
	0x42, 0x48, 0x11, 0x36, 0x3F, 0x1F, 0x3B, 0x42, 0x16, 0x32, 0x3C, 0x23, 0x46, 0x4B, 0x35, 0x31, 
	0x28, 0x20, 0x40, 0x43, 0x1C, 0x3F, 0x43, 0x1D, 0x2A, 0x35, 0x1D, 0x3F, 0x43, 0x1A, 0x2F, 0x38, 
	0x14, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x22, 0x38, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1E, 
	0x3B, 0x42, 0x11, 0x36, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x38, 0x40, 0x1B, 0x40, 0x3E, 0x27, 0x4A, 
	0x52, 0x1C, 0x3E, 0x3D, 0x1C, 0x40, 0x3F, 0x20, 0x44, 0x47, 0x1A, 0x3B, 0x3C, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1E, 0x23, 0x34, 0x64, 0x6D, 0x20, 
	0x3F, 0x46, 0x24, 0x4D, 0x57, 0x1B, 0x3C, 0x3B, 0x1C, 0x3B, 0x3B, 0x24, 0x47, 0x4B, 0x1B, 0x3B, 
	0x3C, 0x2A, 0x4C, 0x56, 0x1E, 0x42, 0x44, 0x1B, 0x3F, 0x3D, 0x2B, 0x4E, 0x5A, 0x1A, 0x3D, 0x3B, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3C, 0x40, 0x24, 0x4B, 0x4E, 
	0x1C, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1E, 0x3A, 0x45, 0x1B, 0x2C, 
	0x34, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x20, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x20, 
	0x26, 0x26, 0x44, 0x39, 0x35, 0x37, 0x3A, 0x30, 0x3A, 0x32, 0x32, 0x2E, 0x23, 0x22, 0x11, 0x29, 
	0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1E, 0x31, 
	0x3B, 0x13, 0x26, 0x25, 0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 
	0x1D, 0x2E, 0x36, 0x1C, 0x38, 0x42, 0x28, 0x12, 0x0F, 0x1C, 0x31, 0x3A, 0x1E, 0x2E, 0x37, 0x22, 
	0x45, 0x47, 0x11, 0x36, 0x3F, 0x1C, 0x3B, 0x42, 0x1D, 0x2B, 0x34, 0x1F, 0x44, 0x49, 0x18, 0x2C, 
	0x38, 0x37, 0x45, 0x42, 0x1A, 0x2C, 0x37, 0x1D, 0x3A, 0x42, 0x1D, 0x43, 0x40, 0x1E, 0x3D, 0x40, 
	0x11, 0x36, 0x3F, 0x12, 0x37, 0x40, 0x38, 0x43, 0x40, 0x1A, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 
	0x3F, 0x40, 0x1B, 0x3F, 0x40, 0x12, 0x39, 0x40, 0x35, 0x3C, 0x3A, 0x1A, 0x39, 0x3E, 0x2A, 0x4C, 
	0x56, 0x1A, 0x42, 0x43, 0x1B, 0x3E, 0x3C, 0x1A, 0x42, 0x42, 0x29, 0x4D, 0x57, 0x25, 0x40, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x34, 0x5D, 0x5F, 0x20, 
	0x3D, 0x48, 0x1E, 0x40, 0x3F, 0x2A, 0x4C, 0x55, 0x1B, 0x4C, 0x55, 0x1C, 0x4C, 0x55, 0x1B, 0x3A, 
	0x3A, 0x29, 0x4C, 0x56, 0x1A, 0x3D, 0x3B, 0x1D, 0x40, 0x40, 0x1A, 0x3D, 0x3A, 0x2A, 0x4D, 0x58, 
	0x1B, 0x39, 0x3D, 0x1C, 0x3C, 0x3E, 0x1B, 0x3F, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1B, 
	0x38, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x39, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x2F, 0x3A, 0x1C, 0x43, 0x3F, 
	0x1D, 0x31, 0x3B, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2C, 0x33, 0x18, 0x29, 0x2C, 0x11, 0x24, 
	0x20, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x12, 
	0x29, 0x2B, 0x1E, 0x16, 0x18, 0x38, 0x38, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x34, 0x2B, 0x15, 0x2B, 
	0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 
	0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x30, 0x37, 0x34, 0x19, 0x30, 0x39, 0x0F, 0x39, 0x42, 0x1F, 
	0x39, 0x3F, 0x13, 0x37, 0x40, 0x12, 0x38, 0x42, 0x1F, 0x2E, 0x36, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 
	0x42, 0x1A, 0x39, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1E, 0x3B, 0x40, 0x1C, 0x3B, 0x3F, 
	0x1F, 0x44, 0x47, 0x11, 0x35, 0x3F, 0x19, 0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x35, 0x40, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x48, 
	0x4E, 0x29, 0x4B, 0x54, 0x28, 0x4B, 0x54, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x2B, 0x50, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x3A, 0x69, 0x75, 0x26, 
	0x48, 0x4A, 0x19, 0x4A, 0x54, 0x2A, 0x4B, 0x55, 0x1B, 0x3F, 0x3E, 0x1F, 0x48, 0x4F, 0x24, 0x48, 
	0x4B, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1B, 0x3E, 0x3C, 0x1B, 0x45, 0x4A, 0x29, 0x4C, 0x56, 
	0x1D, 0x3E, 0x40, 0x26, 0x4A, 0x51, 0x2A, 0x4D, 0x58, 0x1B, 0x3E, 0x3C, 0x1D, 0x40, 0x40, 0x1B, 
	0x3F, 0x3D, 0x1B, 0x3B, 0x3C, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3B, 0x11, 0x24, 0x22, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1F, 
	0x32, 0x3C, 0x16, 0x2E, 0x35, 0x30, 0x2F, 0x30, 0x3A, 0x2F, 0x31, 0x2F, 0x1F, 0x1C, 0x16, 0x2C, 
	0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x29, 0x2B, 0x22, 
	0x2C, 0x35, 0x1B, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1A, 0x30, 0x39, 
	0x1C, 0x2F, 0x37, 0x1E, 0x2E, 0x36, 0x1B, 0x32, 0x3C, 0x1E, 0x3F, 0x42, 0x1A, 0x37, 0x40, 0x12, 
	0x37, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x39, 0x42, 0x12, 0x38, 0x42, 0x1C, 0x40, 
	0x40, 0x1E, 0x37, 0x40, 0x1D, 0x36, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x3F, 0x1C, 0x3C, 0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 
	0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x3D, 0x2A, 0x4C, 
	0x56, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x53, 0x2A, 0x4F, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x32, 0x5B, 0x5E, 0x28, 
	0x4B, 0x4B, 0x2A, 0x4A, 0x54, 0x19, 0x3F, 0x3E, 0x1B, 0x4C, 0x56, 0x28, 0x49, 0x4E, 0x19, 0x2C, 
	0x37, 0x26, 0x4A, 0x51, 0x1A, 0x42, 0x42, 0x1D, 0x3B, 0x3D, 0x1B, 0x49, 0x50, 0x1E, 0x40, 0x40, 
	0x29, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x28, 0x4B, 0x53, 0x1B, 0x3B, 0x3C, 0x2A, 
	0x4D, 0x58, 0x24, 0x45, 0x4C, 0x1B, 0x38, 0x3C, 0x1D, 0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 0x11, 0x24, 0x22, 0x18, 
	0x2A, 0x2F, 0x1B, 0x30, 0x3B, 0x38, 0x35, 0x29, 0x3A, 0x3B, 0x30, 0x23, 0x2A, 0x2E, 0x13, 0x28, 
	0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x27, 
	0x1C, 0x1B, 0x1F, 0x1F, 0x1D, 0x14, 0x29, 0x2A, 0x1F, 0x32, 0x3C, 0x15, 0x28, 0x2A, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 
	0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x32, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x1B, 0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1A, 0x33, 
	0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x18, 0x39, 0x43, 0x37, 0x46, 0x43, 
	0x20, 0x31, 0x38, 0x0F, 0x39, 0x42, 0x1F, 0x3F, 0x42, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x37, 
	0x40, 0x15, 0x38, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1F, 0x3D, 0x40, 0x1D, 0x35, 0x40, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3D, 0x3E, 0x1F, 0x43, 0x40, 0x1C, 0x3F, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1C, 0x3F, 0x3E, 0x19, 0x40, 
	0x40, 0x27, 0x4A, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 0x53, 0x28, 0x43, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x68, 0x73, 0x2C, 
	0x4D, 0x50, 0x18, 0x49, 0x52, 0x2A, 0x4B, 0x54, 0x27, 0x47, 0x4D, 0x19, 0x4A, 0x53, 0x26, 0x49, 
	0x4F, 0x20, 0x44, 0x46, 0x26, 0x49, 0x50, 0x1A, 0x3D, 0x3A, 0x2A, 0x4C, 0x56, 0x19, 0x3C, 0x39, 
	0x28, 0x4B, 0x54, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1A, 0x3D, 0x3A, 0x1D, 0x39, 0x3E, 0x1A, 
	0x46, 0x49, 0x1B, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1A, 0x3E, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x39, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x29, 0x34, 
	0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1C, 
	0x2C, 0x36, 0x1D, 0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3A, 
	0x1A, 0x2C, 0x32, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x13, 
	0x26, 0x26, 0x19, 0x2E, 0x35, 0x24, 0x24, 0x1F, 0x3C, 0x3A, 0x30, 0x18, 0x31, 0x3C, 0x1F, 0x32, 
	0x3C, 0x15, 0x28, 0x29, 0x1D, 0x30, 0x39, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 
	0x26, 0x24, 0x19, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 
	0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x16, 0x27, 0x29, 0x1D, 0x3B, 0x45, 0x1D, 0x2C, 
	0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x38, 0x19, 0x31, 0x39, 0x20, 0x32, 0x39, 
	0x32, 0x3B, 0x39, 0x13, 0x38, 0x42, 0x19, 0x32, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 
	0x3E, 0x12, 0x37, 0x40, 0x1D, 0x42, 0x3E, 0x1E, 0x3D, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x3A, 0x3E, 0x1E, 0x49, 0x4D, 0x0E, 0x33, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3C, 0x3F, 0x1D, 
	0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x1E, 0x42, 0x43, 0x29, 0x4B, 
	0x55, 0x28, 0x4C, 0x52, 0x38, 0x53, 0x50, 0x1C, 0x48, 0x52, 0x1A, 0x4A, 0x53, 0x1A, 0x49, 0x50, 
	0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x67, 0x71, 0x20, 
	0x43, 0x49, 0x29, 0x4A, 0x52, 0x1A, 0x4B, 0x54, 0x1E, 0x40, 0x3F, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x4E, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 0x3B, 0x38, 0x28, 0x4B, 0x54, 0x19, 0x3D, 0x3A, 0x2B, 
	0x4D, 0x59, 0x1A, 0x3D, 0x3B, 0x1A, 0x3E, 0x3B, 0x1D, 0x3D, 0x40, 0x1A, 0x3E, 0x3B, 0x1C, 0x3D, 
	0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x36, 0x20, 
	0x46, 0x49, 0x1C, 0x44, 0x40, 0x20, 0x46, 0x49, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x25, 0x2F, 0x30, 0x44, 0x3F, 0x34, 0x1B, 0x1B, 0x1A, 0x14, 0x29, 
	0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x31, 0x1F, 
	0x32, 0x3D, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1D, 
	0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x37, 0x1D, 0x39, 0x43, 0x1D, 0x3C, 
	0x43, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x16, 0x2B, 0x37, 
	0x3B, 0x3E, 0x36, 0x0E, 0x38, 0x42, 0x1C, 0x31, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x19, 0x43, 
	0x4B, 0x11, 0x35, 0x3D, 0x26, 0x4A, 0x4E, 0x1C, 0x2E, 0x38, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x44, 0x46, 0x1E, 0x40, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x1E, 0x46, 0x4A, 0x29, 0x4B, 0x54, 0x18, 0x4A, 
	0x52, 0x2A, 0x47, 0x4D, 0x37, 0x3E, 0x3C, 0x32, 0x56, 0x53, 0x2A, 0x4C, 0x53, 0x28, 0x4E, 0x50, 
	0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x4A, 0x52, 0x1B, 0x47, 0x4D, 0x22, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4B, 0x55, 0x18, 0x3B, 0x37, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x38, 0x2B, 0x4E, 0x59, 0x19, 
	0x3C, 0x39, 0x29, 0x4C, 0x56, 0x2A, 0x4D, 0x58, 0x19, 0x3C, 0x39, 0x2B, 0x4E, 0x59, 0x1E, 0x42, 
	0x42, 0x1F, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1D, 0x42, 0x40, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 
	0x3F, 0x42, 0x1D, 0x31, 0x3C, 0x1C, 0x3F, 0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x11, 
	0x23, 0x1F, 0x16, 0x2B, 0x31, 0x27, 0x30, 0x31, 0x3C, 0x31, 0x2F, 0x15, 0x2E, 0x37, 0x12, 0x25, 
	0x23, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x1A, 0x2C, 0x32, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 
	0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1F, 0x32, 0x3C, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x1D, 
	0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 
	0x37, 0x1D, 0x2C, 0x35, 0x1D, 0x30, 0x39, 0x13, 0x35, 0x3E, 0x19, 0x38, 0x42, 0x32, 0x3B, 0x39, 
	0x38, 0x3C, 0x36, 0x0E, 0x36, 0x42, 0x1F, 0x42, 0x40, 0x13, 0x37, 0x40, 0x13, 0x36, 0x3E, 0x13, 
	0x37, 0x3F, 0x13, 0x36, 0x3E, 0x1D, 0x48, 0x4D, 0x1C, 0x46, 0x4C, 0x0F, 0x33, 0x3C, 0x2A, 0x4F, 
	0x57, 0x0D, 0x32, 0x3B, 0x22, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x3E, 
	0x1D, 0x45, 0x47, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3D, 0x1B, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 
	0x3E, 0x3C, 0x1B, 0x45, 0x49, 0x2A, 0x4C, 0x56, 0x25, 0x47, 0x4D, 0x27, 0x4A, 0x52, 0x29, 0x4A, 
	0x52, 0x18, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x2B, 0x4F, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x66, 0x70, 0x2C, 
	0x53, 0x5B, 0x19, 0x49, 0x51, 0x1B, 0x4A, 0x52, 0x29, 0x4A, 0x53, 0x19, 0x47, 0x4C, 0x28, 0x4A, 
	0x52, 0x26, 0x49, 0x52, 0x2F, 0x50, 0x52, 0x18, 0x46, 0x4C, 0x29, 0x4B, 0x54, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x2A, 0x4B, 0x55, 0x1D, 0x40, 0x3F, 0x1E, 
	0x42, 0x42, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x37, 0x2B, 0x4E, 0x59, 0x19, 0x3C, 0x39, 0x29, 0x4C, 
	0x57, 0x28, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x1B, 0x39, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x38, 0x3D, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 
	0x2A, 0x35, 0x15, 0x26, 0x28, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x14, 0x27, 0x27, 0x1E, 0x30, 0x39, 0x1C, 
	0x36, 0x42, 0x0F, 0x23, 0x22, 0x20, 0x29, 0x23, 0x3C, 0x37, 0x2F, 0x29, 0x38, 0x3B, 0x1A, 0x2E, 
	0x35, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x25, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x30, 0x18, 0x2A, 
	0x2F, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x22, 0x18, 0x2A, 0x2F, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 
	0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x3B, 0x43, 0x1D, 0x3E, 0x42, 0x1E, 0x44, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3C, 0x42, 
	0x36, 0x3F, 0x3B, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x35, 0x3E, 0x1D, 0x4A, 0x52, 0x19, 
	0x3E, 0x45, 0x12, 0x35, 0x3E, 0x12, 0x34, 0x3C, 0x1C, 0x46, 0x4C, 0x1B, 0x40, 0x44, 0x27, 0x49, 
	0x50, 0x28, 0x4B, 0x51, 0x1B, 0x3D, 0x3C, 0x1D, 0x44, 0x45, 0x1C, 0x39, 0x3E, 0x20, 0x45, 0x47, 
	0x1C, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x29, 0x4C, 0x56, 0x29, 0x4C, 0x56, 0x1D, 0x45, 0x49, 0x2A, 
	0x4B, 0x55, 0x1B, 0x4B, 0x55, 0x1A, 0x43, 0x45, 0x1A, 0x4A, 0x53, 0x29, 0x4D, 0x52, 0x26, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1D, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x49, 0x52, 0x1A, 0x4A, 0x52, 0x28, 0x49, 0x52, 0x1D, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x28, 
	0x4B, 0x54, 0x18, 0x44, 0x46, 0x2A, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1B, 0x3E, 0x3C, 0x1E, 0x42, 
	0x42, 0x28, 0x4C, 0x55, 0x1A, 0x3B, 0x3B, 0x1B, 0x3D, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x20, 
	0x43, 0x47, 0x20, 0x40, 0x48, 0x1C, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x1E, 0x32, 0x3C, 0x16, 
	0x40, 0x45, 0x19, 0x2B, 0x33, 0x20, 0x31, 0x38, 0x34, 0x3F, 0x3B, 0x37, 0x32, 0x26, 0x1B, 0x30, 
	0x3C, 0x11, 0x24, 0x22, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2A, 0x2F, 0x1C, 0x31, 0x3C, 0x14, 0x27, 0x27, 0x1F, 0x32, 0x3D, 0x1B, 0x2E, 
	0x35, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1D, 0x46, 0x43, 0x1D, 0x28, 0x34, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x28, 0x3F, 0x42, 
	0x35, 0x3F, 0x3C, 0x18, 0x33, 0x3E, 0x1E, 0x43, 0x40, 0x1B, 0x3D, 0x3E, 0x18, 0x40, 0x4B, 0x1C, 
	0x45, 0x4B, 0x1F, 0x48, 0x4B, 0x18, 0x42, 0x4B, 0x16, 0x38, 0x3B, 0x14, 0x3A, 0x45, 0x14, 0x38, 
	0x3B, 0x20, 0x45, 0x49, 0x1E, 0x45, 0x48, 0x1C, 0x4D, 0x57, 0x1D, 0x44, 0x45, 0x1B, 0x3E, 0x3C, 
	0x1D, 0x3E, 0x3D, 0x1B, 0x45, 0x49, 0x28, 0x4B, 0x54, 0x20, 0x43, 0x46, 0x20, 0x44, 0x47, 0x29, 
	0x4B, 0x55, 0x1A, 0x43, 0x45, 0x2A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x19, 0x49, 0x52, 0x2A, 0x4C, 
	0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x28, 0x39, 0x67, 0x71, 0x1E, 
	0x44, 0x49, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x2B, 0x4C, 0x52, 0x18, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x1A, 0x40, 
	0x3F, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x3F, 0x3E, 0x1E, 
	0x40, 0x46, 0x20, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x24, 0x22, 0x14, 0x28, 0x2E, 0x40, 
	0x3C, 0x32, 0x20, 0x30, 0x36, 0x42, 0x35, 0x30, 0x3D, 0x3A, 0x31, 0x3B, 0x39, 0x2F, 0x1A, 0x2F, 
	0x3A, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 
	0x2C, 0x32, 0x1C, 0x31, 0x3C, 0x33, 0x30, 0x26, 0x16, 0x2A, 0x31, 0x11, 0x24, 0x22, 0x12, 0x25, 
	0x24, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 
	0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x15, 0x33, 0x3C, 
	0x3F, 0x37, 0x2A, 0x15, 0x31, 0x3C, 0x18, 0x3C, 0x40, 0x1E, 0x40, 0x3D, 0x15, 0x38, 0x3E, 0x11, 
	0x33, 0x3C, 0x18, 0x3D, 0x45, 0x1D, 0x47, 0x4A, 0x2C, 0x4C, 0x56, 0x1C, 0x4C, 0x55, 0x24, 0x46, 
	0x4A, 0x35, 0x51, 0x4F, 0x2C, 0x48, 0x4F, 0x1C, 0x43, 0x44, 0x1B, 0x3E, 0x3C, 0x2A, 0x4C, 0x57, 
	0x1B, 0x45, 0x49, 0x1B, 0x4B, 0x55, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x22, 
	0x44, 0x46, 0x1B, 0x4B, 0x55, 0x22, 0x47, 0x4C, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2E, 0x4F, 
	0x52, 0x27, 0x4A, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x28, 
	0x4A, 0x4F, 0x27, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x27, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x28, 0x4A, 0x52, 
	0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2E, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x52, 0x24, 0x47, 0x4C, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x19, 0x4A, 
	0x53, 0x28, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 0x3D, 
	0x2B, 0x4E, 0x59, 0x1B, 0x39, 0x3D, 0x1C, 0x42, 0x3F, 0x1F, 0x3C, 0x45, 0x1D, 0x40, 0x45, 0x31, 
	0x3A, 0x3B, 0x1B, 0x3D, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x1B, 0x32, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x3A, 0x2B, 
	0x39, 0x3A, 0x15, 0x3A, 0x40, 0x45, 0x3C, 0x32, 0x48, 0x3F, 0x37, 0x36, 0x35, 0x2A, 0x16, 0x2C, 
	0x35, 0x11, 0x24, 0x22, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x30, 0x1B, 0x30, 0x3A, 0x1D, 0x30, 0x39, 0x1F, 0x32, 0x3C, 0x15, 0x28, 
	0x29, 0x12, 0x25, 0x23, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1D, 0x2C, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x40, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 
	0x43, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x3F, 0x19, 0x3C, 0x43, 
	0x3A, 0x39, 0x31, 0x28, 0x3D, 0x43, 0x0E, 0x34, 0x3D, 0x1F, 0x4F, 0x58, 0x11, 0x33, 0x3B, 0x1F, 
	0x4F, 0x57, 0x1B, 0x40, 0x43, 0x18, 0x3C, 0x44, 0x1C, 0x44, 0x47, 0x1D, 0x48, 0x4F, 0x18, 0x3A, 
	0x3B, 0x20, 0x43, 0x48, 0x1B, 0x4A, 0x51, 0x18, 0x39, 0x3D, 0x1C, 0x3F, 0x3D, 0x28, 0x4B, 0x55, 
	0x1E, 0x40, 0x40, 0x1B, 0x3F, 0x3F, 0x1B, 0x4A, 0x53, 0x1C, 0x4A, 0x53, 0x22, 0x44, 0x46, 0x28, 
	0x4B, 0x55, 0x20, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x29, 0x4A, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 
	0x52, 0x32, 0x54, 0x52, 0x2B, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x4D, 0x4E, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x2A, 
	0x4C, 0x4F, 0x26, 0x49, 0x52, 0x2B, 0x4D, 0x52, 0x1A, 0x49, 0x52, 0x20, 0x49, 0x52, 0x28, 0x49, 
	0x52, 0x18, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x49, 0x52, 
	0x28, 0x4C, 0x53, 0x31, 0x55, 0x53, 0x19, 0x47, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4A, 0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3F, 0x3D, 0x1D, 0x39, 0x3E, 
	0x1B, 0x47, 0x4A, 0x1D, 0x3A, 0x3E, 0x1B, 0x39, 0x3D, 0x2A, 0x4E, 0x57, 0x2A, 0x4D, 0x57, 0x1A, 
	0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3D, 
	0x3F, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x39, 0x1C, 0x3C, 0x42, 
	0x19, 0x30, 0x39, 0x11, 0x3A, 0x43, 0x19, 0x35, 0x3D, 0x19, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x19, 
	0x34, 0x3E, 0x14, 0x3E, 0x43, 0x52, 0x42, 0x39, 0x4B, 0x40, 0x38, 0x3E, 0x3A, 0x31, 0x1F, 0x30, 
	0x36, 0x18, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x31, 0x13, 
	0x26, 0x26, 0x12, 0x25, 0x23, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 0x1F, 0x32, 
	0x3C, 0x18, 0x2A, 0x2E, 0x1A, 0x2F, 0x36, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3D, 0x43, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1D, 0x40, 0x43, 0x1D, 0x31, 
	0x3B, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3A, 0x3F, 0x1F, 0x44, 0x45, 0x20, 0x3B, 0x3D, 
	0x36, 0x3B, 0x36, 0x2B, 0x42, 0x42, 0x1C, 0x3C, 0x3D, 0x1E, 0x4D, 0x56, 0x11, 0x33, 0x3B, 0x1E, 
	0x4D, 0x55, 0x16, 0x3C, 0x42, 0x15, 0x3B, 0x44, 0x1E, 0x4D, 0x56, 0x1B, 0x4B, 0x54, 0x1D, 0x43, 
	0x47, 0x23, 0x51, 0x56, 0x1B, 0x3D, 0x42, 0x11, 0x35, 0x3E, 0x15, 0x39, 0x3D, 0x28, 0x4B, 0x54, 
	0x29, 0x4C, 0x53, 0x26, 0x4F, 0x54, 0x1B, 0x48, 0x52, 0x1B, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x26, 
	0x4A, 0x52, 0x26, 0x49, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x24, 0x47, 
	0x52, 0x2E, 0x50, 0x52, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4F, 0x51, 0x2F, 0x5A, 0x61, 
	0x04, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x65, 0x6F, 0x2A, 
	0x4C, 0x4E, 0x26, 0x49, 0x52, 0x27, 0x49, 0x52, 0x18, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x29, 0x4C, 
	0x52, 0x27, 0x49, 0x52, 0x31, 0x53, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x26, 0x4A, 0x53, 
	0x29, 0x43, 0x47, 0x49, 0x47, 0x47, 0x31, 0x55, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x1B, 0x3E, 0x3C, 0x1C, 0x38, 0x3C, 
	0x24, 0x48, 0x4C, 0x1B, 0x3C, 0x3C, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x1B, 0x3C, 0x3D, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3F, 0x22, 0x46, 
	0x47, 0x1C, 0x3C, 0x40, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x44, 0x1C, 0x45, 0x40, 0x1F, 0x40, 0x49, 
	0x2B, 0x2E, 0x2A, 0x19, 0x31, 0x3A, 0x1B, 0x33, 0x3B, 0x13, 0x26, 0x25, 0x1F, 0x32, 0x3C, 0x16, 
	0x28, 0x2A, 0x1A, 0x30, 0x3A, 0x3D, 0x42, 0x44, 0x52, 0x48, 0x3D, 0x43, 0x3D, 0x34, 0x27, 0x24, 
	0x23, 0x0F, 0x25, 0x24, 0x20, 0x33, 0x3E, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x16, 0x29, 
	0x2C, 0x1D, 0x32, 0x3C, 0x23, 0x18, 0x15, 0x1A, 0x2F, 0x36, 0x13, 0x26, 0x25, 0x1D, 0x2F, 0x38, 
	0x1D, 0x40, 0x44, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1C, 0x2B, 0x35, 0x1D, 0x30, 0x39, 0x1D, 0x38, 0x42, 0x1D, 0x2B, 
	0x35, 0x1D, 0x40, 0x42, 0x1D, 0x3D, 0x40, 0x1B, 0x3A, 0x3D, 0x2B, 0x4F, 0x59, 0x18, 0x36, 0x3E, 
	0x37, 0x3B, 0x35, 0x31, 0x40, 0x40, 0x1A, 0x43, 0x45, 0x1D, 0x4C, 0x55, 0x15, 0x3A, 0x43, 0x1D, 
	0x4D, 0x56, 0x28, 0x4A, 0x4F, 0x0F, 0x33, 0x3C, 0x16, 0x3C, 0x42, 0x2B, 0x48, 0x4F, 0x2C, 0x4F, 
	0x51, 0x5D, 0x53, 0x4D, 0x30, 0x50, 0x53, 0x13, 0x3C, 0x44, 0x20, 0x44, 0x44, 0x26, 0x49, 0x53, 
	0x2C, 0x54, 0x53, 0x58, 0x4F, 0x4A, 0x43, 0x51, 0x4D, 0x13, 0x44, 0x4E, 0x22, 0x4A, 0x53, 0x29, 
	0x4C, 0x52, 0x2A, 0x4E, 0x52, 0x3E, 0x4E, 0x4C, 0x1A, 0x48, 0x52, 0x2C, 0x4E, 0x52, 0x32, 0x54, 
	0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4D, 0x53, 0x19, 0x43, 0x4D, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x78, 0x80, 0x2A, 
	0x50, 0x58, 0x27, 0x4A, 0x51, 0x2F, 0x51, 0x52, 0x2B, 0x4D, 0x52, 0x2B, 0x4E, 0x52, 0x2E, 0x4F, 
	0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 
	0x28, 0x4C, 0x53, 0x30, 0x55, 0x53, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 
	0x4F, 0x52, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4E, 0x56, 
	0x1B, 0x31, 0x3A, 0x2B, 0x50, 0x58, 0x1B, 0x2C, 0x37, 0x1C, 0x3B, 0x3E, 0x1D, 0x3E, 0x40, 0x1C, 
	0x40, 0x40, 0x1A, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3F, 0x12, 0x3E, 
	0x48, 0x1E, 0x3A, 0x3D, 0x1A, 0x29, 0x30, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x38, 0x19, 0x3C, 0x40, 
	0x40, 0x46, 0x44, 0x22, 0x33, 0x39, 0x1C, 0x2F, 0x37, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x1E, 
	0x31, 0x3A, 0x19, 0x2E, 0x38, 0x3E, 0x3C, 0x33, 0x4C, 0x40, 0x38, 0x46, 0x3D, 0x35, 0x3E, 0x3A, 
	0x30, 0x0D, 0x24, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x31, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 
	0x2B, 0x31, 0x15, 0x28, 0x29, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2F, 0x39, 0x37, 0x37, 0x2E, 0x1B, 0x2F, 0x39, 0x1A, 0x32, 0x3B, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x44, 0x1D, 
	0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x20, 0x46, 0x49, 0x1C, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x2E, 
	0x38, 0x1D, 0x3C, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3B, 0x40, 0x1B, 0x3C, 0x3C, 0x23, 0x49, 0x4E, 
	0x30, 0x40, 0x40, 0x35, 0x3C, 0x39, 0x1E, 0x42, 0x44, 0x1D, 0x4C, 0x55, 0x11, 0x33, 0x3C, 0x15, 
	0x37, 0x39, 0x2B, 0x4C, 0x56, 0x19, 0x43, 0x48, 0x15, 0x3F, 0x4A, 0x22, 0x3C, 0x3B, 0x56, 0x50, 
	0x4C, 0x5A, 0x55, 0x4E, 0x4F, 0x51, 0x4B, 0x1B, 0x43, 0x4B, 0x1B, 0x42, 0x42, 0x26, 0x4A, 0x54, 
	0x29, 0x4B, 0x51, 0x69, 0x59, 0x4E, 0x5A, 0x53, 0x4E, 0x1F, 0x3C, 0x3F, 0x27, 0x4A, 0x53, 0x2E, 
	0x4F, 0x52, 0x29, 0x4E, 0x52, 0x3C, 0x4D, 0x4C, 0x2B, 0x4E, 0x52, 0x28, 0x4B, 0x52, 0x24, 0x47, 
	0x52, 0x28, 0x4B, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x2C, 0x4E, 0x52, 0x1C, 0x49, 0x53, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x75, 0x7E, 0x29, 
	0x4E, 0x57, 0x31, 0x53, 0x51, 0x30, 0x52, 0x52, 0x31, 0x53, 0x52, 0x2B, 0x4D, 0x52, 0x15, 0x48, 
	0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x32, 0x54, 0x52, 0x26, 0x49, 0x52, 
	0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4B, 0x54, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x25, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 
	0x1B, 0x3D, 0x39, 0x1B, 0x4C, 0x56, 0x1B, 0x3B, 0x3B, 0x27, 0x4B, 0x52, 0x1A, 0x3B, 0x3C, 0x20, 
	0x3E, 0x3D, 0x3B, 0x43, 0x43, 0x19, 0x40, 0x3F, 0x18, 0x3C, 0x40, 0x1E, 0x32, 0x3B, 0x1A, 0x26, 
	0x2C, 0x1D, 0x3E, 0x43, 0x1D, 0x39, 0x3F, 0x1D, 0x2B, 0x35, 0x1D, 0x3B, 0x42, 0x1D, 0x3D, 0x42, 
	0x1A, 0x2A, 0x35, 0x1C, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x20, 0x12, 0x25, 0x23, 0x1B, 
	0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x18, 0x3D, 0x44, 0x4A, 0x3D, 0x33, 0x54, 0x4B, 0x42, 0x45, 0x3C, 
	0x33, 0x15, 0x2B, 0x34, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x1A, 0x2C, 0x32, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x1F, 
	0x31, 0x3B, 0x18, 0x28, 0x2B, 0x18, 0x37, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x1B, 0x30, 0x3A, 0x1C, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2F, 0x39, 0x1C, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x3C, 0x40, 0x1C, 0x34, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x37, 0x40, 0x18, 0x3F, 0x3D, 
	0x35, 0x3C, 0x39, 0x2B, 0x3D, 0x3B, 0x1A, 0x46, 0x4A, 0x1D, 0x4B, 0x54, 0x18, 0x3E, 0x47, 0x1E, 
	0x4E, 0x56, 0x1E, 0x48, 0x4D, 0x28, 0x4C, 0x54, 0x1A, 0x4C, 0x55, 0x27, 0x40, 0x44, 0x5F, 0x59, 
	0x52, 0x62, 0x58, 0x4F, 0x58, 0x54, 0x50, 0x27, 0x40, 0x42, 0x19, 0x4A, 0x51, 0x29, 0x49, 0x4F, 
	0x3B, 0x44, 0x43, 0x48, 0x4C, 0x4A, 0x43, 0x55, 0x53, 0x1D, 0x48, 0x4F, 0x28, 0x4A, 0x53, 0x18, 
	0x4A, 0x53, 0x2C, 0x4F, 0x53, 0x31, 0x55, 0x53, 0x2B, 0x4E, 0x52, 0x30, 0x51, 0x52, 0x32, 0x54, 
	0x52, 0x2B, 0x4D, 0x52, 0x2C, 0x4E, 0x52, 0x2B, 0x4D, 0x51, 0x2F, 0x53, 0x57, 0x2E, 0x59, 0x5F, 
	0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x20, 0x25, 0x3B, 0x7C, 0x88, 0x30, 
	0x54, 0x5B, 0x2A, 0x4C, 0x50, 0x31, 0x54, 0x53, 0x2E, 0x4F, 0x51, 0x2E, 0x50, 0x52, 0x2C, 0x4E, 
	0x51, 0x2C, 0x4E, 0x52, 0x29, 0x4B, 0x52, 0x29, 0x4B, 0x52, 0x2C, 0x50, 0x53, 0x26, 0x4A, 0x53, 
	0x27, 0x4A, 0x53, 0x27, 0x4C, 0x55, 0x23, 0x39, 0x36, 0x31, 0x55, 0x55, 0x26, 0x4A, 0x53, 0x27, 
	0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x28, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4A, 
	0x53, 0x27, 0x4B, 0x53, 0x28, 0x4C, 0x54, 0x1C, 0x44, 0x46, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x53, 
	0x28, 0x4B, 0x54, 0x25, 0x47, 0x4D, 0x1D, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x26, 
	0x4A, 0x54, 0x37, 0x4F, 0x4D, 0x2E, 0x3F, 0x3E, 0x0E, 0x35, 0x40, 0x1A, 0x3C, 0x3F, 0x22, 0x42, 
	0x49, 0x1C, 0x3E, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3B, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x28, 0x14, 
	0x27, 0x27, 0x1B, 0x2C, 0x33, 0x19, 0x3C, 0x44, 0x3B, 0x3A, 0x33, 0x54, 0x4B, 0x40, 0x48, 0x3E, 
	0x34, 0x1E, 0x33, 0x3B, 0x16, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1C, 0x2E, 0x36, 0x18, 
	0x35, 0x3D, 0x18, 0x35, 0x3E, 0x1E, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x14, 0x27, 0x27, 0x16, 0x29, 0x2C, 0x23, 0x2F, 0x33, 0x1C, 0x37, 0x3F, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x42, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x2F, 
	0x3A, 0x1B, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x1C, 0x3F, 0x3F, 0x1B, 0x3F, 0x3D, 0x29, 0x4E, 0x59, 
	0x2B, 0x44, 0x47, 0x50, 0x3C, 0x30, 0x19, 0x49, 0x52, 0x1C, 0x4B, 0x54, 0x1E, 0x4C, 0x51, 0x16, 
	0x43, 0x4D, 0x1E, 0x3E, 0x48, 0x1A, 0x42, 0x4B, 0x1A, 0x46, 0x4C, 0x50, 0x5E, 0x61, 0x69, 0x5B, 
	0x4A, 0x55, 0x4C, 0x3F, 0x49, 0x4B, 0x46, 0x22, 0x48, 0x50, 0x24, 0x3E, 0x48, 0x23, 0x3E, 0x49, 
	0x24, 0x46, 0x4B, 0x43, 0x44, 0x3D, 0x40, 0x47, 0x44, 0x22, 0x3F, 0x48, 0x31, 0x4E, 0x4E, 0x22, 
	0x3D, 0x47, 0x25, 0x40, 0x48, 0x26, 0x43, 0x4B, 0x1C, 0x49, 0x53, 0x1C, 0x47, 0x52, 0x29, 0x53, 
	0x58, 0x28, 0x53, 0x57, 0x28, 0x53, 0x57, 0x28, 0x52, 0x57, 0x2B, 0x56, 0x5D, 0x30, 0x54, 0x5F, 
	0x03, 0x08, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x12, 0x24, 0x25, 0x39, 0x71, 0x7F, 0x2E, 
	0x56, 0x5D, 0x27, 0x53, 0x57, 0x27, 0x46, 0x4B, 0x2A, 0x57, 0x5F, 0x34, 0x51, 0x55, 0x2A, 0x56, 
	0x5D, 0x27, 0x52, 0x56, 0x28, 0x52, 0x56, 0x28, 0x54, 0x58, 0x24, 0x3E, 0x46, 0x25, 0x43, 0x4A, 
	0x29, 0x50, 0x4D, 0x25, 0x43, 0x4A, 0x28, 0x45, 0x4A, 0x28, 0x43, 0x47, 0x23, 0x44, 0x4D, 0x24, 
	0x3E, 0x48, 0x23, 0x3E, 0x48, 0x27, 0x45, 0x4B, 0x18, 0x42, 0x4B, 0x27, 0x40, 0x48, 0x29, 0x4D, 
	0x4D, 0x25, 0x44, 0x4A, 0x23, 0x3E, 0x48, 0x24, 0x3E, 0x49, 0x23, 0x40, 0x4A, 0x23, 0x40, 0x4A, 
	0x28, 0x4C, 0x54, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x47, 0x4E, 0x35, 0x3F, 0x3E, 0x1B, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1C, 0x3E, 
	0x3F, 0x1D, 0x35, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1B, 0x31, 0x3B, 0x2B, 0x3C, 0x3D, 0x4E, 0x40, 0x37, 0x4E, 0x40, 
	0x37, 0x28, 0x42, 0x46, 0x0E, 0x22, 0x1F, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1A, 0x2C, 0x32, 0x11, 0x24, 0x22, 0x15, 0x27, 0x28, 0x19, 
	0x36, 0x40, 0x19, 0x35, 0x3D, 0x16, 0x35, 0x3E, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x29, 0x2C, 0x1B, 0x39, 0x45, 0x37, 0x35, 0x2A, 0x1A, 0x2C, 0x37, 0x1C, 0x2F, 0x37, 
	0x1A, 0x2A, 0x31, 0x1D, 0x3F, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3F, 0x43, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x38, 
	0x3E, 0x28, 0x4D, 0x54, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1D, 0x3F, 0x3E, 0x1A, 0x3D, 0x3B, 
	0x24, 0x3F, 0x40, 0x4D, 0x3D, 0x33, 0x37, 0x44, 0x44, 0x1E, 0x48, 0x4C, 0x1A, 0x2B, 0x32, 0x13, 
	0x12, 0x0E, 0x07, 0x03, 0x00, 0x07, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x06, 0x03, 0x09, 0x0B, 
	0x09, 0x07, 0x00, 0x00, 0x00, 0x08, 0x07, 0x06, 0x09, 0x06, 0x0B, 0x07, 0x02, 0x0B, 0x03, 0x00, 
	0x06, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x06, 0x06, 0x02, 0x14, 0x09, 0x0D, 0x03, 0x08, 0x03, 0x14, 
	0x09, 0x0D, 0x0F, 0x06, 0x06, 0x09, 0x02, 0x00, 0x07, 0x09, 0x04, 0x07, 0x08, 0x04, 0x06, 0x07, 
	0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x09, 0x0B, 0x0B, 0x06, 0x03, 0x00, 
	0x0E, 0x0D, 0x11, 0x0B, 0x0B, 0x0E, 0x09, 0x0B, 0x0E, 0x0F, 0x09, 0x0D, 0x08, 0x0C, 0x08, 0x06, 
	0x06, 0x02, 0x06, 0x07, 0x03, 0x06, 0x08, 0x04, 0x06, 0x06, 0x02, 0x0C, 0x0E, 0x12, 0x08, 0x09, 
	0x08, 0x0C, 0x0D, 0x0F, 0x0C, 0x0D, 0x0F, 0x0C, 0x0E, 0x11, 0x13, 0x08, 0x0B, 0x13, 0x08, 0x0B, 
	0x0B, 0x0F, 0x12, 0x13, 0x08, 0x09, 0x13, 0x08, 0x0C, 0x0F, 0x0C, 0x0E, 0x0D, 0x11, 0x13, 0x06, 
	0x06, 0x00, 0x0E, 0x03, 0x00, 0x06, 0x02, 0x00, 0x07, 0x07, 0x03, 0x09, 0x00, 0x00, 0x08, 0x0C, 
	0x0C, 0x14, 0x09, 0x0C, 0x0F, 0x06, 0x04, 0x0C, 0x08, 0x07, 0x0B, 0x0E, 0x12, 0x04, 0x0C, 0x08, 
	0x24, 0x47, 0x4D, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x18, 0x3D, 0x3C, 0x1F, 0x43, 0x45, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 
	0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x14, 0x27, 0x27, 0x1B, 0x2B, 0x33, 0x16, 0x3F, 0x45, 0x3C, 0x3C, 0x34, 0x4D, 0x40, 
	0x37, 0x44, 0x47, 0x44, 0x15, 0x2B, 0x34, 0x14, 0x27, 0x28, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3D, 0x14, 0x27, 0x27, 0x15, 
	0x27, 0x28, 0x19, 0x2A, 0x2E, 0x1B, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x16, 0x29, 0x2B, 0x1D, 0x2F, 0x38, 0x1B, 0x2E, 0x38, 0x1C, 0x3D, 0x40, 0x27, 0x31, 0x34, 
	0x1C, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x44, 0x42, 0x1D, 
	0x2B, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x43, 0x40, 0x1B, 0x3A, 
	0x3D, 0x1B, 0x37, 0x3D, 0x1C, 0x3A, 0x3E, 0x25, 0x48, 0x4C, 0x1B, 0x48, 0x4F, 0x1C, 0x4C, 0x56, 
	0x1F, 0x44, 0x46, 0x37, 0x36, 0x2E, 0x36, 0x3A, 0x34, 0x1A, 0x49, 0x4E, 0x1B, 0x28, 0x32, 0x33, 
	0x66, 0x71, 0x3A, 0x95, 0xA7, 0x3B, 0x95, 0xA6, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x94, 
	0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 
	0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x93, 0xA3, 0x3B, 0x93, 0xA4, 0x3A, 
	0x94, 0xA4, 0x3A, 0x93, 0xA4, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 
	0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x94, 0xA5, 
	0x3A, 0x93, 0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x94, 0xA4, 0x3A, 0x94, 0xA4, 0x3A, 0x92, 0xA3, 0x3B, 
	0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x92, 0xA3, 0x3A, 0x91, 
	0xA2, 0x3D, 0x97, 0xAC, 0x3A, 0x92, 0xA2, 0x3A, 0x92, 0xA3, 0x3A, 0x93, 0xA3, 0x39, 0x92, 0xA2, 
	0x3A, 0x91, 0xA1, 0x3D, 0x99, 0xAD, 0x39, 0x92, 0xA2, 0x3A, 0x93, 0xA3, 0x3A, 0x92, 0xA3, 0x3A, 
	0x92, 0xA3, 0x3A, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x91, 0xA2, 0x42, 0xA3, 0xB0, 0x3A, 0x91, 
	0xA2, 0x3A, 0x93, 0xA3, 0x39, 0x91, 0xA2, 0x43, 0x9C, 0xB0, 0x5C, 0xB6, 0xC5, 0x0B, 0x0F, 0x12, 
	0x24, 0x40, 0x4A, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 
	0x48, 0x4E, 0x27, 0x4A, 0x53, 0x22, 0x45, 0x49, 0x28, 0x4C, 0x56, 0x24, 0x47, 0x4B, 0x1C, 0x3C, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2E, 0x1C, 0x31, 0x3A, 0x1E, 0x31, 0x37, 0x4A, 0x3F, 
	0x35, 0x4F, 0x40, 0x39, 0x1F, 0x2F, 0x34, 0x1A, 0x2C, 0x34, 0x1B, 0x2E, 0x35, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 0x23, 0x1F, 0x31, 0x3B, 0x1C, 0x35, 0x3F, 0x15, 
	0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1A, 0x33, 0x3C, 0x1E, 0x31, 0x3A, 0x1A, 0x2A, 0x31, 0x1D, 0x3E, 0x44, 0x1C, 0x2E, 0x37, 
	0x1A, 0x2B, 0x31, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2C, 0x35, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x2A, 0x4F, 
	0x59, 0x1E, 0x40, 0x43, 0x1C, 0x37, 0x3E, 0x1F, 0x3D, 0x44, 0x29, 0x4C, 0x56, 0x1D, 0x49, 0x53, 
	0x1D, 0x42, 0x43, 0x35, 0x49, 0x4C, 0x33, 0x3D, 0x3A, 0x1B, 0x46, 0x4D, 0x19, 0x29, 0x32, 0x3B, 
	0x77, 0x84, 0x3C, 0xA1, 0xBB, 0x40, 0xA4, 0xBD, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBB, 0x40, 0xA2, 
	0xBC, 0x40, 0xA2, 0xBC, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBC, 0x3F, 0xA1, 0xBB, 0x44, 0xAA, 0xC2, 
	0x44, 0xAA, 0xC2, 0x3F, 0xA0, 0xBA, 0x44, 0xA9, 0xC1, 0x46, 0xB1, 0xC5, 0x47, 0xB2, 0xC6, 0x3E, 
	0x9F, 0xB9, 0x47, 0xB3, 0xC7, 0x3F, 0xA0, 0xBA, 0x3F, 0xA0, 0xBA, 0x47, 0xB2, 0xC5, 0x46, 0xB1, 
	0xC5, 0x43, 0xA8, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 0xB1, 0xC5, 0x43, 0xA8, 0xC0, 0x43, 0xA8, 0xC0, 
	0x47, 0xB2, 0xC5, 0x43, 0xA8, 0xC0, 0x44, 0xA9, 0xC1, 0x43, 0xA9, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 
	0xB1, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB1, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 
	0xCD, 0x49, 0xBA, 0xCC, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 0xCD, 
	0x49, 0xBB, 0xCD, 0x45, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x45, 0xAF, 0xC4, 0x4A, 
	0xBC, 0xCE, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC4, 0x45, 0xB5, 0xC9, 0x4C, 0xC0, 0xCF, 0x45, 0xB2, 
	0xC6, 0x46, 0xAF, 0xC4, 0x4A, 0xBE, 0xCF, 0x40, 0xA3, 0xBE, 0x43, 0xA7, 0xBB, 0x0C, 0x0E, 0x11, 
	0x23, 0x3D, 0x47, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 
	0x35, 0x38, 0x28, 0x4C, 0x55, 0x1D, 0x40, 0x42, 0x2A, 0x4A, 0x51, 0x1E, 0x3C, 0x45, 0x1C, 0x40, 
	0x3F, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x44, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1E, 0x2F, 0x39, 0x13, 0x25, 0x25, 0x1D, 0x32, 0x3B, 0x18, 0x3E, 0x44, 0x3C, 0x3B, 
	0x33, 0x57, 0x4B, 0x3F, 0x30, 0x3F, 0x44, 0x1A, 0x2E, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2A, 0x2F, 0x18, 
	0x2A, 0x2F, 0x1B, 0x2E, 0x34, 0x1E, 0x30, 0x39, 0x13, 0x26, 0x25, 0x1C, 0x30, 0x39, 0x28, 0x33, 
	0x35, 0x1A, 0x2C, 0x34, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 
	0x30, 0x39, 0x1D, 0x37, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x1E, 0x43, 
	0x43, 0x2A, 0x4E, 0x59, 0x1B, 0x3F, 0x3D, 0x1B, 0x3D, 0x3F, 0x27, 0x39, 0x3B, 0x34, 0x57, 0x56, 
	0x1B, 0x42, 0x44, 0x1A, 0x3E, 0x3E, 0x37, 0x3A, 0x34, 0x12, 0x40, 0x48, 0x1A, 0x2A, 0x33, 0x3A, 
	0x75, 0x81, 0x3B, 0x9D, 0xB6, 0x47, 0xB3, 0xC5, 0x4B, 0xC3, 0xD2, 0x4B, 0xC0, 0xCF, 0x48, 0xB5, 
	0xC6, 0x48, 0xB5, 0xC6, 0x4B, 0xC0, 0xCF, 0x4B, 0xBC, 0xCB, 0x4B, 0xC0, 0xCF, 0x4A, 0xBC, 0xCB, 
	0x4A, 0xBB, 0xCA, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4A, 0xBF, 0xCF, 0x4B, 
	0xC0, 0xCF, 0x4A, 0xC3, 0xD3, 0x4B, 0xC0, 0xCF, 0x4B, 0xC0, 0xCF, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 
	0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 0xD2, 0x4A, 0xBD, 0xCC, 0x4A, 0xBD, 0xCC, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4A, 0xC4, 0xD3, 0x4F, 0xC5, 0xD9, 
	0x4D, 0xC4, 0xD5, 0x49, 0xC4, 0xD3, 0x4D, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4C, 
	0xC3, 0xD5, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4D, 0xC4, 0xD5, 0x49, 0xC3, 0xD3, 0x4A, 0xC4, 
	0xD3, 0x4A, 0xC5, 0xD4, 0x4B, 0xC3, 0xD1, 0x3A, 0x98, 0xB2, 0x3B, 0x94, 0xA4, 0x06, 0x08, 0x03, 
	0x28, 0x48, 0x4E, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4B, 0x54, 0x27, 0x4A, 0x53, 0x1C, 0x42, 0x42, 0x35, 0x3E, 0x3D, 0x20, 0x3F, 0x3D, 0x1C, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3F, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x3E, 0x43, 0x1C, 0x42, 0x3F, 0x1D, 0x3A, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x3D, 0x44, 0x1D, 0x3B, 0x42, 0x1D, 0x2C, 0x36, 0x1B, 0x3C, 0x44, 0x25, 0x33, 
	0x36, 0x53, 0x48, 0x3D, 0x4D, 0x42, 0x36, 0x1A, 0x28, 0x28, 0x18, 0x2A, 0x30, 0x1A, 0x2C, 0x32, 
	0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 
	0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x2F, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x43, 0x1D, 0x2A, 0x34, 0x1D, 0x38, 0x3F, 0x1D, 
	0x3D, 0x42, 0x1D, 0x44, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x40, 0x3E, 0x20, 0x45, 0x46, 0x1C, 0x33, 
	0x3E, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 0x3F, 0x3E, 0x25, 0x43, 0x46, 0x32, 0x50, 0x4F, 
	0x2B, 0x40, 0x44, 0x48, 0x4C, 0x4D, 0x4D, 0x3D, 0x34, 0x1D, 0x34, 0x3D, 0x14, 0x29, 0x2F, 0x3A, 
	0x75, 0x82, 0x3B, 0x9C, 0xB5, 0x49, 0xBB, 0xCC, 0x4A, 0xBF, 0xCF, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xB9, 0xC9, 
	0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x49, 0xBE, 0xD0, 0x46, 0xB5, 0xCB, 0x4B, 0xC6, 0xD5, 0x4A, 
	0xC4, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC4, 0xD4, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x4A, 0xC4, 0xD2, 0x52, 0xBE, 0xD9, 
	0x48, 0xBE, 0xD0, 0x4C, 0xC3, 0xD4, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4C, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 
	0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC3, 0xD1, 0x34, 0x8C, 0xA6, 0x3B, 0x95, 0xA4, 0x0E, 0x11, 0x14, 
	0x1C, 0x44, 0x4D, 0x28, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1B, 0x40, 0x40, 0x2A, 0x4D, 0x59, 0x1B, 0x3F, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3E, 0x43, 0x1C, 0x29, 0x34, 0x20, 0x45, 0x49, 0x1C, 0x43, 0x40, 0x1E, 0x30, 0x39, 0x1D, 
	0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x16, 0x2B, 
	0x37, 0x4C, 0x42, 0x36, 0x5C, 0x51, 0x4B, 0x2A, 0x3E, 0x3F, 0x0E, 0x22, 0x20, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2F, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1A, 0x2A, 0x30, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x1D, 
	0x3B, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x1C, 0x47, 0x4C, 0x25, 0x47, 0x4C, 0x1C, 0x40, 
	0x3E, 0x1C, 0x3F, 0x3E, 0x22, 0x45, 0x4A, 0x20, 0x46, 0x4B, 0x19, 0x3A, 0x3C, 0x26, 0x48, 0x50, 
	0x38, 0x40, 0x3E, 0x2B, 0x51, 0x51, 0x45, 0x47, 0x44, 0x32, 0x31, 0x29, 0x1F, 0x1E, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 
	0x4A, 0xC5, 0xD4, 0x49, 0xC0, 0xD4, 0x37, 0x82, 0x93, 0x31, 0x69, 0x78, 0x46, 0xB8, 0xD0, 0x4B, 
	0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 
	0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x50, 0xC5, 0xD7, 0x4D, 0xB8, 0xD0, 0x00, 0x00, 0x00, 
	0x3B, 0x9C, 0xB1, 0x59, 0xCD, 0xE4, 0x48, 0xC5, 0xD4, 0x4F, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB1, 0x42, 0xA1, 0xB7, 0x06, 0x08, 0x03, 
	0x28, 0x42, 0x48, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x1B, 0x3B, 
	0x3D, 0x1D, 0x40, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2E, 0x37, 0x1E, 0x3E, 0x42, 0x0F, 0x39, 0x43, 0x1B, 
	0x31, 0x39, 0x1B, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x12, 0x35, 
	0x3F, 0x3C, 0x36, 0x2A, 0x4F, 0x44, 0x39, 0x3F, 0x42, 0x44, 0x1B, 0x31, 0x36, 0x19, 0x2E, 0x35, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3D, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1A, 0x32, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1C, 0x3A, 0x3E, 0x1D, 0x39, 0x3D, 0x1D, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 
	0x3F, 0x1E, 0x42, 0x44, 0x28, 0x4E, 0x56, 0x3D, 0x4C, 0x4B, 0x22, 0x43, 0x45, 0x16, 0x48, 0x4F, 
	0x23, 0x48, 0x4F, 0x20, 0x48, 0x50, 0x23, 0x4D, 0x57, 0x25, 0x39, 0x40, 0x14, 0x28, 0x2E, 0x3A, 
	0x75, 0x82, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC6, 0xD5, 
	0x4F, 0xC0, 0xD7, 0x36, 0x6E, 0x7B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x2C, 0x52, 0x58, 0x46, 
	0xB9, 0xD0, 0x4B, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xBA, 0xCA, 
	0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 0x4A, 0xBC, 0xCC, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 
	0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC3, 0xD2, 0x4B, 0xC2, 0xD4, 0x2F, 0x76, 0x82, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x24, 0x51, 0x5B, 0x4F, 0xBF, 0xD5, 0x50, 0xC8, 0xD9, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x54, 0xC2, 0xDC, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3E, 0x9B, 0xAE, 0x07, 0x09, 0x04, 
	0x24, 0x45, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x53, 0x1F, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x2A, 0x4D, 
	0x58, 0x1A, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x38, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x43, 0x1D, 0x2B, 0x35, 0x18, 0x34, 0x3C, 0x1B, 
	0x31, 0x39, 0x11, 0x3B, 0x44, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 
	0x36, 0x25, 0x34, 0x38, 0x4D, 0x40, 0x37, 0x4D, 0x40, 0x36, 0x31, 0x3B, 0x36, 0x2B, 0x2E, 0x30, 
	0x1D, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x39, 0x1A, 0x2B, 0x31, 0x1D, 0x36, 0x3F, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3D, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1C, 
	0x3A, 0x3E, 0x28, 0x4B, 0x52, 0x1B, 0x4C, 0x56, 0x1C, 0x47, 0x4B, 0x20, 0x44, 0x46, 0x1B, 0x3E, 
	0x3D, 0x20, 0x45, 0x49, 0x29, 0x45, 0x4A, 0x49, 0x3E, 0x39, 0x2E, 0x3B, 0x39, 0x39, 0x50, 0x53, 
	0x28, 0x48, 0x4B, 0x37, 0x35, 0x2A, 0x36, 0x43, 0x45, 0x1A, 0x46, 0x4C, 0x19, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC4, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC8, 0xD7, 0x4C, 0xB5, 0xCE, 
	0x0B, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x07, 0x04, 0x04, 0x06, 0x03, 0x03, 0x03, 0x04, 0x00, 0x42, 
	0x98, 0xAB, 0x49, 0xC0, 0xD2, 0x4A, 0xC3, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBD, 0xCD, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD4, 0x51, 0xC7, 0xDC, 0x40, 0xA7, 0xBB, 0x02, 0x03, 0x02, 0x07, 0x03, 0x03, 
	0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x0E, 0x29, 0x2E, 0x4B, 0xB2, 0xC9, 0x4B, 0xC6, 0xD6, 0x4C, 
	0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4D, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD0, 0x3A, 0x98, 0xB2, 0x3B, 0x95, 0xA5, 0x07, 0x09, 0x06, 
	0x24, 0x44, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1B, 0x3E, 0x3D, 0x23, 0x46, 
	0x4B, 0x1B, 0x3F, 0x3D, 0x1B, 0x3B, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x40, 0x40, 0x1D, 0x2F, 0x38, 0x1B, 0x31, 0x39, 0x1E, 
	0x2F, 0x37, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3D, 
	0x43, 0x15, 0x3B, 0x44, 0x50, 0x42, 0x37, 0x52, 0x49, 0x3E, 0x34, 0x3A, 0x33, 0x27, 0x31, 0x31, 
	0x18, 0x32, 0x3B, 0x1E, 0x30, 0x39, 0x14, 0x27, 0x28, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x18, 
	0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x3A, 
	0x43, 0x1D, 0x31, 0x39, 0x1D, 0x2C, 0x36, 0x1D, 0x43, 0x43, 0x1A, 0x2E, 0x38, 0x1D, 0x38, 0x42, 
	0x1D, 0x3D, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 
	0x36, 0x40, 0x1B, 0x3C, 0x3D, 0x24, 0x46, 0x4B, 0x1C, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4B, 0x27, 0x4B, 0x55, 0x27, 0x46, 0x4B, 0x4F, 0x3F, 0x35, 0x4D, 0x3E, 0x34, 0x3E, 0x3A, 0x36, 
	0x54, 0x53, 0x4F, 0x46, 0x3A, 0x39, 0x45, 0x48, 0x48, 0x3C, 0x50, 0x51, 0x1E, 0x1B, 0x1D, 0x3A, 
	0x76, 0x83, 0x3B, 0x9C, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC7, 0xD6, 0x4C, 0xB5, 0xCE, 0x0C, 0x0D, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x0F, 
	0x25, 0x27, 0x50, 0xBE, 0xD5, 0x4A, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC5, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 0xC2, 0xD7, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x4B, 0xC3, 0xD4, 0x4E, 0xC4, 0xD8, 0x30, 0x6C, 0x79, 0x02, 0x03, 0x00, 0x07, 0x06, 0x06, 
	0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x07, 0x00, 0x00, 0x00, 0x13, 0x22, 0x23, 0x47, 0xB1, 0xC8, 0x54, 
	0xC6, 0xDF, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4F, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x09, 0x06, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x43, 0x1A, 0x3D, 
	0x3C, 0x23, 0x46, 0x4B, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1B, 
	0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 
	0x39, 0x19, 0x2C, 0x37, 0x3D, 0x37, 0x2A, 0x4D, 0x42, 0x39, 0x36, 0x35, 0x2F, 0x38, 0x2E, 0x27, 
	0x18, 0x32, 0x3C, 0x1B, 0x2B, 0x31, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x1A, 
	0x2C, 0x32, 0x1D, 0x35, 0x3D, 0x1D, 0x38, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 
	0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1A, 0x45, 0x43, 0x3B, 0x35, 0x2B, 0x1A, 0x38, 0x43, 
	0x1D, 0x31, 0x3A, 0x1D, 0x40, 0x40, 0x1A, 0x39, 0x40, 0x1D, 0x39, 0x40, 0x1D, 0x44, 0x40, 0x1D, 
	0x35, 0x40, 0x1D, 0x43, 0x40, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4A, 0x28, 0x4B, 0x54, 0x29, 0x46, 0x4B, 0x44, 0x3B, 0x30, 0x50, 0x52, 0x53, 0x20, 0x19, 0x15, 
	0x4F, 0x49, 0x3E, 0x50, 0x45, 0x3D, 0x47, 0x4B, 0x49, 0x2E, 0x5A, 0x5C, 0x15, 0x28, 0x32, 0x3B, 
	0x76, 0x82, 0x3B, 0x9D, 0xB6, 0x46, 0xAE, 0xC3, 0x4A, 0xBB, 0xCB, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 
	0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC5, 0xD4, 0x4E, 0xBB, 0xD1, 0x0B, 0x0B, 0x08, 0x00, 0x00, 0x00, 
	0x0C, 0x0F, 0x0F, 0x0B, 0x0E, 0x0E, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x08, 0x09, 0x09, 0x00, 
	0x00, 0x00, 0x2F, 0x68, 0x76, 0x4B, 0xC3, 0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC1, 
	0xD5, 0x54, 0xCC, 0xE0, 0x3A, 0x8C, 0x9C, 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x07, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x12, 0x18, 0x15, 0x4A, 
	0xB5, 0xCB, 0x51, 0xC6, 0xDC, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xDC, 0x51, 0xC2, 
	0xD3, 0x47, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x0D, 0x02, 0x00, 
	0x29, 0x4A, 0x4E, 0x2E, 0x50, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x19, 0x43, 0x45, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x23, 0x46, 
	0x4A, 0x29, 0x4C, 0x56, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1D, 0x2E, 0x36, 0x1B, 0x33, 0x3C, 0x53, 0x44, 0x39, 0x37, 0x32, 0x2F, 0x2B, 0x2F, 0x2B, 
	0x16, 0x32, 0x3D, 0x15, 0x39, 0x43, 0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x3F, 0x43, 0x1A, 0x31, 0x3B, 0x1D, 0x39, 0x42, 
	0x1D, 0x31, 0x3A, 0x1A, 0x3C, 0x40, 0x38, 0x44, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x36, 0x40, 0x1D, 
	0x44, 0x40, 0x1D, 0x37, 0x40, 0x1C, 0x40, 0x3E, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 0x3E, 0x24, 0x46, 
	0x4A, 0x18, 0x4B, 0x55, 0x1C, 0x46, 0x4C, 0x45, 0x3B, 0x31, 0x90, 0x89, 0x82, 0x54, 0x4E, 0x42, 
	0x43, 0x3B, 0x33, 0x4F, 0x46, 0x3C, 0x61, 0x52, 0x48, 0x4E, 0x75, 0x82, 0x1A, 0x1E, 0x22, 0x34, 
	0x70, 0x7B, 0x3B, 0x9D, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 
	0xCB, 0x4A, 0xC5, 0xD5, 0x4B, 0xC5, 0xD8, 0x26, 0x53, 0x5E, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x03, 0x03, 0x06, 0x09, 0x09, 0x43, 0xAB, 0xC0, 0x4C, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x49, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC5, 
	0xD8, 0x55, 0xC1, 0xDA, 0x03, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 
	0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x13, 
	0x18, 0x15, 0x47, 0xB0, 0xC7, 0x51, 0xC5, 0xDA, 0x4B, 0xC2, 0xD4, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 
	0xD1, 0x4F, 0xC2, 0xD7, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x28, 
	0x46, 0x4D, 0x2E, 0x44, 0x47, 0x1A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x29, 0x4B, 0x54, 0x19, 0x3C, 
	0x38, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x42, 0x42, 0x1D, 0x2F, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1E, 0x32, 0x3A, 0x19, 0x2E, 0x38, 0x38, 0x3B, 0x32, 0x38, 0x3A, 0x2F, 0x3B, 0x2F, 0x31, 
	0x29, 0x28, 0x25, 0x13, 0x26, 0x27, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2B, 0x35, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3D, 0x42, 0x1C, 0x3E, 0x3F, 0x1A, 0x35, 0x40, 0x1D, 0x37, 0x40, 0x1D, 0x37, 0x40, 0x1D, 
	0x3B, 0x40, 0x1B, 0x40, 0x3D, 0x23, 0x46, 0x4A, 0x20, 0x43, 0x4B, 0x18, 0x38, 0x3D, 0x23, 0x44, 
	0x46, 0x30, 0x46, 0x49, 0x47, 0x45, 0x3F, 0x28, 0x29, 0x1F, 0x65, 0x62, 0x5D, 0x61, 0x57, 0x4D, 
	0x32, 0x2E, 0x2C, 0x36, 0x36, 0x2C, 0x51, 0x48, 0x3E, 0x5B, 0x52, 0x4A, 0x1F, 0x28, 0x27, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4A, 0xBB, 0xCB, 0x4A, 0xB8, 0xC8, 0x4A, 0xC5, 
	0xD4, 0x4C, 0xC4, 0xD7, 0x2F, 0x74, 0x80, 0x07, 0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x02, 0x00, 0x1D, 0x43, 0x49, 0x47, 0xBA, 0xD1, 0x4B, 0xC0, 0xCF, 0x4A, 0xB6, 
	0xC6, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD6, 0x4F, 0xC3, 
	0xDB, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 
	0x00, 0x00, 0x15, 0x29, 0x2E, 0x4F, 0xBC, 0xD3, 0x4F, 0xC5, 0xD9, 0x4A, 0xC2, 0xD3, 0x4C, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC1, 0xD4, 0x3C, 0x9D, 0xB6, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x43, 0x4A, 0x27, 0x4B, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x49, 0x52, 0x38, 
	0x54, 0x52, 0x2B, 0x44, 0x48, 0x1D, 0x4B, 0x54, 0x1A, 0x4A, 0x53, 0x1E, 0x47, 0x4D, 0x2A, 0x4D, 
	0x57, 0x19, 0x3C, 0x39, 0x1C, 0x3F, 0x3F, 0x20, 0x44, 0x46, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3D, 0x42, 0x1D, 0x3F, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1E, 0x2F, 0x37, 0x1B, 0x32, 
	0x3A, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1E, 0x3A, 0x43, 0x38, 0x31, 0x2B, 0x38, 0x2E, 0x30, 
	0x3D, 0x3C, 0x30, 0x19, 0x2F, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x31, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x43, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x36, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x3C, 0x3F, 0x20, 0x44, 0x46, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1C, 0x3A, 0x3F, 0x1C, 
	0x40, 0x3E, 0x23, 0x47, 0x4B, 0x27, 0x4C, 0x57, 0x35, 0x4F, 0x4E, 0x3A, 0x47, 0x47, 0x29, 0x39, 
	0x35, 0x51, 0x42, 0x37, 0x47, 0x3F, 0x38, 0x34, 0x30, 0x2B, 0x69, 0x5F, 0x4F, 0x6F, 0x69, 0x58, 
	0x6A, 0x62, 0x54, 0x45, 0x3E, 0x37, 0x48, 0x3C, 0x34, 0x58, 0x4D, 0x43, 0x1F, 0x29, 0x28, 0x39, 
	0x75, 0x82, 0x3B, 0x9D, 0xB6, 0x45, 0xAB, 0xC0, 0x4A, 0xC5, 0xD5, 0x4A, 0xBA, 0xCA, 0x4C, 0xC8, 
	0xD8, 0x42, 0x9A, 0xAE, 0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x00, 0x00, 0x00, 0x42, 0x9B, 0xAE, 0x49, 0xC0, 0xD3, 0x4A, 0xC4, 
	0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x4A, 0xC0, 0xD0, 0x4A, 0xBC, 0xCC, 
	0x4A, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC6, 0xDA, 0x48, 0xB2, 
	0xC5, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x00, 0x00, 0x00, 0x25, 0x52, 0x5C, 0x52, 0xC6, 0xDE, 0x55, 0xC3, 0xDA, 0x47, 0xC2, 
	0xD0, 0x4F, 0xC2, 0xD6, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3B, 0x95, 0xA5, 0x0D, 0x00, 0x00, 
	0x29, 0x57, 0x5A, 0x26, 0x48, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x25, 0x4A, 0x54, 0x31, 
	0x3B, 0x39, 0x2E, 0x40, 0x43, 0x2C, 0x44, 0x47, 0x2B, 0x48, 0x4F, 0x1E, 0x42, 0x43, 0x20, 0x44, 
	0x47, 0x29, 0x4C, 0x57, 0x1A, 0x3D, 0x3A, 0x25, 0x48, 0x4D, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2A, 0x34, 0x18, 0x32, 0x3B, 0x1E, 0x3A, 0x43, 0x1D, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x1E, 0x30, 
	0x38, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x38, 0x13, 0x35, 0x3F, 0x33, 0x2B, 0x22, 0x39, 0x30, 0x31, 
	0x34, 0x2E, 0x29, 0x23, 0x2F, 0x2F, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x3B, 0x45, 0x1A, 
	0x29, 0x30, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x2E, 0x38, 0x22, 0x49, 0x4D, 0x37, 0x3F, 0x3D, 0x20, 0x46, 0x4B, 0x20, 0x44, 0x46, 0x1A, 
	0x3F, 0x3E, 0x23, 0x43, 0x45, 0x13, 0x38, 0x3B, 0x42, 0x3C, 0x34, 0x50, 0x40, 0x3D, 0x3E, 0x39, 
	0x30, 0x54, 0x4B, 0x43, 0x78, 0x73, 0x6E, 0x4E, 0x45, 0x3C, 0x68, 0x5F, 0x4F, 0x61, 0x5F, 0x5F, 
	0x73, 0x6A, 0x59, 0x62, 0x58, 0x4E, 0x40, 0x46, 0x44, 0x4E, 0x45, 0x39, 0x1A, 0x1D, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC1, 0xD0, 0x4A, 0xB9, 0xC9, 0x4A, 0xC6, 0xD5, 0x51, 0xBF, 
	0xD6, 0x03, 0x04, 0x03, 0x02, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x13, 0x25, 0x27, 0x4A, 0xB9, 0xCE, 0x4B, 0xC0, 
	0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x55, 0xCB, 0xE2, 0x29, 0x56, 
	0x60, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x07, 0x08, 0x08, 0x00, 0x00, 0x00, 0x36, 0x86, 0x92, 0x51, 0xCA, 0xDF, 0x4E, 0xC2, 
	0xD3, 0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x39, 0x96, 0xB0, 0x3C, 0x96, 0xA6, 0x06, 0x0B, 0x07, 
	0x26, 0x45, 0x4D, 0x26, 0x49, 0x53, 0x33, 0x55, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4C, 0x52, 0x23, 
	0x49, 0x54, 0x29, 0x50, 0x54, 0x25, 0x4A, 0x54, 0x2A, 0x48, 0x4E, 0x1A, 0x3D, 0x3B, 0x28, 0x4B, 
	0x55, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3E, 0x3C, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1E, 
	0x3D, 0x42, 0x11, 0x38, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x3F, 0x42, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x39, 0x30, 0x2B, 0x38, 0x2F, 0x30, 
	0x39, 0x3B, 0x31, 0x3B, 0x3A, 0x31, 0x1C, 0x30, 0x38, 0x16, 0x2E, 0x33, 0x1E, 0x2C, 0x35, 0x1D, 
	0x3E, 0x44, 0x1D, 0x39, 0x43, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x34, 0x3D, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x19, 0x3C, 0x3D, 0x2A, 0x4E, 0x59, 0x19, 0x3E, 0x3D, 0x25, 
	0x3E, 0x3E, 0x4C, 0x4E, 0x4D, 0x2E, 0x3F, 0x3F, 0x52, 0x3F, 0x37, 0x38, 0x37, 0x2E, 0x4D, 0x3F, 
	0x36, 0x51, 0x4A, 0x3D, 0x84, 0x7C, 0x74, 0x4F, 0x47, 0x3F, 0x54, 0x4C, 0x44, 0x4E, 0x45, 0x3F, 
	0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4B, 0x5C, 0x52, 0x4A, 0x47, 0x43, 0x37, 0x1B, 0x1E, 0x24, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC4, 0xD4, 0x4A, 0xC0, 0xD3, 0x2F, 0x75, 
	0x81, 0x02, 0x00, 0x00, 0x07, 0x06, 0x06, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x00, 0x00, 0x32, 0x66, 0x73, 0x4B, 0xC4, 
	0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x49, 0xBF, 0xCE, 0x4C, 0xC2, 0xD4, 0x54, 0xCC, 0xE0, 0x3A, 0x8B, 0x9B, 0x00, 0x00, 
	0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x08, 0x07, 0x13, 0x1A, 0x1C, 0x4B, 0xB9, 0xD0, 0x51, 0xC5, 
	0xDB, 0x54, 0xC2, 0xDC, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x31, 0x54, 0x52, 0x35, 
	0x52, 0x51, 0x48, 0x49, 0x48, 0x29, 0x4A, 0x4E, 0x27, 0x4B, 0x56, 0x1A, 0x42, 0x43, 0x28, 0x4A, 
	0x53, 0x27, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1A, 0x3D, 0x3B, 0x1C, 0x40, 0x3F, 0x1E, 0x40, 0x3E, 
	0x1D, 0x49, 0x4D, 0x1D, 0x39, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 
	0x3C, 0x40, 0x1E, 0x36, 0x40, 0x1F, 0x3E, 0x40, 0x1D, 0x38, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x12, 0x35, 0x3E, 0x3C, 0x2F, 0x2F, 0x33, 0x30, 0x2A, 
	0x2E, 0x2F, 0x25, 0x2F, 0x2F, 0x26, 0x20, 0x2E, 0x32, 0x12, 0x3C, 0x44, 0x15, 0x36, 0x3E, 0x1B, 
	0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x1A, 0x37, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3C, 0x3D, 0x1B, 0x40, 0x3D, 0x1F, 0x40, 0x40, 0x32, 
	0x42, 0x43, 0x20, 0x3F, 0x40, 0x22, 0x3D, 0x3E, 0x33, 0x57, 0x58, 0x32, 0x37, 0x31, 0x30, 0x44, 
	0x49, 0x4E, 0x40, 0x39, 0x56, 0x4C, 0x3D, 0x51, 0x49, 0x3E, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3A, 
	0x4B, 0x42, 0x3F, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4A, 0x48, 0x3A, 0x32, 0x1C, 0x1E, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4D, 0xB8, 0xD0, 0x04, 0x09, 
	0x08, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 
	0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x09, 0x43, 0xAC, 
	0xC1, 0x4B, 0xC5, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC5, 0xD3, 0x55, 0xC1, 0xDB, 0x03, 0x06, 0x04, 0x03, 0x00, 
	0x00, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x2E, 0x63, 0x70, 0x53, 0xC7, 
	0xDF, 0x48, 0xC3, 0xD1, 0x4D, 0xC1, 0xD2, 0x3C, 0x9C, 0xB5, 0x3E, 0x9B, 0xAE, 0x06, 0x08, 0x06, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x52, 0x33, 0x55, 0x52, 0x2B, 0x48, 0x4D, 0x28, 
	0x43, 0x48, 0x40, 0x47, 0x46, 0x29, 0x44, 0x49, 0x28, 0x40, 0x42, 0x19, 0x3D, 0x3B, 0x27, 0x4D, 
	0x57, 0x1C, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x2C, 0x4F, 0x57, 0x1A, 0x3F, 0x44, 0x0D, 0x34, 0x3F, 
	0x18, 0x3A, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 
	0x35, 0x40, 0x1F, 0x40, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 
	0x36, 0x1D, 0x3B, 0x44, 0x1B, 0x2C, 0x37, 0x1F, 0x33, 0x3B, 0x3A, 0x31, 0x2E, 0x39, 0x2F, 0x31, 
	0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x3D, 0x31, 0x2E, 0x23, 0x42, 0x3D, 0x0F, 0x38, 0x42, 0x18, 
	0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x48, 
	0x44, 0x1B, 0x2E, 0x38, 0x19, 0x2B, 0x36, 0x27, 0x3E, 0x43, 0x0E, 0x38, 0x3F, 0x0F, 0x34, 0x3E, 
	0x1E, 0x42, 0x40, 0x1C, 0x3C, 0x3D, 0x2B, 0x50, 0x5A, 0x18, 0x33, 0x3E, 0x2E, 0x40, 0x3E, 0x38, 
	0x35, 0x2A, 0x36, 0x38, 0x31, 0x3F, 0x45, 0x44, 0x25, 0x45, 0x4C, 0x34, 0x50, 0x50, 0x20, 0x40, 
	0x44, 0x3E, 0x40, 0x42, 0x3B, 0x3E, 0x3B, 0x4C, 0x42, 0x42, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 
	0x50, 0x48, 0x3D, 0x5C, 0x53, 0x4B, 0x5F, 0x56, 0x4F, 0x24, 0x43, 0x47, 0x16, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD1, 0x4A, 0xC2, 0xD4, 0x39, 0x8A, 0x97, 0x00, 0x00, 
	0x00, 0x03, 0x02, 0x02, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0F, 0x0F, 
	0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x15, 0x35, 
	0x38, 0x4E, 0xBF, 0xD9, 0x4D, 0xC5, 0xD6, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x4E, 0xC3, 0xD6, 0x50, 0xC3, 0xDC, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 
	0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x07, 0x06, 0x07, 0x02, 0x43, 0xA1, 
	0xB2, 0x4D, 0xC7, 0xD9, 0x50, 0xC5, 0xD8, 0x39, 0x96, 0xAF, 0x3E, 0x9B, 0xAF, 0x06, 0x09, 0x06, 
	0x26, 0x45, 0x4C, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x1F, 0x4A, 0x53, 0x29, 
	0x46, 0x4D, 0x35, 0x52, 0x50, 0x28, 0x4E, 0x53, 0x3E, 0x4F, 0x4E, 0x1E, 0x46, 0x4B, 0x33, 0x3D, 
	0x3C, 0x2B, 0x43, 0x46, 0x20, 0x46, 0x4B, 0x33, 0x51, 0x4F, 0x39, 0x50, 0x4F, 0x32, 0x3C, 0x38, 
	0x14, 0x44, 0x4F, 0x1D, 0x3A, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 0x40, 0x1E, 
	0x36, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x31, 
	0x39, 0x18, 0x30, 0x39, 0x2E, 0x34, 0x32, 0x2C, 0x43, 0x40, 0x39, 0x39, 0x2E, 0x36, 0x37, 0x2E, 
	0x2C, 0x2E, 0x24, 0x37, 0x2F, 0x2F, 0x33, 0x2E, 0x29, 0x3B, 0x39, 0x33, 0x15, 0x30, 0x3B, 0x18, 
	0x36, 0x3F, 0x1A, 0x43, 0x42, 0x1D, 0x35, 0x3E, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 
	0x35, 0x35, 0x45, 0x43, 0x33, 0x3F, 0x3C, 0x42, 0x44, 0x3D, 0x45, 0x4C, 0x4C, 0x1B, 0x4D, 0x55, 
	0x12, 0x3A, 0x40, 0x16, 0x3E, 0x42, 0x15, 0x3F, 0x3F, 0x22, 0x43, 0x44, 0x37, 0x34, 0x29, 0x50, 
	0x44, 0x3B, 0x36, 0x36, 0x2E, 0x35, 0x35, 0x2B, 0x38, 0x34, 0x28, 0x40, 0x4C, 0x4B, 0x3A, 0x4D, 
	0x4E, 0x32, 0x38, 0x37, 0x2B, 0x23, 0x1B, 0x46, 0x3E, 0x35, 0x4F, 0x47, 0x3C, 0x5D, 0x55, 0x4D, 
	0x52, 0x4A, 0x42, 0x62, 0x57, 0x4D, 0x3E, 0x57, 0x58, 0x2C, 0x50, 0x52, 0x1B, 0x22, 0x28, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4C, 0xB6, 0xCE, 0x03, 0x07, 0x06, 0x07, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0E, 0x0E, 0x0B, 0x09, 0x09, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x08, 0x08, 0x00, 0x00, 
	0x00, 0x3B, 0x8E, 0x9E, 0x4A, 0xC3, 0xD4, 0x4A, 0xC3, 0xD2, 0x49, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 
	0x54, 0xC2, 0xDC, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x52, 0xC6, 0xDB, 0x48, 0xB2, 0xC6, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00, 0x04, 0x04, 
	0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x02, 0x00, 0x2A, 0x67, 
	0x74, 0x56, 0xC8, 0xDF, 0x4F, 0xC1, 0xD4, 0x3F, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x2B, 0x58, 0x5F, 0x2C, 0x4E, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x1B, 
	0x49, 0x52, 0x32, 0x54, 0x52, 0x31, 0x53, 0x52, 0x30, 0x53, 0x53, 0x1D, 0x47, 0x4F, 0x33, 0x3F, 
	0x3E, 0x18, 0x3E, 0x3D, 0x19, 0x3F, 0x3E, 0x1C, 0x3E, 0x44, 0x22, 0x3F, 0x46, 0x38, 0x3C, 0x38, 
	0x1A, 0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x34, 0x40, 0x1E, 
	0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1E, 0x2B, 0x35, 0x19, 0x31, 
	0x39, 0x1E, 0x38, 0x3F, 0x39, 0x2E, 0x2A, 0x39, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x36, 0x34, 0x2E, 
	0x39, 0x3A, 0x31, 0x38, 0x30, 0x30, 0x31, 0x2F, 0x28, 0x3A, 0x35, 0x32, 0x34, 0x2F, 0x25, 0x33, 
	0x2C, 0x2C, 0x15, 0x35, 0x42, 0x1E, 0x3E, 0x40, 0x1E, 0x43, 0x42, 0x1D, 0x30, 0x39, 0x1A, 0x2F, 
	0x38, 0x1F, 0x42, 0x43, 0x36, 0x3B, 0x3A, 0x2F, 0x24, 0x1C, 0x35, 0x35, 0x2A, 0x3B, 0x37, 0x2B, 
	0x3C, 0x37, 0x2C, 0x33, 0x3C, 0x39, 0x4B, 0x3D, 0x34, 0x4E, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x33, 0x35, 0x2C, 0x4F, 0x43, 0x3A, 0x39, 0x38, 0x2F, 0x38, 0x39, 0x35, 0x5E, 0x59, 
	0x55, 0x6C, 0x61, 0x54, 0x31, 0x2C, 0x27, 0x3F, 0x3B, 0x38, 0x4E, 0x46, 0x42, 0x51, 0x49, 0x3E, 
	0x51, 0x49, 0x3F, 0x4E, 0x44, 0x3B, 0x2B, 0x40, 0x42, 0x2E, 0x40, 0x3F, 0x1A, 0x25, 0x2B, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4D, 0xC5, 0xD4, 0x3D, 0x9B, 0xA9, 0x03, 0x03, 0x00, 0x03, 0x02, 
	0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x09, 0x08, 
	0x08, 0x0C, 0x0F, 0x0D, 0x47, 0xAB, 0xC2, 0x4D, 0xC7, 0xD9, 0x4C, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4E, 
	0xC3, 0xD4, 0x51, 0xC3, 0xDB, 0x26, 0x4D, 0x53, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x0B, 0x09, 0x0D, 0x0E, 
	0x0F, 0x4E, 0xB7, 0xCD, 0x50, 0xC6, 0xDA, 0x3F, 0xA1, 0xBB, 0x3B, 0x95, 0xA5, 0x04, 0x09, 0x06, 
	0x28, 0x53, 0x57, 0x2C, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2E, 0x4F, 0x52, 0x19, 
	0x49, 0x52, 0x29, 0x4B, 0x52, 0x2A, 0x4D, 0x52, 0x32, 0x54, 0x52, 0x25, 0x4A, 0x54, 0x33, 0x3C, 
	0x39, 0x26, 0x4D, 0x58, 0x34, 0x3D, 0x3B, 0x26, 0x48, 0x4D, 0x19, 0x3B, 0x3D, 0x1D, 0x48, 0x4D, 
	0x24, 0x46, 0x4B, 0x1C, 0x40, 0x3E, 0x1D, 0x3A, 0x40, 0x1D, 0x3A, 0x40, 0x1E, 0x43, 0x40, 0x1C, 
	0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1F, 0x44, 0x40, 0x1D, 0x38, 0x3E, 0x15, 0x34, 
	0x3E, 0x3E, 0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x30, 0x2E, 0x30, 0x2E, 0x27, 
	0x39, 0x37, 0x31, 0x39, 0x3A, 0x31, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x3A, 
	0x37, 0x30, 0x33, 0x2F, 0x2B, 0x0F, 0x36, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x3A, 0x2F, 0x46, 
	0x44, 0x13, 0x2E, 0x3B, 0x39, 0x31, 0x2A, 0x36, 0x32, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x2C, 0x30, 
	0x34, 0x30, 0x2B, 0x3D, 0x3A, 0x31, 0x4E, 0x43, 0x3A, 0x4B, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x31, 
	0x34, 0x2B, 0x3A, 0x39, 0x31, 0x4B, 0x40, 0x38, 0x4A, 0x3F, 0x37, 0x54, 0x49, 0x3F, 0x6C, 0x77, 
	0x7A, 0x75, 0x6A, 0x5D, 0x48, 0x43, 0x38, 0x44, 0x3C, 0x33, 0x4E, 0x46, 0x43, 0x52, 0x4A, 0x3F, 
	0x5B, 0x53, 0x4B, 0x4D, 0x45, 0x40, 0x51, 0x45, 0x3D, 0x54, 0x46, 0x3D, 0x1A, 0x1D, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD6, 0x33, 0x72, 0x83, 0x02, 0x02, 0x00, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 0x09, 
	0x09, 0x04, 0x07, 0x06, 0x28, 0x56, 0x60, 0x4F, 0xC5, 0xD9, 0x4F, 0xC3, 0xD7, 0x48, 0xC2, 0xD1, 
	0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 
	0xC6, 0xDB, 0x3F, 0x9D, 0xAA, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x03, 0x06, 
	0x03, 0x37, 0x86, 0x98, 0x4D, 0xCD, 0xDB, 0x3D, 0x9C, 0xB5, 0x3B, 0x96, 0xA6, 0x0D, 0x00, 0x00, 
	0x2B, 0x57, 0x5E, 0x2B, 0x4D, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4E, 0x52, 0x18, 
	0x49, 0x52, 0x29, 0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4B, 
	0x54, 0x26, 0x4A, 0x52, 0x28, 0x4A, 0x51, 0x33, 0x3D, 0x3C, 0x2E, 0x40, 0x40, 0x19, 0x3E, 0x3C, 
	0x1C, 0x46, 0x4B, 0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3C, 0x3E, 0x22, 
	0x48, 0x4D, 0x1C, 0x39, 0x3E, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3E, 0x42, 0x22, 0x33, 
	0x38, 0x37, 0x2F, 0x2B, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2E, 0x2F, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x27, 0x34, 0x31, 0x2B, 0x38, 
	0x39, 0x30, 0x3A, 0x39, 0x2F, 0x28, 0x2B, 0x2F, 0x16, 0x43, 0x4B, 0x16, 0x45, 0x4A, 0x37, 0x3A, 
	0x38, 0x3C, 0x37, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 0x36, 0x38, 0x2F, 0x38, 0x3A, 0x30, 
	0x38, 0x2C, 0x30, 0x37, 0x38, 0x2F, 0x34, 0x36, 0x2E, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x4D, 
	0x42, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x46, 0x3C, 0x34, 0x5A, 0x51, 0x48, 0x6F, 0x7C, 
	0x79, 0x5D, 0x56, 0x50, 0x40, 0x39, 0x37, 0x4A, 0x3F, 0x36, 0x4C, 0x43, 0x39, 0x4D, 0x45, 0x3A, 
	0x53, 0x4B, 0x42, 0x4A, 0x42, 0x38, 0x51, 0x49, 0x3F, 0x4E, 0x47, 0x3B, 0x1A, 0x1E, 0x23, 0x39, 
	0x75, 0x81, 0x3E, 0xA4, 0xBB, 0x49, 0xC0, 0xD5, 0x2B, 0x57, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 
	0x07, 0x07, 0x04, 0x03, 0x00, 0x02, 0x00, 0x37, 0x89, 0x99, 0x50, 0xC3, 0xD6, 0x4E, 0xC2, 0xD4, 
	0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD0, 0x4A, 
	0xC2, 0xD4, 0x53, 0xC7, 0xDF, 0x31, 0x5D, 0x66, 0x00, 0x00, 0x00, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x03, 0x02, 
	0x00, 0x2A, 0x54, 0x5B, 0x4A, 0xC0, 0xD5, 0x3D, 0x9E, 0xB7, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x28, 0x52, 0x57, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x2B, 
	0x4C, 0x52, 0x18, 0x49, 0x52, 0x27, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x26, 0x4B, 0x55, 0x1C, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x34, 0x3E, 0x3C, 0x29, 0x47, 0x4C, 
	0x1B, 0x4A, 0x52, 0x1D, 0x3F, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3B, 0x40, 0x36, 
	0x40, 0x3F, 0x1B, 0x42, 0x40, 0x1E, 0x43, 0x40, 0x1C, 0x37, 0x40, 0x1E, 0x35, 0x3D, 0x3C, 0x33, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x30, 0x26, 0x38, 0x30, 0x30, 0x30, 0x30, 0x27, 0x2F, 0x28, 0x1F, 0x33, 0x35, 0x2B, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x2F, 0x38, 0x2B, 0x2B, 0x33, 0x29, 0x20, 0x3C, 0x39, 0x2F, 0x30, 0x2C, 
	0x25, 0x36, 0x2F, 0x2E, 0x35, 0x2E, 0x2C, 0x36, 0x38, 0x2F, 0x51, 0x45, 0x3B, 0x35, 0x38, 0x2F, 
	0x39, 0x31, 0x2C, 0x39, 0x37, 0x2C, 0x3D, 0x39, 0x31, 0x48, 0x3F, 0x36, 0x4B, 0x40, 0x38, 0x3D, 
	0x3A, 0x32, 0x4B, 0x40, 0x38, 0x3D, 0x39, 0x31, 0x5B, 0x52, 0x4A, 0x56, 0x4E, 0x43, 0x71, 0x6C, 
	0x5E, 0x5F, 0x57, 0x4F, 0x4A, 0x40, 0x39, 0x4C, 0x44, 0x44, 0x49, 0x3F, 0x35, 0x4C, 0x44, 0x44, 
	0x48, 0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x47, 0x3D, 0x43, 0x39, 0x32, 0x1B, 0x1F, 0x23, 0x39, 
	0x78, 0x87, 0x43, 0xAE, 0xC2, 0x4E, 0xBB, 0xD2, 0x02, 0x02, 0x00, 0x07, 0x08, 0x07, 0x0C, 0x0F, 
	0x0F, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 
	0x0B, 0x00, 0x00, 0x00, 0x15, 0x19, 0x1A, 0x40, 0xA9, 0xB9, 0x52, 0xC5, 0xDD, 0x50, 0xC2, 0xD8, 
	0x51, 0xC4, 0xD7, 0x4F, 0xC6, 0xDC, 0x52, 0xC4, 0xD8, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x53, 
	0xC2, 0xD2, 0x54, 0xC5, 0xDF, 0x4E, 0xBA, 0xD1, 0x11, 0x2B, 0x30, 0x03, 0x00, 0x00, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x04, 
	0x04, 0x06, 0x06, 0x02, 0x4A, 0xB5, 0xC8, 0x40, 0xA5, 0xBF, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x32, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 
	0x49, 0x52, 0x27, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4D, 0x53, 0x2C, 0x44, 
	0x48, 0x34, 0x3C, 0x39, 0x26, 0x4B, 0x55, 0x27, 0x4B, 0x54, 0x20, 0x46, 0x4B, 0x1B, 0x3F, 0x3D, 
	0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x12, 0x36, 0x40, 0x34, 
	0x3C, 0x3A, 0x19, 0x38, 0x40, 0x0F, 0x36, 0x40, 0x22, 0x3A, 0x42, 0x32, 0x34, 0x2E, 0x39, 0x3A, 
	0x30, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x30, 0x30, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x31, 0x2F, 0x28, 0x36, 0x31, 0x2E, 0x38, 
	0x35, 0x2F, 0x31, 0x3F, 0x3C, 0x2E, 0x27, 0x1D, 0x31, 0x2F, 0x28, 0x39, 0x3A, 0x31, 0x35, 0x31, 
	0x2C, 0x38, 0x2E, 0x30, 0x38, 0x3A, 0x2F, 0x37, 0x2E, 0x2E, 0x3C, 0x35, 0x32, 0x39, 0x30, 0x2A, 
	0x2E, 0x47, 0x4B, 0x1D, 0x42, 0x4A, 0x37, 0x3C, 0x36, 0x32, 0x38, 0x32, 0x4C, 0x42, 0x38, 0x4A, 
	0x40, 0x37, 0x4E, 0x44, 0x42, 0x2F, 0x33, 0x29, 0x4C, 0x43, 0x3F, 0x4F, 0x47, 0x3F, 0x55, 0x4C, 
	0x44, 0x55, 0x4D, 0x45, 0x4D, 0x45, 0x3A, 0x4C, 0x44, 0x39, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 
	0x49, 0x3F, 0x37, 0x4C, 0x43, 0x3A, 0x52, 0x4A, 0x3F, 0x42, 0x39, 0x32, 0x1C, 0x1D, 0x22, 0x34, 
	0x8B, 0x9C, 0x43, 0xA8, 0xC3, 0x3A, 0x92, 0xA1, 0x03, 0x04, 0x02, 0x07, 0x04, 0x04, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 
	0x07, 0x0F, 0x16, 0x14, 0x4A, 0xB5, 0xCB, 0x51, 0xC6, 0xDB, 0x4E, 0xC4, 0xD7, 0x51, 0xC4, 0xDA, 
	0x53, 0xBF, 0xD7, 0x3C, 0x9B, 0xA4, 0x53, 0xBF, 0xD8, 0x53, 0xC6, 0xDE, 0x52, 0xC5, 0xD8, 0x4D, 
	0xC2, 0xD6, 0x4D, 0xC2, 0xD2, 0x4C, 0xC7, 0xD9, 0x4F, 0xBD, 0xD2, 0x04, 0x07, 0x06, 0x06, 0x06, 
	0x06, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 
	0x00, 0x07, 0x07, 0x08, 0x45, 0x9E, 0xB1, 0x42, 0xA8, 0xC2, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x29, 0x53, 0x58, 0x2A, 0x4C, 0x52, 0x2E, 0x50, 0x52, 0x31, 0x53, 0x52, 0x28, 0x4B, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x1E, 0x4B, 0x52, 0x1A, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x1F, 0x48, 0x4E, 0x26, 0x4B, 0x54, 0x29, 0x48, 0x4E, 0x1E, 0x46, 0x4A, 0x16, 0x3A, 0x3E, 
	0x1D, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 
	0x3B, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x36, 0x40, 0x26, 0x3C, 0x42, 0x4F, 0x43, 0x37, 0x33, 0x2F, 
	0x2B, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x37, 0x30, 0x2F, 0x2E, 0x2F, 0x25, 
	0x30, 0x31, 0x27, 0x26, 0x1C, 0x1D, 0x33, 0x30, 0x28, 0x3C, 0x34, 0x30, 0x38, 0x30, 0x30, 0x36, 
	0x32, 0x2F, 0x4B, 0x42, 0x37, 0x2E, 0x2C, 0x27, 0x36, 0x2F, 0x2E, 0x36, 0x31, 0x2E, 0x38, 0x3A, 
	0x30, 0x39, 0x32, 0x2E, 0x36, 0x37, 0x33, 0x33, 0x3E, 0x39, 0x39, 0x30, 0x2A, 0x32, 0x40, 0x3E, 
	0x15, 0x42, 0x40, 0x36, 0x40, 0x3F, 0x13, 0x34, 0x42, 0x32, 0x3B, 0x36, 0x48, 0x3E, 0x36, 0x4A, 
	0x3F, 0x37, 0x52, 0x4A, 0x43, 0x4E, 0x44, 0x42, 0x49, 0x3E, 0x35, 0x4E, 0x46, 0x3B, 0x4C, 0x44, 
	0x39, 0x5B, 0x53, 0x4B, 0x4E, 0x46, 0x3C, 0x44, 0x3C, 0x34, 0x4B, 0x40, 0x38, 0x4C, 0x44, 0x3A, 
	0x49, 0x3F, 0x37, 0x48, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x4E, 0x47, 0x3B, 0x1B, 0x1C, 0x20, 0x34, 
	0x89, 0x9A, 0x43, 0xA9, 0xC3, 0x3D, 0x9B, 0xAB, 0x04, 0x06, 0x03, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x09, 0x08, 0x00, 0x00, 
	0x00, 0x3F, 0x9A, 0xAD, 0x52, 0xC9, 0xDE, 0x48, 0xC5, 0xD3, 0x53, 0xC8, 0xDE, 0x2E, 0x6E, 0x77, 
	0x00, 0x02, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x28, 0x51, 0x59, 0x44, 0xA3, 0xB8, 0x56, 
	0xC9, 0xE1, 0x4E, 0xC3, 0xD7, 0x4E, 0xC3, 0xD5, 0x52, 0xC4, 0xDB, 0x31, 0x6F, 0x7D, 0x04, 0x06, 
	0x04, 0x0B, 0x09, 0x09, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 
	0x09, 0x04, 0x08, 0x06, 0x3A, 0x7A, 0x88, 0x3C, 0xA0, 0xBA, 0x42, 0x99, 0xA8, 0x0D, 0x00, 0x00, 
	0x28, 0x53, 0x58, 0x31, 0x53, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x2A, 0x4F, 0x52, 0x3B, 0x4D, 0x4D, 0x3D, 0x4F, 0x4D, 0x18, 0x4A, 0x53, 0x1C, 0x4A, 
	0x52, 0x19, 0x4A, 0x53, 0x2E, 0x44, 0x47, 0x36, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x0D, 0x34, 0x3E, 
	0x1E, 0x46, 0x47, 0x1D, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3D, 0x43, 0x38, 0x32, 0x2C, 0x32, 0x2F, 
	0x29, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x3A, 0x3B, 0x32, 
	0x37, 0x32, 0x2F, 0x2F, 0x31, 0x26, 0x1E, 0x22, 0x29, 0x1C, 0x3B, 0x42, 0x3A, 0x38, 0x2E, 0x35, 
	0x37, 0x2F, 0x4F, 0x43, 0x3A, 0x36, 0x38, 0x2F, 0x39, 0x37, 0x31, 0x2C, 0x2E, 0x24, 0x3A, 0x32, 
	0x2F, 0x32, 0x42, 0x3E, 0x30, 0x43, 0x43, 0x2F, 0x40, 0x42, 0x30, 0x43, 0x43, 0x36, 0x3E, 0x39, 
	0x18, 0x30, 0x39, 0x2E, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x44, 0x48, 0x49, 0x33, 0x34, 0x2A, 0x48, 
	0x3F, 0x37, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x40, 0x4F, 0x47, 0x42, 0x4B, 0x42, 
	0x38, 0x4E, 0x45, 0x3A, 0x64, 0x5A, 0x4F, 0x34, 0x34, 0x2B, 0x3E, 0x3A, 0x32, 0x50, 0x47, 0x3D, 
	0x4D, 0x45, 0x3B, 0x4C, 0x44, 0x3A, 0x47, 0x3C, 0x42, 0x54, 0x4A, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x42, 0xA8, 0xC3, 0x2F, 0x65, 0x6D, 0x02, 0x03, 0x02, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x04, 0x03, 0x1B, 0x3E, 
	0x43, 0x56, 0xC9, 0xE1, 0x4E, 0xC5, 0xD8, 0x4F, 0xC5, 0xDB, 0x28, 0x50, 0x5A, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 
	0x67, 0x70, 0x4F, 0xC8, 0xDE, 0x51, 0xC4, 0xD9, 0x54, 0xC6, 0xDD, 0x49, 0xAE, 0xBE, 0x06, 0x04, 
	0x04, 0x07, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x08, 
	0x08, 0x02, 0x04, 0x02, 0x29, 0x66, 0x6F, 0x3D, 0xA2, 0xBD, 0x44, 0x9D, 0xB0, 0x04, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x2F, 0x51, 0x52, 0x2C, 0x4E, 0x52, 0x2C, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x35, 0x4C, 0x4A, 0x42, 0x47, 0x46, 0x29, 0x44, 0x47, 0x1A, 0x4A, 
	0x53, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x54, 0x43, 0x48, 0x46, 0x4B, 0x4C, 0x4B, 0x20, 0x3A, 0x3E, 
	0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x43, 0x40, 0x26, 0x3C, 0x43, 0x3A, 0x31, 0x2E, 0x35, 0x2E, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x37, 0x34, 0x30, 0x34, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 
	0x37, 0x2F, 0x2F, 0x39, 0x30, 0x31, 0x3B, 0x33, 0x27, 0x15, 0x2C, 0x39, 0x3A, 0x38, 0x2E, 0x34, 
	0x36, 0x2E, 0x49, 0x3F, 0x37, 0x35, 0x36, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2E, 0x24, 0x38, 0x36, 
	0x30, 0x1D, 0x33, 0x3B, 0x1E, 0x32, 0x39, 0x34, 0x43, 0x40, 0x1D, 0x37, 0x3E, 0x20, 0x42, 0x4D, 
	0x20, 0x48, 0x4C, 0x1F, 0x42, 0x4D, 0x23, 0x3E, 0x3D, 0x42, 0x48, 0x47, 0x3C, 0x38, 0x30, 0x31, 
	0x34, 0x2B, 0x4B, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x49, 0x3F, 0x36, 0x48, 0x3E, 0x3E, 0x4D, 0x43, 
	0x3E, 0x44, 0x48, 0x45, 0x79, 0x77, 0x6F, 0x4F, 0x49, 0x43, 0x43, 0x3C, 0x36, 0x48, 0x3C, 0x33, 
	0x57, 0x4F, 0x49, 0x6A, 0x62, 0x4E, 0x51, 0x49, 0x3F, 0x4C, 0x45, 0x39, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3E, 0xA2, 0xBD, 0x2C, 0x6B, 0x77, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 0x09, 0x06, 0x07, 0x08, 0x47, 0xA1, 
	0xB5, 0x4A, 0xC5, 0xD4, 0x52, 0xC8, 0xDD, 0x36, 0x82, 0x93, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x02, 
	0x02, 0x03, 0x2C, 0x71, 0x7D, 0x51, 0xC3, 0xD9, 0x53, 0xC5, 0xDC, 0x53, 0xC3, 0xDE, 0x03, 0x08, 
	0x06, 0x07, 0x07, 0x06, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x14, 
	0x14, 0x03, 0x02, 0x02, 0x25, 0x4C, 0x4E, 0x44, 0xA1, 0xBA, 0x4E, 0xA6, 0xBD, 0x06, 0x02, 0x00, 
	0x28, 0x52, 0x58, 0x25, 0x49, 0x4C, 0x15, 0x44, 0x4D, 0x1D, 0x49, 0x52, 0x2E, 0x4F, 0x51, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4C, 0x53, 0x29, 0x43, 0x47, 0x29, 0x47, 0x4E, 0x19, 0x4A, 
	0x52, 0x29, 0x4A, 0x52, 0x19, 0x4A, 0x52, 0x28, 0x47, 0x4E, 0x25, 0x45, 0x49, 0x1A, 0x38, 0x3C, 
	0x28, 0x4B, 0x53, 0x1B, 0x3F, 0x3D, 0x1C, 0x3A, 0x3E, 0x1C, 0x39, 0x3F, 0x0F, 0x35, 0x3F, 0x19, 
	0x3C, 0x40, 0x0F, 0x34, 0x3E, 0x1C, 0x3B, 0x3F, 0x24, 0x40, 0x43, 0x38, 0x2B, 0x2C, 0x38, 0x3B, 
	0x30, 0x38, 0x2C, 0x30, 0x37, 0x3A, 0x30, 0x3C, 0x3A, 0x32, 0x4A, 0x42, 0x38, 0x2E, 0x2C, 0x26, 
	0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x1A, 0x34, 0x3E, 0x18, 0x34, 0x3B, 0x3E, 0x38, 0x33, 0x48, 
	0x3E, 0x36, 0x3D, 0x39, 0x31, 0x3E, 0x39, 0x34, 0x40, 0x38, 0x35, 0x2E, 0x29, 0x22, 0x15, 0x3A, 
	0x47, 0x20, 0x42, 0x4B, 0x1F, 0x42, 0x4B, 0x23, 0x39, 0x3D, 0x24, 0x39, 0x3E, 0x20, 0x40, 0x45, 
	0x35, 0x3F, 0x3C, 0x2A, 0x3C, 0x39, 0x28, 0x40, 0x43, 0x43, 0x3A, 0x30, 0x3D, 0x39, 0x31, 0x4A, 
	0x43, 0x3A, 0x4A, 0x40, 0x3B, 0x47, 0x3C, 0x3B, 0x4A, 0x40, 0x37, 0x4D, 0x44, 0x3A, 0x39, 0x36, 
	0x30, 0x49, 0x3F, 0x38, 0x37, 0x42, 0x46, 0x4F, 0x45, 0x3E, 0x71, 0x6A, 0x5D, 0x3A, 0x48, 0x4A, 
	0x4E, 0x44, 0x39, 0x4E, 0x46, 0x3C, 0x58, 0x50, 0x46, 0x56, 0x4B, 0x3E, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x42, 0xA8, 0xC3, 0x2C, 0x64, 0x6C, 0x00, 0x00, 0x00, 0x07, 0x08, 0x07, 0x07, 0x06, 
	0x04, 0x00, 0x00, 0x00, 0x08, 0x06, 0x04, 0x07, 0x04, 0x04, 0x04, 0x00, 0x00, 0x07, 0x06, 0x04, 
	0x03, 0x00, 0x00, 0x07, 0x04, 0x04, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x03, 
	0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x09, 0x08, 0x00, 0x00, 0x00, 0x08, 0x09, 0x09, 0x45, 0xB4, 
	0xC7, 0x4A, 0xC6, 0xD5, 0x46, 0xB5, 0xCB, 0x2A, 0x65, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0B, 0x0B, 0x0B, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x06, 
	0x02, 0x00, 0x0C, 0x16, 0x19, 0x4F, 0xB9, 0xD2, 0x54, 0xC5, 0xDD, 0x51, 0xC3, 0xD9, 0x2F, 0x6A, 
	0x77, 0x00, 0x00, 0x00, 0x07, 0x03, 0x03, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x06, 0x06, 0x03, 0x02, 0x00, 0x04, 0x00, 0x00, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x03, 
	0x02, 0x00, 0x07, 0x04, 0x04, 0x09, 0x07, 0x07, 0x09, 0x0F, 0x0E, 0x09, 0x06, 0x06, 0x09, 0x0D, 
	0x0D, 0x08, 0x06, 0x04, 0x0E, 0x22, 0x20, 0x4D, 0xA2, 0xBA, 0x43, 0xA1, 0xAE, 0x0C, 0x03, 0x02, 
	0x4E, 0x5D, 0x5B, 0x24, 0x3C, 0x47, 0x16, 0x3B, 0x42, 0x1E, 0x46, 0x4E, 0x2B, 0x50, 0x59, 0x2A, 
	0x4C, 0x4E, 0x2A, 0x4C, 0x4F, 0x2A, 0x4C, 0x4F, 0x2A, 0x4D, 0x50, 0x2A, 0x4D, 0x4F, 0x26, 0x4A, 
	0x4F, 0x1E, 0x47, 0x50, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x50, 0x14, 0x43, 0x4D, 0x1E, 0x44, 0x47, 
	0x1D, 0x43, 0x46, 0x22, 0x43, 0x47, 0x1E, 0x45, 0x48, 0x1B, 0x3C, 0x43, 0x27, 0x3D, 0x44, 0x11, 
	0x36, 0x3C, 0x1D, 0x40, 0x4A, 0x1B, 0x3C, 0x45, 0x3C, 0x3D, 0x39, 0x43, 0x37, 0x33, 0x31, 0x30, 
	0x2A, 0x35, 0x38, 0x2F, 0x32, 0x31, 0x2B, 0x37, 0x36, 0x2C, 0x4B, 0x40, 0x3A, 0x3F, 0x38, 0x35, 
	0x30, 0x31, 0x28, 0x30, 0x32, 0x28, 0x1B, 0x32, 0x36, 0x2A, 0x54, 0x58, 0x32, 0x52, 0x56, 0x58, 
	0x4A, 0x42, 0x59, 0x50, 0x46, 0x68, 0x5E, 0x53, 0x65, 0x5C, 0x53, 0x59, 0x4E, 0x42, 0x4D, 0x4E, 
	0x4E, 0x2B, 0x51, 0x55, 0x2C, 0x50, 0x55, 0x45, 0x54, 0x53, 0x45, 0x53, 0x52, 0x30, 0x51, 0x51, 
	0x45, 0x42, 0x3C, 0x48, 0x42, 0x40, 0x70, 0x69, 0x65, 0x6C, 0x61, 0x55, 0x5D, 0x53, 0x4A, 0x66, 
	0x5D, 0x4F, 0x67, 0x5E, 0x50, 0x67, 0x5E, 0x50, 0x66, 0x5D, 0x52, 0x73, 0x6A, 0x5B, 0x67, 0x5E, 
	0x56, 0x67, 0x5E, 0x4F, 0x65, 0x5A, 0x4E, 0x6A, 0x60, 0x54, 0x68, 0x62, 0x56, 0x70, 0x6B, 0x65, 
	0x6C, 0x62, 0x53, 0x63, 0x5B, 0x54, 0x6E, 0x65, 0x54, 0x6C, 0x5E, 0x52, 0x1C, 0x22, 0x24, 0x36, 
	0x84, 0x94, 0x43, 0xAB, 0xC1, 0x4B, 0xBB, 0xCF, 0x12, 0x29, 0x2A, 0x00, 0x02, 0x02, 0x09, 0x07, 
	0x0B, 0x0B, 0x07, 0x0B, 0x06, 0x09, 0x0D, 0x02, 0x0D, 0x11, 0x03, 0x0D, 0x11, 0x07, 0x09, 0x0D, 
	0x02, 0x0E, 0x12, 0x06, 0x09, 0x0D, 0x06, 0x09, 0x0D, 0x03, 0x0E, 0x12, 0x09, 0x06, 0x09, 0x06, 
	0x0B, 0x0E, 0x09, 0x07, 0x0B, 0x08, 0x06, 0x09, 0x04, 0x06, 0x09, 0x12, 0x2C, 0x2B, 0x51, 0xBE, 
	0xDA, 0x54, 0xC3, 0xD4, 0x58, 0xD1, 0xE4, 0x2A, 0x5E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0C, 0x00, 0x04, 0x03, 0x02, 0x04, 0x04, 0x0C, 
	0x09, 0x09, 0x00, 0x00, 0x00, 0x43, 0xA4, 0xB3, 0x4F, 0xC6, 0xDA, 0x4F, 0xC5, 0xD7, 0x3E, 0xA0, 
	0xB3, 0x14, 0x32, 0x35, 0x07, 0x04, 0x07, 0x04, 0x09, 0x0C, 0x09, 0x07, 0x0B, 0x08, 0x07, 0x0B, 
	0x08, 0x06, 0x09, 0x09, 0x07, 0x09, 0x00, 0x0E, 0x12, 0x09, 0x04, 0x07, 0x04, 0x0B, 0x0E, 0x09, 
	0x07, 0x09, 0x08, 0x06, 0x09, 0x08, 0x0C, 0x0E, 0x04, 0x08, 0x0C, 0x08, 0x0D, 0x0F, 0x08, 0x0C, 
	0x0F, 0x07, 0x06, 0x08, 0x0F, 0x16, 0x1A, 0x44, 0xA6, 0xB9, 0x38, 0x93, 0xA4, 0x11, 0x12, 0x09, 
	0xC3, 0xB1, 0xA3, 0xD5, 0xBD, 0xAB, 0x59, 0x74, 0x77, 0x38, 0x70, 0x7A, 0x38, 0x77, 0x81, 0x38, 
	0x65, 0x6E, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x67, 0x70, 0x39, 0x67, 
	0x71, 0x33, 0x5F, 0x65, 0x39, 0x62, 0x65, 0x39, 0x68, 0x73, 0x35, 0x5D, 0x60, 0x32, 0x5B, 0x61, 
	0x32, 0x5E, 0x67, 0x35, 0x64, 0x6C, 0x33, 0x61, 0x6B, 0x22, 0x53, 0x5B, 0x34, 0x5F, 0x65, 0x2A, 
	0x4E, 0x58, 0x34, 0x5E, 0x65, 0x2E, 0x55, 0x59, 0x38, 0x53, 0x56, 0x58, 0x4B, 0x43, 0x56, 0x4C, 
	0x43, 0x57, 0x4D, 0x43, 0x51, 0x47, 0x3C, 0x4C, 0x46, 0x3B, 0x5F, 0x56, 0x4C, 0x69, 0x60, 0x54, 
	0x52, 0x48, 0x44, 0x54, 0x4A, 0x42, 0x08, 0x09, 0x09, 0x11, 0x20, 0x23, 0x13, 0x12, 0x11, 0x15, 
	0x0D, 0x0F, 0x16, 0x1B, 0x1A, 0x18, 0x19, 0x14, 0x1B, 0x19, 0x14, 0x1A, 0x22, 0x1D, 0x19, 0x1B, 
	0x18, 0x19, 0x11, 0x11, 0x19, 0x12, 0x12, 0x1E, 0x0C, 0x0B, 0x0E, 0x23, 0x29, 0x18, 0x13, 0x13, 
	0x1F, 0x12, 0x0E, 0x1A, 0x1E, 0x19, 0x1D, 0x24, 0x1E, 0x1D, 0x24, 0x1F, 0x1B, 0x1F, 0x1E, 0x16, 
	0x18, 0x13, 0x1D, 0x1E, 0x20, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1F, 0x1A, 0x1B, 0x1D, 0x1E, 
	0x1F, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1C, 0x1D, 0x1F, 0x27, 0x24, 0x22, 0x1B, 0x23, 0x1D, 
	0x1B, 0x23, 0x1E, 0x31, 0x2A, 0x26, 0x25, 0x26, 0x22, 0x25, 0x25, 0x1F, 0x13, 0x13, 0x14, 0x3B, 
	0x81, 0x92, 0x39, 0x96, 0xB1, 0x4C, 0xC6, 0xD4, 0x46, 0xB4, 0xC7, 0x46, 0xAA, 0xBC, 0x45, 0xAF, 
	0xC0, 0x46, 0xAE, 0xC0, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 
	0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 0x45, 0xAE, 0xBF, 0x45, 0xAE, 0xBE, 0x4B, 0xAE, 0xBF, 0x45, 
	0xAE, 0xC0, 0x48, 0xAE, 0xC0, 0x4B, 0xAE, 0xC0, 0x44, 0xAD, 0xBD, 0x4B, 0xB3, 0xCB, 0x4F, 0xC4, 
	0xD4, 0x50, 0xC2, 0xD6, 0x53, 0xC9, 0xDE, 0x2B, 0x66, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x02, 0x02, 0x0B, 0x0C, 0x0C, 0x12, 0x1F, 0x1E, 0x43, 0x57, 0x62, 0x13, 0x1F, 0x1E, 0x06, 
	0x06, 0x06, 0x03, 0x03, 0x00, 0x3C, 0x97, 0xA5, 0x4F, 0xC7, 0xDB, 0x53, 0xC2, 0xDB, 0x50, 0xC5, 
	0xD9, 0x4A, 0xB8, 0xD3, 0x49, 0xAB, 0xC0, 0x50, 0xBB, 0xD2, 0x49, 0xAD, 0xC3, 0x4D, 0xB2, 0xC4, 
	0x4F, 0xB5, 0xC4, 0x49, 0xAE, 0xC4, 0x49, 0xAB, 0xC1, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x49, 
	0xAE, 0xC4, 0x4F, 0xB3, 0xC3, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x4A, 0xAE, 0xC3, 0x49, 0xAE, 
	0xC4, 0x4C, 0xB0, 0xC2, 0x4C, 0xBB, 0xD3, 0x39, 0x99, 0xB3, 0x3E, 0x9B, 0xAF, 0x09, 0x0E, 0x14, 
	0x49, 0x42, 0x36, 0x44, 0x39, 0x33, 0x36, 0x27, 0x24, 0x0C, 0x27, 0x26, 0x11, 0x20, 0x25, 0x11, 
	0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x1F, 0x24, 0x11, 0x1C, 0x20, 0x11, 0x24, 
	0x28, 0x12, 0x1D, 0x22, 0x11, 0x1D, 0x23, 0x11, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x12, 0x1E, 0x23, 
	0x12, 0x1E, 0x23, 0x12, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x14, 0x1F, 0x25, 0x0C, 0x19, 0x16, 0x0D, 
	0x1A, 0x19, 0x0C, 0x19, 0x18, 0x0C, 0x1A, 0x19, 0x0D, 0x1E, 0x22, 0x1B, 0x14, 0x12, 0x1A, 0x16, 
	0x0F, 0x16, 0x0E, 0x0F, 0x1B, 0x0F, 0x11, 0x18, 0x0E, 0x0F, 0x19, 0x1B, 0x16, 0x18, 0x1A, 0x15, 
	0x1B, 0x15, 0x13, 0x14, 0x15, 0x16, 0x00, 0x00, 0x00, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x03, 0x03, 0x02, 0x02, 0x03, 0x06, 0x06, 0x07, 0x02, 0x02, 0x02, 0x03, 0x02, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x04, 0x04, 0x04, 0x02, 0x00, 0x03, 0x03, 0x03, 
	0x02, 0x03, 0x04, 0x02, 0x02, 0x03, 0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x02, 0x02, 0x00, 0x02, 
	0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 
	0x81, 0x92, 0x48, 0xB7, 0xCA, 0x50, 0xC5, 0xD9, 0x50, 0xC5, 0xD6, 0x4A, 0xC5, 0xD4, 0x51, 0xC5, 
	0xD8, 0x4A, 0xC5, 0xD4, 0x4D, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4B, 0xC5, 0xD5, 0x4A, 0xC5, 0xD4, 
	0x51, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x55, 0xC5, 0xDF, 0x51, 0xC5, 0xDA, 0x4D, 
	0xC5, 0xD4, 0x49, 0xC5, 0xD5, 0x50, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x52, 0xC5, 0xD8, 0x47, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x52, 0xC6, 0xDB, 0x44, 0xA1, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x06, 0x0C, 0x0C, 0x31, 0x36, 0x34, 0xA1, 0xB4, 0xC4, 0x2A, 0x3A, 0x39, 0x00, 
	0x02, 0x00, 0x00, 0x03, 0x03, 0x46, 0xA6, 0xB4, 0x54, 0xC5, 0xDD, 0x4F, 0xC2, 0xD4, 0x4F, 0xC2, 
	0xD3, 0x53, 0xC4, 0xDD, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDC, 0x54, 0xC5, 0xDE, 0x4D, 0xC5, 0xD8, 
	0x54, 0xC5, 0xDE, 0x52, 0xC5, 0xDC, 0x5E, 0xD1, 0xE4, 0x5B, 0xCC, 0xE3, 0x53, 0xC5, 0xDD, 0x53, 
	0xC5, 0xDE, 0x53, 0xC5, 0xD2, 0x52, 0xC3, 0xDC, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDE, 0x53, 0xC5, 
	0xD2, 0x52, 0xC5, 0xDE, 0x5A, 0xCF, 0xE0, 0x49, 0x9F, 0xB8, 0x3A, 0x94, 0xA2, 0x09, 0x11, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x00, 
	0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 
	0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x02, 0x04, 
	0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02, 0x03, 
	0x04, 0x03, 0x04, 0x04, 0x02, 0x04, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 
	0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 
	0x82, 0x93, 0x3C, 0x9D, 0xB7, 0x4A, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x4E, 0xC2, 0xD1, 0x48, 
	0xC2, 0xD2, 0x55, 0xC2, 0xD2, 0x47, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD1, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD7, 0x51, 0xC5, 0xDC, 0x1E, 0x3E, 0x46, 0x03, 0x00, 0x00, 
	0x08, 0x06, 0x06, 0x09, 0x08, 0x08, 0x09, 0x12, 0x15, 0x24, 0x2E, 0x2C, 0x0E, 0x08, 0x08, 0x02, 
	0x00, 0x00, 0x18, 0x33, 0x37, 0x4E, 0xBC, 0xD6, 0x53, 0xC4, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD0, 0x52, 0xC2, 0xCF, 0x53, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x53, 0xC1, 0xDA, 0x57, 0xC6, 0xD8, 0x4B, 0xC0, 0xD4, 0x4C, 0xC2, 0xD1, 0x52, 
	0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 
	0xDA, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3C, 0xA1, 0xB9, 0x42, 0xA0, 0xB6, 0x09, 0x12, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0D, 0x0D, 0x03, 0x06, 0x06, 0x03, 0x07, 0x06, 0x03, 
	0x07, 0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x06, 0x07, 0x00, 0x07, 
	0x07, 0x00, 0x04, 0x04, 0x00, 0x04, 0x04, 0x03, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x04, 0x06, 
	0x00, 0x03, 0x04, 0x00, 0x04, 0x06, 0x00, 0x04, 0x06, 0x00, 0x03, 0x04, 0x12, 0x0B, 0x0C, 0x0F, 
	0x09, 0x0B, 0x0D, 0x07, 0x08, 0x08, 0x08, 0x09, 0x00, 0x03, 0x04, 0x14, 0x0B, 0x0C, 0x00, 0x03, 
	0x04, 0x13, 0x0C, 0x0C, 0x11, 0x0B, 0x0B, 0x0F, 0x09, 0x0B, 0x11, 0x0B, 0x0C, 0x0F, 0x09, 0x0B, 
	0x0F, 0x09, 0x0B, 0x0E, 0x08, 0x09, 0x0E, 0x08, 0x09, 0x13, 0x09, 0x09, 0x1A, 0x29, 0x2E, 0x35, 
	0x8B, 0x9B, 0x3B, 0x98, 0xB3, 0x4B, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x53, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDD, 0x4F, 0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x52, 0xC5, 0xD9, 0x50, 0xBD, 0xD4, 0x0D, 0x27, 0x2B, 
	0x00, 0x00, 0x00, 0x09, 0x06, 0x04, 0x06, 0x03, 0x02, 0x02, 0x00, 0x00, 0x03, 0x06, 0x04, 0x11, 
	0x15, 0x13, 0x49, 0xB2, 0xC8, 0x51, 0xC7, 0xDD, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x53, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x53, 0xC2, 0xDA, 0x49, 0xC2, 0xCE, 0x52, 0xC1, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x53, 0xC3, 
	0xD9, 0x5D, 0xCD, 0xD9, 0x52, 0xC7, 0xDB, 0x46, 0x99, 0xB2, 0x3D, 0x9B, 0xAD, 0x0D, 0x0B, 0x0E, 
	0x0E, 0x08, 0x09, 0x0F, 0x0F, 0x09, 0x06, 0x08, 0x09, 0x00, 0x09, 0x09, 0x02, 0x03, 0x02, 0x02, 
	0x03, 0x02, 0x04, 0x09, 0x08, 0x04, 0x08, 0x08, 0x08, 0x12, 0x12, 0x03, 0x02, 0x00, 0x02, 0x03, 
	0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x02, 0x04, 0x03, 0x02, 0x04, 0x03, 
	0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x02, 
	0x04, 0x03, 0x03, 0x04, 0x04, 0x02, 0x04, 0x03, 0x00, 0x03, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 
	0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 
	0x03, 0x07, 0x06, 0x03, 0x07, 0x06, 0x1A, 0x31, 0x35, 0x1B, 0x2F, 0x34, 0x1B, 0x2F, 0x33, 0x19, 
	0x31, 0x35, 0x1E, 0x36, 0x3C, 0x34, 0x39, 0x33, 0x39, 0x39, 0x2E, 0x3C, 0x3A, 0x33, 0x31, 0x26, 
	0x25, 0x4B, 0x46, 0x40, 0x2E, 0x40, 0x3F, 0x1A, 0x31, 0x3A, 0x32, 0x35, 0x2B, 0x49, 0x43, 0x38, 
	0x4D, 0x49, 0x3D, 0x48, 0x3D, 0x39, 0x47, 0x3C, 0x38, 0x4A, 0x46, 0x3A, 0x4A, 0x47, 0x3C, 0x4D, 
	0x43, 0x40, 0x70, 0x68, 0x57, 0x3C, 0x35, 0x2E, 0x44, 0x3E, 0x38, 0x4C, 0x49, 0x3D, 0x43, 0x3A, 
	0x3A, 0x45, 0x3D, 0x36, 0x48, 0x45, 0x3D, 0x4B, 0x48, 0x3C, 0x44, 0x39, 0x36, 0x4A, 0x47, 0x3C, 
	0x48, 0x45, 0x3B, 0x5B, 0x51, 0x48, 0x5B, 0x51, 0x48, 0x4C, 0x47, 0x3C, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3B, 0x99, 0xB3, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD4, 0x48, 0xC2, 0xD0, 0x55, 0xC2, 
	0xDC, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x4E, 0xC5, 0xD7, 0x51, 0xBA, 0xD0, 
	0x2C, 0x67, 0x73, 0x0E, 0x16, 0x18, 0x03, 0x04, 0x07, 0x08, 0x13, 0x15, 0x26, 0x4C, 0x53, 0x4B, 
	0xB8, 0xCC, 0x52, 0xC5, 0xDC, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xCF, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x54, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x4C, 0xC2, 0xD2, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5D, 0xCD, 
	0xD9, 0x4F, 0xBE, 0xD9, 0x4E, 0xC5, 0xD8, 0x38, 0x96, 0xB0, 0x38, 0x93, 0xA2, 0x0F, 0x09, 0x08, 
	0x95, 0x86, 0x7C, 0x87, 0x86, 0x7F, 0x6B, 0x67, 0x60, 0x37, 0x4E, 0x52, 0x19, 0x46, 0x50, 0x1F, 
	0x48, 0x4F, 0x2E, 0x59, 0x61, 0x28, 0x4E, 0x4D, 0x2A, 0x4F, 0x4E, 0x15, 0x44, 0x4F, 0x28, 0x4E, 
	0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x4F, 0x50, 0x25, 0x3F, 0x4A, 0x1F, 0x45, 0x4F, 
	0x1F, 0x40, 0x4A, 0x20, 0x45, 0x4E, 0x1C, 0x3B, 0x46, 0x1F, 0x3E, 0x45, 0x26, 0x42, 0x4D, 0x23, 
	0x3E, 0x46, 0x1E, 0x3C, 0x40, 0x26, 0x3E, 0x47, 0x44, 0x4F, 0x4D, 0x20, 0x3E, 0x47, 0x1F, 0x3E, 
	0x42, 0x1F, 0x38, 0x42, 0x20, 0x39, 0x43, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 
	0x1A, 0x31, 0x35, 0x1A, 0x2F, 0x33, 0x1E, 0x31, 0x3A, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2E, 0x1A, 
	0x30, 0x3A, 0x3F, 0x2F, 0x2E, 0x3A, 0x2F, 0x31, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x3A, 0x38, 
	0x32, 0x3A, 0x38, 0x2C, 0x13, 0x34, 0x40, 0x0E, 0x39, 0x44, 0x28, 0x2F, 0x2F, 0x4C, 0x3F, 0x36, 
	0x4E, 0x40, 0x3A, 0x39, 0x46, 0x45, 0x40, 0x35, 0x32, 0x46, 0x3E, 0x36, 0x4A, 0x3F, 0x37, 0x50, 
	0x48, 0x42, 0x69, 0x60, 0x54, 0x42, 0x3B, 0x39, 0x4B, 0x40, 0x37, 0x4C, 0x40, 0x39, 0x4B, 0x42, 
	0x38, 0x4B, 0x40, 0x37, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 
	0x4F, 0x46, 0x3C, 0x4D, 0x44, 0x3B, 0x50, 0x48, 0x3E, 0x54, 0x49, 0x3E, 0x1A, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x51, 0xC6, 0xDB, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 
	0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x50, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x55, 0xBF, 0xCE, 0x4E, 0xC5, 0xDA, 0x50, 0xC2, 0xD5, 0x53, 0xC5, 0xDB, 
	0x53, 0xC6, 0xDC, 0x5A, 0xBD, 0xD6, 0x4D, 0xB7, 0xCF, 0x4E, 0xB5, 0xCC, 0x56, 0xCB, 0xE1, 0x4D, 
	0xCB, 0xDD, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x4D, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 0x54, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xDA, 0x51, 0xC0, 0xCE, 0x5E, 0xCE, 0xDA, 0x51, 0xC0, 0xDA, 0x4B, 0xC1, 0xCE, 0x55, 0xC5, 
	0xDA, 0x5D, 0xCD, 0xD9, 0x53, 0xC7, 0xDA, 0x3D, 0xA1, 0xB9, 0x4F, 0xA6, 0xBD, 0x02, 0x04, 0x03, 
	0x7F, 0x70, 0x61, 0x8F, 0x7C, 0x6C, 0x75, 0x6E, 0x66, 0x63, 0x5D, 0x58, 0x1C, 0x3C, 0x45, 0x12, 
	0x3D, 0x48, 0x34, 0x56, 0x53, 0x2B, 0x4E, 0x53, 0x32, 0x54, 0x53, 0x2E, 0x4F, 0x53, 0x26, 0x49, 
	0x53, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x54, 0x22, 0x46, 0x49, 0x1C, 0x43, 0x44, 
	0x1D, 0x4A, 0x51, 0x1C, 0x4C, 0x55, 0x1D, 0x43, 0x43, 0x19, 0x49, 0x53, 0x20, 0x44, 0x44, 0x1C, 
	0x49, 0x4D, 0x1B, 0x3A, 0x3F, 0x25, 0x3E, 0x40, 0x31, 0x40, 0x40, 0x1A, 0x40, 0x40, 0x1D, 0x30, 
	0x39, 0x1A, 0x31, 0x39, 0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 0x44, 
	0x1D, 0x32, 0x3B, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1C, 
	0x2F, 0x38, 0x24, 0x30, 0x30, 0x2F, 0x30, 0x24, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x31, 0x2E, 
	0x28, 0x3A, 0x31, 0x2E, 0x30, 0x43, 0x3E, 0x11, 0x3A, 0x42, 0x22, 0x30, 0x36, 0x27, 0x3C, 0x38, 
	0x42, 0x37, 0x2B, 0x24, 0x42, 0x43, 0x44, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x43, 
	0x3C, 0x33, 0x43, 0x3B, 0x36, 0x4A, 0x3F, 0x36, 0x4D, 0x43, 0x40, 0x31, 0x34, 0x2B, 0x4D, 0x42, 
	0x38, 0x4A, 0x40, 0x40, 0x49, 0x3F, 0x36, 0x4F, 0x47, 0x43, 0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x40, 
	0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x3B, 0x51, 0x48, 0x3E, 0x46, 0x42, 0x37, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB1, 0x4E, 0xC7, 0xD8, 0x49, 0xBC, 0xCB, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x4E, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x53, 0xC2, 0xDD, 0x4E, 0xC2, 
	0xD0, 0x4C, 0xC5, 0xD6, 0x42, 0xAD, 0xC3, 0x46, 0xA7, 0xB7, 0x56, 0xCB, 0xE2, 0x52, 0xC7, 0xDB, 
	0x51, 0xCA, 0xDE, 0x57, 0xCE, 0xE4, 0x5A, 0xCF, 0xE4, 0x57, 0xD1, 0xE3, 0x51, 0xC5, 0xDD, 0x39, 
	0x8E, 0x9C, 0x53, 0xC8, 0xDD, 0x50, 0xC3, 0xD9, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xD0, 0x49, 0xC2, 
	0xCF, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC0, 0xD7, 0x5C, 0xCC, 
	0xD9, 0x4E, 0xBE, 0xD9, 0x5A, 0xCC, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x93, 0xA3, 0x00, 0x06, 0x04, 
	0x68, 0x5C, 0x54, 0x91, 0x80, 0x6E, 0x81, 0x6F, 0x62, 0x85, 0x77, 0x68, 0x36, 0x47, 0x47, 0x18, 
	0x4B, 0x54, 0x2A, 0x46, 0x4C, 0x25, 0x49, 0x52, 0x28, 0x4B, 0x52, 0x2B, 0x4E, 0x52, 0x29, 0x4B, 
	0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x48, 0x4F, 0x1B, 0x3B, 0x3C, 
	0x1D, 0x3B, 0x3C, 0x1D, 0x4A, 0x51, 0x1D, 0x3E, 0x3C, 0x1D, 0x3A, 0x3E, 0x1D, 0x3B, 0x3F, 0x1C, 
	0x3A, 0x3E, 0x20, 0x40, 0x3E, 0x39, 0x3B, 0x35, 0x39, 0x3B, 0x35, 0x1A, 0x3A, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x16, 
	0x36, 0x40, 0x2B, 0x30, 0x29, 0x36, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2E, 
	0x24, 0x36, 0x42, 0x3C, 0x3D, 0x30, 0x2A, 0x13, 0x39, 0x42, 0x1D, 0x46, 0x48, 0x19, 0x3F, 0x3F, 
	0x23, 0x45, 0x48, 0x26, 0x45, 0x49, 0x45, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4C, 0x42, 0x39, 0x4D, 
	0x42, 0x39, 0x31, 0x34, 0x2B, 0x50, 0x47, 0x3D, 0x61, 0x58, 0x4D, 0x32, 0x34, 0x2B, 0x3F, 0x3B, 
	0x32, 0x4A, 0x3F, 0x40, 0x49, 0x3F, 0x36, 0x4B, 0x43, 0x3E, 0x51, 0x49, 0x3E, 0x58, 0x50, 0x47, 
	0x4E, 0x43, 0x3E, 0x54, 0x4C, 0x42, 0x53, 0x4B, 0x42, 0x54, 0x49, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x89, 0x99, 0x45, 0xAD, 0xC4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4B, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x52, 0xC2, 0xCF, 0x4C, 0xC1, 
	0xD4, 0x55, 0xCD, 0xE1, 0x31, 0x78, 0x87, 0x00, 0x00, 0x00, 0x29, 0x53, 0x5B, 0x38, 0x87, 0x9B, 
	0x40, 0xA2, 0xAF, 0x3E, 0xA0, 0xAB, 0x47, 0xA9, 0xB8, 0x32, 0x82, 0x94, 0x27, 0x52, 0x58, 0x00, 
	0x00, 0x00, 0x31, 0x7B, 0x85, 0x54, 0xCC, 0xE3, 0x53, 0xC3, 0xDB, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4E, 0xC1, 0xD1, 0x4E, 
	0xC1, 0xD1, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD8, 0x5A, 0xCA, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x5D, 0xCD, 0xDA, 0x52, 0xC7, 0xDA, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x68, 0x5B, 0x50, 0x90, 0x7E, 0x70, 0x8E, 0x7D, 0x6F, 0x84, 0x75, 0x68, 0x4D, 0x54, 0x53, 0x18, 
	0x49, 0x53, 0x28, 0x47, 0x4C, 0x29, 0x4C, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4B, 0x52, 0x33, 0x55, 
	0x52, 0x27, 0x4B, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x50, 
	0x1B, 0x3E, 0x3C, 0x1D, 0x43, 0x45, 0x1D, 0x46, 0x4B, 0x1E, 0x3D, 0x3D, 0x0E, 0x35, 0x3F, 0x1C, 
	0x3B, 0x3D, 0x2A, 0x4E, 0x59, 0x1F, 0x3C, 0x3E, 0x20, 0x3D, 0x40, 0x1C, 0x3D, 0x42, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x32, 0x3B, 0x16, 0x28, 0x2A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x1F, 
	0x2F, 0x35, 0x31, 0x29, 0x1D, 0x31, 0x30, 0x28, 0x34, 0x2F, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x30, 
	0x24, 0x11, 0x2C, 0x3C, 0x3D, 0x37, 0x2E, 0x34, 0x3F, 0x3B, 0x38, 0x43, 0x43, 0x1C, 0x45, 0x47, 
	0x19, 0x36, 0x3E, 0x2B, 0x3B, 0x34, 0x3B, 0x33, 0x30, 0x4B, 0x40, 0x38, 0x3E, 0x38, 0x33, 0x49, 
	0x40, 0x37, 0x34, 0x36, 0x2E, 0x47, 0x3F, 0x37, 0x5E, 0x56, 0x4A, 0x37, 0x36, 0x2E, 0x46, 0x3D, 
	0x35, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x3C, 0x3B, 0x37, 0x2E, 0x5B, 0x4F, 0x47, 
	0x33, 0x4D, 0x50, 0x4A, 0x3C, 0x36, 0x4F, 0x47, 0x3C, 0x4D, 0x46, 0x3A, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9D, 0xB6, 0x4B, 0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD1, 0x4B, 0xC2, 0xD3, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xD9, 0x53, 0xC3, 
	0xD4, 0x54, 0xC5, 0xE1, 0x04, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x04, 
	0x04, 0x03, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x06, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x32, 0x76, 0x85, 0x51, 0xC5, 0xDC, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD9, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4C, 0xC2, 0xCE, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x57, 0xC7, 0xD9, 0x5A, 
	0xCA, 0xDC, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xD8, 0x5D, 0xCD, 0xE4, 0x4F, 0xBE, 0xD8, 0x51, 0xC0, 
	0xD7, 0x51, 0xC0, 0xCF, 0x4F, 0xC5, 0xD8, 0x49, 0x9E, 0xB7, 0x3A, 0x96, 0xA6, 0x04, 0x00, 0x00, 
	0x62, 0x54, 0x47, 0x71, 0x6C, 0x5E, 0x8F, 0x7C, 0x6B, 0x88, 0x75, 0x69, 0x63, 0x5C, 0x4F, 0x23, 
	0x42, 0x48, 0x18, 0x4A, 0x53, 0x31, 0x52, 0x53, 0x2C, 0x4E, 0x52, 0x16, 0x49, 0x52, 0x29, 0x4B, 
	0x53, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x28, 0x4A, 0x53, 
	0x26, 0x49, 0x50, 0x1C, 0x3E, 0x3C, 0x1D, 0x4A, 0x51, 0x1C, 0x49, 0x50, 0x23, 0x43, 0x46, 0x1C, 
	0x38, 0x3F, 0x1F, 0x44, 0x45, 0x1B, 0x40, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3D, 0x40, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x16, 0x32, 0x3C, 0x3B, 
	0x2F, 0x2B, 0x2E, 0x30, 0x25, 0x3A, 0x35, 0x32, 0x39, 0x37, 0x31, 0x30, 0x2E, 0x27, 0x34, 0x2F, 
	0x2B, 0x35, 0x30, 0x26, 0x27, 0x26, 0x24, 0x2A, 0x3E, 0x42, 0x3D, 0x4E, 0x4D, 0x34, 0x3E, 0x3D, 
	0x22, 0x49, 0x4D, 0x27, 0x45, 0x49, 0x42, 0x39, 0x2F, 0x61, 0x58, 0x4A, 0x31, 0x2C, 0x24, 0x33, 
	0x2F, 0x2C, 0x37, 0x38, 0x2F, 0x46, 0x3D, 0x34, 0x48, 0x3E, 0x36, 0x4D, 0x42, 0x39, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x49, 0x3E, 0x35, 0x56, 0x4D, 0x40, 0x46, 0x40, 0x42, 0x60, 0x56, 0x46, 
	0x46, 0x4C, 0x4B, 0x48, 0x42, 0x40, 0x48, 0x3D, 0x34, 0x54, 0x4A, 0x3E, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xB9, 0xC9, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x48, 0xC2, 0xD1, 0x4D, 0xC1, 0xD5, 0x53, 0xCB, 
	0xDF, 0x3A, 0x8D, 0x9D, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x0C, 0x0B, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x04, 0x00, 0x00, 0x0F, 0x1E, 0x20, 0x4E, 0xBC, 0xD2, 0x53, 0xC5, 0xDA, 0x52, 0xC2, 
	0xDA, 0x4D, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4F, 0xC0, 0xD6, 0x5E, 0xCE, 0xE4, 0x51, 0xC0, 0xD6, 
	0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5A, 
	0xCA, 0xD8, 0x50, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 
	0xD9, 0x51, 0xC1, 0xD7, 0x59, 0xCC, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x5E, 0x54, 0x47, 0x62, 0x5A, 0x48, 0x74, 0x6E, 0x66, 0x81, 0x71, 0x66, 0x6D, 0x5F, 0x51, 0x4C, 
	0x5C, 0x5D, 0x11, 0x43, 0x4C, 0x28, 0x44, 0x47, 0x2E, 0x50, 0x54, 0x29, 0x4A, 0x53, 0x22, 0x44, 
	0x47, 0x27, 0x4D, 0x53, 0x27, 0x49, 0x52, 0x28, 0x4B, 0x54, 0x1D, 0x43, 0x45, 0x19, 0x4A, 0x53, 
	0x2A, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3C, 0x3C, 0x1D, 0x4D, 0x56, 0x13, 0x34, 0x3C, 0x1D, 
	0x2E, 0x38, 0x1D, 0x44, 0x40, 0x1E, 0x3A, 0x42, 0x0F, 0x36, 0x3F, 0x1E, 0x38, 0x42, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x2E, 0x37, 0x3C, 
	0x32, 0x30, 0x30, 0x2F, 0x27, 0x30, 0x2E, 0x27, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x3A, 0x35, 
	0x31, 0x29, 0x2F, 0x29, 0x19, 0x31, 0x3C, 0x23, 0x1E, 0x22, 0x1E, 0x45, 0x4F, 0x19, 0x33, 0x3D, 
	0x1B, 0x3D, 0x3F, 0x1C, 0x3B, 0x3E, 0x45, 0x3C, 0x33, 0x76, 0x6C, 0x5B, 0x4C, 0x46, 0x3D, 0x30, 
	0x30, 0x26, 0x29, 0x33, 0x32, 0x51, 0x4A, 0x49, 0x4F, 0x40, 0x36, 0x3A, 0x37, 0x2E, 0x4E, 0x40, 
	0x36, 0x4E, 0x43, 0x42, 0x48, 0x42, 0x40, 0x49, 0x4B, 0x46, 0x3F, 0x40, 0x42, 0x53, 0x4A, 0x46, 
	0x49, 0x4C, 0x4A, 0x40, 0x47, 0x49, 0x55, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x49, 0xB5, 0xCA, 0x4A, 0xBF, 0xCF, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x55, 0xC2, 0xDD, 0x4E, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4D, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 0xD1, 0x51, 0xC4, 0xD7, 0x54, 0xC5, 
	0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 
	0x0C, 0x0C, 0x0B, 0x13, 0x13, 0x03, 0x02, 0x00, 0x31, 0x65, 0x72, 0x55, 0xC9, 0xE0, 0x52, 0xC2, 
	0xDA, 0x4C, 0xC2, 0xD1, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD6, 0x52, 0xC2, 0xDA, 
	0x51, 0xC1, 0xDA, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x50, 
	0xC0, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xCA, 0xD9, 0x53, 0xC3, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 0xC1, 
	0xD9, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x08, 0x07, 
	0x63, 0x57, 0x49, 0x5B, 0x53, 0x48, 0x6B, 0x62, 0x52, 0x6E, 0x6E, 0x66, 0x74, 0x60, 0x4D, 0x60, 
	0x64, 0x61, 0x1E, 0x3F, 0x49, 0x13, 0x3C, 0x47, 0x18, 0x40, 0x40, 0x19, 0x49, 0x50, 0x0D, 0x31, 
	0x3B, 0x19, 0x46, 0x4F, 0x1F, 0x49, 0x4F, 0x1F, 0x3B, 0x42, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x55, 
	0x19, 0x3C, 0x39, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3D, 0x1D, 0x4E, 0x57, 0x18, 0x43, 0x4B, 0x1E, 
	0x2A, 0x33, 0x11, 0x39, 0x43, 0x1F, 0x2A, 0x34, 0x12, 0x38, 0x42, 0x1E, 0x3F, 0x42, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x24, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x16, 0x30, 0x3A, 0x3B, 
	0x3A, 0x2E, 0x38, 0x31, 0x31, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x29, 0x36, 0x32, 0x2E, 0x39, 0x32, 
	0x31, 0x34, 0x2F, 0x25, 0x16, 0x32, 0x3C, 0x1A, 0x2C, 0x36, 0x3B, 0x46, 0x43, 0x20, 0x48, 0x4C, 
	0x1F, 0x40, 0x3F, 0x24, 0x34, 0x38, 0x30, 0x2C, 0x25, 0x4E, 0x48, 0x3F, 0x5C, 0x52, 0x4A, 0x46, 
	0x3A, 0x2F, 0x13, 0x3B, 0x3F, 0x2A, 0x39, 0x33, 0x23, 0x40, 0x42, 0x1B, 0x3A, 0x42, 0x29, 0x40, 
	0x42, 0x46, 0x4A, 0x4A, 0x34, 0x46, 0x47, 0x4F, 0x4D, 0x4A, 0x29, 0x4B, 0x4B, 0x1E, 0x3B, 0x3A, 
	0x30, 0x51, 0x53, 0x3C, 0x4A, 0x4B, 0x54, 0x4A, 0x3F, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD1, 0x54, 0xC2, 0xDD, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x53, 0xC6, 0xD8, 0x3A, 0x8D, 
	0x9D, 0x04, 0x06, 0x03, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 
	0x15, 0x15, 0x0B, 0x14, 0x14, 0x09, 0x0F, 0x0E, 0x04, 0x08, 0x06, 0x46, 0xAB, 0xC2, 0x54, 0xCA, 
	0xDF, 0x52, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xDA, 0x52, 0xC2, 0xCF, 0x51, 0xC1, 0xD4, 
	0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 
	0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5C, 0xCC, 0xD8, 0x52, 0xC3, 0xD9, 0x53, 0xC3, 
	0xD8, 0x59, 0xC9, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x07, 0x06, 
	0x68, 0x5C, 0x4F, 0x63, 0x5B, 0x4C, 0x65, 0x5C, 0x4A, 0x65, 0x5E, 0x56, 0x70, 0x66, 0x59, 0x90, 
	0x7E, 0x6E, 0x62, 0x58, 0x4E, 0x38, 0x5B, 0x5E, 0x2E, 0x45, 0x4C, 0x38, 0x4F, 0x4F, 0x22, 0x3C, 
	0x3F, 0x1B, 0x40, 0x49, 0x19, 0x44, 0x4A, 0x0F, 0x34, 0x3E, 0x12, 0x37, 0x3C, 0x27, 0x49, 0x4F, 
	0x29, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x3C, 0x1A, 0x49, 0x53, 0x1F, 
	0x3D, 0x3F, 0x11, 0x37, 0x40, 0x1F, 0x3A, 0x43, 0x12, 0x38, 0x40, 0x1D, 0x36, 0x3D, 0x1B, 0x31, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x13, 0x33, 0x3D, 0x39, 
	0x3B, 0x32, 0x42, 0x36, 0x33, 0x2C, 0x2C, 0x27, 0x2F, 0x26, 0x1C, 0x2F, 0x32, 0x26, 0x3A, 0x2F, 
	0x32, 0x36, 0x2F, 0x29, 0x16, 0x32, 0x3C, 0x13, 0x39, 0x44, 0x33, 0x40, 0x3F, 0x20, 0x4B, 0x54, 
	0x31, 0x40, 0x42, 0x35, 0x35, 0x30, 0x35, 0x33, 0x2C, 0x3A, 0x35, 0x2F, 0x52, 0x4B, 0x44, 0x34, 
	0x44, 0x48, 0x22, 0x48, 0x4E, 0x1A, 0x3F, 0x3F, 0x1E, 0x44, 0x47, 0x26, 0x40, 0x40, 0x48, 0x3A, 
	0x2F, 0x48, 0x40, 0x43, 0x2E, 0x38, 0x31, 0x25, 0x4C, 0x53, 0x49, 0x4A, 0x48, 0x1D, 0x4B, 0x56, 
	0x23, 0x47, 0x4E, 0x42, 0x40, 0x40, 0x54, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9B, 0xB5, 0x4D, 0xC6, 0xD7, 0x4C, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x47, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x54, 
	0xC2, 0xDD, 0x47, 0xC2, 0xD1, 0x53, 0xC2, 0xCF, 0x52, 0xC2, 0xD9, 0x56, 0xCB, 0xE2, 0x29, 0x53, 
	0x5A, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x0B, 0x09, 0x24, 0x4B, 0x52, 0x56, 0xCC, 
	0xE2, 0x52, 0xC2, 0xDA, 0x53, 0xC4, 0xD8, 0x5A, 0xCB, 0xD9, 0x51, 0xC1, 0xD7, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xC9, 0xD9, 0x5D, 
	0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x53, 0xC3, 0xD8, 0x5B, 0xCB, 0xE4, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3D, 0xA0, 0xB8, 0x49, 0xA3, 0xBA, 0x00, 0x06, 0x03, 
	0x6B, 0x5D, 0x4F, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x6D, 0x64, 0x50, 0x4E, 0x47, 0x40, 0x73, 
	0x63, 0x54, 0x73, 0x6A, 0x58, 0x64, 0x5D, 0x5A, 0x6E, 0x67, 0x5D, 0x67, 0x5A, 0x4F, 0x69, 0x5C, 
	0x4E, 0x61, 0x58, 0x4E, 0x3F, 0x49, 0x4A, 0x3C, 0x47, 0x43, 0x0F, 0x37, 0x3F, 0x1D, 0x40, 0x44, 
	0x2A, 0x4D, 0x57, 0x1B, 0x40, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x3B, 0x40, 0x1B, 0x3B, 0x3E, 0x0F, 
	0x36, 0x40, 0x1D, 0x3C, 0x42, 0x1E, 0x2B, 0x34, 0x0F, 0x38, 0x42, 0x23, 0x47, 0x47, 0x0F, 0x36, 
	0x40, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1C, 0x3A, 0x44, 0x23, 
	0x34, 0x38, 0x61, 0x57, 0x4A, 0x4C, 0x43, 0x3B, 0x29, 0x23, 0x1C, 0x25, 0x1C, 0x1C, 0x35, 0x31, 
	0x2C, 0x34, 0x32, 0x29, 0x22, 0x23, 0x29, 0x26, 0x2F, 0x2E, 0x32, 0x3B, 0x36, 0x35, 0x3B, 0x36, 
	0x33, 0x3D, 0x39, 0x39, 0x32, 0x2E, 0x38, 0x39, 0x30, 0x38, 0x31, 0x2E, 0x32, 0x32, 0x2C, 0x1E, 
	0x3B, 0x42, 0x1B, 0x3D, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3F, 0x19, 0x3D, 0x42, 0x37, 0x3B, 
	0x36, 0x33, 0x3D, 0x3B, 0x1E, 0x40, 0x42, 0x24, 0x3E, 0x3D, 0x45, 0x4B, 0x4B, 0x1C, 0x47, 0x4E, 
	0x1A, 0x4A, 0x55, 0x48, 0x44, 0x45, 0x50, 0x47, 0x3F, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB5, 0xC9, 0x4F, 0xC4, 0xD8, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 
	0xCC, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x4A, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD1, 0x50, 0xC2, 0xD1, 0x52, 0xC2, 0xDC, 0x54, 0xC6, 0xD6, 0x46, 0xAF, 0xC4, 0x02, 0x04, 
	0x03, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x06, 0x08, 0x03, 0x47, 0xA4, 
	0xBC, 0x53, 0xCA, 0xE0, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 
	0x50, 0xBF, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x52, 
	0xC3, 0xD9, 0x53, 0xC3, 0xD9, 0x5D, 0xCD, 0xD9, 0x4E, 0xBD, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x4E, 0xBE, 0xD8, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x04, 0x03, 
	0x69, 0x57, 0x4A, 0x61, 0x5B, 0x4B, 0x47, 0x3D, 0x36, 0x4A, 0x42, 0x39, 0x4C, 0x45, 0x3C, 0x69, 
	0x5E, 0x4B, 0x66, 0x63, 0x5E, 0x60, 0x5A, 0x56, 0x5E, 0x56, 0x4F, 0x60, 0x58, 0x52, 0x6A, 0x61, 
	0x52, 0x6A, 0x60, 0x53, 0x54, 0x4F, 0x49, 0x5C, 0x4C, 0x45, 0x14, 0x3B, 0x3E, 0x0E, 0x34, 0x3E, 
	0x1E, 0x42, 0x45, 0x1B, 0x3C, 0x3D, 0x2A, 0x4E, 0x58, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1C, 
	0x3C, 0x40, 0x0F, 0x37, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x20, 0x45, 0x48, 0x22, 0x46, 
	0x48, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1E, 0x31, 0x3A, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 0x39, 0x23, 
	0x39, 0x3E, 0x5D, 0x52, 0x47, 0x7E, 0x6D, 0x5C, 0x48, 0x43, 0x3D, 0x2F, 0x27, 0x1F, 0x35, 0x31, 
	0x2E, 0x2B, 0x1E, 0x18, 0x11, 0x24, 0x25, 0x31, 0x29, 0x24, 0x36, 0x33, 0x2C, 0x38, 0x38, 0x2F, 
	0x38, 0x39, 0x2F, 0x38, 0x2C, 0x2F, 0x33, 0x38, 0x31, 0x36, 0x3D, 0x38, 0x18, 0x39, 0x3F, 0x1C, 
	0x39, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1A, 0x40, 
	0x42, 0x1A, 0x40, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x39, 0x40, 0x57, 0x48, 0x3D, 0x4E, 0x44, 0x40, 
	0x33, 0x50, 0x51, 0x4D, 0x4C, 0x48, 0x59, 0x4F, 0x46, 0x54, 0x4A, 0x3F, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4D, 0xC6, 0xD7, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x52, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 0x55, 0xC2, 0xD9, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD2, 0x52, 0xC2, 0xD0, 0x53, 0xC3, 0xD6, 0x4F, 0xC2, 0xD9, 0x32, 0x70, 0x7D, 0x02, 0x03, 
	0x00, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x0B, 0x0D, 0x0D, 0x16, 0x33, 
	0x36, 0x54, 0xC9, 0xE1, 0x54, 0xC5, 0xDD, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x51, 0xC0, 0xD9, 
	0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD9, 0x50, 
	0xBF, 0xD9, 0x59, 0xC9, 0xD9, 0x51, 0xC1, 0xD9, 0x58, 0xC8, 0xD9, 0x5B, 0xCB, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x59, 0x53, 0x45, 0x73, 0x64, 0x52, 0x4A, 0x43, 0x3A, 0x4E, 0x46, 0x3C, 0x4C, 0x44, 0x3A, 0x59, 
	0x52, 0x49, 0x6A, 0x5E, 0x4B, 0x70, 0x65, 0x52, 0x7C, 0x6F, 0x62, 0x65, 0x5E, 0x52, 0x6F, 0x62, 
	0x51, 0x69, 0x5F, 0x53, 0x47, 0x4A, 0x48, 0x62, 0x59, 0x50, 0x60, 0x55, 0x4D, 0x1C, 0x3D, 0x42, 
	0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x3D, 0x29, 0x4D, 0x57, 0x1B, 0x3C, 0x3D, 0x1D, 0x3D, 0x40, 0x1D, 
	0x3D, 0x40, 0x1F, 0x43, 0x40, 0x1E, 0x3E, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x1C, 0x2B, 
	0x34, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 
	0x1E, 0x2F, 0x38, 0x14, 0x27, 0x28, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x16, 
	0x2B, 0x37, 0x3E, 0x38, 0x2F, 0x77, 0x69, 0x55, 0x42, 0x3F, 0x36, 0x38, 0x38, 0x32, 0x35, 0x33, 
	0x2C, 0x29, 0x23, 0x1E, 0x28, 0x1A, 0x18, 0x3B, 0x36, 0x33, 0x38, 0x3A, 0x30, 0x37, 0x39, 0x30, 
	0x35, 0x31, 0x2C, 0x39, 0x2E, 0x2F, 0x36, 0x35, 0x2F, 0x33, 0x44, 0x44, 0x1A, 0x42, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1B, 0x3F, 0x3E, 0x23, 0x38, 0x3E, 0x56, 0x57, 0x4D, 0x52, 0x48, 0x3D, 
	0x4F, 0x43, 0x3B, 0x50, 0x4D, 0x46, 0x51, 0x4F, 0x49, 0x57, 0x4D, 0x49, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x4B, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x4D, 
	0xC2, 0xD0, 0x52, 0xC2, 0xDB, 0x51, 0xC5, 0xD9, 0x46, 0xAE, 0xC2, 0x02, 0x04, 0x03, 0x08, 0x04, 
	0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x16, 0x16, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x04, 0x04, 
	0x04, 0x40, 0x97, 0xA9, 0x54, 0xC9, 0xDF, 0x5C, 0xCD, 0xDC, 0x5D, 0xCD, 0xD8, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x50, 0xBF, 0xD9, 0x53, 
	0xC3, 0xD9, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5B, 0xCB, 
	0xD7, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x95, 0xA4, 0x0E, 0x0B, 0x11, 
	0x48, 0x3D, 0x3A, 0x6F, 0x64, 0x51, 0x47, 0x3E, 0x37, 0x48, 0x3D, 0x36, 0x4F, 0x46, 0x3D, 0x4C, 
	0x44, 0x3A, 0x4E, 0x45, 0x3D, 0x53, 0x4C, 0x43, 0x82, 0x72, 0x65, 0x74, 0x6A, 0x5E, 0x69, 0x61, 
	0x50, 0x67, 0x5E, 0x53, 0x50, 0x4D, 0x48, 0x5C, 0x54, 0x4C, 0x64, 0x58, 0x4F, 0x2E, 0x46, 0x45, 
	0x0E, 0x35, 0x3F, 0x1D, 0x3D, 0x3E, 0x23, 0x45, 0x4C, 0x1C, 0x40, 0x3E, 0x1D, 0x40, 0x40, 0x1E, 
	0x42, 0x40, 0x11, 0x35, 0x40, 0x12, 0x38, 0x42, 0x1E, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x22, 0x45, 
	0x4A, 0x1D, 0x30, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 
	0x1D, 0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x31, 0x3A, 0x1D, 0x3A, 0x43, 0x1A, 
	0x39, 0x40, 0x36, 0x34, 0x29, 0x44, 0x38, 0x34, 0x46, 0x3E, 0x36, 0x28, 0x20, 0x19, 0x2F, 0x2E, 
	0x24, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x36, 0x34, 0x2C, 0x37, 0x2C, 0x2F, 0x3F, 0x35, 0x33, 
	0x35, 0x2C, 0x2B, 0x37, 0x33, 0x2F, 0x16, 0x38, 0x40, 0x1A, 0x33, 0x3D, 0x1A, 0x3B, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x23, 0x47, 0x4C, 0x20, 0x38, 0x3E, 0x5C, 0x4F, 0x46, 0x63, 0x5B, 0x4A, 
	0x4C, 0x44, 0x3A, 0x4D, 0x44, 0x3A, 0x55, 0x4C, 0x43, 0x57, 0x4D, 0x48, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC6, 0xD5, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 
	0xC2, 0xD4, 0x52, 0xC2, 0xDA, 0x53, 0xCA, 0xDD, 0x35, 0x7E, 0x8B, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x08, 0x08, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0B, 0x15, 
	0x14, 0x16, 0x2A, 0x2A, 0x4E, 0xBF, 0xDB, 0x54, 0xC5, 0xDE, 0x4F, 0xBF, 0xD8, 0x50, 0xC0, 0xD9, 
	0x57, 0xC6, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x59, 0xC9, 0xDC, 0x4F, 0xBE, 0xD7, 0x5D, 
	0xCE, 0xD9, 0x4E, 0xBD, 0xD9, 0x5B, 0xCB, 0xD9, 0x52, 0xC2, 0xD8, 0x52, 0xC3, 0xDA, 0x5A, 0xCA, 
	0xE3, 0x5A, 0xCA, 0xDC, 0x58, 0xCA, 0xE1, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x07, 0x02, 0x00, 
	0x4B, 0x47, 0x3C, 0x52, 0x4A, 0x43, 0x53, 0x4B, 0x40, 0x4D, 0x44, 0x3B, 0x49, 0x3E, 0x37, 0x4A, 
	0x40, 0x38, 0x3B, 0x32, 0x30, 0x47, 0x43, 0x3A, 0x72, 0x65, 0x58, 0x77, 0x67, 0x59, 0x73, 0x65, 
	0x55, 0x71, 0x63, 0x52, 0x5D, 0x54, 0x4D, 0x57, 0x4F, 0x47, 0x63, 0x58, 0x4C, 0x2E, 0x47, 0x4A, 
	0x0E, 0x34, 0x3E, 0x22, 0x46, 0x46, 0x1B, 0x2C, 0x37, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 
	0x42, 0x40, 0x1D, 0x3D, 0x40, 0x12, 0x37, 0x40, 0x1E, 0x3A, 0x3C, 0x1B, 0x30, 0x39, 0x0F, 0x38, 
	0x42, 0x1C, 0x3C, 0x42, 0x1D, 0x2F, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x15, 0x35, 0x3E, 0x2C, 0x2E, 0x29, 0x1B, 0x31, 0x3A, 0x1B, 
	0x36, 0x40, 0x2C, 0x2F, 0x29, 0x39, 0x31, 0x28, 0x5C, 0x54, 0x4B, 0x2C, 0x26, 0x24, 0x32, 0x2A, 
	0x24, 0x2F, 0x30, 0x26, 0x38, 0x34, 0x2E, 0x35, 0x3D, 0x39, 0x36, 0x39, 0x34, 0x37, 0x2C, 0x2F, 
	0x3A, 0x3A, 0x2E, 0x25, 0x3D, 0x44, 0x1B, 0x3C, 0x40, 0x1A, 0x3D, 0x42, 0x36, 0x43, 0x40, 0x1A, 
	0x34, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x39, 
	0x3F, 0x1F, 0x44, 0x45, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4D, 0x47, 0x43, 0x5C, 0x54, 0x46, 
	0x4D, 0x45, 0x3B, 0x48, 0x3D, 0x35, 0x58, 0x50, 0x48, 0x58, 0x4D, 0x4A, 0x1A, 0x1B, 0x1F, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC8, 0x4A, 0xBE, 0xCD, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 0x52, 
	0xC2, 0xDA, 0x53, 0xC3, 0xD8, 0x54, 0xC5, 0xE1, 0x03, 0x07, 0x06, 0x07, 0x03, 0x03, 0x0C, 0x0C, 
	0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x08, 0x08, 
	0x0B, 0x0C, 0x0C, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x12, 
	0x11, 0x0F, 0x11, 0x15, 0x3D, 0x89, 0x98, 0x5A, 0xCF, 0xE4, 0x5B, 0xCC, 0xDB, 0x59, 0xC9, 0xD7, 
	0x4F, 0xBF, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x4F, 0xBF, 0xD7, 0x5D, 0xCD, 0xE4, 0x4E, 
	0xBD, 0xD7, 0x59, 0xC9, 0xD8, 0x5B, 0xCB, 0xD8, 0x51, 0xC2, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 
	0xD9, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x58, 0x51, 0x43, 0x61, 0x59, 0x4A, 0x4D, 0x45, 0x3D, 0x5B, 0x53, 0x49, 0x47, 0x3D, 0x35, 0x4B, 
	0x42, 0x38, 0x4B, 0x40, 0x38, 0x43, 0x3D, 0x34, 0x69, 0x5E, 0x54, 0x6F, 0x61, 0x4F, 0x61, 0x5A, 
	0x49, 0x78, 0x67, 0x55, 0x60, 0x5E, 0x5E, 0x62, 0x5D, 0x56, 0x60, 0x55, 0x48, 0x3F, 0x53, 0x51, 
	0x0F, 0x37, 0x3D, 0x22, 0x4C, 0x52, 0x1F, 0x42, 0x45, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 
	0x3B, 0x40, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x1C, 0x32, 0x3B, 0x1E, 0x37, 0x3C, 0x1F, 0x2B, 
	0x35, 0x11, 0x39, 0x43, 0x1E, 0x2F, 0x37, 0x18, 0x2F, 0x35, 0x1B, 0x2B, 0x32, 0x16, 0x29, 0x2C, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x1D, 0x2E, 0x36, 0x1B, 
	0x37, 0x3F, 0x1E, 0x34, 0x3B, 0x6F, 0x61, 0x55, 0x71, 0x64, 0x56, 0x2B, 0x26, 0x24, 0x31, 0x26, 
	0x22, 0x30, 0x2B, 0x20, 0x2F, 0x2F, 0x29, 0x1F, 0x46, 0x4A, 0x35, 0x3C, 0x37, 0x38, 0x30, 0x2F, 
	0x3D, 0x32, 0x2C, 0x18, 0x3D, 0x43, 0x1D, 0x3D, 0x42, 0x1A, 0x29, 0x34, 0x35, 0x43, 0x42, 0x22, 
	0x42, 0x40, 0x1C, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1E, 0x44, 0x47, 0x30, 0x3F, 0x3F, 0x50, 0x44, 0x3E, 0x60, 0x58, 0x4A, 
	0x4D, 0x45, 0x3B, 0x3B, 0x38, 0x30, 0x58, 0x4F, 0x46, 0x4C, 0x45, 0x39, 0x1B, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC7, 0x4C, 0xC5, 0xD6, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD0, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD3, 0x4E, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 
	0xC1, 0xD9, 0x52, 0xCB, 0xDE, 0x3D, 0x90, 0xA0, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 
	0x13, 0x09, 0x15, 0x14, 0x18, 0x1F, 0x20, 0x4E, 0xBB, 0xD2, 0x5C, 0xCF, 0xE3, 0x5B, 0xCB, 0xE3, 
	0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD9, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xDB, 0x5A, 0xCA, 0xD6, 0x5B, 
	0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 
	0xD7, 0x5B, 0xCB, 0xD8, 0x51, 0xC4, 0xD7, 0x49, 0x9E, 0xB7, 0x3A, 0x95, 0xA5, 0x02, 0x06, 0x04, 
	0x5D, 0x52, 0x45, 0x64, 0x5C, 0x4B, 0x66, 0x5E, 0x4C, 0x5C, 0x54, 0x47, 0x4F, 0x47, 0x3C, 0x3D, 
	0x34, 0x32, 0x4B, 0x42, 0x38, 0x4A, 0x3F, 0x37, 0x43, 0x3D, 0x3C, 0x67, 0x5E, 0x51, 0x59, 0x52, 
	0x4A, 0x6E, 0x60, 0x4E, 0x5E, 0x57, 0x48, 0x6F, 0x65, 0x53, 0x63, 0x5B, 0x49, 0x53, 0x49, 0x42, 
	0x14, 0x2B, 0x37, 0x15, 0x3E, 0x45, 0x23, 0x48, 0x4C, 0x22, 0x40, 0x3F, 0x19, 0x38, 0x3E, 0x33, 
	0x3B, 0x3A, 0x13, 0x36, 0x40, 0x13, 0x38, 0x40, 0x12, 0x39, 0x42, 0x12, 0x39, 0x42, 0x19, 0x33, 
	0x3B, 0x12, 0x39, 0x42, 0x1F, 0x2C, 0x35, 0x0F, 0x3B, 0x44, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1B, 
	0x2E, 0x36, 0x20, 0x34, 0x38, 0x6C, 0x64, 0x5A, 0x8F, 0x7C, 0x6C, 0x5A, 0x52, 0x47, 0x4F, 0x4A, 
	0x47, 0x2B, 0x34, 0x31, 0x18, 0x30, 0x3C, 0x24, 0x4D, 0x55, 0x31, 0x3F, 0x3D, 0x3B, 0x38, 0x2C, 
	0x20, 0x32, 0x38, 0x1C, 0x3D, 0x42, 0x1C, 0x3B, 0x3E, 0x1B, 0x35, 0x38, 0x1A, 0x3D, 0x3F, 0x1C, 
	0x3F, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x28, 0x4C, 0x54, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4E, 0x48, 0x43, 0x5B, 0x52, 0x4A, 
	0x4D, 0x46, 0x3B, 0x4A, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 0x47, 0x43, 0x38, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9C, 0xB5, 0x50, 0xC5, 0xD9, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD1, 0x55, 0xC2, 
	0xDD, 0x47, 0xC2, 0xD0, 0x51, 0xC2, 0xD8, 0x4A, 0xC2, 0xD3, 0x49, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 
	0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x4F, 
	0xC3, 0xD8, 0x53, 0xC5, 0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 
	0x14, 0x08, 0x0F, 0x0E, 0x0D, 0x12, 0x13, 0x31, 0x6B, 0x77, 0x5B, 0xCC, 0xE1, 0x4E, 0xBF, 0xD8, 
	0x5C, 0xCD, 0xD8, 0x4F, 0xBE, 0xD9, 0x50, 0xBF, 0xD8, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xE2, 0x5B, 0xCB, 0xD6, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 0xDA, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x57, 0x50, 0x42, 0x66, 0x5E, 0x4C, 0x59, 0x51, 0x45, 0x4B, 0x43, 0x39, 0x4A, 0x3F, 0x37, 0x31, 
	0x30, 0x2C, 0x4C, 0x42, 0x39, 0x4C, 0x42, 0x39, 0x49, 0x3E, 0x36, 0x51, 0x49, 0x3F, 0x4C, 0x44, 
	0x3B, 0x57, 0x50, 0x47, 0x72, 0x66, 0x54, 0x62, 0x5A, 0x52, 0x66, 0x5D, 0x51, 0x51, 0x4C, 0x45, 
	0x16, 0x28, 0x34, 0x1A, 0x3F, 0x3F, 0x2B, 0x44, 0x46, 0x32, 0x42, 0x42, 0x26, 0x37, 0x3C, 0x36, 
	0x2E, 0x20, 0x18, 0x43, 0x4B, 0x12, 0x37, 0x3F, 0x1A, 0x32, 0x3A, 0x19, 0x33, 0x3B, 0x19, 0x34, 
	0x3C, 0x12, 0x3A, 0x43, 0x1B, 0x31, 0x39, 0x1E, 0x36, 0x3E, 0x1D, 0x3B, 0x45, 0x1D, 0x2F, 0x38, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3A, 0x44, 0x1D, 
	0x2E, 0x36, 0x18, 0x38, 0x42, 0x35, 0x3F, 0x40, 0x8A, 0x79, 0x67, 0x62, 0x58, 0x4D, 0x5D, 0x57, 
	0x50, 0x22, 0x3B, 0x42, 0x1B, 0x3D, 0x40, 0x1E, 0x35, 0x3D, 0x3B, 0x31, 0x2B, 0x3B, 0x38, 0x2E, 
	0x15, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x27, 0x4C, 0x52, 0x27, 0x4D, 0x58, 0x1E, 0x45, 0x49, 0x1C, 
	0x42, 0x44, 0x20, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 
	0x40, 0x1C, 0x36, 0x3E, 0x1B, 0x42, 0x40, 0x23, 0x3F, 0x40, 0x53, 0x47, 0x3E, 0x53, 0x4B, 0x40, 
	0x48, 0x3D, 0x36, 0x4A, 0x40, 0x38, 0x49, 0x3F, 0x37, 0x53, 0x47, 0x3C, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 
	0xD1, 0x4B, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x54, 0xC2, 0xDB, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 
	0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x53, 0xC2, 0xDB, 0x4C, 0xC1, 0xD4, 0x55, 
	0xC9, 0xDD, 0x40, 0x90, 0x9F, 0x03, 0x06, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x11, 
	0x11, 0x16, 0x2C, 0x2C, 0x09, 0x14, 0x13, 0x11, 0x0D, 0x0F, 0x4F, 0xBC, 0xD3, 0x5C, 0xCE, 0xE2, 
	0x51, 0xC1, 0xDB, 0x5C, 0xCC, 0xD8, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 0xD7, 0x5B, 
	0xCB, 0xD8, 0x4F, 0xBE, 0xD9, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD8, 0x50, 0xBF, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x54, 0x4D, 0x42, 0x54, 0x4C, 0x46, 0x62, 0x5A, 0x4A, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3D, 0x40, 
	0x36, 0x33, 0x4D, 0x43, 0x39, 0x2F, 0x34, 0x2B, 0x4B, 0x3F, 0x38, 0x54, 0x4C, 0x43, 0x53, 0x4A, 
	0x40, 0x57, 0x4F, 0x46, 0x6A, 0x5E, 0x4D, 0x5F, 0x57, 0x51, 0x6C, 0x63, 0x50, 0x67, 0x59, 0x4E, 
	0x18, 0x31, 0x3A, 0x0F, 0x37, 0x40, 0x1E, 0x3B, 0x42, 0x36, 0x3C, 0x37, 0x3B, 0x39, 0x2E, 0x32, 
	0x2E, 0x25, 0x20, 0x35, 0x3C, 0x16, 0x3B, 0x42, 0x11, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1E, 0x2F, 
	0x38, 0x1B, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x37, 0x16, 0x28, 0x2A, 0x18, 0x2A, 0x2E, 
	0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3E, 0x44, 0x1D, 
	0x2E, 0x36, 0x1B, 0x2F, 0x38, 0x25, 0x3D, 0x43, 0x68, 0x5B, 0x4F, 0x3E, 0x45, 0x46, 0x49, 0x3B, 
	0x38, 0x12, 0x28, 0x35, 0x19, 0x3D, 0x43, 0x28, 0x42, 0x3F, 0x39, 0x37, 0x2E, 0x3B, 0x38, 0x2E, 
	0x14, 0x36, 0x42, 0x0F, 0x37, 0x40, 0x1A, 0x31, 0x3B, 0x3A, 0x44, 0x40, 0x26, 0x49, 0x51, 0x1A, 
	0x4B, 0x55, 0x20, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x0F, 0x35, 0x40, 0x1E, 0x42, 0x40, 0x1D, 0x3D, 
	0x40, 0x1B, 0x40, 0x3D, 0x1B, 0x3D, 0x40, 0x1E, 0x3B, 0x3E, 0x62, 0x56, 0x4D, 0x4A, 0x42, 0x38, 
	0x4F, 0x47, 0x3D, 0x49, 0x3F, 0x37, 0x4A, 0x3F, 0x38, 0x40, 0x3B, 0x31, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD0, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 
	0x4B, 0xC2, 0xD0, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x54, 
	0xC8, 0xDF, 0x28, 0x51, 0x58, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0C, 0x16, 
	0x16, 0x15, 0x29, 0x29, 0x09, 0x1D, 0x1D, 0x1A, 0x18, 0x19, 0x2C, 0x58, 0x65, 0x53, 0xC7, 0xDF, 
	0x5D, 0xCD, 0xDC, 0x52, 0xC2, 0xD8, 0x50, 0xC0, 0xD9, 0x52, 0xC2, 0xD7, 0x5A, 0xCA, 0xE3, 0x5B, 
	0xCB, 0xD7, 0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD9, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDD, 0x58, 0xCA, 0xDF, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x63, 0x59, 0x4B, 0x54, 0x4C, 0x42, 0x50, 0x48, 0x3E, 0x4A, 0x40, 0x42, 0x4A, 0x40, 0x37, 0x38, 
	0x30, 0x30, 0x4B, 0x42, 0x38, 0x4D, 0x43, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x34, 0x50, 0x48, 0x3C, 0x78, 0x6D, 0x5A, 0x66, 0x63, 0x5D, 0x61, 0x58, 0x4F, 0x64, 0x58, 0x4A, 
	0x2A, 0x39, 0x39, 0x0C, 0x37, 0x42, 0x35, 0x39, 0x35, 0x36, 0x3D, 0x38, 0x38, 0x2F, 0x2E, 0x3A, 
	0x30, 0x33, 0x32, 0x2E, 0x20, 0x20, 0x36, 0x3C, 0x1A, 0x40, 0x40, 0x1B, 0x32, 0x3D, 0x14, 0x25, 
	0x25, 0x14, 0x2B, 0x30, 0x1D, 0x40, 0x44, 0x1D, 0x40, 0x43, 0x1D, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x19, 0x31, 0x39, 0x1C, 0x32, 0x39, 0x60, 0x53, 0x48, 0x44, 0x3A, 0x30, 0x3F, 0x44, 
	0x47, 0x38, 0x3E, 0x39, 0x34, 0x3D, 0x39, 0x2E, 0x2A, 0x1F, 0x39, 0x39, 0x31, 0x38, 0x38, 0x2F, 
	0x36, 0x2E, 0x2E, 0x1B, 0x46, 0x43, 0x1A, 0x37, 0x42, 0x2F, 0x40, 0x40, 0x33, 0x3D, 0x39, 0x24, 
	0x42, 0x42, 0x1D, 0x4B, 0x55, 0x35, 0x3E, 0x3C, 0x1B, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x18, 0x39, 0x3D, 0x39, 0x3B, 0x3E, 0x63, 0x5A, 0x4B, 0x5A, 0x52, 0x48, 
	0x4C, 0x44, 0x3A, 0x4B, 0x42, 0x39, 0x4F, 0x47, 0x3C, 0x57, 0x4C, 0x43, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9A, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xDA, 0x54, 0xC2, 0xDB, 
	0x4C, 0xC2, 0xD2, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xCF, 0x4D, 0xC2, 0xD0, 0x4D, 0xC4, 0xD6, 0x51, 
	0xBD, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x09, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x11, 0x11, 0x16, 0x2B, 
	0x2B, 0x12, 0x29, 0x29, 0x2E, 0x1B, 0x1B, 0x22, 0x15, 0x14, 0x0D, 0x16, 0x18, 0x44, 0xA4, 0xB5, 
	0x5A, 0xCD, 0xE2, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x5C, 0xCD, 0xDB, 0x5B, 0xCB, 0xE0, 0x5B, 
	0xCB, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5B, 0xCB, 
	0xDA, 0x5A, 0xCA, 0xE2, 0x58, 0xCA, 0xDE, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x70, 0x5F, 0x54, 0x65, 0x5C, 0x4D, 0x51, 0x49, 0x42, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x3D, 
	0x35, 0x32, 0x4C, 0x42, 0x39, 0x39, 0x33, 0x30, 0x3C, 0x3A, 0x31, 0x35, 0x36, 0x2E, 0x34, 0x36, 
	0x2E, 0x45, 0x3D, 0x35, 0x66, 0x5D, 0x52, 0x72, 0x63, 0x50, 0x61, 0x59, 0x52, 0x5B, 0x55, 0x4F, 
	0x35, 0x48, 0x47, 0x1B, 0x35, 0x3F, 0x22, 0x3F, 0x42, 0x1D, 0x3D, 0x43, 0x3A, 0x37, 0x34, 0x2E, 
	0x23, 0x15, 0x30, 0x31, 0x27, 0x2E, 0x28, 0x23, 0x1B, 0x49, 0x52, 0x1D, 0x44, 0x40, 0x1E, 0x31, 
	0x3C, 0x16, 0x29, 0x2B, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x37, 0x1B, 0x2E, 0x37, 0x19, 
	0x2A, 0x31, 0x18, 0x35, 0x3E, 0x11, 0x3A, 0x45, 0x33, 0x3A, 0x3A, 0x4E, 0x40, 0x37, 0x51, 0x48, 
	0x42, 0x4E, 0x43, 0x39, 0x49, 0x3F, 0x35, 0x37, 0x2F, 0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2F, 
	0x31, 0x3C, 0x39, 0x1B, 0x2A, 0x36, 0x19, 0x30, 0x39, 0x44, 0x44, 0x40, 0x40, 0x31, 0x2B, 0x24, 
	0x48, 0x4E, 0x1D, 0x4B, 0x54, 0x37, 0x52, 0x52, 0x24, 0x3F, 0x45, 0x1C, 0x3D, 0x3E, 0x1B, 0x3D, 
	0x3D, 0x2A, 0x4E, 0x58, 0x18, 0x3A, 0x3D, 0x39, 0x3C, 0x3F, 0x66, 0x5C, 0x4B, 0x56, 0x4E, 0x43, 
	0x50, 0x48, 0x3F, 0x50, 0x48, 0x42, 0x47, 0x3D, 0x35, 0x53, 0x49, 0x3D, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x39, 0x98, 0xB2, 0x50, 0xC1, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 
	0x54, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC1, 0xD9, 0x57, 
	0xCE, 0xE2, 0x4D, 0xBB, 0xCF, 0x12, 0x2E, 0x32, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x0B, 0x08, 
	0x08, 0x0B, 0x0F, 0x0F, 0x0B, 0x15, 0x15, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x18, 0x2F, 0x2F, 0x07, 0x0E, 0x0E, 0x0E, 0x1D, 
	0x1C, 0x0B, 0x1A, 0x19, 0x19, 0x15, 0x16, 0x0F, 0x12, 0x14, 0x2A, 0x4F, 0x55, 0x44, 0xAB, 0xBE, 
	0x5A, 0xCC, 0xDF, 0x4F, 0xBF, 0xD8, 0x51, 0xC0, 0xD9, 0x50, 0xBF, 0xD8, 0x50, 0xBF, 0xD8, 0x4F, 
	0xBE, 0xD8, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 
	0xE2, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDB, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x71, 0x62, 0x59, 0x66, 0x5E, 0x4D, 0x64, 0x5D, 0x4B, 0x53, 0x4B, 0x43, 0x4E, 0x46, 0x3E, 0x4A, 
	0x40, 0x37, 0x4E, 0x46, 0x3B, 0x39, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x37, 0x37, 0x2F, 0x36, 0x36, 
	0x2F, 0x43, 0x3E, 0x35, 0x62, 0x59, 0x4C, 0x76, 0x6C, 0x59, 0x6A, 0x60, 0x52, 0x51, 0x4B, 0x47, 
	0x1B, 0x31, 0x39, 0x19, 0x3D, 0x40, 0x1C, 0x3E, 0x40, 0x1B, 0x36, 0x40, 0x20, 0x39, 0x3C, 0x33, 
	0x26, 0x1D, 0x30, 0x30, 0x27, 0x2B, 0x30, 0x2A, 0x16, 0x2F, 0x3A, 0x18, 0x3E, 0x42, 0x1D, 0x33, 
	0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1A, 0x2E, 0x37, 0x1F, 0x35, 0x39, 0x24, 0x36, 0x3B, 0x20, 
	0x34, 0x37, 0x15, 0x29, 0x2B, 0x13, 0x24, 0x25, 0x1E, 0x37, 0x42, 0x40, 0x39, 0x2C, 0x46, 0x3C, 
	0x3C, 0x55, 0x4D, 0x43, 0x46, 0x3D, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x3B, 0x3E, 0x11, 0x36, 0x3F, 0x19, 0x2B, 0x36, 0x33, 0x3D, 0x39, 0x39, 0x37, 0x2C, 0x2B, 
	0x3D, 0x3B, 0x12, 0x38, 0x43, 0x20, 0x4C, 0x56, 0x31, 0x43, 0x45, 0x19, 0x42, 0x47, 0x1D, 0x34, 
	0x3E, 0x1B, 0x3B, 0x3D, 0x1C, 0x3B, 0x42, 0x1B, 0x35, 0x3E, 0x4C, 0x3D, 0x33, 0x4F, 0x47, 0x3E, 
	0x6A, 0x62, 0x4E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x40, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9B, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xD7, 0x53, 0xC2, 0xDB, 
	0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4E, 
	0xC1, 0xD1, 0x56, 0xCA, 0xDF, 0x40, 0xA2, 0xB5, 0x2A, 0x67, 0x73, 0x0D, 0x0D, 0x0F, 0x02, 0x00, 
	0x00, 0x06, 0x07, 0x06, 0x07, 0x09, 0x08, 0x09, 0x06, 0x04, 0x09, 0x0E, 0x0D, 0x0B, 0x0D, 0x0D, 
	0x09, 0x0D, 0x0D, 0x09, 0x0D, 0x0D, 0x11, 0x0D, 0x0D, 0x08, 0x0F, 0x0F, 0x09, 0x13, 0x12, 0x09, 
	0x12, 0x12, 0x09, 0x12, 0x12, 0x08, 0x11, 0x11, 0x0D, 0x1B, 0x1A, 0x0E, 0x19, 0x1A, 0x14, 0x0F, 
	0x14, 0x1F, 0x19, 0x16, 0x29, 0x61, 0x6D, 0x3F, 0xA5, 0xBC, 0x56, 0xC9, 0xE1, 0x5A, 0xCD, 0xDD, 
	0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 0xD8, 0x5B, 
	0xCB, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x75, 0x67, 0x56, 0x61, 0x5A, 0x49, 0x53, 0x4C, 0x40, 0x4D, 0x45, 0x40, 0x49, 
	0x3F, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x46, 0x3B, 0x42, 0x39, 0x34, 0x3C, 0x3A, 0x32, 0x3E, 0x3B, 
	0x33, 0x2E, 0x29, 0x27, 0x3D, 0x36, 0x31, 0x6B, 0x61, 0x52, 0x60, 0x5B, 0x57, 0x57, 0x4B, 0x43, 
	0x12, 0x2C, 0x37, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3E, 0x40, 0x25, 0x43, 0x46, 0x38, 
	0x2B, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x25, 0x31, 0x2E, 0x2A, 0x11, 0x39, 0x44, 0x1B, 0x36, 
	0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x14, 0x27, 0x27, 0x19, 0x2A, 0x2F, 0x1E, 0x34, 0x3A, 0x7A, 0x68, 0x59, 0x7D, 0x78, 0x6E, 0x89, 
	0x77, 0x63, 0x60, 0x5D, 0x55, 0x0F, 0x28, 0x2F, 0x12, 0x25, 0x25, 0x1F, 0x39, 0x43, 0x33, 0x38, 
	0x35, 0x57, 0x4D, 0x43, 0x3F, 0x3A, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x38, 0x3B, 0x19, 0x3A, 0x42, 0x2F, 0x3A, 0x39, 0x3F, 0x3A, 0x30, 0x34, 0x36, 0x2E, 0x54, 
	0x42, 0x3A, 0x1D, 0x3C, 0x45, 0x1F, 0x47, 0x4B, 0x36, 0x3B, 0x37, 0x34, 0x44, 0x44, 0x13, 0x3F, 
	0x47, 0x1D, 0x3C, 0x40, 0x1D, 0x29, 0x34, 0x1B, 0x3D, 0x40, 0x1D, 0x45, 0x4A, 0x44, 0x38, 0x2C, 
	0x52, 0x47, 0x42, 0x54, 0x4C, 0x44, 0x5D, 0x55, 0x46, 0x52, 0x4A, 0x42, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x50, 0xC2, 0xD0, 0x52, 0xC2, 0xD0, 0x53, 0xC2, 0xD9, 
	0x4D, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x49, 0xC2, 0xCE, 0x53, 
	0xC2, 0xDB, 0x49, 0xC1, 0xCF, 0x58, 0xCA, 0xDD, 0x54, 0xC7, 0xDE, 0x4C, 0xB5, 0xCB, 0x44, 0x9C, 
	0xAE, 0x29, 0x5D, 0x6A, 0x1A, 0x28, 0x29, 0x07, 0x07, 0x09, 0x06, 0x04, 0x06, 0x02, 0x04, 0x02, 
	0x0C, 0x0E, 0x0C, 0x0C, 0x0F, 0x0D, 0x0B, 0x0F, 0x0D, 0x0E, 0x11, 0x11, 0x0D, 0x13, 0x13, 0x11, 
	0x11, 0x14, 0x0E, 0x0D, 0x11, 0x14, 0x0F, 0x0F, 0x14, 0x23, 0x20, 0x28, 0x56, 0x61, 0x3E, 0x89, 
	0x9A, 0x49, 0xB5, 0xCB, 0x5C, 0xCC, 0xE2, 0x5A, 0xCE, 0xE0, 0x5C, 0xCD, 0xDF, 0x5B, 0xCB, 0xDB, 
	0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xDA, 0x5A, 
	0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD5, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x71, 0x67, 0x55, 0x60, 0x58, 0x48, 0x69, 0x60, 0x4E, 0x4B, 0x43, 0x3F, 0x48, 
	0x3E, 0x38, 0x4F, 0x47, 0x3C, 0x4F, 0x48, 0x3D, 0x3E, 0x35, 0x32, 0x3B, 0x33, 0x31, 0x35, 0x37, 
	0x2E, 0x37, 0x38, 0x2F, 0x3F, 0x3B, 0x33, 0x65, 0x5C, 0x50, 0x5F, 0x57, 0x4F, 0x51, 0x45, 0x38, 
	0x0F, 0x30, 0x3B, 0x18, 0x3D, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x43, 0x31, 0x2F, 0x26, 0x3B, 
	0x30, 0x33, 0x31, 0x30, 0x28, 0x2E, 0x30, 0x25, 0x37, 0x2F, 0x2A, 0x25, 0x37, 0x3B, 0x0F, 0x39, 
	0x42, 0x1B, 0x34, 0x3D, 0x1E, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x15, 0x27, 0x28, 0x12, 0x2A, 0x2B, 0x24, 0x33, 0x35, 0x5B, 0x4F, 0x44, 0x49, 0x50, 0x51, 0x6A, 
	0x66, 0x5D, 0x54, 0x56, 0x55, 0x15, 0x30, 0x35, 0x14, 0x27, 0x2C, 0x0E, 0x3A, 0x44, 0x18, 0x32, 
	0x3B, 0x56, 0x4A, 0x40, 0x3F, 0x3B, 0x34, 0x36, 0x2E, 0x2F, 0x37, 0x38, 0x2F, 0x40, 0x3C, 0x33, 
	0x2B, 0x29, 0x27, 0x22, 0x3D, 0x47, 0x2F, 0x43, 0x43, 0x3F, 0x39, 0x2F, 0x3A, 0x39, 0x31, 0x42, 
	0x3A, 0x31, 0x47, 0x4F, 0x4F, 0x25, 0x45, 0x49, 0x1B, 0x49, 0x4F, 0x33, 0x28, 0x1B, 0x1B, 0x3A, 
	0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x36, 0x42, 0x1B, 0x3A, 0x3D, 0x1A, 0x3F, 0x3D, 0x1C, 0x42, 0x43, 
	0x31, 0x39, 0x3A, 0x4E, 0x44, 0x3F, 0x5B, 0x53, 0x4B, 0x4B, 0x44, 0x38, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 
	0xDB, 0x4D, 0xC2, 0xD0, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDD, 0x50, 0xC2, 0xD0, 0x49, 0xC2, 0xD0, 
	0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x53, 
	0xC2, 0xDA, 0x4C, 0xC1, 0xD4, 0x52, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x53, 0xC5, 0xDD, 0x54, 0xC8, 
	0xDB, 0x54, 0xC7, 0xDD, 0x50, 0xC0, 0xDA, 0x4A, 0xAE, 0xC0, 0x3E, 0x9F, 0xB0, 0x3D, 0x82, 0x94, 
	0x31, 0x6D, 0x7D, 0x27, 0x62, 0x6F, 0x2B, 0x62, 0x6E, 0x31, 0x74, 0x86, 0x33, 0x76, 0x87, 0x38, 
	0x86, 0x97, 0x3E, 0x9E, 0xAF, 0x45, 0xA9, 0xBA, 0x4F, 0xBF, 0xDA, 0x5C, 0xC9, 0xE0, 0x55, 0xCB, 
	0xDF, 0x5A, 0xCD, 0xDF, 0x51, 0xC2, 0xDA, 0x5C, 0xCC, 0xE3, 0x4E, 0xBD, 0xD7, 0x59, 0xC9, 0xD8, 
	0x4F, 0xBE, 0xD7, 0x5B, 0xCB, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x57, 0xCA, 0xDB, 0x3E, 0xA0, 0xB9, 0x3A, 0x94, 0xA3, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x58, 0x71, 0x62, 0x52, 0x5F, 0x58, 0x48, 0x67, 0x5F, 0x4D, 0x4D, 0x45, 0x3E, 0x4D, 
	0x44, 0x40, 0x4D, 0x45, 0x40, 0x4E, 0x45, 0x3E, 0x4D, 0x45, 0x3A, 0x4D, 0x43, 0x39, 0x48, 0x3F, 
	0x37, 0x32, 0x34, 0x2C, 0x48, 0x42, 0x38, 0x6C, 0x62, 0x52, 0x5E, 0x56, 0x4F, 0x53, 0x47, 0x3F, 
	0x18, 0x35, 0x3E, 0x0F, 0x35, 0x3F, 0x1E, 0x43, 0x40, 0x1D, 0x3B, 0x42, 0x15, 0x31, 0x3D, 0x31, 
	0x25, 0x15, 0x3A, 0x30, 0x33, 0x35, 0x30, 0x2C, 0x30, 0x30, 0x25, 0x27, 0x2E, 0x2E, 0x0F, 0x3A, 
	0x44, 0x16, 0x31, 0x37, 0x14, 0x25, 0x25, 0x1B, 0x2E, 0x35, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 
	0x18, 0x30, 0x36, 0x1E, 0x30, 0x3A, 0x1C, 0x32, 0x39, 0x50, 0x44, 0x3E, 0x57, 0x4E, 0x45, 0x58, 
	0x4F, 0x48, 0x5A, 0x51, 0x47, 0x53, 0x44, 0x3D, 0x3D, 0x36, 0x2E, 0x19, 0x33, 0x3D, 0x1C, 0x3C, 
	0x3F, 0x60, 0x54, 0x4B, 0x47, 0x3F, 0x39, 0x3A, 0x33, 0x30, 0x37, 0x38, 0x2F, 0x37, 0x37, 0x2F, 
	0x39, 0x3B, 0x34, 0x30, 0x43, 0x43, 0x2E, 0x3C, 0x3A, 0x30, 0x3C, 0x39, 0x4F, 0x43, 0x39, 0x39, 
	0x38, 0x2F, 0x3B, 0x3A, 0x33, 0x28, 0x44, 0x47, 0x18, 0x49, 0x4E, 0x36, 0x31, 0x26, 0x1A, 0x31, 
	0x3C, 0x1D, 0x3C, 0x40, 0x1B, 0x40, 0x3D, 0x2A, 0x4E, 0x58, 0x29, 0x4C, 0x56, 0x19, 0x3A, 0x3E, 
	0x1E, 0x35, 0x3C, 0x55, 0x4A, 0x40, 0x51, 0x49, 0x3F, 0x58, 0x4E, 0x45, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB0, 0x50, 0xC6, 0xDA, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDB, 0x4E, 0xC2, 0xD4, 0x47, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x4D, 0xC2, 0xD6, 0x54, 0xC2, 0xDC, 
	0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4F, 
	0xC1, 0xD6, 0x59, 0xC7, 0xDD, 0x51, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 
	0xDA, 0x52, 0xC3, 0xDB, 0x53, 0xC4, 0xDC, 0x53, 0xC5, 0xDE, 0x57, 0xCD, 0xE0, 0x54, 0xC9, 0xDD, 
	0x55, 0xCB, 0xE0, 0x56, 0xCD, 0xE1, 0x55, 0xCD, 0xE1, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xDE, 0x54, 
	0xC8, 0xDC, 0x56, 0xCC, 0xE0, 0x5B, 0xCD, 0xE0, 0x5C, 0xCD, 0xE2, 0x5B, 0xCC, 0xDF, 0x5B, 0xCB, 
	0xDB, 0x5A, 0xCA, 0xDD, 0x5B, 0xCB, 0xE3, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xDE, 0x54, 0xC5, 0xDD, 
	0x5C, 0xCC, 0xE3, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 
	0xCA, 0xDA, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xDC, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 
	0xDC, 0x5A, 0xCA, 0xE2, 0x5A, 0xCD, 0xDF, 0x3E, 0x9F, 0xB5, 0x48, 0xA2, 0xBA, 0x00, 0x04, 0x02, 
	0x70, 0x60, 0x57, 0x73, 0x6A, 0x57, 0x65, 0x5D, 0x50, 0x62, 0x5A, 0x49, 0x55, 0x4D, 0x42, 0x57, 
	0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4C, 0x44, 0x40, 0x4A, 0x3F, 0x36, 0x30, 0x34, 0x2B, 0x48, 0x3F, 
	0x36, 0x4D, 0x42, 0x39, 0x4C, 0x44, 0x39, 0x67, 0x62, 0x5B, 0x60, 0x58, 0x50, 0x5A, 0x4F, 0x46, 
	0x48, 0x3D, 0x33, 0x16, 0x3D, 0x48, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x34, 0x1B, 0x38, 0x42, 0x27, 
	0x2F, 0x32, 0x3B, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x26, 0x1C, 0x2C, 0x30, 0x2A, 0x19, 0x37, 
	0x42, 0x12, 0x39, 0x43, 0x1D, 0x33, 0x3C, 0x14, 0x26, 0x26, 0x19, 0x2A, 0x2F, 0x14, 0x2C, 0x31, 
	0x19, 0x36, 0x3F, 0x1A, 0x2B, 0x32, 0x1B, 0x2F, 0x38, 0x1A, 0x2C, 0x32, 0x5C, 0x51, 0x46, 0x67, 
	0x5F, 0x4B, 0x56, 0x4C, 0x44, 0x37, 0x4A, 0x4D, 0x52, 0x46, 0x3E, 0x40, 0x38, 0x30, 0x37, 0x48, 
	0x4A, 0x5E, 0x54, 0x4B, 0x50, 0x48, 0x3D, 0x4F, 0x44, 0x3A, 0x34, 0x35, 0x2C, 0x3A, 0x38, 0x2F, 
	0x25, 0x2F, 0x30, 0x35, 0x3E, 0x3A, 0x36, 0x2E, 0x29, 0x36, 0x37, 0x2E, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x34, 0x35, 0x2A, 0x2B, 0x3B, 0x3C, 0x23, 0x3E, 0x47, 0x18, 0x35, 0x39, 0x1D, 0x3A, 
	0x3E, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1A, 0x3B, 0x3B, 0x29, 0x4E, 0x58, 0x1D, 0x3A, 0x40, 
	0x35, 0x35, 0x2F, 0x4E, 0x43, 0x40, 0x50, 0x48, 0x3D, 0x56, 0x4C, 0x42, 0x1C, 0x20, 0x23, 0x32, 
	0x87, 0x98, 0x45, 0xAE, 0xC5, 0x52, 0xC5, 0xD5, 0x4A, 0xC1, 0xD0, 0x4D, 0xC1, 0xD2, 0x4F, 0xC2, 
	0xD4, 0x50, 0xC2, 0xD5, 0x51, 0xC3, 0xD6, 0x50, 0xC3, 0xD6, 0x50, 0xC2, 0xD4, 0x4F, 0xC1, 0xD4, 
	0x4F, 0xC1, 0xD4, 0x4F, 0xC2, 0xD4, 0x4F, 0xC0, 0xD3, 0x4F, 0xC4, 0xD6, 0x4F, 0xC1, 0xD4, 0x4F, 
	0xC3, 0xD6, 0x51, 0xC3, 0xD5, 0x55, 0xC8, 0xDA, 0x4F, 0xC2, 0xD4, 0x52, 0xC5, 0xD7, 0x4E, 0xC0, 
	0xD3, 0x4F, 0xC2, 0xD4, 0x4E, 0xC0, 0xD3, 0x51, 0xC6, 0xD8, 0x54, 0xC5, 0xD8, 0x56, 0xC8, 0xDB, 
	0x59, 0xCB, 0xDE, 0x57, 0xC6, 0xD9, 0x53, 0xC5, 0xD8, 0x53, 0xC6, 0xD9, 0x59, 0xCB, 0xDE, 0x53, 
	0xCA, 0xDD, 0x59, 0xCA, 0xDD, 0x52, 0xC9, 0xDC, 0x59, 0xCA, 0xDC, 0x4F, 0xC5, 0xD7, 0x52, 0xC5, 
	0xD7, 0x58, 0xCA, 0xDD, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCA, 0xDC, 
	0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 
	0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 
	0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCB, 0xDE, 0x5C, 0xD3, 0xE7, 0x3B, 0x98, 0xA6, 0x00, 0x04, 0x03, 
	0x6F, 0x60, 0x57, 0x75, 0x6C, 0x5A, 0x72, 0x67, 0x56, 0x62, 0x5A, 0x4C, 0x50, 0x48, 0x40, 0x58, 
	0x50, 0x49, 0x4E, 0x46, 0x3D, 0x5E, 0x56, 0x46, 0x4F, 0x47, 0x42, 0x46, 0x3D, 0x34, 0x38, 0x37, 
	0x32, 0x37, 0x37, 0x2E, 0x49, 0x43, 0x38, 0x66, 0x5D, 0x52, 0x67, 0x60, 0x5B, 0x43, 0x49, 0x47, 
	0x1E, 0x33, 0x39, 0x1C, 0x3A, 0x40, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1B, 0x32, 0x3C, 0x2B, 
	0x33, 0x31, 0x2F, 0x26, 0x1A, 0x36, 0x32, 0x30, 0x30, 0x28, 0x1D, 0x31, 0x31, 0x27, 0x29, 0x2E, 
	0x2C, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x34, 0x19, 0x2A, 0x2E, 0x15, 0x25, 0x25, 
	0x19, 0x37, 0x42, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x39, 0x47, 0x3D, 0x31, 0x5D, 
	0x55, 0x48, 0x54, 0x4C, 0x44, 0x57, 0x4D, 0x44, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x46, 0x5A, 0x50, 
	0x47, 0x5E, 0x56, 0x4D, 0x4F, 0x46, 0x3D, 0x4C, 0x4F, 0x4C, 0x48, 0x3C, 0x36, 0x34, 0x37, 0x2F, 
	0x12, 0x2C, 0x3B, 0x3C, 0x36, 0x2E, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x3E, 
	0x3B, 0x33, 0x50, 0x44, 0x3B, 0x3C, 0x37, 0x2C, 0x35, 0x45, 0x45, 0x27, 0x4E, 0x5A, 0x1B, 0x40, 
	0x3D, 0x1B, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x19, 0x3D, 0x3E, 0x36, 0x3B, 0x35, 
	0x4F, 0x40, 0x39, 0x3E, 0x4A, 0x4C, 0x50, 0x47, 0x42, 0x40, 0x34, 0x30, 0x1F, 0x25, 0x26, 0x46, 
	0x90, 0xA5, 0x3A, 0x9A, 0xB3, 0x33, 0x8A, 0xA4, 0x3C, 0x9B, 0xB5, 0x3F, 0xA1, 0xBA, 0x39, 0x96, 
	0xAF, 0x37, 0x92, 0xAB, 0x34, 0x8A, 0xA3, 0x33, 0x89, 0xA2, 0x39, 0x94, 0xAD, 0x3E, 0xA0, 0xB8, 
	0x3E, 0xA0, 0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x38, 0x92, 0xAB, 0x3E, 
	0x9F, 0xB7, 0x3E, 0xA0, 0xB8, 0x35, 0x8E, 0xA7, 0x33, 0x89, 0xA2, 0x36, 0x8E, 0xA7, 0x3F, 0xA1, 
	0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x37, 0x92, 0xAB, 0x3E, 0x9F, 0xB8, 
	0x3D, 0x9F, 0xB8, 0x37, 0x92, 0xAC, 0x3E, 0xA0, 0xB8, 0x37, 0x92, 0xAB, 0x3D, 0x9E, 0xB6, 0x3D, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3E, 0x9E, 0xB6, 0x3D, 0x9E, 
	0xB6, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 
	0x3C, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB6, 0x3C, 0x9D, 0xB6, 0x3D, 0x9D, 0xB5, 0x3C, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 
	0xB5, 0x3C, 0x9E, 0xB6, 0x45, 0x98, 0xB2, 0x31, 0x71, 0x80, 0x3A, 0x95, 0xA9, 0x00, 0x04, 0x03, 
	0x71, 0x62, 0x5A, 0x70, 0x65, 0x54, 0x5D, 0x56, 0x46, 0x63, 0x5B, 0x49, 0x59, 0x51, 0x4A, 0x60, 
	0x58, 0x49, 0x66, 0x5E, 0x4B, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x4D, 0x44, 0x3A, 0x53, 0x4A, 
	0x43, 0x4B, 0x40, 0x45, 0x3B, 0x37, 0x2F, 0x5B, 0x52, 0x46, 0x5F, 0x53, 0x47, 0x27, 0x44, 0x48, 
	0x1E, 0x45, 0x47, 0x1C, 0x42, 0x3F, 0x1D, 0x40, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x19, 
	0x31, 0x3D, 0x33, 0x28, 0x1C, 0x30, 0x26, 0x1B, 0x23, 0x18, 0x1C, 0x32, 0x28, 0x1D, 0x28, 0x2F, 
	0x2F, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1E, 0x2F, 0x38, 0x18, 0x36, 0x3E, 0x19, 0x37, 0x40, 
	0x11, 0x22, 0x1E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x15, 0x28, 0x2A, 0x1A, 0x32, 0x3C, 0x53, 
	0x49, 0x3E, 0x67, 0x5F, 0x4C, 0x5E, 0x56, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5F, 0x57, 
	0x4F, 0x60, 0x58, 0x4F, 0x4F, 0x45, 0x40, 0x3A, 0x4A, 0x4B, 0x4E, 0x4C, 0x4A, 0x28, 0x42, 0x44, 
	0x36, 0x35, 0x30, 0x2F, 0x2B, 0x25, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 0x3B, 0x32, 
	0x32, 0x2C, 0x3A, 0x39, 0x31, 0x50, 0x44, 0x3B, 0x3C, 0x36, 0x2B, 0x26, 0x44, 0x47, 0x26, 0x42, 
	0x47, 0x0E, 0x35, 0x3E, 0x1E, 0x3A, 0x40, 0x1D, 0x32, 0x3C, 0x1A, 0x36, 0x42, 0x34, 0x3B, 0x36, 
	0x4C, 0x3F, 0x36, 0x4F, 0x45, 0x3D, 0x4C, 0x43, 0x39, 0x49, 0x45, 0x39, 0x1C, 0x23, 0x24, 0x6B, 
	0xB4, 0xCC, 0x45, 0xBC, 0xD2, 0x3D, 0x98, 0xAE, 0x46, 0xB3, 0xC5, 0x43, 0xA2, 0xB5, 0x3F, 0x9B, 
	0xB1, 0x3F, 0x9A, 0xB0, 0x47, 0xB8, 0xCE, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB0, 0xC3, 
	0x45, 0xA8, 0xB8, 0x46, 0xB6, 0xCC, 0x45, 0xB4, 0xC9, 0x44, 0xB5, 0xCA, 0x45, 0xB5, 0xCA, 0x45, 
	0xB4, 0xC9, 0x45, 0xB4, 0xC9, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB4, 
	0xC9, 0x46, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x44, 0xB4, 0xC9, 0x45, 0xB6, 0xCC, 0x47, 0xAF, 0xC0, 
	0x4A, 0xB0, 0xC1, 0x46, 0xB3, 0xC5, 0x44, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x43, 0xB4, 0xC9, 0x43, 
	0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB3, 
	0xC9, 0x46, 0xB3, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB5, 0xCC, 
	0x49, 0xB5, 0xCC, 0x42, 0xB4, 0xC9, 0x4F, 0xB4, 0xC6, 0x52, 0xB3, 0xC6, 0x40, 0xB3, 0xC9, 0x49, 
	0xB3, 0xC9, 0x46, 0xB3, 0xC9, 0x42, 0xB3, 0xC9, 0x49, 0xB5, 0xCC, 0x48, 0xB8, 0xCF, 0x48, 0xB3, 
	0xC8, 0x42, 0xB4, 0xC9, 0x48, 0xB5, 0xC9, 0x49, 0xB7, 0xD1, 0x53, 0xC1, 0xDB, 0x00, 0x03, 0x07, 
	0x7F, 0x70, 0x58, 0x71, 0x6A, 0x59, 0x6E, 0x62, 0x52, 0x60, 0x58, 0x47, 0x56, 0x4E, 0x48, 0x6C, 
	0x60, 0x4F, 0x5C, 0x54, 0x46, 0x5A, 0x52, 0x4B, 0x53, 0x4B, 0x42, 0x4F, 0x47, 0x3D, 0x53, 0x4B, 
	0x40, 0x48, 0x3D, 0x37, 0x4C, 0x40, 0x37, 0x3F, 0x3F, 0x3D, 0x57, 0x4A, 0x42, 0x1B, 0x38, 0x3E, 
	0x19, 0x3E, 0x3F, 0x1D, 0x38, 0x3E, 0x1C, 0x2A, 0x34, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x43, 0x1B, 
	0x33, 0x3D, 0x27, 0x20, 0x1F, 0x31, 0x27, 0x1B, 0x27, 0x1D, 0x1C, 0x31, 0x29, 0x1E, 0x28, 0x30, 
	0x30, 0x0F, 0x3A, 0x44, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x32, 0x1E, 0x2F, 0x37, 0x1B, 0x33, 0x3C, 
	0x1F, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x14, 0x28, 0x2B, 0x1C, 
	0x2B, 0x31, 0x5D, 0x52, 0x44, 0x62, 0x5A, 0x53, 0x51, 0x4E, 0x49, 0x52, 0x4F, 0x4A, 0x5D, 0x54, 
	0x4C, 0x5F, 0x57, 0x4F, 0x57, 0x4E, 0x45, 0x46, 0x48, 0x44, 0x50, 0x51, 0x4D, 0x48, 0x3C, 0x35, 
	0x3C, 0x39, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x4C, 
	0x42, 0x39, 0x35, 0x30, 0x2E, 0x3A, 0x39, 0x31, 0x51, 0x43, 0x39, 0x2F, 0x3D, 0x3C, 0x33, 0x3F, 
	0x3E, 0x1E, 0x45, 0x45, 0x1B, 0x3B, 0x3C, 0x12, 0x22, 0x26, 0x1A, 0x40, 0x45, 0x2F, 0x3F, 0x40, 
	0x4C, 0x3E, 0x37, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x36, 0x45, 0x40, 0x37, 0x1F, 0x1D, 0x1F, 0x1C, 
	0x2A, 0x28, 0x20, 0x20, 0x24, 0x22, 0x2E, 0x33, 0x18, 0x28, 0x2A, 0x19, 0x2A, 0x2C, 0x19, 0x2B, 
	0x2C, 0x19, 0x2C, 0x2F, 0x16, 0x28, 0x2B, 0x18, 0x28, 0x2A, 0x19, 0x29, 0x2B, 0x19, 0x29, 0x2B, 
	0x19, 0x2A, 0x2E, 0x19, 0x29, 0x2B, 0x18, 0x2A, 0x2C, 0x27, 0x24, 0x26, 0x1F, 0x28, 0x2A, 0x18, 
	0x29, 0x2B, 0x19, 0x29, 0x2B, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x1C, 0x2B, 
	0x2A, 0x15, 0x28, 0x2A, 0x1E, 0x1E, 0x22, 0x1A, 0x2B, 0x2A, 0x1D, 0x22, 0x23, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x0F, 0x16, 0x1A, 0x25, 0x30, 0x31, 0x29, 0x30, 0x29, 0x22, 0x29, 0x2B, 0x26, 
	0x2E, 0x2B, 0x27, 0x2E, 0x28, 0x28, 0x2F, 0x2A, 0x29, 0x33, 0x2B, 0x29, 0x33, 0x2B, 0x28, 0x32, 
	0x2A, 0x28, 0x32, 0x2A, 0x27, 0x2A, 0x31, 0x27, 0x2F, 0x2E, 0x28, 0x32, 0x2A, 0x29, 0x33, 0x2B, 
	0x27, 0x32, 0x29, 0x25, 0x28, 0x2F, 0x25, 0x2E, 0x2C, 0x25, 0x31, 0x29, 0x28, 0x32, 0x2A, 0x28, 
	0x32, 0x2A, 0x27, 0x31, 0x2A, 0x28, 0x32, 0x2A, 0x28, 0x32, 0x2A, 0x27, 0x31, 0x29, 0x29, 0x31, 
	0x2C, 0x24, 0x29, 0x2E, 0x23, 0x28, 0x2E, 0x27, 0x2C, 0x2C, 0x22, 0x2E, 0x2F, 0x0F, 0x0B, 0x0B, 
	0x7E, 0x71, 0x5E, 0x72, 0x6A, 0x5C, 0x76, 0x6E, 0x5F, 0x71, 0x65, 0x54, 0x5F, 0x58, 0x52, 0x71, 
	0x65, 0x53, 0x5F, 0x58, 0x49, 0x59, 0x51, 0x4A, 0x57, 0x4F, 0x47, 0x4C, 0x43, 0x3B, 0x50, 0x4D, 
	0x46, 0x4D, 0x4A, 0x48, 0x46, 0x3F, 0x35, 0x33, 0x2F, 0x2B, 0x45, 0x3A, 0x30, 0x29, 0x46, 0x48, 
	0x18, 0x3E, 0x40, 0x1D, 0x2C, 0x37, 0x22, 0x44, 0x49, 0x1C, 0x39, 0x3E, 0x1C, 0x2A, 0x34, 0x20, 
	0x47, 0x4A, 0x19, 0x32, 0x3E, 0x33, 0x27, 0x1B, 0x30, 0x27, 0x1C, 0x30, 0x28, 0x1C, 0x20, 0x27, 
	0x2B, 0x16, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x11, 0x23, 0x1F, 
	0x1B, 0x2E, 0x35, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1C, 0x33, 0x3C, 0x1D, 
	0x2B, 0x2E, 0x4E, 0x45, 0x3A, 0x66, 0x5E, 0x54, 0x5B, 0x52, 0x47, 0x4C, 0x49, 0x44, 0x4E, 0x4C, 
	0x47, 0x5A, 0x51, 0x4A, 0x51, 0x4E, 0x48, 0x59, 0x4F, 0x45, 0x4F, 0x4B, 0x49, 0x46, 0x3D, 0x34, 
	0x4A, 0x40, 0x38, 0x36, 0x31, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x35, 
	0x37, 0x2F, 0x38, 0x39, 0x30, 0x35, 0x33, 0x2E, 0x3C, 0x3A, 0x31, 0x3E, 0x37, 0x2C, 0x23, 0x44, 
	0x48, 0x27, 0x4B, 0x56, 0x2E, 0x51, 0x55, 0x3D, 0x4D, 0x4B, 0x49, 0x4C, 0x4B, 0x42, 0x4C, 0x4C, 
	0x48, 0x43, 0x46, 0x49, 0x3E, 0x34, 0x49, 0x3F, 0x40, 0x4B, 0x40, 0x37, 0x42, 0x3E, 0x34, 0x45, 
	0x36, 0x32, 0x42, 0x3D, 0x3A, 0x1E, 0x50, 0x57, 0x1C, 0x43, 0x48, 0x1C, 0x3F, 0x49, 0x22, 0x45, 
	0x4C, 0x1E, 0x34, 0x39, 0x39, 0x3F, 0x3A, 0x22, 0x40, 0x4B, 0x1C, 0x36, 0x39, 0x1C, 0x3D, 0x42, 
	0x1C, 0x36, 0x3A, 0x1C, 0x37, 0x3B, 0x1C, 0x37, 0x3A, 0x14, 0x25, 0x28, 0x16, 0x28, 0x30, 0x20, 
	0x3D, 0x44, 0x1C, 0x3C, 0x3F, 0x23, 0x48, 0x4B, 0x23, 0x43, 0x49, 0x1F, 0x40, 0x49, 0x1B, 0x40, 
	0x4A, 0x24, 0x45, 0x4A, 0x5F, 0x56, 0x4C, 0x73, 0x65, 0x57, 0x73, 0x64, 0x59, 0x7A, 0x6D, 0x5F, 
	0x0F, 0x0C, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x2F, 0x2A, 0x9D, 0x8A, 0x7F, 0x67, 
	0x5A, 0x52, 0x47, 0x3E, 0x35, 0x3A, 0x33, 0x2C, 0x59, 0x4E, 0x48, 0x50, 0x44, 0x39, 0x55, 0x49, 
	0x47, 0x57, 0x4B, 0x3F, 0x65, 0x57, 0x48, 0x5F, 0x54, 0x45, 0x54, 0x48, 0x43, 0x4E, 0x3F, 0x38, 
	0x5B, 0x50, 0x47, 0x7D, 0x6D, 0x58, 0x69, 0x5C, 0x4E, 0x66, 0x5B, 0x4E, 0x59, 0x4E, 0x45, 0x53, 
	0x47, 0x45, 0x61, 0x56, 0x4B, 0x54, 0x48, 0x45, 0x54, 0x48, 0x45, 0x59, 0x4E, 0x45, 0x63, 0x58, 
	0x4A, 0x79, 0x69, 0x58, 0x82, 0x72, 0x5B, 0x75, 0x66, 0x5D, 0x6E, 0x62, 0x54, 0x82, 0x74, 0x61, 
	0x7F, 0x6D, 0x5E, 0x5A, 0x53, 0x45, 0x63, 0x5D, 0x56, 0x73, 0x6C, 0x58, 0x63, 0x5A, 0x51, 0x60, 
	0x59, 0x53, 0x5B, 0x53, 0x49, 0x5A, 0x52, 0x4B, 0x50, 0x47, 0x3C, 0x4A, 0x4C, 0x49, 0x49, 0x4B, 
	0x48, 0x64, 0x5A, 0x4B, 0x5C, 0x53, 0x49, 0x39, 0x37, 0x2E, 0x33, 0x3C, 0x38, 0x1D, 0x3F, 0x48, 
	0x1E, 0x43, 0x3F, 0x18, 0x32, 0x3B, 0x0F, 0x38, 0x40, 0x1B, 0x33, 0x3C, 0x1D, 0x2E, 0x36, 0x1C, 
	0x3F, 0x43, 0x1B, 0x31, 0x3A, 0x27, 0x31, 0x31, 0x31, 0x25, 0x19, 0x32, 0x32, 0x2C, 0x4D, 0x43, 
	0x39, 0x18, 0x22, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1E, 0x33, 0x3C, 0x18, 
	0x2C, 0x37, 0x3A, 0x3F, 0x42, 0x66, 0x5C, 0x4B, 0x5B, 0x52, 0x47, 0x5C, 0x53, 0x4B, 0x5D, 0x54, 
	0x4D, 0x67, 0x5E, 0x4A, 0x44, 0x46, 0x44, 0x51, 0x4D, 0x4A, 0x46, 0x3D, 0x36, 0x31, 0x31, 0x2A, 
	0x36, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x3F, 
	0x3C, 0x34, 0x36, 0x34, 0x2F, 0x4A, 0x40, 0x38, 0x33, 0x36, 0x2E, 0x50, 0x43, 0x3A, 0x4A, 0x3F, 
	0x38, 0x1E, 0x47, 0x4C, 0x15, 0x4B, 0x55, 0x27, 0x47, 0x4F, 0x18, 0x3C, 0x3B, 0x3E, 0x45, 0x45, 
	0x50, 0x42, 0x39, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3F, 0x49, 0x3F, 0x3F, 0x4C, 0x42, 0x38, 0x40, 
	0x3A, 0x31, 0x43, 0x4C, 0x4C, 0x1F, 0x49, 0x53, 0x1C, 0x4A, 0x53, 0x1B, 0x4B, 0x53, 0x2A, 0x49, 
	0x50, 0x35, 0x40, 0x3E, 0x1C, 0x40, 0x3F, 0x1F, 0x3C, 0x46, 0x1C, 0x39, 0x3F, 0x1D, 0x3E, 0x40, 
	0x1D, 0x42, 0x40, 0x1B, 0x3A, 0x3E, 0x29, 0x4E, 0x57, 0x27, 0x49, 0x4D, 0x2E, 0x40, 0x3D, 0x1E, 
	0x4F, 0x58, 0x19, 0x2B, 0x35, 0x28, 0x4B, 0x51, 0x1A, 0x4C, 0x55, 0x2B, 0x4C, 0x56, 0x19, 0x45, 
	0x48, 0x31, 0x48, 0x4E, 0x72, 0x5F, 0x52, 0x70, 0x6A, 0x58, 0x83, 0x71, 0x65, 0x89, 0x7B, 0x69, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x04, 0x06, 0x38, 0x2E, 0x2A, 0xA1, 0x91, 0x84, 0x7A, 
	0x6B, 0x58, 0x72, 0x67, 0x5A, 0x32, 0x32, 0x2A, 0x4C, 0x42, 0x39, 0x50, 0x48, 0x3D, 0x5D, 0x55, 
	0x4D, 0x51, 0x49, 0x40, 0x63, 0x5C, 0x4B, 0x5B, 0x53, 0x49, 0x64, 0x5A, 0x52, 0x33, 0x45, 0x49, 
	0x5F, 0x55, 0x4E, 0x73, 0x68, 0x55, 0x63, 0x5B, 0x53, 0x67, 0x5F, 0x4B, 0x59, 0x51, 0x4A, 0x5C, 
	0x53, 0x4A, 0x5D, 0x53, 0x4A, 0x5C, 0x54, 0x4B, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x56, 0x4E, 
	0x47, 0x5C, 0x54, 0x48, 0x75, 0x65, 0x50, 0x90, 0x7E, 0x6E, 0x72, 0x67, 0x57, 0x7E, 0x6D, 0x64, 
	0x75, 0x6A, 0x5E, 0x6E, 0x66, 0x58, 0x71, 0x67, 0x54, 0x7F, 0x6E, 0x68, 0x66, 0x5D, 0x51, 0x66, 
	0x5D, 0x4A, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x59, 0x50, 0x48, 0x4C, 0x4E, 0x4B, 0x43, 0x3D, 
	0x40, 0x54, 0x4C, 0x46, 0x5B, 0x53, 0x4B, 0x4B, 0x42, 0x38, 0x3A, 0x36, 0x2B, 0x12, 0x33, 0x3E, 
	0x11, 0x38, 0x42, 0x1C, 0x30, 0x38, 0x18, 0x34, 0x3C, 0x1A, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x31, 0x3C, 0x29, 0x1D, 0x16, 0x3F, 0x35, 0x2B, 0x47, 0x5A, 
	0x5C, 0x11, 0x26, 0x2B, 0x19, 0x2A, 0x30, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x12, 0x25, 0x23, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x22, 0x16, 0x29, 0x2C, 0x20, 
	0x35, 0x3C, 0x43, 0x3A, 0x32, 0x57, 0x4D, 0x44, 0x3D, 0x42, 0x46, 0x4F, 0x46, 0x3C, 0x56, 0x54, 
	0x4F, 0x5B, 0x52, 0x4A, 0x4B, 0x4E, 0x4B, 0x54, 0x4B, 0x47, 0x3F, 0x36, 0x31, 0x37, 0x2C, 0x30, 
	0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x35, 0x2C, 0x2C, 0x37, 0x33, 0x30, 0x2E, 0x2C, 0x26, 0x2B, 
	0x2C, 0x23, 0x33, 0x32, 0x2C, 0x51, 0x44, 0x3B, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x3D, 0x3A, 
	0x31, 0x37, 0x37, 0x30, 0x31, 0x43, 0x40, 0x39, 0x51, 0x51, 0x2E, 0x4F, 0x4F, 0x0C, 0x2A, 0x33, 
	0x22, 0x28, 0x29, 0x49, 0x40, 0x37, 0x4A, 0x40, 0x3A, 0x4A, 0x40, 0x3F, 0x47, 0x3C, 0x35, 0x3A, 
	0x32, 0x2A, 0x3D, 0x4E, 0x4E, 0x20, 0x4A, 0x53, 0x1C, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 0x2C, 0x45, 
	0x4A, 0x1D, 0x3F, 0x3E, 0x35, 0x40, 0x40, 0x18, 0x38, 0x3F, 0x1D, 0x36, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1B, 0x39, 0x3D, 0x28, 0x4C, 0x56, 0x2B, 0x45, 0x49, 0x36, 0x40, 0x3F, 0x1C, 
	0x4C, 0x55, 0x1A, 0x3E, 0x45, 0x1C, 0x3F, 0x3D, 0x1B, 0x3D, 0x3B, 0x1B, 0x3E, 0x3C, 0x19, 0x48, 
	0x4F, 0x28, 0x47, 0x4D, 0x74, 0x63, 0x55, 0x6E, 0x68, 0x55, 0x81, 0x6F, 0x60, 0x81, 0x74, 0x64, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x6E, 
	0x62, 0x57, 0x73, 0x68, 0x55, 0x50, 0x48, 0x40, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x57, 0x4F, 
	0x47, 0x5A, 0x52, 0x4A, 0x50, 0x48, 0x40, 0x5D, 0x56, 0x49, 0x79, 0x6A, 0x56, 0x61, 0x57, 0x50, 
	0x61, 0x59, 0x52, 0x60, 0x58, 0x52, 0x62, 0x5A, 0x54, 0x57, 0x4F, 0x48, 0x5B, 0x52, 0x4A, 0x49, 
	0x4A, 0x47, 0x39, 0x48, 0x4B, 0x52, 0x48, 0x3C, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x58, 0x50, 
	0x48, 0x4A, 0x49, 0x43, 0x55, 0x4D, 0x48, 0x84, 0x73, 0x5D, 0x75, 0x6A, 0x64, 0x88, 0x78, 0x65, 
	0x7F, 0x6E, 0x5B, 0x72, 0x6A, 0x5E, 0x72, 0x6B, 0x58, 0x66, 0x5F, 0x51, 0x5D, 0x55, 0x4E, 0x67, 
	0x5E, 0x51, 0x4F, 0x47, 0x40, 0x59, 0x51, 0x48, 0x5A, 0x52, 0x4A, 0x5D, 0x53, 0x4A, 0x56, 0x53, 
	0x4D, 0x49, 0x3F, 0x3E, 0x53, 0x4A, 0x44, 0x34, 0x33, 0x2C, 0x3B, 0x38, 0x2F, 0x28, 0x3E, 0x44, 
	0x0F, 0x37, 0x40, 0x1B, 0x39, 0x42, 0x1D, 0x2B, 0x35, 0x1D, 0x48, 0x44, 0x1D, 0x30, 0x39, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1B, 0x30, 0x3A, 0x32, 0x27, 0x19, 0x39, 0x2E, 0x24, 0x77, 0x6F, 
	0x6B, 0x1C, 0x28, 0x24, 0x13, 0x33, 0x3A, 0x1B, 0x33, 0x3C, 0x1A, 0x2C, 0x33, 0x14, 0x27, 0x28, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1D, 0x31, 0x3B, 0x14, 
	0x2A, 0x32, 0x46, 0x3C, 0x32, 0x51, 0x49, 0x3E, 0x4E, 0x45, 0x3F, 0x4F, 0x44, 0x3F, 0x4F, 0x46, 
	0x3A, 0x55, 0x4D, 0x45, 0x5C, 0x52, 0x48, 0x53, 0x4B, 0x48, 0x40, 0x36, 0x32, 0x2E, 0x2E, 0x26, 
	0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x39, 0x2F, 0x4A, 0x40, 0x38, 0x4B, 0x42, 0x39, 0x37, 
	0x35, 0x30, 0x36, 0x34, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x33, 0x2C, 0x36, 0x36, 
	0x2C, 0x38, 0x38, 0x30, 0x3D, 0x38, 0x2F, 0x4B, 0x44, 0x3C, 0x67, 0x5C, 0x54, 0x22, 0x42, 0x48, 
	0x0D, 0x24, 0x2A, 0x3B, 0x38, 0x2E, 0x47, 0x3F, 0x36, 0x4D, 0x3E, 0x3A, 0x39, 0x50, 0x54, 0x43, 
	0x4A, 0x49, 0x33, 0x50, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4B, 0x54, 0x13, 0x3A, 0x40, 0x40, 0x40, 
	0x3E, 0x1E, 0x40, 0x40, 0x2C, 0x40, 0x40, 0x36, 0x42, 0x40, 0x1A, 0x38, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x46, 0x49, 0x2A, 0x4A, 0x4F, 0x46, 0x4A, 0x49, 0x29, 
	0x4C, 0x50, 0x15, 0x40, 0x4B, 0x1C, 0x42, 0x43, 0x2A, 0x4C, 0x57, 0x19, 0x3C, 0x39, 0x28, 0x4B, 
	0x55, 0x28, 0x42, 0x45, 0x8C, 0x7B, 0x6C, 0x7D, 0x6E, 0x66, 0x81, 0x76, 0x69, 0x7B, 0x6D, 0x60, 
	0x0F, 0x12, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0C, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x75, 
	0x6A, 0x57, 0x67, 0x5E, 0x52, 0x5B, 0x4F, 0x44, 0x55, 0x4D, 0x45, 0x4B, 0x44, 0x3C, 0x49, 0x40, 
	0x38, 0x4F, 0x47, 0x3D, 0x55, 0x4D, 0x45, 0x57, 0x4F, 0x48, 0x64, 0x5C, 0x53, 0x60, 0x59, 0x46, 
	0x71, 0x65, 0x54, 0x61, 0x59, 0x48, 0x64, 0x5C, 0x49, 0x5A, 0x51, 0x4A, 0x5C, 0x53, 0x4A, 0x4E, 
	0x4F, 0x4B, 0x3B, 0x4A, 0x4B, 0x4D, 0x42, 0x3A, 0x5C, 0x54, 0x4C, 0x4F, 0x47, 0x3C, 0x59, 0x51, 
	0x49, 0x59, 0x51, 0x49, 0x4A, 0x43, 0x3B, 0x7A, 0x6A, 0x54, 0x6E, 0x64, 0x55, 0x8C, 0x7A, 0x6C, 
	0x90, 0x7F, 0x6E, 0x8B, 0x79, 0x6A, 0x67, 0x60, 0x56, 0x4E, 0x46, 0x3D, 0x4B, 0x42, 0x3E, 0x4F, 
	0x46, 0x3E, 0x46, 0x42, 0x43, 0x4F, 0x46, 0x3F, 0x63, 0x5B, 0x53, 0x53, 0x4B, 0x42, 0x51, 0x48, 
	0x42, 0x4B, 0x40, 0x3A, 0x48, 0x3F, 0x36, 0x2F, 0x2C, 0x27, 0x2F, 0x2E, 0x23, 0x26, 0x38, 0x3B, 
	0x1A, 0x34, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x2C, 0x35, 0x1A, 0x30, 0x39, 0x1D, 0x31, 0x39, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x24, 0x2F, 0x30, 0x40, 0x34, 0x31, 0x7C, 0x75, 
	0x6B, 0x1B, 0x2F, 0x30, 0x14, 0x2B, 0x30, 0x1A, 0x33, 0x3C, 0x25, 0x30, 0x32, 0x1E, 0x32, 0x3C, 
	0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x19, 0x2C, 0x34, 0x2B, 0x30, 0x2B, 0x19, 
	0x2E, 0x39, 0x28, 0x35, 0x33, 0x50, 0x46, 0x42, 0x51, 0x47, 0x3E, 0x39, 0x4A, 0x4D, 0x4D, 0x48, 
	0x44, 0x5F, 0x55, 0x4B, 0x44, 0x48, 0x46, 0x58, 0x4F, 0x44, 0x3F, 0x3B, 0x38, 0x32, 0x2E, 0x2A, 
	0x39, 0x36, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 
	0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x25, 0x28, 
	0x28, 0x33, 0x33, 0x29, 0x35, 0x37, 0x2F, 0x51, 0x47, 0x3C, 0x5B, 0x51, 0x48, 0x51, 0x57, 0x52, 
	0x25, 0x3F, 0x44, 0x3C, 0x33, 0x2F, 0x33, 0x2B, 0x2B, 0x3B, 0x40, 0x3B, 0x30, 0x5B, 0x64, 0x27, 
	0x51, 0x55, 0x18, 0x3D, 0x45, 0x0F, 0x32, 0x3A, 0x23, 0x4C, 0x55, 0x1C, 0x49, 0x4F, 0x16, 0x39, 
	0x3E, 0x1B, 0x3E, 0x40, 0x1A, 0x37, 0x40, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3E, 0x23, 0x47, 0x4B, 0x28, 0x50, 0x55, 0x4F, 0x4D, 0x4A, 0x23, 
	0x37, 0x3C, 0x19, 0x3D, 0x3D, 0x1F, 0x47, 0x4B, 0x2B, 0x4E, 0x54, 0x27, 0x4B, 0x55, 0x24, 0x4B, 
	0x54, 0x26, 0x40, 0x46, 0x7F, 0x6D, 0x53, 0x80, 0x6E, 0x5F, 0x76, 0x70, 0x6A, 0x86, 0x76, 0x62, 
	0x0F, 0x13, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x77, 
	0x6B, 0x57, 0x56, 0x50, 0x4C, 0x2C, 0x4C, 0x4F, 0x70, 0x60, 0x54, 0x7C, 0x67, 0x55, 0x65, 0x5B, 
	0x4F, 0x63, 0x5C, 0x49, 0x60, 0x58, 0x49, 0x62, 0x5A, 0x54, 0x61, 0x5A, 0x53, 0x61, 0x5A, 0x53, 
	0x68, 0x60, 0x51, 0x59, 0x51, 0x48, 0x57, 0x4E, 0x47, 0x4F, 0x4D, 0x48, 0x53, 0x4B, 0x42, 0x4F, 
	0x45, 0x3C, 0x47, 0x49, 0x45, 0x4F, 0x4C, 0x46, 0x5C, 0x54, 0x4B, 0x4E, 0x46, 0x3F, 0x4D, 0x45, 
	0x3E, 0x59, 0x51, 0x49, 0x5F, 0x57, 0x4C, 0x48, 0x40, 0x38, 0x4C, 0x44, 0x3F, 0x57, 0x4E, 0x43, 
	0x5A, 0x52, 0x4B, 0x80, 0x71, 0x64, 0x6D, 0x62, 0x4F, 0x3D, 0x37, 0x30, 0x4C, 0x43, 0x3E, 0x51, 
	0x48, 0x40, 0x31, 0x34, 0x2A, 0x47, 0x3D, 0x35, 0x4C, 0x43, 0x3C, 0x4D, 0x44, 0x3A, 0x47, 0x3E, 
	0x35, 0x35, 0x34, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2F, 0x25, 0x2F, 0x2E, 0x24, 0x2F, 0x38, 0x36, 
	0x13, 0x3B, 0x43, 0x1D, 0x37, 0x40, 0x1D, 0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x2E, 0x39, 0x30, 0x29, 0x5C, 0x55, 
	0x4B, 0x16, 0x2B, 0x2F, 0x14, 0x27, 0x29, 0x1B, 0x2C, 0x33, 0x1A, 0x2E, 0x34, 0x13, 0x26, 0x26, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1C, 0x30, 0x3A, 0x1D, 
	0x32, 0x39, 0x4A, 0x44, 0x3D, 0x52, 0x49, 0x3E, 0x58, 0x4F, 0x45, 0x49, 0x4B, 0x47, 0x4B, 0x4E, 
	0x4B, 0x52, 0x4E, 0x48, 0x53, 0x49, 0x3D, 0x4D, 0x44, 0x40, 0x47, 0x3E, 0x3D, 0x2C, 0x25, 0x1D, 
	0x32, 0x31, 0x2A, 0x38, 0x39, 0x30, 0x36, 0x37, 0x2F, 0x49, 0x3F, 0x37, 0x3D, 0x3A, 0x32, 0x35, 
	0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x24, 0x28, 
	0x27, 0x3B, 0x3B, 0x32, 0x34, 0x2F, 0x2C, 0x3F, 0x3A, 0x32, 0x54, 0x4B, 0x40, 0x51, 0x48, 0x40, 
	0x6C, 0x60, 0x54, 0x6F, 0x66, 0x5B, 0x40, 0x3C, 0x32, 0x3B, 0x3A, 0x37, 0x6D, 0x6B, 0x6B, 0x5B, 
	0x6F, 0x77, 0x33, 0x5F, 0x6A, 0x12, 0x37, 0x3F, 0x1A, 0x47, 0x4F, 0x1E, 0x4C, 0x56, 0x35, 0x3F, 
	0x3D, 0x1E, 0x3E, 0x3E, 0x20, 0x40, 0x3F, 0x1D, 0x44, 0x46, 0x25, 0x43, 0x4D, 0x1C, 0x3A, 0x3E, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1A, 0x3C, 0x3E, 0x2E, 0x44, 0x46, 0x4E, 0x4E, 0x4B, 0x29, 
	0x44, 0x43, 0x1B, 0x3F, 0x40, 0x1F, 0x3E, 0x46, 0x20, 0x43, 0x4A, 0x25, 0x46, 0x4A, 0x35, 0x3E, 
	0x3C, 0x4B, 0x57, 0x53, 0x88, 0x73, 0x61, 0x8A, 0x78, 0x6B, 0x65, 0x62, 0x55, 0x69, 0x61, 0x53, 
	0x0C, 0x04, 0x07, 0x00, 0x00, 0x00, 0x04, 0x06, 0x06, 0x38, 0x2F, 0x2A, 0xA3, 0x92, 0x82, 0x74, 
	0x66, 0x59, 0x51, 0x50, 0x4D, 0x18, 0x40, 0x47, 0x25, 0x4B, 0x50, 0x69, 0x5D, 0x4F, 0x64, 0x5C, 
	0x53, 0x62, 0x5A, 0x52, 0x62, 0x5A, 0x47, 0x69, 0x60, 0x54, 0x60, 0x58, 0x47, 0x61, 0x57, 0x4F, 
	0x5F, 0x57, 0x47, 0x67, 0x5E, 0x55, 0x56, 0x4F, 0x47, 0x54, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x5D, 
	0x55, 0x4C, 0x57, 0x4E, 0x45, 0x57, 0x4E, 0x46, 0x5D, 0x55, 0x4C, 0x4B, 0x43, 0x38, 0x52, 0x4A, 
	0x3F, 0x50, 0x48, 0x3E, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x5F, 0x56, 0x48, 0x46, 0x48, 0x47, 
	0x25, 0x37, 0x37, 0x74, 0x65, 0x5A, 0x72, 0x69, 0x58, 0x46, 0x3C, 0x34, 0x44, 0x42, 0x3F, 0x4A, 
	0x3F, 0x36, 0x3B, 0x39, 0x31, 0x33, 0x36, 0x2E, 0x34, 0x36, 0x2E, 0x3C, 0x39, 0x31, 0x34, 0x37, 
	0x2E, 0x30, 0x2C, 0x27, 0x34, 0x2F, 0x2B, 0x2F, 0x2F, 0x26, 0x35, 0x32, 0x2C, 0x3C, 0x3A, 0x2F, 
	0x22, 0x35, 0x3B, 0x1C, 0x38, 0x42, 0x1D, 0x38, 0x40, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x39, 0x42, 0x1B, 0x31, 0x39, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x30, 0x33, 0x33, 0x27, 0x4E, 0x4C, 
	0x4B, 0x13, 0x2A, 0x34, 0x11, 0x24, 0x20, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 
	0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x13, 0x26, 0x27, 0x25, 
	0x38, 0x3C, 0x52, 0x53, 0x4F, 0x5D, 0x54, 0x4B, 0x5C, 0x53, 0x4A, 0x5B, 0x52, 0x4A, 0x5D, 0x53, 
	0x4A, 0x45, 0x48, 0x45, 0x54, 0x51, 0x4A, 0x4D, 0x43, 0x3E, 0x4C, 0x50, 0x4C, 0x43, 0x39, 0x36, 
	0x37, 0x30, 0x2F, 0x38, 0x30, 0x30, 0x34, 0x37, 0x2E, 0x4F, 0x43, 0x3A, 0x31, 0x34, 0x2B, 0x51, 
	0x44, 0x3B, 0x33, 0x36, 0x2E, 0x52, 0x45, 0x3C, 0x36, 0x37, 0x2C, 0x36, 0x31, 0x2E, 0x35, 0x32, 
	0x2B, 0x2C, 0x2E, 0x24, 0x32, 0x2C, 0x29, 0x3C, 0x3A, 0x34, 0x4D, 0x44, 0x3C, 0x47, 0x3D, 0x3F, 
	0x51, 0x49, 0x3F, 0x77, 0x6E, 0x5C, 0x3C, 0x35, 0x33, 0x34, 0x32, 0x2B, 0x43, 0x3F, 0x38, 0x57, 
	0x49, 0x3E, 0x32, 0x54, 0x55, 0x18, 0x46, 0x4E, 0x13, 0x38, 0x40, 0x1F, 0x43, 0x49, 0x39, 0x43, 
	0x42, 0x39, 0x51, 0x50, 0x32, 0x3F, 0x3E, 0x35, 0x42, 0x3F, 0x1A, 0x35, 0x3E, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3E, 0x3E, 0x1D, 0x2F, 0x3A, 0x1C, 0x3B, 0x3F, 0x1E, 0x47, 0x4C, 0x49, 0x4C, 0x4B, 0x2B, 
	0x40, 0x3F, 0x1B, 0x2A, 0x35, 0x1C, 0x30, 0x39, 0x1A, 0x3B, 0x3F, 0x35, 0x3F, 0x3D, 0x29, 0x4B, 
	0x50, 0x29, 0x4A, 0x4F, 0x67, 0x5E, 0x4F, 0x89, 0x77, 0x65, 0x7A, 0x6A, 0x58, 0x5F, 0x56, 0x49, 
	0x0D, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x2B, 0x2A, 0x87, 0x78, 0x68, 0x65, 
	0x5E, 0x4E, 0x5D, 0x51, 0x46, 0x32, 0x42, 0x46, 0x2B, 0x49, 0x4E, 0x6A, 0x5E, 0x53, 0x69, 0x60, 
	0x50, 0x56, 0x4F, 0x48, 0x5D, 0x55, 0x4E, 0x63, 0x5B, 0x54, 0x57, 0x52, 0x49, 0x2A, 0x3F, 0x42, 
	0x5B, 0x55, 0x4F, 0x6C, 0x63, 0x55, 0x58, 0x50, 0x45, 0x4E, 0x43, 0x39, 0x51, 0x49, 0x3E, 0x4D, 
	0x4B, 0x46, 0x57, 0x4F, 0x46, 0x4B, 0x43, 0x3B, 0x52, 0x4A, 0x44, 0x52, 0x4A, 0x3F, 0x57, 0x4F, 
	0x47, 0x51, 0x49, 0x3F, 0x51, 0x47, 0x3F, 0x39, 0x40, 0x3F, 0x5E, 0x55, 0x48, 0x76, 0x6B, 0x59, 
	0x34, 0x44, 0x49, 0x72, 0x66, 0x59, 0x85, 0x72, 0x69, 0x62, 0x57, 0x48, 0x5A, 0x52, 0x47, 0x4F, 
	0x47, 0x3C, 0x40, 0x3B, 0x33, 0x4E, 0x43, 0x3A, 0x3B, 0x39, 0x31, 0x34, 0x36, 0x2E, 0x53, 0x45, 
	0x3C, 0x32, 0x33, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x29, 0x1F, 0x31, 0x2F, 0x28, 
	0x3C, 0x31, 0x2B, 0x1A, 0x33, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x44, 0x16, 0x2E, 0x33, 0x18, 0x32, 0x3C, 0x35, 0x31, 0x23, 0x28, 0x23, 0x1F, 0x51, 0x47, 
	0x46, 0x29, 0x4D, 0x4E, 0x14, 0x2A, 0x2F, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x16, 0x29, 0x2C, 0x1E, 
	0x33, 0x3B, 0x4C, 0x40, 0x34, 0x5A, 0x51, 0x47, 0x4B, 0x4E, 0x4C, 0x5D, 0x53, 0x4A, 0x57, 0x4F, 
	0x47, 0x4D, 0x4A, 0x42, 0x4F, 0x43, 0x3E, 0x55, 0x4B, 0x3F, 0x58, 0x4E, 0x45, 0x4A, 0x43, 0x38, 
	0x36, 0x39, 0x2F, 0x33, 0x2C, 0x27, 0x4C, 0x44, 0x3A, 0x47, 0x3E, 0x36, 0x50, 0x45, 0x3B, 0x3A, 
	0x39, 0x31, 0x37, 0x37, 0x2F, 0x36, 0x36, 0x2C, 0x2F, 0x42, 0x42, 0x39, 0x32, 0x2E, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x39, 0x3A, 0x31, 0x32, 0x30, 0x2A, 0x4C, 0x42, 0x38, 0x49, 0x3F, 0x42, 
	0x45, 0x3B, 0x37, 0x6A, 0x61, 0x53, 0x5B, 0x52, 0x4B, 0x2A, 0x2A, 0x22, 0x44, 0x3B, 0x3B, 0x33, 
	0x4B, 0x4C, 0x43, 0x4D, 0x4B, 0x18, 0x4A, 0x54, 0x1B, 0x4C, 0x55, 0x1E, 0x49, 0x50, 0x18, 0x39, 
	0x3A, 0x18, 0x42, 0x4C, 0x22, 0x3B, 0x3E, 0x22, 0x39, 0x40, 0x1C, 0x37, 0x40, 0x1D, 0x3B, 0x3E, 
	0x1A, 0x4A, 0x54, 0x1D, 0x3C, 0x3E, 0x1D, 0x3F, 0x40, 0x1B, 0x3B, 0x3F, 0x23, 0x3F, 0x47, 0x22, 
	0x42, 0x42, 0x1B, 0x2A, 0x34, 0x25, 0x4C, 0x50, 0x1A, 0x3D, 0x3E, 0x1A, 0x39, 0x3E, 0x24, 0x48, 
	0x4F, 0x2B, 0x55, 0x5A, 0x42, 0x45, 0x45, 0x73, 0x6E, 0x62, 0x84, 0x73, 0x65, 0x58, 0x52, 0x47, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x09, 0x09, 0x0B, 0x35, 0x2A, 0x27, 0x8F, 0x80, 0x70, 0x52, 
	0x4B, 0x45, 0x59, 0x51, 0x4A, 0x60, 0x55, 0x49, 0x5D, 0x52, 0x49, 0x5D, 0x55, 0x4E, 0x63, 0x5C, 
	0x4B, 0x58, 0x50, 0x48, 0x64, 0x5C, 0x55, 0x62, 0x59, 0x4B, 0x4D, 0x4D, 0x4A, 0x30, 0x42, 0x43, 
	0x38, 0x47, 0x4A, 0x59, 0x4F, 0x46, 0x4F, 0x4C, 0x49, 0x2E, 0x38, 0x34, 0x5A, 0x50, 0x48, 0x53, 
	0x4B, 0x42, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3B, 0x4A, 0x40, 0x39, 0x4D, 0x44, 0x3F, 0x58, 0x50, 
	0x47, 0x53, 0x4A, 0x3F, 0x4D, 0x45, 0x3C, 0x09, 0x25, 0x34, 0x55, 0x4A, 0x40, 0x6F, 0x63, 0x53, 
	0x53, 0x48, 0x40, 0x5A, 0x55, 0x4D, 0x7C, 0x6C, 0x5B, 0x74, 0x69, 0x56, 0x53, 0x4B, 0x3F, 0x45, 
	0x3C, 0x38, 0x33, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x43, 0x3C, 0x34, 0x36, 0x37, 0x2F, 0x36, 0x37, 
	0x2F, 0x34, 0x35, 0x2B, 0x28, 0x22, 0x1F, 0x30, 0x32, 0x28, 0x30, 0x29, 0x1F, 0x2F, 0x30, 0x27, 
	0x31, 0x2F, 0x24, 0x18, 0x31, 0x3D, 0x16, 0x36, 0x40, 0x16, 0x3A, 0x45, 0x1A, 0x2E, 0x38, 0x1B, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x1B, 0x31, 0x3A, 0x1E, 0x23, 0x2B, 0x31, 0x31, 0x26, 0x34, 0x32, 
	0x27, 0x1F, 0x36, 0x3E, 0x13, 0x39, 0x43, 0x14, 0x26, 0x25, 0x1E, 0x31, 0x3B, 0x1C, 0x2F, 0x37, 
	0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x18, 
	0x2E, 0x38, 0x37, 0x38, 0x34, 0x43, 0x3C, 0x35, 0x33, 0x3B, 0x3B, 0x4E, 0x4E, 0x4C, 0x68, 0x5F, 
	0x4B, 0x50, 0x45, 0x42, 0x34, 0x48, 0x48, 0x3D, 0x42, 0x40, 0x4D, 0x42, 0x36, 0x3D, 0x37, 0x31, 
	0x3A, 0x35, 0x2C, 0x15, 0x31, 0x3E, 0x2F, 0x1F, 0x1C, 0x2E, 0x36, 0x30, 0x37, 0x2B, 0x2F, 0x37, 
	0x36, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x32, 0x3D, 0x3A, 0x38, 0x32, 0x2F, 0x38, 0x39, 
	0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 0x36, 0x37, 0x2F, 0x47, 0x3E, 0x36, 0x53, 0x4B, 0x3F, 
	0x47, 0x3D, 0x42, 0x58, 0x50, 0x45, 0x6A, 0x62, 0x54, 0x5A, 0x52, 0x46, 0x60, 0x55, 0x4C, 0x32, 
	0x3E, 0x40, 0x2C, 0x3F, 0x3F, 0x26, 0x47, 0x4C, 0x2C, 0x42, 0x44, 0x28, 0x46, 0x4C, 0x2C, 0x3E, 
	0x40, 0x0E, 0x35, 0x3E, 0x1B, 0x3D, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 0x3C, 0x40, 
	0x1E, 0x3E, 0x3E, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 0x2B, 0x35, 0x1C, 
	0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1A, 0x3D, 0x40, 0x38, 0x42, 0x40, 0x1A, 0x3E, 0x3F, 0x1F, 0x43, 
	0x45, 0x20, 0x47, 0x49, 0x43, 0x4A, 0x4B, 0x4C, 0x4C, 0x49, 0x66, 0x62, 0x60, 0x43, 0x45, 0x3D, 
	0x12, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x0D, 0x0E, 0x38, 0x2B, 0x28, 0x8B, 0x79, 0x6B, 0x5C, 
	0x54, 0x47, 0x58, 0x50, 0x49, 0x64, 0x5C, 0x55, 0x59, 0x51, 0x49, 0x59, 0x51, 0x49, 0x59, 0x51, 
	0x49, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x47, 0x4E, 0x4B, 0x45, 0x60, 0x54, 0x4B, 
	0x5D, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x51, 0x48, 0x39, 0x4A, 0x4D, 0x57, 0x4D, 0x45, 0x58, 
	0x50, 0x47, 0x4D, 0x45, 0x3D, 0x5F, 0x57, 0x4E, 0x4D, 0x44, 0x3F, 0x44, 0x40, 0x44, 0x50, 0x48, 
	0x3F, 0x4E, 0x45, 0x40, 0x4D, 0x3F, 0x35, 0x1C, 0x43, 0x45, 0x51, 0x3F, 0x35, 0x3F, 0x3A, 0x33, 
	0x37, 0x37, 0x2F, 0x36, 0x47, 0x48, 0x37, 0x42, 0x40, 0x53, 0x48, 0x3D, 0x4D, 0x43, 0x3A, 0x3A, 
	0x38, 0x30, 0x35, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x3B, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x2F, 0x31, 0x27, 0x30, 0x29, 0x20, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 
	0x2F, 0x2F, 0x26, 0x3A, 0x32, 0x2E, 0x3A, 0x31, 0x2C, 0x37, 0x34, 0x29, 0x37, 0x35, 0x29, 0x2F, 
	0x33, 0x2E, 0x26, 0x23, 0x24, 0x22, 0x2A, 0x2F, 0x32, 0x32, 0x27, 0x30, 0x2A, 0x20, 0x30, 0x31, 
	0x27, 0x27, 0x23, 0x22, 0x1B, 0x32, 0x3C, 0x1C, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x19, 0x2E, 0x35, 0x23, 
	0x30, 0x34, 0x27, 0x2A, 0x27, 0x2E, 0x20, 0x23, 0x31, 0x35, 0x2C, 0x3A, 0x46, 0x45, 0x67, 0x5C, 
	0x4B, 0x5B, 0x4E, 0x42, 0x18, 0x2E, 0x34, 0x12, 0x26, 0x2C, 0x23, 0x38, 0x3C, 0x26, 0x30, 0x31, 
	0x1E, 0x24, 0x20, 0x18, 0x2B, 0x31, 0x14, 0x2B, 0x30, 0x1A, 0x27, 0x2E, 0x36, 0x31, 0x2A, 0x39, 
	0x2E, 0x32, 0x35, 0x36, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 
	0x30, 0x39, 0x38, 0x2E, 0x25, 0x45, 0x49, 0x39, 0x37, 0x2E, 0x34, 0x36, 0x2E, 0x4B, 0x40, 0x38, 
	0x4A, 0x40, 0x36, 0x45, 0x3E, 0x3B, 0x5A, 0x52, 0x46, 0x58, 0x50, 0x48, 0x47, 0x3F, 0x36, 0x36, 
	0x35, 0x2C, 0x38, 0x36, 0x2C, 0x3E, 0x38, 0x31, 0x4F, 0x40, 0x37, 0x4E, 0x3F, 0x36, 0x48, 0x3B, 
	0x30, 0x0F, 0x37, 0x42, 0x12, 0x36, 0x40, 0x1E, 0x44, 0x40, 0x1D, 0x37, 0x40, 0x1E, 0x3D, 0x40, 
	0x0F, 0x36, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x43, 0x1A, 
	0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2A, 0x34, 0x1A, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 
	0x3F, 0x19, 0x37, 0x3F, 0x30, 0x3C, 0x39, 0x3A, 0x45, 0x45, 0x5F, 0x53, 0x49, 0x39, 0x48, 0x47, 
	0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0F, 0x07, 0x08, 0x16, 0x1F, 0x1C, 0x86, 0x79, 0x67, 0x55, 
	0x4E, 0x48, 0x59, 0x51, 0x49, 0x65, 0x5D, 0x55, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x4F, 0x45, 0x3C, 0x4E, 0x4F, 0x4C, 
	0x59, 0x4E, 0x44, 0x5C, 0x52, 0x49, 0x57, 0x4C, 0x42, 0x52, 0x48, 0x3D, 0x65, 0x5D, 0x4D, 0x49, 
	0x40, 0x3A, 0x4C, 0x43, 0x3F, 0x51, 0x49, 0x3E, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3F, 0x51, 0x48, 
	0x3F, 0x45, 0x43, 0x43, 0x4C, 0x40, 0x36, 0x31, 0x3A, 0x36, 0x2B, 0x3D, 0x3E, 0x1B, 0x28, 0x2A, 
	0x15, 0x31, 0x3C, 0x1A, 0x2A, 0x35, 0x18, 0x37, 0x3F, 0x49, 0x3D, 0x34, 0x38, 0x37, 0x30, 0x36, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 0x33, 0x35, 0x2C, 0x38, 0x38, 0x30, 0x36, 0x31, 
	0x2F, 0x39, 0x38, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x32, 0x27, 0x22, 0x13, 0x18, 0x32, 0x34, 0x29, 
	0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x29, 0x1F, 0x2F, 0x30, 0x27, 0x30, 
	0x31, 0x27, 0x31, 0x2B, 0x20, 0x32, 0x33, 0x28, 0x30, 0x28, 0x1E, 0x30, 0x25, 0x1B, 0x30, 0x33, 
	0x29, 0x28, 0x1E, 0x1D, 0x27, 0x19, 0x18, 0x29, 0x26, 0x24, 0x1B, 0x34, 0x3F, 0x14, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x18, 0x2B, 0x31, 0x1A, 0x2E, 0x35, 0x2A, 0x30, 0x2E, 0x1E, 
	0x32, 0x38, 0x2B, 0x24, 0x1E, 0x2B, 0x26, 0x20, 0x28, 0x33, 0x34, 0x18, 0x32, 0x3B, 0x53, 0x52, 
	0x4E, 0x44, 0x47, 0x42, 0x13, 0x27, 0x2C, 0x13, 0x26, 0x25, 0x12, 0x25, 0x25, 0x11, 0x25, 0x25, 
	0x12, 0x27, 0x27, 0x12, 0x25, 0x23, 0x20, 0x33, 0x3E, 0x0D, 0x25, 0x24, 0x33, 0x2A, 0x25, 0x2E, 
	0x2C, 0x22, 0x39, 0x31, 0x32, 0x36, 0x33, 0x2E, 0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 
	0x30, 0x38, 0x2F, 0x30, 0x39, 0x32, 0x2E, 0x37, 0x38, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 
	0x48, 0x3F, 0x37, 0x32, 0x35, 0x2B, 0x46, 0x3D, 0x38, 0x4C, 0x40, 0x37, 0x38, 0x37, 0x30, 0x37, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x32, 0x1D, 0x37, 0x3E, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x3C, 0x40, 
	0x1C, 0x3A, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x40, 0x40, 0x1E, 0x3D, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 
	0x44, 0x43, 0x1D, 0x29, 0x34, 0x1D, 0x3C, 0x45, 0x1D, 0x2A, 0x34, 0x1E, 0x3D, 0x43, 0x0E, 0x37, 
	0x40, 0x23, 0x42, 0x42, 0x32, 0x3B, 0x36, 0x60, 0x54, 0x46, 0x5F, 0x55, 0x4A, 0x43, 0x4A, 0x46, 
	0x00, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x57, 
	0x50, 0x42, 0x5A, 0x52, 0x4B, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5C, 0x53, 0x4B, 0x53, 0x4E, 0x4A, 0x27, 0x40, 0x42, 
	0x3E, 0x3D, 0x3E, 0x34, 0x3E, 0x3E, 0x2B, 0x42, 0x44, 0x4F, 0x49, 0x43, 0x64, 0x5C, 0x4B, 0x58, 
	0x50, 0x49, 0x54, 0x4C, 0x43, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 
	0x42, 0x49, 0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x24, 0x38, 0x3E, 0x19, 0x32, 0x3C, 
	0x1A, 0x32, 0x3A, 0x1A, 0x32, 0x3A, 0x13, 0x2F, 0x3A, 0x51, 0x43, 0x38, 0x4D, 0x42, 0x39, 0x35, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x50, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 
	0x38, 0x31, 0x2C, 0x29, 0x33, 0x33, 0x2A, 0x37, 0x2F, 0x2F, 0x33, 0x34, 0x2A, 0x22, 0x13, 0x18, 
	0x31, 0x32, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x28, 0x30, 0x29, 0x1F, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x23, 0x16, 0x1B, 0x31, 0x28, 0x1C, 0x30, 0x27, 0x1C, 0x30, 0x28, 
	0x1F, 0x31, 0x2F, 0x24, 0x25, 0x1A, 0x1C, 0x27, 0x1B, 0x1B, 0x28, 0x1A, 0x19, 0x25, 0x1E, 0x1E, 
	0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x24, 0x25, 0x29, 0x15, 0x38, 0x44, 0x28, 0x32, 0x31, 0x2F, 
	0x23, 0x1C, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1D, 0x27, 0x25, 0x24, 0x1D, 0x34, 0x3C, 0x51, 0x42, 
	0x3A, 0x2F, 0x47, 0x47, 0x0F, 0x30, 0x35, 0x14, 0x26, 0x25, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 0x28, 0x2A, 0x0F, 0x26, 0x26, 0x26, 0x31, 0x33, 0x30, 
	0x2F, 0x25, 0x37, 0x38, 0x2F, 0x2C, 0x2C, 0x24, 0x39, 0x3A, 0x31, 0x2F, 0x2C, 0x26, 0x35, 0x34, 
	0x2C, 0x38, 0x3A, 0x30, 0x37, 0x2C, 0x2F, 0x3F, 0x3C, 0x33, 0x37, 0x37, 0x2F, 0x35, 0x37, 0x2F, 
	0x34, 0x36, 0x2E, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x3A, 0x3A, 0x31, 0x50, 0x44, 0x3B, 0x35, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x49, 0x3E, 
	0x34, 0x26, 0x3C, 0x42, 0x11, 0x36, 0x40, 0x19, 0x40, 0x40, 0x37, 0x42, 0x3F, 0x1B, 0x3C, 0x40, 
	0x1D, 0x36, 0x40, 0x1E, 0x3F, 0x40, 0x1E, 0x3D, 0x40, 0x0F, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1D, 
	0x31, 0x3A, 0x1D, 0x45, 0x44, 0x1E, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x18, 0x34, 
	0x3C, 0x1A, 0x29, 0x34, 0x2B, 0x3B, 0x44, 0x65, 0x5A, 0x4B, 0x67, 0x5E, 0x57, 0x52, 0x4B, 0x42, 
	0x11, 0x08, 0x09, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x1A, 0x22, 0x1E, 0x84, 0x72, 0x63, 0x4B, 
	0x44, 0x43, 0x55, 0x4D, 0x44, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x5B, 0x53, 0x4B, 0x4C, 0x44, 0x3D, 0x58, 0x4F, 0x47, 0x4E, 0x3D, 0x34, 0x1C, 0x3F, 0x3F, 
	0x20, 0x49, 0x4E, 0x16, 0x37, 0x3F, 0x34, 0x3E, 0x39, 0x3F, 0x42, 0x44, 0x56, 0x4D, 0x45, 0x5C, 
	0x54, 0x4C, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x51, 0x49, 
	0x3F, 0x49, 0x3F, 0x37, 0x4B, 0x40, 0x37, 0x44, 0x3D, 0x33, 0x1C, 0x2A, 0x2C, 0x13, 0x2C, 0x30, 
	0x1E, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x19, 0x2E, 0x38, 0x44, 0x3C, 0x32, 0x4D, 0x43, 0x39, 0x36, 
	0x35, 0x2F, 0x37, 0x30, 0x30, 0x3C, 0x3B, 0x32, 0x33, 0x35, 0x2C, 0x35, 0x37, 0x2F, 0x51, 0x45, 
	0x3B, 0x33, 0x30, 0x2B, 0x38, 0x2F, 0x30, 0x39, 0x2F, 0x31, 0x38, 0x31, 0x30, 0x30, 0x32, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x29, 0x20, 0x30, 0x27, 0x1D, 0x30, 0x32, 0x29, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x31, 0x28, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x20, 0x1D, 0x30, 0x27, 
	0x1C, 0x30, 0x2A, 0x1F, 0x28, 0x22, 0x20, 0x25, 0x1A, 0x1C, 0x2A, 0x24, 0x20, 0x27, 0x1B, 0x1C, 
	0x25, 0x1E, 0x1E, 0x0F, 0x28, 0x28, 0x29, 0x27, 0x27, 0x0C, 0x27, 0x25, 0x28, 0x1E, 0x23, 0x08, 
	0x28, 0x29, 0x27, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x28, 0x1A, 0x19, 0x14, 0x2F, 0x38, 0x2E, 0x37, 
	0x33, 0x1F, 0x33, 0x3D, 0x0F, 0x24, 0x23, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 0x1A, 0x1B, 0x2A, 0x31, 0x2C, 0x2F, 
	0x2F, 0x25, 0x35, 0x35, 0x2C, 0x2E, 0x2E, 0x25, 0x39, 0x37, 0x31, 0x35, 0x2F, 0x2C, 0x38, 0x2F, 
	0x30, 0x38, 0x35, 0x30, 0x38, 0x2F, 0x30, 0x34, 0x30, 0x2B, 0x37, 0x38, 0x30, 0x35, 0x37, 0x2F, 
	0x51, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 0x38, 0x30, 0x29, 0x2A, 0x44, 0x3D, 0x35, 0x36, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x36, 0x2E, 0x3A, 0x39, 0x31, 0x4D, 0x42, 0x39, 0x50, 0x42, 
	0x38, 0x25, 0x42, 0x42, 0x11, 0x37, 0x40, 0x16, 0x30, 0x3A, 0x27, 0x45, 0x48, 0x0F, 0x36, 0x3F, 
	0x1E, 0x37, 0x40, 0x1D, 0x45, 0x42, 0x1B, 0x2C, 0x37, 0x1B, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x0F, 0x3B, 0x44, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 
	0x38, 0x1A, 0x3B, 0x44, 0x2B, 0x39, 0x33, 0x51, 0x46, 0x3C, 0x59, 0x51, 0x49, 0x5E, 0x56, 0x4A, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x75, 0x6F, 0x60, 0x50, 
	0x47, 0x43, 0x58, 0x50, 0x48, 0x59, 0x51, 0x49, 0x66, 0x5E, 0x56, 0x58, 0x50, 0x48, 0x50, 0x47, 
	0x3C, 0x57, 0x4F, 0x46, 0x50, 0x48, 0x3D, 0x5C, 0x54, 0x4D, 0x19, 0x3D, 0x47, 0x1B, 0x3A, 0x3F, 
	0x1C, 0x40, 0x3E, 0x1C, 0x3B, 0x40, 0x1D, 0x35, 0x3D, 0x3B, 0x3E, 0x3F, 0x5E, 0x54, 0x46, 0x55, 
	0x4D, 0x46, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x42, 0x48, 0x3E, 
	0x35, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x45, 0x46, 0x3D, 0x32, 0x12, 0x29, 0x30, 0x18, 0x2A, 0x2E, 
	0x16, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x38, 0x46, 0x3D, 0x33, 0x48, 0x3F, 0x37, 0x31, 
	0x2C, 0x29, 0x33, 0x2F, 0x2A, 0x35, 0x35, 0x2F, 0x53, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x33, 0x33, 0x2A, 0x24, 0x1B, 0x1B, 0x30, 0x32, 0x28, 
	0x30, 0x30, 0x27, 0x30, 0x32, 0x29, 0x30, 0x27, 0x1D, 0x30, 0x28, 0x1E, 0x30, 0x27, 0x1E, 0x31, 
	0x34, 0x2A, 0x23, 0x16, 0x1B, 0x32, 0x2A, 0x1D, 0x26, 0x1D, 0x1D, 0x32, 0x29, 0x1D, 0x30, 0x27, 
	0x1D, 0x30, 0x26, 0x1C, 0x31, 0x28, 0x1C, 0x32, 0x29, 0x1C, 0x25, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x27, 0x1C, 0x1C, 0x2B, 0x1A, 0x1A, 0x29, 0x23, 0x1F, 0x28, 0x1A, 0x1B, 0x2B, 0x20, 0x1D, 0x31, 
	0x2E, 0x25, 0x28, 0x22, 0x1F, 0x28, 0x22, 0x1F, 0x26, 0x1B, 0x1C, 0x2B, 0x20, 0x1C, 0x29, 0x2B, 
	0x29, 0x26, 0x31, 0x32, 0x28, 0x22, 0x1D, 0x0E, 0x27, 0x27, 0x14, 0x2A, 0x2E, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1C, 0x33, 0x3E, 0x32, 0x27, 0x20, 0x39, 0x33, 0x30, 0x35, 
	0x2F, 0x2C, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 
	0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x34, 0x30, 0x3E, 0x3C, 0x33, 0x36, 0x38, 0x2F, 
	0x3C, 0x3A, 0x32, 0x35, 0x37, 0x2E, 0x4E, 0x43, 0x3A, 0x40, 0x3C, 0x34, 0x39, 0x38, 0x30, 0x3C, 
	0x3A, 0x32, 0x35, 0x36, 0x2E, 0x4E, 0x43, 0x3A, 0x4E, 0x43, 0x3A, 0x39, 0x38, 0x30, 0x3E, 0x38, 
	0x2F, 0x26, 0x43, 0x43, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x11, 0x39, 0x42, 
	0x1B, 0x30, 0x38, 0x1B, 0x2E, 0x38, 0x38, 0x48, 0x44, 0x1B, 0x2B, 0x35, 0x1A, 0x33, 0x3B, 0x1D, 
	0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1E, 0x31, 0x39, 0x1D, 0x3B, 0x44, 0x1C, 0x2F, 0x38, 0x18, 0x3D, 
	0x42, 0x1B, 0x39, 0x3B, 0x3F, 0x48, 0x49, 0x4F, 0x45, 0x3F, 0x4F, 0x47, 0x3F, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x76, 0x6C, 0x5D, 0x58, 
	0x50, 0x45, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x57, 0x4F, 0x47, 0x4F, 0x46, 0x3A, 0x47, 0x4A, 
	0x4A, 0x4A, 0x40, 0x3C, 0x5D, 0x53, 0x4B, 0x3E, 0x42, 0x3C, 0x0E, 0x38, 0x3F, 0x1D, 0x3D, 0x3F, 
	0x1D, 0x47, 0x48, 0x1D, 0x40, 0x3F, 0x18, 0x39, 0x42, 0x43, 0x44, 0x3F, 0x66, 0x5C, 0x4B, 0x53, 
	0x4B, 0x43, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x49, 0x3E, 
	0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x37, 0x45, 0x42, 0x3A, 0x0B, 0x20, 0x1E, 0x1E, 0x31, 0x3B, 
	0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1A, 0x2E, 0x38, 0x37, 0x37, 0x2C, 0x4B, 0x42, 0x38, 0x32, 
	0x2E, 0x2A, 0x2C, 0x30, 0x24, 0x39, 0x2E, 0x31, 0x30, 0x33, 0x29, 0x3A, 0x34, 0x32, 0x38, 0x36, 
	0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x39, 0x35, 0x32, 0x2F, 0x28, 0x1D, 0x30, 0x24, 0x1A, 
	0x30, 0x28, 0x1F, 0x30, 0x27, 0x1E, 0x30, 0x33, 0x2A, 0x30, 0x2C, 0x24, 0x30, 0x26, 0x1C, 0x31, 
	0x27, 0x1B, 0x32, 0x29, 0x1D, 0x23, 0x18, 0x1D, 0x33, 0x2A, 0x1C, 0x26, 0x1D, 0x1D, 0x30, 0x27, 
	0x1C, 0x31, 0x2F, 0x25, 0x23, 0x16, 0x1B, 0x2C, 0x2A, 0x25, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x2B, 0x1A, 0x1A, 0x0B, 0x29, 0x29, 0x26, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x32, 
	0x2F, 0x26, 0x2A, 0x1E, 0x1D, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x26, 0x19, 
	0x1A, 0x31, 0x2C, 0x23, 0x1E, 0x34, 0x3C, 0x2C, 0x1E, 0x1B, 0x2A, 0x27, 0x27, 0x12, 0x2A, 0x2E, 
	0x14, 0x2A, 0x2E, 0x0F, 0x26, 0x25, 0x1D, 0x2A, 0x35, 0x31, 0x2E, 0x23, 0x2F, 0x30, 0x26, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3A, 0x35, 0x32, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x31, 0x39, 0x38, 
	0x31, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x31, 0x2F, 0x38, 0x32, 0x30, 
	0x37, 0x39, 0x2F, 0x36, 0x2F, 0x2F, 0x48, 0x40, 0x37, 0x4D, 0x43, 0x39, 0x4E, 0x43, 0x3A, 0x48, 
	0x3F, 0x37, 0x32, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x39, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x38, 0x37, 
	0x2E, 0x2C, 0x3D, 0x37, 0x11, 0x37, 0x42, 0x12, 0x39, 0x42, 0x1B, 0x30, 0x38, 0x1E, 0x3A, 0x43, 
	0x1D, 0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1A, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1C, 0x30, 0x38, 0x1D, 0x3E, 0x43, 0x42, 0x42, 
	0x3E, 0x3F, 0x4B, 0x4E, 0x54, 0x48, 0x3E, 0x4E, 0x45, 0x40, 0x4D, 0x45, 0x3F, 0x5A, 0x52, 0x48, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1E, 0x6F, 0x6B, 0x63, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x55, 0x4D, 0x45, 0x4C, 0x43, 0x3B, 0x4C, 0x4F, 
	0x4C, 0x5E, 0x55, 0x4C, 0x57, 0x4E, 0x46, 0x40, 0x3C, 0x35, 0x0E, 0x34, 0x3F, 0x1D, 0x44, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x45, 0x42, 0x1C, 0x2E, 0x38, 0x1B, 0x30, 0x38, 0x4B, 0x3F, 0x35, 0x53, 
	0x4B, 0x40, 0x50, 0x48, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x40, 0x4B, 0x42, 0x3F, 0x49, 0x3F, 
	0x36, 0x4A, 0x40, 0x37, 0x4D, 0x42, 0x38, 0x2C, 0x3A, 0x38, 0x18, 0x32, 0x3D, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x2E, 0x38, 0x40, 0x3B, 0x31, 0x36, 0x37, 0x2F, 0x35, 
	0x32, 0x2C, 0x39, 0x2F, 0x31, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x27, 0x20, 0x1E, 0x31, 0x30, 
	0x28, 0x37, 0x31, 0x2F, 0x33, 0x34, 0x2A, 0x37, 0x32, 0x2F, 0x2F, 0x31, 0x27, 0x30, 0x32, 0x2A, 
	0x31, 0x26, 0x1B, 0x30, 0x27, 0x1C, 0x29, 0x1E, 0x1A, 0x26, 0x1B, 0x1B, 0x32, 0x2A, 0x1D, 0x23, 
	0x18, 0x1D, 0x31, 0x28, 0x1D, 0x31, 0x28, 0x1C, 0x29, 0x23, 0x1F, 0x27, 0x1C, 0x1B, 0x32, 0x29, 
	0x1C, 0x27, 0x1C, 0x1B, 0x32, 0x30, 0x24, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 
	0x0B, 0x29, 0x29, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x2A, 
	0x18, 0x19, 0x08, 0x29, 0x2A, 0x2E, 0x27, 0x22, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 
	0x1C, 0x28, 0x22, 0x1F, 0x2C, 0x26, 0x1F, 0x28, 0x22, 0x1F, 0x2C, 0x29, 0x23, 0x27, 0x19, 0x1A, 
	0x2F, 0x20, 0x1A, 0x23, 0x23, 0x22, 0x2F, 0x2A, 0x22, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 
	0x30, 0x27, 0x30, 0x30, 0x27, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x2C, 0x2E, 
	0x24, 0x36, 0x31, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x38, 0x39, 0x30, 
	0x37, 0x32, 0x2F, 0x36, 0x30, 0x2F, 0x30, 0x2C, 0x28, 0x36, 0x32, 0x2F, 0x37, 0x38, 0x2C, 0x45, 
	0x37, 0x34, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x3A, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x39, 0x38, 
	0x2F, 0x2A, 0x37, 0x36, 0x0F, 0x38, 0x42, 0x13, 0x39, 0x42, 0x18, 0x34, 0x3C, 0x1E, 0x31, 0x39, 
	0x1D, 0x3A, 0x43, 0x1D, 0x3A, 0x43, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2B, 0x31, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2C, 0x35, 0x1A, 0x3B, 0x44, 0x14, 0x33, 0x3C, 0x2A, 0x34, 0x37, 0x68, 0x5C, 
	0x4A, 0x5B, 0x51, 0x45, 0x4D, 0x45, 0x3F, 0x48, 0x3D, 0x40, 0x50, 0x47, 0x3F, 0x4C, 0x48, 0x3D, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x75, 0x6B, 0x5B, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x4E, 0x45, 0x3D, 0x4E, 0x4B, 
	0x45, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4B, 0x45, 0x3C, 0x31, 0x18, 0x28, 0x35, 0x1D, 0x44, 0x44, 
	0x1A, 0x2F, 0x39, 0x1E, 0x3E, 0x42, 0x1E, 0x32, 0x3A, 0x0C, 0x39, 0x43, 0x2A, 0x31, 0x32, 0x57, 
	0x4D, 0x42, 0x47, 0x3C, 0x40, 0x54, 0x4C, 0x40, 0x48, 0x3E, 0x3F, 0x49, 0x3F, 0x36, 0x4A, 0x40, 
	0x37, 0x4A, 0x40, 0x45, 0x47, 0x3E, 0x34, 0x28, 0x31, 0x32, 0x1C, 0x2F, 0x39, 0x1D, 0x30, 0x38, 
	0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x33, 0x3B, 0x4C, 0x40, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2E, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x2F, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x30, 0x32, 0x27, 0x31, 0x28, 0x1E, 0x31, 0x2A, 0x1F, 
	0x23, 0x18, 0x1C, 0x32, 0x2B, 0x1F, 0x31, 0x34, 0x2A, 0x31, 0x2E, 0x24, 0x23, 0x18, 0x1C, 0x33, 
	0x2B, 0x1D, 0x27, 0x1D, 0x1C, 0x31, 0x2A, 0x1F, 0x31, 0x34, 0x29, 0x32, 0x34, 0x29, 0x27, 0x1E, 
	0x1E, 0x25, 0x1A, 0x1B, 0x32, 0x35, 0x29, 0x2B, 0x28, 0x24, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x0D, 0x28, 0x28, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x28, 0x19, 0x1A, 0x35, 0x35, 0x29, 0x2A, 
	0x25, 0x22, 0x2A, 0x1F, 0x1E, 0x2A, 0x1E, 0x1D, 0x33, 0x37, 0x2B, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 
	0x25, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x24, 0x25, 0x19, 0x1B, 0x29, 0x23, 0x20, 0x27, 0x1C, 0x1B, 
	0x31, 0x29, 0x1E, 0x30, 0x32, 0x27, 0x38, 0x30, 0x30, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3B, 0x35, 0x33, 0x2C, 0x2F, 0x24, 0x3A, 0x35, 0x32, 0x39, 0x37, 
	0x31, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x31, 0x2E, 0x37, 0x39, 0x30, 
	0x3D, 0x3B, 0x32, 0x4A, 0x42, 0x38, 0x30, 0x2C, 0x28, 0x3C, 0x35, 0x2F, 0x15, 0x2E, 0x3A, 0x1D, 
	0x2E, 0x34, 0x30, 0x34, 0x2F, 0x4F, 0x43, 0x39, 0x47, 0x3E, 0x36, 0x36, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x3C, 0x38, 0x2C, 0x14, 0x37, 0x42, 0x19, 0x2C, 0x32, 0x1E, 0x30, 0x38, 0x16, 0x29, 0x2B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x42, 0x1A, 0x2A, 0x30, 0x1D, 0x38, 0x42, 0x1D, 
	0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2C, 0x35, 0x1B, 0x2C, 0x36, 0x2C, 0x32, 0x36, 0x65, 0x5B, 
	0x4D, 0x58, 0x50, 0x46, 0x49, 0x40, 0x3F, 0x49, 0x3F, 0x3B, 0x65, 0x5C, 0x53, 0x3F, 0x4A, 0x47, 
	0x12, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x74, 0x6D, 0x68, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4A, 0x58, 0x50, 0x48, 0x5C, 0x53, 
	0x4B, 0x5C, 0x54, 0x4C, 0x5C, 0x53, 0x4B, 0x52, 0x51, 0x4E, 0x1E, 0x3F, 0x42, 0x15, 0x26, 0x2E, 
	0x1E, 0x2C, 0x36, 0x12, 0x38, 0x42, 0x1A, 0x38, 0x43, 0x12, 0x37, 0x42, 0x32, 0x3A, 0x3A, 0x53, 
	0x49, 0x3E, 0x4B, 0x42, 0x3B, 0x54, 0x4C, 0x42, 0x42, 0x3A, 0x32, 0x4A, 0x40, 0x38, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x37, 0x4D, 0x40, 0x38, 0x33, 0x3E, 0x39, 0x12, 0x27, 0x2B, 0x1B, 0x33, 0x3C, 
	0x1B, 0x33, 0x3C, 0x15, 0x28, 0x2C, 0x2A, 0x33, 0x34, 0x4A, 0x3F, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x30, 
	0x27, 0x31, 0x32, 0x28, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1C, 0x28, 0x1E, 0x1C, 
	0x33, 0x2B, 0x1D, 0x24, 0x19, 0x1C, 0x27, 0x1E, 0x1E, 0x32, 0x29, 0x1C, 0x28, 0x1E, 0x1D, 0x24, 
	0x1A, 0x1C, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x24, 0x18, 0x1A, 0x28, 0x1F, 0x1E, 0x32, 0x35, 
	0x29, 0x25, 0x1A, 0x1B, 0x28, 0x20, 0x1F, 0x32, 0x2B, 0x1F, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x11, 0x28, 0x28, 0x0E, 0x27, 0x28, 0x28, 0x1B, 0x1B, 0x09, 0x2A, 0x2B, 0x2A, 0x1E, 0x1D, 0x32, 
	0x35, 0x29, 0x2C, 0x25, 0x20, 0x08, 0x29, 0x2A, 0x27, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x29, 0x23, 
	0x1F, 0x29, 0x23, 0x20, 0x24, 0x18, 0x1A, 0x2C, 0x2A, 0x25, 0x25, 0x19, 0x1A, 0x32, 0x36, 0x2A, 
	0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2E, 0x2F, 0x25, 0x3A, 0x38, 0x32, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x39, 0x37, 
	0x31, 0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x2F, 0x2E, 0x2B, 0x2E, 0x23, 0x36, 0x31, 0x2E, 
	0x35, 0x35, 0x2F, 0x50, 0x45, 0x3B, 0x37, 0x33, 0x2F, 0x30, 0x2E, 0x2F, 0x1B, 0x31, 0x3B, 0x15, 
	0x29, 0x2C, 0x1E, 0x34, 0x3E, 0x3B, 0x3D, 0x35, 0x4E, 0x42, 0x39, 0x33, 0x36, 0x2E, 0x51, 0x44, 
	0x3B, 0x3F, 0x3A, 0x30, 0x1A, 0x2B, 0x36, 0x16, 0x3C, 0x45, 0x1F, 0x30, 0x39, 0x14, 0x2C, 0x30, 
	0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x38, 0x42, 0x1D, 
	0x2E, 0x36, 0x1D, 0x37, 0x3F, 0x1D, 0x3A, 0x43, 0x1B, 0x39, 0x43, 0x27, 0x2F, 0x2E, 0x5F, 0x53, 
	0x4A, 0x5B, 0x53, 0x45, 0x4F, 0x47, 0x3F, 0x4E, 0x46, 0x3B, 0x5F, 0x57, 0x4F, 0x53, 0x4D, 0x43, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x19, 0x20, 0x1D, 0x86, 0x7A, 0x68, 0x56, 
	0x4E, 0x47, 0x58, 0x50, 0x48, 0x4C, 0x44, 0x3C, 0x53, 0x4B, 0x45, 0x5B, 0x53, 0x4B, 0x52, 0x4A, 
	0x40, 0x50, 0x48, 0x3D, 0x51, 0x49, 0x3E, 0x50, 0x46, 0x3E, 0x51, 0x4F, 0x4B, 0x2C, 0x3E, 0x42, 
	0x14, 0x39, 0x42, 0x1A, 0x32, 0x38, 0x4A, 0x3C, 0x30, 0x24, 0x31, 0x31, 0x3F, 0x49, 0x4B, 0x4F, 
	0x46, 0x3A, 0x47, 0x3C, 0x35, 0x53, 0x4B, 0x42, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x1F, 0x31, 0x38, 0x16, 0x29, 0x2C, 
	0x1C, 0x34, 0x3E, 0x15, 0x29, 0x2E, 0x2F, 0x33, 0x2E, 0x4F, 0x43, 0x3A, 0x35, 0x37, 0x2F, 0x35, 
	0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x32, 
	0x27, 0x23, 0x13, 0x18, 0x32, 0x34, 0x29, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x26, 0x1A, 0x1B, 0x32, 0x35, 0x2A, 0x23, 0x18, 0x1B, 0x32, 0x29, 0x1C, 0x32, 
	0x2B, 0x1F, 0x32, 0x35, 0x2A, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x32, 0x34, 
	0x29, 0x25, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 0x32, 0x28, 0x1B, 0x25, 0x1B, 0x1C, 0x2B, 0x1A, 0x1A, 
	0x0C, 0x28, 0x29, 0x25, 0x1E, 0x1E, 0x29, 0x23, 0x1F, 0x28, 0x1B, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 
	0x1F, 0x1E, 0x33, 0x36, 0x2A, 0x29, 0x16, 0x19, 0x34, 0x31, 0x24, 0x28, 0x20, 0x1F, 0x26, 0x1B, 
	0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x28, 0x20, 0x1F, 0x26, 0x1C, 0x1C, 0x25, 0x18, 0x1A, 
	0x32, 0x34, 0x29, 0x30, 0x32, 0x27, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x2E, 0x30, 0x25, 0x2F, 0x2F, 0x26, 0x36, 0x31, 
	0x2E, 0x38, 0x39, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x38, 0x31, 0x3A, 0x38, 0x32, 0x2F, 0x2C, 0x26, 
	0x36, 0x34, 0x2E, 0x36, 0x38, 0x2F, 0x39, 0x31, 0x30, 0x31, 0x32, 0x30, 0x15, 0x2A, 0x30, 0x19, 
	0x2A, 0x2E, 0x14, 0x28, 0x2C, 0x2F, 0x2B, 0x2C, 0x4F, 0x44, 0x3A, 0x33, 0x36, 0x2E, 0x35, 0x36, 
	0x2E, 0x3E, 0x3E, 0x37, 0x16, 0x31, 0x3B, 0x1C, 0x2B, 0x31, 0x14, 0x27, 0x27, 0x14, 0x2B, 0x30, 
	0x1E, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2B, 0x1B, 
	0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 0x1C, 0x39, 0x42, 0x1D, 0x31, 0x38, 0x42, 0x49, 
	0x47, 0x69, 0x5E, 0x4C, 0x4E, 0x46, 0x3D, 0x59, 0x51, 0x4A, 0x5C, 0x54, 0x4B, 0x58, 0x50, 0x4A, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x56, 
	0x4F, 0x47, 0x5B, 0x53, 0x4B, 0x53, 0x4B, 0x45, 0x4D, 0x45, 0x3D, 0x5C, 0x54, 0x4C, 0x56, 0x4E, 
	0x45, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3F, 0x50, 0x48, 0x40, 0x56, 0x4D, 0x43, 0x53, 0x48, 0x3F, 
	0x50, 0x49, 0x44, 0x4F, 0x4A, 0x45, 0x50, 0x46, 0x42, 0x43, 0x3F, 0x43, 0x4A, 0x3D, 0x33, 0x50, 
	0x48, 0x42, 0x53, 0x4B, 0x42, 0x53, 0x4B, 0x42, 0x48, 0x3D, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x3B, 0x36, 0x2A, 0x11, 0x27, 0x29, 
	0x15, 0x28, 0x29, 0x15, 0x2A, 0x30, 0x33, 0x38, 0x33, 0x50, 0x44, 0x3A, 0x3A, 0x39, 0x31, 0x33, 
	0x30, 0x2B, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x36, 0x30, 0x2E, 0x2C, 0x30, 0x24, 0x35, 0x30, 
	0x2C, 0x30, 0x32, 0x27, 0x30, 0x32, 0x28, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1B, 0x33, 0x36, 0x2A, 
	0x33, 0x36, 0x2A, 0x25, 0x18, 0x1A, 0x32, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x25, 0x1B, 0x1C, 0x26, 
	0x1B, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1F, 0x1E, 0x28, 0x22, 0x1F, 0x32, 0x36, 0x2A, 0x2A, 0x20, 0x1E, 0x0B, 0x28, 0x29, 
	0x35, 0x2F, 0x25, 0x28, 0x1A, 0x1A, 0x2B, 0x28, 0x23, 0x26, 0x1B, 0x1C, 0x28, 0x1B, 0x1B, 0x28, 
	0x1E, 0x1C, 0x29, 0x1E, 0x1E, 0x09, 0x29, 0x2A, 0x26, 0x1F, 0x1D, 0x33, 0x2F, 0x23, 0x28, 0x1A, 
	0x1B, 0x09, 0x2A, 0x2B, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x25, 0x19, 0x1B, 0x24, 0x16, 0x1A, 0x2F, 0x32, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x25, 0x31, 0x2E, 
	0x28, 0x39, 0x3A, 0x31, 0x2F, 0x2E, 0x26, 0x30, 0x2E, 0x27, 0x36, 0x31, 0x2E, 0x39, 0x37, 0x31, 
	0x35, 0x2C, 0x2C, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x30, 0x31, 0x36, 0x31, 0x0E, 0x23, 0x20, 0x19, 
	0x37, 0x43, 0x1A, 0x33, 0x3C, 0x1C, 0x34, 0x3C, 0x4A, 0x3F, 0x35, 0x4E, 0x43, 0x3A, 0x3A, 0x39, 
	0x31, 0x39, 0x36, 0x2B, 0x0F, 0x36, 0x42, 0x19, 0x35, 0x3E, 0x15, 0x25, 0x25, 0x1C, 0x34, 0x3D, 
	0x14, 0x2B, 0x2F, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x14, 
	0x27, 0x27, 0x1F, 0x31, 0x3B, 0x1A, 0x2A, 0x30, 0x1D, 0x3A, 0x43, 0x1B, 0x2C, 0x36, 0x1A, 0x39, 
	0x3E, 0x4B, 0x46, 0x42, 0x62, 0x59, 0x49, 0x54, 0x4C, 0x45, 0x4F, 0x47, 0x3D, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x61, 0x57, 
	0x50, 0x48, 0x58, 0x50, 0x48, 0x5D, 0x55, 0x4D, 0x51, 0x48, 0x3E, 0x56, 0x4E, 0x46, 0x50, 0x48, 
	0x3E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x3F, 0x46, 0x3C, 0x3A, 0x53, 0x4B, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x51, 0x48, 0x40, 0x50, 0x48, 0x42, 0x52, 
	0x4A, 0x40, 0x52, 0x4A, 0x40, 0x4B, 0x42, 0x39, 0x49, 0x3F, 0x36, 0x4A, 0x40, 0x45, 0x4A, 0x40, 
	0x37, 0x44, 0x3D, 0x35, 0x4E, 0x42, 0x38, 0x4B, 0x42, 0x38, 0x45, 0x3D, 0x34, 0x13, 0x29, 0x31, 
	0x12, 0x25, 0x23, 0x18, 0x2C, 0x33, 0x23, 0x1D, 0x1A, 0x3C, 0x39, 0x2E, 0x50, 0x45, 0x3B, 0x4A, 
	0x42, 0x38, 0x34, 0x2F, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x37, 0x30, 
	0x2F, 0x2F, 0x31, 0x27, 0x30, 0x2A, 0x20, 0x31, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x25, 0x18, 0x1A, 
	0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x32, 0x35, 0x29, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x32, 
	0x28, 0x32, 0x2F, 0x23, 0x25, 0x1A, 0x1C, 0x25, 0x18, 0x1B, 0x2A, 0x1D, 0x1A, 0x0D, 0x29, 0x29, 
	0x26, 0x1C, 0x1C, 0x13, 0x26, 0x26, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0B, 0x29, 0x2A, 0x34, 
	0x27, 0x1E, 0x32, 0x2B, 0x1F, 0x27, 0x20, 0x1D, 0x0C, 0x27, 0x28, 0x34, 0x34, 0x28, 0x26, 0x1A, 
	0x1B, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1C, 0x31, 0x27, 0x1B, 0x2F, 0x31, 0x27, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2E, 0x2F, 
	0x25, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x34, 0x31, 0x2B, 0x2C, 0x2E, 0x24, 0x39, 0x3A, 0x31, 
	0x35, 0x34, 0x2C, 0x35, 0x2C, 0x2C, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x29, 0x15, 0x2B, 0x32, 0x11, 
	0x29, 0x2A, 0x15, 0x29, 0x2E, 0x1D, 0x2E, 0x35, 0x37, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4F, 0x43, 
	0x39, 0x4B, 0x3F, 0x36, 0x1E, 0x32, 0x37, 0x18, 0x35, 0x3E, 0x18, 0x36, 0x3E, 0x1B, 0x33, 0x3C, 
	0x15, 0x27, 0x27, 0x11, 0x24, 0x20, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x12, 
	0x24, 0x22, 0x11, 0x2A, 0x2A, 0x1B, 0x32, 0x3B, 0x1D, 0x39, 0x42, 0x1D, 0x2F, 0x37, 0x15, 0x2B, 
	0x33, 0x34, 0x43, 0x44, 0x6B, 0x60, 0x4C, 0x5F, 0x57, 0x4B, 0x58, 0x50, 0x48, 0x5A, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x78, 0x69, 0x4B, 
	0x44, 0x42, 0x4B, 0x43, 0x3B, 0x51, 0x49, 0x3E, 0x4B, 0x49, 0x44, 0x56, 0x4E, 0x45, 0x55, 0x4D, 
	0x44, 0x5C, 0x54, 0x4C, 0x57, 0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 
	0x4B, 0x42, 0x54, 0x4C, 0x43, 0x48, 0x3E, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x22, 0x31, 0x33, 0x4C, 0x3D, 0x36, 0x50, 0x44, 0x3A, 0x1A, 0x2A, 0x2A, 
	0x1B, 0x2F, 0x36, 0x13, 0x26, 0x26, 0x1C, 0x32, 0x3C, 0x16, 0x2F, 0x3B, 0x39, 0x2C, 0x2A, 0x37, 
	0x36, 0x30, 0x4C, 0x43, 0x39, 0x33, 0x33, 0x2B, 0x36, 0x2F, 0x2E, 0x39, 0x36, 0x31, 0x31, 0x30, 
	0x29, 0x30, 0x29, 0x1E, 0x30, 0x26, 0x1B, 0x31, 0x29, 0x1E, 0x32, 0x35, 0x2A, 0x33, 0x36, 0x2A, 
	0x25, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1E, 0x1E, 0x28, 0x19, 0x1A, 0x31, 0x30, 0x27, 0x32, 0x2F, 0x24, 0x26, 0x20, 0x1D, 
	0x09, 0x29, 0x2A, 0x35, 0x26, 0x20, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0E, 0x29, 0x29, 0x0C, 
	0x27, 0x29, 0x32, 0x25, 0x1B, 0x20, 0x1C, 0x1E, 0x0E, 0x27, 0x28, 0x32, 0x2F, 0x26, 0x26, 0x1B, 
	0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2A, 0x27, 0x1E, 0x1E, 
	0x31, 0x2F, 0x25, 0x30, 0x25, 0x1B, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 
	0x2E, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x2E, 0x28, 0x39, 0x37, 0x31, 0x36, 0x35, 0x2E, 0x2C, 0x2F, 0x24, 0x39, 0x33, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x36, 0x30, 0x2A, 0x16, 0x23, 0x26, 0x1A, 
	0x2F, 0x36, 0x24, 0x29, 0x2B, 0x39, 0x31, 0x2B, 0x38, 0x38, 0x30, 0x39, 0x38, 0x2E, 0x2A, 0x37, 
	0x36, 0x4E, 0x42, 0x36, 0x2C, 0x34, 0x33, 0x12, 0x25, 0x26, 0x1F, 0x30, 0x39, 0x1A, 0x2B, 0x31, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1F, 
	0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1A, 0x2B, 0x31, 0x1A, 0x2B, 
	0x31, 0x18, 0x39, 0x43, 0x4D, 0x3F, 0x35, 0x63, 0x5B, 0x4B, 0x5A, 0x52, 0x4B, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x62, 0x58, 
	0x51, 0x49, 0x53, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x50, 0x47, 0x3D, 0x58, 0x50, 0x48, 0x5B, 0x53, 
	0x4B, 0x56, 0x4E, 0x46, 0x50, 0x48, 0x3E, 0x58, 0x50, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 
	0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x47, 0x3D, 0x40, 0x49, 0x3D, 0x36, 0x4C, 0x43, 0x39, 0x48, 
	0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x45, 0x3D, 0x33, 0x11, 0x29, 0x34, 0x1B, 0x2E, 0x32, 0x50, 0x43, 0x37, 0x32, 0x31, 0x2F, 
	0x1B, 0x30, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 0x2B, 0x2B, 0x22, 
	0x1E, 0x1C, 0x38, 0x37, 0x30, 0x39, 0x34, 0x31, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x30, 0x32, 
	0x28, 0x24, 0x18, 0x1B, 0x32, 0x28, 0x1B, 0x24, 0x19, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x25, 0x18, 0x1A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x32, 0x34, 
	0x29, 0x2F, 0x26, 0x22, 0x0D, 0x28, 0x28, 0x15, 0x23, 0x25, 0x30, 0x25, 0x1B, 0x2C, 0x23, 0x1C, 
	0x20, 0x1C, 0x1E, 0x31, 0x33, 0x29, 0x29, 0x23, 0x1F, 0x26, 0x1C, 0x1C, 0x2A, 0x1B, 0x1B, 0x1B, 
	0x23, 0x23, 0x26, 0x19, 0x1B, 0x32, 0x2E, 0x25, 0x0B, 0x28, 0x29, 0x28, 0x1A, 0x1B, 0x26, 0x1C, 
	0x1C, 0x2A, 0x24, 0x20, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1E, 0x1F, 0x33, 0x30, 0x24, 
	0x23, 0x18, 0x1B, 0x31, 0x26, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x26, 
	0x1B, 0x1C, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2F, 0x30, 
	0x26, 0x2F, 0x30, 0x26, 0x31, 0x30, 0x28, 0x37, 0x30, 0x2F, 0x39, 0x2F, 0x31, 0x38, 0x33, 0x30, 
	0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x36, 0x2E, 0x2C, 0x30, 0x33, 0x2C, 0x15, 
	0x2E, 0x3B, 0x31, 0x34, 0x2F, 0x39, 0x39, 0x30, 0x3A, 0x39, 0x30, 0x1D, 0x2F, 0x32, 0x18, 0x2F, 
	0x39, 0x2B, 0x2E, 0x32, 0x1E, 0x35, 0x3D, 0x16, 0x29, 0x2C, 0x16, 0x36, 0x3E, 0x1E, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 
	0x29, 0x2C, 0x14, 0x27, 0x27, 0x1B, 0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 
	0x38, 0x1B, 0x36, 0x3F, 0x1B, 0x35, 0x3C, 0x48, 0x3D, 0x32, 0x5A, 0x52, 0x4A, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x71, 0x63, 0x55, 
	0x4E, 0x40, 0x5A, 0x52, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x4F, 0x47, 0x3D, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x53, 0x4A, 0x3F, 
	0x53, 0x4B, 0x42, 0x52, 0x4A, 0x40, 0x4F, 0x46, 0x3F, 0x3E, 0x4A, 0x4D, 0x4B, 0x3D, 0x33, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x3C, 0x39, 0x30, 0x2A, 0x32, 0x32, 0x0D, 0x23, 0x22, 0x23, 0x30, 0x3A, 0x2C, 0x2C, 0x20, 
	0x19, 0x2E, 0x36, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x15, 0x2A, 0x2E, 0x13, 
	0x2F, 0x39, 0x3B, 0x3A, 0x2F, 0x38, 0x2E, 0x30, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x26, 0x31, 0x29, 
	0x1E, 0x25, 0x19, 0x1B, 0x32, 0x36, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 0x1B, 0x1C, 0x29, 0x20, 
	0x1E, 0x27, 0x24, 0x22, 0x12, 0x27, 0x27, 0x0D, 0x28, 0x28, 0x2C, 0x1D, 0x1B, 0x29, 0x1F, 0x1D, 
	0x26, 0x1B, 0x1C, 0x32, 0x2B, 0x1F, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x32, 0x36, 0x2A, 0x2A, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 
	0x1C, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x28, 0x1F, 0x1C, 0x32, 0x28, 0x1C, 0x29, 0x20, 0x1C, 
	0x27, 0x1D, 0x1C, 0x30, 0x28, 0x1E, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x30, 
	0x31, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x30, 0x2E, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x32, 0x28, 0x29, 0x24, 0x20, 0x30, 0x2B, 0x27, 0x37, 0x33, 0x2F, 0x39, 0x3A, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x3A, 0x30, 0x2C, 0x32, 0x30, 0x3C, 
	0x39, 0x2F, 0x39, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x34, 0x2C, 0x14, 0x20, 0x24, 0x1D, 0x31, 
	0x3A, 0x15, 0x2B, 0x32, 0x34, 0x3A, 0x36, 0x15, 0x2B, 0x34, 0x1B, 0x33, 0x3C, 0x14, 0x2C, 0x30, 
	0x1F, 0x30, 0x3A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2C, 0x36, 0x1A, 0x36, 0x3F, 0x39, 0x3E, 0x40, 0x59, 0x50, 0x46, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1B, 0x22, 0x1E, 0x7E, 0x70, 0x61, 0x5C, 
	0x54, 0x4E, 0x58, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5C, 0x54, 0x4C, 0x50, 0x48, 0x3E, 0x5B, 0x53, 0x4B, 0x4E, 0x44, 0x3E, 0x4F, 0x4B, 0x44, 
	0x4A, 0x3D, 0x34, 0x54, 0x4C, 0x43, 0x4B, 0x42, 0x38, 0x4D, 0x40, 0x3E, 0x3B, 0x4E, 0x51, 0x4B, 
	0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4C, 0x42, 
	0x39, 0x45, 0x3D, 0x34, 0x2B, 0x35, 0x36, 0x0F, 0x24, 0x23, 0x14, 0x28, 0x29, 0x16, 0x2B, 0x32, 
	0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 0x18, 0x2A, 0x2F, 0x1A, 0x2E, 0x34, 0x1F, 0x2C, 0x35, 0x2F, 
	0x1E, 0x13, 0x36, 0x38, 0x2F, 0x37, 0x32, 0x2F, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x20, 
	0x1F, 0x26, 0x1B, 0x1C, 0x28, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1A, 0x1B, 0x32, 0x2B, 0x1F, 0x2A, 0x1F, 
	0x1E, 0x0C, 0x28, 0x28, 0x11, 0x27, 0x27, 0x33, 0x27, 0x20, 0x11, 0x27, 0x27, 0x28, 0x1B, 0x1C, 
	0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1B, 0x1C, 0x2A, 0x1C, 0x1A, 0x33, 0x29, 0x1C, 0x27, 0x1D, 0x1C, 0x29, 0x23, 
	0x20, 0x25, 0x1A, 0x1B, 0x28, 0x22, 0x20, 0x28, 0x20, 0x1F, 0x31, 0x2A, 0x1F, 0x31, 0x28, 0x1C, 
	0x31, 0x27, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x31, 
	0x2E, 0x27, 0x1F, 0x1E, 0x26, 0x1B, 0x1C, 0x25, 0x1A, 0x1B, 0x2A, 0x26, 0x20, 0x2F, 0x29, 0x26, 
	0x39, 0x37, 0x31, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x39, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x2F, 0x2F, 0x37, 0x35, 0x14, 0x31, 
	0x3D, 0x16, 0x2C, 0x38, 0x43, 0x3C, 0x31, 0x2E, 0x2A, 0x27, 0x18, 0x2E, 0x36, 0x11, 0x23, 0x1E, 
	0x18, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x12, 0x25, 0x24, 0x1D, 0x30, 
	0x3A, 0x25, 0x38, 0x3D, 0x4E, 0x40, 0x34, 0x4F, 0x44, 0x3F, 0x4F, 0x47, 0x44, 0x5D, 0x54, 0x48, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x64, 0x59, 
	0x52, 0x4C, 0x65, 0x5D, 0x49, 0x59, 0x51, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x4A, 0x66, 0x5E, 
	0x4A, 0x5A, 0x52, 0x4B, 0x51, 0x49, 0x3E, 0x54, 0x4B, 0x40, 0x39, 0x34, 0x28, 0x22, 0x33, 0x37, 
	0x33, 0x39, 0x37, 0x50, 0x44, 0x3A, 0x49, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x49, 0x3D, 0x34, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4B, 0x40, 0x38, 0x3A, 0x39, 
	0x31, 0x38, 0x38, 0x2F, 0x26, 0x30, 0x31, 0x1D, 0x32, 0x3D, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 
	0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x18, 0x2A, 0x2F, 0x16, 0x2B, 0x30, 0x1E, 0x24, 0x1F, 0x3C, 
	0x34, 0x33, 0x39, 0x35, 0x31, 0x31, 0x2F, 0x28, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x25, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x36, 0x2A, 0x28, 0x19, 0x1A, 0x12, 0x25, 0x26, 0x33, 0x34, 0x29, 0x2A, 0x25, 
	0x20, 0x26, 0x23, 0x20, 0x0C, 0x29, 0x29, 0x28, 0x1A, 0x1B, 0x28, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1B, 0x1C, 0x32, 0x2F, 0x26, 0x08, 0x27, 0x29, 0x26, 0x1F, 0x1D, 0x32, 0x2F, 0x24, 0x27, 0x1F, 
	0x1F, 0x32, 0x30, 0x24, 0x32, 0x2B, 0x1F, 0x27, 0x1E, 0x1E, 0x2B, 0x29, 0x24, 0x25, 0x1A, 0x1C, 
	0x2A, 0x20, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x32, 
	0x27, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x29, 0x26, 0x20, 
	0x3A, 0x34, 0x32, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x30, 0x35, 0x31, 
	0x25, 0x2A, 0x3B, 0x3D, 0x4C, 0x40, 0x37, 0x40, 0x3C, 0x32, 0x28, 0x2F, 0x32, 0x1E, 0x31, 0x3C, 
	0x18, 0x34, 0x3C, 0x19, 0x36, 0x40, 0x12, 0x24, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x1D, 0x30, 
	0x3A, 0x23, 0x37, 0x3B, 0x5A, 0x4E, 0x48, 0x5C, 0x54, 0x49, 0x4F, 0x47, 0x3F, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x20, 0x1D, 0x84, 0x78, 0x68, 0x63, 
	0x59, 0x4C, 0x57, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5B, 0x53, 0x4B, 0x52, 0x49, 0x3E, 0x4E, 0x49, 0x45, 0x1F, 0x37, 0x3E, 0x1A, 0x2E, 0x37, 
	0x13, 0x2F, 0x3A, 0x3E, 0x3D, 0x34, 0x48, 0x3E, 0x35, 0x4E, 0x46, 0x3C, 0x4F, 0x47, 0x40, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x33, 0x36, 
	0x2E, 0x37, 0x38, 0x30, 0x40, 0x39, 0x2F, 0x13, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 
	0x19, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2E, 0x35, 0x14, 0x27, 0x24, 0x3B, 
	0x30, 0x31, 0x33, 0x2E, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x35, 0x29, 0x1B, 0x1F, 0x20, 0x16, 0x24, 0x25, 0x33, 0x25, 0x19, 0x33, 0x32, 
	0x2B, 0x32, 0x34, 0x28, 0x2B, 0x1D, 0x1A, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x32, 0x35, 0x29, 0x33, 0x2B, 0x24, 0x08, 0x27, 0x2A, 0x34, 0x2A, 0x1E, 0x25, 0x1B, 
	0x1C, 0x25, 0x1A, 0x1C, 0x28, 0x20, 0x1F, 0x33, 0x36, 0x2A, 0x27, 0x1F, 0x1F, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1B, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2B, 0x27, 0x23, 0x26, 0x19, 0x1A, 0x29, 0x23, 0x20, 0x26, 0x1B, 0x1C, 0x2A, 0x26, 0x22, 
	0x34, 0x35, 0x2B, 0x38, 0x39, 0x30, 0x38, 0x2C, 0x30, 0x38, 0x3A, 0x30, 0x35, 0x30, 0x2C, 0x38, 
	0x30, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x4D, 0x42, 
	0x39, 0x34, 0x39, 0x33, 0x3D, 0x39, 0x31, 0x32, 0x3B, 0x35, 0x31, 0x24, 0x22, 0x0D, 0x24, 0x20, 
	0x1C, 0x34, 0x3D, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1F, 
	0x32, 0x3C, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 0x32, 0x16, 0x29, 
	0x2C, 0x15, 0x2B, 0x37, 0x53, 0x4D, 0x4A, 0x67, 0x5E, 0x4B, 0x53, 0x4B, 0x43, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1E, 0x24, 0x1F, 0x7D, 0x75, 0x68, 0x58, 
	0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 
	0x4B, 0x59, 0x51, 0x49, 0x4F, 0x47, 0x3F, 0x52, 0x47, 0x42, 0x29, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x16, 0x3A, 0x43, 0x14, 0x2F, 0x3A, 0x27, 0x31, 0x31, 0x54, 0x4A, 0x3E, 0x4F, 0x47, 0x3C, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x4A, 0x40, 0x37, 0x49, 0x3F, 
	0x37, 0x36, 0x37, 0x2E, 0x4B, 0x40, 0x35, 0x13, 0x29, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x30, 0x20, 0x2A, 0x33, 0x31, 0x32, 0x2F, 0x39, 
	0x2F, 0x30, 0x39, 0x38, 0x31, 0x2F, 0x2F, 0x26, 0x31, 0x32, 0x28, 0x25, 0x19, 0x1B, 0x27, 0x1D, 
	0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 
	0x1A, 0x1B, 0x2B, 0x1F, 0x1D, 0x0F, 0x28, 0x28, 0x11, 0x27, 0x28, 0x27, 0x22, 0x1D, 0x31, 0x32, 
	0x28, 0x2A, 0x25, 0x22, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x25, 0x19, 0x1B, 0x30, 0x30, 0x27, 0x28, 0x18, 0x19, 0x32, 0x2B, 0x1F, 0x25, 0x1B, 
	0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x2A, 0x1C, 0x26, 0x1B, 0x1D, 
	0x25, 0x19, 0x1B, 0x25, 0x19, 0x1B, 0x31, 0x2B, 0x22, 0x30, 0x29, 0x20, 0x2F, 0x31, 0x27, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2A, 0x24, 0x1F, 0x25, 0x34, 0x34, 0x2C, 0x27, 0x22, 0x25, 0x18, 0x1A, 0x2A, 0x26, 0x22, 
	0x35, 0x33, 0x2C, 0x38, 0x39, 0x30, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x2C, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 
	0x2E, 0x36, 0x36, 0x2E, 0x35, 0x36, 0x2E, 0x50, 0x43, 0x39, 0x3C, 0x3F, 0x38, 0x13, 0x28, 0x2F, 
	0x1F, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x12, 0x25, 0x23, 0x1C, 0x35, 0x40, 0x15, 0x28, 0x29, 0x12, 0x25, 0x23, 0x1F, 0x32, 
	0x3D, 0x0D, 0x25, 0x29, 0x56, 0x4A, 0x47, 0x62, 0x5A, 0x4A, 0x5B, 0x53, 0x4C, 0x53, 0x4D, 0x44, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x2E, 0x2A, 0x8D, 0x7B, 0x6C, 0x59, 
	0x51, 0x47, 0x58, 0x50, 0x49, 0x4F, 0x47, 0x3C, 0x50, 0x48, 0x3E, 0x50, 0x48, 0x3E, 0x50, 0x48, 
	0x3E, 0x52, 0x49, 0x3E, 0x4C, 0x44, 0x3C, 0x51, 0x47, 0x43, 0x27, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x1D, 0x3A, 0x43, 0x1A, 0x31, 0x39, 0x14, 0x31, 0x3C, 0x3C, 0x34, 0x2A, 0x4C, 0x42, 0x39, 0x49, 
	0x3F, 0x37, 0x4B, 0x40, 0x38, 0x49, 0x3F, 0x36, 0x33, 0x36, 0x2B, 0x51, 0x43, 0x3E, 0x45, 0x3A, 
	0x33, 0x2C, 0x36, 0x34, 0x28, 0x31, 0x32, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 0x26, 0x25, 0x24, 0x20, 0x1C, 0x3A, 
	0x31, 0x32, 0x39, 0x32, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 
	0x37, 0x2A, 0x27, 0x23, 0x20, 0x12, 0x27, 0x27, 0x12, 0x26, 0x27, 0x23, 0x29, 0x25, 0x32, 0x32, 
	0x28, 0x31, 0x33, 0x28, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x18, 0x1A, 0x11, 0x26, 0x27, 0x31, 0x2F, 0x27, 0x28, 0x1D, 
	0x1B, 0x34, 0x37, 0x2B, 0x27, 0x20, 0x1D, 0x09, 0x29, 0x2A, 0x28, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x24, 0x16, 0x1A, 0x32, 0x34, 0x29, 0x31, 0x33, 0x29, 0x29, 0x24, 0x20, 0x34, 
	0x31, 0x2B, 0x37, 0x30, 0x2F, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 
	0x26, 0x32, 0x31, 0x26, 0x1D, 0x32, 0x3A, 0x2F, 0x2A, 0x23, 0x32, 0x33, 0x27, 0x2A, 0x24, 0x1F, 
	0x28, 0x24, 0x1F, 0x3A, 0x38, 0x32, 0x38, 0x37, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x3A, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 
	0x3B, 0x4E, 0x43, 0x3A, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x4B, 0x40, 0x36, 0x1C, 0x2B, 0x2E, 
	0x18, 0x2B, 0x30, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x16, 
	0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x25, 0x24, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 0x27, 
	0x28, 0x27, 0x35, 0x39, 0x5F, 0x55, 0x46, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x09, 0x20, 0x23, 0x1F, 0x82, 0x75, 0x63, 0x56, 
	0x4F, 0x48, 0x4E, 0x46, 0x3B, 0x5C, 0x54, 0x4D, 0x52, 0x4A, 0x40, 0x59, 0x51, 0x49, 0x5B, 0x52, 
	0x4A, 0x4D, 0x4F, 0x4D, 0x53, 0x4A, 0x3F, 0x53, 0x4A, 0x3E, 0x35, 0x3A, 0x37, 0x1A, 0x2C, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x19, 0x32, 0x3B, 0x1F, 0x2E, 0x36, 0x45, 0x36, 0x32, 0x53, 
	0x4B, 0x42, 0x4A, 0x3F, 0x35, 0x2C, 0x38, 0x36, 0x27, 0x2F, 0x2F, 0x22, 0x3F, 0x45, 0x28, 0x30, 
	0x2F, 0x16, 0x2C, 0x35, 0x16, 0x2A, 0x30, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 
	0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x1A, 0x33, 0x3F, 0x3A, 
	0x2E, 0x29, 0x39, 0x30, 0x31, 0x34, 0x30, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x19, 0x1A, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x1E, 0x20, 0x22, 0x2B, 0x22, 
	0x1D, 0x32, 0x33, 0x29, 0x1C, 0x16, 0x18, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x38, 0x2B, 0x26, 0x16, 0x19, 0x25, 0x1A, 0x1C, 0x25, 0x1A, 
	0x1B, 0x27, 0x16, 0x19, 0x09, 0x28, 0x29, 0x27, 0x20, 0x1D, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x25, 0x24, 0x18, 0x1B, 0x24, 0x18, 0x1A, 0x27, 0x1E, 0x1D, 0x2F, 
	0x31, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x39, 0x30, 
	0x31, 0x30, 0x32, 0x27, 0x27, 0x1B, 0x1A, 0x32, 0x32, 0x27, 0x23, 0x2F, 0x32, 0x26, 0x35, 0x36, 
	0x29, 0x23, 0x1E, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x31, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x50, 0x44, 0x3B, 0x33, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x48, 0x3E, 0x35, 0x1D, 0x30, 0x38, 
	0x11, 0x25, 0x26, 0x13, 0x26, 0x29, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x1A, 0x2C, 0x32, 0x13, 
	0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x11, 0x25, 
	0x25, 0x1D, 0x2C, 0x2A, 0x6C, 0x5A, 0x4D, 0x60, 0x59, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x20, 0x1D, 0x87, 0x78, 0x67, 0x5C, 
	0x54, 0x4D, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x53, 0x4B, 0x5A, 0x52, 0x49, 0x4B, 0x42, 
	0x37, 0x33, 0x46, 0x47, 0x55, 0x4D, 0x49, 0x52, 0x44, 0x39, 0x30, 0x3C, 0x36, 0x1A, 0x3D, 0x45, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2F, 0x38, 0x25, 0x31, 0x32, 0x5A, 
	0x4E, 0x43, 0x20, 0x2B, 0x29, 0x16, 0x31, 0x3C, 0x1C, 0x2F, 0x39, 0x1B, 0x31, 0x3A, 0x1C, 0x30, 
	0x3A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 
	0x1E, 0x1A, 0x38, 0x2E, 0x2B, 0x31, 0x30, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x32, 0x27, 0x25, 0x19, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x28, 0x2F, 0x24, 
	0x1D, 0x32, 0x35, 0x2A, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x29, 0x1E, 0x1B, 0x26, 
	0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x28, 0x1C, 0x1A, 0x32, 0x37, 0x2B, 0x32, 0x27, 0x1A, 0x32, 0x35, 
	0x2A, 0x32, 0x34, 0x29, 0x34, 0x33, 0x28, 0x32, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x25, 0x19, 0x1B, 0x32, 0x29, 0x1C, 0x32, 0x28, 0x1C, 0x32, 0x2F, 0x24, 0x31, 0x33, 0x28, 0x2F, 
	0x30, 0x26, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x33, 
	0x27, 0x29, 0x23, 0x20, 0x32, 0x32, 0x26, 0x31, 0x30, 0x26, 0x30, 0x2F, 0x24, 0x39, 0x2F, 0x2F, 
	0x2F, 0x32, 0x26, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x39, 0x2F, 0x38, 0x2C, 0x30, 0x38, 
	0x39, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 
	0x2F, 0x35, 0x37, 0x2F, 0x36, 0x37, 0x2F, 0x48, 0x3F, 0x37, 0x50, 0x45, 0x3B, 0x4D, 0x3F, 0x34, 
	0x28, 0x42, 0x46, 0x32, 0x42, 0x45, 0x11, 0x25, 0x28, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x11, 0x24, 
	0x24, 0x22, 0x37, 0x3E, 0x66, 0x57, 0x48, 0x63, 0x5C, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x54, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x75, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x4D, 0x4B, 0x45, 0x57, 0x4D, 0x4B, 0x2B, 0x26, 
	0x1C, 0x15, 0x2F, 0x3A, 0x23, 0x38, 0x3C, 0x2A, 0x32, 0x32, 0x19, 0x31, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x29, 0x33, 0x33, 0x53, 
	0x45, 0x3A, 0x13, 0x22, 0x25, 0x1B, 0x34, 0x3E, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x18, 0x2A, 
	0x2F, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 
	0x15, 0x28, 0x29, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x11, 0x27, 0x26, 0x18, 
	0x26, 0x2A, 0x3A, 0x31, 0x30, 0x2E, 0x30, 0x25, 0x38, 0x30, 0x30, 0x35, 0x31, 0x2C, 0x29, 0x24, 
	0x1F, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0C, 
	0x2A, 0x2A, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x24, 0x1D, 
	0x1E, 0x26, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2B, 0x28, 
	0x1E, 0x1B, 0x26, 0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x25, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 0x1A, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x19, 0x1B, 0x30, 0x26, 0x1B, 0x25, 0x1A, 0x1B, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1D, 0x26, 0x1B, 0x1D, 0x24, 0x19, 0x1B, 0x2B, 0x26, 0x22, 0x30, 
	0x31, 0x27, 0x2E, 0x30, 0x25, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x30, 0x33, 0x27, 0x23, 0x13, 
	0x18, 0x33, 0x34, 0x27, 0x1C, 0x31, 0x39, 0x24, 0x2F, 0x31, 0x2C, 0x33, 0x2F, 0x30, 0x30, 0x25, 
	0x28, 0x22, 0x1E, 0x34, 0x30, 0x2B, 0x38, 0x31, 0x30, 0x35, 0x3C, 0x36, 0x38, 0x39, 0x2F, 0x38, 
	0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 
	0x3C, 0x33, 0x36, 0x2E, 0x39, 0x36, 0x30, 0x35, 0x32, 0x2A, 0x39, 0x40, 0x3F, 0x42, 0x3B, 0x30, 
	0x31, 0x35, 0x2C, 0x57, 0x55, 0x51, 0x2B, 0x31, 0x30, 0x0E, 0x24, 0x24, 0x13, 0x26, 0x26, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x28, 
	0x2A, 0x24, 0x37, 0x3C, 0x51, 0x4C, 0x4A, 0x64, 0x5C, 0x49, 0x5B, 0x53, 0x4B, 0x5C, 0x54, 0x45, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x87, 0x79, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4A, 0x4D, 0x49, 0x46, 0x4C, 0x3F, 0x36, 0x1D, 0x2F, 
	0x36, 0x1C, 0x2F, 0x38, 0x1C, 0x2F, 0x38, 0x15, 0x29, 0x2E, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 
	0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x38, 0x2A, 0x33, 0x33, 0x48, 
	0x40, 0x36, 0x1B, 0x1C, 0x1C, 0x18, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 
	0x2F, 0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x19, 0x2E, 0x34, 0x1F, 0x1E, 0x1E, 0x14, 
	0x28, 0x26, 0x34, 0x30, 0x29, 0x2F, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 
	0x28, 0x30, 0x2A, 0x20, 0x32, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x28, 
	0x28, 0x30, 0x24, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x28, 0x1B, 0x1B, 0x28, 0x22, 0x1F, 0x2B, 
	0x1E, 0x1B, 0x28, 0x1B, 0x1B, 0x29, 0x1E, 0x1B, 0x34, 0x37, 0x2A, 0x24, 0x25, 0x23, 0x12, 0x27, 
	0x27, 0x29, 0x1B, 0x1B, 0x19, 0x24, 0x24, 0x26, 0x19, 0x1B, 0x33, 0x36, 0x2A, 0x33, 0x36, 0x2A, 
	0x24, 0x19, 0x1B, 0x33, 0x2A, 0x1C, 0x25, 0x1A, 0x1D, 0x33, 0x2A, 0x1C, 0x24, 0x18, 0x1B, 0x32, 
	0x34, 0x29, 0x30, 0x2E, 0x24, 0x2E, 0x30, 0x26, 0x36, 0x32, 0x2E, 0x28, 0x23, 0x1F, 0x33, 0x36, 
	0x2A, 0x27, 0x1E, 0x1D, 0x2C, 0x25, 0x1F, 0x32, 0x32, 0x27, 0x33, 0x2F, 0x28, 0x28, 0x30, 0x2C, 
	0x32, 0x30, 0x28, 0x36, 0x30, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x2F, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x31, 0x2C, 0x38, 0x3A, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x53, 0x45, 0x3C, 0x2E, 0x33, 0x2E, 0x23, 0x28, 0x2B, 0x1A, 0x30, 0x3B, 0x11, 0x29, 0x30, 
	0x2C, 0x28, 0x29, 0x5E, 0x52, 0x45, 0x51, 0x47, 0x3A, 0x19, 0x30, 0x38, 0x12, 0x25, 0x24, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 
	0x24, 0x1F, 0x34, 0x3D, 0x4F, 0x43, 0x39, 0x68, 0x5F, 0x55, 0x65, 0x5D, 0x4A, 0x5C, 0x54, 0x4C, 
	0x0D, 0x07, 0x08, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x08, 0x19, 0x22, 0x1D, 0x8B, 0x7C, 0x6A, 0x5C, 
	0x54, 0x4D, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x52, 0x52, 0x4D, 0x06, 0x23, 0x2B, 0x0F, 0x24, 
	0x20, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x38, 0x23, 0x32, 0x38, 0x3F, 
	0x3A, 0x2C, 0x14, 0x2B, 0x32, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 
	0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 0x26, 0x26, 0x20, 0x26, 0x24, 0x3E, 
	0x30, 0x2E, 0x2F, 0x30, 0x26, 0x30, 0x2C, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x28, 0x27, 0x1C, 0x1B, 0x25, 0x1A, 0x1B, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x11, 0x28, 
	0x28, 0x28, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x11, 0x28, 0x28, 0x15, 0x26, 0x26, 0x2A, 0x1A, 0x1A, 0x0E, 
	0x28, 0x29, 0x0E, 0x29, 0x29, 0x28, 0x1B, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1C, 0x1C, 0x28, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 
	0x29, 0x23, 0x20, 0x28, 0x22, 0x20, 0x26, 0x1B, 0x1C, 0x28, 0x22, 0x20, 0x29, 0x23, 0x20, 0x25, 
	0x19, 0x1B, 0x27, 0x1F, 0x1E, 0x31, 0x32, 0x28, 0x29, 0x23, 0x1F, 0x32, 0x34, 0x29, 0x25, 0x18, 
	0x1A, 0x26, 0x1C, 0x1C, 0x26, 0x1B, 0x1C, 0x27, 0x1E, 0x1E, 0x30, 0x31, 0x27, 0x2F, 0x2F, 0x25, 
	0x37, 0x32, 0x2F, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2F, 0x2C, 0x38, 0x3B, 0x30, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x30, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x38, 
	0x30, 0x38, 0x37, 0x2C, 0x1E, 0x34, 0x3E, 0x13, 0x27, 0x29, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x29, 0x30, 0x34, 0x36, 0x32, 0x4D, 0x40, 0x38, 0x46, 0x42, 0x39, 0x14, 0x29, 0x31, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x27, 0x18, 0x33, 0x3D, 0x52, 0x46, 0x42, 0x58, 0x50, 0x49, 0x59, 0x51, 0x45, 
	0x1A, 0x15, 0x13, 0x08, 0x09, 0x09, 0x07, 0x07, 0x07, 0x1B, 0x1F, 0x1D, 0x57, 0x4E, 0x46, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x51, 0x4D, 0x49, 0x47, 0x3B, 0x35, 0x14, 0x2A, 
	0x30, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 
	0x30, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x27, 0x23, 
	0x22, 0x20, 0x31, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x29, 0x1F, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x28, 0x20, 0x1F, 0x25, 0x1B, 0x1C, 0x33, 0x2A, 0x1D, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x19, 0x25, 
	0x25, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x28, 0x1C, 0x1C, 0x15, 0x26, 0x26, 

};

static UINT g_sizeofTexture = sizeof(g_texture);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\media4\scene.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.h

Abstract:

	3D scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#ifndef __SCENE_H__
#define __SCENE_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"
#include "Camera.h"
#include "Ball.h"
#include "InvertedBall.h"
#include "bitfont.h"
#include "spark.h"

namespace Media4 {

//------------------------------------------------------------------------------
//	Vertex for background triangles
//------------------------------------------------------------------------------
#define FVF_CSCENE_BACKGROUND_VERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

//------------------------------------------------------------------------------
//	Number of selectable items in UI
//------------------------------------------------------------------------------
#define NUM_SELECTIONS 13

//------------------------------------------------------------------------------
//	CScene:
//------------------------------------------------------------------------------
class CScene {

public:

	struct Vertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
		DWORD color;        // The vertex color
	};

	struct TVertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
        float u, v;         // Texture coordinates
	};

	enum Hit
	{
		HIT_NOTHING,
		HIT_WALL,
		HIT_BALL
	};

public:

	CScene(void);
    ~CScene(void);

    HRESULT Initialize(IDirect3DDevice8* pDevice);
	void Render(IDirect3DDevice8* pDevice);
	void NextFrame(void);

	void AddBall(void);
	void RemoveBall(void);

	void AddLight(void);
	void RemoveLight(void);

	BOOL DrawText( void ) { return m_bDrawText; }
	void SetDrawText( BOOL bDrawText ) { m_bDrawText = bDrawText; }

private:

	BOOL IntersectRaySphere(const XGVECTOR3&, const XGVECTOR3&, 
							const XGVECTOR3&, float, XGVECTOR3&);
	BOOL IntersectRayInSphere(const XGVECTOR3&, const XGVECTOR3&, 
							  const XGVECTOR3&, float, XGVECTOR3&);
	BOOL GetSphereIntersection(const XGVECTOR3&, float, const XGVECTOR3&,
							   const XGVECTOR3&, float, float&);
	DWORD RandomColor(void);
	void CollideBalls(const XGVECTOR3&, XGVECTOR3&, float&, float,
					  const XGVECTOR3&, XGVECTOR3&, float&, float);

	void BallHitBall(UINT, UINT);
	void BallHitWall(UINT, const XGVECTOR3&);
	void BallSpeedChanged(UINT, float, float);
	void BallDirectionChanged(UINT, const XGVECTOR3&, const XGVECTOR3&);

    HRESULT CreateShaders(IDirect3DDevice8*);
    void ReleaseShaders();
    HRESULT CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc);
	void RecalculateSpeeds(void);
	
    void CycleDisplayMode(void);

public:
	CCamera				m_camera;

private:
    HANDLE              m_hFile;
	UINT				m_numBalls;
	UINT				m_maxBalls;
    UINT                m_numLights;
    UINT                m_maxLights;
	CBall*				m_balls;
	XGMATRIX			m_identityMatrix;
	float				m_radius;
	float				m_radius2;
	CInvertedBall		m_invertedSphere;
	UINT				m_numLayers;
	Vertex*				m_backgroundTriangles;
	IDirect3DSurface8*	m_backBuffer;
	BitFont				m_font;
	double				m_elapsedTime;
	double				m_lastTime;
	double				m_avgFrameRate;
	double				m_currentFrameRate;
	double				m_frequency;
	double				m_startTime;
	double				m_lastCycle;
	UINT				m_frame;
	int					m_ballDetail;
    int                 m_lightDetail;
	int					m_wallDetail;
	float				m_maxSpeed;
	float				m_minSpeed;
	double				m_drawRate;
	UINT				m_numTris;
    DWORD               m_dwVShader;
    DWORD               m_dwVShader2;
    DWORD               m_dwVShaderAddress;
    DWORD               m_dwVShaderAddress2;
    DWORD               m_dwPShader;
    IDirect3DCubeTexture8* m_pd3dtcNormal;
    D3DCOLORVALUE       m_dcvAmbient;
    IDirect3DDevice8*   m_pDevice;
	BOOL				m_bDrawWireframe;
	BOOL				m_bRelativeSpeed;
	BOOL				m_bDrawText;
	CSpark				m_sparks;
    IDirect3DTexture8*  m_pd3dtText;
    TVertex            m_prText[4];
	float				m_dSpeed;
	float				m_currentMaxSpeed;
	float				m_currentMinSpeed;
    D3DDISPLAYMODE*     m_pd3ddm;
    UINT                m_uNumDisplayModes;
    UINT                m_uDisplayMode;

    //
    // audio debug variables
    //

    DWORD               m_dwAudioReadPtr;
    DWORD               m_dwAudioWritePtr;
    DWORD               m_dwAudioReadTotal;
    DWORD               m_dwAudioWriteTotal;

    DWORD               m_dwAudioDelta;

};


//------------------------------------------------------------------------------
//	File IO event handler
//------------------------------------------------------------------------------
struct FileIOHandle
    {
    DWORD buffSize;
    char *buffer;
    };
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\netstrm\netstream.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 2001 Microsoft Corporation.  All Rights Reserved.
 *
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *  11/1/2000   georgioc created
 *  2/25/2001   georgioc added p2p voice xmos
 *
 ***************************************************************************/

#include "netstream.h"

#include <stdlib.h>
#include <stdio.h>

ULONG g_NetStrmDebugLevel = 2;

VOID
InsertContext(
    PGRAPH_CONTEXT pContext,
    PMEDIA_BUFFER_CTX pCtx,
    XMediaObject *pXmo,
    BOOL fSource
    );


NETSTREAM_GLOBAL_DATA g_Data;

VOID __cdecl main()
{
    WSADATA wsadata;
    INT err;

    memset(&g_Data,0,sizeof(NETSTREAM_GLOBAL_DATA));

    g_Data.dwFlags = 0;

    DBG_INFO(("**** NetStream Test started...Global data at %x\n",&g_Data));    
    DBG_INFO(("**** To receive net data ed %x %x\n",
             &g_Data,     
             TESTF_NET_RECV));

    DBG_INFO(("**** To send net data ed %x %x\n",
             &g_Data,     
             TESTF_NET_SEND));

    g_Data.dwFlags = TESTF_NET_SEND | TESTF_USE_CODEC;

    BREAK_INTO_DEBUGGER;

    //
    //  Initialize core peripheral port support
    //

    XInitDevices(0,NULL);
    
    //
    // load network stack
    //

    DBG_INFO(("NetStream: Loading XBox network stack...\n"));
    err = XnetInitialize(NULL, TRUE);
    if (err != NO_ERROR) {
        DBG_ERROR(("NetStream: XnetInitialize failed with %x",
                  err));
        return;
    }

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        DBG_ERROR(("NetStream: WSAStartup failed with %x",
                  err));
        return;
    }

    g_Data.ContextArray[NET_RECV_CONTEXT].dwFlags = g_Data.dwFlags;
    g_Data.ContextArray[NET_SEND_CONTEXT].dwFlags = g_Data.dwFlags;

    //
    // initialize full duplex filter graph and net stack.
    // define flags here  to determine test configuration
    // first initialize the local capture graph, then the target graph
    //
    
    if (g_Data.dwFlags & TESTF_NET_RECV) {

        err = Init(NET_RECV_CONTEXT);    
        if (FAILED(err)) {
            DBG_ERROR(("Init of net receive context failed, resorting to half duplex\n"));
            g_Data.dwFlags &= ~TESTF_NET_RECV;
        }
    
    }

    if (g_Data.dwFlags & TESTF_NET_SEND) {

        err = Init(NET_SEND_CONTEXT);    
        if (FAILED(err)) {
            DBG_ERROR(("Init of net send context failed, resorting to half duplex\n"));
            g_Data.dwFlags &= ~TESTF_NET_SEND;
        }

    }

    //
    // instruct routine to poll each filter graph (0 for timeout means dont block)
    //

    while (TRUE) {

        if (g_Data.dwFlags & TESTF_NET_RECV) {
            TransferData(NET_RECV_CONTEXT, 0);
        } 
        
        if (g_Data.dwFlags & TESTF_NET_SEND) {
            TransferData(NET_SEND_CONTEXT, 0);
        }        

        if (g_Data.dwFlags == 0) { 
        
            break;
        }
    }    

    Cleanup();
    DBG_INFO(("*** Test stopped, type .reboot now\n"));
    BREAK_INTO_DEBUGGER
   
    Sleep(INFINITE);

    return;

}

//
// Init: Creates a streaming graph between 3 XMOs
// A source, a in-between (codec in this case) and a target
// Depending on whcih net mode we are in, the source and target change
// In Client Mode:
//      Source must be the NetXmo in client mode
//      IntermediaXmo can be NULL
//      Target XMO must be an Audio device (hawk or mcpx)
// In Server Mode:
//      SourceXmo can be NULL
//      pWaveFile can be NULL if sourceXmo != NULL and vice versa
//      pIntermediateXmo can be NULL
//      pTargetXmo must be the NetXmo initialized in server mode
// We only support one target and one source, but you could actually
// have multiple sources and targets that manipulate the same stream
// all you have to do is call multiple XMos, one after the other
// using the same XMediaBuffer (in sync mode) or multiple copies (async)
// In case there is no hawk microphone device, we will read data from a file
// and stream that over the net.
// If there is no hawk output device and we are in client mode, we will output 
// to the MCPX
//

HRESULT
Init(DWORD dwIndex)
{
    PGRAPH_CONTEXT pContext = &g_Data.ContextArray[dwIndex];
    DWORD dwInsertions;
    PCHAR pszAddress;
    CHAR localAddressBuffer[256];
    struct in_addr localAddress;
    DWORD dwMinSize, dwDeviceId;
    DWORD err = S_OK;
    DWORD count = 0;
    DWORD i;

    PWAVEFORMATEX           format = &pContext->wfxAudioFormat;

    PMEDIA_BUFFER_CTX       pCtx;
    XMEDIAINFO              xMediaInfo;

    union {

        WAVEFORMATEX wfx;
#ifdef SILVER
        IMAADPCMWAVEFORMAT wfxAdpcm;
#else // SILVER
		XBOXADPCMWAVEFORMAT wfxAdpcm;
#endif // SILVER
        VOICECODECWAVEFORMAT wfxVox;
    };

#ifdef SILVER
    ZeroMemory( &wfxAdpcm, sizeof( IMAADPCMWAVEFORMAT ) );
#else // SILVER
	ZeroMemory( &wfxAdpcm, sizeof( XBOXADPCMWAVEFORMAT ) );
#endif // SILVER

    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    pContext->dwPacketSize = PACKET_SIZE;
    pContext->dwMaxBufferCount = PACKET_CNT;

    //
    // init the audio format..
    //

    format->wFormatTag          = WAVE_FORMAT_PCM;
    format->nSamplesPerSec      = 8000;
    format->nChannels           = 1;
    format->wBitsPerSample      = (WORD) 16;
    format->nBlockAlign         = (16 * format->nChannels / 8);
    format->nAvgBytesPerSec     = format->nSamplesPerSec * format->nBlockAlign;
    format->cbSize              = 0;

    //
    // figure out which machine we are running on...
    //

    do {

        XnetGetIpAddress(&localAddress);
        pszAddress = inet_ntoa(localAddress);
        memcpy(localAddressBuffer,pszAddress,sizeof(localAddressBuffer));

        i = RtlCompareMemory(localAddressBuffer,LOOPADDRESS,sizeof(LOOPADDRESS));
        if (i!=sizeof(LOOPADDRESS)) {
            DBG_ERROR(("**** NetStream: Local address is %s ****\n", localAddressBuffer));
            break;
        }

    } while (TRUE);

    pContext->dwPlayerPort = INVALID_PORT;

    //
    // Wait up to 2 secs to find hawk
    //

    while (count++ < 2) {

        DBG_INFO(("Netstream: Sleeping for 1 sec , waiting for hawk\n"));

        dwInsertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
        if(dwInsertions)
        {
        
            DBG_INFO(("Netstream: Insertions 0x%08x\n", dwInsertions));

            for(i=0; i < 32; i++)
            {
                //
                //  Handle Insertions
                //
                if(dwInsertions&(1 << i))
                {
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                    } else
                    {
                        dwPort = i-16;
                    }

                    DBG_INFO(("Netstream: Hawk in port %d\n", dwPort));
                    pContext->dwPlayerPort = dwPort;
                    count = 0x100;
                    break;

                }
                
                
            } // for loop
        } // if

        Sleep(1000);

    } // while

    dwMinSize = RtlCompareMemory(inet_ntoa(localAddress),TESTADDR_RIGHT,sizeof(TESTADDR_RIGHT));

    //
    // initialize the source XMO
    //  

    if (dwIndex == NET_RECV_CONTEXT) {
        
        //
        // Instantiate Net xmo
        // Figure which machine we a running so we connect to the OTHER machine
        // Pass the max packet size, not the real packet size after encoding
        // in case we want to send raw data
        //
                
        err = XnetCreateMediaObject(
            &pContext->pSourceXmo,
            INVALID_SOCKET,
            (dwMinSize == sizeof(TESTADDR_RIGHT) ? TESTADDR_LEFT : TESTADDR_RIGHT),
            TESTPORT,
            PACKET_SIZE,
            0);

        
        if (FAILED(err)) {          
            DBG_ERROR(("NetStream: XcreateNetMediaObject failed with %x",
                      err));

            goto exitError;         
        }
        
    }
    
    if (dwIndex == NET_SEND_CONTEXT) {
                        
        err = XVoiceCreateMediaObject(
            XDEVICE_TYPE_VOICE_MICROPHONE,
            pContext->dwPlayerPort,
            PACKET_CNT,
            format,
            &pContext->pSourceXmo);
        
        if (FAILED(err)) {          
            DBG_ERROR(("NetStream: XcreateHawkMediaObject failed with %x",
                      err));

            err = E_FAIL;
            goto exitError;

        }
        
    }

    //
    // now create a codec or in-between XMO
    //

    if (pContext->dwFlags & TESTF_USE_CODEC) {

        DWORD dwFlags;

        //
        // if we are testing a net client, it means we
        // are receiving compressed data from the server
        // If we are in erver mode, we are sending data so we need
        // to encode it first (thus create an encoder)
        // assumption is that the other side encoded with the same codec it was
        // specified for this side..
        //

        dwFlags = ( dwIndex == NET_SEND_CONTEXT ) ? 1 : 0;     

        if ( dwFlags )
        {
            DBG_INFO(("creating voice encoder\n"));

            err = XVoiceEncoderCreateMediaObject(
                FALSE, // manual mode
                WAVE_FORMAT_VOXWARE_SC06,
                format,
                20, // voice activation threshold
                &pContext->pIntermediateXmo
                );

        }
        else
        {

            DBG_INFO(("creating voice decoder\n"));

            err = XVoiceDecoderCreateMediaObject(
                0, // zero latency
                WAVE_FORMAT_VOXWARE_SC06,
                format,
                &pContext->pIntermediateXmo
                );

        }

        if (FAILED(err)) {          

            DBG_ERROR(("NetStream: voice codec failed with %x",
                      err));
            goto exitError;         
        }

        //
        // if the codec XMO is in place dont pass a DST temp buffer...
        //

        pContext->pIntermediateXmo->GetInfo( &xMediaInfo );

        if (xMediaInfo.dwFlags & XMO_STREAMF_IN_PLACE) {

            DBG_INFO(("TransferData: Inbetween xmo %x is in place\n",
                     pContext->pIntermediateXmo));

        } else {
                                               
            memset(&pContext->DstMediaBuffer,
                   0,
                   sizeof(XMEDIAPACKET));

            pContext->DstMediaBuffer.dwMaxSize = PACKET_SIZE;
            pContext->DstMediaBuffer.pvBuffer = new BYTE[PACKET_SIZE];

            ASSERT(pContext->DstMediaBuffer.pvBuffer);

            DBG_INFO(("TransferData: Inbetween xmo %x is not in place, using temp buffer\n",
                     pContext->pIntermediateXmo));

        }

    }

    //
    // init the target XMOs
    //

    if (dwIndex == NET_SEND_CONTEXT) {
        
        //
        // the recv context already has a net XMO instantiated, use it
        // the net xmo can be used for both send and receive at the same time
        //

        pContext->pTargetXmo = g_Data.ContextArray[NET_RECV_CONTEXT].pSourceXmo;
        if (!pContext->pTargetXmo) {

            //
            // half duplex mode
            //

            err = XnetCreateMediaObject(
                &pContext->pTargetXmo,
                INVALID_SOCKET,
                (dwMinSize == sizeof(TESTADDR_RIGHT) ? TESTADDR_LEFT : TESTADDR_RIGHT),
                TESTPORT,
                PACKET_SIZE,
                0);
    
            
            if (FAILED(err)) {          
                DBG_ERROR(("NetStream: XnetCreateMediaobject failed with %x",
                          err));
                goto exitError;         
            }


        }
        
    } else {
#ifdef SILVER
        dwDeviceId = DSDEVID_VOICE(pContext->dwPlayerPort);
#else // SILVER
		dwDeviceId = 0;
#endif // SILVER

        //
        // net recv, we are receiving data and sending to an
        // audio device. default is mcpx
        //

        if (pContext->dwPlayerPort != INVALID_PORT) {
            
            //
            // for now just open hawk direct..
            //

            err = XVoiceCreateMediaObject(
                XDEVICE_TYPE_VOICE_HEADPHONE,
                pContext->dwPlayerPort,
                PACKET_CNT,
                format,
                &pContext->pTargetXmo);
            
            if (err) {
                DBG_ERROR(("NetStream: XVoiceCreateMediaobject failed with %x\n",
                          err));
            }
            

        } else {

            //
            // default to MCPX
            //

            err = E_FAIL;

        }

        if (FAILED(err)) {          
            
            //
            // if we tried to open the hawk output and it failed
            // try the mcpx
            //

#ifdef SILVER
            if (dwDeviceId != DSDEVID_MCPX) {
#else // SILVER
			if ( dwDeviceId != 0 ) {
#endif // SILVER

                DSSTREAMDESC dsDesc;

                memset(&dsDesc,0,sizeof(dsDesc));
#ifdef SILVER
                dsDesc.dwSize = sizeof(dsDesc);
#endif // SILVER
                dsDesc.dwFlags = 0;
                dsDesc.dwMaxAttachedPackets = PACKET_CNT;
                dsDesc.lpwfxFormat = format;
#ifdef SILVER
                dwDeviceId = DSDEVID_MCPX;
#else // SILVER
				dwDeviceId = 0;
#endif // SILVER

#ifdef SILVER
                err = DirectSoundCreateStream(
                    dwDeviceId,
                    &dsDesc,
                    (LPDIRECTSOUNDSTREAM *)&pContext->pTargetXmo,
                    NULL);
#else // SILVER
				err = DirectSoundCreateStream( &dsDesc, (LPDIRECTSOUNDSTREAM *)&pContext->pTargetXmo );
#endif // SILVER

                if (FAILED(err)) {          
                    DBG_ERROR(("NetStream: DirectSoundCreateXMOStream failed with %x",
                              err));

                    DBG_ERROR(("Init: Could not open a target audio XMO\n"));
                    goto exitError;
                }

            } else {

                DBG_WARN(("Init: Could not open a target audio XMO\n"));
                pContext->pTargetXmo = NULL;

            }

        }

    }

#if DBG

    //
    // at this point we should have all the XMOs
    // figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned
    // As a last check we make sure its also larger than the maxLookahead
    //

    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if ( pContext->pSourceXmo )
    {
        err = pContext->pSourceXmo->GetInfo( &xMediaInfo );
        ASSERT( err == NOERROR );
        pContext->dwMinPacketSize = xMediaInfo.dwOutputSize;

        NETSTRM_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);

    }

    if ( pContext->pIntermediateXmo )
    {
        err = pContext->pIntermediateXmo->GetInfo( &xMediaInfo );
        ASSERT( err == NOERROR );
        pContext->dwMinPacketSize = max( xMediaInfo.dwInputSize, pContext->dwMinPacketSize );

        //NETSTRM_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);
    }

    if ( pContext->pTargetXmo )
    {
        err = pContext->pTargetXmo->GetInfo( &xMediaInfo );
        ASSERT( err == NOERROR );
        pContext->dwMinPacketSize = max( xMediaInfo.dwOutputSize, pContext->dwMinPacketSize );

        NETSTRM_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);
    }

#endif

    pContext->dwPacketSize = PACKET_SIZE;

    ASSERT(pContext->pTargetXmo);
    ASSERT(pContext->pSourceXmo);

    InitializeListHead(&pContext->SrcPendingList);
    InitializeListHead(&pContext->DstPendingList);

    //
    // allocate one large buffer for incoming/outgoing data
    //

    dwMinSize = MAXBUFSIZE;
    pContext->TransferBuffer = new BYTE[dwMinSize];
    ASSERT(pContext->TransferBuffer);

    memset(pContext->TransferBuffer,0,dwMinSize);

    //
    // allocate a context pool
    //

    dwMinSize = (PACKET_CNT*sizeof(MEDIA_BUFFER_CTX))+10;
    pContext->PacketContextPool = new BYTE[dwMinSize];
    ASSERT(pContext->PacketContextPool);

    memset(pContext->PacketContextPool,8,dwMinSize);

    //
    // we attach all available buffers in the beginning to prime the graph:
    // as each buffer is completed by the source, the event is signalled and
    // we pass the media buffer to the next XMO
    //

    for (i=0; i<PACKET_CNT;i++) {

        pCtx = (PMEDIA_BUFFER_CTX) (pContext->PacketContextPool+sizeof(MEDIA_BUFFER_CTX)*i);

        memset(pCtx,0,sizeof(MEDIA_BUFFER_CTX));

        pCtx->dwCompletedSize = PACKET_SIZE;
        pCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        pCtx->hCompletionEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
        pCtx->pBuffer = &pContext->TransferBuffer[i*PACKET_SIZE];

        ASSERT(pCtx->hCompletionEvent);

        InsertContext(pContext,
                      pCtx,
                      pContext->pSourceXmo,
                      TRUE);

    }

    return S_OK;

exitError:

    return err;

}

VOID
Cleanup()
{
    PGRAPH_CONTEXT pContext;
    ULONG i=0;
    DBG_INFO(("Test cleanup. Deleting media objects.\n"));

    for (i=0;i<2;i++) {
        pContext = &g_Data.ContextArray[i];

        //
        // delete any xmos...
        //
    
        if (pContext->pSourceXmo) {
            pContext->pSourceXmo->Release();
        }
    
        if (pContext->pIntermediateXmo) {
            pContext->pIntermediateXmo->Release();
        }
    
        if (pContext->pTargetXmo) {
            pContext->pTargetXmo->Release();
        }


    }


    DBG_ERROR(("Unloading XBox network stack...\n"));
    WSACleanup();

    XnetCleanup();

}



HRESULT
TransferData(
    DWORD dwIndex,
    DWORD dwTimeout
    )
{
    PGRAPH_CONTEXT pContext = &g_Data.ContextArray[dwIndex];
    HRESULT hr=S_OK;
    DWORD index = 0;
    XMEDIAPACKET xmb;
    DWORD dwSize;    
    PMEDIA_BUFFER_CTX pSrcCtx, pDstCtx;
    HANDLE hArray[2];

    //
    // setup media buffer
    //

    memset(&xmb,0,sizeof(xmb));

    dwSize = 0;
    pSrcCtx = NULL;
    pDstCtx = NULL;

    //
    // Wait for the oldest buffers submitted to the source and target xmo
    // oldest buffers are at the head, since we insert at the tail, remove from head
    //

    if (!IsListEmpty(&pContext->SrcPendingList)) {

        pSrcCtx = (PMEDIA_BUFFER_CTX) pContext->SrcPendingList.Flink; // head
        hArray[0] = pSrcCtx->hCompletionEvent;
        dwSize = 1;

    }

    if (!IsListEmpty(&pContext->DstPendingList)) {

        pDstCtx = (PMEDIA_BUFFER_CTX) pContext->DstPendingList.Flink; //head
        hArray[dwSize] = pDstCtx->hCompletionEvent;
        dwSize++;

    }        

    if (dwSize) {

        index = WaitForMultipleObjects(dwSize,
                                       hArray,
                                       FALSE,
                                       dwTimeout);

    }

    if (pSrcCtx && 
        (pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING)) {

        //
        // a src buffer completed.
        // Remove this context from the Src pending list.
        // Send it to a codec, if present, then send it to the Target xmo
        //

        RemoveEntryList(&pSrcCtx->ListEntry);

        //
        // Before we pass it on, set xmb to amount of data we received
        //

        xmb.pvBuffer = pSrcCtx->pBuffer;            
        xmb.dwMaxSize = pSrcCtx->dwCompletedSize;        
        xmb.hCompletionEvent = pSrcCtx->hCompletionEvent;

        DBG_SPAM(("Context %x received %x bytes, xmb %x\n",pSrcCtx, xmb.dwMaxSize, &xmb));
        ASSERT(xmb.dwMaxSize);

        pSrcCtx->dwCompletedSize = 0;
        pSrcCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;

        if (pContext->pIntermediateXmo) {

            if (pContext->DstMediaBuffer.pvBuffer) {

                //
                // for debug reasons, find out output byte count
                // NOTE: its ok to pass a pointer to a stack variable since
                // middle XMO is sync!!! Never do this with async XMOs!!!
                //

                pContext->DstMediaBuffer.pdwCompletedSize = &dwSize;
                dwSize = 0;

                hr = pContext->pIntermediateXmo->Process(
                    &xmb,
                    &pContext->DstMediaBuffer);


                ASSERT(dwSize <=PACKET_SIZE);

                memcpy(xmb.pvBuffer,
                       pContext->DstMediaBuffer.pvBuffer,
                       dwSize);

                DBG_SPAM(("Conversion produced %x bytes\n",dwSize));

            } else {

                //
                // middle xmo is IN_PLACE
                //

                hr = pContext->pIntermediateXmo->Process(
                    NULL,
                    &xmb);

            }

            pSrcCtx->dwCompletedSize = dwSize;
            ASSERT(!NETSTRM_FAILED(hr));

        } else { // if intermediate xmo

            pSrcCtx->dwCompletedSize = PACKET_SIZE;

        }

        //
        // if the voice decoder returned 0 bytes it means
        // that the received packet was silence..
        // We have two choices:
        // 1) pass to the target xmo a packet initialized with silence(using some
        // single preallocated silence buffer)
        // 2) dont pass anything to the target xmo and just requeue the completed context
        // to the source list.
        // If we choose 1), we are keeping the average stream throughput fairly constant
        // If we choose 2) we use less cpu time since no need for the target to queue up
        // the packet, notify us when its complete etc.
        // Here I chose 2) because its simple. You might want to use 1) to keep your filter
        // graph more deterministic and also allow for some jitter-smoothing
        //

        if (dwSize == 0) {

            pSrcCtx->dwCompletedSize = PACKET_SIZE;

            //
            // re-attach packet to source
            //

            InsertContext(pContext,
                          pSrcCtx,
                          pContext->pSourceXmo,
                          TRUE);


        } else {

            //
            // pass media buffer to the target xmo.
            //

            InsertContext(pContext,
                          pSrcCtx,
                          pContext->pTargetXmo,
                          FALSE);

        }

    }

    //
    // check if destination buffer xmo was also done..
    //

    if (pDstCtx && 
        (pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING)) {        

        DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

        RemoveEntryList(&pDstCtx->ListEntry);        
        ASSERT(pDstCtx->dwCompletedSize != 0);

        //
        // the target XMO is done with a buffer.
        //

        pDstCtx->dwCompletedSize = PACKET_SIZE;
        InsertContext(pContext,
                      pDstCtx,
                      pContext->pSourceXmo,
                      TRUE);


    } 

    return hr;

}

//
// helper functions

VOID
InsertContext(
    PGRAPH_CONTEXT pContext,
    PMEDIA_BUFFER_CTX pCtx,
    XMediaObject *pXmo,
    BOOL fSource
    )
{
    XMEDIAPACKET xmb;
    HRESULT hr;

    memset(&xmb,0,sizeof(xmb));            

    xmb.pvBuffer = pCtx->pBuffer;            
    xmb.dwMaxSize = pCtx->dwCompletedSize;

    pCtx->dwCompletedSize = 0;
    pCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;

    xmb.hCompletionEvent = pCtx->hCompletionEvent;
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;
    xmb.pdwStatus = &pCtx->dwStatus;

    if (fSource) {

        hr = pXmo->Process(
            NULL,
            &xmb);

        InsertTailList(&pContext->SrcPendingList, &pCtx->ListEntry);

    } else {

        hr = pXmo->Process(
            &xmb,
            NULL);

        InsertTailList(&pContext->DstPendingList, &pCtx->ListEntry);

    }

    if (NETSTRM_FAILED(hr)) {

        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\netxmo\netxmo.cpp ===
#include "netxmo.h"
#include "netxmop.h"

ULONG g_NetXmoDebugLevel;

HRESULT
XnetCreateMediaObject(
    XMediaObject **ppMediaObject,
    SOCKET Socket,
    const char * pszAddress,
    DWORD dwPort,
    DWORD dwMaxPacketSize,
    DWORD dwFlags
    )
{   
    HRESULT hr;
    CNetXMO *pNetXmo;

    //
    // create net xmo
    //

    pNetXmo = new CNetXMO();
    ASSERT(pNetXmo);
    if (pNetXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pNetXmo->Initialize(Socket,
                             (PUCHAR)pszAddress,
                             dwPort,
                             dwMaxPacketSize,
                             dwFlags);


    *ppMediaObject = NULL;

    if (SUCCEEDED(hr)) {
        *ppMediaObject = pNetXmo;
        pNetXmo->AddRef();
    }

    return hr;

}

HRESULT CNetXMO::Initialize(
    SOCKET ExternalSocket,
    PUCHAR pszAddress,
    DWORD dwPort,
    DWORD dwMaxPacketSize,
    DWORD dwFlags
    )
{
    SOCKET sock = NULL;
    INT err, size;
    DWORD i;
    PXMB_CONTEXT pCtx;

    if (ExternalSocket == INVALID_SOCKET) {

        //
        // use unreliable but with small latency UDP
        //
    
        sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if (sock == INVALID_SOCKET) {
            CALLFAILED(socket,GetLastError());
            return E_FAIL;
        }
    
        //
        // create the local socket
        //
    
        m_SocketName.sin_family = AF_INET;
        m_SocketName.sin_port = htons((USHORT)dwPort);    
        m_SocketName.sin_addr.s_addr  = INADDR_ANY;
    
        err = bind(sock,
                   (struct sockaddr*)&m_SocketName,
                   sizeof(m_SocketName));

        if (err != NO_ERROR) {
            DbgPrint("Net xmo %x failed bind with err = %x\n",
                     this,
                     err);

            goto exit;
        }
    
        //
        // create a remote address
        //
    
        m_RemoteSocketName.sin_family = AF_INET;
        m_RemoteSocketName.sin_port = htons((USHORT)dwPort);    
        m_RemoteSocketName.sin_addr.s_addr = inet_addr((const char *)pszAddress);
    
        //
        // connect local socket to remote address
        //
    
        err = connect(sock,
                      (struct sockaddr*)&m_RemoteSocketName,
                      sizeof(m_RemoteSocketName));
    
        if (err != NO_ERROR) {
            DbgPrint("Net xmo %x failed connect with err = %x\n",
                     this,
                     err);
            goto exit;
        }
        
        DbgPrint("Net xmo %x connecting to: %u.%u.%u.%u:%d\n",
                 this,
                 m_RemoteSocketName.sin_addr.S_un.S_un_b.s_b1, m_RemoteSocketName.sin_addr.S_un.S_un_b.s_b2, m_RemoteSocketName.sin_addr.S_un.S_un_b.s_b3, m_RemoteSocketName.sin_addr.S_un.S_un_b.s_b4,
                 ntohs(m_RemoteSocketName.sin_port));
        
        size = sizeof(m_SocketName);

        err = getsockname(sock,
                          (struct sockaddr*) &m_SocketName,
                          &size);

        if (err != NO_ERROR) {
            DbgPrint("Net xmo %x failed getsockname with err = %x\n",
                     this,
                     err);

            goto exit;
        }
    
        DbgPrint("Net xmo %x local address: %u.%u.%u.%u:%d\n",
                 this,
                 m_SocketName.sin_addr.S_un.S_un_b.s_b1, m_SocketName.sin_addr.S_un.S_un_b.s_b2, m_SocketName.sin_addr.S_un.S_un_b.s_b3, m_SocketName.sin_addr.S_un.S_un_b.s_b4,
                 ntohs(m_SocketName.sin_port));

        m_Socket = sock;

        err = ioctlsocket(m_Socket,
                          FIONBIO,
                          &m_cRef);

        if (err!=NO_ERROR) {

            DbgPrint("Net xmo %x failed ioctlsocket with err = %x\n",
                     this,
                     err);

            //
            // this is non fatal
            //

        }

    } else {

        DbgPrint("Net xmo %x using supplied socket: %x\n",
                 this,
                 ExternalSocket);

        m_Socket = ExternalSocket;

    }

    InitializeListHead(&m_AvailableList);
    InitializeListHead(&m_PendingList);

    //
    // prime our available list with contexts
    //

    for (i=0;i<MAX_NETXMO_BUFFER_COUNT;i++) {

        pCtx = new XMB_CONTEXT;
        ASSERT(pCtx);
        if (pCtx == NULL) {
            err = E_OUTOFMEMORY;
            goto exit;
        }

        InsertTailList(&m_AvailableList,&pCtx->ListEntry);

    }

    //
    // allocate double buffer for receive and send
    // we only need one because we are sync
    //

    m_pRecvBuffer = (PUCHAR) new BYTE[dwMaxPacketSize+sizeof(NETXMOPACKETHEADER)];

    ASSERT(m_pRecvBuffer);

    if (m_pRecvBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    m_pSendBuffer = (PUCHAR) new BYTE[dwMaxPacketSize+sizeof(NETXMOPACKETHEADER)];
    ASSERT(m_pSendBuffer);

    if (m_pSendBuffer == NULL) {
        return E_OUTOFMEMORY;
    }

    m_dwFlags = dwFlags;

    //
    // initialize synchronization object
    //

    m_hMutex = CreateMutex(NULL,
                FALSE,
                NULL);

    if (m_hMutex == NULL) {

        DbgPrint("Netxmo: Thread creation failed..");
        goto exit;


    }

    //
    // we are initialized ok. Now create a thread that will gives us
    // some context to run and check if the net has completed packets
    //

    m_hThread = CreateThread(NULL,
                             4096,
                             NetXmoThreadProc,
                             this,
                             0,
                             &m_dwThreadId);

    if (m_hThread == NULL) {

        DbgPrint("Netxmo: Thread creation failed..");
        goto exit;

    }

    //
    // create event that will signal thread to terminate
    //

    m_hDeleteThreadEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (m_hDeleteThreadEvent == NULL) {

        DbgPrint("Netxmo: Thread creation failed..");
        goto exit;

    }

    //
    // single event to track the outstanding recv packet request
    //

    m_hRecvPacketEvent = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (m_hRecvPacketEvent == NULL) {

        DbgPrint("Netxmo: Thread creation failed..");
        goto exit;

    }

    return S_OK;

exit:
    if (sock) {
        closesocket(sock);
    }
    
    WSACleanup();

    return E_FAIL;


}


STDMETHODIMP_(ULONG) CNetXMO::Release()
{

   long l = InterlockedDecrement((long*)&m_cRef);

   if (l == 0)
      delete this;
   return l;
}

CNetXMO::~CNetXMO()
{

    PXMB_CONTEXT pCtx;

    //
    // set the delete event
    //

    if (m_hDeleteThreadEvent) {

        SetEvent(m_hDeleteThreadEvent);
 
    }
 
    //
    // wait on thread exiting..
    //

    if (m_hThread) {
        WaitForSingleObject(m_hThread,INFINITE);
    }

    ASSERT(m_dwThreadId == 0);

    //
    // cleanup
    //

    //
    // close the socket. This will cancel all pending requests
    // but it will NOT trigger notifications...
    //

    closesocket(m_Socket);

    //
    // if anything pending, complete it
    //

    if (!IsListEmpty(&m_PendingList)) {
    
        pCtx = (PXMB_CONTEXT) m_PendingList.Flink;

        while ((PLIST_ENTRY)pCtx != &m_PendingList) {

            if (pCtx->Xmb.pdwCompletedSize) {
                *pCtx->Xmb.pdwCompletedSize = 0;
            }
            
            if (pCtx->Xmb.pdwStatus) {
                *pCtx->Xmb.pdwStatus = XMEDIAPACKET_STATUS_FLUSHED;
            }
            
            if (pCtx->Xmb.hCompletionEvent) {
                SetEvent(pCtx->Xmb.hCompletionEvent);
            }

            NX_DBG_ERROR(("NetXMO::ThreadProc: Cleaning up pending context %x\n",pCtx));;

            ReturnContext(pCtx);

            pCtx = (PXMB_CONTEXT) m_PendingList.Flink;

        }

    }

    //
    // free all available list contexts
    //

    if (!IsListEmpty(&m_AvailableList)) {

        pCtx = (PXMB_CONTEXT) m_AvailableList.Flink;

        while ((PLIST_ENTRY)pCtx != &m_AvailableList) {

            RemoveEntryList(&pCtx->ListEntry);
            delete pCtx;
            pCtx = (PXMB_CONTEXT) m_AvailableList.Flink;

             if ((PLIST_ENTRY)pCtx == &m_AvailableList) {
                 break;
             }

        }

    }

    if (m_pRecvBuffer) {
        delete [] m_pRecvBuffer;
    }
    
    if (m_pSendBuffer) {
        delete [] m_pSendBuffer;
    }
    
    if (m_hMutex) {

        CloseHandle(m_hMutex);

    }
 
    if (m_hDeleteThreadEvent) {
        CloseHandle(m_hDeleteThreadEvent);
    }

    if (m_hRecvPacketEvent) {
        CloseHandle(m_hRecvPacketEvent);
    }
    

}


HRESULT STDMETHODCALLTYPE CNetXMO::GetInfo( 
    PXMEDIAINFO pInfo
    )
{
    ASSERT(pInfo);

    pInfo->dwFlags = XMO_STREAMF_INPUT_ASYNC;

    pInfo->dwInputSize = 1;
    pInfo->dwOutputSize = 1;

    return S_OK;

}


HRESULT STDMETHODCALLTYPE CNetXMO::Process( 
    const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
    const XMEDIAPACKET __RPC_FAR *pDstBuffer
    )
{

    DWORD dwSize;
    PNETXMOPACKETHEADER pHeader;
    PXMB_CONTEXT pCtx;
    HRESULT hr = NOERROR;

    if (pSrcBuffer) {

        ASSERT ( pSrcBuffer->dwMaxSize <= MAX_NETXMO_TRANSFER_SIZE);

        //
        // they want to send data..
        //

        pHeader = (PNETXMOPACKETHEADER) m_pSendBuffer;

        memcpy(m_pSendBuffer+sizeof(NETXMOPACKETHEADER),
               pSrcBuffer->pvBuffer,
               pSrcBuffer->dwMaxSize);

        pHeader->bType = NETXMO_PACKET_TYPE_AUDIO;
        pHeader->bSeqNum = m_bSeqNum++;
        pHeader->wSize = (WORD)pSrcBuffer->dwMaxSize;

        dwSize = pSrcBuffer->dwMaxSize + sizeof(NETXMOPACKETHEADER);

        dwSize = send(m_Socket,
             (const char *)pHeader,
             dwSize,
             0);

        if (dwSize == SOCKET_ERROR) {

            hr = E_FAIL;
            CALLFAILED(send,hr);
            goto processRecv;

        } 

        if (pSrcBuffer->pdwCompletedSize) {

            *pSrcBuffer->pdwCompletedSize = SUCCEEDED(hr) ? pSrcBuffer->dwMaxSize : 0;

        }

        if (pSrcBuffer->pdwStatus) {

            *pSrcBuffer->pdwStatus = SUCCEEDED(hr) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;

        }

        if (pSrcBuffer->hCompletionEvent) {

            SetEvent(pSrcBuffer->hCompletionEvent);

        }

    }

processRecv:

    if (pDstBuffer) {

        //
        // receive data..
        //

        ASSERT ( pDstBuffer->dwMaxSize <= MAX_NETXMO_TRANSFER_SIZE);

        //
        // Set initial packet status to pending
        //

        if (pDstBuffer->pdwStatus) {
            *pDstBuffer->pdwStatus = XMEDIAPACKET_STATUS_PENDING;
        }
        
        //
        // grab mutex to sync with thread
        //

        WaitForSingleObject(m_hMutex,INFINITE);

        pCtx = (PXMB_CONTEXT) RemoveTailList(&m_AvailableList);
        ASSERT(pCtx);

        memcpy(&pCtx->Xmb, pDstBuffer,sizeof(XMEDIAPACKET));

        InsertTailList(&m_PendingList,&pCtx->ListEntry);

        ReleaseMutex(m_hMutex);

        return S_OK;

    }

    return S_OK;

}


DWORD WINAPI NetXmoThreadProc(
    LPVOID pParameter
    )
{
    CNetXMO *pThis = (CNetXMO *) pParameter;
    pThis->ThreadProc();

    return 0;
}

VOID CNetXMO::ThreadProc()
{
    HRESULT hr = S_OK;
    HANDLE hArray[2];
    DWORD eventIndex;
    PXMB_CONTEXT pCtx;

    while (m_cRef > 0) {

        //
        // this function should have been called in response to an event being signalled
        // check if we have any pending recv buffers
        //
    
        //
        // grab a mutex
        //

        hArray[0] = m_hDeleteThreadEvent;
        hArray[1] = m_hMutex;

        eventIndex = WaitForMultipleObjects(2,
                                            hArray,
                                            FALSE,
                                            INFINITE);


        if ((eventIndex - WAIT_OBJECT_0) == 0) {

            //
            // thread needs to be deleted, bail...
            //

            NX_DBG_INFO(("ThreadProc: Leaving thread\n"));

            ReleaseMutex(m_hMutex);
            goto exit;

        }

        if (!IsListEmpty(&m_PendingList)) {
    
            pCtx = (PXMB_CONTEXT) m_PendingList.Flink;

            //
            // ask xnet to see if it has data for us
            //

            NX_DBG_INFO(("ThreadProc: Submiting context %x to XNET, overlapped\n",pCtx));
            hr = SubmitRecvRequest(&pCtx->Xmb,pCtx);

            ReleaseMutex(m_hMutex);

            if ((hr == E_PENDING) || (hr == NOERROR)) {

                if ((hr == E_PENDING)) {

                    //
                    // now wait on the deletion and packet event
                    //
    
                    hArray[0] = m_hDeleteThreadEvent;                
                    hArray[1] = m_hRecvPacketEvent;
    
                    eventIndex = WaitForMultipleObjects(2,
                                                        hArray,
                                                        FALSE,
                                                        INFINITE);
    
    
                    if ((eventIndex - WAIT_OBJECT_0) == 0) {
    
                        //
                        // thread needs to be deleted, bail...
                        // 
    
                        NX_DBG_INFO(("ThreadProc: Leaving thread\n"));
    
                        goto exit;
    
                    }

                }

                //
                // set caller parameters, extract header info
                //
                    
                NX_DBG_INFO(("ThreadProc: Handling completed context %x\n",pCtx));
                HandleRecvCompletion(&pCtx->Xmb);
    
                ReturnContext(pCtx);

            } else {

                //
                // error occured
                //

                if (pCtx->Xmb.pdwCompletedSize) {
                    *pCtx->Xmb.pdwCompletedSize = 0;
                }
                
                if (pCtx->Xmb.pdwStatus) {
                    *pCtx->Xmb.pdwStatus = XMEDIAPACKET_STATUS_FAILURE;
                }
                
                if (pCtx->Xmb.hCompletionEvent) {
                    SetEvent(pCtx->Xmb.hCompletionEvent);
                }

                NX_DBG_ERROR(("NetXMO::Process: SubmitRecvRequest failed with %x\n",hr));;

                //
                // return context to available list
                //
    
                ReturnContext(pCtx);

            }

        } else { // if listempty

            ReleaseMutex(m_hMutex);

        }

    }

exit:

    m_dwThreadId = 0;
    ExitThread(0);

}

HRESULT STDMETHODCALLTYPE CNetXMO::GetStatus( 
        /* [out] */ DWORD __RPC_FAR *pdwFlags
        )
{

    //
    // let the caller know if we can accept any more data
    //

    *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;

    if(!IsListEmpty(&m_AvailableList))
    {
        *pdwFlags |= XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    }

    return S_OK;

}

HRESULT
CNetXMO::ReturnContext(
    PXMB_CONTEXT pCtx
    )
{

    HANDLE hArray[2];
    DWORD eventIndex;

    //
    // grab a mutex (assume the thread does not own it already)
    //

    hArray[0] = m_hDeleteThreadEvent;
    hArray[1] = m_hMutex;

    eventIndex = WaitForMultipleObjects(2,
                                        hArray,
                                        FALSE,
                                        INFINITE);

    if ((eventIndex - WAIT_OBJECT_0) == 0) {

        //
        // thread needs to be deleted, bail...
        //

        NX_DBG_INFO(("ThreadProc: We have been deleted, Leaving thread\n"));

        ReleaseMutex(m_hMutex);
        return E_FAIL;

    }

    //
    // return context to available list
    //

    RemoveEntryList(&pCtx->ListEntry);
    InsertTailList(&m_AvailableList,&pCtx->ListEntry);

    ReleaseMutex(m_hMutex);
    return NOERROR;

}

HRESULT
CNetXMO::SubmitRecvRequest(
    const XMEDIAPACKET *pDstBuffer,
    PXMB_CONTEXT pCtx
    )

{
    INT err;
    HRESULT hr;
    WSABUF wsaBuf;
    
    DWORD dwFlags = 0, dwSize;

    dwSize = pDstBuffer->dwMaxSize + sizeof(NETXMOPACKETHEADER);

    wsaBuf.len = dwSize;
    wsaBuf.buf = (PCHAR) m_pRecvBuffer;

    //
    // NULL the header
    //

    *((PULONG)m_pRecvBuffer) = 0;

    m_overlapped.hEvent = m_hRecvPacketEvent;

    err = WSARecv(m_Socket,
            &wsaBuf,
            1,
            &dwSize,
            &dwFlags,
            &m_overlapped,
            NULL);

    if (err) {
        err = WSAGetLastError();
    }

    NX_DBG_SPAM(("SubmitRecvRequest: WSARecv status %x\n",err));

    //
    // convert to COM error
    //
    
    if (err == WSA_IO_PENDING) {
        hr = E_PENDING;
    } else if (err) {
        hr = E_FAIL;
    } else {
        // no error
        hr = S_OK;
    }

    NX_DBG_SPAM(("SubmitRecvRequest: WSARecv COM status %x\n",hr));

    return hr;
}

VOID
CNetXMO::HandleRecvCompletion(
    const XMEDIAPACKET *pDstBuffer
    )
{

    PNETXMOPACKETHEADER pHeader;
    DWORD dwSize;

    //
    // event if there was one
    // has been signalled by XNET.
    // Extract our header, set XMB fields
    //

    pHeader = (PNETXMOPACKETHEADER) m_pRecvBuffer;

    ASSERT(pDstBuffer->dwMaxSize >= pHeader->wSize);
    dwSize = min(pDstBuffer->dwMaxSize, pHeader->wSize);

    memcpy((PUCHAR)pDstBuffer->pvBuffer,
           m_pRecvBuffer+sizeof(NETXMOPACKETHEADER),
           dwSize);

    if(pHeader->bSeqNum != m_bSeqNum) {

        NX_DBG_SPAM(("Out of sequence packet. Seq %d, expected %d\n",
                 pHeader->bSeqNum,
                 m_bSeqNum));

        m_bSeqNum = pHeader->bSeqNum;

        //
        // in here, you could possibly implement re-ordering
        //

    }

    m_bSeqNum++;

    if (pDstBuffer->pdwCompletedSize) {

        *pDstBuffer->pdwCompletedSize = dwSize;

    }
    
    if (pDstBuffer->pdwStatus) {

        *pDstBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;

    }

    if (pDstBuffer->hCompletionEvent) {

        SetEvent(pDstBuffer->hCompletionEvent);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\netxmo\netxmo.h ===
#ifndef __NETXMO_H__
#define __NETXMO_H__

#include <xtl.h>

HRESULT
XnetCreateMediaObject(
    XMediaObject **ppMediaObject,
    SOCKET Socket,
    const char * pAddress,
    DWORD dwPort,
    DWORD dwMaxPacketSize,
    DWORD dwFlags
    );

#define MAX_NETXMO_TRANSFER_SIZE 1500
#define MAX_NETXMO_BUFFER_COUNT 20

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\netxmo\netxmop.h ===
#define _NTDRIVER_

#include <xtl.h>
#include <winsockx.h>
#include <xdbg.h>

#if DBG

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_NetXmoDebugLevel;
#define NX_DBG_SPAM(_exp_) {if (g_NetXmoDebugLevel >= DEBUG_LEVEL_SPAM) DbgPrint _exp_;}
#define NX_DBG_INFO(_exp) {if (g_NetXmoDebugLevel >= DEBUG_LEVEL_INFO) DbgPrint _exp;}
#define NX_DBG_ERROR(_exp) {if (g_NetXmoDebugLevel >= DEBUG_LEVEL_ERROR) DbgPrint _exp;}
#define NX_DBG_WARN(_exp) {if (g_NetXmoDebugLevel >= DEBUG_LEVEL_WARNING) DbgPrint _exp;}

#define NETXMO_FAILED(Status) ((HRESULT)(Status)<0 && ((HRESULT)(Status)!=E_PENDING))

#else

#define NX_DBG_SPAM(_exp_)
#define NX_DBG_INFO(_exp_)
#define NX_DBG_ERROR(_exp_)
#define NX_DBG_WARN(_exp_)

#endif


#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#undef  BREAK_INTO_DEBUGGER
#define BREAK_INTO_DEBUGGER __asm int 3
#define CALLFAILED(_apiname, err) \
        DbgPrint(#_apiname " failed: %d %d\n", err)

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

#define NETXMO_PACKET_TYPE_AUDIO    0x01

typedef struct _netXMOPacketHeader {

    BYTE bType;
    BYTE bSeqNum;
    WORD wSize;

} NETXMOPACKETHEADER, *PNETXMOPACKETHEADER;


typedef struct _netxmbcontext {

    LIST_ENTRY ListEntry;
    XMEDIAPACKET Xmb;

} XMB_CONTEXT, *PXMB_CONTEXT;


class CNetXMO:public XMediaObject {

public:
    CNetXMO()
    {
        m_cRef = 0;
        m_pRecvBuffer = NULL;
        m_pSendBuffer = NULL;
        m_bSeqNum  = 0;
        m_hThread = NULL;
        m_hDeleteThreadEvent = NULL;
        m_hRecvPacketEvent = NULL;
        m_hMutex = NULL;
        m_dwThreadId = 0;
        m_dwFlags = 0;
        m_Socket = NULL;
        memset(&m_SocketName,0,sizeof(m_SocketName));
        memset(&m_RemoteSocketName,0,sizeof(m_RemoteSocketName));
        InitializeListHead(&m_AvailableList);
        InitializeListHead(&m_PendingList);
        memset(&m_overlapped,0,sizeof(m_overlapped));
    }

    ~CNetXMO();

    HRESULT Initialize(
        SOCKET Socket,
        PUCHAR pszAddress,
        DWORD dwPort,
        DWORD dwMaxPacketSize,
        DWORD dwFlags);

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release(); 

    HRESULT STDMETHODCALLTYPE GetInfo( 
        PXMEDIAINFO pInfo
        );
    
    HRESULT STDMETHODCALLTYPE Process( 
        const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
        const XMEDIAPACKET __RPC_FAR *pDstBuffer
        );
    
    HRESULT STDMETHODCALLTYPE Flush()
    {

        //
        // we could flush all pending receive packets here
        // but it involves closing the socket and reopening
        // which isoverhead and creates race conditions
        // Netstream.xbe does not use flush so this was not implemented
        //

        m_bSeqNum = 0;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Discontinuity(void)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetStatus( 
        DWORD *dwFlags
        );
    
private:

    friend DWORD WINAPI NetXmoThreadProc(
      LPVOID lpParameter   // thread data
    );

    VOID ThreadProc();

    HRESULT
    SubmitRecvRequest(
        const XMEDIAPACKET *pDstBuffer,
        PXMB_CONTEXT pCtx
        );

    VOID
    HandleRecvCompletion(
        const XMEDIAPACKET *pDstBuffer
        );



    HRESULT
    ReturnContext(
        PXMB_CONTEXT pCtx
        );

protected:

    HANDLE m_hThread;
    HANDLE m_hDeleteThreadEvent;
    HANDLE m_hRecvPacketEvent;
    DWORD m_dwThreadId;

    HANDLE m_hMutex;

    ULONG m_cRef;
    DWORD m_dwFlags;

    SOCKET m_Socket;
    struct sockaddr_in m_SocketName;
    struct sockaddr_in m_RemoteSocketName;

    LIST_ENTRY m_AvailableList;
    LIST_ENTRY m_PendingList;

    PUCHAR m_pRecvBuffer;
    PUCHAR m_pSendBuffer;

    WSAOVERLAPPED m_overlapped;
    UCHAR m_bSeqNum;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\srcxmo\srcxmo.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SRCXMO.h
 *  Content:    Sample rate converter interface
 *
 ****************************************************************************/
#pragma once

#include <xtl.h>

typedef short *LPSHORT;

//
// Sample-rate converter XMO
//

class CSrcMediaObject
    : public XMediaObject
{
protected:
    const DWORD             m_dwChannelCount;           // Channel count
    const DWORD             m_dwSourceFrequency;        // Source sampling rate
    const DWORD             m_dwDestinationFrequency;   // Destination sampling rate
    DWORD                   m_dwSourceAlignment;        // Source sample alignment
    DWORD                   m_dwDestinationAlignment;   // Source sample alignment
    DWORD                   m_dwSrcIndex;               // SRC index
    ULONG                   m_ulRefCount;               // Object reference count

public:
    CSrcMediaObject(DWORD dwChannelCount, DWORD dwSourceFrequency, DWORD dwDestinationFrequency);

public:
    // IUnknown methods
    virtual ULONG STDMETHODCALLTYPE AddRef(void);
    virtual ULONG STDMETHODCALLTYPE Release(void);

    // XMediaObject methods
    virtual HRESULT STDMETHODCALLTYPE GetInfo(LPXMEDIAINFO pInfo);
    virtual HRESULT STDMETHODCALLTYPE GetStatus(LPDWORD pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE Process(LPCXMEDIAPACKET pInputPacket, LPCXMEDIAPACKET pOutputPacket);
    virtual HRESULT STDMETHODCALLTYPE Discontinuity(void);
    virtual HRESULT STDMETHODCALLTYPE Flush(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\samprate\samprate.h ===
#pragma once

static const ULONG MIN_INPUT = 2;

HRESULT XSrcCreateMediaObject( XMediaObject **ppMediaObject, PWAVEFORMATEX pWaveFormat );

class CSrcXMO : public XMediaObject {

public:

	CSrcXMO( void )
	{
		m_cRef = 0;
	}

	~CSrcXMO( void )
	{
		delete m_pWaveFormat;
	}


    STDMETHODIMP_(ULONG) AddRef( void ) 
	{
       return InterlockedIncrement( (long*) &m_cRef );
    }

    STDMETHODIMP_(ULONG) Release( void ) 
	{
       long l = InterlockedDecrement( (long*) &m_cRef );

       if ( l == 0 )
          delete this;

       return l;
    }
    
    HRESULT STDMETHODCALLTYPE Flush( void )
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Discontinuity( void )
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetStatus( LPDWORD pdwStatus )
    {
        if ( pdwStatus ) 
		{
            *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        }

        return S_OK;
    }

    HRESULT Initialize( PWAVEFORMATEX pWaveFormat );

	HRESULT STDMETHODCALLTYPE GetInfo( LPXMEDIAINFO pXMediaInfo );
    HRESULT STDMETHODCALLTYPE Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer );

protected:

	BOOL IsValidPcmFormat( LPCWAVEFORMATEX pwfx );

protected:

    ULONG m_cRef;
	PWAVEFORMATEX m_pWaveFormat;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\samprate\samprate.cpp ===
#include <xtl.h>
#include "samprate.h"

HRESULT XSrcCreateMediaObject( XMediaObject **ppMediaObject, PWAVEFORMATEX pWaveFormat )
{
	HRESULT hr;
	CSrcXMO* pXMO = new CSrcXMO();

	if ( NULL == pXMO )
		return E_OUTOFMEMORY;

	hr = pXMO->Initialize( pWaveFormat );

	*ppMediaObject = NULL;

	if ( SUCCEEDED( hr ) )
	{
		*ppMediaObject = pXMO;
		pXMO->AddRef();
	}

	return hr;
}


BOOL CSrcXMO::IsValidPcmFormat( LPCWAVEFORMATEX pwfx )
{
    if ( NULL == pwfx )
        return FALSE;

    if ( WAVE_FORMAT_PCM != pwfx->wFormatTag )
        return FALSE;

    if ( 1 != pwfx->nChannels )
        return FALSE;

    if ( 16 != pwfx->wBitsPerSample )
        return FALSE;

    if ( pwfx->wBitsPerSample * pwfx->nChannels / 8 != pwfx->nBlockAlign )
        return FALSE;

    if( pwfx->nSamplesPerSec * pwfx->nBlockAlign != pwfx->nAvgBytesPerSec )
        return FALSE;

    if ( pwfx->nSamplesPerSec != 8000 && pwfx->nSamplesPerSec != 16000 )
        return FALSE;

    return TRUE;
}

HRESULT CSrcXMO::Initialize( PWAVEFORMATEX pWaveFormat )
{
	if ( ! IsValidPcmFormat( pWaveFormat ) )
		return E_INVALIDARG;

	m_pWaveFormat = new WAVEFORMATEX;

	if ( NULL == m_pWaveFormat )
		return E_OUTOFMEMORY;

	memcpy( m_pWaveFormat, pWaveFormat, sizeof( WAVEFORMATEX ) );

	if ( 8000 == pWaveFormat->nSamplesPerSec )
	{
		pWaveFormat->nSamplesPerSec = 16000;
	}
	else if ( 16000 == pWaveFormat->nSamplesPerSec )
	{
		pWaveFormat->nSamplesPerSec = 8000;
	}

	pWaveFormat->nAvgBytesPerSec = pWaveFormat->nSamplesPerSec * pWaveFormat->nBlockAlign;

	return S_OK;
}
    
HRESULT STDMETHODCALLTYPE CSrcXMO::GetInfo( LPXMEDIAINFO pXMediaInfo )
{
	if ( NULL == pXMediaInfo )
		return E_POINTER;

    pXMediaInfo->dwFlags = XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_SINGLE_SAMPLE_PER_PACKET | XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_FIXED_PACKET_ALIGNMENT | XMO_STREAMF_IN_PLACE;

	if ( 0 == pXMediaInfo->dwInputSize && 0 == pXMediaInfo->dwOutputSize )
	{
		pXMediaInfo->dwInputSize = MIN_INPUT;
		pXMediaInfo->dwOutputSize = MIN_INPUT;
	}

	else if ( 0 == pXMediaInfo->dwInputSize )
	{
		pXMediaInfo->dwOutputSize = pXMediaInfo->dwOutputSize - pXMediaInfo->dwOutputSize % MIN_INPUT;
		pXMediaInfo->dwInputSize = pXMediaInfo->dwOutputSize;
	}

	else if ( 0 == pXMediaInfo->dwOutputSize )
	{
		pXMediaInfo->dwInputSize = pXMediaInfo->dwInputSize + pXMediaInfo->dwInputSize % MIN_INPUT;
		pXMediaInfo->dwOutputSize = pXMediaInfo->dwInputSize;
	}

	return S_OK;
}


HRESULT STDMETHODCALLTYPE CSrcXMO::Process( LPCXMEDIAPACKET pSrcBuffer, LPCXMEDIAPACKET pDstBuffer )
{

	if ( NULL == pDstBuffer || NULL == pSrcBuffer )
		return E_POINTER;

	short*                  pSrc        = (short*)pSrcBuffer->pvBuffer;
    DWORD                   cSrc        = pSrcBuffer->dwMaxSize / 2;
    short*                  pDst        = (short*)pDstBuffer->pvBuffer;
    DWORD                   cDst        = pDstBuffer->dwMaxSize / 2;
	DWORD                   cSamples    = min( cSrc, cDst );
    HRESULT                 hr          = S_OK;

    if( pSrcBuffer->pdwCompletedSize )
    {
        pSrc += *pSrcBuffer->pdwCompletedSize;
        cSrc -= *pSrcBuffer->pdwCompletedSize;
    }

    if( pDstBuffer->pdwCompletedSize )
    {
        pDst += *pDstBuffer->pdwCompletedSize;
        cDst -= *pDstBuffer->pdwCompletedSize;
    }

	if ( 8000 == m_pWaveFormat->nSamplesPerSec )
	{
		while ( cSamples-- )
		{
			pDst[0] = pSrc[0];
			pDst[1] = pSrc[0];
			pSrc++;
			pDst += 2;
		}
	}
	else if ( 16000 == m_pWaveFormat->nSamplesPerSec )
	{
		while ( cSamples-- )
		{
			pDst[0] = pSrc[0];
			pDst++;
			pSrc += 2;
		}
	}

	if( pSrcBuffer->pdwCompletedSize )
    {
        (*pSrcBuffer->pdwCompletedSize) += cSrc;
    }

    if( pDstBuffer->pdwCompletedSize )
    {
        (*pDstBuffer->pdwCompletedSize) += cDst;
    }

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\srcxmo\srcxmo.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       SRCXMO.cpp
 *  Content:    Sample Rate Converter implementation
 *
 ****************************************************************************/

#include "SRCXMO.h"

/****************************************************************************
 *
 *  CSrcMediaObject
 *
 *  Description:
 *      Object constructor.
 *
 *  Arguments:
 *      DWORD [in]: channel count.
 *      DWORD [in]: source sampling rate.
 *      DWORD [in]: destination sampling rate.
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

CSrcMediaObject::CSrcMediaObject
(
    DWORD                   dwChannelCount, 
    DWORD                   dwSourceFrequency, 
    DWORD                   dwDestinationFrequency
)
:   m_dwChannelCount(dwChannelCount),
    m_dwSourceFrequency(dwSourceFrequency),
    m_dwDestinationFrequency(dwDestinationFrequency),
    m_dwSrcIndex(0),
    m_ulRefCount(1)
{
    //
    // Calculate the input and output alignment.  Because we may produce or
    // consume more than one sample at a time (i.e. up- or downsampling), 
    // we need to calculate worst-case alignment.
    //

    if(m_dwSourceFrequency < m_dwDestinationFrequency)
    {
        m_dwSourceAlignment = (m_dwDestinationFrequency + m_dwSourceFrequency - 1) / m_dwSourceFrequency;
        m_dwDestinationAlignment = 1;
    }
    else if(m_dwSourceFrequency > m_dwDestinationFrequency)
    {
        m_dwSourceAlignment = 1;
        m_dwDestinationAlignment = (m_dwSourceFrequency + m_dwDestinationFrequency - 1) / m_dwDestinationFrequency;
    }
    else
    {
        m_dwSourceAlignment = 1;
        m_dwDestinationAlignment = 1;
    }
}


/****************************************************************************
 *
 *  AddRef
 *
 *  Description:
 *      Increments the object's reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: new object reference count.
 *
 ****************************************************************************/

ULONG
CSrcMediaObject::AddRef
(
    void
)
{
    return ++m_ulRefCount;
}


/****************************************************************************
 *
 *  Release
 *
 *  Description:
 *      Decrements the object's reference count.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      ULONG: new object reference count.
 *
 ****************************************************************************/

ULONG
CSrcMediaObject::Release
(
    void
)
{
    if(!--m_ulRefCount)
    {
        delete this;
        return 0;
    }

    return m_ulRefCount;
}


/****************************************************************************
 *
 *  GetInfo
 *
 *  Description:
 *      Gets information about the data the XMO supports.
 *
 *  Arguments:
 *      LPXMEDIAINFO [out]: information data.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CSrcMediaObject::GetInfo
(
    LPXMEDIAINFO            pxmi
)
{
    DWORD                   dwSourceSampleCount;
    DWORD                   dwDestinationSampleCount;
    
    //
    // Flags are easy.  We only support complete samples, but other than
    // that, we don't do much.
    //
    
    pxmi->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE;

    //
    // Our input alignment is the minumum number of samples we require to
    // produce a single output sample.  We store our alignement in terms
    // of samples, but we need to return it in terms of bytes.  We only
    // work with 16-bit data, so converting samples to bytes is as simple
    // as multiplying by the channel count times 2 (16-bit samples == 2 bytes 
    // per sample).
    //

    pxmi->dwInputSize = m_dwSourceAlignment * m_dwChannelCount * 2;

    //
    // Output alignment is maximum number of samples we will every produce
    // when given a single input sample.
    //

    pxmi->dwOutputSize = m_dwDestinationAlignment * m_dwChannelCount * 2;

    //
    // We're a synchronous XMO, so MaxLookahead doesn't apply to us.  
    // Normally, this would be our "low watermark" value; i.e. the minimum
    // amount of data that must be queued at any given time in order to
    // prevent starvation.
    //

    pxmi->dwMaxLookahead = 0;

    return S_OK;
}


/****************************************************************************
 *
 *  GetStatus
 *
 *  Description:
 *      Gets the current status of the XMO.
 *
 *  Arguments:
 *      LPDWORD [out]: status.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CSrcMediaObject::GetStatus
(
    LPDWORD                 pdwStatus
)
{
    //
    // We're a synchronous XMO, so we're always ready for more data.
    //
    
    *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;

    return S_OK;
}


/****************************************************************************
 *
 *  Process
 *
 *  Description:
 *      Processes data.
 *
 *  Arguments:
 *      LPCXMEDIAPACKET [in]: input packet.
 *      LPCXMEDIAPACKET [in]: output packet.
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CSrcMediaObject::Process
(
    LPCXMEDIAPACKET         pxmpSource,
    LPCXMEDIAPACKET         pxmpDestination
)
{
    LPSHORT                 psSourceBuffer;
    LPSHORT                 psDestinationBuffer;
    DWORD                   dwSourceSampleCount;
    DWORD                   dwDestinationSampleCount;
    DWORD                   dwWorkingSourceSampleCount;
    DWORD                   dwWorkingDestinationSampleCount;
    DWORD                   i, j;
    
    //
    // Save pointers to the data buffers
    //

    psSourceBuffer = (LPSHORT)pxmpSource->pvBuffer;
    psDestinationBuffer = (LPSHORT)pxmpDestination->pvBuffer;
    
    //
    // Convert packet sizes from bytes to samples
    //

    dwSourceSampleCount = pxmpSource->dwMaxSize / m_dwChannelCount / 2;
    dwDestinationSampleCount = pxmpDestination->dwMaxSize / m_dwChannelCount / 2;

    //
    // Enter the main loop
    //

    while((dwSourceSampleCount >= m_dwSourceAlignment) && (dwDestinationSampleCount >= m_dwDestinationAlignment))
    {
        //
        // Calculate the number of source samples we'll be using in this
        // iteration.  If we're upsampling, we may produce more than one
        // output sample.  If we're downsampling, we may require more than
        // one input sample.  Because we keep a running SRC index, we'll
        // only produce or consume as many samples as we really need in order
        // to keep the sampling rate accurate.
        //

        dwWorkingSourceSampleCount = 1;
        dwWorkingDestinationSampleCount = 1;

        if(m_dwSourceFrequency < m_dwDestinationFrequency)
        {
            m_dwSrcIndex += m_dwDestinationFrequency;
        
            dwWorkingDestinationSampleCount = m_dwSrcIndex / m_dwSourceFrequency;

            if(dwWorkingDestinationSampleCount > dwDestinationSampleCount)
            {
                dwWorkingDestinationSampleCount = dwDestinationSampleCount;
            }

            m_dwSrcIndex -= dwWorkingDestinationSampleCount * m_dwSourceFrequency;
        }
        else if(m_dwSourceFrequency > m_dwDestinationFrequency)
        {
            m_dwSrcIndex += m_dwSourceFrequency;
        
            dwWorkingSourceSampleCount = m_dwSrcIndex / m_dwDestinationFrequency;

            if(dwWorkingSourceSampleCount > dwSourceSampleCount)
            {
                dwWorkingSourceSampleCount = dwSourceSampleCount;
            }

            m_dwSrcIndex -= dwWorkingSourceSampleCount * m_dwDestinationFrequency;
        }

        //
        // Copy samples.  Because we only consume multiple source samples
        // during a downsample operation, the loop below only references
        // the working destination sample count.  Well, that and the channel
        // count, but you knew that.
        //

        for(i = 0; i < dwWorkingDestinationSampleCount; i++)
        {
            for(j = 0; j < m_dwChannelCount; j++)
            {
                psDestinationBuffer[j + (m_dwChannelCount * i)] = psSourceBuffer[j];
            }
        }

        //
        // Increment pointers and decrement sizes
        //

        psSourceBuffer += dwWorkingSourceSampleCount * m_dwChannelCount;
        dwSourceSampleCount -= dwWorkingSourceSampleCount;

        psDestinationBuffer += dwWorkingDestinationSampleCount * m_dwChannelCount;
        dwDestinationSampleCount -= dwWorkingDestinationSampleCount;
    }

    //
    // Update the output parameters of the packet descriptions.  There's really 
    // nothing you can do to cause us to error (short of a page fault), so we
    // always return success.  We'll calculate the number of bytes processed by
    // just looking at the difference between the current and starting data
    // buffer pointers.
    //

    if(pxmpSource->pdwCompletedSize)
    {
        *pxmpSource->pdwCompletedSize = (LPBYTE)psSourceBuffer - (LPBYTE)pxmpSource->pvBuffer;
    }

    if(pxmpSource->pdwStatus)
    {
        *pxmpSource->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if(pxmpSource->hCompletionEvent)
    {
        SetEvent(pxmpSource->hCompletionEvent);
    }

    if(pxmpDestination->pdwCompletedSize)
    {
        *pxmpDestination->pdwCompletedSize = (LPBYTE)psDestinationBuffer - (LPBYTE)pxmpDestination->pvBuffer;
    }

    if(pxmpDestination->pdwStatus)
    {
        *pxmpDestination->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if(pxmpDestination->hCompletionEvent)
    {
        SetEvent(pxmpDestination->hCompletionEvent);
    }

    return S_OK;
}


/****************************************************************************
 *
 *  Discontinuity
 *
 *  Description:
 *      Signals a discontinuity in the stream.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CSrcMediaObject::Discontinuity
(
    void
)
{
    //
    // Discontinuity doesn't mean anything to a synchronous XMO.  If we were
    // asynchronous, it would signal that no more source data is available
    // and all remaining destination packets should be completed.
    //

    return S_OK;
}


/****************************************************************************
 *
 *  Flush
 *
 *  Description:
 *      Resets the stream to it's default state.
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      HRESULT: COM result code.
 *
 ****************************************************************************/

HRESULT
CSrcMediaObject::Flush
(
    void
)
{
    //
    // We'll just reset the SRC index
    //

    m_dwSrcIndex = 0;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\echo.h ===
HRESULT
XCreateEchoFxMediaObject(
    DWORD dwDelay,
    DWORD dwSampleSize,
    XMediaObject **ppMediaObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\echo.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include "echop.h"
#include "echo.h"

//
// implements a simple synchronous XMO and in-place
//

HRESULT
XCreateEchoFxMediaObject(
    DWORD dwDelay,
    DWORD dwSampleSize,
    XMediaObject **ppMediaObject
    )
{   
    HRESULT hr;
    CEchoXMO *pXmo;

    //
    // create net xmo
    //

    pXmo = new CEchoXMO();
    ASSERT(pXmo);
    if (pXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pXmo->Initialize(dwDelay,
                          dwSampleSize);


    *ppMediaObject = NULL;

    if (SUCCEEDED(hr)) {
        *ppMediaObject = pXmo;
        pXmo->AddRef();
    }

    return hr;

}

HRESULT CEchoXMO::Initialize(
    DWORD dwDelay,
    DWORD dwSampleSize
    )
{

    //
    // this simple XMO only supports 16 bit samples (2 bytes)
    // however arbitrary sample size can be supported if the Process routine
    // treats input/dst buffers as arrays with proper size element size
    //

    ASSERT(dwSampleSize == (16 >> 3));
    m_dwSampleSize = dwSampleSize;
    m_dwDelay = dwDelay;

    //
    // allocate a buffer used as the delay line. Caches the previous packet..
    //

    m_pPreviousPacket = new SHORT[dwDelay/dwSampleSize];
    ASSERT(m_pPreviousPacket);

    memset(m_pPreviousPacket,0,dwDelay/dwSampleSize);
    return S_OK;

}



HRESULT STDMETHODCALLTYPE CEchoXMO::GetInfo( 
    PXMEDIAINFO pInfo
    )
{
    ASSERT(pInfo);

    //
    // we are a synchronous, in-place XMO
    //

    pInfo->dwFlags = XMO_STREAMF_IN_PLACE | XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_WHOLE_SAMPLES;

    //
    // because we are synchronous and not in place the buffers they pass
    // must be large enough to implement the echo effect
    // For a synchronous XMO, maxlookahead is irrelevant
    //

    pInfo->dwInputSize = m_dwDelay;
    pInfo->dwOutputSize = m_dwDelay;

    return S_OK;

}

HRESULT STDMETHODCALLTYPE CEchoXMO::GetStatus( 
        /* [out] */ DWORD __RPC_FAR *pdwFlags
        )
{

    //
    // let the caller know if we can accept any more data
    //

    ASSERT(pdwFlags);
    *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA | XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    return S_OK;

}


HRESULT STDMETHODCALLTYPE CEchoXMO::Process( 
    const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
    const XMEDIAPACKET __RPC_FAR *pDstBuffer
    )
{
    DWORD delayOffset = m_dwDelay/m_dwSampleSize;
    PSHORT dstBuffer, srcBuffer;
    SHORT srcSample;
    LONG temp32;

    //
    // we need both a destination and source buffer to operate
    //

    ASSERT(pSrcBuffer);
    ASSERT(pDstBuffer);

    //
    // make sure we have enough data to implement the echo effect
    //

    ASSERT(pSrcBuffer->dwMaxSize >= m_dwDelay);
    ASSERT(pDstBuffer->dwMaxSize >= m_dwDelay);
    ASSERT(pSrcBuffer->pvBuffer);
    ASSERT(pDstBuffer->pvBuffer);

    dstBuffer = (PSHORT) pDstBuffer->pvBuffer;
    srcBuffer = (PSHORT) pSrcBuffer->pvBuffer;

    //
    // echo effect
    //

    for (ULONG i=0;i<pDstBuffer->dwMaxSize/m_dwSampleSize;i++) {

        srcSample = srcBuffer[i];

        //
        // assume 16 bit samples. See comment in Initialize function.
        // Below we clip to avoid noise
        // 

        temp32 = m_pPreviousPacket[i]/2;

        temp32 += (LONG)srcSample;

        if (temp32 > 32767) {
            temp32 = 32767;
        } else if (temp32 < -32767) {
            temp32 = -32767;
        }

        dstBuffer[i] = (SHORT)temp32;

        //
        // cache the current src packet for the next call to process
        //

        m_pPreviousPacket[i] = srcSample;
    }

    if (pDstBuffer->pdwCompletedSize) {
        *pDstBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pDstBuffer->pdwStatus) {
        *pDstBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if (pSrcBuffer->pdwCompletedSize) {
        *pSrcBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pSrcBuffer->pdwStatus) {
        *pSrcBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    //
    // set any events
    //

    if (pSrcBuffer->hCompletionEvent) {
        SetEvent(pSrcBuffer->hCompletionEvent);
    }

    if (pSrcBuffer->hCompletionEvent) {
        SetEvent(pSrcBuffer->hCompletionEvent);
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\eq.h ===
HRESULT
XCreateEchoFxMediaObject(
    XMediaObject **ppMediaObject,
    DWORD dwDelay,
    DWORD dwSampleSize
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\eqp.h ===
#define _NTDRIVER_

#include <xtl.h>
#include <xdbg.h>

#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#undef  BREAK_INTO_DEBUGGER
#define BREAK_INTO_DEBUGGER __asm int 3


#define EQ_XMO_REQUIRED_SAMPLES 4 //(2 samples stereo)

class CEQXMO:public XMediaObject {

public:
    CEQXMO()
    {
        m_cRef = 0;
        memset(&m_wfx,0,sizeof(WAVEFORMATEX));
        memset(m_PreviousSamples, 0, EQ_XMO_REQUIRED_SAMPLES);
    }

    ~CEQXMO()
    {
    }

    HRESULT Initialize(
        PWAVEFORMATEX pwfx,
        float fCutoff,
        float fResonance
        );

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
        long l = InterlockedDecrement((long*)&m_cRef);
     
        if (l == 0)
           delete this;
        return l;
    }

    HRESULT STDMETHODCALLTYPE GetInfo( 
        PXMEDIAINFO pInfo
        );
    
    HRESULT STDMETHODCALLTYPE Process( 
        const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
        const XMEDIAPACKET __RPC_FAR *pDstBuffer
        );
    
    HRESULT STDMETHODCALLTYPE Flush()
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Discontinuity(void)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetStatus( 
        DWORD *dwFlags
        );
    
    //
    // these methods are specific to this filter
    //

    HRESULT STDMETHODCALLTYPE SetParameters( 
        float fCutoff,
        float fResonance
        );

    VOID ChamberlinFilter( 
        PSHORT srcBuffer,
        PSHORT dstBuffer,
        ULONG nStep,
        ULONG nLength,
        ULONG nOffset
        );

protected:

    SHORT m_PreviousSamples[EQ_XMO_REQUIRED_SAMPLES];
    ULONG m_cRef;

    WAVEFORMATEX m_wfx;

    //
    // chamberlin filter coefficients
    //

    unsigned int m_F;
    unsigned int m_Q;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\eq.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include "eqp.h"
#include "eq.h"


const int nFcWidth	= 16;

const int nFcPrec	= 16;
const int nQcPrec	= 15;
const int nGPrec	= 13;
const int nFltSmoothPrec=nFcPrec+5;
const int nDataPrec=23;

const float fOneOverSampleRate = 1.0f/48000.0f;
const float fPi = 3.14159265f;
void DlsToChamberlin(float fCutoff,float fResonance,unsigned int *pF,unsigned int *pQ);

//
// implements a simple synchronous XMO and in-place
//

HRESULT
XCreateParametricEQMediaObject(
    XMediaObject **ppMediaObject,
    PWAVEFORMATEX pwfx,
    float fCutoff,
    float fResonance
    )
{   
    HRESULT hr;
    CEQXMO *pXmo;

    //
    // create net xmo
    //

    pXmo = new CEQXMO();
    ASSERT(pXmo);
    if (pXmo == NULL) {
        return E_OUTOFMEMORY;
    }

    hr = pXmo->Initialize(pwfx,
                          fCutoff,
                          fResonance);


    *ppMediaObject = NULL;

    if (SUCCEEDED(hr)) {
        *ppMediaObject = pXmo;
        pXmo->AddRef();
    }

    return hr;

}

HRESULT CEQXMO::Initialize(
    PWAVEFORMATEX pwfx,
    float fCutoff,
    float fResonance
    )
{

    ASSERT(pwfx->wFormatTag == WAVE_FORMAT_PCM);
    memcpy(&m_wfx,pwfx,sizeof(WAVEFORMATEX));

    //
    // convert cutoff and resonance values to chamberlin low pass filter params F_tp and Q_tp
    //

    DlsToChamberlin(fCutoff,fResonance,&m_F,&m_Q);

    return S_OK;

}

long FTOL(float ftmp1)
{
	unsigned long lTemp1;
	__asm
	{
		fld	ftmp1
		fistp lTemp1
	}
	return lTemp1;
}

//
// This is a simple approximation of the mapping from DLS2 filter
//   descriptors, Cutoff in Hz and Resonance in dB, to Chamberlin
//   filter coefficients, F and Q.  The approximation is close
//   for small Cutoffs (< 6kHz) but breaks down for larger cutoffs.
//   The function is consistent in that F and Q are monotonic with
//   Cutoff and Resonance, respectively.  Output filter coefficients
//   are suitable conditioned for use in the apu.
//
void DlsToChamberlin(float fCutoff,float fResonance,unsigned int *pF,unsigned int *pQ)
{

	if(fResonance<0)
		fResonance = 0;
	if(fResonance>22.5f)
		fResonance = 22.5f;

	float fNormCutoff = fCutoff*fOneOverSampleRate;

	if(fNormCutoff<0.0f) fNormCutoff = 0.0f;
	if(fNormCutoff>0.5)	fNormCutoff = 0.5f;

	// The approximation
    float fFc = (float)(2.0*sin(fPi*fNormCutoff));
    float fQc = (float)pow(10.0,-0.05*fResonance);

	// Limit and convert to integer format
	*pF = (unsigned int)FTOL(fFc*(1<<nFcPrec));
	if(*pF>((1<<nFcWidth)-1))
		*pF = (1<<nFcWidth)-1;
	*pQ = (unsigned int)FTOL(fQc*(1<<nQcPrec));
	if(*pQ>((1<<nFcWidth)-1))
		*pQ = (1<<nFcWidth)-1;

	// Still need to limit on the low side

	return;
}


HRESULT CEQXMO::SetParameters(
    float fCutoff,
    float fResonance
    )

{

    //
    // convert cutoff and resonance values to chamberlin low pass filter params F_tp and Q_tp
    //

    DlsToChamberlin(fCutoff,fResonance,&m_F,&m_Q);

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CEQXMO::GetInfo( 
    PXMEDIAINFO pInfo
    )
{
    ASSERT(pInfo);

    //
    // we are a synchronous, in-place XMO
    //

    pInfo->dwFlags = XMO_STREAMF_IN_PLACE | XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_FIXED_PACKET_ALIGNMENT;

    //
    // require at least 4 blocks of sound samples
    // 

    pInfo->dwInputSize = m_wfx.nBlockAlign*4;
    pInfo->dwOutputSize = m_wfx.nBlockAlign*4;

    return S_OK;

}

HRESULT STDMETHODCALLTYPE CEQXMO::GetStatus( 
        /* [out] */ DWORD __RPC_FAR *pdwFlags
        )
{

    //
    // let the caller know if we can accept any more data
    //

    ASSERT(pdwFlags);
    *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;
    return S_OK;

}


HRESULT STDMETHODCALLTYPE CEQXMO::Process( 
    const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
    const XMEDIAPACKET __RPC_FAR *pDstBuffer
    )
{
    SHORT history[4];
    PSHORT srcBuffer,dstBuffer;
    DWORD dwSize;

    //
    // we need both a destination and source buffer to operate
    //

    ASSERT(pSrcBuffer);
    ASSERT(pDstBuffer);

    //
    // make sure we have enough data
    //

    ASSERT(pSrcBuffer->dwMaxSize >= (DWORD)m_wfx.nBlockAlign*4);
    ASSERT(pDstBuffer->dwMaxSize >= (DWORD)m_wfx.nBlockAlign*4);

    //
    // ensure both buffers are the same size
    //

    ASSERT(pSrcBuffer->dwMaxSize == pDstBuffer->dwMaxSize);

    ASSERT(pSrcBuffer->pvBuffer);
    ASSERT(pDstBuffer->pvBuffer);

    dwSize = pDstBuffer->dwMaxSize/(m_wfx.wBitsPerSample >> 3);
    dstBuffer = (PSHORT) pDstBuffer->pvBuffer;
    srcBuffer = (PSHORT) pSrcBuffer->pvBuffer;

    //
    // if the stream is stereo we have to pass each channel through the filter in parallel.
    // If the stream is mono we need to cascade the filter (2 in a row)
    //

    if (m_wfx.nChannels == 1) {

        //
        // save the last 2 samples of this packet in case the SrcBuffer and DstBuffer are the same
        //
    
        history[0] = srcBuffer[dwSize-3];
        history[1] = srcBuffer[dwSize-2];

        //
        // mono processing
        //

        ChamberlinFilter(srcBuffer,
                         dstBuffer,
                         dwSize,
                         1,
                         0);

        //
        // second pass
        //

        ChamberlinFilter(dstBuffer,
                         dstBuffer,
                         dwSize,
                         1,
                         0);

        //
        // cache the last two samples of this packet
        //
    
        m_PreviousSamples[0] = history[0];
        m_PreviousSamples[1] = history[1];

    } else {

        ULONG i;

        for (i=0;i<EQ_XMO_REQUIRED_SAMPLES;i++) {

            history[i] = m_PreviousSamples[i];

        }

        //
        // stereo processing. Do left channel first
        //

        ChamberlinFilter(srcBuffer,
                         dstBuffer,
                         pDstBuffer->dwMaxSize/(m_wfx.wBitsPerSample >> 3),
                         2,
                         0);

        //
        // right channel
        //

        ChamberlinFilter(srcBuffer,
                         dstBuffer,
                         pDstBuffer->dwMaxSize/(m_wfx.wBitsPerSample >> 3),
                         2,
                         1);

        //
        // cache the last two samples of this packet
        //
    
        for (i=0;i<EQ_XMO_REQUIRED_SAMPLES;i++) {

            m_PreviousSamples[i] = history[i];

        }


    }


    if (pDstBuffer->pdwCompletedSize) {
        *pDstBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pDstBuffer->pdwStatus) {
        *pSrcBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    if (pSrcBuffer->pdwCompletedSize) {
        *pDstBuffer->pdwCompletedSize = pSrcBuffer->dwMaxSize;
    }

    if (pSrcBuffer->pdwStatus) {
        *pSrcBuffer->pdwStatus = XMEDIAPACKET_STATUS_SUCCESS;
    }

    return S_OK;

}

VOID CEQXMO::ChamberlinFilter( 
    PSHORT srcBuffer,
    PSHORT dstBuffer,
    ULONG nStep,
    ULONG nLength,
    ULONG nOffset
    )
{
    float fN, fD, fTemp, fF = (float)m_F, fQ = (float)m_Q, fPrevSample;

    //
    // divide nLength (in samples) by nStep (also in samples)
    //

    nLength /= nStep;

    //
    // implement the modified chamberlin filter (boost/cut filter)
    // the index counter i is in samples
    //

    for (ULONG i=nLength-nStep;i>=0;i-=nStep) {

        //
        // numerator
        //

        if (i==nStep) {

            fPrevSample = (float)srcBuffer[i*nStep-nStep*1 +nOffset];

        } else {

            fPrevSample = (float)m_PreviousSamples[1*nStep+nOffset];

        }
        
        fN = fF*fF*fPrevSample;

        // 
        // denominator
        //

        fTemp = 1 - (2-fF*fQ - fF*fF)*fPrevSample;

        //
        // get 2 samples back
        //

        if (i>nStep) {

            fPrevSample = (float)srcBuffer[i*nStep-2*nStep +nOffset];

        } else {

            fPrevSample = (float)m_PreviousSamples[0+nOffset];

        }

        fD = fTemp + (1 - fF*fQ)*fPrevSample;

        //
        // transfer function result
        //

        fTemp = fN/fD;

        //
        // convert to SHORT

        dstBuffer[i*nStep+nOffset] = (SHORT)fTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmoclnt\xmoclnt.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       xmoclnt.cpp
 *  Content:    XMO client sample.
 *
 ****************************************************************************/

#include <xtl.h>
#include "SRCXMO.h"

/****************************************************************************
 *
 *  wWinMain
 *
 *  Description:
 *      Application entry point.
 *
 *  Arguments:
 *      HINSTANCE [in]: unused.
 *      HINSTANCE [in]: unused.
 *      LPWSTR [in]: unused.
 *      int [in]: unused.
 *
 *  Returns:  
 *      int: 0.
 *
 ****************************************************************************/

void __cdecl main()
{
    static const LPCSTR     pszFileName                         = "t:\\media\\xmoclnt.wav";
    static const DWORD      dwPlaybackFrequency                 = 48000;
    static const DWORD      dwPacketCount                       = 4;
    static const DWORD      dwPacketSize                        = 0x4000;
    LPXFILEMEDIAOBJECT      pSourceFilter                       = NULL;
    LPXMEDIAOBJECT          pIntermediateFilter                 = NULL;
    LPDIRECTSOUNDSTREAM     pRenderFilter                       = NULL;
    LPVOID                  pvSourceBuffer                      = NULL;
    LPVOID                  pvDestinationBuffer                 = NULL;
    HANDLE                  ahPacketEvents[dwPacketCount];
    XMEDIAPACKET            xmpSource;
    XMEDIAPACKET            xmpDestination;
    DWORD                   dwSourceCompletedSize;
    DWORD                   dwDestinationCompletedSize;
    DWORD                   dwPacketIndex;
    LPCWAVEFORMATEX         pwfxFile;
    WAVEFORMATEX            wfxStream;
    DSSTREAMDESC            dssd;
    HRESULT                 hr;

    //
    // We'll use a hard-coded packet size, because... well... I'm lazy.
    // In a shipping application, you'd want to calculate the optimal packet
    // size based on alignment restrictions and the MaxLookahead of any
    // asynchronous filters.  I'm going to make up a constant value.  If
    // the SRC has to do a significant downsample before sending to the
    // renderer, it's possible the stream will starve.
    //

    //
    // Create the source (wave file) filter.  We'll assume the source file
    // is 16-bit PCM.  Other than that, we don't really care what the format
    // is.
    //

    hr = XWaveFileCreateMediaObject(pszFileName, &pwfxFile, &pSourceFilter);

    //
    // Create the intermediate (SRC) filter
    //

    if(SUCCEEDED(hr))
    {
        if(!(pIntermediateFilter = new CSrcMediaObject(pwfxFile->nChannels, pwfxFile->nSamplesPerSec, dwPlaybackFrequency)))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Create the render (DirectSound stream) filter
    //

    if(SUCCEEDED(hr))
    {
        wfxStream.wFormatTag = WAVE_FORMAT_PCM;
        wfxStream.nChannels = pwfxFile->nChannels;
        wfxStream.nSamplesPerSec = dwPlaybackFrequency;
        wfxStream.wBitsPerSample = pwfxFile->wBitsPerSample;
        wfxStream.nBlockAlign = wfxStream.nChannels * wfxStream.wBitsPerSample / 8;
        wfxStream.nAvgBytesPerSec = wfxStream.nSamplesPerSec * wfxStream.nBlockAlign;
        
        ZeroMemory(&dssd, sizeof(dssd));

#ifdef SILVER
        dssd.dwSize = sizeof(dssd);
#endif // SILVER
        dssd.dwMaxAttachedPackets = dwPacketCount;
        dssd.lpwfxFormat = &wfxStream;

#ifdef SILVER
        hr = DirectSoundCreateStream(DSDEVID_MCPX, &dssd, &pRenderFilter, NULL);
#else // SILVER
		hr = DirectSoundCreateStream( &dssd, &pRenderFilter );
#endif // SILVER
    }

    //
    // Allocate the source data buffer.  Because the source filter is 
    // synchronous, we can just use a single buffer and packet description.  
    // Because the amount of data we read from the source may be a different 
    // size than the amount we send to the renderer, using a single packet 
    // size is really sub-optimal.  We may end up re-reading data from the 
    // source because the renderer couldn't accept it all.  Oh well.  Sample 
    // code isn't supposed to be great.
    //

    if(SUCCEEDED(hr))
    {
        if(!(pvSourceBuffer = LocalAlloc(LPTR, dwPacketSize)))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Allocate a buffer large enough to store packet data for all the 
    // renderer's packets.  Because he's asynchronous, we have to keep the
    // data around until he's done processing it.
    //

    if(SUCCEEDED(hr))
    {
        if(!(pvDestinationBuffer = LocalAlloc(LPTR, dwPacketSize * dwPacketCount)))
        {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // Create render packet completion events
    //

    if(SUCCEEDED(hr))
    {
        for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
        {
            if(!(ahPacketEvents[dwPacketIndex] = CreateEvent(NULL, TRUE, TRUE, NULL)))
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
    }

    //
    // Enter the main loop
    //

    while(SUCCEEDED(hr))
    {
        //
        // Wait for a packet completion event to be signalled.  If this is our
        // first time through the loop, all the packets are free, so all the
        // events are signalled.
        //

        dwPacketIndex = WaitForMultipleObjects(dwPacketCount, ahPacketEvents, FALSE, INFINITE) - WAIT_OBJECT_0;
        
        //
        // Read some data
        //

        ZeroMemory(&xmpSource, sizeof(xmpSource));
        
        xmpSource.pvBuffer = pvSourceBuffer;
        xmpSource.dwMaxSize = dwPacketSize;
        xmpSource.pdwCompletedSize = &dwSourceCompletedSize;
        
        hr = pSourceFilter->Process(NULL, &xmpSource);

        //
        // If there's no more data to read, go ahead and break out of the loop
        //

        if(SUCCEEDED(hr) && !dwSourceCompletedSize)
        {
            break;
        }

        //
        // Send it through the SRC.  Be sure to fix up the packet size to
        // correspond to the completed size from the source filter.
        //

        if(SUCCEEDED(hr))
        {
            xmpSource.dwMaxSize = dwSourceCompletedSize;

            ZeroMemory(&xmpDestination, sizeof(xmpDestination));

            xmpDestination.pvBuffer = (LPBYTE)pvDestinationBuffer + (dwPacketIndex * dwPacketSize);
            xmpDestination.dwMaxSize = dwPacketSize;
            xmpDestination.pdwCompletedSize = &dwDestinationCompletedSize;

            hr = pIntermediateFilter->Process(&xmpSource, &xmpDestination);
        }

        //
        // It's possible that we read some data, but it's not enough to pass
        // through the intermediate filter.  If that's true, go ahead and
        // break out of the loop.
        //
        
        if(SUCCEEDED(hr) && !dwDestinationCompletedSize)
        {
            break;
        }

        //
        // Send the packet to the renderer.  Again, be sure to fix up the 
        // packet size.  We don't care how much data actually gets played,
        // so we'll reset pdwCompletedSize to NULL.  If we did care how
        // much was played (or how much was processed by any asynchronous
        // XMO), we'd need to be sure that the variable pointed to by
        // pdwCompletedSize was not 
        //

        if(SUCCEEDED(hr))
        {
            xmpDestination.dwMaxSize = dwDestinationCompletedSize;
            xmpDestination.pdwCompletedSize = NULL;
            xmpDestination.hCompletionEvent = ahPacketEvents[dwPacketIndex];

            ResetEvent(xmpDestination.hCompletionEvent);

            hr = pRenderFilter->Process(&xmpDestination, NULL);
        }

        //
        // If the intermediate XMO processed less data than we supplied to
        // it, seek backwards in the source XMO.  I outlined why this is lame
        // above, but oh well...
        //

        if(SUCCEEDED(hr) && (dwSourceCompletedSize < xmpSource.dwMaxSize))
        {
            hr = pSourceFilter->Seek(-(LONG)(xmpSource.dwMaxSize - dwSourceCompletedSize), FILE_CURRENT, NULL);
        }
    }

    //
    // Wait for all packets to be completed
    //

    WaitForMultipleObjects(dwPacketCount, ahPacketEvents, TRUE, INFINITE);

    //
    // Free events
    //

    for(dwPacketIndex = 0; dwPacketIndex < dwPacketCount; dwPacketIndex++)
    {
        if(ahPacketEvents[dwPacketIndex])
        {
            CloseHandle(ahPacketEvents[dwPacketIndex]);
        }
    }
    
    //
    // Free memory
    //

    if(pvSourceBuffer)
    {
        LocalFree(pvSourceBuffer);
    }

    if(pvDestinationBuffer)
    {
        LocalFree(pvDestinationBuffer);
    }

    //
    // Free objects
    //

    if(pSourceFilter)
    {
        pSourceFilter->Release();
    }

    if(pIntermediateFilter)
    {
        pIntermediateFilter->Release();
    }

    if(pRenderFilter)
    {
        pRenderFilter->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\xmofilt.cpp ===
#include "xmofilt.h"
#include "echo.h"
#include <stdlib.h>
#include <stdio.h>

ULONG g_XmoFilterDebugLevel = 2;


TESTDATA g_TestData;

void __cdecl main()
{
    HRESULT hr;

    memset(&g_TestData,0,sizeof(TESTDATA));

    g_TestData.dwFlags = 0;

    DBG_INFO(("**** XmoFilter Test started...Global data at %x\n",&g_TestData));    

    g_TestData.dwFlags = 1;

    BREAK_INTO_DEBUGGER;

    g_TestData.ContextArray[0].dwFlags = g_TestData.dwFlags;

    //Initialize core peripheral port support
    XInitDevices(0,NULL);

    //
    // initialize filter graph
    // define flags here  to determine test configuration
    // The reason we use a context array above is so that you can instantiate multiple
    // xmo filters at the same time and have them run independent of each other.
    // Right now we only use one streaming filter also viewed as chain of streaming objects
    //
    
    hr = Init(0);    
    if (FAILED(hr)) {
        DBG_ERROR(("Init of context failed\n"));
    }

    //
    // instruct routine to poll the filter graph so completed packets can be moved through
    // the streaming chain
    //

    while (TRUE) {

        TransferData(0);

        if (g_TestData.dwFlags == 0) { 
        
            break;
        }
    }    

    Cleanup();
    DBG_INFO(("*** Test stopped, type .reboot now\n"));
    BREAK_INTO_DEBUGGER
   
    Sleep(INFINITE);

}

//
// Init: Creates a streaming graph between 3 XMOs
// A source, a in-between (codec in this case) and a target
// We only support one intermediate xmo, but you could actually
// have multiple ones that manipulate the same stream
// passing packets between them
//

HRESULT
Init(DWORD dwIndex)
{
    PGRAPH_CONTEXT pContext = &g_TestData.ContextArray[dwIndex];
    DWORD dwInsertions;
    DWORD dwDeviceId;
    HRESULT hr = S_OK;
    DWORD count = 0;
    DWORD i;
    DWORD dwMinSize;

    //
    // directory path for audio PCM files
    //

    PWAVEFORMATEX           format = &pContext->wfxAudioFormat;

    PMEDIA_PACKET_CTX       pCtx;
    XMEDIAINFO              xMediaInfo;

    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    pContext->dwPacketSize = PACKET_SIZE;
    pContext->dwMaxBufferCount = PACKET_CNT;

    //
    // init the audio format..
    //

    format->wFormatTag          = WAVE_FORMAT_PCM;
    format->nSamplesPerSec      = 16000;
    format->nChannels           = 1;
    format->wBitsPerSample      = (WORD) 16;
    format->nBlockAlign         = (16 * format->nChannels / 8);
    format->nAvgBytesPerSec     = format->nSamplesPerSec * format->nBlockAlign;
    format->cbSize              = 0;

    pContext->dwPlayerPort = INVALID_PORT;

    //
    // Wait up to 2 secs to find hawk
    //

    while (count++ < 2) {

        DBG_INFO(("XmoFilter: Sleeping for 1 sec , waiting for hawk\n"));

        Sleep(1000);

        dwInsertions = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
        if(dwInsertions)
        {
        
            DBG_INFO(("XmoFilter: Insertions 0x%08x\n", dwInsertions));

            for(i=0; i < 32; i++)
            {
                //
                //  Handle Insertions
                //
                if(dwInsertions&(1 << i))
                {
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                    } else
                    {
                        dwPort = i-16;
                    }

                    DBG_INFO(("XmoFilter: Hawk in port %d\n", dwPort));
                    pContext->dwPlayerPort = dwPort;
                    count = 0x100;
                    break;

                }
                
                
            } // for loop
        } // if

    } // while

    //
    // instantiate the first XMO in the chain. This will be the hawk USB microphone device
    //

    hr = XVoiceCreateMediaObject(
        XDEVICE_TYPE_VOICE_MICROPHONE,
        pContext->dwPlayerPort,
        PACKET_CNT,
        format,
        &pContext->pSourceXmo);
    
    if (FAILED(hr)) {          
        DBG_ERROR(("XmoFilter: XcreateHawkMediaObject failed with %x",
                  hr));

        return hr;

    }

    //
    // now create a codec or in-between XMO
    //

    hr = XCreateEchoFxMediaObject(
        pContext->dwPacketSize,     // dwDelay (length in bytes of delay line)
        format->wBitsPerSample >> 3, // dwSampleSize (convert to bytes)
        &pContext->pIntermediateXmo
        );

    if (FAILED(hr)) {          
        DBG_ERROR(("XmoFilter: XcreateEchoFxMediaObject failed with %x",
                  hr));

        return hr;

    }

    //
    // now create the target XMO, the end part of the streaming chain
    //

    DSSTREAMDESC dsDesc;

    memset(&dsDesc,0,sizeof(dsDesc));

#ifdef SILVER
    dsDesc.dwSize = sizeof(dsDesc);
#endif // SILVER
    dsDesc.dwFlags = 0;
    dsDesc.dwMaxAttachedPackets = PACKET_CNT;
    dsDesc.lpwfxFormat = format;
#ifdef SILVER
    dwDeviceId = DSDEVID_MCPX;

    hr = DirectSoundCreateStream(
        dwDeviceId,
        &dsDesc,
        (LPDIRECTSOUNDSTREAM *)&pContext->pTargetXmo,
        NULL);
#else // SILVER
	hr = DirectSoundCreateStream( &dsDesc, (LPDIRECTSOUNDSTREAM *)&pContext->pTargetXmo );
#endif // SILVER

    if (FAILED(hr)) {          
        DBG_ERROR(("XmoFilter: DirectSoundCreateXMOStream failed with %x",
                  hr));

        DBG_ERROR(("Init: Could not open a target audio XMO\n"));
        return hr;
    }

    //
    // at this point we should have all the XMOs
    // figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned
    // As a last check we make sure its also larger than the maxLookahead
    //

    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if ( pContext->pSourceXmo )
    {
        hr = pContext->pSourceXmo->GetInfo( &xMediaInfo );
        ASSERT( hr == NOERROR );
        pContext->dwMinPacketSize = xMediaInfo.dwOutputSize;

        XMOFILTER_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);

    }

    if ( pContext->pIntermediateXmo )
    {
        hr = pContext->pIntermediateXmo->GetInfo( &xMediaInfo );
        ASSERT( hr == NOERROR );
        pContext->dwMinPacketSize = max( xMediaInfo.dwInputSize, pContext->dwMinPacketSize );
        XMOFILTER_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);
    }

    if ( pContext->pTargetXmo )
    {
        hr = pContext->pTargetXmo->GetInfo( &xMediaInfo );
        ASSERT( hr == NOERROR );
        pContext->dwMinPacketSize = max( xMediaInfo.dwOutputSize, pContext->dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE(xMediaInfo,pContext->dwPacketSize);
    }

    ASSERT(pContext->pTargetXmo);
    ASSERT(pContext->pSourceXmo);

    InitializeListHead(&pContext->SrcPendingList);
    InitializeListHead(&pContext->DstPendingList);

    //
    // allocate one large buffer for incoming/outgoing data
    // The buffer is going ot be split in small packet segments that
    // will be used to stream data between XMOs
    //

    dwMinSize = MAXBUFSIZE;
    pContext->TransferBuffer = new BYTE[dwMinSize];
    ASSERT(pContext->TransferBuffer);

    memset(pContext->TransferBuffer,0,dwMinSize);

    //
    // allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target XMO
    //

    dwMinSize = (PACKET_CNT*sizeof(MEDIA_PACKET_CTX))+10;
    pContext->PacketContextPool = new BYTE[dwMinSize];
    ASSERT(pContext->PacketContextPool);

    memset(pContext->PacketContextPool,8,dwMinSize);

    //
    // We attach all available packet buffers in the beginning to prime the graph:
    // As each packet is completed by the source XMO, the event is signalled in
    // its packet context and we pass the packet to the next XMO
    //

    for (i=0; i<PACKET_CNT;i++) {

        pCtx = (PMEDIA_PACKET_CTX) (pContext->PacketContextPool+sizeof(MEDIA_PACKET_CTX)*i);

        memset(pCtx,0,sizeof(MEDIA_PACKET_CTX));

        pCtx->dwCompletedSize = pContext->dwPacketSize;
        pCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;
        pCtx->pBuffer = &pContext->TransferBuffer[i*PACKET_SIZE];

        InsertContext(pContext,
                      pCtx,
                      pContext->pSourceXmo,
                      TRUE);

    }

    return S_OK;

}

VOID
Cleanup()
{
    PGRAPH_CONTEXT pContext;
    ULONG i=0;
    DBG_INFO(("Test cleanup. Deleting media objects.\n"));

    for (i=0;i<2;i++) {
        pContext = &g_TestData.ContextArray[i];

        //
        // delete any xmos...
        //
    
        if (pContext->pSourceXmo) {
            pContext->pSourceXmo->Release();
        }
    
        if (pContext->pIntermediateXmo) {
            pContext->pIntermediateXmo->Release();
        }
    
        if (pContext->pTargetXmo) {
            pContext->pTargetXmo->Release();
        }


    }

}



HRESULT
TransferData(
    DWORD dwIndex
    )
{
    PGRAPH_CONTEXT pContext = &g_TestData.ContextArray[dwIndex];
    HRESULT hr=S_OK;
    DWORD index = 0;
    XMEDIAPACKET xmb;
    DWORD dwSize;    
    PMEDIA_PACKET_CTX pSrcCtx, pDstCtx;
    HANDLE hArray[2];

    //
    // setup media buffer
    //

    memset(&xmb,0,sizeof(xmb));

    dwSize = 0;
    pSrcCtx = NULL;
    pDstCtx = NULL;

    //
    // Wait for the oldest buffers submitted to the source and target xmo
    // oldest buffers are at the head, since we insert at the tail, remove from head
    //

    if (!IsListEmpty(&pContext->SrcPendingList)) {

        pSrcCtx = (PMEDIA_PACKET_CTX) pContext->SrcPendingList.Flink; // head

    }

    if (!IsListEmpty(&pContext->DstPendingList)) {

        pDstCtx = (PMEDIA_PACKET_CTX) pContext->DstPendingList.Flink; //head

    }        

    if (pSrcCtx && 
        (pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING)) {

        //
        // a src buffer completed.
        // Remove this context from the Src pending list.
        // Send it to a codec, if present, then send it to the Target xmo
        //

        RemoveEntryList(&pSrcCtx->ListEntry);

        //
        // Before we pass it on, set the context packet to amount of data we received
        //

        xmb.pvBuffer = pSrcCtx->pBuffer;            
        xmb.dwMaxSize = pSrcCtx->dwCompletedSize;        
        xmb.hCompletionEvent = NULL;

        DBG_SPAM(("Context %x received %x bytes, xmb %x\n",pSrcCtx, xmb.dwMaxSize, &xmb));
        ASSERT(xmb.dwMaxSize);

        pSrcCtx->dwCompletedSize = 0;
        pSrcCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;

        if (pContext->pIntermediateXmo) {

            //
            // NOTE: its ok to pass a pointer to a stack variable since
            // middle XMO is sync!!! Never do this with async XMOs!!!
            // Note that we pass the same media packet description twice
            // THis is  because the particular intermediate effect XMO is in place
            // and it operates on a single buffer
            //

            dwSize = xmb.dwMaxSize;
            xmb.pdwCompletedSize = &dwSize;

            hr = pContext->pIntermediateXmo->Process(
                &xmb,
                &xmb);

            ASSERT(SUCCEEDED(hr));
            ASSERT(dwSize <=PACKET_SIZE);

            pSrcCtx->dwCompletedSize = dwSize;

        } else { // if intermediate xmo

            pSrcCtx->dwCompletedSize = pContext->dwPacketSize;

        }

        //
        // pass media buffer to the target xmo.
        //

        InsertContext(pContext,
                      pSrcCtx,
                      pContext->pTargetXmo,
                      FALSE);

    }

    //
    // check if destination buffer xmo was also done..
    //

    if (pDstCtx && 
        (pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING)) {        

        DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

        RemoveEntryList(&pDstCtx->ListEntry);

        ASSERT(pDstCtx->dwCompletedSize != 0);

        //
        // the target XMO is done with a buffer.
        //

        pDstCtx->dwCompletedSize = PACKET_SIZE;
        InsertContext(pContext,
                      pDstCtx,
                      pContext->pSourceXmo,
                      TRUE);


    } 

    return hr;

}

//
// helper function
// InsertContext prepares a packet context and attaches it to the source
// or target XMO
//

VOID
InsertContext(
    PGRAPH_CONTEXT pContext,
    PMEDIA_PACKET_CTX pCtx,
    XMediaObject *pXmo,
    BOOL fSource
    )
{
    XMEDIAPACKET xmb;
    HRESULT hr;

    memset(&xmb,0,sizeof(xmb));            

    xmb.pvBuffer = pCtx->pBuffer;            
    xmb.dwMaxSize = pCtx->dwCompletedSize;

    pCtx->dwCompletedSize = 0;
    pCtx->dwStatus = XMEDIAPACKET_STATUS_PENDING;

    xmb.hCompletionEvent = NULL;
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;
    xmb.pdwStatus = &pCtx->dwStatus;

    if (fSource) {

        //
        // attach to the source XMO (first xmo in the chain)
        //

        hr = pXmo->Process(
            NULL,
            &xmb);

        InsertTailList(&pContext->SrcPendingList, &pCtx->ListEntry);


    } else {

        //
        // attach to the target XMO (first xmo in the chain)
        //

        hr = pXmo->Process(
            &xmb,
            NULL);

        InsertTailList(&pContext->DstPendingList, &pCtx->ListEntry);

    }

    if (FAILED(hr)) {

        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
        BREAK_INTO_DEBUGGER;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\echop.h ===
#define _NTDRIVER_

#include <xtl.h>
#include <xdbg.h>

#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#undef  BREAK_INTO_DEBUGGER
#define BREAK_INTO_DEBUGGER __asm int 3


class CEchoXMO:public XMediaObject {

public:
    CEchoXMO()
    {
        m_cRef = 0;
        m_dwDelay = 0;
        m_dwSampleSize = 0;
        m_pPreviousPacket = NULL;
    }

    ~CEchoXMO()
    {
    }

    HRESULT Initialize(
        DWORD dwDelay,
        DWORD dwSampleSize
        );

    STDMETHODIMP_(ULONG) AddRef() {
       return InterlockedIncrement((long*)&m_cRef);
    }

    STDMETHODIMP_(ULONG) Release() {
        long l = InterlockedDecrement((long*)&m_cRef);
     
        if (l == 0)
           delete this;
        return l;
    }

    HRESULT STDMETHODCALLTYPE GetInfo( 
        PXMEDIAINFO pInfo
        );
    
    HRESULT STDMETHODCALLTYPE Process( 
        const XMEDIAPACKET __RPC_FAR *pSrcBuffer,
        const XMEDIAPACKET __RPC_FAR *pDstBuffer
        );
    
    HRESULT STDMETHODCALLTYPE Flush()
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE Discontinuity(void)
    {
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetStatus( 
        DWORD *dwFlags
        );
    

protected:

    PSHORT m_pPreviousPacket;
    ULONG m_cRef;
    DWORD m_dwDelay;
    DWORD m_dwSampleSize;


};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\samples\xmofiltr\xmofilt.h ===
#include <xtl.h>
#include <xdbg.h>


#if DBG

//
// simple macro to verify that the packet size is OK for a particular XMO
//


#define XMOFILTER_VERIFY_PACKET_SIZE(xMediaInfo,dwPacketSize) ASSERT(xMediaInfo.dwOutputSize <= dwPacketSize);\
    if (xMediaInfo.dwOutputSize) ASSERT(dwPacketSize%xMediaInfo.dwOutputSize == 0);\
    ASSERT(dwPacketSize >= xMediaInfo.dwMaxLookahead);\

#else 

    #define XMOFILTER_VERIFY_PACKET_SIZE(xMediaInfo,dwPacketSize)

#endif


#if DBG

#define DEBUG_LEVEL_ERROR 0
#define DEBUG_LEVEL_WARNING 1
#define DEBUG_LEVEL_INFO 2
#define DEBUG_LEVEL_SPAM 5

extern ULONG g_XmoFilterDebugLevel;
#define DBG_SPAM(_exp_) {if (g_XmoFilterDebugLevel >= DEBUG_LEVEL_SPAM) DbgPrint _exp_;}
#define DBG_INFO(_exp) {if (g_XmoFilterDebugLevel >= DEBUG_LEVEL_INFO) DbgPrint _exp;}
#define DBG_ERROR(_exp) {if (g_XmoFilterDebugLevel >= DEBUG_LEVEL_ERROR) DbgPrint _exp;}
#define DBG_WARN(_exp) {if (g_XmoFilterDebugLevel >= DEBUG_LEVEL_WARNING) DbgPrint _exp;}

#else
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp_)
#define DBG_ERROR(_exp_)
#define DBG_WARN(_exp_)
#endif


#undef max
#undef min
#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#define PACKET_CNT      3

//
// we arrived at this value based on the requirements of the XMOs
// The idea is to pick an arbitrary packet size, go through the Init function once
// and then if any asserts fires while verifying the packet sizes, change the packet
// to satisfy all requirements
//

#define PACKET_SIZE		0x140*0x40

#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)



#define BREAK_INTO_DEBUGGER __asm int 3

typedef struct _testmediabuf {

    LIST_ENTRY ListEntry;
	DWORD dwStatus;
	DWORD dwCompletedSize;
    PUCHAR pBuffer;

} MEDIA_PACKET_CTX, *PMEDIA_PACKET_CTX;

#define INVALID_PORT        0xFFFFFFFF

typedef struct _graphcontext {

    DWORD dwFlags;
	DWORD dwPlayerPort;
	XMediaObject *pSourceXmo;
	XMediaObject *pIntermediateXmo;
	XMediaObject *pSRCXmo;
	XMediaObject *pTargetXmo;

	DWORD	dwMinPacketSize;
	DWORD	dwPacketSize;
    DWORD   dwMaxBufferCount;

	WAVEFORMATEX wfxAudioFormat;

    LIST_ENTRY  SrcPendingList;
    LIST_ENTRY  DstPendingList;

	PUCHAR TransferBuffer;
    PUCHAR PacketContextPool;

    ULONGLONG dwReserved;


} GRAPH_CONTEXT, *PGRAPH_CONTEXT;


typedef struct _testdata {

	DWORD dwFlags;
    GRAPH_CONTEXT ContextArray[2];

} TESTDATA, *PTESTDATA;

//
// xmofilt.cpp
//
VOID
Cleanup();

HRESULT
TransferData(DWORD dwIndex);

HRESULT
Init(DWORD dwIndex);

VOID
InsertContext(
    PGRAPH_CONTEXT pContext,
    PMEDIA_PACKET_CTX pCtx,
    XMediaObject *pXmo,
    BOOL fSource
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Ball.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

    28-April-2001 danrose
	    Added sound

    21-June-2001 danhaff
        Made lights flash with beat of music.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "Ball.h"
#include "helpers.h"
#include "music.h"

using namespace WFVO;

namespace WFVO {

extern CMusic g_music;
extern LPDIRECTSOUND g_dsound;

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL (D3DFVF_XYZ | D3DFVF_NORMAL)
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f

#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

#define AMBIENT_SOUND_FREQUENCY 26000

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CBall::m_uRef = 0;
IDirect3DTexture8* CBall::m_pd3dtBase = NULL;
IDirect3DTexture8* CBall::m_pd3dtBump = NULL;
IDirect3DTexture8* CBall::m_pd3dtLight = NULL;
IDirect3DTexture8* CBall::m_pd3dtWhite = NULL;
IDirect3DTexture8* CBall::m_pd3dtFlat = NULL;
CAudioData CBall::m_CollisionSoundData;
CAudioData CBall::m_AmbientSoundData;

//------------------------------------------------------------------------------
//	CBall::CBall
//------------------------------------------------------------------------------
CBall::CBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	            = TRUE;
	m_pVB		            = NULL;
	m_pIB		            = NULL;
	m_pSubMix               = NULL;
	m_pAmbientSound         = NULL;
	m_pAmbientSoundData     = NULL;
	m_pCollisionSound	    = NULL;
	m_pCollisionSoundData   = NULL;
	m_fillMode	            = D3DFILL_SOLID;
	m_mass		            = 0;
    m_dwCollisionFrequency  = 0;
    m_uRef++;

    ZeroMemory( &m_dwInLightRange, 4 * sizeof(DWORD));
}

//------------------------------------------------------------------------------
//	CBall::~CBall
//------------------------------------------------------------------------------
CBall::~CBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
        if (m_pd3dtBump) {
            m_pd3dtBump->Release();
            m_pd3dtBump = NULL;
        }
        if (m_pd3dtLight) {
            m_pd3dtLight->Release();
            m_pd3dtLight = NULL;
        }
        if (m_pd3dtWhite) {
            m_pd3dtWhite->Release();
            m_pd3dtWhite = NULL;
        }
        if (m_pd3dtFlat) {
            m_pd3dtFlat->Release();
            m_pd3dtFlat = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CBall::Create
//------------------------------------------------------------------------------
HRESULT
CBall::Create(
			  IN IDirect3DDevice8*	pDevice,
			  IN float				radius,
			  IN float				mass,
			  IN int				numLong,
			  IN int				numLat,
              IN BOOL               bLight,
              IN DWORD              dwID
			  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	UINT		index       = 0;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;
    int         i, j;
    float       fX, fY, fTX, fSinY, fCosY;
    Vertex*     pr;


	// Release previous buffers
	Release();

	// Setup
    m_dwID      = dwID;
	m_radius	= radius;
	m_detail	= numLat;
	m_mass		= mass; // 4.0f / 3.0f * PI * m_radius * m_radius * m_radius;

    m_bLightSource = bLight;

    if (bLight) {

        XGVECTOR3 vColor, vSpecular;

        if (g_TestParams.bTextureBalls) {
            XGVec3Normalize(&vColor, &XGVECTOR3((float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX, (float)rand() / (float)RAND_MAX));
            XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));
        }
        else {
            vColor = XGVECTOR3(1.0f, 1.0f, 1.0f);
            vSpecular = XGVECTOR3(1.0f, 1.0f, 1.0f);
        }

        memset(&m_light, 0, sizeof(D3DLIGHT8));
        m_light.Type = D3DLIGHT_POINT;
        m_light.Diffuse.r = vColor.x;
        m_light.Diffuse.g = vColor.y;
        m_light.Diffuse.b = vColor.z;
        m_light.Diffuse.a = 1.0f;//FRND(1.0f);
        m_light.Specular.r = vSpecular.x;
        m_light.Specular.g = vSpecular.y;
        m_light.Specular.b = vSpecular.z;
        m_light.Specular.a = 1.0f;
        m_light.Ambient.r = 0.0f;
        m_light.Ambient.g = 0.0f;
        m_light.Ambient.b = 0.0f;
        m_light.Ambient.a = 0.0f;
        m_light.Range = 1000.0f;
        m_light.Attenuation0 = 0.0f;
        m_light.Attenuation1 = 0.8f + (float)rand() / (float)RAND_MAX * 0.4f;
        m_light.Attenuation2 = 0.0f;
    }
    else {

        if (g_TestParams.bTextureBalls) {

	        m_material.Diffuse.r	= 0.5f;
	        m_material.Diffuse.g	= 0.5f;
	        m_material.Diffuse.b	= 0.5f;
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;
	        m_material.Ambient.g	= 0.25f;
	        m_material.Ambient.b	= 0.25f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
        else {

    	    // Create a random color for the material
	        do 
	        {
		        m_material.Diffuse.r	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.g	= (float)rand() / (float)RAND_MAX;
		        m_material.Diffuse.b	= (float)rand() / (float)RAND_MAX;
	        }
	        while ((m_material.Diffuse.r + m_material.Diffuse.g + m_material.Diffuse.b) < 1.0f);
	        m_material.Diffuse.a	= 1.0f;
	        m_material.Ambient.r	= 0.25f;//m_material.Diffuse.r * 0.4f;
	        m_material.Ambient.g	= 0.25f;//m_material.Diffuse.g * 0.4f;
	        m_material.Ambient.b	= 0.25f;//m_material.Diffuse.b * 0.4f;
	        m_material.Ambient.a	= 1.0f;
	        m_material.Specular.r	= 1.0f;
	        m_material.Specular.g	= 1.0f;
	        m_material.Specular.b	= 1.0f;
	        m_material.Specular.a	= 1.0f;
	        m_material.Emissive.r	= 0.0f;
	        m_material.Emissive.g	= 0.0f;
	        m_material.Emissive.b	= 0.0f;
	        m_material.Emissive.a	= 0.0f;
	        m_material.Power		= 32.0f;
        }
    }

	// Num verts and tris
	m_numVertices	= (numLong + 1) * numLat;
	m_numTriangles	= numLong * (numLat - 1) * 2;

    // Create the sphere vertex buffer
    hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 0, D3DPOOL_DEFAULT, &m_pVB);
	if(FAILED(hr))
	{
		return hr;
	}

	hr = pDevice->CreateIndexBuffer(m_numTriangles * 3 * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
        m_pVB->Release();
		return hr;
	}

    m_pVB->Lock(0, 0, (LPBYTE*)&vertices, 0);
	m_pIB->Lock(0, 0, (LPBYTE*)&indices, 0);

    // Create the sphere
    for (j = 0; j < numLat; j++) {

        fY = (float)(j) / (float)(numLat - 1);
        fSinY = (float)(sin(fY * M_PI));
        fCosY = (float)(cos(fY * M_PI));

        for (i = 0; i <= numLong; i++) {

            pr = &vertices[(numLong + 1) * j + i];
            fX = (float)(i) / (float)(numLong);
            fTX = fX * M_2PI;

            pr->vNormal.x = (float)(cos(fTX)) * fSinY;
            pr->vNormal.y = fCosY;
            pr->vNormal.z = (float)(sin(fTX)) * fSinY;
            pr->position.x = pr->vNormal.x * m_radius;
            pr->position.y = pr->vNormal.y * m_radius;
            pr->position.z = pr->vNormal.z * m_radius;
            pr->tu = fX * 2.0f;
            pr->tv = fY * 1.0f;
        }
    }

    for (j = 0; j < numLat - 1; j++) {

        for (i = 0; i < numLong; i++) {

            indices[index++] = (j + 1) * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
            indices[index++] = j * (numLong + 1) + i;
            indices[index++] = j * (numLong + 1) + i + 1;
            indices[index++] = (j + 1) * (numLong + 1) + i + 1;
        }
    }

    if (!bLight) {
        // Initialize the model to texture space transforms
        if (!ComputeTangentTransforms(vertices, indices, index, TRUE)) {
            m_pVB->Release();
            m_pIB->Release();
            return FALSE;
        }
    }

    m_pVB->Unlock();
    m_pIB->Unlock();

	m_dontDraw = FALSE;

	hr = InitAudio();
	if (FAILED( hr))
	{
		Release();
		delete [] indices;
		return hr;
	}

    // Create the base texture
    if (!m_pd3dtBase) {
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szBallBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the bump texture
    if (!m_pd3dtBump) {
        hr = CreateTextureFromHeightMap(pDevice, g_TestParams.szBallBumpTex, &m_pd3dtBump);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create the light texture
    if (!m_pd3dtLight) {
        hr = CreateLightTexture(pDevice, 128, &m_pd3dtLight);
        if (FAILED(hr)) {
            return hr;
        }
    }

    // Create a white texture
    if (!m_pd3dtWhite) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtWhite);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtWhite->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = 0xFFFFFFFF;
        m_pd3dtWhite->UnlockRect(0);
    }

    // Create a flat normal map
    if (!m_pd3dtFlat) {

        D3DLOCKED_RECT d3dlr;

        hr = pDevice->CreateTexture(1, 1, 0, 0, D3DFMT_X8R8G8B8, 0, &m_pd3dtFlat);
        if (FAILED(hr)) {
            return hr;
        }

        m_pd3dtFlat->LockRect(0, &d3dlr, NULL, 0);
        *((LPDWORD)d3dlr.pBits) = VectorToColor(&XGVECTOR3(0.0f, 0.0f, -1.0f));
        m_pd3dtFlat->UnlockRect(0);
    }

	return S_OK;
}

//------------------------------------------------------------------------------
//	CBall::SetPosition
//------------------------------------------------------------------------------
void 
CBall::SetPosition(
				   IN const XGVECTOR3& position
				   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::SetDirection
//------------------------------------------------------------------------------
void 
CBall::SetDirection(
					IN const XGVECTOR3& direction
					)
/*++

Routine Description:

	Sets the direction of the ball

Arguments:

	IN direction -	Direction

Return Value:

	None

--*/
{
	m_direction = direction;
}

//------------------------------------------------------------------------------
//	CBall::SetSpeed
//------------------------------------------------------------------------------
void 
CBall::SetSpeed(
				IN float speed
				)
				/*++

Routine Description:

	Sets the speed of the ball

Arguments:

	IN speed -	Speed

Return Value:

	None

--*/
{
	m_speed = speed;
}

//------------------------------------------------------------------------------
//	CBall::GetSpeed
//------------------------------------------------------------------------------
float 
CBall::GetSpeed(void) const
/*++

Routine Description:

	Returns the speed of the ball

Arguments:

	None

Return Value:

	The speed of the ball

--*/
{
	return m_speed;
}

//------------------------------------------------------------------------------
//	CBall::GetDirection
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetDirection(void) const
/*++

Routine Description:

	Returns the direction of the ball

Arguments:

	None

Return Value:

	Direction of the ball

--*/
{
	return m_direction;
}

//------------------------------------------------------------------------------
//	CBall::Move
//------------------------------------------------------------------------------
void
CBall::Move(
			IN float amount
			)
/*++

Routine Description:

	Updates the position of the ball by moving it amount

Arguments:

	IN amount -	Amount to move

Return Value:

	None

--*/
{
	XGVECTOR3	da = m_direction * amount;

	m_location += da;
	m_worldMatrix(3,0) += da.x;
	m_worldMatrix(3,1) += da.y;
	m_worldMatrix(3,2) += da.z;
	m_min = XGVECTOR3(m_location.x - m_radius, m_location.y - m_radius, m_location.z - m_radius);
	m_max = XGVECTOR3(m_location.x + m_radius, m_location.y + m_radius, m_location.z + m_radius);
    if (m_bLightSource) {
        m_light.Position.x = m_location.x;
        m_light.Position.y = m_location.y;
        m_light.Position.z = m_location.z;
    }
}

//------------------------------------------------------------------------------
//	CBall::GetRadius
//------------------------------------------------------------------------------
float 
CBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CBall::Render
//------------------------------------------------------------------------------
void
CBall::Render(
			  IN IDirect3DDevice8*	pDevice,
              IN XGMATRIX*          pmViewProj,
              IN XGVECTOR3*         pvEyePos,
              IN D3DLIGHT8*         pLight,
              IN D3DCOLORVALUE*     pdcvAmbient,
              IN UINT               uPass
			  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    XGMATRIX mBackWorld, mTransform;
    XGVECTOR3 vEyePos, vLightPos;
    static XGVECTOR3 vOrigin = XGVECTOR3(0.0f, 0.0f, 0.0f);

	if(m_dontDraw)
		return;

	// Vertex shader type
//	pDevice->SetVertexShader(XYZ_NORMAL);

	// Set the material
//	pDevice->SetMaterial(&m_material);

    if (!m_bLightSource) {

        // Set the transform
        XGMatrixMultiply(&mTransform, &m_worldMatrix, pmViewProj);
        XGMatrixTranspose(&mTransform, &mTransform);
        pDevice->SetVertexShaderConstant(0, &mTransform, 4);

        XGMatrixInverse(&mBackWorld, NULL, &m_worldMatrix);

        // Transform the eye position into model space
        XGVec3TransformCoord(&vEyePos, pvEyePos, &mBackWorld);
        pDevice->SetVertexShaderConstant(5, &vEyePos, 1);

        // Transform the light position into model space
        vLightPos.x = pLight->Position.x;
        vLightPos.y = pLight->Position.y;
        vLightPos.z = pLight->Position.z;
        XGVec3TransformCoord(&vLightPos, &vLightPos, &mBackWorld);
        pDevice->SetVertexShaderConstant(4, &vLightPos, 1);

        // Set the ambient-emissive term for lighting
        if (uPass) {
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, 0);
        }
        else {
            D3DCOLORVALUE dcvAmbientEmissive;
            dcvAmbientEmissive.r = m_material.Emissive.r + m_material.Ambient.r * pdcvAmbient->r;
            dcvAmbientEmissive.g = m_material.Emissive.g + m_material.Ambient.g * pdcvAmbient->g;
            dcvAmbientEmissive.b = m_material.Emissive.b + m_material.Ambient.b * pdcvAmbient->b;
            dcvAmbientEmissive.a = m_material.Emissive.a + m_material.Ambient.a * pdcvAmbient->a;
            if (dcvAmbientEmissive.r > 1.0f) dcvAmbientEmissive.r = 1.0f;
            if (dcvAmbientEmissive.g > 1.0f) dcvAmbientEmissive.g = 1.0f;
            if (dcvAmbientEmissive.b > 1.0f) dcvAmbientEmissive.b = 1.0f;
            if (dcvAmbientEmissive.a > 1.0f) dcvAmbientEmissive.a = 1.0f;
            pDevice->SetRenderState(D3DRS_PSCONSTANT0_3, (BYTE)(dcvAmbientEmissive.a * 255.0f) << 24 | 
                                                           (BYTE)(dcvAmbientEmissive.r * 255.0f) << 16 |
                                                           (BYTE)(dcvAmbientEmissive.g * 255.0f) << 8 |
                                                           (BYTE)(dcvAmbientEmissive.b * 255.0f));
        }

        pDevice->SetVertexShaderConstant(7, &pLight->Attenuation0, 1);
        pDevice->SetVertexShaderConstant(8, &XGVECTOR4(0.0f, 0.0f, 0.0f, pLight->Range), 1);
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_1, ModulateColors(&pLight->Diffuse, &m_material.Diffuse));
        pDevice->SetRenderState(D3DRS_PSCONSTANT1_1, ModulateColors(&pLight->Specular, &m_material.Specular));
        pDevice->SetRenderState(D3DRS_PSCONSTANT0_2, ModulateColors(&pLight->Ambient, &m_material.Ambient));

        // Draw opaque on the first pass, translucent on all subsequent passes
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, uPass ? TRUE : FALSE);

        if (g_TestParams.bTextureBalls) {
            pDevice->SetTexture(0, m_pd3dtBase);
            pDevice->SetTexture(1, m_pd3dtBump);
        }
        else {
            pDevice->SetTexture(0, m_pd3dtWhite);
            pDevice->SetTexture(1, m_pd3dtFlat);
        }

	    // Set the vertex buffer stream source
	    pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	    // Fill mode
	    pDevice->SetRenderState(D3DRS_FILLMODE, m_fillMode);

	    // Draw the object
	    pDevice->SetIndices(m_pIB, 0);
	    pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
							          m_numTriangles);
    }
    else {

	    // Set the translation
    	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

        pDevice->SetVertexShader(D3DFVF_XYZ);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_TFACTOR);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

        //Render black if we're not on beat, otherwise the light's real color.
        BOOL bRenderBlack= FALSE;
        if  (g_TestParams.bDMusic)
        {
            if (m_dwID % 4 != g_music.GetBeat())
                bRenderBlack = TRUE;
        };
        if (bRenderBlack)
            pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA((BYTE)(127.0f * m_light.Diffuse.r), (BYTE)(127.0f * m_light.Diffuse.g), (BYTE)(127.0f * m_light.Diffuse.b), (BYTE)(255.0f * m_light.Diffuse.a)));
        else
            pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, D3DCOLOR_RGBA((BYTE)(255.0f * m_light.Diffuse.r), (BYTE)(255.0f * m_light.Diffuse.g), (BYTE)(255.0f * m_light.Diffuse.b), (BYTE)(255.0f * m_light.Diffuse.a)));

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

        pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

        pDevice->SetTexture(3, m_pd3dtLight);

        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3));

        pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

        pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
        pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

        pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
        pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
        pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
    }

    RenderAudio();
}

//------------------------------------------------------------------------------
//	CBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CBall::GetNumTris
//------------------------------------------------------------------------------
int 
CBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CBall::GetLocation
//------------------------------------------------------------------------------
const XGVECTOR3&
CBall::GetLocation(void) const
/*++

Routine Description:

	Returns the location of the ball

Arguments:

	None

Return Value:

	The location of the ball

--*/
{
	return m_location;
}

//------------------------------------------------------------------------------
//	CBall::Release
//------------------------------------------------------------------------------
void
CBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}
/*
	if ( m_pCollisionSound )
	{
		m_pCollisionSound->Release();
		m_pCollisionSound = NULL;
	}

	if ( m_pAmbientSound )
	{
		m_pAmbientSound->Release();
		m_pAmbientSound = NULL;
	}

	if ( m_pSubMix )
	{
		m_pSubMix->Release();
		m_pSubMix = NULL;
	}

    if(m_pCollisionSoundData)
    {
        m_pCollisionSoundData->Release();
        m_pCollisionSoundData = NULL;
    }

    if(m_pAmbientSoundData)
    {
        m_pAmbientSoundData->Release();
        m_pAmbientSoundData = NULL;
    }
*/
}

//------------------------------------------------------------------------------
//	CBall::InitAudio
//------------------------------------------------------------------------------
HRESULT
CBall::InitAudio( void )
/*++

Routine Description:

	Init the sound buffer

Arguments:

	None

Return Value:

	S_OK, E_XXXX

--*/
{	
    HRESULT                 hr  = DS_OK;

    if(m_bLightSource && g_TestParams.b3DSound)
    {
		if(g_TestParams.bSubMixBallSound)
		{
			hr = CreateSubMixDestination();
		}

        if(SUCCEEDED(hr) && g_TestParams.bLightSound)
        {
            hr = CreateAmbientSound();
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = CreateCollisionSound();
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CBall::CreateSubMixDestination
//------------------------------------------------------------------------------
HRESULT
CBall::CreateSubMixDestination( void )
{
    DSBUFFERDESC            dsbd;
    HRESULT                 hr;

    ASSERT(!m_pSubMix);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwFlags = DSBCAPS_MIXIN;

    if(g_TestParams.b3DSound)
    {
        dsbd.dwFlags |= DSBCAPS_CTRL3D;
    }

//    return DirectSoundCreateBuffer(&dsbd, &m_pSubMix);
    return S_OK;
}

//------------------------------------------------------------------------------
//	CBall::CreateCollisionSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateCollisionSound( void )
{
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwAudioDataSize;
    HRESULT                 hr;

    return S_OK;
    /*

    ASSERT(!m_pCollisionSound);
    ASSERT(!m_pCollisionSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pCollisionSoundData = &m_CollisionSoundData;
    hr = m_pCollisionSoundData->CreateFile(g_TestParams.szBounceSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);

    if(SUCCEEDED(hr))
    {
        m_dwCollisionFrequency = dsbd.lpwfxFormat->nSamplesPerSec;
        
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pCollisionSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pCollisionSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pCollisionSound->SetOutputBuffer(m_pSubMix);
    }

    if(FAILED(hr) && m_pCollisionSound)
    {
        m_pCollisionSound->Release();
        m_pCollisionSound = NULL;
    }

    return hr;
    */
}

//------------------------------------------------------------------------------
//	CBall::CreateAmbientSound
//------------------------------------------------------------------------------
HRESULT
CBall::CreateAmbientSound( void )
{
    WAVEFORMATEX            wfx;
    DSBUFFERDESC            dsbd;
    DSMIXBINS               dsmixbins;
    LPVOID                  pvAudioData;
    DWORD                   dwSampleCount;
    DWORD                   dwAudioDataSize;
    BOOL                    fInit;
    DSLFODESC               lfo;
    HRESULT                 hr;
    int                     i;

    return S_OK;
    /*

    ASSERT(!m_pAmbientSound);
    ASSERT(!m_pAmbientSoundData);

    ZeroMemory(&dsbd, sizeof(dsbd));
    ZeroMemory(&lfo, sizeof(lfo));

    dsbd.dwSize = sizeof(dsbd);
    dsbd.dwFlags = DSBCAPS_LOCDEFER;

    m_pAmbientSoundData = &m_AmbientSoundData;

    if(g_TestParams.szLightSound[0])
    {
        hr = m_pAmbientSoundData->CreateFile(g_TestParams.szLightSound, (LPCWAVEFORMATEX *)&dsbd.lpwfxFormat, &pvAudioData, &dwAudioDataSize);
    }
    else
    {
        wfx.wFormatTag = WAVE_FORMAT_PCM;
        wfx.nChannels = 1;
        wfx.nSamplesPerSec = AMBIENT_SOUND_FREQUENCY;
        wfx.wBitsPerSample = 16;
        wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
        wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
        wfx.cbSize = 0;
    
        dsbd.lpwfxFormat = &wfx;

        dwSampleCount = 128;
        dwAudioDataSize = dwSampleCount * wfx.nBlockAlign;
    
        hr = m_pAmbientSoundData->CreateEmpty(&wfx, dwAudioDataSize, &pvAudioData, &fInit);

        if(SUCCEEDED(hr) && fInit)
        {
            for(i = 0; i < (int)dwSampleCount; i++)
            {
                *((short *)pvAudioData + i) = (short)(65536 * ((float)(i - (dwSampleCount / 2)) / (FLOAT)dwSampleCount));
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        if(m_pSubMix)
        {
            dsmixbins.dwMixBinCount = 0;
            dsbd.lpMixBins = &dsmixbins;
        }
        else if(g_TestParams.b3DSound)
        {
            dsbd.dwFlags |= DSBCAPS_CTRL3D;
        }

        hr = DirectSoundCreateBuffer(&dsbd, &m_pAmbientSound);
    }

    if(SUCCEEDED(hr))
    {
        hr = m_pAmbientSound->SetBufferData(pvAudioData, dwAudioDataSize);
    }

    if(SUCCEEDED(hr) && m_pSubMix)
    {
        hr = m_pAmbientSound->SetOutputBuffer(m_pSubMix);
    }

    if(SUCCEEDED(hr))
    {
        lfo.dwLFO = DSLFO_MULTI;
        lfo.dwDelta = 200;
        lfo.lPitchModulation = 64;
        lfo.lAmplitudeModulation = 48;

        hr = m_pAmbientSound->SetLFO(&lfo);
    }

    if(FAILED(hr) && m_pAmbientSound)
    {
        m_pAmbientSound->Release();
        m_pAmbientSound = NULL;
    }

    return hr;
    */
}

//------------------------------------------------------------------------------
//	CBall::GetLight
//------------------------------------------------------------------------------
D3DLIGHT8*
CBall::GetLight( void )
{
  
    if (g_TestParams.bDMusic)
    {
        if (m_dwID % 4 != g_music.GetBeat())
        {
          m_lightDark = m_light;
          m_lightDark.Diffuse.r = m_light.Diffuse.r * 0.5f;
          m_lightDark.Diffuse.g = m_light.Diffuse.g * 0.5f;
          m_lightDark.Diffuse.b = m_light.Diffuse.b * 0.5f;
          m_lightDark.Diffuse.a = 1.0f;//FRND(1.0f);
          m_lightDark.Specular.r = m_light.Specular.r * 0.5f;
          m_lightDark.Specular.g = m_light.Specular.g * 0.5f;
          m_lightDark.Specular.b = m_light.Specular.b * 0.5f;
          m_lightDark.Specular.a = 1.0f;
          return &m_lightDark;
        }
    }
    
    return &m_light;
}

//------------------------------------------------------------------------------
//	CBall::PlayBuffer
//------------------------------------------------------------------------------
void
CBall::PlayBuffer(
				  IN float	volume,
				  IN float	pitch
				  )
/*++

Routine Description:

	Play the sound Buffer

Arguments:

	IN volume	- Volume (0.0 - 1.0)
	IN pitch	- Pitch (0.0 - 1.0)

Return Value:

	None

--*/
{
    static const DWORD      dwVolumeRange   = 3000; // 0-30dB
    static const DWORD      dwPitchRange    = 4; // +/-2 octaves
    const LONG              lGlobalVolume   = g_TestParams.lDSVolume;
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalVolume;
    LONG                    lLocalPitch;

    return;
    /*
    
    lLocalVolume = (LONG)-((1.0f - volume) * (FLOAT)dwVolumeRange);
    lLocalPitch = (LONG)((0.5f - pitch) * (FLOAT)dwPitchRange) << 12;

	if(m_pCollisionSound)
	{
        if(!m_pSubMix)
        {
		    lLocalVolume += lGlobalVolume;
            lLocalPitch += lGlobalPitch;
        }
            
        if(lLocalVolume > DSBVOLUME_MAX)
        {
            lLocalVolume = DSBVOLUME_MAX;
        }
        else if(lLocalVolume < DSBVOLUME_MIN)
        {
            lLocalVolume = DSBVOLUME_MIN;
        }
        
        m_pCollisionSound->SetVolume(lLocalVolume);

        if(lLocalPitch > DSBPITCH_MAX)
        {
            lLocalPitch = DSBPITCH_MAX;
        }
        else if(lLocalPitch < DSBPITCH_MIN)
        {
            lLocalPitch = DSBPITCH_MIN;
        }

		m_pCollisionSound->SetPitch(lLocalPitch);

        if(!m_pSubMix && g_TestParams.b3DSound)
        {
            m_pCollisionSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
        }

		m_pCollisionSound->Play(0, 0, DSBPLAY_FROMSTART);
	}
*/
}

//------------------------------------------------------------------------------
//	CBall::RenderAudio
//------------------------------------------------------------------------------
void
CBall::RenderAudio(void)
{
    const LONG              lGlobalPitch    = CalculatePitch(g_TestParams.dwDSFreq);
    LONG                    lLocalPitch;

    return;
/*
    
    if(m_pSubMix)
    {
        m_pSubMix->SetVolume(g_TestParams.lDSVolume);
        m_pSubMix->SetPitch(lGlobalPitch);

        if(g_TestParams.b3DSound)
        {
            m_pSubMix->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
            m_pSubMix->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
        }
    }

    if(m_pAmbientSound)
    {
        if(m_pSubMix)
        {
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume);
        }
        else
        {
            lLocalPitch = CalculatePitch(AMBIENT_SOUND_FREQUENCY);
            
            m_pAmbientSound->SetVolume(g_TestParams.lAmbientVolume + g_TestParams.lDSVolume);
            m_pAmbientSound->SetPitch(lLocalPitch + lGlobalPitch);

            if(g_TestParams.b3DSound)
            {
                m_pAmbientSound->SetPosition(m_location.x, m_location.y, m_location.z, DS3D_DEFERRED);
                m_pAmbientSound->SetVelocity(m_direction.x, m_direction.y, m_direction.z, DS3D_DEFERRED);
            }
        }

        m_pAmbientSound->Play(0, 0, DSBPLAY_LOOPING);
    }
*/
}

//------------------------------------------------------------------------------
//	CBall::DisableAmbientAudio
//------------------------------------------------------------------------------
void
CBall::DisableAmbientAudio(void)
{
    if(m_pAmbientSound)
    {
        m_pAmbientSound->Stop();
    }
}

//------------------------------------------------------------------------------
//	CBall::DrawSolid
//------------------------------------------------------------------------------
void 
CBall::DrawSolid(void)
/*++

Routine Description:

	Sets the render state of the ball to render solid

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_SOLID;
}

//------------------------------------------------------------------------------
//	CBall::DrawWireframe
//------------------------------------------------------------------------------
void 
CBall::DrawWireframe(void)
/*++

Routine Description:

	Sets the render state of the ball to render wireframe

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_WIREFRAME;
}

//------------------------------------------------------------------------------
//	CBall::DrawPoints
//------------------------------------------------------------------------------
void 
CBall::DrawPoints(void)
/*++

Routine Description:

	Sets the render state of the ball to render as points

Arguments:

	None

Return Value:

	None

--*/
{
	m_fillMode = D3DFILL_POINT;
}

//------------------------------------------------------------------------------
//	CBall::DrawReduced
//------------------------------------------------------------------------------
void
CBall::DrawReduced(void)
/*++

Routine Description:

	Draws in a reduced mode based on the level of detail

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_detail > 16)
		DrawPoints();
	else
		DrawWireframe();
}

//******************************************************************************
void CBall::PlaceLightInRange(UINT uLight, BOOL bInRange) {

    DWORD dwLight;
    UINT index;

    for (index = 0; uLight > 31; uLight -= 32, index++);

    if (index > 4) {
        // Light index exceeds the maximum
        __asm int 3;
        return;
    }

    if (bInRange) {
        m_dwInLightRange[index] |= (1 << uLight);
    }
    else {
        m_dwInLightRange[index] &= ~(1 << uLight);
    }
}

//******************************************************************************
HRESULT CBall::CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, LPCSTR szImage, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dtHeight, *pd3dt;
    D3DSURFACE_DESC d3dsd;
    D3DLOCKED_RECT d3dlr;
    float* pfHeightMap, *pfHeight;
    LPDWORD pdwPixel;
    UINT i, x, y, uCount;
    XGVECTOR3 v1, v2, n;
    HRESULT hr;

    if (!ppd3dt) {   
        return E_FAIL;
    }

    *ppd3dt = NULL;

    hr = D3DXCreateTextureFromFileEx(pDevice, szImage, D3DX_DEFAULT, D3DX_DEFAULT, 
                                D3DX_DEFAULT, 0, D3DFMT_X8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &pd3dtHeight);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dtHeight->GetLevelDesc(0, &d3dsd);

    // Create the bump map
    hr = pDevice->CreateTexture(d3dsd.Width, d3dsd.Height, 0, 0, D3DFMT_X8R8G8B8, 0, &pd3dt);
    if (!pd3dt) {
        pd3dtHeight->Release();
        return hr;
    }

    pfHeightMap = (float*)HeapAlloc(GetProcessHeap(), 0, d3dsd.Width * d3dsd.Height * sizeof(float));
    if (!pfHeightMap) {
        pd3dtHeight->Release();
        pd3dt->Release();
        return E_OUTOFMEMORY;
    }

    uCount = pd3dtHeight->GetLevelCount();

    for (i = 0; i < uCount; i++) {

        pd3dtHeight->GetLevelDesc(i, &d3dsd);

        // Convert the pixel intensities in the source image into height values
        // ranging from 0.0 to 1.0
        pd3dtHeight->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        Swizzler swz(d3dsd.Width, d3dsd.Height, 1);
        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                pfHeightMap[y * d3dsd.Width + x] = 
                       (float)(((pdwPixel[swz.Get2D()] >> 16) & 0xFF) +
                               ((pdwPixel[swz.Get2D()] >> 8)  & 0xFF) +
                               ((pdwPixel[swz.Get2D()])       & 0xFF)) / 3.0f / 255.0f;
                swz.IncU();
            }

//            pdwPixel += d3dlr.Pitch >> 2;
            swz.IncV();
        }

        pd3dtHeight->UnlockRect(i);

        // Calculate normal map vectors from the height map information
        pd3dt->LockRect(i, &d3dlr, NULL, 0);

        pdwPixel = (LPDWORD)d3dlr.pBits;

        v1 = XGVECTOR3(0.0f, 0.0f, 0.0f);
        v2 = XGVECTOR3(0.0f, 0.0f, 0.0f);

        swz.SetU(0);
        swz.SetV(0);

        for (y = 0; y < d3dsd.Height; y++) {

            for (x = 0; x < d3dsd.Width; x++) {

                // Tiled
                pfHeight = &pfHeightMap[y * d3dsd.Width + x];
                if (y == d3dsd.Height - 1) {
                    v2.z = -(pfHeightMap[x] - *pfHeight);
                }
                else {
                    v2.z = -(pfHeight[d3dsd.Width] - pfHeight[0]);
                }
                if (x == d3dsd.Width - 1) {
                    v1.z = -(*(pfHeight - x) - *pfHeight);
                }
                else {
                    v1.z = -(pfHeight[1] - pfHeight[0]);
                }
                v1.x = (float)sqrt(1.0f - v1.z * v1.z);
                v2.y = (float)sqrt(1.0f - v2.z * v2.z);
                XGVec3Cross(&n, &v2, &v1);
                XGVec3Normalize(&n, &n);
                pdwPixel[swz.Get2D()] = VectorToColor(&n);

                swz.IncU();
            }

            swz.IncV();
        }

        pd3dt->UnlockRect(i);
    }

    HeapFree(GetProcessHeap(), 0, pfHeightMap);
    pd3dtHeight->Release();

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
HRESULT CBall::CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, IDirect3DTexture8** ppd3dt) {

    IDirect3DTexture8* pd3dt;
    D3DLOCKED_RECT d3dlr;
    LPDWORD pdwTexel;
    D3DXVECTOR3 vNormal, vCenter, vUp;
    float fRadius, fRadiusSq;
    BYTE Intensity;
    UINT i, j;
    HRESULT hr;
    Swizzler swz(uLength, uLength, 1);

    if (!ppd3dt) {
        return FALSE;
    }

    *ppd3dt = NULL;

    hr = pDevice->CreateTexture(uLength, uLength, 0, 0, D3DFMT_A8R8G8B8, 0, &pd3dt);
    if (FAILED(hr)) {
        return hr;
    }

    pd3dt->LockRect(0, &d3dlr, NULL, 0);
    pdwTexel = (LPDWORD)d3dlr.pBits;
    fRadius = (float)(uLength / 2);
    fRadiusSq = fRadius * fRadius;
    vCenter = D3DXVECTOR3(fRadius + 0.5f, fRadius + 0.5f, 0.0f);
    vUp = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    swz.SetU(0);
    swz.SetV(0);

    for (i = 0; i < uLength; i++) {

        for (j = 0; j < uLength; j++) {

            vNormal = D3DXVECTOR3((float)j, (float)i, 0.0f) - vCenter;
            if (D3DXVec3Length(&vNormal) < fRadius) {
                vNormal.z = (float)sqrt(fRadiusSq - vNormal.x * vNormal.x - vNormal.y * vNormal.y);
                D3DXVec3Normalize(&vNormal, &vNormal);
                Intensity = (BYTE)(D3DXVec3Dot(&vNormal, &vUp) * 255.0f);
                pdwTexel[swz.Get2D()] = D3DCOLOR_RGBA(Intensity, Intensity, Intensity, Intensity);
            }
            else {
                pdwTexel[swz.Get2D()] = 0;
            }

            swz.IncU();
        }

        swz.IncV();
    }

    pd3dt->UnlockRect(0);

    *ppd3dt = pd3dt;

    return D3D_OK;
}

//******************************************************************************
// Calculate non-normalized tangent and binormal vector terms for use in
// constructing an othonormal basis transform to rotate a vector from model
// space to tangent space.
//******************************************************************************
BOOL CBall::CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                                            Vertex* prVertices, LPWORD pwIndices, 
                                            UINT uNumIndices, BOOL bInterpolate)
{
    XGVECTOR3       vEdge0, vEdge1, vTemp;
    XGVECTOR3       vPlane[3];
    WORD            w0, w1, w2;
    float           fTemp;
    UINT            i, j, k;

    memset(pvTangent, 0, uNumIndices * sizeof(XGVECTOR3));
    memset(pvBinormal, 0, uNumIndices * sizeof(XGVECTOR3));

    // Calculate the tangent and binormal vectors for each vertex.  If the vertex is
    // indexed by more than one triangle, add the vectors for each triangle together
    // to obtain an average of the vectors for all triangles formed by the vertex.
    for (i = 0; i < uNumIndices; i+=3) {

        w0 = pwIndices[i];
        w1 = pwIndices[i+1];
        w2 = pwIndices[i+2];

        vEdge0 = XGVECTOR3(prVertices[w1].position.x - prVertices[w0].position.x, prVertices[w1].tu - prVertices[w0].tu, prVertices[w1].tv - prVertices[w0].tv);
        vEdge1 = XGVECTOR3(prVertices[w2].position.x - prVertices[w0].position.x, prVertices[w2].tu - prVertices[w0].tu, prVertices[w2].tv - prVertices[w0].tv);
        XGVec3Cross(&vPlane[0], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.y - prVertices[w0].position.y;
        vEdge1.x = prVertices[w2].position.y - prVertices[w0].position.y;
        XGVec3Cross(&vPlane[1], &vEdge0, &vEdge1);
        vEdge0.x = prVertices[w1].position.z - prVertices[w0].position.z;
        vEdge1.x = prVertices[w2].position.z - prVertices[w0].position.z;
        XGVec3Cross(&vPlane[2], &vEdge0, &vEdge1);

        if (FABS(vPlane[0].x) < 0.000000001f || FABS(vPlane[1].x) < 0.000000001f || FABS(vPlane[2].x) < 0.000000001f) {
            return FALSE;
        }

        vTemp = XGVECTOR3(-vPlane[0].y / vPlane[0].x, -vPlane[1].y / vPlane[1].x, -vPlane[2].y / vPlane[1].x);
        pvTangent[w0] += vTemp;
        pvTangent[w1] += vTemp;
        pvTangent[w2] += vTemp;

        vTemp = XGVECTOR3(-vPlane[0].z / vPlane[0].x, -vPlane[1].z / vPlane[1].x, -vPlane[2].z / vPlane[1].x);
        pvBinormal[w0] += vTemp;
        pvBinormal[w1] += vTemp;
        pvBinormal[w2] += vTemp;
    }

    if (bInterpolate) {

        LPWORD          pwMerge, pwProcessed;
        UINT            uNumMerges, uNumProcessed = 0;

        pwMerge = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwMerge) {
            return FALSE;
        }

        pwProcessed = (LPWORD)HeapAlloc(GetProcessHeap(), 0, uNumIndices * sizeof(WORD));
        if (!pwProcessed) {
            HeapFree(GetProcessHeap(), 0, pwMerge);
            return FALSE;
        }

        for (i = 0; i < uNumIndices; i++) {

            // Verify pwIndices[i] has to already been processed...if it has continue
            for (j = 0; j < uNumProcessed; j++) {
                if (pwIndices[i] == pwProcessed[j]) {
                    break;
                }
            }
            if (j < uNumProcessed) {
                continue;
            }

            pwMerge[0] = pwIndices[i];
            pwProcessed[uNumProcessed++] = pwIndices[i];
            uNumMerges = 1;

            // Traverse the vertex list, identifying all vertices whose positions are
            // equal to the current vertex position
            for (j = i + 1; j < uNumIndices; j++) {

                fTemp = XGVec3LengthSq(&(prVertices[pwIndices[i]].position - prVertices[pwIndices[j]].position));
                if (fTemp < 0.0000001f) {

                    // See whether the matching vertex has already been added to the merge list
                    for (k = 0; k < uNumMerges; k++) {
                        if (pwIndices[j] == pwMerge[k]) {
                            break;
                        }
                    }
                    if (k == uNumMerges) {
                        pwMerge[uNumMerges++] = pwIndices[j];
                        pwProcessed[uNumProcessed++] = pwIndices[j];
                    }
                }
            }

            if (uNumMerges > 1 && uNumMerges < 5) {
                w0 = pwMerge[0];
                XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
                XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);
                for (j = 1; j < uNumMerges; j++) {
                    w1 = pwMerge[j];
                    XGVec3Normalize(&pvTangent[w1], &pvTangent[w1]);
                    XGVec3Normalize(&pvBinormal[w1], &pvBinormal[w1]);
                    pvTangent[w0] += pvTangent[w1];
                    pvBinormal[w0] += pvBinormal[w1];
                }
                for (j = 1; j < uNumMerges; j++) {
                    pvTangent[pwMerge[j]] = pvTangent[w0];
                    pvBinormal[pwMerge[j]] = pvBinormal[w0];
                }
            }
        }

        HeapFree(GetProcessHeap(), 0, pwProcessed);
        HeapFree(GetProcessHeap(), 0, pwMerge);
    }

    return TRUE;
}

//******************************************************************************
BOOL CBall::ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, UINT uNumIndices, BOOL bInterpolate) {

    XGVECTOR3       vNormal, vTemp;
    XGVECTOR3       *pvTangent, *pvBinormal;
    WORD            w0;
    XGVECTOR3*      pmT;
    XGVECTOR3       mZero[3];
	UINT            i;

    memset(&mZero, 0, 3 * sizeof(XGVECTOR3));

    for (i = 0; i < uNumIndices; i++) {
        memcpy((LPBYTE)&prVertices[pwIndices[i]].vTangent.x, &mZero, 3 * sizeof(XGVECTOR3));
    }

    pvTangent = (XGVECTOR3*)HeapAlloc(GetProcessHeap(), 0, 2 * uNumIndices * sizeof(XGVECTOR3));
    if (!pvTangent) {
        return FALSE;
    }
    pvBinormal = pvTangent + uNumIndices;

    if (!CalculateTangentTerms(pvTangent, pvBinormal, prVertices, pwIndices, uNumIndices, bInterpolate)) {
        HeapFree(GetProcessHeap(), 0, pvTangent);
        return FALSE;
    }

    for (i = 0; i < uNumIndices; i++) {

        w0 = pwIndices[i];
        pmT = (XGVECTOR3*)((LPBYTE)&prVertices[w0].vTangent.x);
        if (!memcmp(pmT, &mZero, 3 * sizeof(XGVECTOR3))) {

            XGVec3Normalize(&pvTangent[w0], &pvTangent[w0]);
            XGVec3Normalize(&pvBinormal[w0], &pvBinormal[w0]);

            XGVec3Cross(&vNormal, &pvTangent[w0], &pvBinormal[w0]);

            pmT[0].x = -pvTangent[w0].x;
            pmT[0].y = -pvTangent[w0].y;
            pmT[0].z = -pvTangent[w0].z;

            pmT[1].x = -pvBinormal[w0].x;
            pmT[1].y = -pvBinormal[w0].y;
            pmT[1].z = -pvBinormal[w0].z;

            pmT[2].x = vNormal.x;
            pmT[2].y = vNormal.y;
            pmT[2].z = vNormal.z;
        }
    }

    HeapFree(GetProcessHeap(), 0, pvTangent);

    return TRUE;
}

//------------------------------------------------------------------------------
//	CBall::IsLightSource
//------------------------------------------------------------------------------
BOOL 
CBall::IsLightSource(void) const
/*++

Routine Description:

	Returns TRUE if the ball is a light source, FALSE otherwise

Arguments:

	None

Return Value:

	TRUE if the ball is a light source, FALSE otherwise

--*/
{
	return m_bLightSource;
}
}

//------------------------------------------------------------------------------
//	CBall::CalculatePitch
//------------------------------------------------------------------------------

LONG
CBall::CalculatePitch
(
    DWORD                   dwFrequency
)
{
    static const DWORD      dwBaseFrequency = 48000;
    FLOAT                   fl4096          = 4096.0f;
    FLOAT                   flRatio         = (FLOAT)dwFrequency / (FLOAT)dwBaseFrequency;
    LONG                    lPitch;

    if(dwBaseFrequency == dwFrequency)
    {
        lPitch = 0;
    }
    else if(!dwFrequency)
    {
        lPitch = DSBPITCH_MIN;
    }
    else
    {
        __asm 
        {
            fld     fl4096
            fld     flRatio
            fyl2x
            fistp   lPitch
        }
    }

    return lPitch;
}

//------------------------------------------------------------------------------
//	CAudioData::CAudioData
//------------------------------------------------------------------------------

CAudioData::CAudioData(void)
{
    m_pwfxFormat = NULL;
    m_pvAudioData = NULL;
    m_dwAudioDataSize = NULL;
    m_dwRefCount = 0;
}

//------------------------------------------------------------------------------
//	CAudioData::~CAudioData
//------------------------------------------------------------------------------

CAudioData::~CAudioData(void)
{
    if(m_pwfxFormat)
    {
        delete [] m_pwfxFormat;
    }

    if(m_pvAudioData)
    {
        delete [] m_pvAudioData;
    }
}

//------------------------------------------------------------------------------
//	CAudioData::CreateFile
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize)
{
    LPXFILEMEDIAOBJECT      pFile       = NULL;
    HRESULT                 hr          = DS_OK;
    LPCWAVEFORMATEX         pwfxFormat;
    XMEDIAPACKET            xmp;

    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        hr = XWaveFileCreateMediaObject(pszFile, &pwfxFormat, &pFile);

        if(SUCCEEDED(hr))
        {
            if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            hr = pFile->GetLength(&m_dwAudioDataSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }

        if(SUCCEEDED(hr))
        {
            ZeroMemory(&xmp, sizeof(xmp));

            xmp.pvBuffer = m_pvAudioData;
            xmp.dwMaxSize = m_dwAudioDataSize;
            
            hr = pFile->Process(NULL, &xmp);
        }

        if(pFile)
        {
            pFile->Release();
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppwfxFormat = m_pwfxFormat;
        *ppvAudioData = m_pvAudioData;
        *pdwAudioDataSize = m_dwAudioDataSize;
    }

    return hr;
}

//------------------------------------------------------------------------------
//	CAudioData::CreateEmpty
//------------------------------------------------------------------------------

HRESULT
CAudioData::CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize)
{
    HRESULT                 hr  = DS_OK;
    
    if(!m_dwRefCount)
    {
        ASSERT(!m_pwfxFormat);
        ASSERT(!m_pvAudioData);
        ASSERT(!m_dwAudioDataSize);

        m_dwAudioDataSize = dwAudioDataSize;

        if(!(m_pwfxFormat = (LPWAVEFORMATEX)new BYTE [sizeof(*pwfxFormat) + pwfxFormat->cbSize]))
        {
            hr = DSERR_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {
            CopyMemory(m_pwfxFormat, pwfxFormat, sizeof(*pwfxFormat) + pwfxFormat->cbSize);
        }

        if(SUCCEEDED(hr))
        {
            if(!(m_pvAudioData = new BYTE [m_dwAudioDataSize]))
            {
                hr = DSERR_OUTOFMEMORY;
            }
        }
    }

    if(SUCCEEDED(hr))
    {
        ASSERT(m_pwfxFormat);
        ASSERT(m_pvAudioData);
        ASSERT(m_dwAudioDataSize);
        
        AddRef();

        *ppvAudioData = m_pvAudioData;
        *pfInitialize = (1 == m_dwRefCount);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\waveinfo\waveinfo.cpp ===
#include <xtl.h>
#include <WaveLdr.h>
#include <DbgTrace.h>

void __stdcall wWinMain ( 
	HINSTANCE hInstance, 
	HINSTANCE hPrevInstance, 
	LPTSTR lpCmdLine, 
	int nCmdShow 
) 
{

	BOOL			bDone					= TRUE;
	HRESULT			hr						= S_OK;

	TCHAR			tszFullPath[MAX_PATH];
	TCHAR			tszInfo[MAX_PATH];
	CWaveFile		waveFile;
	WAVEFORMATEX	wavFormat;
	WIN32_FIND_DATA findFileData;
	DWORD			dwDuration;
	DWORD			dwAmount;
	DWORD			dwNumWritten;
	HANDLE			hFileList;
	HANDLE			hFile;
	float			fDuration;

	DBGTRACE( TEXT( "Starting app" ) );

	hFile = CreateFile( TEXT( "t:\\media\\bvt\\format.log" ),
						GENERIC_WRITE,
						0,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL );

	hFileList = FindFirstFile( TEXT( "t:\\media\\bvt\\*.wav" ), &findFileData );

	while ( INVALID_HANDLE_VALUE != hFile && 
		    INVALID_HANDLE_VALUE != hFileList && 
			TRUE == bDone && 
			SUCCEEDED( hr ) ) 
	{

		wsprintf( tszFullPath, TEXT( "t:\\media\\bvt\\%s" ), findFileData.cFileName );

		hr = waveFile.Open( tszFullPath );
		
		if ( SUCCEEDED( hr ) ) 
		{
			hr = waveFile.GetFormat( &wavFormat, sizeof( WAVEFORMATEX ), &dwAmount );
		}

		if ( SUCCEEDED( hr ) ) 
		{
			hr = waveFile.GetDuration( &dwDuration );
		}

		if ( SUCCEEDED( hr ) ) 
		{
			fDuration = (float) dwDuration / (float) ( wavFormat.nSamplesPerSec * wavFormat.wBitsPerSample * wavFormat.nChannels / 8 );

			swprintf( tszInfo,  
				      TEXT( "File: %11s " )				\
					  TEXT( "Duration: %10f " )			\
					  TEXT( "Samples per sec: %6u " )	\
					  TEXT( "Bits Per sample: %3u " )	\
					  TEXT( "Num channels: %u\r\n"  ), 
					  findFileData.cFileName, 
					  fDuration, 
					  wavFormat.nSamplesPerSec, 
					  wavFormat.wBitsPerSample, 
					  wavFormat.nChannels );

			bDone = WriteFile( hFile, 
							   (void*) tszInfo, 
							   sizeof( TCHAR ) * wcslen( tszInfo ),
							   &dwNumWritten,
							   NULL );

			if ( bDone ) {
				bDone = FindNextFile( hFileList, &findFileData );
			}
		}
	}
	
	if ( INVALID_HANDLE_VALUE != hFileList )
		FindClose( hFileList );

	if ( INVALID_HANDLE_VALUE != hFile )
		CloseHandle( hFile );
	
	DBGTRACE( TEXT( "Ending app" ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\stress\mmstress.cpp ===
#include <xtl.h>
#include <dsutil.h>

HRESULT MMStress( void )
{
	HRESULT hr;
	WIN32_FIND_DATA findData;
	BOOL bMore;
	HANDLE hFiles;

	CHAR szFullName[MAX_PATH];
	LPSTR szFiles = NULL;

	int iRand = 0;
	int iRand2 = 0;

	while ( true )
	{
	   	bMore = TRUE;

		iRand2 = rand() % 2;

		hFiles = FindFirstFile( 0 == iRand2 ? DVD_FILES : WMA_FILES, &findData );

		while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore )
		{
			iRand = rand() % 4;

            //
            // added checking code to see if findfirst/next or printf is giving 
            // us a null pointer. yes, it is overkill.
            //     

            //
            // looking for a stress failure where it appears we pass a NULL 
            // pointer from here
            //
            
            if (NULL == findData.cFileName) {
                OutputDebugStringA("NULL == findData.cFileName - send email to xstress!\n");
                DebugBreak();
            }
			
            sprintf( szFullName, "%s\\%s", 0 == iRand2 ? DVD_DRIVE : WMA_DRIVE, findData.cFileName );

            //
            // looking for a stress failure where it appears we pass a NULL 
            // pointer from here
            //

            if (NULL == szFullName) {
                OutputDebugStringA("NULL == szFullName - send email to xstress!\n");
                DebugBreak();
            }

			if ( 0 == iRand2 )
				hr = PlayOneFile( szFullName, (PLAY_MODE) iRand, true );
			else
				hr = PlayWmaFile( szFullName );

			bMore = FindNextFile( hFiles, &findData );
		}

		if ( INVALID_HANDLE_VALUE != hFiles )
			FindClose( hFiles );
	}

	return hr;
}

VOID WINAPI MMStressStartTest( HANDLE LogHandle )
{
	SETLOG( LogHandle, "danrose", "Multimedia", "Stress", "StartTest" );

	HRESULT hr = S_OK;

	EXECUTE( MMStress(); );
}

VOID WINAPI MMStressEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mmStress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mmStress )
    EXPORT_TABLE_ENTRY( "StartTest", MMStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MMStressEndTest )
END_EXPORT_TABLE( mmStress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

namespace WFVO {

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};
}
#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Camera.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Camera.cpp

Abstract:

	Camera for D3D viewing

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "Camera.h"

using namespace WFVO;

namespace WFVO {

//------------------------------------------------------------------------------
//	CCamera::CCamera
//------------------------------------------------------------------------------
CCamera::CCamera(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	D3DLIGHT8	light;

	// Default viewport
	m_viewport.X		= 0;
	m_viewport.Y		= 0;
	m_viewport.Width	= 640;
	m_viewport.Height	= 480;
	m_viewport.MinZ		= 0.0f;
	m_viewport.MaxZ		= 1.0f;

	// View matrix
	XGMatrixIdentity(&m_viewMatrix);

	// Projection matrix
	XGMatrixIdentity(&m_projectionMatrix);

	// light
	light.Type			= D3DLIGHT_DIRECTIONAL;
    light.Diffuse.r		= 1.0f;
    light.Diffuse.g		= 1.0f;
    light.Diffuse.b		= 1.0f;
    light.Diffuse.a		= 1.0f;
    light.Specular.r	= 1.0f;
    light.Specular.g	= 1.0f;
    light.Specular.b	= 1.0f;
    light.Specular.a	= 1.0f;
    light.Ambient.r		= 1.0f;
    light.Ambient.g		= 1.0f;
    light.Ambient.b		= 1.0f;
    light.Ambient.a		= 1.0f;
    light.Direction.x	= 0.0f;
    light.Direction.y	= 0.0f;
    light.Direction.z	= 1.0f;
    light.Range			= 1000.0f;
	SetLight(0, light);

	// Other parameters
	m_focalPoint		= XGVECTOR3(0.0f, 0.0f, 0.0f);
	m_position			= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_viewUp			= XGVECTOR3(0.0f, 1.0f, 0.0f);
	m_vpn				= XGVECTOR3(0.0f, 0.0f, 1.0f);
	m_lightPosition		= m_position;
	m_lightNum			= 5;
	m_lightOn			= TRUE;
	m_fixedLight		= TRUE;
	m_drawAxis			= FALSE;

	// Axis color
	m_axis[0].color	= 0xffff0000;
	m_axis[1].color	= 0xffff0000;
	m_axis[2].color	= 0xff00ff00;
	m_axis[3].color	= 0xff00ff00;
	m_axis[4].color	= 0xff0000ff;
	m_axis[5].color	= 0xff0000ff;

	m_lightNormal[0].color	= 0xffffffff;
	m_lightNormal[1].color	= 0xffffffff;
}

//------------------------------------------------------------------------------
//	CCamera::~CCamera
//------------------------------------------------------------------------------
CCamera::~CCamera(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CCamera::Render
//------------------------------------------------------------------------------
void 
CCamera::Render(
				IN IDirect3DDevice8* pD3DDevice
				)
/*++

Routine Description:

	Render the scene

Arguments:

	IN pD3DDevice -	Device to draw to

Return Value:

	None

--*/
{
	// View matrix
	pD3DDevice->SetTransform(D3DTS_VIEW, &m_viewMatrix);

	// Projection matrix
	pD3DDevice->SetTransform(D3DTS_PROJECTION, &m_projectionMatrix);

	pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);

	// Draw the axis?
	if(m_drawAxis)
	{
		DWORD oldState;
		
		pD3DDevice->GetRenderState(D3DRS_LIGHTING, &oldState);
		pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

		// Draw the axis?
		pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
		pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 3, m_axis, 
									sizeof(CCamera::Vertex));

		if(m_lightOn)
		{
			pD3DDevice->SetVertexShader(D3DFVF_XYZ | D3DFVF_DIFFUSE);
			pD3DDevice->DrawPrimitiveUP(D3DPT_LINELIST, 1, m_lightNormal, 
										sizeof(CCamera::Vertex));
		}

		if(oldState)
			pD3DDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	}

	// light
	pD3DDevice->SetLight(m_lightNum, &m_light);
	pD3DDevice->LightEnable(m_lightNum, m_lightOn);

}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN DWORD	x, 
					 IN DWORD	y, 
					 IN DWORD	w, 
					 IN DWORD	h, 
					 IN float	minZ, 
					 IN float	maxZ
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN x -			X coordinate
	IN y -			Y coordinate
	IN w -			Width
	IN h -			Height
	IN minZ -		Z coordinate of fron clipping plane (0.0 - 1.0)
	IN maxZ -		Z coordinate of back clipping plane (0.0 - 1.0)
	IN vieport -	Complete viewport structure

Return Value:

	None

--*/
{
	m_viewport.X		= x;
	m_viewport.Y		= y;
	m_viewport.Width	= w;
	m_viewport.Height	= h;
	m_viewport.MinZ		= minZ;
	m_viewport.MaxZ		= maxZ;
}

//------------------------------------------------------------------------------
//	CCamera::SetViewport
//------------------------------------------------------------------------------
void 
CCamera::SetViewport(
					 IN const D3DVIEWPORT8& viewport
					 )
/*++

Routine Description:

	Sets the viewport

Arguments:

	IN viewport -	Viewport

Return Value:

	None

--*/
{
	m_viewport.X		= viewport.X;
	m_viewport.Y		= viewport.Y;
	m_viewport.Width	= viewport.Width;
	m_viewport.Height	= viewport.Height;
	m_viewport.MinZ		= viewport.MinZ;
	m_viewport.MaxZ		= viewport.MaxZ;
}

//------------------------------------------------------------------------------
//	CCamera::GetViewport
//------------------------------------------------------------------------------
const D3DVIEWPORT8& 
CCamera::GetViewport(void)
/*++

Routine Description:

	Returns the viewport

Arguments:

	None

Return Value:

	The current viewport

--*/
{
	return m_viewport;
}

//------------------------------------------------------------------------------
//	CCamera::LookAt
//------------------------------------------------------------------------------
void 
CCamera::LookAt(
				IN const XGVECTOR3& position, 
				IN const XGVECTOR3& focalPoint, 
				IN const XGVECTOR3& viewUp
				)
/*++

Routine Description:

	Sets the (initial) orientation of the camera

Arguments:

	IN position -	Position of camera
	IN focalPoint -	Focal point of camera
	IN viewUp -		View up vector

Return Value:

	None

--*/
{
	float	length;

	m_focalPoint	= focalPoint;
	m_position		= position;
	m_viewUp		= viewUp;
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);
	XGVec3Subtract(&m_vpn, &m_focalPoint, &m_position);

	length	= XGVec3Length(&m_vpn);
	m_vpn	/= length;
	length	/= 4.0f;

	// Calculate the axis
	m_axis[0].x	= m_focalPoint.x;
	m_axis[0].y	= m_focalPoint.y;
	m_axis[0].z	= m_focalPoint.z;
	m_axis[1].x	= m_axis[0].x + length;
	m_axis[1].y	= m_axis[0].y;
	m_axis[1].z	= m_axis[0].z;
	m_axis[2].x	= m_axis[0].x;
	m_axis[2].y	= m_axis[0].y;
	m_axis[2].z	= m_axis[0].z;
	m_axis[3].x	= m_axis[0].x;
	m_axis[3].y	= m_axis[0].y + length;
	m_axis[3].z	= m_axis[0].z;
	m_axis[4].x	= m_axis[0].x;
	m_axis[4].y	= m_axis[0].y;
	m_axis[4].z	= m_axis[0].z;
	m_axis[5].x	= m_axis[0].x;
	m_axis[5].y	= m_axis[0].y;
	m_axis[5].z	= m_axis[0].z + length;

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetFieldOfView
//------------------------------------------------------------------------------
void 
CCamera::SetPerspectiveFov(
						   IN float	fov,
						   IN float	aspect,
						   IN float	zNear,
						   IN float	zFar
						   )
/*++

Routine Description:

	Sets the field of view and the perspective projection

Arguments:

	IN fov -	Field of view in degrees.
	IN aspect -	Aspect ratio
	IN zNear -	Near clipping plane
	IN zFar -	Far clipping plane

Return Value:

	None

--*/
{
	m_aspect	= aspect;
	m_fov		= XGToRadian(fov);
	m_zNear		= zNear;
	m_zFar		= zFar;
	m_dz		= m_zFar - m_zNear;
	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, m_zNear, 
							   m_zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Zoom
//------------------------------------------------------------------------------
void 
CCamera::Zoom(
			  IN float amount
			  )
/*++

Routine Description:

	Zooms the camera in or out

Arguments:

	IN amount -	Amount to zoom in world coordinates

Return Value:

	None

--*/
{
	float		length;
	float		zFar;
	float		zNear;
	XGVECTOR3	oldPosition = m_position;

	// Make sure user doesn't zoom past focal point
	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	if((length <= 0.01) && (amount > 0.0f))
		return;
	if(amount >= length)
		amount = length - 0.01f;

	// Move the point
	m_position.x += m_vpn.x * amount;
	m_position.y += m_vpn.y * amount;
	m_position.z += m_vpn.z * amount;
	
	// Reproject
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	length = XGVec3Length(&XGVECTOR3(m_focalPoint - m_position));
	m_zNear = length - (m_dz / 2.0f) - 0.01f;
	m_zFar	= length + (m_dz / 2.0f) + 0.01f;

	if(m_zNear < 0.00001f)
		zNear = 0.00001f;
	else
		zNear = m_zNear;
	if(m_zFar < 0.00001f)
		zFar = 0.00001f;
	else
		zFar = m_zFar;

	XGMatrixPerspectiveFovLH(&m_projectionMatrix, m_fov, m_aspect, zNear, zFar);
}

//------------------------------------------------------------------------------
//	CCamera::Rotate
//------------------------------------------------------------------------------
void 
CCamera::Rotate(
				IN float				degrees, 
				IN const XGVECTOR3&	axis
				)
/*++

Routine Description:

	Rotates the scene around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about

Return Value:

	None

--*/
{
	XGMATRIX	rotate;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, m_viewMatrix, rotate);

	// Transform the position
	XGVec3TransformCoord(&m_position, &m_position, &m_viewMatrix);

	// Recalculate the view plane normal
	XGVec3Normalize(&m_vpn, &XGVECTOR3(m_focalPoint - m_position));

	// Transform the view up vector
	XGVec3TransformCoord(&m_viewUp, &m_viewUp, &rotate);

	// Reset the view matrix
	XGMatrixLookAtLH(&m_viewMatrix, &m_position, &m_focalPoint, &m_viewUp);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateX
//------------------------------------------------------------------------------
void 
CCamera::RotateX(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the X axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	axis;

	XGVec3Cross(&axis, &m_vpn, &m_viewUp);
	Rotate(degrees, axis);
}

//------------------------------------------------------------------------------
//	CCamera::RotateY
//------------------------------------------------------------------------------
void 
CCamera::RotateY(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Y axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::RotateZ
//------------------------------------------------------------------------------
void 
CCamera::RotateZ(
				 IN float degrees
				 )
/*++

Routine Description:

	Rotates the scene around the Z axis of the screen

	Regardless of the current orientation of the objects in the scene,
	the rotation will be about axis relative to the screen (Z into, Y
	up and X to the right).

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	Rotate(degrees, m_vpn);
}

//------------------------------------------------------------------------------
//	CCamera::EnableLight
//------------------------------------------------------------------------------
void 
CCamera::EnableLight(
					 IN BOOL	turnOn,
					 IN BOOL	fixedLight
					 )
/*++

Routine Description:

	Enables the headlight

Arguments:

	IN turnOn -		TRUE to enable, FALSE to disable
	IN fixedLight -	TRUE to follow camera position, FALSE to float

Return Value:

	None

--*/
{
	m_lightOn		= turnOn;
	m_fixedLight	= fixedLight;
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::SetLight
//------------------------------------------------------------------------------
void 
CCamera::SetLight(
				  IN DWORD				lightNum, 
				  IN const D3DLIGHT8&	lightParams
				  )
/*++

Routine Description:

	Sets the parameters of the light

Arguments:

	IN lightNum -		Light number to use.
	IN lightParams -	Parameters of the light source

Return Value:

	None

--*/
{
	m_lightNum			= lightNum;

    m_light.Type		= lightParams.Type;
	m_light.Diffuse.r	= lightParams.Diffuse.r;	
	m_light.Diffuse.g	= lightParams.Diffuse.g;	
	m_light.Diffuse.b	= lightParams.Diffuse.b;	
    m_light.Specular.r	= lightParams.Specular.r;
	m_light.Specular.g	= lightParams.Specular.g;
	m_light.Specular.b	= lightParams.Specular.b;
    m_light.Ambient.r	= lightParams.Ambient.r;
	m_light.Ambient.g	= lightParams.Ambient.g;
	m_light.Ambient.b	= lightParams.Ambient.b;
    m_light.Range		= lightParams.Range;
}

//------------------------------------------------------------------------------
//	CCamera::RotateLight
//------------------------------------------------------------------------------
void 
CCamera::RotateLight(
					 IN float				degrees, 
					 IN const XGVECTOR3&	axis
					 )
/*++

Routine Description:

	Rotates the Light around an arbitrary axis

Arguments:

	IN degrees -	Amount to rotate.
	IN axis -		Axis to rotate about.

Return Value:

	None

--*/
{
	XGMATRIX	matrix;
	XGMATRIX	temp;

	if(degrees == 0.0f)
		return;

	MakeRotationMatrices(degrees, axis, matrix, temp);

	// Transform the position
	XGVec3TransformCoord(&m_lightPosition, &m_lightPosition, &matrix);

	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightX
//------------------------------------------------------------------------------
void 
CCamera::RotateLightX(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	XGVECTOR3	cross;

	XGVec3Cross(&cross, &m_vpn, &m_viewUp);
	RotateLight(degrees, cross);
}

//------------------------------------------------------------------------------
//	CCamera::RotateLightY
//------------------------------------------------------------------------------
void 
CCamera::RotateLightY(
					  IN float degrees
					  )
/*++

Routine Description:

	Rotates the Light around the X axis of the screen

Arguments:

	IN degrees -	Amount to rotate in degrees

Return Value:

	None

--*/
{
	RotateLight(degrees, m_viewUp);
}

//------------------------------------------------------------------------------
//	CCamera::SetDrawAxis
//------------------------------------------------------------------------------
void 
CCamera::SetDrawAxis(
					 IN BOOL draw
					 )
/*++

Routine Description:

	Enables and disbles the drawing of an axis

	Red == +X, Blue == +Y and Green == +Z

Arguments:

	IN draw -	TRUE to draw the axis, FALSE to hide the axis

Return Value:

	None

--*/
{
	m_drawAxis = draw;
}

//------------------------------------------------------------------------------
//	CCamera::SetHome
//------------------------------------------------------------------------------
void
CCamera::SetHome(void)
/*++

Routine Description:

	Sets the home position of the camera to the current position

Arguments:

	None

Return Value:

	None

--*/
{
	m_homePosition		= m_position;
	m_homeViewUp		= m_viewUp;
	m_homeFocalPoint	= m_focalPoint;
	m_homeVpn			= m_vpn;
	m_homeLightPosition	= m_lightPosition;
	m_homeLightOn		= m_lightOn;
	m_homeFixedLight	= m_fixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::GoHome
//------------------------------------------------------------------------------
void
CCamera::GoHome(void)
/*++

Routine Description:

	Moves the camera to its home position

Arguments:

	None

Return Value:

	None

--*/
{
	m_position		= m_homePosition;
	m_viewUp		= m_homeViewUp;
	m_focalPoint	= m_homeFocalPoint;
	m_vpn			= m_homeVpn;
	m_lightPosition	= m_homeLightPosition;
	m_lightOn		= m_homeLightOn;
	m_fixedLight	= m_homeFixedLight;
	
	UpdateLight();
}

//------------------------------------------------------------------------------
//	CCamera::UpdateLight
//------------------------------------------------------------------------------
void
CCamera::UpdateLight(void)
/*++

Routine Description:

	Updates the light direction based upon the movement of the camera
	so the light always points towards the focal point

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;

	if(m_fixedLight)
	{
		m_lightPosition		= m_position;
		m_light.Direction	= m_vpn;
	}
	else
	{
		XGVECTOR3	direction;
		XGVec3Normalize(&direction, &XGVECTOR3(m_focalPoint - m_lightPosition));
		m_light.Direction = direction;
	}

	m_lightNormal[0].x = m_focalPoint.x;
	m_lightNormal[0].y = m_focalPoint.y;
	m_lightNormal[0].z = m_focalPoint.z;

	XGVec3Lerp(&point, &m_focalPoint, &m_lightPosition, 0.5);

	m_lightNormal[1].x = point.x;
	m_lightNormal[1].y = point.y;
	m_lightNormal[1].z = point.z;
}

//------------------------------------------------------------------------------
//	CCamera::MakeRotationMatrices
//------------------------------------------------------------------------------
void
CCamera::MakeRotationMatrices(
							  IN float				degrees, 
							  IN const XGVECTOR3&	axis,
							  OUT XGMATRIX&			transform,
							  OUT XGMATRIX&			rotation
							  )
/*++

Routine Description:

	Create a transformation and rotation (only) matrix from the
	current focal point and a rotation about an arbitrary axis

Arguments:

	IN degrees -	Degrees to rotate about
	IN axis -		Axis to rotate about
	OUT transform -	Complete transormation matrix
	OUT rotation -	Rotation matrix only

Return Value:

	None

--*/
{
	if(degrees == 0.0f)
	{
		XGMatrixIdentity(&transform);
		XGMatrixIdentity(&rotation);
		return;
	}

	XGMATRIX	temp;
	
	XGMatrixTranslation(&transform, -m_focalPoint.x, -m_focalPoint.y, 
						-m_focalPoint.z);
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixRotationAxis(&rotation, &axis, 
										  XGToRadian(degrees)));
	XGMatrixMultiply(&transform, &transform, 
					 XGMatrixTranslation(&temp, m_focalPoint.x, 
										 m_focalPoint.y, m_focalPoint.z));
}

//------------------------------------------------------------------------------
//	CCamera::GetPosition
//------------------------------------------------------------------------------
void 
CCamera::GetPosition(XGVECTOR3* pvPosition)
{
    if (pvPosition) {
        *pvPosition = m_position;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Ball.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ball.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __BALL_H__
#define __BALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace WFVO {

//------------------------------------------------------------------------------
//	CAudioData
//------------------------------------------------------------------------------
class CAudioData
{
protected:
    LPWAVEFORMATEX          m_pwfxFormat;
    LPVOID                  m_pvAudioData;
    DWORD                   m_dwAudioDataSize;
    DWORD                   m_dwRefCount;

public:
    CAudioData(void);
    virtual ~CAudioData(void);

public:
    HRESULT CreateFile(LPCSTR pszFile, LPCWAVEFORMATEX *ppwfxFormat, LPVOID *ppvAudioData, LPDWORD pdwAudioDataSize);
    HRESULT CreateEmpty(LPCWAVEFORMATEX pwfxFormat, DWORD dwAudioDataSize, LPVOID *ppvAudioData, LPBOOL pfInitialize);
    DWORD AddRef(void);
    DWORD Release(void);
};

__inline DWORD CAudioData::AddRef(void)
{
    return ++m_dwRefCount;
}

__inline DWORD CAudioData::Release(void)
{
    if(m_dwRefCount)
    {
        return --m_dwRefCount;
    }
    else
    {
        return 0;
    }
}

//------------------------------------------------------------------------------
//	CBall
//------------------------------------------------------------------------------
class CBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		float		tu, tv;
        XGVECTOR3   vTangent;
        XGVECTOR3   vBinormal;
        XGVECTOR3   vNormal;
	};

public:

	CBall(void);
	virtual ~CBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, float, int, int, BOOL, DWORD);
	void SetPosition(const XGVECTOR3&);
	void SetDirection(const XGVECTOR3&);
	void SetSpeed(float);
	float GetSpeed(void) const;
	const XGVECTOR3& GetDirection(void) const;
	void Move(float);
	void Render(IDirect3DDevice8*, XGMATRIX*, XGVECTOR3*, D3DLIGHT8*, D3DCOLORVALUE*, UINT);

	void DrawSolid(void);
	void DrawReduced(void);
	void DrawWireframe(void);
	void DrawPoints(void);

	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;
	const XGVECTOR3& GetLocation(void) const;

    D3DLIGHT8* GetLight(void);
    void PlaceLightInRange(UINT uLight, BOOL bInRange);
	BOOL IsLightSource(void) const;

	void PlayBuffer(float volume /* 0.0-1.0 */, float pitch /* 0.0-1.0 */);
    void DisableAmbientAudio( void );

	float GetMass(void) const { return m_mass; };

private:

	void Release(void);

    HRESULT CreateTextureFromHeightMap(IDirect3DDevice8* pDevice, 
                            LPCSTR szImage, IDirect3DTexture8** ppd3dt);
    HRESULT CreateLightTexture(IDirect3DDevice8* pDevice, UINT uLength, 
                            IDirect3DTexture8** ppd3dt);

    BOOL ComputeTangentTransforms(Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);
    BOOL CalculateTangentTerms(XGVECTOR3* pvTangent, XGVECTOR3* pvBinormal, 
                            Vertex* prVertices, LPWORD pwIndices, 
                            UINT uNumIndices, BOOL bInterpolate);

	HRESULT InitAudio(void);
    HRESULT CreateSubMixDestination(void);
    HRESULT CreateCollisionSound(void);
    HRESULT CreateAmbientSound(void);
    void RenderAudio(void);

    LONG CalculatePitch(DWORD dwFrequency);

private:

	D3DMATERIAL8			m_material;
    D3DLIGHT8               m_light;
    D3DLIGHT8               m_lightDark;
	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;
	BOOL					m_dontDraw;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_direction;
	float					m_speed;
	float					m_radius;
	XGVECTOR3				m_location;
	DWORD					m_fillMode;
	LPDIRECTSOUNDBUFFER     m_pCollisionSound;
    LPDIRECTSOUNDBUFFER     m_pAmbientSound;
    LPDIRECTSOUNDBUFFER     m_pSubMix;
    static CAudioData       m_CollisionSoundData;
    CAudioData *            m_pCollisionSoundData;
    static CAudioData       m_AmbientSoundData;
    CAudioData *            m_pAmbientSoundData;
	int						m_detail;
    BOOL                    m_bLightSource;
    DWORD                   m_dwInLightRange[4];
	float					m_mass;
    DWORD                   m_dwID;
    DWORD                   m_dwCollisionFrequency;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
    static IDirect3DTexture8* m_pd3dtBump;
    static IDirect3DTexture8* m_pd3dtLight;
    static IDirect3DTexture8* m_pd3dtWhite;
    static IDirect3DTexture8* m_pd3dtFlat;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef XBOX
#include <xgraphics.h>
#endif

using namespace WFVO;

namespace WFVO {

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Camera.h ===
// Camera.h: interface for the CCamera class.
//
//////////////////////////////////////////////////////////////////////

#ifndef CAMERA_H
#define CAMERA_H

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace WFVO {

//------------------------------------------------------------------------------
//	CCamera:
//------------------------------------------------------------------------------
class CCamera  
{
public:

	struct Vertex
	{
		FLOAT	x, y, z;
		DWORD	color;
	};

public:

	CCamera(void);
	virtual ~CCamera(void);
	void Render(IDirect3DDevice8*);
	void SetViewport(DWORD, DWORD, DWORD, DWORD, float, float);
	void SetViewport(const D3DVIEWPORT8&);
	const D3DVIEWPORT8& GetViewport(void);
	void LookAt(const XGVECTOR3&, const XGVECTOR3&, const XGVECTOR3&);
	void SetPerspectiveFov(float, float, float, float);
	void Zoom(float);
	void Rotate(float, const XGVECTOR3&);
	void RotateX(float);
	void RotateY(float);
	void RotateZ(float);
	void EnableLight(BOOL, BOOL fixedLight);
	void SetLight(DWORD, const D3DLIGHT8&);
	void RotateLight(float, const XGVECTOR3&);
	void RotateLightX(float);
	void RotateLightY(float);
	void SetDrawAxis(BOOL);
	void SetHome(void);
	void GoHome(void);
    void GetPosition(XGVECTOR3* pvPosition);

private:

	void UpdateLight(void);
	void MakeRotationMatrices(float, const XGVECTOR3&, XGMATRIX&, XGMATRIX&);

private:

	D3DVIEWPORT8	m_viewport;			// Viewport
	XGMATRIX		m_viewMatrix;		// View matrix
	XGMATRIX		m_projectionMatrix;	// Projection matrix
	D3DLIGHT8		m_light;			// Light parameters
	XGVECTOR3		m_focalPoint;		// Focal point of camera
	XGVECTOR3		m_position;			// Position of camera
	XGVECTOR3		m_viewUp;			// View up vector of camera
	XGVECTOR3		m_vpn;				// View plane normal of camera
	XGVECTOR3		m_lightPosition;	// Position of light
	DWORD			m_lightNum;			// Llight number
	BOOL			m_lightOn;			// TRUE to enable the light
	BOOL			m_fixedLight;		// TRUE to lock light to the camera position
	Vertex			m_axis[6];			// Axis for rendering
	BOOL			m_drawAxis;			// TRUE to draw axis
	Vertex			m_lightNormal[2];	// Light normal
	XGVECTOR3		m_homeFocalPoint;
	XGVECTOR3		m_homePosition;
	XGVECTOR3		m_homeViewUp;
	XGVECTOR3		m_homeVpn;
	XGVECTOR3		m_homeLightPosition;
	BOOL			m_homeLightOn;
	BOOL			m_homeFixedLight;
	float			m_aspect;
	float			m_fov;
	float			m_zNear;
	float			m_zFar;
	float			m_dz;

};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\input.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.h

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

namespace WFVO {

void CheckUserInput(void);
void InputDukeInsertions(DWORD add, DWORD remove=0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\DSStress.h ===
#pragma once

HRESULT StartDSStress(DWORD dwThreads, DWORD dwBuffers2D, DWORD dwBuffers3D, DWORD dwStreams2D, DWORD dwStreams3D, DWORD dwMixinBuffers2D, DWORD dwMixinBuffers3D, DWORD dwSends2D, DWORD dwSends3D, DWORD dwWait);
HRESULT StopDSStress(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\helpers.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:



--*/

//------------------------------------------------------------------------------
//	Includes:
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <stdio.h>
#include <io.h>
#include <xgraphics.h>
#include <dmusici.h>
#include "media.h"
#include "helpers.h"
#include "macros.h"
#include "DSSTDFX.h"

#ifdef _DEBUG
    extern "C" DWORD g_dwDirectSoundDebugLevel;
    extern "C" DWORD g_dwDirectSoundDebugBreakLevel;
#endif

using namespace WFVO;

namespace WFVO {

AUDIOPATHPAIR AudioPathPairs[4] = 
{
{"DMUS_APATH_SHARED_STEREOPLUSREVERB", DMUS_APATH_SHARED_STEREOPLUSREVERB},
{"DMUS_APATH_SHARED_STEREO", DMUS_APATH_SHARED_STEREO},
{"DMUS_APATH_DYNAMIC_MONO", DMUS_APATH_DYNAMIC_MONO},
{"DMUS_APATH_DYNAMIC_3D", DMUS_APATH_DYNAMIC_3D}
};


  
//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT Log
(
    LPSTR                   szFormat,
    ...
)
{
    va_list va;
    char szBuffer[1000];

    va_start(va, szFormat);
    vsprintf(szBuffer, szFormat, va);
    va_end(va);

    OutputDebugStringA(szBuffer);
    return S_OK;
};


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid)
{
	HRESULT hr = S_OK;
	WIN32_FIND_DATA findData;
	BOOL bMore = TRUE;
	HANDLE hFiles;
	CHAR szFullPath[MAX_PATH];
	CHAR szFiles[MAX_PATH];

	sprintf( szFiles, "%s\\*", szDir ); 

	hFiles = FindFirstFile( szFiles, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore && SUCCEEDED( hr ) )
	{
		sprintf( szFullPath, "%s\\%s", szDir, findData.cFileName );

		if ( findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
		{
			CHECKRUN( RecurseDirectory( szFullPath, LoadFile, pVoid) );
		}

		else
		{
			CHECKRUN( LoadFile(szFullPath, pVoid) );
		}

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}



//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
LPCSTR PathFindFileName(LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut)
{
LPSTR szFile = NULL;
DWORD dwLength;

if (!szFullString)
{
    szPathOut[0] = NULL;
    szFileOut[0] = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (LPSTR)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

strcpy(szFileOut, szFile);

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szPathOut, szFullString, dwLength);
szPathOut[dwLength] = NULL;

return S_OK;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT TranslatePath(const char *szFullString, LPSTR szRemotePath, LPSTR szLocalDir )
{
LPSTR szFile = NULL;
DWORD dwLength;

if (!szFullString)
{
    szRemotePath[0] = NULL;
    szLocalDir[0] = NULL;
    return E_POINTER;
}

//Parse out the file name.
szFile = (LPSTR)PathFindFileName(szFullString);
if (!szFile)
    return E_FAIL;

//Get the length of the directory name.
dwLength = strlen(szFullString) - strlen(szFile);

//Copy only that length, and set the final character of the out-string to NULL.
strncpy(szLocalDir, szFullString, dwLength);
szLocalDir[dwLength] = NULL;

//translate local dir into remote dir
strcpy( szRemotePath, "mediastress/" );
LPSTR lpszTemp = strstr( szLocalDir, "t:\\media\\" );
if ( szLocalDir != lpszTemp )
{
	return E_FAIL;
}
int i = 12;
int j = 9;
while ( '\0' != szLocalDir[j] )
{
	if ( MAX_PATH <= i )
	{
		return E_FAIL;
	}
	if ( '\\' == szLocalDir[j] )
	{
		szRemotePath[i] = '/';
	}
	else
	{
		szRemotePath[i] = szLocalDir[j];
	}
	i++; j++;
}
strcpy( &szRemotePath[i], szFile );

if ( NULL == strchr( szFile, '.' ) )
{
	strcat( szLocalDir, szFile );
	strcat( szRemotePath, "/" );
}

return S_OK;
}



TESTPARAMS g_TestParams = {0};

//------------------------------------------------------------------------------
//Print Test Params
//------------------------------------------------------------------------------
HRESULT PrintTestParams(void)
{
    Log("\n");
    Log("---------- STRESS PARAMETERS --------\n");
    Log("dwSeed:                %lu\n", g_TestParams.dwSeed);
    Log("dwBallDetail:          %lu\n", g_TestParams.dwBallDetail);
    Log("dwWallDetail:          %lu\n", g_TestParams.dwWallDetail);
    Log("dwLightDetail:         %lu\n", g_TestParams.dwLightDetail);
    Log("dwNumLayers:           %lu\n", g_TestParams.dwNumLayers);
    Log("dwNumBalls:            %lu\n", g_TestParams.dwNumBalls);
    Log("dwMaxBalls:            %lu\n", g_TestParams.dwMaxBalls);
    Log("dwNumLights:           %lu\n", g_TestParams.dwNumLights);
    Log("dwMaxLights:           %lu\n", g_TestParams.dwMaxLights);
    Log("fRadius:               %g\n", g_TestParams.fRadius);
    Log("fMaxSpeed:             %g\n", g_TestParams.fMaxSpeed);
    Log("fMinSpeed:             %g\n", g_TestParams.fMinSpeed);
    Log("bTextureBalls          %s\n", g_TestParams.bTextureBalls ? "TRUE" : "FALSE");
    Log("szBallBaseTex:         %s\n", g_TestParams.szBallBaseTex);
    Log("szBallBumpTex:         %s\n", g_TestParams.szBallBumpTex);
    Log("szSphereBaseTex:       %s\n", g_TestParams.szSphereBaseTex);
    Log("szLightVSH:            %s\n", g_TestParams.szLightVSH);
    Log("szSparkVSH:            %s\n", g_TestParams.szSparkVSH);
    Log("bDMusic:               %s\n", g_TestParams.bDMusic ? "TRUE" : "FALSE");
    Log("bDMDoWorkLocally:      %s\n", g_TestParams.bDMDoWorkLocally ? "TRUE" : "FALSE");
    Log("bDMUseGM:              %s\n", g_TestParams.bDMUseGM ? "TRUE" : "FALSE");
    Log("bDMLoaderThread:       %s\n", g_TestParams.bDMLoaderThread ? "TRUE" : "FALSE");
    Log("dwDMVoiceCount:        %d\n", g_TestParams.dwDMVoiceCount);
    Log("szDMStressDir:         %s\n", g_TestParams.szDMStressDir);
    Log("szDMSupportDir:        %s\n", g_TestParams.szDMSupportDir);
    Log("szDMAudioPath:         %s\n", g_TestParams.szDMAudioPath);
    Log("szDMHeap:              %s\n", g_TestParams.szDMHeap);
    Log("dwDMFixedHeapSizeNorm: %u\n", g_TestParams.dwDMFixedHeapSizeNorm);
    Log("dwDMFixedHeapSizePhys: %u\n", g_TestParams.dwDMFixedHeapSizePhys);
    Log("dwMaxSparks:           %lu\n", g_TestParams.dwMaxSparks);
    Log("bSparksAreLights:      %s\n", g_TestParams.bSparksAreLights ? "TRUE" : "FALSE");
    Log("dwSparksPerCollision:  %lu\n", g_TestParams.dwSparksPerCollision);
    Log("dwSparkMaxAge:         %lu\n", g_TestParams.dwSparkMaxAge);
    Log("bDrawWireframe:        %s\n", g_TestParams.bDrawWireframe ? "TRUE" : "FALSE");
    Log("bRelativeSpeed:        %s\n", g_TestParams.bRelativeSpeed ? "TRUE" : "FALSE");
    Log("dwFileIOSize:          %lu\n", g_TestParams.dwFileIOSize);
    Log("lDMMasterVolume:       %ld\n", g_TestParams.lDMMasterVolume);
    Log("lDMMasterTranspose:    %hd\n", g_TestParams.lDMMasterTranspose);
    Log("fDMMasterTempo:        %g\n", g_TestParams.fDMMasterTempo);
    Log("bD3DPerf:              %s\n", g_TestParams.bD3DPerf ? "TRUE" : "FALSE");
    Log("szDSScratchImage:      %s\n", g_TestParams.szDSScratchImage);
    Log("szDSEnvironment:       %s\n", g_TestParams.szDSEnvironment);
    Log("b3DSound:              %s\n", g_TestParams.b3DSound ? "TRUE" : "FALSE");
    Log("bSubMixBallSound:      %s\n", g_TestParams.bSubMixBallSound ? "TRUE" : "FALSE");
    Log("szLightSound:          %s\n", g_TestParams.szLightSound);
    Log("lDSVolume:             %ld\n", g_TestParams.lDSVolume);
    Log("dwDSFreq:              %lu\n", g_TestParams.dwDSFreq);
    Log("lAmbientVolume:        %ld\n", g_TestParams.lAmbientVolume);
    Log("bCopyMediaFromNetwork  %s\n", g_TestParams.bCopyMediaFromNetwork ? "TRUE" : "FALSE");
    Log("dwMultiSampleType:     %lu\n", g_TestParams.dwMultiSampleType);
    Log("dwBackBufferCount:     %lu\n", g_TestParams.dwBackBufferCount);
    Log("bCycleDisplayModes:    %s\n", g_TestParams.bCycleDisplayModes ? "TRUE" : "FALSE");
    Log("dwCycleTime:           %ld\n", g_TestParams.dwCycleTime);
    Log("dwDMDebugLevel:        %ld\n", g_TestParams.dwDMDebugLevel);
    Log("dwDMRIPLevel:          %ld\n", g_TestParams.dwDMRIPLevel);

    Log("dwDSSThreads:          %lu\n", g_TestParams.dwDSSThreads);
    Log("dwDSSTotalBuffers2D:   %lu\n", g_TestParams.dwDSSTotalBuffers2D);
    Log("dwDSSTotalBuffers3D:   %lu\n", g_TestParams.dwDSSTotalBuffers3D);
    Log("dwDSSTotalStreams2D:   %lu\n", g_TestParams.dwDSSTotalStreams2D);
    Log("dwDSSTotalStreams3D:   %lu\n", g_TestParams.dwDSSTotalStreams3D);
    Log("dwDSSMixinBuffers2D:   %lu\n", g_TestParams.dwDSSMixinBuffers2D);
    Log("dwDSSMixinBuffers3D:   %lu\n", g_TestParams.dwDSSMixinBuffers3D);
    Log("dwDSSSends2D:          %lu\n", g_TestParams.dwDSSSends2D);
    Log("dwDSSSends3D:          %lu\n", g_TestParams.dwDSSSends3D);
    Log("dwDSSWait:             %lu\n", g_TestParams.dwDSSWait);


    if (g_TestParams.dwDMSegments)
    {
        Log("ppDMSegments:  \n");
        for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
            Log("                                  %s\n", g_TestParams.ppDMSegments[i]);

    }
    else
    {
        Log("ppDMSegments:         NONE\n");
    }

#ifdef _DEBUG
    Log("g_dwDirectSoundDebugLevel:         %ld\n", g_dwDirectSoundDebugLevel);
    Log("g_dwDirectSoundDebugBreakLevel:    %ld\n", g_dwDirectSoundDebugBreakLevel);
#endif

    Log("-----------------------------------\n");
    return S_OK;
};

//------------------------------------------------------------------------------
//Read Test Params
//-----------------------------------------------------------------------------
static LPCSTR szAppName = "MEDIA";
static LPCSTR szDefaultININame =    "D:\\testini.ini";
static LPCSTR szSecondaryININame =  "T:\\testini.ini";
static LPCSTR szSectionName = "DMSEGMENTS";
#define MAXSIZE 0xFFFF

HRESULT LoadTestParams(void)
    {
    CHAR *szTemp;
    FLOAT fTemp = 0;
    DWORD dwTemp = 0;
    DWORD dwBufferSize=0;
    DWORD dwReturned = 0;
    LARGE_INTEGER liSeed = {0};
    DWORD i=0;
    CHAR szININame[MAX_PATH] = {0};

    //First look for testini's in the current directory, then on t:\    
    if (0 == _access(szDefaultININame, 0))
    {
        Log("Note: Found default ini file %s\n", szDefaultININame);
        strcpy(szININame, szDefaultININame);
    }
    else
    {
        Log("Note: Couldn't find %s; trying secondary INI file %s\n", szDefaultININame, szSecondaryININame);
        if (0 == _access(szSecondaryININame, 0))
        {
            Log("Note: Found secondary ini file %s\n", szSecondaryININame);            
            strcpy(szININame, szSecondaryININame);
        }
        else
        {            
            Log("Note: Couldn't find secondary file %s either; giving up!!\n", szSecondaryININame);
            return E_FAIL;
        }
    }

    //Allocate 0xFFFF- more than enough to hold all the file names
    szTemp = new CHAR[MAXSIZE];
    memset(szTemp, 0, MAXSIZE);
    memset(&g_TestParams, 0, sizeof(g_TestParams));

    //Randomize calls to rand() based on current time.
    g_TestParams.dwSeed = GetPrivateProfileIntA(szAppName, "dwseed", 0, szININame);
    if (g_TestParams.dwSeed == 0)
    {
        Log("Seed not specified; generating one.\n");
        QueryPerformanceCounter(&liSeed);
        g_TestParams.dwSeed = liSeed.LowPart;
    }
    srand(g_TestParams.dwSeed);    

    g_TestParams.dwBallDetail = GetPrivateProfileIntA(szAppName, "dwballdetail", 12, szININame);
    g_TestParams.dwWallDetail = GetPrivateProfileIntA(szAppName, "dwwalldetail", 20, szININame);
    g_TestParams.dwLightDetail = GetPrivateProfileIntA(szAppName, "dwlightdetail", 12, szININame);
    g_TestParams.dwNumLayers = GetPrivateProfileIntA(szAppName, "dwnumlayers", 0, szININame);
    g_TestParams.dwNumBalls = GetPrivateProfileIntA(szAppName, "dwnumballs", 20, szININame);
    g_TestParams.dwMaxBalls = GetPrivateProfileIntA(szAppName, "dwmaxballs", 50, szININame);
    g_TestParams.dwNumLights = GetPrivateProfileIntA(szAppName, "dwnumlights", 5, szININame);
    g_TestParams.dwMaxLights = GetPrivateProfileIntA(szAppName, "dwmaxlights", 10, szININame);

    g_TestParams.dwMaxSparks = GetPrivateProfileIntA(szAppName, "dwmaxsparks", 500, szININame);
    g_TestParams.bSparksAreLights =GetPrivateProfileIntA(szAppName, "bsparksarelights", 1, szININame);
    g_TestParams.dwSparksPerCollision =GetPrivateProfileIntA(szAppName, "dwsparkspercollision", 4, szININame);
    g_TestParams.dwSparkMaxAge =GetPrivateProfileIntA(szAppName, "dwsparkmaxage", 100, szININame);
    g_TestParams.bDrawWireframe =GetPrivateProfileIntA(szAppName, "bdrawwireframe", 1, szININame);
    g_TestParams.bRelativeSpeed =GetPrivateProfileIntA(szAppName, "brelativespeed", 1, szININame);

    g_TestParams.dwFileIOSize = GetPrivateProfileIntA(szAppName, "dwFileIOSize", 128, szININame);
    g_TestParams.lDMMasterVolume=    GetPrivateProfileIntA(szAppName, "lDMMasterVolume", 0, szININame);
    g_TestParams.lDMMasterTranspose = (short)GetPrivateProfileIntA(szAppName, "lDMMasterTranspose", 0, szININame);
    GetPrivateProfileStringA(szAppName, "fDMMasterTempo", "1",  szTemp, 49, szININame);
    g_TestParams.fDMMasterTempo = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName,   "fradius",   "5.5", szTemp, 49, szININame);
    fTemp = (float)atof(szTemp);
    if (fTemp != 0.0f)
        g_TestParams.fRadius = fTemp;    

    GetPrivateProfileStringA(szAppName, "fmaxspeed", "10",  szTemp, 49, szININame);
    g_TestParams.fMaxSpeed = (FLOAT)atof(szTemp);

    GetPrivateProfileStringA(szAppName, "fminspeed", "0.1", szTemp, 49, szININame);
    g_TestParams.fMinSpeed = (FLOAT)atof(szTemp);

    g_TestParams.bTextureBalls = GetPrivateProfileIntA(szAppName, "bTextureBalls", TRUE, szININame);
    g_TestParams.bD3DPerf = GetPrivateProfileIntA(szAppName, "bD3DPerf", TRUE, szININame);

    GetPrivateProfileStringA(szAppName, "szBallBaseTexture", "t:\\media\\graphics\\ballbase.bmp", g_TestParams.szBallBaseTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szBallBumpTexture", "t:\\media\\graphics\\ballbump.bmp", g_TestParams.szBallBumpTex, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSphereBaseTexture", "t:\\media\\graphics\\sphrbase.bmp", g_TestParams.szSphereBaseTex, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szLightVSH", "t:\\media\\graphics\\light.vsh", g_TestParams.szLightVSH, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szSparkVSH", "t:\\media\\graphics\\spark.vsh", g_TestParams.szSparkVSH, MAX_PATH, szININame);

    GetPrivateProfileStringA(szAppName, "szBounceSound", "t:\\media\\audio\\pcm\\ball.wav", g_TestParams.szBounceSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szLightSound", "", g_TestParams.szLightSound, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSHRTF", "FULL", g_TestParams.szDSHRTF, MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDSEnvironment", "SewerPipe", g_TestParams.szDSEnvironment, MAX_PATH, szININame);

    g_TestParams.b3DSound = GetPrivateProfileIntA(szAppName, "b3DSound", TRUE, szININame);
    g_TestParams.bSubMixBallSound = GetPrivateProfileIntA(szAppName, "bSubMixBallSound", TRUE, szININame);
    g_TestParams.bLightSound = GetPrivateProfileIntA(szAppName, "bLightSound", TRUE, szININame);
    g_TestParams.lDSVolume = GetPrivateProfileIntA(szAppName, "lDSVolume", 0, szININame);
    g_TestParams.dwDSFreq = GetPrivateProfileIntA(szAppName, "dwDSFreq", 48000, szININame);
    g_TestParams.lAmbientVolume = GetPrivateProfileIntA(szAppName, "lAmbientVolume", -2200, szININame);

    g_TestParams.bDMusic            = GetPrivateProfileIntA(szAppName, "bDMusic",          TRUE, szININame);
    g_TestParams.bDMDoWorkLocally   = GetPrivateProfileIntA(szAppName, "bDMDoWorkLocally", FALSE, szININame);
    g_TestParams.bDMUseGM           = GetPrivateProfileIntA(szAppName, "bDMUseGM"       , FALSE, szININame);
    g_TestParams.bDMLoaderThread    = GetPrivateProfileIntA(szAppName, "bDMLoaderThread", TRUE, szININame);
    g_TestParams.dwDMVoiceCount     = GetPrivateProfileIntA(szAppName, "dwDMVoiceCount",   128, szININame);

    g_TestParams.dwDMDebugLevel     = GetPrivateProfileIntA(szAppName, "dwDMDebugLevel",   1, szININame);
    g_TestParams.dwDMRIPLevel       = GetPrivateProfileIntA(szAppName, "dwDMRIPLevel",     0, szININame);

    g_TestParams.dwDSSThreads =         GetPrivateProfileIntA(szAppName, "dwDSSThreads",        0, szININame);
    g_TestParams.dwDSSTotalBuffers2D =  GetPrivateProfileIntA(szAppName, "dwDSSTotalBuffers2D", 0, szININame);
    g_TestParams.dwDSSTotalBuffers3D =  GetPrivateProfileIntA(szAppName, "dwDSSTotalBuffers3D", 0, szININame);
    g_TestParams.dwDSSTotalStreams2D =  GetPrivateProfileIntA(szAppName, "dwDSSTotalStreams2D", 0, szININame);
    g_TestParams.dwDSSTotalStreams3D =  GetPrivateProfileIntA(szAppName, "dwDSSTotalStreams3D", 0, szININame);
    g_TestParams.dwDSSMixinBuffers2D =  GetPrivateProfileIntA(szAppName, "dwDSSMixinBuffers2D", 0, szININame);
    g_TestParams.dwDSSMixinBuffers3D =  GetPrivateProfileIntA(szAppName, "dwDSSMixinBuffers3D", 0, szININame);
    g_TestParams.dwDSSSends2D =         GetPrivateProfileIntA(szAppName, "dwDSSSends2D",        0,      szININame);
    g_TestParams.dwDSSSends3D =         GetPrivateProfileIntA(szAppName, "dwDSSSends3D",        0,      szININame);
    g_TestParams.dwDSSWait    =         GetPrivateProfileIntA(szAppName, "dwDSSWait",           100000, szININame);


    GetPrivateProfileStringA(szAppName, "szDMStressDir",  "t:\\media\\music\\default", g_TestParams.szDMStressDir,  MAX_PATH, szININame);
    GetPrivateProfileStringA(szAppName, "szDMSupportDir", "t:\\media\\music\\support", g_TestParams.szDMSupportDir, MAX_PATH, szININame);

    //If user specified random audiopath, choose a different one now.
    GetPrivateProfileStringA(szAppName, "szDMAudioPath", "Random", g_TestParams.szDMAudioPath, MAX_PATH, szININame);
    if (_strcmpi("random", g_TestParams.szDMAudioPath)==0)
    {
        strcpy(g_TestParams.szDMAudioPath, AudioPathPairs[rand() % NUMELEMS(AudioPathPairs)].szString);
        Log("Choosing random audiopath: %s", g_TestParams.szDMAudioPath);
    }



    //READ IN THE SEGMENT NAMES!!
    //===========================
    //Get our string; parse it out.
    dwReturned = GetPrivateProfileSectionA(szSectionName, szTemp, MAXSIZE, szININame);
    if (dwReturned == MAXSIZE - 2)
    {
        Log("ERROR: Filled up entire %d characters, need to increase MAXSIZE", MAXSIZE);
    }
    //Count the words in the string, if it exists.
    if (szTemp[0])
    {
        for (i=0;;i++)
        {
            if (szTemp[i]==0 && i)
                g_TestParams.dwDMSegments++;

            if (szTemp[i]==0 && szTemp[i+1] == 0)
                break;
        }
    }
    //If there's any strings, then allocate space and copy them.
    if (g_TestParams.dwDMSegments)
    {
        //Allocate that many LPSTR's
        g_TestParams.ppDMSegments = new LPSTR[g_TestParams.dwDMSegments];

        //Go through again and allocate each ptr, and copy the word into it.
        DWORD dwBaseIndex = 0;
        for (i=0; i<g_TestParams.dwDMSegments; i++)
        {
            //Get length + 1
            dwTemp = strlen(&szTemp[dwBaseIndex]) + 1;
            g_TestParams.ppDMSegments[i] = new CHAR[dwTemp];
            strcpy(g_TestParams.ppDMSegments[i], &szTemp[dwBaseIndex]);
            while (szTemp[dwBaseIndex++]);
        }
    }
    delete[]szTemp;


    //Scratch Image
    GetPrivateProfileStringA(szAppName, "szDSScratchImage", "Default", g_TestParams.szDSScratchImage, MAX_PATH, szININame);

    //Heap
    //Default size is 2 MB apiece for a fixed heap, and of course 0 for non-fixed heaps (they can grow as big as they want)
    GetPrivateProfileStringA(szAppName, "szDMHeap", "Tracking", g_TestParams.szDMHeap, MAX_PATH, szININame);
    BOOL bFixedSizeHeap = (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0) || (_strcmpi(g_TestParams.szDMHeap, "FixedDefault") == 0) || (_strcmpi(g_TestParams.szDMHeap, "FixedCache") == 0);
    g_TestParams.dwDMFixedHeapSizeNorm    = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizeNorm",     bFixedSizeHeap ? 4*1024*1024 : 0, szININame);
    g_TestParams.dwDMFixedHeapSizePhys  = GetPrivateProfileIntA(szAppName, "dwDMFixedHeapSizePhys",   bFixedSizeHeap ? 1024*1024 / 2: 0, szININame);

    g_TestParams.bCopyMediaFromNetwork = GetPrivateProfileIntA(szAppName, "bCopyMediaFromNetwork", TRUE, szININame);

    //Dsound debug
#ifdef _DEBUG
    g_dwDirectSoundDebugLevel = GetPrivateProfileIntA(szAppName,      "dwDSDebugLevel", 3, szININame);
    g_dwDirectSoundDebugBreakLevel = GetPrivateProfileIntA(szAppName, "dwDSDebugBreakLevel", 2, szININame);
#endif

    g_TestParams.dwMultiSampleType = GetPrivateProfileIntA(szAppName, "dwMultiSampleType", 0x0011, szININame);
    g_TestParams.dwBackBufferCount = GetPrivateProfileIntA(szAppName, "dwBackBufferCount", 0, szININame);
    g_TestParams.bCycleDisplayModes = GetPrivateProfileIntA(szAppName, "bCycleDisplayModes", FALSE, szININame);
    g_TestParams.dwCycleTime = GetPrivateProfileIntA(szAppName, "dwCycleTime", 1000, szININame);

    PrintTestParams();
    return S_OK;
};


//------------------------------------------------------------------------------
//Verify files exist.  This must be called AFTER the files are copied down.
//-----------------------------------------------------------------------------
HRESULT SanityCheckFiles(void)
{
HRESULT hr = S_OK;

    BOOL bFound = FALSE;
    for (DWORD i=0; i<NUMELEMS(AudioPathPairs); i++)
    {
        if (_strcmpi(g_TestParams.szDMAudioPath, (const char *)AudioPathPairs[i].szString)==0)
        {
            bFound = TRUE;
            break;
        }
    }

    //If the name didn't match one of the audiopath types or "random" then it's a path, and
    //  we should make sure it exists.
    if (!bFound)
    {
        if (_access(g_TestParams.szDMAudioPath, 0))
        {
            Log("Error: Audiopath file %s is not found\n", g_TestParams.szDMAudioPath);
            hr = E_FAIL;
        }
    }

    if (_access(g_TestParams.szBounceSound, 0))
    {
        Log("Error: Wave file for bounce sound (%s) is not found\n", g_TestParams.szBounceSound);
        hr = E_FAIL;
    }

    if (_strcmpi("Default", g_TestParams.szDSScratchImage))
    {
        if (_access(g_TestParams.szDSScratchImage, 0))
        {
            Log("Error: DSP image file (%s) is not found\n", g_TestParams.szDSScratchImage);
            hr = E_FAIL;
        }
    }


    if (g_TestParams.bDMusic)
    {
        if (_access(g_TestParams.szDMStressDir, 0))
        {
            Log("Error: Directory for DMusic segment files (%s) is not found\n", g_TestParams.szDMStressDir);
            hr = E_FAIL;
        }
    }

    return hr;

}


//------------------------------------------------------------------------------
//Print warning messages for things that aren't right.
//-----------------------------------------------------------------------------
HRESULT SanityCheckTestParams(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.ppDMSegments && g_TestParams.dwDMSegments == 0)
    {
        Log("Error: ppDMSegments is not NULL but dwDMSegments == 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments == 0 && g_TestParams.dwDMSegments > 0)
    {
        Log("Error: ppDMSegments is NULL but dwDMSegments > 0\n");
        hr = E_FAIL;
    }

    if (g_TestParams.ppDMSegments && g_TestParams.szDMStressDir)
    {
        Log("Warning: szDMStressDir = %s but [DMSegments] section was specified.  Using [DMSegments] section\n", g_TestParams.szDMStressDir);
    }

    if (!g_TestParams.bDMusic && g_TestParams.ppDMSegments)
    {
        Log("Warning: bDMusic=FALSE but [DMSegments] section was specified.  Ignoring [DMSegments] section\n");
    }

    if (g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls)
    {
        Log("Error: dwNumBalls = %d; dwMaxBalls = %d\n", g_TestParams.dwNumBalls , g_TestParams.dwMaxBalls);
        hr = E_FAIL;
    }

    if (g_TestParams.dwNumLights > g_TestParams.dwMaxLights)
    {
        Log("Error: dwNumLights = %d; dwMaxLights = %d\n", g_TestParams.dwNumLights , g_TestParams.dwMaxLights);
        hr = E_FAIL;
    }
    if (g_TestParams.dwSparksPerCollision > g_TestParams.dwMaxSparks)
    {
        Log("Error: dwSparksPerCollision = %d; dwMaxSparks = %d\n", g_TestParams.dwSparksPerCollision , g_TestParams.dwMaxSparks);
        hr = E_FAIL;
    }

 

    if (_strcmpi(g_TestParams.szDSHRTF, "full") &&
        _strcmpi(g_TestParams.szDSHRTF, "light")
        )
    {
        Log("Error: Specified %s for g_TestParams.szDSHRTF; need to specify ""FULL"" or ""LIGHT""\n", g_TestParams.szDSHRTF);
        hr = E_FAIL;
    }

    if (_strcmpi(g_TestParams.szDMHeap, "Default") &&
        _strcmpi(g_TestParams.szDMHeap, "Tracking") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedUser") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedDefault") &&
        _strcmpi(g_TestParams.szDMHeap, "FixedCache")

        )
    {
        Log("Error: Specified %s for g_TestParams.szDMHeap; need to specify ""Default"", ""Tracking"", ""FixedUser"", ""FixedDefault"", or ""FixedCache""\n", g_TestParams.szDMHeap);
        hr = E_FAIL;
    }

    if (!(_strcmpi(g_TestParams.szDMHeap, "FixedUser") || _strcmpi(g_TestParams.szDMHeap, "FixedDefault") || _strcmpi(g_TestParams.szDMHeap, "FixedCache")))
    {
        if(g_TestParams.dwDMFixedHeapSizeNorm != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizeNorm.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizeNorm);
        }
        if(g_TestParams.dwDMFixedHeapSizePhys != 0)
        {
            Log("Warning: Specified %s (not ""Fixed*"") for g_TestParams.szDMHeap, but specified a non-zero size (%u) for the szDMFixedHeapSizePhys.\n", g_TestParams.szDMHeap, g_TestParams.dwDMFixedHeapSizePhys);
        }
    }

    switch (g_TestParams.dwMultiSampleType & 0xFFFF) {
        case D3DMULTISAMPLE_NONE:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR:
        case D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR:
        case D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN:
        case D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN:
            break;
        default:
            Log("Warning: Invalid multisample type 0x%X specified. Using D3DMULTISAMPLE_NONE by default.\n", g_TestParams.dwMultiSampleType & 0xFFFF);
            g_TestParams.dwMultiSampleType = D3DMULTISAMPLE_NONE;
            break;
    }

    switch (g_TestParams.dwMultiSampleType & 0xF0000) {
        case D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8:
        case D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8:
            break;
        default:
            Log("Warning: Invalid prefilter buffer format 0x%X specified, switching to the default.\n", g_TestParams.dwMultiSampleType & 0xF0000);
            g_TestParams.dwMultiSampleType &= 0xFFF0FFFF;
            break;
    }

    if (g_TestParams.dwBackBufferCount > 2) {
        Log("Error: Specified %d for g_TestParams.dwBackBufferCount\n", g_TestParams.dwBackBufferCount);
        hr = E_FAIL;
    }

    return hr;
};



//------------------------------------------------------------------------------
//Deallocate everything allocated by testparams.
//-----------------------------------------------------------------------------
HRESULT FreeTestParams(void)
{
DWORD i = 0;

for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
{
    if (g_TestParams.ppDMSegments)
    {
        delete []g_TestParams.ppDMSegments[i];
        g_TestParams.ppDMSegments[i] = NULL;
    }
    else
        Log("ERROR!!  Deleting string of ppDMSegments[%d] but it was already NULL!", i);

}

delete []g_TestParams.ppDMSegments;
g_TestParams.ppDMSegments = NULL;
return S_OK;
}

//-----------------------------------------------------------------------------
// Name: DownloadScratch
// Desc: Downloads a DSP scratch image to the DSP
//-----------------------------------------------------------------------------
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwSize = 0;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC EffectLoc = {0};
    EffectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
    EffectLoc.dwCrosstalkIndex   = I3DL2_CHAIN_XTALK;
    
    if (_strcmpi("Default", g_TestParams.szDSScratchImage) == 0)
    {
        CHECKRUN(XAudioDownloadEffectsImage("dsstdfx", &EffectLoc, XAUDIO_DOWNLOADFX_XBESECTION, &pDesc));
    }
    else
    {
        CHECKRUN(XAudioDownloadEffectsImage(pszScratchFile, &EffectLoc, XAUDIO_DOWNLOADFX_EXTERNFILE, &pDesc));
    }

    return hr;
}

//------------------------------------------------------------------------------
// Multiply the given color values and convert the result to a 32 bit color
//-----------------------------------------------------------------------------
D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2) {

    D3DCOLORVALUE dcv;
    dcv.r = pdcv1->r * pdcv2->r;
    dcv.g = pdcv1->g * pdcv2->g;
    dcv.b = pdcv1->b * pdcv2->b;
    dcv.a = pdcv1->a * pdcv2->a;
    return (BYTE)(dcv.a * 255.0f) << 24 | (BYTE)(dcv.r * 255.0f) << 16 |
           (BYTE)(dcv.g * 255.0f) << 8 | (BYTE)(dcv.b * 255.0f);
}




//------------------------------------------------------------------------------
//  WaitForSegmentStop
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStop(
                   IN IDirectMusicPerformance8*   ptPerf8, 
                   IN IDirectMusicSegment8*       ptSegment8, 
                   IN IDirectMusicSegmentState8*  ptSegmentState8, 
                   IN DWORD                         dwTimeout
                   )
/*++

Routine Description:

    Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment stopped within the specified time; E_FAIL otherwise.

--*/
{
    DWORD   dwStartTime     = 0;

    dwStartTime = timeGetTime();
    do
    {
        // Has the segment stopped playing?
        OptionalDoWork();
        if(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8) != S_OK)
            return S_OK;
          
    }
    while (timeGetTime() - dwStartTime < dwTimeout);

    return E_FAIL;
}

//------------------------------------------------------------------------------
//  WaitForSegmentStart
//------------------------------------------------------------------------------
HRESULT 
WaitForSegmentStart(
                    IN IDirectMusicPerformance8*  ptPerf8, 
                    IN IDirectMusicSegment8*      ptSegment8, 
                    IN IDirectMusicSegmentState8* ptSegmentState8,
                    IN DWORD                        dwTimeout
                    )
/*++

Routine Description:

    Returns S_OK if the segment started within the specified time; E_FAIL otherwise.

Arguments:

    IN ptPerf8 -            Performance
    IN ptSegment8 -         Segment to query 
    IN ptSegmentState8 -    Segment state 
    IN dwTimeout -          Milleseconds to timeout
    IN enableBreak -        TRUE to enable the user/tester to break out

Return Value:

    S_OK if the segment started within the specified time; E_FAIL otherwise.

--*/
{
    DWORD dwStartTime = 0;
    dwStartTime = timeGetTime();
    do
    {
        // Has the segment started playing?
        OptionalDoWork();
        if(ptPerf8->IsPlaying(ptSegment8, ptSegmentState8) == S_OK)
            return S_OK;
    }
    while (timeGetTime() - dwStartTime < dwTimeout);

    return E_FAIL;
};

/********************************************************************************
Returns S_OK if the segment started within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStart(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't start playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
Returns S_OK if the segment stopped within the specified time; E_FAIL otherwise.
Prints a message on error.
********************************************************************************/
HRESULT ExpectSegmentStop(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname)
{
HRESULT hr = S_OK;
hr = WaitForSegmentStop(ptPerf8, ptSegment8, ptSegmentState8, dwTimeout);
if (FAILED(hr))
    Log("ERROR: ""%s"" didn't stop playing after %d ms", szSegname, dwTimeout);

return hr;
};


/********************************************************************************
********************************************************************************/
void OptionalDoWork(void)
{
    if (g_TestParams.bDMDoWorkLocally)
        DirectMusicDoWork(10);

}

/********************************************************************************
********************************************************************************/
void WaitForThreadEnd(HANDLE *phThread)
{
    DWORD dwWaitResult = WAIT_TIMEOUT;

    if(*phThread)
    {
        dwWaitResult = WAIT_TIMEOUT;
        while(dwWaitResult != WAIT_OBJECT_0)
        {
            dwWaitResult = WaitForSingleObject(*phThread, 0);
            Sleep(100);
        }

        CloseHandle(*phThread);
        *phThread = NULL;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\input.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	input.cpp

Abstract:

	Media stress - User input code

Author:

    Josh Poley (jpoley) 25-June-2001

Environment:

	Xbox only

Revision History:

	25-June-2001 jpoley
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "media.h"
#include "scene.h"
#include "music.h"
#include "input.h"
#include "helpers.h"

using namespace WFVO;
namespace WFVO {

extern CScene g_scene;
extern CMusic g_music;

#define STICK_DEAD_ZONE     7000
#define STICK_SCALE_FACTOR  16000.0f

HANDLE hDuke[XGetPortCount()];

static const DWORD XIDMasks[] = {
    XDEVICE_PORT0_MASK,
    XDEVICE_PORT1_MASK,
    XDEVICE_PORT2_MASK,
    XDEVICE_PORT3_MASK
    };

#define MAXPORTS NUMELEMS(XIDMasks)

/* uncomment if we add support for sub devices (such as mus)
static const DWORD XMUMasks[] = {
    XDEVICE_PORT0_TOP_MASK,
    XDEVICE_PORT1_TOP_MASK,
    XDEVICE_PORT2_TOP_MASK,
    XDEVICE_PORT3_TOP_MASK,
    XDEVICE_PORT0_BOTTOM_MASK,
    XDEVICE_PORT1_BOTTOM_MASK,
    XDEVICE_PORT2_BOTTOM_MASK,
    XDEVICE_PORT3_BOTTOM_MASK
    };
*/

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
static void HandleInput(unsigned port, XINPUT_STATE *state);


#define HOLDTIME 300  //.3 seconds
#define REPEATTIME 30 //once per frame, at 30 FPS
#define UP         0
#define HOLDING    1
#define DOWN       2


void CheckUserInput(void)
    {
    // check for device insertions and removals
    DWORD addDuke, removeDuke;
    XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &addDuke, &removeDuke);
    InputDukeInsertions(addDuke, removeDuke);

    // check for user input
    XINPUT_STATE state;
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(hDuke[port] == NULL) continue;

        XInputGetState(hDuke[port], &state);
        HandleInput(port, &state);
        }
    }

void InputDukeInsertions(DWORD add, DWORD remove/*=0*/)
    {
    for(unsigned port=0; port<XGetPortCount(); port++)
        {
        if(remove & XIDMasks[port])
            {
            if(hDuke[port]) XInputClose(hDuke[port]);
            hDuke[port] = NULL;
            }
        if(add & XIDMasks[port])
            {
            hDuke[port] = XInputOpen(XDEVICE_TYPE_GAMEPAD, port, 0, NULL);
            }
        }
    }

//------------------------------------------------------------------------------
//	Local Functions:
//------------------------------------------------------------------------------
void HandleInput(unsigned port, XINPUT_STATE *state)
    {
    //State of D-Pad
    static DWORD dwRightState[MAXPORTS]={UP};
    static DWORD dwLeftState[MAXPORTS]={UP};
    static DWORD dwStartTimeRight[MAXPORTS] = {0};
    static DWORD dwStartTimeLeft[MAXPORTS] = {0}; 

    //Needed to keep track not only of positions, but what has changed.    
    static XINPUT_STATE stateOld[MAXPORTS];
    static bFirstIteration[MAXPORTS] = {TRUE};

    BOOL bChange = FALSE;
    DWORD dwTemp = 0;


    //If the first time, make it appear that no changes were made.
    if (bFirstIteration[port])
    {
        stateOld[port] = *state;
        bFirstIteration[port] = FALSE;
    }

    //Log 
    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_UP))
    {
        if (--g_TestParams.dwDMSelected == 0xFFFFFFFF)
            g_TestParams.dwDMSelected = NUM_SELECTIONS - 1;
    }

    if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN && !(stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_DOWN))
    {
        if (++g_TestParams.dwDMSelected == NUM_SELECTIONS)
            g_TestParams.dwDMSelected = 0;
    }

	//
	// set text state based on button state and previous scene text state
	//
	if ( state->Gamepad.wButtons & XINPUT_GAMEPAD_START && ! ( stateOld[port].Gamepad.wButtons & XINPUT_GAMEPAD_START ) )
	{
		g_scene.SetDrawText( ! g_scene.DrawText() );
	}

    // ZOOM: trigger
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] / 255.0f);
        }
    if(state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0x0A)
        {
        g_scene.m_camera.Zoom((float)state->Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] / -255.0f);
        }

    // Rotate X Y: left thumb stick
    if(!(state->Gamepad.sThumbLX > -STICK_DEAD_ZONE && state->Gamepad.sThumbLX < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateY(state->Gamepad.sThumbLX/STICK_SCALE_FACTOR);
        }
    if(!(state->Gamepad.sThumbLY > -STICK_DEAD_ZONE && state->Gamepad.sThumbLY < STICK_DEAD_ZONE))
        {
        g_scene.m_camera.RotateX(state->Gamepad.sThumbLY/STICK_SCALE_FACTOR);
        }


	// process DMUSIC input only if text is displayed    
    if ( g_scene.DrawText() )
    {
        //Handle right side of the D-Pad
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_RIGHT)
        {
            bChange = FALSE;
            if (UP == dwRightState[port])
            {
                bChange = TRUE;
                dwRightState[port] = HOLDING;
                dwStartTimeRight[port] = timeGetTime();
            }
            else if (HOLDING == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > HOLDTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                    dwRightState[port] = DOWN;
                }
            }
            else if (DOWN == dwRightState[port])
            {
                if (timeGetTime() - dwStartTimeRight[port] > REPEATTIME)
                {
                    dwStartTimeRight[port] = timeGetTime();
                    bChange = TRUE;
                }
            }

            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			    case 0:
				    g_TestParams.dwNumBalls++;
				    if ( g_TestParams.dwNumBalls > g_TestParams.dwMaxBalls )
					    g_TestParams.dwNumBalls = g_TestParams.dwMaxBalls;

				    g_scene.AddBall();
				    break;

			    case 1:
				    g_TestParams.dwNumLights++;
				    if ( g_TestParams.dwNumLights > g_TestParams.dwMaxLights )
					    g_TestParams.dwNumLights = g_TestParams.dwMaxLights;

				    g_scene.AddLight();
				    break;

			    case 2:
				    g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				    break;

			    case 3:
				    g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				    break;

			    case 4:
				    g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				    break;

			    case 5:
				    g_TestParams.dwSparksPerCollision++;
				    break;

                case 6:
                    g_music.NextSegment();
                    break;
                case 7:
                    g_TestParams.lDMMasterVolume += 100;
                    if (g_TestParams.lDMMasterVolume > 0)
                        g_TestParams.lDMMasterVolume = 0;
                    g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
                    break;
                case 8: 
                    g_TestParams.fDMMasterTempo += 0.1f;
                    if (g_TestParams.fDMMasterTempo > 100.f)
                        g_TestParams.fDMMasterTempo = 100.f;
                    g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
                    break;
                case 9: 
                    if (g_TestParams.lDMMasterTranspose < 127)
                    {
                        g_TestParams.lDMMasterTranspose += 1;
                        g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);
                    }
                    break;
                case 10: 
                    g_music.GetReverb(&dwTemp);
                    if (0xFFFFFFFF == dwTemp)
                        dwTemp = 127;                    
                    if (dwTemp < 127)
                    {
                        dwTemp++;
                        g_music.SetReverb((unsigned short)dwTemp);
                    }
                    break;
                case 11:
                    g_TestParams.lDSVolume += 100;

				    if ( g_TestParams.lDSVolume > 0 )
					    g_TestParams.lDSVolume = 0;

                    break;

                case 12:
                    g_TestParams.dwDSFreq += 100;

				    if ( g_TestParams.dwDSFreq > 96000 )
					    g_TestParams.dwDSFreq = 96000;

                    break;
                }
            }
        }
        else
        {
            dwRightState[port] = UP;
        }

        //Handle left side of the D-Pad.
        if (state->Gamepad.wButtons & XINPUT_GAMEPAD_DPAD_LEFT)
        {
            bChange = FALSE;
            if (UP == dwLeftState[port])
            {
                bChange = TRUE;
                dwLeftState[port] = HOLDING;
                dwStartTimeLeft[port] = timeGetTime();
            }
            else if (HOLDING == dwLeftState[port])
            {
                DWORD dwTemp = timeGetTime();

                if (timeGetTime() - dwStartTimeLeft[port] > HOLDTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                    dwLeftState[port] = DOWN;
                }
            }
            else if (DOWN == dwLeftState[port])
            {
                if (timeGetTime() - dwStartTimeLeft[port] > REPEATTIME)
                {
                    dwStartTimeLeft[port] = timeGetTime();
                    bChange = TRUE;
                }
            }
 
            if (bChange)
            {
                switch (g_TestParams.dwDMSelected)
                {
			case 0:
				g_TestParams.dwNumBalls--;
				if ( g_TestParams.dwNumBalls == 0xFFFFFFFF )
					g_TestParams.dwNumBalls = 0;

				g_scene.RemoveBall();
				break;

			case 1:
				g_TestParams.dwNumLights--;
				if ( g_TestParams.dwNumLights == 0xFFFFFFFF )
					g_TestParams.dwNumLights = 0;

				g_scene.RemoveLight();
				break;

			case 2:
				g_TestParams.bDrawWireframe = !g_TestParams.bDrawWireframe;
				break;

			case 3:
				g_TestParams.bRelativeSpeed = !g_TestParams.bRelativeSpeed;
				break;

			case 4:
				g_TestParams.bSparksAreLights = !g_TestParams.bSparksAreLights;
				break;

			case 5:
				g_TestParams.dwSparksPerCollision--;
				if ( g_TestParams.dwSparksPerCollision == 0xFFFFFFFF )
					g_TestParams.dwSparksPerCollision = 0;
				break;

            case 6:
                g_music.NextSegment();
                break;
            case 7:
                g_TestParams.lDMMasterVolume -= 100;
                if (g_TestParams.lDMMasterVolume < -10000)
                    g_TestParams.lDMMasterVolume = -10000;
                g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
                break;
            case 8: 
                g_TestParams.fDMMasterTempo -= 0.1f;
                if (g_TestParams.fDMMasterTempo < 0.f)
                    g_TestParams.fDMMasterTempo = 0.f;
                g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
                break;
            case 9: 
                if (g_TestParams.lDMMasterTranspose > -128)
                {
                    g_TestParams.lDMMasterTranspose -= 1;
                    g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);
                }
                break;
            case 10: 
                g_music.GetReverb(&dwTemp);
                if (0xFFFFFFFF == dwTemp)
                    dwTemp = 127;                    
                if (dwTemp > 0)
                {
                    dwTemp--;
                    g_music.SetReverb((unsigned short)dwTemp);
                }
                break;

            case 11:
                g_TestParams.lDSVolume -= 100;

				if ( g_TestParams.lDSVolume < -10000 )
					g_TestParams.lDSVolume = -10000;

                break;

            case 12:
                g_TestParams.dwDSFreq -= 100;

				if ( g_TestParams.dwDSFreq < DSBFREQUENCY_MIN || g_TestParams.dwDSFreq > 96000 )
					g_TestParams.dwDSFreq = DSBFREQUENCY_MIN;

                break;
                }
            }
        }
        else
        {
            dwLeftState[port] = UP;
        }
    }


    //Store the last frame's joystick state.
    stateOld[port] = *state;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\media.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.h

Abstract:

	Media Stress - D3D, DSound, DMusic and others

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\helpers.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Helpers.cpp

Abstract:

	Helper functions for logging, etc

Author:

	Daniel Haffner (danhaff) 04/29/01

Revision History:
--*/


#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include <xgmath.h>
#include <dmusici.h>
#include "stdio.h"

namespace WFVO {

//TESTPARAMS STUFF
struct TESTPARAMS
{
    
    DWORD dwSeed;
    DWORD dwBallDetail;
    DWORD dwWallDetail;
    DWORD dwLightDetail;
    DWORD dwNumLayers;	
    DWORD dwNumBalls;	
    DWORD dwMaxBalls;
    DWORD dwNumLights;
    DWORD dwMaxLights;
    FLOAT fRadius;
    FLOAT fMaxSpeed;
    FLOAT fMinSpeed;
    BOOL  bTextureBalls;
    CHAR  szBallBaseTex[MAX_PATH];
    CHAR  szBallBumpTex[MAX_PATH];
    CHAR  szSphereBaseTex[MAX_PATH];
    CHAR  szLightVSH[MAX_PATH];
    CHAR  szSparkVSH[MAX_PATH];
    BOOL  bDMusic;
    BOOL  bDMDoWorkLocally;
    BOOL  bDMUseGM;
    DWORD dwDMVoiceCount;
    CHAR  szDMStressDir [MAX_PATH];
    CHAR  szDMSupportDir[MAX_PATH];
    CHAR  szDMAudioPath[MAX_PATH];
    CHAR  szDMHeap[MAX_PATH];
    DWORD dwDMFixedHeapSizeNorm;
    DWORD dwDMFixedHeapSizePhys;
    LPSTR *ppDMSegments;
    DWORD dwDMSegments;
    BOOL  bDMLoaderThread;
	BOOL  bDrawWireframe;
	BOOL  bRelativeSpeed;
	BOOL  bD3DPerf;
    DWORD dwMaxSparks;
    BOOL  bSparksAreLights;
    DWORD dwSparksPerCollision;
	DWORD dwSparkMaxAge;
    DWORD dwFileIOSize;
    LONG  lDMMasterVolume;
    float fDMMasterTempo;
    short lDMMasterTranspose;
    DWORD dwDMDebugLevel;
    DWORD dwDMRIPLevel;
    DWORD dwDMSelected;

    CHAR  szDSScratchImage[MAX_PATH];
    CHAR  szDSHRTF[MAX_PATH];

    CHAR szDSEnvironment[MAX_PATH];
    BOOL b3DSound;
    CHAR szLightSound[MAX_PATH];
    CHAR szBounceSound[MAX_PATH];
    BOOL bSubMixBallSound;
    BOOL bLightSound;
	LONG lDSVolume;
	DWORD dwDSFreq;
    LONG lAmbientVolume;
    BOOL bCopyMediaFromNetwork;

    DWORD dwMultiSampleType;
    DWORD dwBackBufferCount;
    BOOL bCycleDisplayModes;
    DWORD dwCycleTime;

    //Stuff for new DSound thread.
    DWORD dwDSSThreads;
    DWORD dwDSSTotalBuffers2D;
    DWORD dwDSSTotalBuffers3D;
    DWORD dwDSSTotalStreams2D;
    DWORD dwDSSTotalStreams3D;
    DWORD dwDSSMixinBuffers2D;
    DWORD dwDSSMixinBuffers3D;
    DWORD dwDSSSends2D;
    DWORD dwDSSSends3D;
    DWORD dwDSSWait;
};


extern TESTPARAMS g_TestParams;
HRESULT LoadTestParams(void);
HRESULT FreeTestParams(void);
HRESULT SanityCheckTestParams(void);
HRESULT SanityCheckFiles(void);
HRESULT DownloadScratch(IDirectSound *pDSound, PCHAR pszScratchFile);


//OTHER STUFF
HRESULT Log(LPSTR szFormat, ...);
typedef HRESULT (*LOADPROC)(LPSTR szFullPath, LPVOID pVoid);
HRESULT RecurseDirectory(LPSTR szDir, LOADPROC LoadFile, LPVOID pVoid);
HRESULT ChopPath(const char *szFullString, LPSTR szPathOut, LPSTR szFileOut);
HRESULT TranslatePath(const char *szFullString, LPSTR szRemotePath, LPSTR szLocalDir );
void WaitForThreadEnd(HANDLE *phThread);


//DMusic segment playback stuff
HRESULT WaitForSegmentStop (IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT WaitForSegmentStart(IN IDirectMusicPerformance8* ptPerf8, IN IDirectMusicSegment8* ptSegment8, IN IDirectMusicSegmentState8* ptSegmentState8,IN DWORD dwTimeout);
HRESULT ExpectSegmentStart(IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);
HRESULT ExpectSegmentStop (IDirectMusicPerformance8 *ptPerf8, IDirectMusicSegment8 *ptSegment8, IDirectMusicSegmentState8 *ptSegmentState8, DWORD dwTimeout, LPSTR szSegname);
void OptionalDoWork(void);




inline DWORD F2DW(float f) { return *((LPDWORD)&f); }

inline D3DCOLOR VectorToColor(XGVECTOR3* pv) {
    
    return ((BYTE)((pv->x + 1.0f) / 2.0f * 255.0f) << 16) |
           ((BYTE)((pv->y + 1.0f) / 2.0f * 255.0f) << 8)  |
            (BYTE)((pv->z + 1.0f) / 2.0f * 255.0f);
}

D3DCOLOR ModulateColors(D3DCOLORVALUE* pdcv1, D3DCOLORVALUE* pdcv2);

struct AUDIOPATHPAIR
{
    LPSTR szString;
    DWORD dwValue;
};

extern AUDIOPATHPAIR AudioPathPairs[4];
extern HANDLE g_hLogMedia;



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\DSStress.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	DSound.cpp

Abstract:

	DSound Playback engine for stress

Author:

	Dan Haffner(danhaff) 16-Jan-2002

Environment:

	Xbox only

Revision History:

	16-Jan-2002     danhaff
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "media.h"
#include "helpers.h"
#include "macros.h"
#include "dsstress.h"


using namespace WFVO;

/*
class SE
{
public: 
    DWORD m_dwStatus;
    DWORD m_dwPacket;
    m_pStream;
    m


};
*/


//------------------------------------------------------------------------------
//	Prototypes
//------------------------------------------------------------------------------
DWORD DSStressThreadProc(void *DSStress);


//------------------------------------------------------------------------------
//	Defines
//------------------------------------------------------------------------------
#define MAX_SOUNDS2D 2000
#define MAX_SOUNDS3D 2000
#define MAX_PLAYINGSOUNDS2D 188
#define MAX_PLAYINGSOUNDS3D 64
#define MAX_ATTACHEDPACKETS 64
//#define WAIT 25000
/********************************************************************************
********************************************************************************/
class DSStress
{
public:
    DSStress(void);
    ~DSStress(void);
    HRESULT Init(DWORD dwBuffers2D, DWORD dwBuffers3D, DWORD dwStreams2D, DWORD dwStreams3D, DWORD dwMixinBuffers2D, DWORD dwMixinBuffers3D, DWORD dwSends2D, DWORD dwSends3D, DWORD dwWait);
    HRESULT Shutdown(void);

private:
    
    HRESULT Help_CreateSoundBuffer(BOOL b3D, WORD wChannels, BOOL bMixin, IDirectSoundBuffer **ppBuffer);
    HRESULT Help_CreateSoundStream(BOOL b3D, WORD wChannels, IDirectSoundStream **ppStream);
    
    HANDLE m_hThread;
    BOOL  m_bInitialized;
    DWORD m_dwStreams2D;
    DWORD m_dwStreams3D;
    DWORD m_dwBuffers2D;
    DWORD m_dwBuffers3D;
    DWORD m_dwMixinBuffers2D;
    DWORD m_dwMixinBuffers3D;
    DWORD m_dwSends2D;
    DWORD m_dwSends3D;
    DWORD m_dwWait;

    DWORD m_dwPlayingSounds2D;
    DWORD m_dwPlayingSounds3D;
    DWORD m_dwStatus2D[MAX_SOUNDS2D];
    DWORD m_dwStatus3D[MAX_SOUNDS3D];

//    XMEDIAPACKET xmp2D;
//    XMEDIAPACKET xmp3D;
    DWORD        m_dwPacket2D[MAX_SOUNDS2D];;
    DWORD        m_dwPacket3D[MAX_SOUNDS3D];;

    DWORD m_bQuitSignal;
    IDirectSoundStream *m_pStream2D[MAX_SOUNDS2D];
    IDirectSoundStream *m_pStream3D[MAX_SOUNDS3D];
    IDirectSoundBuffer *m_pBuffer2D[MAX_SOUNDS2D];
    IDirectSoundBuffer *m_pBuffer3D[MAX_SOUNDS3D];
    IDirectSoundBuffer *m_pMixinBuffer2D[MAX_SOUNDS2D];
    IDirectSoundBuffer *m_pMixinBuffer3D[MAX_SOUNDS3D];
    LPVOID              m_pvBufferData;

    friend DWORD DSStressThreadProc(void *DSStress);
};


/********************************************************************************
********************************************************************************/
DSStress::DSStress(void)
{
    m_hThread   = NULL;
    m_bInitialized  = NULL;
    m_dwStreams2D = 0;
    m_dwStreams3D = 0;
    m_dwBuffers2D = 0;
    m_dwBuffers3D = 0;
    m_dwMixinBuffers2D = 0;
    m_dwMixinBuffers3D = 0;
    m_dwSends2D= 0;
    m_dwSends3D= 0;
    m_dwWait   = 0;

    memset(m_pStream2D, 0, sizeof(IDirectSoundStream *) * MAX_SOUNDS2D);
    memset(m_pStream3D, 0, sizeof(IDirectSoundStream *) * MAX_SOUNDS3D);
    memset(m_pBuffer2D, 0, sizeof(IDirectSoundBuffer *) * MAX_SOUNDS2D);
    memset(m_pBuffer3D, 0, sizeof(IDirectSoundBuffer *) * MAX_SOUNDS3D);
    memset(m_pMixinBuffer2D, 0, sizeof(IDirectSoundBuffer *) * MAX_SOUNDS2D);
    memset(m_pMixinBuffer3D, 0, sizeof(IDirectSoundBuffer *) * MAX_SOUNDS3D);

//    memset(xmp2D,       0,        sizeof(XMEDIAPACKET) * MAX_SOUNDS2D);
//    memset(xmp3D,       0,        sizeof(XMEDIAPACKET) * MAX_SOUNDS3D);
    memset(m_dwPacket2D,  XMEDIAPACKET_STATUS_SUCCESS,        sizeof(DWORD)        * MAX_SOUNDS2D);
    memset(m_dwPacket3D,  XMEDIAPACKET_STATUS_SUCCESS,        sizeof(DWORD)        * MAX_SOUNDS3D);

    memset(m_dwStatus2D,  FALSE, sizeof(DWORD)* MAX_SOUNDS2D);
    memset(m_dwStatus3D,  FALSE, sizeof(DWORD)* MAX_SOUNDS3D);

    m_dwPlayingSounds2D = 0;
    m_dwPlayingSounds3D = 0;

    m_pvBufferData = NULL;
    m_bQuitSignal = FALSE;

};

/********************************************************************************
********************************************************************************/
DSStress::~DSStress(void)
{
ASSERT(m_bInitialized);
delete[] m_pvBufferData;
m_pvBufferData = NULL;
};


/********************************************************************************
********************************************************************************/
HRESULT DSStress::Shutdown(void)
{
ASSERT(m_bInitialized);
m_bQuitSignal = TRUE;
WaitForThreadEnd(&m_hThread);
return S_OK;
}


/********************************************************************************
********************************************************************************/
HRESULT DSStress::Init(DWORD dwBuffers2D, DWORD dwBuffers3D, DWORD dwStreams2D, DWORD dwStreams3D, DWORD dwMixinBuffers2D, DWORD dwMixinBuffers3D, DWORD dwSends2D, DWORD dwSends3D, DWORD dwWait)
{
    ASSERT(!m_bInitialized);
    ASSERT(dwBuffers2D <= MAX_SOUNDS2D);
    ASSERT(dwBuffers3D <= MAX_SOUNDS3D);
    ASSERT(dwStreams2D <= MAX_SOUNDS2D);
    ASSERT(dwStreams3D <= MAX_SOUNDS3D);
    ASSERT(dwMixinBuffers2D <= MAX_SOUNDS2D);
    ASSERT(dwMixinBuffers3D <= MAX_SOUNDS3D);

    HRESULT hr = S_OK;
    DWORD i = 0;


    //Copy the in-params.
    m_dwBuffers2D = dwBuffers2D;
    m_dwBuffers3D = dwBuffers3D;
    m_dwStreams2D = dwStreams2D;
    m_dwStreams3D = dwStreams3D;
    m_dwMixinBuffers2D = dwMixinBuffers2D;
    m_dwMixinBuffers3D = dwMixinBuffers3D;
    //m_dwWait           = dwWait;
    
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************
    //*********************************************************    
    //***************  REMOVE THIS!!! *************************
    m_dwWait           = 25000;



    m_dwSends2D = dwSends2D;
    m_dwSends3D = dwSends3D;

    //None of the sounds start off playing.
    //  Streams take resources all the time (currently)
    //  MixinBuffers take resources all the time.
    m_dwPlayingSounds2D = dwStreams2D + dwMixinBuffers2D;
    m_dwPlayingSounds3D = dwStreams3D + dwMixinBuffers3D;

    //Create sound data.
    if (SUCCEEDED(hr))
    {
        m_pvBufferData = new BYTE[30000];
        CHECKALLOC(m_pvBufferData);
        for (i=0; i<30000; i++)
            ((char *)(m_pvBufferData))[i] = rand() % 256;
    }

    //Create all the buffers and streams.
    if (SUCCEEDED(hr))
    {
        //Create mixin buffers first so we can send to them.
        for (i=0; i<dwMixinBuffers2D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundBuffer(FALSE, 1, TRUE, &m_pMixinBuffer2D[i]));        
        }
        for (i=0; i<dwMixinBuffers3D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundBuffer(TRUE, 1, TRUE, &m_pMixinBuffer3D[i]));        
        }

        //Create normal buffers.
        for (i=0; i<dwBuffers2D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundBuffer(FALSE, 1, FALSE, &m_pBuffer2D[i]));        
        }
        for (i=0; i<dwBuffers3D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundBuffer(TRUE, 1, FALSE, &m_pBuffer3D[i]));        
        }
        for (i=0; i<dwStreams2D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundStream(FALSE, 1, &m_pStream2D[i]));        
        }
        for (i=0; i<dwStreams3D && SUCCEEDED(hr); i++)
        {
            CHECKRUN(Help_CreateSoundStream(TRUE, 1, &m_pStream3D[i]));        
        }
    }
    

    if (SUCCEEDED(hr))
    {
        m_hThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)DSStressThreadProc,(void*)this, 0, NULL);
        if (!m_hThread)
        {
            Log("CMusic::LoadNextSegment: CreateThread(LoadNextSegmentThreadProc) failed!!\n");
            hr = E_FAIL;        
        }
    }

    return S_OK;
}


/********************************************************************************
********************************************************************************/
DWORD DSStressThreadProc(void *pvDSStress)
{
HRESULT hr = S_OK;
DSStress *pDSStress = (DSStress*)pvDSStress;
XMEDIAPACKET xmp = {0};
DWORD i= 0;
DWORD dwStatus = 0;


ASSERT(pvDSStress);
ASSERT(!pDSStress->m_bInitialized);

    while (!pDSStress->m_bQuitSignal)
    {


        //Process the mixin buffers first.
        for (i=0; i<pDSStress->m_dwMixinBuffers2D && SUCCEEDED(hr); i++)
        {
            if (!(rand() % pDSStress->m_dwWait))
            {

                CHECKRUN(pDSStress->m_pMixinBuffer2D[i]->SetFrequency(DSBFREQUENCY_MIN + rand() % (DSBFREQUENCY_MAX - DSBFREQUENCY_MIN)));

//                CHECKRUN(pDSStress->m_pMixinBuffer2D[i]->Stop());
//                CHECKRUN(pDSStress->m_pMixinBuffer2D[i]->SetCurrentPosition(0));
//                CHECKRUN(pDSStress->m_pMixinBuffer2D[i]->Play(0, 0, rand() % 2 ? DSBPLAY_LOOPING : 0));                    

            }
        }
        for (i=0; i<pDSStress->m_dwMixinBuffers3D && SUCCEEDED(hr); i++)
        {
            if (!(rand() % pDSStress->m_dwWait))
            {
                CHECKRUN(pDSStress->m_pMixinBuffer3D[i]->SetFrequency(DSBFREQUENCY_MIN + rand() % (DSBFREQUENCY_MAX - DSBFREQUENCY_MIN)));
//                CHECKRUN(pDSStress->m_pMixinBuffer3D[i]->Stop());
//                CHECKRUN(pDSStress->m_pMixinBuffer3D[i]->SetCurrentPosition(0));
//                CHECKRUN(pDSStress->m_pMixinBuffer3D[i]->Play(0, 0, rand() % 2 ? DSBPLAY_LOOPING : 0));                    

            }
        }





        //Start and/or stop some buffers.
        for (i=0; i<pDSStress->m_dwBuffers2D && SUCCEEDED(hr); i++)
        {

            //Get the status.
            CHECKRUN(pDSStress->m_pBuffer2D[i]->GetStatus(&dwStatus));
            
            //Check to see if this sound has ended.
            if (pDSStress->m_dwStatus2D[i])
            {
                if (!(dwStatus & DSBSTATUS_PLAYING))
                {
                    pDSStress->m_dwPlayingSounds2D--;
                    pDSStress->m_dwStatus2D[i] = FALSE;
                    DirectSoundDoWork();
                }
            }
            
            if (pDSStress->m_dwPlayingSounds2D < MAX_PLAYINGSOUNDS2D)
            {
                if (!(rand() % pDSStress->m_dwWait))
                {
                    CHECKRUN(pDSStress->m_pBuffer2D[i]->Stop());
                    CHECKRUN(pDSStress->m_pBuffer2D[i]->SetCurrentPosition(0));
                    CHECKRUN(pDSStress->m_pBuffer2D[i]->Play(0, 0, 0));                    

                    //If it wasn't playing but it is now, then note that.
                    if (!(dwStatus & DSBSTATUS_PLAYING))
                    {
                        pDSStress->m_dwStatus2D[i] = TRUE;
                        pDSStress->m_dwPlayingSounds2D++;
                    }
                }
            }
        }
        //Start and/or stop some buffers.
        for (i=0; i<pDSStress->m_dwBuffers3D && SUCCEEDED(hr); i++)
        {

            //Get status.
            CHECKRUN(pDSStress->m_pBuffer3D[i]->GetStatus(&dwStatus));

            //If this sound has ended, then note that.
            if (pDSStress->m_dwStatus3D[i])
            {
                if (!(dwStatus & DSBSTATUS_PLAYING))
                {
                    pDSStress->m_dwPlayingSounds3D--;
                    pDSStress->m_dwStatus3D[i] = FALSE;
                    DirectSoundDoWork();
                }
            }


            if (pDSStress->m_dwPlayingSounds3D < MAX_PLAYINGSOUNDS3D)
            {
                if (!(rand() % pDSStress->m_dwWait))
                {
                    CHECKRUN(pDSStress->m_pBuffer3D[i]->Stop());
                    CHECKRUN(pDSStress->m_pBuffer3D[i]->SetCurrentPosition(0));
                    CHECKRUN(pDSStress->m_pBuffer3D[i]->Play(0, 0, 0));
                
                    //If it wasn't playing but it is now, then note that.
                    if (!(dwStatus & DSBSTATUS_PLAYING))
                    {
                        pDSStress->m_dwStatus3D[i] = TRUE;
                        pDSStress->m_dwPlayingSounds3D++;
                    }
                }
            }
        }


        if (pDSStress->m_dwPlayingSounds2D < MAX_PLAYINGSOUNDS2D)
        {
            for (i=0; i<pDSStress->m_dwStreams2D && SUCCEEDED(hr); i++)
            {            

                if (pDSStress->m_dwPacket2D[i] == XMEDIAPACKET_STATUS_SUCCESS)
                {
                    if (!(rand() % pDSStress->m_dwWait))
                    {
                        xmp.pvBuffer = pDSStress->m_pvBufferData;
                        xmp.dwMaxSize = 30000;
                        xmp.pdwStatus = &pDSStress->m_dwPacket2D[i];
                        CHECKRUN(pDSStress->m_pStream2D[i]->Process(&xmp, NULL));
                    }
                }            
            }
        }

        if (pDSStress->m_dwPlayingSounds3D < MAX_PLAYINGSOUNDS3D)
        {
            for (i=0; i<pDSStress->m_dwStreams3D && SUCCEEDED(hr); i++)
            {
                if (pDSStress->m_dwPacket3D[i] == XMEDIAPACKET_STATUS_SUCCESS)
                {
                    if (!(rand() % pDSStress->m_dwWait))
                    {
                        xmp.pvBuffer = pDSStress->m_pvBufferData;
                        xmp.dwMaxSize = 30000;
                        xmp.pdwStatus = &pDSStress->m_dwPacket3D[i];
                        CHECKRUN(pDSStress->m_pStream3D[i]->Process(&xmp, NULL));
                    }
                }            
            }
        }

        //Take care of stream-related items in case there are no buffers.
        DirectSoundDoWork();
    }

    return 0;
};





/********************************************************************************
********************************************************************************/
HRESULT DSStress::Help_CreateSoundBuffer(BOOL b3D, WORD wChannels, BOOL bMixin, IDirectSoundBuffer **ppBuffer)
{
    HRESULT hr = S_OK;    

    ASSERT(wChannels < 8);
    
    DSBUFFERDESC dsbd = {0};
    dsbd.dwSize = sizeof(dsbd);
    
    //Can't have locdefer mixin buffahs.
    if (!bMixin)
        dsbd.dwFlags = DSBCAPS_LOCDEFER;

    if (b3D)
        dsbd.dwFlags |= DSBCAPS_CTRL3D;

    if (bMixin)
        dsbd.dwFlags |= DSBCAPS_MIXIN;
    
    //Set up the wave format.
    WAVEFORMATEX wfx = {0};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = wChannels;
    wfx.nSamplesPerSec = 8000;
    wfx.wBitsPerSample = 8;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize = 0;
    
    if (!bMixin)
        dsbd.lpwfxFormat = &wfx;
    else
        dsbd.lpwfxFormat = NULL;

    if (!bMixin)
        dsbd.dwBufferBytes = 30000;
    else
        dsbd.dwBufferBytes = 0;


    CHECKRUN(DirectSoundCreateBuffer(&dsbd, ppBuffer));

    if (!bMixin)
    {
        CHECKRUN((*ppBuffer)->SetBufferData(m_pvBufferData, dsbd.dwBufferBytes));
        
        //assume mixin buffers have already been created.
        if (!b3D)
        {            
            if (m_dwSends2D)
            {
                CHECKRUN((*ppBuffer)->SetOutputBuffer(m_pMixinBuffer2D[rand() % m_dwMixinBuffers2D]));
                m_dwSends2D--;
            }
            else if (m_dwSends3D)
            {
                CHECKRUN((*ppBuffer)->SetOutputBuffer(m_pMixinBuffer3D[rand() % m_dwMixinBuffers3D]));
                m_dwSends3D--;
            }
        }

    }

    return hr;
}



/********************************************************************************
********************************************************************************/
HRESULT DSStress::Help_CreateSoundStream(BOOL b3D, WORD wChannels, IDirectSoundStream **ppStream)
{
    HRESULT hr = S_OK;    
    
    DSSTREAMDESC dssd = {0};
    dssd.dwFlags = DSBCAPS_LOCDEFER;
    if (b3D)
        dssd.dwFlags |= DSBCAPS_CTRL3D;

    dssd.dwMaxAttachedPackets = MAX_ATTACHEDPACKETS;
    
    //Set up the wave format.
    WAVEFORMATEX wfx = {0};
    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.nChannels = wChannels;
    wfx.nSamplesPerSec = 8000;
    wfx.wBitsPerSample = 8;
    wfx.nBlockAlign = wfx.nChannels * wfx.wBitsPerSample / 8;
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize = 0;
    dssd.lpwfxFormat = &wfx;

    CHECKRUN(DirectSoundCreateStream(&dssd, ppStream));
    return hr;
}


DSStress *g_pDSStress = NULL;
DWORD     g_dwThreads = NULL;



/********************************************************************************
********************************************************************************/
HRESULT StartDSStress(DWORD dwThreads, DWORD dwBuffers2D, DWORD dwBuffers3D, DWORD dwStreams2D, DWORD dwStreams3D, DWORD dwMixinBuffers2D, DWORD dwMixinBuffers3D, DWORD dwSends2D, DWORD dwSends3D, DWORD dwWait)
{
    HRESULT hr = S_OK;
    DWORD i = 0;

    g_dwThreads = dwThreads;

    g_pDSStress = new DSStress[g_dwThreads];    
    CHECKALLOC(g_pDSStress);

    for (i=0; i<g_dwThreads && SUCCEEDED(hr); i++)
    {
        CHECKRUN(g_pDSStress[i].Init(dwBuffers2D, dwBuffers3D, dwStreams2D, dwStreams3D, dwMixinBuffers2D, dwMixinBuffers3D, dwSends2D, dwSends3D, dwWait));
    }    

    return hr;
};



/********************************************************************************
********************************************************************************/
HRESULT StopDSStress(void)
{

    delete []g_pDSStress;
    g_pDSStress = NULL;
    return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Music.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Music.h

Abstract:

	Music Playback engine for stress

Author:

	Dan Haffner(danhaff) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	29-Apr-2001 danhaff
		Initial Version

--*/
#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "dmusici.h"
#include "MusicHeap.h"

namespace WFVO {

#define FILES 5000

enum STATE {eWaiting, eTransitioning, eLoading};
//------------------------------------------------------------------------------
//	CMusic:
//------------------------------------------------------------------------------
class CMusic
{
public:
	CMusic(void);
    ~CMusic(void);
    HRESULT Initialize(void);
	HRESULT Update(void);
    
    //Get information.
    HRESULT GetSegmentTitleCurrent(WCHAR *szSongTitle);
    DWORD   GetBeat(void);

    //Set information
    HRESULT NextSegment(void);
    HRESULT SetMasterTranspose(short lMasterTranspose);
    HRESULT SetMasterTempo(float fMasterTempo);
    HRESULT SetMasterVolume(LONG lMasterVolume);
    HRESULT SetReverb(unsigned short nReverb);
    HRESULT GetReverb(DWORD *nReverb);

    //Get Information
    void GetHeapAllocation          (DWORD *pdwHeapAllocation,           DWORD *pdwHeapAllocationPhysical) ;
    void GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak,       DWORD *pdwHeapAllocationPeakPhysical) ;
    void GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks,     DWORD *pdwHeapAllocationBlocksPhysical) ;
    void GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak, DWORD *pdwHeapAllocationBlocksPeakPhysical) ;

	
private:
    IDirectMusicPerformance *m_pPerf;
    IDirectMusicAudioPath *m_pPath;
    IDirectMusicLoader    *m_pLoader;

    IDirectMusicSegment *m_pSegmentCurrent;
    IDirectMusicSegment *m_pSegmentNext;
    IDirectMusicSegment *m_pSegmentGMReset;
    IMusicHeap *m_pHeapNormal;
    IMusicHeap *m_pHeapPhysical;

    
    HRESULT LoadNextSegment(void);
    HRESULT UpdateBeatState(void);
    HRESULT UpdatePlaybackState(void);
    HRESULT TransitionSegments(void);

    //Current State
    LPSTR m_ppszFiles[FILES];
    DWORD m_dwMaxFiles;
    DWORD m_dwCurrentFile;
    CHAR m_szSegmentTitleCurrent[MAX_PATH];
    CHAR m_szSegmentTitleNext   [MAX_PATH];
    STATE m_eState;
    BOOL  m_dwBeat;
    DWORD m_dwStartTime;

    DWORD m_dwReverb;
   
    //Thread stuff    
    HANDLE m_hThreadLoad;    
    HANDLE m_hThreadTransition;    
    HRESULT m_hrThreadProcReturn;

    //Information to queue up and set.
    BOOL m_bNextSegment;
    
    friend DWORD LoadNextSegmentThreadProc(void *pvMusic);
    friend DWORD TransitionSegmentsThreadProc(void *pvMusic);
};

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\InvertedBall.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001	robheit
		Initial Version

--*/

#ifndef __INVERTEDBALL_H__
#define __INVERTEDBALL_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace WFVO {

//------------------------------------------------------------------------------
//	CInvertedBall
//------------------------------------------------------------------------------
class CInvertedBall
{
public:

	struct Vertex
	{
		XGVECTOR3	position;
		XGVECTOR3	normal;
		float		tu, tv;
	};

public:

	CInvertedBall(void);
	virtual ~CInvertedBall(void);
	
	HRESULT Create(IDirect3DDevice8*, float, int, int);
	void SetPosition(const XGVECTOR3&);
	const XGVECTOR3& GetMin(void) const;
	const XGVECTOR3& GetMax(void) const;
	void Render(IDirect3DDevice8*, UINT, BOOL);

	int GetNumVerts(void) const;
	int GetNumTris(void) const;
	float GetRadius(void) const;

private:

	void Release(void);

private:

	IDirect3DVertexBuffer8*	m_pVB;
	int						m_numVertices;
	IDirect3DIndexBuffer8*	m_pIB;
	int						m_numTriangles;
	BOOL					m_dontDraw;
	float					m_radius;
	XGMATRIX				m_worldMatrix;
	XGVECTOR3				m_location;
	XGVECTOR3				m_min;
	XGVECTOR3				m_max;

    static UINT             m_uRef;
    static IDirect3DTexture8* m_pd3dtBase;
};
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\MusicHeap.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version

--*/

#pragma once

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "dmusici.h"

namespace WFVO
{


#undef INTERFACE
#define INTERFACE  IMusicHeap
DECLARE_INTERFACE_(IMusicHeap, IDirectMusicHeap)
{
    /*  IUnknown */
    STDMETHOD(QueryInterface)               (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)                (THIS) PURE;
    STDMETHOD_(ULONG,Release)               (THIS) PURE;

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate)   (THIS_ DWORD dwSize, PVOID* pData) PURE;
    STDMETHOD(Free)       (THIS_ PVOID pData) PURE;
    STDMETHOD(GetSize)    (THIS_ PVOID pData, LPDWORD pcbSize) PURE;


    /* IDirectMusicHeapInfo */
    STDMETHOD(GetHeapAllocation          )(THIS_ DWORD *pdwHeapAllocation) PURE;
    STDMETHOD(GetHeapAllocationPeak      )(THIS_ DWORD *pdwHeapAllocationPeak) PURE;
    STDMETHOD(GetHeapAllocationBlocks    )(THIS_ DWORD *pdwHeapAllocationBlocks) PURE;
    STDMETHOD(GetHeapAllocationBlocksPeak)(THIS_ DWORD *pdwHeapAllocationBlocksPeak) PURE;
};                                  


    HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical);
    HRESULT CreateMusicHeapFixed(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);
    HRESULT CreateMusicHeapFixedCache(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize);


}//end "namespace WFVO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\Music.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Music.cpp

Abstract:

	Music Playback engine for stress

Author:

	Dan Haffner(danhaff) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	29-Apr-2001 danhaff
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "media.h"
#include "macros.h"
#include "music.h"
#include "helpers.h"
#include "scene.h"
#include "MusicHeap.h"

using namespace WFVO;

namespace WFVO {

extern CMusic g_music;
extern CScene g_scene;

struct DATA
{
  LPSTR *ppszFiles;
  DWORD *pdwMaxFiles;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT LoadFileCallBack(LPSTR szFullPath, LPVOID pVoid)
{
DATA *pData = (DATA *)pVoid;


    if (strstr(szFullPath, ".wav") || strstr(szFullPath, ".sgt"))
    {
        pData->ppszFiles[*(pData->pdwMaxFiles)] = new CHAR[strlen(szFullPath) + 1];
        strcpy(pData->ppszFiles[*(pData->pdwMaxFiles)], szFullPath);
        (*(pData->pdwMaxFiles))++;
        if (*(pData->pdwMaxFiles) == FILES)
        {
            Log("ERROR!!  With %s, we reached the limit of %d files!!\n", szFullPath, FILES);
            return FALSE;
        }
    }
    return S_OK;
}


#define FILES 5000
void RandomizeFiles(LPSTR *ppszFileNames, DWORD dwCount)
{
LPSTR szTemp = NULL;
DWORD i,j;

    //Go through and swap with a random slot.
    for (i=0; i<dwCount; i++)
    {
        j = rand() % dwCount;

        //swap
        szTemp = ppszFileNames[i];
        ppszFileNames[i] = ppszFileNames[j];
        ppszFileNames[j] = szTemp;
    }
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
CMusic::CMusic(void)
{
m_pPerf = NULL;
m_pPath = NULL;
m_pSegmentCurrent = NULL;
m_pSegmentNext = NULL;
m_pHeapNormal = NULL;
m_pHeapPhysical = NULL;
m_pLoader = NULL;

m_dwMaxFiles= 0;
m_dwCurrentFile = 0;
m_eState = eWaiting;
m_hThreadLoad = NULL;
m_hThreadTransition = NULL;
m_hrThreadProcReturn = S_OK;
m_szSegmentTitleCurrent[0] = 0;
m_szSegmentTitleNext[0] = 0;
m_dwBeat = 0;
m_bNextSegment = FALSE;

m_dwReverb = 0xFFFFFFFF;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
CMusic::~CMusic(void)
{
DWORD i = 0;

    //Wait for threadproc to shut down if we're in one.
    if (eLoading == m_eState)
    {    
        Log("CMusic destruktor: waiting for threadproc -o- content loading to shut down\n");
        WaitForThreadEnd(&m_hThreadLoad);
    }

    //Wait for threadproc to shut down if we're in one.
    if (eTransitioning == m_eState)
    {    
        Log("CMusic destruktor: waiting for threadproc -o- transitioning to shut down\n");
        WaitForThreadEnd(&m_hThreadTransition);
    }



    RELEASE(m_pPath);
    RELEASE(m_pSegmentCurrent);
    RELEASE(m_pSegmentNext);
    RELEASE(m_pSegmentGMReset);
    RELEASE(m_pLoader);
    if (m_pPerf)
    {
        m_pPerf->AddNotificationType(GUID_NOTIFICATION_MEASUREANDBEAT);
        m_pPerf->CloseDown();
        RELEASE(m_pPerf);
    }

    RELEASE(m_pHeapNormal);
    RELEASE(m_pHeapPhysical);

    for (i=0; i<m_dwMaxFiles; i++)
    {
        if (m_ppszFiles[i])
        {
            delete []m_ppszFiles[i];
            m_ppszFiles[i] = NULL;
        }
        else
            Log("ERROR!!  Deleting string of m_ppszFiles[%d] but it was already NULL!\n", i);
    }

};





//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::Initialize(void)
{
HRESULT hr = S_OK;
DATA Data = {0};
DWORD i = 0;
IUnknown *pUnkConfig = NULL;

if (!g_TestParams.bDMusic)
    return S_OK;

//Create the heaps
if (_strcmpi(g_TestParams.szDMHeap, "Default") == 0)
{
    CHECKRUN(DirectMusicInitialize());
}
else if (_strcmpi(g_TestParams.szDMHeap, "Tracking") == 0)
{
    CHECKRUN(CreateMusicHeapTrack(&m_pHeapNormal,   FALSE));
    CHECKRUN(CreateMusicHeapTrack(&m_pHeapPhysical, TRUE));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0)
{
    CHECKRUN(CreateMusicHeapFixed(&m_pHeapNormal,   FALSE, g_TestParams.dwDMFixedHeapSizeNorm));
    CHECKRUN(CreateMusicHeapFixed(&m_pHeapPhysical, TRUE,  g_TestParams.dwDMFixedHeapSizePhys));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedDefault") == 0)
{
    IDirectMusicHeap *pDirectMusicHeapNormal   = NULL;
    IDirectMusicHeap *pDirectMusicHeapPhysical = NULL;
    
    CHECKRUN(DirectMusicCreateFixedSizeHeap        (g_TestParams.dwDMFixedHeapSizeNorm, &pDirectMusicHeapNormal));
    CHECKRUN(DirectMusicCreateFixedSizePhysicalHeap(g_TestParams.dwDMFixedHeapSizePhys, &pDirectMusicHeapPhysical));
    CHECKRUN(DirectMusicInitializeEx(pDirectMusicHeapNormal, pDirectMusicHeapPhysical, DirectMusicDefaultFactory));
    RELEASE(pDirectMusicHeapNormal);
    RELEASE(pDirectMusicHeapPhysical);
}
else if (_strcmpi(g_TestParams.szDMHeap, "FixedCache") == 0)
{
    CHECKRUN(CreateMusicHeapFixedCache(&m_pHeapNormal,   FALSE, g_TestParams.dwDMFixedHeapSizeNorm));
    CHECKRUN(CreateMusicHeapFixedCache(&m_pHeapPhysical, TRUE,  g_TestParams.dwDMFixedHeapSizePhys));
    CHECKRUN(DirectMusicInitializeEx(m_pHeapNormal, m_pHeapPhysical, DirectMusicDefaultFactory));
}

else
{
    Log("ERROR: Invalid value %s for g_TestParams.szDMHeap\n", g_TestParams.szDMHeap);
}


//Create the loader and set GM.DLS on it if requested by user.
CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicLoader, NULL, IID_IDirectMusicLoader, (void **)&m_pLoader));
if (g_TestParams.bDMUseGM)
{
	DMUS_OBJECTDESC DESC;					
    CHAR szTemp[MAX_PATH] = {0};

	memset( &DESC, 0, sizeof(DMUS_OBJECTDESC) );
	DESC.dwSize = sizeof (DMUS_OBJECTDESC);
	DESC.guidClass = CLSID_DirectMusicCollection;  
	        
    sprintf(szTemp, "%s\\gm.dls", g_TestParams.szDMSupportDir);
    mbstowcs(DESC.wszFileName, szTemp, strlen(szTemp));

	DESC.guidObject = GUID_DefaultGMCollection;
	DESC.dwValidData = DMUS_OBJ_CLASS | DMUS_OBJ_FULLPATH | DMUS_OBJ_OBJECT;
	hr = m_pLoader->SetObject(&DESC);
    if(FAILED(hr))
    {
        Log("SetObject on GM.DLS object returned %08Xh; continuing to load anyway\n",hr);
        hr = S_OK;
    }
}


CHECKRUN(DirectMusicCreateInstance(CLSID_DirectMusicPerformance, NULL, IID_IDirectMusicPerformance, (void **)&m_pPerf));
CHECK   (DirectMusicSetDebugLevel(g_TestParams.dwDMDebugLevel, g_TestParams.dwDMRIPLevel));
CHECKRUN(m_pPerf->InitAudioX(0, 0, g_TestParams.dwDMVoiceCount, g_TestParams.bDMDoWorkLocally ? DMUS_INITAUDIO_NOTHREADS : 0));


for (i=0; i<NUMELEMS(AudioPathPairs); i++)
{
    if (_strcmpi((const char *)AudioPathPairs[i].szString, g_TestParams.szDMAudioPath)==0)
    {
        CHECKRUN(m_pPerf->CreateStandardAudioPath(AudioPathPairs[i].dwValue, 128, TRUE, &m_pPath));
        break;
    }
}

//Load up the GMReset segment for future use.
CHAR szTemp[MAX_PATH] = {0};
CHECK(sprintf(szTemp, "%s\\GMReset.sgt", g_TestParams.szDMSupportDir));
CHECKRUN(m_pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szTemp, (void **)&m_pSegmentGMReset));

g_music.SetMasterVolume(g_TestParams.lDMMasterVolume);
g_music.SetMasterTempo(g_TestParams.fDMMasterTempo);
g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);

/*
TODO: LOAD UP YOUR AUDIOPATH CONFIG FILE HERE!!
if (!m_pPath)
{
CHECKRUN(
CHECKRUN(m_pPerf->CreateAudioPath(DMUS_APATH_SHARED_STEREOPLUSREVERB, 128, TRUE, &m_pPath));
*/


//After we're done, g_szFiles will contain a list of files, and g_dwFiles will contain the number.
m_dwMaxFiles = 0;
m_dwCurrentFile = 0;

//Use the segment list if provided, otherwise RecurseDirectory.
if (g_TestParams.dwDMSegments)
{
    for (DWORD i=0; i<g_TestParams.dwDMSegments; i++)
    {
        m_ppszFiles[i]= new CHAR[strlen(g_TestParams.ppDMSegments[i] + 1)];
        strcpy(m_ppszFiles[i], g_TestParams.ppDMSegments[i]);
    }
    m_dwMaxFiles = g_TestParams.dwDMSegments;
}
else
{
    Data.pdwMaxFiles = &m_dwMaxFiles;
    Data.ppszFiles = m_ppszFiles;
    CHECKRUN(RecurseDirectory(g_TestParams.szDMStressDir, LoadFileCallBack, (void *)&Data));
    CHECK   (RandomizeFiles(m_ppszFiles, m_dwMaxFiles));
}

LoadNextSegment();


//Make it notify us of the beats.
m_pPerf->AddNotificationType(GUID_NOTIFICATION_MEASUREANDBEAT);

return hr;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD TransitionSegmentsThreadProc(void *pvMusic)
{
CMusic *pMusic = (CMusic *)pvMusic;
HRESULT hr = S_OK;
HRESULT hrTimeOut = S_OK;
FLOAT fGMResetLength;
DWORD dwTimeOuts = 0;
    
    //Stop the current segment (it may be stopped already but who cares).  Release it.
    if (pMusic->m_pSegmentCurrent)
    {
        CHECKRUN(pMusic->m_pPerf->StopEx(pMusic->m_pSegmentCurrent, 0, 0));
        if (FAILED(hr))
        {
            Log("StopEx() failed on %s; returned %08X", pMusic->m_pSegmentCurrent, hr);
        }
/*
        CHECKRUN(pMusic->m_pSegmentCurrent->Unload(pMusic->m_pPerf));
        if (FAILED(hr))
        {
            Log("Unload() failed on %s; returned %08X", pMusic->m_pSegmentCurrent, hr);
        }
*/
        CHECKRUN(pMusic->m_pLoader->ReleaseObjectByUnknown(pMusic->m_pSegmentCurrent));
        RELEASE(pMusic->m_pSegmentCurrent);
    }

    //Play the GM Reset segment as a secondary segment.  After that, set the transpose back to where it was.
    CHECKRUN(pMusic->m_pPerf->PlaySegmentEx(pMusic->m_pSegmentGMReset, NULL, NULL, 0, 0, NULL, NULL, pMusic->m_pPath));
    if (FAILED(hr))
    {
        Log("GMReset failed to start: PlaySegmentEx returned %08X", hr);
    }
    
    //Wait for it to start, or 1000ms, whichever comes first.
    hrTimeOut = WaitForSegmentStart(pMusic->m_pPerf, pMusic->m_pSegmentGMReset, NULL, 1000);
    if (FAILED(hrTimeOut))
        Log("Timed out waiting 1 second for GM Reset segment to start.\n");

    
    //This segment is 0.25 seconds long at tempo factor 1.  We should divide this number by the tempo factor, and add a fudge factor of (5x + 1s)
    fGMResetLength = (250.f  * 5.f + 1.f) / g_TestParams.fDMMasterTempo;
    
    hrTimeOut = WaitForSegmentStop(pMusic->m_pPerf, pMusic->m_pSegmentGMReset, NULL, DWORD(fGMResetLength));
    if (FAILED(hrTimeOut))
        Log("Timed out waiting %d ms for GM Reset segment to stop.\n", DWORD(fGMResetLength));

    //If the next segment exists, Make it the current one and play it.
    if (pMusic->m_pSegmentNext)
    {
        pMusic->m_pSegmentCurrent = pMusic->m_pSegmentNext;
        strcpy(pMusic->m_szSegmentTitleCurrent, pMusic->m_szSegmentTitleNext);
        CHECKRUN(pMusic->m_pPerf->PlaySegmentEx(pMusic->m_pSegmentCurrent, NULL, NULL, 0, 0, NULL, NULL, pMusic->m_pPath));
        if (SUCCEEDED(hr))
        {
        
            //Wait for this segment to start.
            dwTimeOuts = 0;
            do
            {
                hrTimeOut = WaitForSegmentStart(pMusic->m_pPerf, pMusic->m_pSegmentCurrent, NULL, 1000);
                if (FAILED(hrTimeOut))
                {
                    dwTimeOuts++;
                    Log("We've waited %u second(s) for %s to start\n", dwTimeOuts, pMusic->m_szSegmentTitleCurrent);
                }
            }
            while (FAILED(hrTimeOut) && dwTimeOuts < 10);

            if (FAILED(hrTimeOut))
            {
                Log("Giving up on %s; it failed to start after 10 seconds\n", pMusic->m_szSegmentTitleCurrent);
            }
        }
        else
        {
            Log("%s failed to start: PlaySegmentEx() returned %08X\n", pMusic->m_szSegmentTitleCurrent, hr);
        }
    }

//    //Set the transpose value, which gets reset whenever there's a GM Reset.
//    g_music.SetMasterTranspose(g_TestParams.lDMMasterTranspose);

    pMusic->m_hrThreadProcReturn = hr;
    return 0;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD LoadNextSegmentThreadProc(void *pvMusic)
{
CMusic *pMusic = (CMusic *)pvMusic;

CHAR szFileName[MAX_PATH];
CHAR szFilePath[MAX_PATH];
LPSTR szFullPath = NULL;
HRESULT hr = S_OK;



    //Load up new segment; queue it, get its segstate, and save its name.  Now we have SegmentNext and SegStateNext.    
    do
    {
        hr = S_OK;
        szFullPath = pMusic->m_ppszFiles[pMusic->m_dwCurrentFile];
        ChopPath(szFullPath, szFilePath, szFileName);
        strcpy(pMusic->m_szSegmentTitleNext, szFileName);
        CHECKRUN(pMusic->m_pLoader->SetSearchDirectory(GUID_DirectMusicAllTypes, szFilePath, FALSE));
        CHECKRUN(pMusic->m_pLoader->LoadObjectFromFile(CLSID_DirectMusicSegment, IID_IDirectMusicSegment, szFileName, (void **)&pMusic->m_pSegmentNext));
        if (FAILED(hr))
        {
            Log("LoadObjectFromFile(%s) returned %08X\n", szFileName, hr);
        }
/*
        CHECKRUN(pMusic->m_pSegmentNext->Download(pMusic->m_pPerf));
        if (S_FALSE == hr)
        {
            //TODO: Put back in when 7038 is fixed!!!
            //Log("Downloading %s to the performance returned S_FALSE - why?\n", szFileName);
            hr = S_OK;
        }
*/

        pMusic->m_dwCurrentFile++;
        if (pMusic->m_dwCurrentFile == pMusic->m_dwMaxFiles)
            pMusic->m_dwCurrentFile = 0;
    }
    while (hr != S_OK);
    pMusic->m_hrThreadProcReturn = hr;
    return 0;
}



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::LoadNextSegment(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.bDMLoaderThread)
    {
        m_hThreadLoad = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)LoadNextSegmentThreadProc,(void*)this, 0, NULL);
        if (!m_hThreadLoad)
        {
            Log("CMusic::LoadNextSegment: CreateThread(LoadNextSegmentThreadProc) failed!!\n");
            return E_FAIL;        
        }

    }

    //If we're not using threads, then call the threadproc directly.
    else
    {
        //This will set m_hrThreadProcReturn appropriately.
        LoadNextSegmentThreadProc(this);
        hr = m_hrThreadProcReturn;
    }

    return hr;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::TransitionSegments(void)
{
HRESULT hr = S_OK;

    if (g_TestParams.bDMLoaderThread)
    {
        m_hThreadTransition = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)TransitionSegmentsThreadProc,(void*)this, 0, NULL);
        if (!m_hThreadTransition)
        {
            Log("CMusic::TransitionSegments: CreateThread(TransitionSegmentsThreadProc) failed!!\n");
            return E_FAIL;        
        }

    }

    //If we're not using threads, then call the threadproc directly.
    else
    {
        //This will set m_hrThreadProcReturn appropriately.
        TransitionSegmentsThreadProc(this);
        hr = m_hrThreadProcReturn;
    }

    return hr;
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::Update(void)
{
    HRESULT hr = S_OK;
    
    CHECKRUN(UpdatePlaybackState());
    CHECKRUN(UpdateBeatState());

    return hr;
};


/********************************************************************************
********************************************************************************/
HRESULT CMusic::UpdatePlaybackState(void)
{
HRESULT hr = S_OK;
LONG lRange = 2000;
DWORD dwQuantum = 0;
static DWORD dwLastTime = 0;
DWORD dwThisTime = 0;
DWORD dwWaitResult = 0;
BOOL bMoveToNextState = FALSE;

    if (!g_TestParams.bDMusic)
        return S_OK;

    if (g_TestParams.bDMDoWorkLocally)
    {
        dwThisTime = timeGetTime();
        dwQuantum = dwThisTime - dwLastTime;
        if (dwQuantum > 1000)
            dwQuantum = 10000; 
        dwLastTime = dwThisTime;        
        DirectMusicDoWork(dwQuantum);
    }


    // ------------- Process state variables
    
    
    // ------------- Process the state (m_eState) --------------------------

    //If we're just waiting for the current segment to finish, check if it's finished.
    if (eWaiting == m_eState)
    {
        BOOL bTransition = FALSE;

        //If our current statement has stopped, is non-existent, or we've been instructed to, 
        //  start the new segment playing and start a thread to load up the next one.
        if (!m_pSegmentCurrent)
        {
            bTransition = TRUE;
        }
        else
        {
            if (S_FALSE == m_pPerf->IsPlaying(m_pSegmentCurrent, NULL))
            {
                bTransition = TRUE;
            }
        
        }
        
        //If the user has requested a segment update with the controller, do the same.
        if (m_bNextSegment)
        {
           bTransition = TRUE;
           m_bNextSegment = FALSE;        
        }        

        //If we've waited 5 minutes, then move along to the next segment.  This is so looping waves don't hang the system.
        if (timeGetTime() - m_dwStartTime > 300000)
        {
            bTransition = TRUE;
        }

        //If in one of the above blocks, we've decided to transition, make it so.
        if (bTransition == TRUE)
        {           
           m_eState = eTransitioning;
           TransitionSegments();
        }
       
    }

    //If we're transitioning, check to see if the transition thread has finished and destroy it if it has.
    //  If we are playing, then start the next segment loading.
    else if (eTransitioning == m_eState)
    {
        bMoveToNextState = FALSE;

        if (g_TestParams.bDMLoaderThread)
        {
            dwWaitResult = WaitForSingleObject(m_hThreadTransition, 0);
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                CloseHandle(m_hThreadTransition);
                m_hThreadTransition = NULL;
                bMoveToNextState = TRUE;
            }
        }
        else
        {
            bMoveToNextState = TRUE;
        }


        if (bMoveToNextState)
        {
            m_eState = eLoading;
            LoadNextSegment();
        }

    }
    
    //If we're loading then check to see if the loading thread has finished and destroy it if it has.
    else if (eLoading == m_eState)
    {

        bMoveToNextState = FALSE;

        if (g_TestParams.bDMLoaderThread)
        {
            dwWaitResult = WaitForSingleObject(m_hThreadLoad, 0);
            if (dwWaitResult == WAIT_OBJECT_0)
            {
                CloseHandle(m_hThreadLoad);
                m_hThreadLoad = NULL;
                bMoveToNextState = TRUE;
            }
        }
        else
        {
            bMoveToNextState = TRUE;
        }

        //If we're done loading, move to the next state and note the countdown time.
        if (bMoveToNextState)
        {
            m_eState = eWaiting;
            m_dwStartTime = timeGetTime();
        }
    }

    // default case
    else 
    {    
        Log("Error: Invalid m_eState in %08X\n", this);
    }

    return hr;
}

/********************************************************************************
********************************************************************************/
HRESULT CMusic::UpdateBeatState(void)
{
DMUS_NOTIFICATION_PMSG *pMsg;
HRESULT hr = S_OK;

    if (!g_TestParams.bDMusic)
        return S_OK;

    do
    {
        pMsg = NULL;
        hr = m_pPerf->GetNotificationPMsg(&pMsg);
        if (S_OK == hr)
        {
            m_dwBeat = pMsg->dwField1;
            m_pPerf->FreePMsg((DMUS_PMSG*)pMsg);
        }
    }
    while (S_OK == hr);
    return S_OK;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::GetSegmentTitleCurrent(WCHAR *wszSongTitle)
{
    mbstowcs(wszSongTitle, m_szSegmentTitleCurrent, MAX_PATH);
    return S_OK;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
DWORD CMusic::GetBeat(void)
{
    return m_dwBeat;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::NextSegment(void)
{
m_bNextSegment = TRUE;
return S_OK;

}



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterVolume(LONG lMasterVolume)
{
HRESULT hr = S_OK;
CHECKRUN(m_pPerf->SetGlobalParam(GUID_PerfMasterVolume, (void *)&lMasterVolume, sizeof(lMasterVolume)));
return hr;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterTempo(float fMasterTempo)
{
HRESULT hr = S_OK;
CHECKRUN(m_pPerf->SetGlobalParam(GUID_PerfMasterTempo, (void *)&fMasterTempo, sizeof(fMasterTempo)));
return hr;
}

//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetMasterTranspose(short lMasterTranspose)
{
HRESULT hr = S_OK;
DMUS_TRANSPOSE_PMSG *pTranspose = NULL;

CHECKRUN(m_pPerf->AllocPMsg(sizeof(DMUS_TRANSPOSE_PMSG),(DMUS_PMSG**)&pTranspose ));
if (!pTranspose)
{
    Log("TEST ERROR: Failed to AllocPMsg!!\n");
    hr = E_FAIL;
}

if (SUCCEEDED(hr))
{
    pTranspose->dwSize = sizeof(DMUS_TRANSPOSE_PMSG);
    pTranspose->rtTime = 0;
    pTranspose->dwFlags = DMUS_PMSGF_REFTIME | DMUS_PMSGF_DX8;
    pTranspose->dwType = DMUS_PMSGT_TRANSPOSE;
    pTranspose->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
    pTranspose->nTranspose = g_TestParams.lDMMasterTranspose;
    pTranspose->wMergeIndex = 1; //1 = add this value.
    hr = m_pPerf->SendPMsg( (DMUS_PMSG*)pTranspose );
    if (FAILED(hr))
    {
        m_pPerf->FreePMsg( (DMUS_PMSG*)pTranspose );
        pTranspose = NULL;
    }
}
return hr;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::SetReverb(unsigned short nReverb)
{
HRESULT hr = S_OK;
DMUS_CURVE_PMSG *pCurve= NULL;
m_dwReverb = nReverb;

CHECKRUN(m_pPerf->AllocPMsg(sizeof(DMUS_CURVE_PMSG),(DMUS_PMSG**)&pCurve ));
if (!pCurve)
{
    Log("TEST ERROR: Failed to AllocPMsg!!\n");
    hr = E_FAIL;
}

if (SUCCEEDED(hr))
{
    pCurve->dwSize = sizeof(DMUS_CURVE_PMSG);
    pCurve->rtTime = 0;
    pCurve->dwGroupID = 0xFFFFFFF;     //This was in the sample so I copied it.
    pCurve->dwFlags = DMUS_PMSGF_REFTIME;
    pCurve->dwType = DMUS_PMSGT_CURVE;    
    pCurve->dwPChannel = DMUS_PCHANNEL_BROADCAST_PERFORMANCE;
    
    pCurve->mtDuration = 10;     //duration of the curve.
    pCurve->mtOriginalStart = 0; //right away.
    pCurve->mtResetDuration = 0; //Ignored if DMUS_CURVE_RESET isn't in flags.

    pCurve->nStartValue = (unsigned short)m_dwReverb;  //who cares, it's instant.
    pCurve->nEndValue   = (unsigned short)m_dwReverb;  //what we're setting.
    pCurve->nResetValue = (unsigned short)m_dwReverb;  //Reset to default when invalidated.  //BUGBUG: Right now we don't know the default so we'll use zero.

    pCurve->wMeasure = 0;           // Measure in which this curve occurs 
    pCurve->nOffset  = 0;           // Offset from grid at which this curve occurs 
    pCurve->bBeat    = 0;           // Beat (in measure) at which this curve occurs 
    pCurve->bGrid    = 0;           // Grid offset from beat at which this curve occurs 
    pCurve->bType       = DMUS_CURVET_CCCURVE; // type of curve: CC curve
    pCurve->bCurveShape = DMUS_CURVES_INSTANT; // shape of curve 
    pCurve->bCCData  = 91;          // CC# if this is a control change type 
    pCurve->bFlags   = 0;           // Don't reset the curve.
    pCurve->wParamType = 0;         // RPN or NRPN parameter number.  I think this is zero.
    pCurve->wMergeIndex = 0;        // Allows multiple parameters to be merged (pitchbend, volume, and expression.)

    hr = m_pPerf->SendPMsg( (DMUS_PMSG*)pCurve );
    if (FAILED(hr))
    {
        m_pPerf->FreePMsg( (DMUS_PMSG*)pCurve );
        pCurve = NULL;
    }
}
return hr;
}


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
HRESULT CMusic::GetReverb(DWORD *dwReverb)
{
*dwReverb = m_dwReverb;
return S_OK;
};


//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocation          (DWORD *pdwHeapAllocationNormal, DWORD *pdwHeapAllocationPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationNormal = 0;
        *pdwHeapAllocationPhysical = 0;
        return;
    }
    if (pdwHeapAllocationNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocation(&dw);
            *pdwHeapAllocationNormal = dw;
        }
    }
    if (pdwHeapAllocationPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocation(&dw);
            *pdwHeapAllocationPhysical = dw;
        }
    }
};



//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeakNormal, DWORD *pdwHeapAllocationPeakPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationPeakNormal = 0;
        *pdwHeapAllocationPeakPhysical = 0;
        return;
    }
    if (pdwHeapAllocationPeakNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationPeak(&dw);
            *pdwHeapAllocationPeakNormal = dw;
        }
    }
    if (pdwHeapAllocationPeakPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationPeak(&dw);
            *pdwHeapAllocationPeakPhysical = dw;
        }
    }
};




//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocksNormal, DWORD *pdwHeapAllocationBlocksPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationBlocksNormal = 0;
        *pdwHeapAllocationBlocksPhysical = 0;
        return;
    }
    if (pdwHeapAllocationBlocksNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationBlocks(&dw);
            *pdwHeapAllocationBlocksNormal = dw;
        }
    }
    if (pdwHeapAllocationBlocksPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationBlocks(&dw);
            *pdwHeapAllocationBlocksPhysical = dw;
        }
    }
};




//------------------------------------------------------------------------------
//
//------------------------------------------------------------------------------
void CMusic::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeakNormal, DWORD *pdwHeapAllocationBlocksPeakPhysical)
{
    DWORD dw = 0;
    if (!g_TestParams.bDMusic)
    {
        *pdwHeapAllocationBlocksPeakNormal = 0;
        *pdwHeapAllocationBlocksPeakPhysical = 0;
        return;
    }
    if (pdwHeapAllocationBlocksPeakNormal)
    {
        if (m_pHeapNormal)
        {
            m_pHeapNormal->GetHeapAllocationBlocksPeak(&dw);
            *pdwHeapAllocationBlocksPeakNormal = dw;
        }
    }
    if (pdwHeapAllocationBlocksPeakPhysical)
    {
        if (m_pHeapPhysical)
        {
            m_pHeapPhysical->GetHeapAllocationBlocksPeak(&dw);
            *pdwHeapAllocationBlocksPeakPhysical = dw;
        }
    }
};



}//end "namespace WFVO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\InvertedBall.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	InvertedBall.cpp

Abstract:

	A 3d ball

Author:

	Robert Heitkamp (robheit) 5-Feb-2001

Revision History:

	5-Feb-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include "InvertedBall.h"
#include "helpers.h"

using namespace WFVO;

namespace WFVO {

//------------------------------------------------------------------------------
//	Defines:
//------------------------------------------------------------------------------
#define XYZ_NORMAL_TEX (D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1)
#ifndef PI 
#	define PI 3.14159265359f
#endif

//------------------------------------------------------------------------------
//	Static member initialization
//------------------------------------------------------------------------------

UINT CInvertedBall::m_uRef = 0;
IDirect3DTexture8* CInvertedBall::m_pd3dtBase = NULL;

//------------------------------------------------------------------------------
//	Globals
//------------------------------------------------------------------------------
D3DMATERIAL8 g_material = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.25f, 0.25f, 0.25f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

D3DMATERIAL8 g_material2 = {
	{0.5f, 0.5f, 0.5f, 1.0f},
	{0.0f, 0.0f, 0.0f, 1.0f},
	{1.0f, 1.0f, 1.0f, 1.0f},
	{0.0f, 0.0f, 0.0f, 0.0f},
	0.0f
};

//------------------------------------------------------------------------------
//	CInvertedBall::CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::CInvertedBall(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
	m_dontDraw	= TRUE;
	m_pVB		= NULL;
	m_pIB		= NULL;
    m_uRef++;
}

//------------------------------------------------------------------------------
//	CInvertedBall::~CInvertedBall
//------------------------------------------------------------------------------
CInvertedBall::~CInvertedBall(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	Release();

    if (--m_uRef == 0) {
        if (m_pd3dtBase) {
            m_pd3dtBase->Release();
            m_pd3dtBase = NULL;
        }
    }
}

//------------------------------------------------------------------------------
//	CInvertedBall::Create
//------------------------------------------------------------------------------
HRESULT
CInvertedBall::Create(
					  IN IDirect3DDevice8*	pDevice,
					  IN float				radius,
					  IN int				numLong,
					  IN int				numLat
					  )
/*++

Routine Description:

	Creats a sphere whose center is at the origin with a given radius

Arguments:

	IN pDevice -	D3D Device
	IN radius -		Radius of sphere
	IN numLong -	Number of longitutinal lines
	IN numLat -		Num latitutinal lines

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT		hr;
	float		phi;
	float		rho;
	float		phiInc;
	float		rhoInc;
	int			p;
	int			r;
	int			index;
	VOID*		pVoid		= NULL;
	Vertex*		vertices	= NULL;
	Vertex*		newVerts	= NULL;
	WORD*		indices		= NULL;
	int			latitude1	= numLat - 1;
	int			latitude2	= numLat - 2;
	int			longitude1	= numLong - 1;
	int			p1l;
	int			pl;
	int			last;

	// Release previous buffers
	Release();

	// Setup
	m_radius = radius;

	// Num verts and tris
	m_numVertices	= latitude1 * numLong + 2;
	m_numTriangles	= (latitude1 * 2) * numLong;
	
	// Allocate vertices
	vertices = new Vertex [m_numVertices];
	ASSERT(vertices != NULL);

	// Increments
	phiInc	= (2.0f * PI) / (float)numLong;
	rhoInc	= PI / (float)numLat;

	// Calculate vertices
	vertices[0].normal		= XGVECTOR3(0.0f, -1.0f, 0.0f);
	vertices[0].position	= XGVECTOR3(0.0f, m_radius, 0.0f);
    vertices[0].tu          = 0.0f;
    vertices[0].tv          = 0.0f;
	for(index=1, phi=0.0f, p=0; p<numLong; ++p, phi += phiInc) 
	{
		for(rho=PI/2.0f - rhoInc, r=0; r<latitude1; ++r, rho-=rhoInc, ++index) 
		{
			vertices[index].normal		= XGVECTOR3((float)(cos(phi) * fabs(cos(rho))), 
													  (float)sin(rho), 
													  -(float)(sin(phi) * fabs(cos(rho))));
			vertices[index].position	= XGVECTOR3(vertices[index].normal.x * m_radius, 
													  vertices[index].normal.y * m_radius, 
													  vertices[index].normal.z * m_radius);
			vertices[index].normal		= -vertices[index].normal;
            vertices[index].tu          = (float)p / (float)(numLong - 1) * 4.0f;
            vertices[index].tv          = (float)r / (float)(latitude1 - 1) * 3.0f;
		}
	}
	vertices[index].normal		= XGVECTOR3(0.0f, 1.0f, 0.0f);
	vertices[index].position	= XGVECTOR3(0.0f, -m_radius, 0.0f);
    vertices[index].tu          = 0.0f;
    vertices[index].tv          = 3.0f;
	last = index;

	// Build the indices & real vertices
	m_numVertices	= m_numTriangles * 3;

	indices = new WORD [m_numVertices];
	ASSERT(indices != NULL);

	newVerts = new Vertex [m_numVertices];
	ASSERT(newVerts != NULL);

	for(index = 0, p=0; p<numLong; ++p) 
	{
		// Shortcuts
		pl = p * latitude1 + 1;
		if(p != longitude1)
			p1l = (p+1) * latitude1 + 1;
		else
			p1l = 1;

		// Top triangle
		newVerts[index].tu			= vertices[0].tu;//0.5f;
		newVerts[index].tv			= vertices[0].tv;//0.0f;
		newVerts[index].normal		= vertices[0].normal;
		newVerts[index++].position	= vertices[0].position;
		newVerts[index].tu			= vertices[p1l].tu;//0.0f;
		newVerts[index].tv			= vertices[p1l].tv;//1.0f;
		newVerts[index].normal		= vertices[p1l].normal;
		newVerts[index++].position	= vertices[p1l].position;
		newVerts[index].tu			= vertices[pl].tu;//1.0f;
		newVerts[index].tv			= vertices[pl].tv;//1.0f;
		newVerts[index].normal		= vertices[pl].normal;
		newVerts[index++].position	= vertices[pl].position;

		// Middle triangles
		for(r=0; r<latitude2; ++r) 
		{
			newVerts[index].tu			= vertices[pl + r].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r].tv;//0.0f;
			newVerts[index].normal		= vertices[pl + r].normal;
			newVerts[index++].position	= vertices[pl + r].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;

			newVerts[index].tu			= vertices[pl + r + 1].tu;//0.0f;
			newVerts[index].tv			= vertices[pl + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[pl + r + 1].normal;
			newVerts[index++].position	= vertices[pl + r + 1].position;
			newVerts[index].tu			= vertices[p1l + r].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
			newVerts[index].normal		= vertices[p1l + r].normal;
			newVerts[index++].position	= vertices[p1l + r].position;
			newVerts[index].tu			= vertices[p1l + r + 1].tu;//1.0f;
			newVerts[index].tv			= vertices[p1l + r + 1].tv;//1.0f;
			newVerts[index].normal		= vertices[p1l + r + 1].normal;
			newVerts[index++].position	= vertices[p1l + r + 1].position;
		}

		// Bottom triangle
		newVerts[index].tu			= vertices[last].tu;//0.0f;
		newVerts[index].tv			= vertices[last].tv;//1.0f;
		newVerts[index].normal		= vertices[last].normal;
		newVerts[index++].position	= vertices[last].position;
		newVerts[index].tu			= vertices[pl + r].tu;//1.0f;
		newVerts[index].tv			= vertices[pl + r].tv;//1.0f;
		newVerts[index].normal		= vertices[pl + r].normal;
		newVerts[index++].position	= vertices[pl + r].position;
		newVerts[index].tu			= vertices[p1l + r].tu;//0.5f;
		newVerts[index].tv			= vertices[p1l + r].tv;//0.0f;
		newVerts[index].normal		= vertices[p1l + r].normal;
		newVerts[index++].position	= vertices[p1l + r].position;
	}
	delete [] vertices;
	for(p=0; p<m_numVertices; ++p)
		indices[p] = (WORD)p;

	// Setup the vertex buffer for the Ball
	hr = pDevice->CreateVertexBuffer(m_numVertices * sizeof(Vertex), 0, 
									 XYZ_NORMAL_TEX, D3DPOOL_DEFAULT, 
									 &m_pVB);
	if(FAILED(hr)) 
	{
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	hr = m_pVB->Lock(0, m_numVertices * sizeof(Vertex), (BYTE**)&pVoid, 0);
	if(FAILED(hr))
	{
		Release();
		delete [] newVerts;
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, newVerts, m_numVertices * sizeof(Vertex));
	m_pVB->Unlock();
	delete [] newVerts;

	// Setup the index buffer for the Ball
	hr = pDevice->CreateIndexBuffer(m_numVertices * sizeof(WORD),
									D3DUSAGE_WRITEONLY, D3DFMT_INDEX16,
									D3DPOOL_DEFAULT, &m_pIB);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	hr = m_pIB->Lock(0, m_numVertices * sizeof(WORD), (BYTE**)&pVoid, 0);
	if(FAILED(hr)) 
	{
		Release();
		delete [] indices;
		return hr;
	}

	CopyMemory(pVoid, indices, m_numVertices * sizeof(WORD));
	m_pIB->Unlock();
	delete [] indices;

	// Create the texture
    if (!m_pd3dtBase) {
#if 1
        hr = D3DXCreateTextureFromFileEx(pDevice, g_TestParams.szSphereBaseTex, D3DX_DEFAULT, D3DX_DEFAULT, 
                                    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, 0, D3DX_FILTER_TRIANGLE,
                                    D3DX_FILTER_TRIANGLE, 0, NULL, NULL, &m_pd3dtBase);
#else
        HANDLE hFile;
        DWORD dwSize, dwRead;
        LPBYTE pData;

        hFile = CreateFile(g_TestParams.szSphereBaseTex, GENERIC_READ, 
                                    FILE_SHARE_READ, NULL, OPEN_EXISTING, 
                                    FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile == INVALID_HANDLE_VALUE) {
            return E_FAIL;
        }

        // Get the size of the file
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0xFFFFFFFF) {
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Allocate a buffer for the file data
        pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (!pData) {
            CloseHandle(hFile);
            return E_OUTOFMEMORY;
        }                

        // Read the file into the buffer
        if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
            || dwSize != dwRead)
        {
            HeapFree(GetProcessHeap(), 0, pData);
            CloseHandle(hFile);
            return E_FAIL;
        }

        // Close the file
        CloseHandle(hFile);

        hr = D3DXCreateTextureFromFileInMemory(pDevice, pData, dwSize, &m_pd3dtBase);

        HeapFree(GetProcessHeap(), 0, pData);
#endif

        if (FAILED(hr)) {
            return hr;
        }
    }

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

	m_dontDraw = FALSE;
	return S_OK;
}

//------------------------------------------------------------------------------
//	CInvertedBall::SetPosition
//------------------------------------------------------------------------------
void 
CInvertedBall::SetPosition(
						   IN const XGVECTOR3& position
						   )
/*++

Routine Description:

	Sets the position of the ball

Arguments:

	IN position -	position

Return Value:

	None

--*/
{
	m_location = position;
	XGMatrixTranslation(&m_worldMatrix, m_location[0], m_location[1], 
						  m_location[2]);
	m_min	= XGVECTOR3(m_radius, m_radius, m_radius) + m_location;
	m_max	= XGVECTOR3(-m_radius, -m_radius, -m_radius) - m_location;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetRadius
//------------------------------------------------------------------------------
float 
CInvertedBall::GetRadius(void) const
/*++

Routine Description:

	Returns the radius of the ball

Arguments:

	None

Return Value:

	The radius

--*/
{
	return m_radius;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMin
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMin(void) const
/*++

Routine Description:

	Returns the min coordinate of the Ball

Arguments:

	None

Return Value:

	The min coordinate of the Ball

--*/
{
	return m_min;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetMax
//------------------------------------------------------------------------------
const XGVECTOR3& 
CInvertedBall::GetMax(void) const
/*++

Routine Description:

	Returns the max coordinate of the Ball

Arguments:

	None

Return Value:

	The max coordinate of the Ball

--*/
{
	return m_max;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Render
//------------------------------------------------------------------------------
void
CInvertedBall::Render(
					  IN IDirect3DDevice8*	pDevice,
                      IN UINT               uPass,
					  IN BOOL				bDrawWireframe
					  )
/*++

Routine Description:

	Renders the Ball

Arguments:

	IN pDevice -		IDirect3DDevice8
	IN uPass -			Render Pass
	IN bDrawWireframe -	TRUE to render a wireframe shell

Return Value:

	None

--*/
{
	if(m_dontDraw)
		return;

	// Vertex shader type
	pDevice->SetVertexShader(XYZ_NORMAL_TEX);

	// Set the translation
	pDevice->SetTransform(D3DTS_WORLD, &m_worldMatrix);

	// Enable texture
    pDevice->SetTexture(0, m_pd3dtBase);

	// Set the material
    if (uPass) {
    	pDevice->SetMaterial(&g_material2);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    }
    else {
    	pDevice->SetMaterial(&g_material);
        pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    }

    pDevice->SetRenderState(D3DRS_WRAP0, D3DWRAP_U);

	// Set the vertex buffer stream source
	pDevice->SetStreamSource(0, m_pVB, sizeof(Vertex));

	// Make sure it draws solid
	pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);

	// Draw the object
	pDevice->SetIndices(m_pIB, 0);
	pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
								  m_numTriangles);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_WRAP0, 0);

	// Disable texture
    pDevice->SetTexture(0, NULL);

	if(bDrawWireframe)
	{
		// Draw backfacing wireframe
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME);
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

		// Draw the object
		pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_numVertices, 0, 
									  m_numTriangles);

		// Restore the modes
		pDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
		pDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
	}
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumVerts
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumVerts(void) const
/*++

Routine Description:

	Returns the number of vertices in the Ball

Arguments:

	None

Return Value:

	The number of vertices

--*/
{
	return m_numVertices;
}

//------------------------------------------------------------------------------
//	CInvertedBall::GetNumTris
//------------------------------------------------------------------------------
int 
CInvertedBall::GetNumTris(void) const
/*++

Routine Description:

	Returns the number of triangles in the Ball

Arguments:

	None

Return Value:

	number of triangles

--*/
{
	return m_numTriangles;
}

//------------------------------------------------------------------------------
//	CInvertedBall::Release
//------------------------------------------------------------------------------
void
CInvertedBall::Release(void)
/*++

Routine Description:

	Releases the Ball

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_pVB) {
		m_pVB->Release();
		m_pVB = NULL;
	}
	if(m_pIB) {
		m_pIB->Release();
		m_pIB = NULL;
	}
}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\media.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	media.cpp

Abstract:

	Media stress - D3D, DSound, DMusic and others.

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <time.h>
#include "media.h"
#include "helpers.h"
#include "scene.h"
#include "music.h"
#include "input.h"
#include <d3d8perf.h>
#include "medialoader.h"
#include "dsstress.h"


#ifndef NOLOGGING
#include <makeini.h>
#include <stressmon.h>
#endif // NOLOGGING

using namespace WFVO;

extern HANDLE  g_hLog;

namespace WFVO {

#define MEDIA_FILES_INI_PATH	"D:\\MediaFiles.ini"

//------------------------------------------------------------------------------
//	Static Function Declarations:
//------------------------------------------------------------------------------
static HRESULT Initialize(void);
static HRESULT InitializeD3D(void);
static void Cleanup(void);
static HRESULT InitializeScene(void);

//------------------------------------------------------------------------------
//	Static Global Variables
//------------------------------------------------------------------------------
CMusic              g_music;
IDirect3D8*		    g_d3d			= NULL;
IDirect3DDevice8*	g_d3dDevice		= NULL;
IDirectSound *      g_dsound        = NULL;
BOOL                g_notDone		= TRUE;
CScene				g_scene;

//------------------------------------------------------------------------------
//	media_BasicTest
//------------------------------------------------------------------------------
HRESULT
media_BasicTest(void)
/*++

Routine Description:

    Basic Test for media

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT hr	= S_OK;

	// General initialization
	hr = Initialize();
	if(hr != S_OK)
	{
		__asm int 3;
		return hr;
	}

	// Enable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StartPerfProfile();
#endif 

	// Loop until done
	while(g_notDone)
	{
		// Draw the scene
		g_scene.Render(g_d3dDevice);

		// Next frame
		g_scene.NextFrame();

        // Update Music
		g_music.Update();

        // input
        CheckUserInput();
	}

	// Disable profiling?
#ifdef _DEBUG
	if(g_TestParams.bD3DPerf)
		D3DPERF_StopPerfProfile();
#endif

    // Return the Hresult
    return hr;
}

//
// this function should only be linked in / defined if this is compiled as a lib
//

#ifndef NOLOGGING
DWORD WINAPI StartStressMon( LPVOID lpParameter )
{
	StressMONStartTest( (HANDLE) lpParameter );
	return 0;
}
#endif // NOLOGGING

//------------------------------------------------------------------------------
//	
//------------------------------------------------------------------------------
VOID
WINAPI 
media_StartTest(
				IN HANDLE LogHandle 
				)
/*++

Routine Description:

    The harness entry into the media tests

Arguments:

    IN LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	//
	// decide if this is a lib or an exe, and generate an ini file if it is a lib
	//

#ifndef NOLOGGING

	EXECUTE( makeini_WFVOTest() );
	if ( SUCCEEDED( hr ) )
	{
		CreateThread( NULL, 65536, StartStressMon, (LPVOID) LogHandle, 0, NULL );
	}

#endif // NOLOGGING

    EXECUTE( media_BasicTest() );
}

//------------------------------------------------------------------------------
//	media_EndTest
//------------------------------------------------------------------------------
VOID 
WINAPI 
media_EndTest(VOID)
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
	Cleanup();
}

//------------------------------------------------------------------------------
//	InitializeD3D
//------------------------------------------------------------------------------
static HRESULT
InitializeD3D(void)
/*++

Routine Description:

	Initializes the d3d device

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT					hr;
	D3DPRESENT_PARAMETERS	d3dpp;
	
	// Create an instance of a Direct3D8 object 
	g_d3d = Direct3DCreate8(D3D_SDK_VERSION);
	if(g_d3d == NULL)
		return E_FAIL;
	
	// Setup the present parameters
	ZeroMemory(&d3dpp, sizeof(D3DPRESENT_PARAMETERS));
	d3dpp.BackBufferWidth					= 640;
	d3dpp.BackBufferHeight					= 480;
	d3dpp.BackBufferFormat					= D3DFMT_A8R8G8B8;
	d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
	d3dpp.Flags								= 0;
//	d3dpp.MultiSampleType					= D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN;
	d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
	d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	d3dpp.hDeviceWindow						= NULL;
	d3dpp.Windowed							= FALSE;
	d3dpp.EnableAutoDepthStencil			= TRUE;
	d3dpp.AutoDepthStencilFormat			= D3DFMT_D24S8;
	d3dpp.Flags								= 0;
	d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
	d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_IMMEDIATE;

	// Create the device
	hr = g_d3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, NULL, 
						     D3DCREATE_HARDWARE_VERTEXPROCESSING, &d3dpp, 
						     &g_d3dDevice);
	if(hr != D3D_OK)
		return hr;
	
	// Enable antialiasing
//	g_d3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, TRUE); 

	return S_OK;
}


//------------------------------------------------------------------------------
//	InitializeDSound
//------------------------------------------------------------------------------
static HRESULT
InitializeDSound(void)
/*++
Routine Description:
	Downloads the scratch image to the DSP
Return Value:
	S_OK on success, any other value on failure
*/
{
    static const struct
    {
        LPCSTR                      pszName;
        DSI3DL2LISTENER             Properties;
    } Environments[] =
    {
        { "Default",         { DSI3DL2_ENVIRONMENT_PRESET_DEFAULT } },
        { "Generic",         { DSI3DL2_ENVIRONMENT_PRESET_GENERIC } },
        { "PaddedCell",      { DSI3DL2_ENVIRONMENT_PRESET_PADDEDCELL } },
        { "Room",            { DSI3DL2_ENVIRONMENT_PRESET_ROOM } },
        { "Bathroom",        { DSI3DL2_ENVIRONMENT_PRESET_BATHROOM } },
        { "LivingRoom",      { DSI3DL2_ENVIRONMENT_PRESET_LIVINGROOM } },
        { "StoneRoom",       { DSI3DL2_ENVIRONMENT_PRESET_STONEROOM } },
        { "Auditorium",      { DSI3DL2_ENVIRONMENT_PRESET_AUDITORIUM } },
        { "ConcertHall",     { DSI3DL2_ENVIRONMENT_PRESET_CONCERTHALL } },
        { "Cave",            { DSI3DL2_ENVIRONMENT_PRESET_CAVE } },
        { "Arena",           { DSI3DL2_ENVIRONMENT_PRESET_ARENA } },
        { "Hangar",          { DSI3DL2_ENVIRONMENT_PRESET_HANGAR } },
        { "CarpetedHallway", { DSI3DL2_ENVIRONMENT_PRESET_CARPETEDHALLWAY } },
        { "Hallway",         { DSI3DL2_ENVIRONMENT_PRESET_HALLWAY } },
        { "StoneCorridor",   { DSI3DL2_ENVIRONMENT_PRESET_STONECORRIDOR } },
        { "Alley",           { DSI3DL2_ENVIRONMENT_PRESET_ALLEY } },
        { "Forest",          { DSI3DL2_ENVIRONMENT_PRESET_FOREST } },
        { "City",            { DSI3DL2_ENVIRONMENT_PRESET_CITY } },
        { "Mountains",       { DSI3DL2_ENVIRONMENT_PRESET_MOUNTAINS } },
        { "Quarry",          { DSI3DL2_ENVIRONMENT_PRESET_QUARRY } },
        { "Plain",           { DSI3DL2_ENVIRONMENT_PRESET_PLAIN } },
        { "ParkingLot",      { DSI3DL2_ENVIRONMENT_PRESET_PARKINGLOT } },
        { "SewerPipe",       { DSI3DL2_ENVIRONMENT_PRESET_SEWERPIPE } },
        { "UnderWater",      { DSI3DL2_ENVIRONMENT_PRESET_UNDERWATER } },
        { "NoReverb",        { DSI3DL2_ENVIRONMENT_PRESET_NOREVERB } },
    };

    HRESULT hr = S_OK;
    UINT i;

    CHECKRUN(DirectSoundCreate( NULL, &g_dsound, NULL ));
    if (_strcmpi("none", g_TestParams.szDSScratchImage))
        CHECKRUN(DownloadScratch(g_dsound, g_TestParams.szDSScratchImage));

    if (_strcmpi("full", g_TestParams.szDSHRTF) == 0)
    {
        CHECK(DirectSoundUseFullHRTF());
    }
    else if (_strcmpi("light", g_TestParams.szDSHRTF) == 0)
    {
        CHECK(DirectSoundUseLightHRTF());
    }
    else
        ASSERT(FALSE);

    for (i = 0; i < sizeof(Environments) / sizeof(Environments[0]); i++)
    {
        if (_strcmpi(Environments[i].pszName, g_TestParams.szDSEnvironment) == 0)
        {
            CHECK(g_dsound->SetI3DL2Listener(&Environments[i].Properties, DS3D_IMMEDIATE));
            break;
        }
    }

    ASSERT(i < sizeof(Environments) / sizeof(Environments[0]));

    return hr;
}


//------------------------------------------------------------------------------
//	InitializeMedia
//------------------------------------------------------------------------------
HRESULT InitializeMedia(void)
{
    HRESULT hr = S_OK;

    //If we're instructed not to copy from the network (if we're running from a DVD, for example)
    //  then we'll skip this part.
    if (!g_TestParams.bCopyMediaFromNetwork)
        return S_OK;

	// figure out the remote path for each file
#define MAX_MEDIA_FILES 34
	UINT	nNumFiles = 0;
	MEDIAFILEDESC MediaFiles[MAX_MEDIA_FILES];
	for ( UINT i=0; i < MAX_MEDIA_FILES-1; i++ )
	{
		MediaFiles[i].lpszFromPath = new CHAR [ MAX_PATH ];
		MediaFiles[i].lpszToPath = new CHAR [ MAX_PATH ];
		MediaFiles[i].dwFlags = COPY_IF_NEWER;
		if ( NULL == MediaFiles[i].lpszFromPath || NULL == MediaFiles[i].lpszToPath )
		{
			return E_OUTOFMEMORY;
		}
	}
	MediaFiles[i].lpszFromPath = MediaFiles[i].lpszToPath = NULL;

	hr = TranslatePath( g_TestParams.szBallBaseTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szBallBumpTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath ); 
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szSphereBaseTex, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szLightVSH, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szSparkVSH, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) && g_TestParams.szLightSound[0] ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szLightSound, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		hr = TranslatePath( g_TestParams.szBounceSound, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
	}
	
	if ( SUCCEEDED( hr ) ) {
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "DSP/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\DSPCode\\" );
	}
	
	if ( g_TestParams.bDMusic && SUCCEEDED( hr ) )
	{
		if ( SUCCEEDED( hr ) ) {
			nNumFiles++;
			hr = TranslatePath( g_TestParams.szDMStressDir, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
		}
		if ( SUCCEEDED( hr ) ) {
			nNumFiles++;
			hr = TranslatePath( g_TestParams.szDMSupportDir, MediaFiles[nNumFiles].lpszFromPath, MediaFiles[nNumFiles].lpszToPath );
		}
		/*nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/ADPCM/DLS/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ADPCM\\DLS\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/ADPCM/WaveSeg/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ADPCM\\WaveSeg\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Default/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Default\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MAnyNotes/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\ManyNotes\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MIDI/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\MIDI\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/MIDI/1/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\MIDI\\1\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Beat/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Beat\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Bug6712/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Bug6712\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/MusicReverb/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\MusicReverb\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Other/Sine/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Other\\Sine\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Scott/BBall/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Scott\\BBall\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/support/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\support\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/Variety/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\Variety\\" );
		nNumFiles++;*/
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Looping64/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Looping64\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Looping64/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Looping64\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/OneShot/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\OneShot\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/OneShot/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\OneShot\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Streaming/Original/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Streaming\\Original\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/ADPCM/Streaming/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\ADPCM\\Streaming\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/Looping/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\Looping\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/OneShot/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\OneShot\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Normal/Streaming/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Normal\\Streaming\\" );
		nNumFiles++;
		strcpy( MediaFiles[nNumFiles].lpszFromPath, "mediastress/music/wav/Other/" ); strcpy( MediaFiles[nNumFiles].lpszToPath, "T:\\media\\music\\wav\\Other\\" );
		nNumFiles++;
	}

	//fill in NULLs for unused slots
	for ( i=nNumFiles; i < MAX_MEDIA_FILES; i++ )
	{
		if ( NULL != MediaFiles[i].lpszFromPath )
		{
			delete [] MediaFiles[i].lpszFromPath;
			MediaFiles[i].lpszFromPath = NULL;
		}
		if ( NULL != MediaFiles[i].lpszToPath )
		{
			delete [] MediaFiles[i].lpszToPath;
			MediaFiles[i].lpszToPath = NULL;
		}
	}
	
    SETLOG( g_hLog, "robheit", "MCPX", "media", "Basic" );

	MLSetErrorLevel( 3 );
	EXECUTE( LoadMedia( MediaFiles ) );
	for ( i=0; i < 32; i++ )
	{
		if ( NULL != MediaFiles[i].lpszFromPath )
		{
			delete [] MediaFiles[i].lpszFromPath;
			MediaFiles[i].lpszFromPath = NULL;
		}
		if ( NULL != MediaFiles[i].lpszToPath )
		{
			delete [] MediaFiles[i].lpszToPath;
			MediaFiles[i].lpszToPath = NULL;
		}
	}
	if ( FAILED( hr ) )
	{
        hr = E_FAIL;
	}

    return hr;

}


//------------------------------------------------------------------------------
//	Initialize
//------------------------------------------------------------------------------
static HRESULT
Initialize(void)
/*++

Routine Description:

	General Intialization

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT			hr;
	LONGLONG		timer;
	unsigned int	seed;

	// Set the seed to randomize the runs
	// A variable is used so that the seed can be overrided at run time
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	seed = (unsigned int)timer;
	srand(seed);

    // Load user-defined parameters.    
    hr = LoadTestParams();
    if (FAILED(hr))
        return hr;

    // Check the parameters are in order..    
    hr = SanityCheckTestParams();
    if (FAILED(hr))
        return hr;

    // Copy down the media, if required.
    hr = InitializeMedia();
    //if (FAILED(hr))
    //    return hr;

    // Check that the files are present and accessible.
    hr = SanityCheckFiles();
    if (FAILED(hr))
        return hr;

	// Initialize D3D
	hr = InitializeD3D();
	if(hr != S_OK)
		return hr;

	// Initialize DSound
	hr = InitializeDSound();
	if(hr != S_OK)
		return hr;

    hr = StartDSStress(g_TestParams.dwDSSThreads,                                               //Threads
                       g_TestParams.dwDSSTotalBuffers2D,    g_TestParams.dwDSSTotalBuffers3D,   //Total 2D/3D Buffers                       
                       g_TestParams.dwDSSTotalStreams2D,    g_TestParams.dwDSSTotalStreams3D,   //Total 2D/3D Streams
                       g_TestParams.dwDSSMixinBuffers2D,    g_TestParams.dwDSSMixinBuffers3D,   //Of the2D/3D Buffers, how many will be mixin buffers (these are given highest prio and are always allocated)
                       g_TestParams.dwDSSSends2D,           g_TestParams.dwDSSSends3D,          //How many of the regular 2D buffers will send to a 2D/3D buffer.
                       g_TestParams.dwDSSWait);

	if(hr != S_OK)
		return hr;
    
    // Initialize DMusic
    hr = g_music.Initialize();
	if(hr != S_OK)
		return hr;

	// Create the graphic data
	hr = InitializeScene();
	if(hr != S_OK)
		return hr;

	return S_OK;
}

//------------------------------------------------------------------------------
//	Cleanup
//------------------------------------------------------------------------------
static void
Cleanup(void)
/*++

Routine Description:

	Free resources

Arguments:

	None

Return Value:

	None

--*/
{
	
    if (g_dsound)
    {
        g_dsound->Release();
        g_dsound = NULL;
    }
    
    // IDirect3DDevice8
	if(g_d3dDevice)
	{
		g_d3dDevice->Release();
		g_d3dDevice = NULL;
	}

	// IDirect3D8
	if(g_d3d)
	{
		g_d3d->Release();
		g_d3d = NULL;
	}

    StopDSStress();

    FreeTestParams();
}

//------------------------------------------------------------------------------
//	InitializeScene
//------------------------------------------------------------------------------
static HRESULT
InitializeScene(void)
/*++

Routine Description:

	Initializes all data for the scene

Arguments:

	None

Return Value:

	S_OK on success, any other value on failure

--*/
{
	HRESULT	hr;
	
	hr = g_scene.Initialize(g_d3dDevice);
	return hr;
}


}; //end namespace WFVO


//------------------------------------------------------------------------------
//	Export Function Pointers for StartTest and EndTest
//------------------------------------------------------------------------------
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WFVO )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WFVO )
    EXPORT_TABLE_ENTRY( "StartTest", WFVO::media_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WFVO::media_EndTest )
END_EXPORT_TABLE( WFVO )


//------------------------------------------------------------------------------
//	main
//------------------------------------------------------------------------------
#ifdef NOLOGGING
void 
__cdecl 
main(void)
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize USB Devices
    XInitDevices(0, NULL);
    InputDukeInsertions(XGetDevices(XDEVICE_TYPE_GAMEPAD));
    WFVO::media_StartTest(NULL);
    WFVO::media_EndTest();
}
#endif // NOLOGGING
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\MusicHeapFixed.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapFixed.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 18-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "helpers.h"
#include "assert.h"

using namespace WFVO;


namespace WFVO
{


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
class CMusicHeapFixed : public IMusicHeap
{

   //LOCALALLOC_NEWDELETE What the heck is this?
public:

    CMusicHeapFixed(void);
    ~CMusicHeapFixed(void);
    HRESULT Initialize(DWORD dwSize, bool bIsPhysicalHeap);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);
    STDMETHOD(Free)(void *pv);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);

private:
    void* Alloc(size_t cb);

    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    DWORD m_dwHeapSize;
    bool m_bPhysicalHeap;
    LONG m_cRef;
    IDirectMusicHeap *m_pHeap;
};


CMusicHeapFixed::CMusicHeapFixed(void)
{
    InitializeCriticalSection(&m_csHeap);
    m_cRef = 1;
    m_bPhysicalHeap = false;
    m_dwHeapAllocation = 0;
    m_dwHeapAllocationPeak = 0;
    m_dwHeapAllocationBlocks = 0;
    m_dwHeapAllocationBlocksPeak = 0;
    m_dwHeapSize = 0;
    m_pHeap = NULL;
}

CMusicHeapFixed::~CMusicHeapFixed(void)
{
    DeleteCriticalSection(&m_csHeap);
}

HRESULT CMusicHeapFixed::Initialize(DWORD dwHeapSize, bool bIsPhysicalHeap)
{
    HRESULT hr = S_OK;
    m_bPhysicalHeap = bIsPhysicalHeap;
    m_dwHeapSize = dwHeapSize;

    if (m_bPhysicalHeap)
        hr = DirectMusicCreateFixedSizePhysicalHeap(dwHeapSize, &m_pHeap);        
    else
        hr = DirectMusicCreateFixedSizeHeap(dwHeapSize, &m_pHeap);        
        
    return hr;
}


ULONG STDMETHODCALLTYPE CMusicHeapFixed::AddRef( void)         
{
return InterlockedIncrement(&m_cRef);
}

ULONG STDMETHODCALLTYPE CMusicHeapFixed::Release(void) 
{
    ULONG cRef;            
    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

STDMETHODIMP CMusicHeapFixed::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
return E_NOTIMPL;
}



STDMETHODIMP CMusicHeapFixed::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = Alloc(dwSize);
    if(!pData)
    {
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}


void* CMusicHeapFixed::Alloc(size_t cb)
{
    DWORD* pBlock = 0;
    HRESULT hr = S_OK;
    
    hr = m_pHeap->Allocate(cb + sizeof(DWORD), (LPVOID *)&pBlock);
    EnterCriticalSection(&m_csHeap);
    
    if(!pBlock || FAILED(hr))
    {        
        Log("\n");
        Log("%s HEAP OUT OF MEMORY!!!\n", m_bPhysicalHeap ? "PHYSICAL" : "NON-PHYSICAL");
        Log("m_dwHeapAllocation             = %u\n", m_dwHeapAllocation);
        Log("m_dwHeapSize                   = %u\n", m_dwHeapSize);
        Log("m_dwHeapAllocationBlocks       = %u\n", m_dwHeapAllocationBlocks);
        Log("m_dwHeapAllocationBlocksPeak   = %u\n", m_dwHeapAllocationBlocksPeak);
        Log("\n");
        assert(FALSE);
        LeaveCriticalSection(&m_csHeap);
        return NULL;
    }

    m_dwHeapAllocation += (cb + sizeof(DWORD));
    if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
        m_dwHeapAllocationPeak = m_dwHeapAllocation;
    }
    ++m_dwHeapAllocationBlocks;
    if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
        m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }

    LeaveCriticalSection(&m_csHeap);

    *pBlock = cb;
    return pBlock + 1;
}

STDMETHODIMP CMusicHeapFixed::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    DWORD* pBlock = ((DWORD*) pData) - 1;
    *pcbSize = *pBlock;

    return S_OK;
}

STDMETHODIMP CMusicHeapFixed::Free(void *pv)
{
    assert(pv);
    DWORD* pBlock = ((DWORD*) pv) - 1;
    DWORD cb = *pBlock;
    EnterCriticalSection(&m_csHeap);
    assert(cb+sizeof(DWORD) < 64 * 1024 * 1024);
    
    //Update our stats
    m_dwHeapAllocation -= (cb + sizeof(DWORD));
    --m_dwHeapAllocationBlocks;

    //Set all block memory to a certain value.
    memset((void *)pBlock, 0xFE, cb+sizeof(DWORD));

    LeaveCriticalSection(&m_csHeap);
    m_pHeap->Free(pBlock);
    return S_OK;
}


STDMETHODIMP CMusicHeapFixed::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    *pdwHeapAllocation = m_dwHeapAllocation;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    return S_OK;
};

STDMETHODIMP CMusicHeapFixed::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CreateMusicHeapFixed(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CMusicHeapFixed* pHeap = NULL;

    pHeap = new CMusicHeapFixed();

    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(dwSize, bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}




}//end "namespace WFVO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\MusicHeapFixedCache.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapFixed.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "helpers.h"
#include "assert.h"

using namespace WFVO;

#define VERIFYHEAP VerifyHeap();
#define INITIALIZE_MEMORY 
#define CACHE


namespace WFVO
{

/*
class CMusicHeapFixedCache : public IMusicHeap
{
    //LOCALALLOC_NEWDELETE
public:

    CMusicHeapFixedCache(void);
    HRESULT Initialize(DWORD dwNormalHeapSize);
    ~CMusicHeapFixedCache(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    //  IDirectMusicHeap 
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(Free)   (PVOID pData);

private:
    // Use standard HeapCreate / HeapAlloc heap for the normal heap.
    HANDLE m_hHeap;
    LONG m_cRef;

};



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::CMusicHeapFixedCache(void)
{
m_cRef = 1;
m_hHeap = 0;
}




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CMusicHeapFixedCache::Initialize(DWORD dwNormalHeapSize)
{
    m_hHeap = HeapCreate(0, dwNormalHeapSize, dwNormalHeapSize);
    if(!m_hHeap){
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::~CMusicHeapFixedCache()
{
    if(m_hHeap) {
        HeapDestroy(m_hHeap);
    }
}

// IUnknown
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::AddRef(void) 
    
{
    return InterlockedIncrement(&m_cRef);
}


//------------------------------------------------------------------------------
//-----------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::Release(void) 
{
    ULONG cRef;
        
    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
        delete this;

    return cRef;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//TODO: Add code to track allocations and sizes here.
STDMETHODIMP CMusicHeapFixedCache::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = HeapAlloc(m_hHeap, 0, dwSize);
    if(!pData){
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Free(PVOID pData)
{
    HeapFree(m_hHeap, 0, pData);
    return S_OK;
}




//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

*/

class CMusicHeapFixedCache : public IMusicHeap
{
//    LOCALALLOC_NEWDELETE
private:
    // Use a traditional first-fit heap for the physical memory heap

    struct BlockHead
    {
        BlockHead* pNext;
        //BlockHead* pPrev;
        unsigned int size;
        BOOL bUsed;
    };

    LONG m_cRef;
    CRITICAL_SECTION m_csPhysicalHeap;
    BlockHead* m_pHead;
    
    #ifdef CACHE
    BlockHead *m_pLastBlock;
    DWORD m_dwCacheHits;
    DWORD m_dwCacheMisses;
    DWORD m_dwCacheMissesNotBigEnough;
    #endif

    BOOL m_bPhysical;
    DWORD m_dwHeapSize;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;

    STDMETHOD(VerifyHeap)(void);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    //  IMusicHeap
    STDMETHOD(Allocate)   (DWORD dwSize, PVOID* ppData);
    STDMETHOD(Free)   (PVOID pData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);


    CMusicHeapFixedCache(void);
    ~CMusicHeapFixedCache(void);
    HRESULT Initialize(DWORD dwHeapSize, BOOL bPhysical);

};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::CMusicHeapFixedCache()
{
    m_cRef = 1;
    m_pHead = 0;
    
    #ifdef CACHE
    m_pLastBlock = 0;
    #endif

    m_bPhysical = FALSE;
    m_dwHeapSize = 0;
    ZeroMemory(&m_csPhysicalHeap, sizeof(m_csPhysicalHeap));
    m_dwHeapAllocation           = 0;
    m_dwHeapAllocationPeak       = 0;
    m_dwHeapAllocationBlocks     = 0;
    m_dwHeapAllocationBlocksPeak = 0;
    m_dwCacheHits = 0;
    m_dwCacheMisses = 0;
    m_dwCacheMissesNotBigEnough = 0;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
CMusicHeapFixedCache::~CMusicHeapFixedCache()
{
    XPhysicalFree(m_pHead);
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CMusicHeapFixedCache::Initialize(DWORD dwHeapSize, BOOL bPhysical)
{
    InitializeCriticalSection(&m_csPhysicalHeap);
    EnterCriticalSection(&m_csPhysicalHeap);

    m_dwHeapSize = dwHeapSize;
    if(dwHeapSize < sizeof(BlockHead))
    {
        dwHeapSize = sizeof(BlockHead);
    }
    
    if (!bPhysical)
        m_pHead = (BlockHead *)LocalAlloc(LMEM_FIXED, dwHeapSize);
    else
        m_pHead = (BlockHead*) XPhysicalAlloc(dwHeapSize, MAXULONG_PTR, 0, PAGE_READWRITE);



    if(!m_pHead)
    {
        LeaveCriticalSection(&m_csPhysicalHeap);
        return E_OUTOFMEMORY;
    }
    m_pHead->pNext = 0;
    //m_pHead->pPrev = 0;
    m_pHead->size = dwHeapSize-sizeof(BlockHead);
    m_pHead->bUsed = 0;
    memset(((char *)m_pHead) + sizeof(BlockHead), 0x00, m_pHead->size);
    LeaveCriticalSection(&m_csPhysicalHeap);

    return S_OK;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    return E_NOTIMPL;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::AddRef(void)         
{
    return InterlockedIncrement(&m_cRef);
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE CMusicHeapFixedCache::Release( void)
{
    ULONG cRef;
        
    cRef = InterlockedDecrement(&m_cRef);

    if (cRef == 0)
        delete this;

    return cRef;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::VerifyHeap(void)
{
   DWORD dwCount = 0;
   BlockHead *pB = NULL;
   char *pByte;


   EnterCriticalSection(&m_csPhysicalHeap);

    for(pB = m_pHead; pB; pB = pB->pNext)
    {
        dwCount++;
        pByte = (char *)pB;
        
        //Verify that the first and last byte in this block are 'X'.
        /*
        if (pB->bUsed == 0)
        {
         
            if ((pByte + sizeof(BlockHead))[0] != 'X')
            {
                Log("Heap Corruption at beginning of block");
                assert(FALSE);
            }

            if ((pByte + sizeof(BlockHead))[pB->size - 1] != 'X')
            {
                Log("Heap Corruption at end of block");
                assert(FALSE);
            }
        }
        */

        //Verify that the sizes match.
        if (pB->pNext)
        {
            if ((char *)pB->pNext - (char *)pB != pB->size + sizeof(BlockHead))
            {
                Log("Difference between pB (%08X) and pB->pNext (%08X) is %08X (%d), but the size of pB + sizeof(BlockHead) is %08X (%d)\n",
                     pB,
                     pB->pNext,
                     (char *)pB->pNext - (char *)pB,
                     (char *)pB->pNext - (char *)pB,
                     pB->size,
                     pB->size
                     );
                assert(FALSE);
            }
        }
    }


   LeaveCriticalSection(&m_csPhysicalHeap);
   return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    EnterCriticalSection(&m_csPhysicalHeap);
    BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
    *pcbSize = pB->size;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
}



//------------------------------------------------------------------------------
//CACHING:

//Simple overview that isn't quite right:
//    When we split a block, we cache the remaining (unallocated) block and check it
//    the next allocation attempt before walking the list again.

//The way it really works.
//    When we free a block, we check if it's address is smaller than the currently cached
//    block.  If so, then we make that the cached block.  

//    When we split a block that was found in the cache, we cache the split block (if there is any space left)
    
//    When we split a block that wasn't found in the cache, and there still is a cached block,
//    we keep the cached block, otherwise we cache the split block.
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = NULL;
    BOOL bFound = FALSE;
    BOOL bFoundInCache = FALSE;
    BlockHead* pB = NULL;
    BlockHead* pBStartingPoint = NULL;
    DWORD dwStartingPoint = 0;

    VERIFYHEAP

    EnterCriticalSection(&m_csPhysicalHeap);

    //Round up to the nearest DWORD
    dwSize += (4 - (dwSize & 3));

    //We've cached the most recently-created block.  Try it first.    
/*
    #ifdef CACHE
    if (m_pLastBlock)
    {
        //If this one's big enough take it, otherwise walk to the next big enough one.
        if (dwSize <= m_pLastBlock->size)
        {   
            pB = m_pLastBlock;
            m_pLastBlock = NULL;
            bFound = TRUE;
            bFoundInCache = TRUE;
        }
        else
        {
        }
    }
    #endif
*/


    //Try searching and coalescing from the cached block, then from the beginning.
    for (dwStartingPoint = 0; dwStartingPoint < 2; dwStartingPoint++)        
    {
        //Try the cached block first.
        pBStartingPoint = (dwStartingPoint==0) ? m_pLastBlock : m_pHead;
        for(pB = pBStartingPoint; pB; pB = pB->pNext)
        {
            if((!pB->bUsed))
            {
                // Coalesce with next block, if possible
                while(pB->pNext && !pB->pNext->bUsed)
                {
                    //If we're coalescing the cached block, set the cached block to the one that coalesced it.
#ifdef CACHE
                    if (pB->pNext == m_pLastBlock)
                        m_pLastBlock = pB;
#endif
                
                    pB->size += pB->pNext->size + sizeof(BlockHead);
                    pB->pNext = pB->pNext->pNext;
                }
        
                // Is this block big enough to use?
                if(dwSize <= pB->size)
                {
                    bFound = TRUE;
#ifdef CACHE                    
                    //If we've chosen the cached block, then whip it out.
                    if (pB == m_pLastBlock)
                    {
                        m_pLastBlock = NULL;
                        m_dwCacheHits++;
                    }
                    else
                    {
                        m_dwCacheMisses++;
                    }

#endif


                    break;
                }
            }
        }

        
        if (bFound)
            break;
    }

/*
#ifdef CACHE    
    //Keep stats.
    if (bFoundInCache)
        m_dwCacheHits ++;
    else
        m_dwCacheMisses ++;
#endif
*/


    //If we found a big enough block, then attempt to split it.  Then use it.
    if (bFound)
    {
        // Is it big enough to split?
        if(dwSize + sizeof(BlockHead) < pB->size)
        {
            // Split.  
            BlockHead* pNew = (BlockHead*) (((char*) pB) + sizeof(BlockHead) + dwSize);

            pNew->pNext = pB->pNext;
            pNew->size = pB->size - (dwSize + sizeof(BlockHead));
            pNew->bUsed = 0;
            pB->pNext    = pNew;                    
           
            //Cache the most recently created block.
            m_pLastBlock = pNew;

/*
#ifdef CACHE
            //When we split a block that was found in the cache, we cache the split block (if there is any space left)
            if (bFoundInCache)

            //When we split a block that wasn't found in the cache, and there still is a cached block,
            //we keep the cached block, otherwise we cache the split block.
            else
            {
                if (!m_pLastBlock)
                {
                    m_pLastBlock = pNew;
                }
            }

#endif
*/

            pB->size = dwSize;

        }
        
#ifdef CACHE
/*
        //If the block wasn't big enough to split, then walk the list for a new available block.
        else
        {
            m_pLastBlock = pB;
            do
            {
                m_pLastBlock = m_pLastBlock->pNext;                
                if (NULL == m_pLastBlock)
                    break;
            }
            while (m_pLastBlock->bUsed);

        }
*/

        //If we used the cached block, or don't have one, or couldn't split the new block, then walk the list forward from the one we found to
        //  find a new cached block.
/*
        if (!m_pLastBlock)
        {
            m_pLastBlock = pB;
            do
            {
                m_pLastBlock = m_pLastBlock->pNext;                
                if (NULL == m_pLastBlock)
                    break;
            }
            while (m_pLastBlock->bUsed);

        }
*/

#endif

        pB->bUsed = 'z';
        pData = (void*) (((char*) pB) + sizeof(BlockHead));

        
        #ifdef INITIALIZE_MEMORY
        //Initialize the "new data" to something
        memset(pData, 0xAA, dwSize);
        #endif

        
        //Update our internal data.
        m_dwHeapAllocation += (pB->size + sizeof(BlockHead));
        if(m_dwHeapAllocation > m_dwHeapAllocationPeak)
            m_dwHeapAllocationPeak = m_dwHeapAllocation;
        ++m_dwHeapAllocationBlocks;
        if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak)
            m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }
    
    LeaveCriticalSection(&m_csPhysicalHeap);

    VERIFYHEAP
    
    if(!pData)
    {
        Log("ERROR: Out of %s memory!\n", m_bPhysical ? "Physical" : "Non-Physical");
        Log("Limit:                  %9u\n", m_dwHeapSize);
        Log("Current:                %9u\n", m_dwHeapAllocation);
        Log("Attempting to allocate: %9u\n", dwSize);
        Log("# of allocations:       %9u\n", m_dwHeapAllocationBlocks);
        Log("Fragmentation (bytes):  %9d\n", m_dwHeapSize - m_dwHeapAllocation - dwSize);
        Log("Fragmentation (%%):       %9.2f\n", FLOAT(100 *(m_dwHeapSize - m_dwHeapAllocation - dwSize)) / FLOAT(m_dwHeapSize));
        assert(FALSE);
        return E_OUTOFMEMORY;
    }

    *ppData = pData;
    assert((DWORD)pData % 4 == 0);
    return S_OK;
}



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::Free(PVOID pData)
{
 
    if (!pData)
    {
        Log("FIXED HEAP ERROR: Someone called Free() on a NULL ptr");
        assert(FALSE);
    }

    VERIFYHEAP
    EnterCriticalSection(&m_csPhysicalHeap);
    BlockHead* pB = (BlockHead*)(((char*) pData) - sizeof(BlockHead));
    if (pB->bUsed != 'z')
    {   
        Log("Bad Block");
        assert(FALSE);
    }

    //Update our internal data.
    m_dwHeapAllocation -= (pB->size + sizeof(BlockHead));
    --m_dwHeapAllocationBlocks;

    //If we don't have a block cached, or this one is less than the cached one,
    //  then cache this one.
    #ifdef CACHE
    if (!m_pLastBlock || (pB < m_pLastBlock))
    {
        m_pLastBlock = pB;
    }
    #endif

    //Set all the memory to a known value for debugging.
    #ifdef INITIALIZE_MEMORY
    memset(((char *)pB) + sizeof(BlockHead), 0xFF, pB->size);
    #endif 

    pB->bUsed = 0;

    LeaveCriticalSection(&m_csPhysicalHeap);
    VERIFYHEAP

    return S_OK;
}


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocation = m_dwHeapAllocation;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
STDMETHODIMP CMusicHeapFixedCache::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    EnterCriticalSection(&m_csPhysicalHeap);        
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    LeaveCriticalSection(&m_csPhysicalHeap);
    return S_OK;
};



//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
HRESULT CreateMusicHeapFixedCache(IMusicHeap** ppHeap, bool bPhysical, DWORD dwSize)
{
    HRESULT hr = S_OK;
    CMusicHeapFixedCache* pHeap = NULL;

    pHeap = new CMusicHeapFixedCache();

    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(dwSize, bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}



}//end "namespace WFVO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define IDD_DIALOG1                     101
#define IDD_DIALOGBAR                   103
#define IDC_COMBO1                      1003
#define IDC_EDIT3                       1004
#define IDC_BUTTON2                     1006
#define IDC_BUTTON3                     1007
#define IDC_BUTTON6                     1010
#define IDC_BUTTON7                     1011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\scene.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.cpp

Abstract:

	3D Scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "media.h"
#include "scene.h"
#include "helpers.h"
#include "music.h"

using namespace WFVO;

extern IDirect3D8* g_d3d;

namespace WFVO {

extern CMusic g_music;
extern LPDIRECTSOUND g_dsound;

//------------------------------------------------------------------------------
//	Macros:
//------------------------------------------------------------------------------
#define ADJUST(A) (((-(A)) + 1.0f) / 2.0f)
#define MIN2(A,B) ((A) <= (B) ? (A) : (B))
#define MAX2(A,B) ((A) >= (B) ? (A) : (B))
#define MAX3(A,B,C) MAX2((A), MAX2((B), (C)))
#define FUDGE(A,B,C) (fabs((A) - (B)) < (C) ? (B) : (A))
#ifndef PI 
#	define PI 3.14159265359f
#endif

#define BALL_RADIUS		0.5f
#define LIGHT_RADIUS	0.125f
#define BALL_MASS		10.0f
#define LIGHT_MASS		1.0f

#define DRAWTEXT( a, b, c, d, e, f, g ) \
if ( m_bDrawText )						\
{										\
	m_font.DrawText( a, b, c, d, e, f, g ); \
}											


//------------------------------------------------------------------------------
//	File IO handlers
//------------------------------------------------------------------------------
VOID CompleteIO(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped)
    {
    if(!lpOverlapped || !lpOverlapped->hEvent) 
        {
        // this is bad - memory is corrupt - and because of this we will leak
        return;
        }

    FileIOHandle *info = (FileIOHandle*)lpOverlapped->hEvent;

    if(dwNumberOfBytesTransfered != info->buffSize)
        {
        // error
        }

    // clean up all the handles and structs
    delete info->buffer;
    delete info;
    delete lpOverlapped;
    }


//------------------------------------------------------------------------------
//	CScene::CScene
//------------------------------------------------------------------------------
CScene::CScene(void)
/*++

Routine Description:

	Constructor

Arguments:

	None

Return Value:

	None

--*/
{
    m_pd3ddm = NULL;
}  

//------------------------------------------------------------------------------
//	CScene::~CScene
//------------------------------------------------------------------------------
CScene::~CScene(void)
/*++

Routine Description:

	Destructor

Arguments:

	None

Return Value:

	None

--*/
{
	delete [] m_balls;
	delete [] m_backgroundTriangles;
    ReleaseShaders();
    if (m_pd3ddm) {
        delete [] m_pd3ddm;
    }
}

//------------------------------------------------------------------------------
//	CScene::Initialize
//------------------------------------------------------------------------------
HRESULT
CScene::Initialize(
				   IN IDirect3DDevice8*	pDevice
				   ) 
/*++

Routine Description:

	Intializes the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	S_OK on success, any other value on failure

--*/
{
	LONGLONG	timer;
	HRESULT		hr;
	UINT		i;
	UINT		ii;
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	float		dxyz;
	double		phi;
	double		rho;
	LONGLONG frequency;
    D3DLOCKED_RECT d3dlr;

    m_hFile                 = INVALID_HANDLE_VALUE;
	m_ballDetail			= g_TestParams.dwBallDetail;	// Default = 12
    m_lightDetail			= g_TestParams.dwLightDetail;   // Default = 12
	m_wallDetail			= g_TestParams.dwWallDetail;	// Default = 20
	m_numLayers				= g_TestParams.dwNumLayers;		// Default = 0
	m_numBalls				= g_TestParams.dwNumBalls;		// Default = 20
	m_maxBalls				= g_TestParams.dwMaxBalls;		// Default = 50
    m_numLights				= g_TestParams.dwNumLights;     // Default = 5
    m_maxLights				= g_TestParams.dwMaxLights;     // Default = 10
	m_radius				= g_TestParams.fRadius;	        // Default = 5.5f
	m_maxSpeed				= g_TestParams.fMaxSpeed;		// Default = 15.0f
	m_minSpeed				= g_TestParams.fMinSpeed;		// Default = 0.1f
	m_bDrawWireframe		= g_TestParams.bDrawWireframe;	// Default = TRUE
	m_bRelativeSpeed		= g_TestParams.bRelativeSpeed;	// Default = TRUE
	m_radius2				= m_radius * m_radius;
	m_elapsedTime			= 0.0;
	m_lastTime				= 0.0;
	m_lastCycle				= 0.0;
	m_avgFrameRate			= 0.0;
	m_currentFrameRate		= 0.0;
	m_frame					= 0;
	m_numTris				= 0;
	m_drawRate				= 60.0;

	// this is set by button state, not the ini

	m_bDrawText				= TRUE;

    // We need to store the device in order to delete our programmable shaders on exit
    m_pDevice = pDevice;

	// Cheesey error detection
	m_balls = new CBall [m_maxBalls + m_maxLights];
	ASSERT(m_balls != NULL);
	
	m_backgroundTriangles = new CScene::Vertex [m_numLayers * 3 * 2];
	ASSERT(m_backgroundTriangles != NULL);

	// Query the performance frequency
	QueryPerformanceFrequency((LARGE_INTEGER*)&frequency);
	m_frequency = (double)frequency;

    // Build a display mode list
    m_uNumDisplayModes = g_d3d->GetAdapterModeCount(D3DADAPTER_DEFAULT);
    if (!m_uNumDisplayModes) {
        return E_FAIL;
    }

    m_pd3ddm = new D3DDISPLAYMODE[m_uNumDisplayModes];
    if (!m_pd3ddm) {
        return E_OUTOFMEMORY;
    }

    for (i = 0; i < m_uNumDisplayModes; i++) {
        hr = g_d3d->EnumAdapterModes(D3DADAPTER_DEFAULT, i, &m_pd3ddm[i]);
        if (FAILED(hr)) {
            return hr;
        }
    }
    m_uDisplayMode = 0;
	
	// Create the sphere
	hr = m_invertedSphere.Create(pDevice, m_radius, m_wallDetail * 2, m_wallDetail);
	if(hr != S_OK)
		return hr;
	m_numTris += m_invertedSphere.GetNumTris();

	m_invertedSphere.SetPosition(XGVECTOR3(0.0f, 0.0f, 0.0f));

	// Create the balls
	for(i=0; i<m_maxBalls; ++i)
	{
		hr = m_balls[i].Create(pDevice, BALL_RADIUS, BALL_MASS, m_ballDetail, 
							   (int)((float)m_ballDetail * 0.75f), FALSE, i);
		if(hr != S_OK)
			return hr;
	}

    // Create the lights
    for (; i < m_maxBalls + m_maxLights; i++) {
        hr = m_balls[i].Create(pDevice, LIGHT_RADIUS, LIGHT_MASS, m_lightDetail, 
							   (int)((float)m_lightDetail * 0.75f), TRUE, i);
		if(hr != S_OK)
			return hr;
    }

	m_sparks.Create(pDevice);

	//initialize the sparks


	// Create the background triangles
	for(ii=0, i=0; i<m_numLayers; ++i)
	{
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= RandomColor();
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 0.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 0.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;
		m_backgroundTriangles[ii].x			= 640.0f;
		m_backgroundTriangles[ii].y			= 480.0f;
		m_backgroundTriangles[ii].z			= 1.0f;
		m_backgroundTriangles[ii].rhw		= 1.0f;
		m_backgroundTriangles[ii++].color	= m_backgroundTriangles[ii-1].color;

		m_numTris += 2;
	}

    // Create the shaders
    hr = CreateShaders(pDevice);
    if (FAILED(hr)) {
        return hr;
    }

    // Create the cube texture renormalization map
    hr = CreateNormalMap(pDevice, 256, 0, &m_pd3dtcNormal);
    if (FAILED(hr)) {
        return hr;
    }

    // Create a buffer for the text
    hr = pDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pd3dtText);
    if (FAILED(hr)) {
        return hr;
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    m_prText[0].x = 0.0f;
    m_prText[0].y = 480.0f;
    m_prText[0].u = 0.0f;
    m_prText[0].v = 240.0f;

    m_prText[1].x = 0.0f;
    m_prText[1].y = 0.0f;
    m_prText[1].u = 0.0f;
    m_prText[1].v = 0.0f;

    m_prText[2].x = 640.0f;
    m_prText[2].y = 0.0f;
    m_prText[2].u = 320.0f;
    m_prText[2].v = 0.0f;

    m_prText[3].x = 640.0f;
    m_prText[3].y = 480.0f;
    m_prText[3].u = 320.0f;
    m_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        m_prText[i].z = 0.0f; //0.000001f;
        m_prText[i].rhw = 1.0f; ///1000000.0f;
    }

	// Setup the camera (resuse some other vars)
	m_camera.SetViewport(0, 0, 640, 480, 0.0f, 1.0f);
	m_camera.LookAt(XGVECTOR3(0.0f, 0.0f, -2.0f * m_radius), 
					XGVECTOR3(0.0f, 0.0f, 0.0f), XGVECTOR3(0.0f, 1.0f, 0.0f));
	m_camera.SetPerspectiveFov(45.0f, 640.0f / 480.0f, 0.99f * m_radius, 3.01f * m_radius);
	m_camera.EnableLight(TRUE, FALSE);
	m_camera.RotateLightY(-30.0f);
	m_camera.RotateLightX(-30.0f);
	XGMatrixIdentity(&m_identityMatrix);

	// Set the position, speed and direction for the balls
	for(i=0; i<m_maxBalls + m_numLights; ++i) {

        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Make sure the new ball is not within 1 unit of another
		do {
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
			XGVec3Normalize(&dir, &dir);
			speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;
			for(ii=0; goodLoc && ii<i; ++ii) {
                if (ii == m_numBalls) {
                    ii = m_maxBalls;
                }
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[ii].GetLocation())) <= m_balls[ii].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		} while(!goodLoc);

		m_balls[i].SetPosition(loc);
		m_balls[i].SetDirection(dir);
		m_balls[i].SetSpeed(speed);
		
		m_numTris += m_balls[i].GetNumTris();
	}

	RecalculateSpeeds();

    // Global scene ambient lighting
    m_dcvAmbient.r = 0.2f;
    m_dcvAmbient.g = 0.2f;
    m_dcvAmbient.b = 0.2f;
    m_dcvAmbient.a = 1.0f;

    pDevice->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_RGBA((BYTE)(m_dcvAmbient.r * 255.0f), (BYTE)(m_dcvAmbient.g * 255.0f), (BYTE)(m_dcvAmbient.b * 255.0f), (BYTE)(m_dcvAmbient.a * 255.0f)));

	// Get the backbuffer for the font
	hr = pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_backBuffer);
	if(hr != D3D_OK)
		return hr;

	// Setup the timer
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	m_lastTime	= (double)timer / m_frequency;
	m_startTime	= m_lastTime;
	m_lastCycle	= m_lastTime;

	XGVECTOR4 sparkcolor(1.0f, 0.25f, 0.0f, 0.6f/(float)g_TestParams.dwSparkMaxAge);
	pDevice->SetVertexShaderConstant(23, &sparkcolor, 1);


    //
    // audio variables
    //


    m_dwAudioReadPtr = 0;
    m_dwAudioWritePtr = 0;
    m_dwAudioReadTotal = 0;
    m_dwAudioWriteTotal = 0;
    m_dwAudioDelta = 100000;

    return S_OK;
}

//------------------------------------------------------------------------------
//	CScene::NextFrame
//------------------------------------------------------------------------------
void CScene::NextFrame(void)
/*++

Routine Description:

	Sets up for the next frame

Arguments:

	None

Return Value:

	None

--*/
{
	XGVECTOR3	point;
	float		distance;
	float		saveDistance;
	UINT		hit;
	float		moveLeft;
	float		moved;
	XGVECTOR3	normal;
	XGVECTOR3	inverse;
	XGVECTOR3	reflection;
	UINT		i;
	UINT		ii;
	CScene::Hit	hitWhat;
	XGVECTOR3	loc;
    static BOOL doUpdate = TRUE;
	XGVECTOR3	saveNormal;
	float		speed;
	XGVECTOR3	dirA;
	XGVECTOR3	dirB;
	float		speedA;
	float		speedB;
	long		lastBallHit;
	UINT		numObjects = m_maxBalls + m_numLights;
	UINT		hits;

	// To disable ball or test changes for debug purposes
	if(!doUpdate)
		return;

	//update sparks
	m_sparks.Update(1/(float)m_drawRate);

	// Move all the balls
	for(i=0; i<numObjects; ++i) 
	{
        if (i == m_numBalls) {
			if(m_numLights == 0)
				break;
            i = m_maxBalls;
        }

		// Generate a speed based on the framerate so changes to framerates do not
		// change the actual distance a ball moves
		speed		= m_balls[i].GetSpeed() / (float)m_drawRate;
		moveLeft	= speed;
		moved		= 0.0f;	
		lastBallHit	= -1;
		hits		= 0;

		while((moveLeft > 0.0) && (hits < numObjects))
		{
			++hits;
			saveDistance	= 1.0e30f;
			hitWhat			= CScene::HIT_NOTHING;
			hit				= i;

			// Get the intersection with the bounding sphere
			if(!IntersectRayInSphere(m_balls[i].GetLocation(), m_balls[i].GetDirection(), 
								     XGVECTOR3(0.0f, 0.0f, 0.0f), m_radius, point)) 
			{
				__asm int 3;	// This should never happen!
				doUpdate = FALSE;
				return;
			}

			distance = XGVec3Length(&XGVECTOR3(point - m_balls[i].GetLocation())) -
					   m_balls[i].GetRadius();
			if(distance < 0.0f)
				distance = 0.0f;

			// Will the bounding sphere be hit?
			if(distance <= moveLeft) 
			{
				saveDistance	= distance;
				hitWhat			= CScene::HIT_WALL;
			}

			// Check for intersection with all other balls
			for(ii=0; ii<numObjects; ++ii) 
			{
                if (ii == m_numBalls) {
					if(m_numLights == 0)
						break;
                    ii = m_maxBalls;
                }

				if(i != ii)
				{
					if(GetSphereIntersection(m_balls[i].GetLocation(),
											 m_balls[i].GetRadius(),
											 m_balls[i].GetDirection(),
											 m_balls[ii].GetLocation(),
											 m_balls[ii].GetRadius(),
											 distance)) 
					{
						distance = FUDGE(distance, moveLeft, 0.0001);
						if(distance < 0.0f)
							distance = 0.0f;
						if((distance <= moveLeft) && (distance < saveDistance))
						{
							normal.x = (m_balls[i].GetLocation().x + m_balls[i].GetDirection().x * distance) - 
										m_balls[ii].GetLocation().x;
							normal.y = (m_balls[i].GetLocation().y + m_balls[i].GetDirection().y * distance) -
										m_balls[ii].GetLocation().y;
							normal.z = (m_balls[i].GetLocation().z + m_balls[i].GetDirection().z * distance) -
										m_balls[ii].GetLocation().z;

							// Check for valid hit
							if(XGVec3Dot(&normal, &m_balls[i].GetDirection()) < 0.0f)
							{
								XGVec3Normalize(&saveNormal, &normal);
								saveDistance	= distance;
								hit				= ii;
								hitWhat			= CScene::HIT_BALL;
							}
						}
					}
				}
			}

			// What was hit?
			switch(hitWhat)
			{
			case CScene::HIT_WALL:	// Hit the wall

				// Normal at inner point on sphere
				normal = -point;
				XGVec3Normalize(&normal, &normal);

				// Callback
				BallHitWall(i, normal);

				// Move the ball
				m_balls[i].Move(saveDistance);
				moved = saveDistance;

				// Inverse of direction
				inverse = -m_balls[i].GetDirection();
				
				// Calculate the reflection
				reflection = normal * 2.0f * (XGVec3Dot(&normal, &inverse)) - inverse;

				// Callback
				BallDirectionChanged(i, m_balls[i].GetDirection(), reflection);

				// Change the ball's direction
				m_balls[i].SetDirection(reflection);
				break;

			case CScene::HIT_BALL:	// Hit another ball
			
				// Prevent a ball from running into the same ball multiple times, 
				// and make sure the colliding ball overtakes the target
				if(((long)hit != lastBallHit) &&
				   (m_balls[i].GetSpeed() > (m_balls[hit].GetSpeed() * 
											 XGVec3Dot(&m_balls[i].GetDirection(),
													   &m_balls[hit].GetDirection()))))
				{
					lastBallHit = (long)hit;

					// Move the ball
					m_balls[i].Move(saveDistance);
					moved = saveDistance;

					dirA	= m_balls[i].GetDirection();
					dirB	= m_balls[hit].GetDirection();
					speedA	= m_balls[i].GetSpeed();
					speedB	= m_balls[hit].GetSpeed();

					// If both balls are of the same type, collide as normal
					CollideBalls(m_balls[i].GetLocation(), dirA, speedA, m_balls[i].GetMass(),
								 m_balls[hit].GetLocation(), dirB, speedB, m_balls[hit].GetMass());

					// If the ball's speed changes so should moveLeft...
					moveLeft -= (m_balls[i].GetSpeed() - speedA) / (float)m_drawRate;
					
					// Callbacks
					BallHitBall(i, hit);
					BallDirectionChanged(i, m_balls[i].GetDirection(), dirA);
					BallDirectionChanged(hit, m_balls[hit].GetDirection(), dirB);
					BallSpeedChanged(i, m_balls[i].GetSpeed(), speedA);
					BallSpeedChanged(hit, m_balls[hit].GetSpeed(), speedB);
					
					m_balls[i].SetDirection(dirA);
					m_balls[hit].SetDirection(dirB);
					m_balls[i].SetSpeed(speedA);
					m_balls[hit].SetSpeed(speedB);

					RecalculateSpeeds();
				}
				else
					moveLeft = 0.0f;
				break;

			default:	// Otherwise, just move the ball forward

				m_balls[i].Move(moveLeft);
				moved = moveLeft;

				break;
			}
			moveLeft -= moved;
		}
	}
}

//------------------------------------------------------------------------------
//	CScene::Render
//------------------------------------------------------------------------------
void 
CScene::Render(
			   IN IDirect3DDevice8*	pDevice
			   ) 
/*++

Routine Description:

	Renders the scene

Arguments:

	IN pDevice -	IDirect3DDevice8

Return Value:

	None

--*/
{
    DWORD				dwValue;
	LONGLONG			timer;
	LONGLONG			start;
	WCHAR				buffer[256];
	UINT				i;
	UINT				j;
	UINT				k;
	UINT				y;
    HRESULT				hr;
	double				currentTime;
	float				lineWidth = 1.0f;
    XGMATRIX			mView;
	XGMATRIX			mProj;
	XGMATRIX			mViewProj;
    XGVECTOR3			vEyePos;
    D3DLIGHT8			light;
    IDirect3DSurface8*	pd3ds;
	int					hours;
	int					minutes;
	int					seconds;
	int					fraction;
	BOOL				bCycle;
	double				dt;
    D3DLOCKED_RECT		d3dlr;
    DWORD				dwNormal;
    DWORD				dwPhysical;        

	// For draw rate
	QueryPerformanceCounter((LARGE_INTEGER*)&start);
	
	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
	pDevice->SetRenderState(D3DRS_MULTISAMPLEMASK, 0xffffffff);
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
	pDevice->SetRenderState(D3DRS_LINEWIDTH, *(DWORD*)&lineWidth);

    for (i = 0; i < 2; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }
    for (i = 2; i < 4; i++) {
        pDevice->SetTextureStageState(i, D3DTSS_MINFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MAGFILTER, D3DTEXF_POINT);
        pDevice->SetTextureStageState(i, D3DTSS_MIPFILTER, D3DTEXF_POINT);
    }

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);

    pDevice->SetRenderState(D3DRS_POINTSIZE_MIN, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_A, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_B, F2DW(0.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALE_C, F2DW(1.0f));
    pDevice->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);

    pDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL, 0xff000000, 1.0f, 0);

    // Begin the scene
    pDevice->BeginScene();

    // Screen space offset
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        D3DFIELD_STATUS fstatus;
        pDevice->GetDisplayFieldStatus(&fstatus);
        pDevice->SetScreenSpaceOffset(0.0f, (fstatus.Field == D3DFIELD_EVEN) ? 0.0f : 0.5f);
    }

	// World matrix
	pDevice->SetTransform(D3DTS_WORLD, &m_identityMatrix);

	// Camera
	m_camera.Render(pDevice);

    // Get the view and projection matrices
    pDevice->GetTransform(D3DTS_VIEW, &mView);
    pDevice->GetTransform(D3DTS_PROJECTION, &mProj);

    XGMatrixMultiply(&mViewProj, &mView, &mProj);

    // Get the camera position
    m_camera.GetPosition(&vEyePos);

	// Draw the background triangles with depth write disabled to ensure all are written
	// without affecting other draws
    if(m_numLayers) {
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, FALSE);
        pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
        pDevice->DrawPrimitiveUP(D3DPT_TRIANGLELIST, m_numLayers * 2, m_backgroundTriangles,
                                 sizeof(CScene::Vertex));
        pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
    }
    
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetVertexShader(m_dwVShader);
    pDevice->SetPixelShader(m_dwPShader);

    pDevice->SetTexture(2, m_pd3dtcNormal);
    pDevice->SetTexture(3, m_pd3dtcNormal);

	// Draw balls
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        for (j = 0; j < m_numBalls; j++) {
            m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_balls[i].GetLight(), &m_dcvAmbient, i - m_maxBalls);
        }
    }
	if(g_TestParams.bSparksAreLights) {
		for(i=0, k=m_sparks.GetNumSparks(); i<k; ++i) {
			for (j = 0; j < m_numBalls; j++) {
    			m_balls[j].Render(pDevice, &mViewProj, &vEyePos, m_sparks.GetLight(i), &m_dcvAmbient, 1);
			}
		}
	}

    // Disable ambient audio for any balls not being drawn
    for (i = m_numBalls; i < m_maxBalls; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    for (i = m_maxBalls + m_numLights; i < m_maxBalls + m_maxLights; i++) {
        m_balls[i].DisableAmbientAudio();
    }

    // Clear the texture
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for (i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

    pDevice->SetVertexShader(FVF_CSCENE_BACKGROUND_VERTEX);
    pDevice->SetPixelShader(NULL);
    pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

	// Draw the sphere
	pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i += 8) {

        for (j = 0; j < 8 && j + i < m_maxBalls + m_numLights; j++) {
            memcpy(&light, m_balls[i+j].GetLight(), sizeof(D3DLIGHT8));
            light.Attenuation0 = 0.0f;
            light.Attenuation1 = 0.0f;
            light.Attenuation2 = 2.0f;
            m_pDevice->SetLight(j, &light);
            m_pDevice->LightEnable(j, TRUE);
        }
        for (; j < 8; j++) {
            m_pDevice->LightEnable(j, FALSE);
        }

        m_invertedSphere.Render(pDevice, i - m_maxBalls, m_bDrawWireframe);
    }

	pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	// Draw lights
    for (i = m_maxBalls; i < m_maxBalls + m_numLights; i++) {
        m_balls[i].Render(pDevice, NULL, NULL, NULL, NULL, 0);
    }

	//draw sparks
    pDevice->SetVertexShader(m_dwVShader2);
	m_sparks.Render(pDevice, &mViewProj);

	// Init matrices
	pDevice->SetTransform(D3DTS_VIEW, &m_identityMatrix);
	pDevice->SetTransform(D3DTS_PROJECTION, &m_identityMatrix);

    WCHAR tempbuffer[256];
    DWORD dwColors[NUM_SELECTIONS];
    for (i=0; i<NUM_SELECTIONS; i++)
    {
        if (g_TestParams.dwDMSelected == i)
            dwColors[i] = 0xFFFFFF00;
        else
            dwColors[i] = 0xFFFFFFFF;
    }

    m_pd3dtText->GetSurfaceLevel(0, &pd3ds);

    //
    // Commit 3D audio
    //

    g_dsound->CommitDeferredSettings();

	//
	// Info that does not get changed
	//
	y = 15;

//	swprintf(buffer, L"FPS: %.2lf (%.2lf)", m_avgFrameRate, m_currentFrameRate);
//	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
//	y += 10;
	swprintf(buffer, L"Seed: %u", g_TestParams.dwSeed);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Sparks: %u", m_sparks.GetNumSparks());
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Layers: %u", m_numLayers);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

	swprintf(buffer, L"Triangles: %u", m_numTris);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 40;

    if (_strcmpi(g_TestParams.szDMHeap, "Tracking") == 0)
    {
        g_music.GetHeapAllocation(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DM Heap (N) = %3.2f MB", float(dwNormal) / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
        y+=10;
        swprintf(buffer, L"DM Heap (P) = %3.2f MB", float(dwPhysical) / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;
/*
        g_music.GetHeapAllocationBlocks(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DMusic Heap Blocks = %d", dwNormal + dwPhysical);
        DRAWTEXT(pd3ds, buffer, 25, 75, 0, 0xffffffff, 0);
*/
    }
    else if (_strcmpi(g_TestParams.szDMHeap, "FixedUser") == 0)
    {
        g_music.GetHeapAllocation(&dwNormal, &dwPhysical);
        swprintf(buffer, L"DM Heap (N) = %3.2f/%3.2f MB", float(dwNormal) / 1024.f / 1024.f, float(g_TestParams.dwDMFixedHeapSizeNorm)  / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;
        swprintf(buffer, L"DM Heap (P) = %3.2f/%3.2f MB", float(dwPhysical) / 1024.f / 1024.f, float(g_TestParams.dwDMFixedHeapSizePhys)  / 1024.f / 1024.f);
        DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	    y+=10;

    }

    swprintf(buffer, L"bDMLoaderThread = %d", g_TestParams.bDMLoaderThread);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"bDMDoWorkLocally = %d", g_TestParams.bDMDoWorkLocally);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 10;

    swprintf(buffer, L"dwFileIOSize = %d", g_TestParams.dwFileIOSize);
    DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0);
	y += 60;

	swprintf(buffer, L"DirectSound Playing: %S", g_TestParams.szBounceSound);
	DRAWTEXT(pd3ds, buffer, 25, y, 0, 0xffffffff, 0); 
	y += 10;


	//
	// Info that does get updated
	//
	y = 15;
	swprintf(buffer, L"Balls: %u / %u", g_TestParams.dwNumBalls, m_maxBalls);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[0], 0);
	y += 10;

	swprintf(buffer, L"Lights: %u / %u", g_TestParams.dwNumLights, m_maxLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[1], 0);
	y += 10;

	swprintf(buffer, L"bDrawWireframe=%u", g_TestParams.bDrawWireframe);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[2], 0);
	y += 10;

	swprintf(buffer, L"bRelativeSpeed=%u", g_TestParams.bRelativeSpeed);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[3], 0);
	y += 10;

	swprintf(buffer, L"bSparksAreLights=%u", g_TestParams.bSparksAreLights);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[4], 0);
	y += 10;

	swprintf(buffer, L"dwSparksPerCollision=%u", g_TestParams.dwSparksPerCollision);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[5], 0);
	y += 20;

    g_music.GetSegmentTitleCurrent(tempbuffer);
    swprintf(buffer, L"Playing %s", tempbuffer);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[6], 0);
	y += 10;

    swprintf(buffer, L"Master Volume = %d", g_TestParams.lDMMasterVolume);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[7], 0);
	y += 10;

    swprintf(buffer, L"Master Tempo Factor = %.2f", g_TestParams.fDMMasterTempo);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[8], 0);
	y += 10;

    swprintf(buffer, L"Master Transpose = %d", g_TestParams.lDMMasterTranspose);
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[9], 0);
	y += 10;

    DWORD dwTemp;
    g_music.GetReverb(&dwTemp);
    if (dwTemp != 0xFFFFFFFF)
        swprintf(buffer, L"Reverb Send Level = %d", dwTemp);
    else
        swprintf(buffer, L"Reverb Send Level = Default");
    DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[10], 0);
	y += 20;

	swprintf(buffer, L"DirectSound Volume = %d", g_TestParams.lDSVolume);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[11], 0);
	y += 10;

	swprintf(buffer, L"DirectSound Frequency = %u", g_TestParams.dwDSFreq);
	DRAWTEXT(pd3ds, buffer, 160, y, 0, dwColors[12], 0);
	y += 10;

	// Display the current run time
	currentTime	= m_lastTime - m_startTime;
	hours		= (int)(currentTime / 3600.0);
	currentTime	-= (3600.0 * hours);
	minutes		= (int)(currentTime / 60.0);
	currentTime	-= (60.0 * minutes);
	seconds		= (int)currentTime;
	currentTime	-= (double)seconds;
	fraction	= (int)(currentTime * 100);

	swprintf (buffer,L"Time: %02d:%02d:%02d.%02d ", hours, minutes, seconds, fraction);
	m_font.DrawText(pd3ds, buffer, 25, 215, 0, 0xffffffff, 0);

	// Display the frame rate
	swprintf(buffer, L"FPS: %.2lf", m_avgFrameRate);
    m_font.DrawText(pd3ds, buffer, 240, 215, 0, 0xffffffff, 0);

	pd3ds->Release();

	pDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);

	pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

	pDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_RGBA);
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYCOLOR, 0);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	pDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	pDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
#endif

	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	pDevice->SetTexture(0, m_pd3dtText);

	pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prText, sizeof(TVertex));

	pDevice->SetTexture(0, NULL);
	pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);

#if 0
	pDevice->SetTextureStageState(0, D3DTSS_COLORKEYOP, D3DTCOLORKEYOP_DISABLE);
#else
	pDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	pDevice->SetRenderState(D3DRS_ALPHATESTENABLE, FALSE);
#endif

	pDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);

	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_WRAP);
	m_pDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_WRAP);

	pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    // End the scene
    pDevice->EndScene();

    // Update the screen
    pDevice->Present(NULL, NULL, NULL, NULL);

	// Calculate the frame rate
	QueryPerformanceCounter((LARGE_INTEGER*)&timer);
	currentTime		= (double)timer / m_frequency;
	dt				= currentTime - m_lastTime;
	m_elapsedTime	+= dt;

	// Current frame rate
	m_currentFrameRate = 1.0 / dt;

	// Cycle flag
	bCycle = ((DWORD)((currentTime - m_lastCycle)  * 1000.0) >= g_TestParams.dwCycleTime) ? TRUE : FALSE;

	m_lastTime = currentTime;

	// Frame counter
	++m_frame;

	// Average frame rate calculations
	if(m_elapsedTime > 1.0)
	{
		m_avgFrameRate	= (double)m_frame / m_elapsedTime;
		m_frame			= 0;
		m_elapsedTime	= 0.0;
	}

	// Draw rate
	if(m_bRelativeSpeed)
		m_drawRate = 1.0 / (currentTime - ((double)start / m_frequency));

    if (g_TestParams.bCycleDisplayModes && bCycle) //!(m_frame % 480))
	{
		m_lastCycle = currentTime;
        CycleDisplayMode(); // Reset the display mode
	}
}

//------------------------------------------------------------------------------
//	CScene::CycleDisplayMode
//------------------------------------------------------------------------------
void
CScene::CycleDisplayMode()
{
    D3DPRESENT_PARAMETERS d3dpp;
    float fAspectWidth, fAspectHeight, fFieldOfView;
    HRESULT hr;

    memset(&d3dpp, 0, sizeof(D3DPRESENT_PARAMETERS));
    d3dpp.BackBufferWidth					= m_pd3ddm[m_uDisplayMode].Width;
    d3dpp.BackBufferHeight					= m_pd3ddm[m_uDisplayMode].Height;
    d3dpp.BackBufferFormat					= m_pd3ddm[m_uDisplayMode].Format;
    d3dpp.BackBufferCount					= g_TestParams.dwBackBufferCount;
    d3dpp.Flags								= m_pd3ddm[m_uDisplayMode].Flags;
    d3dpp.MultiSampleType					= g_TestParams.dwMultiSampleType;
    d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow						= NULL;
    d3dpp.Windowed							= FALSE;
    d3dpp.EnableAutoDepthStencil			= TRUE;
    d3dpp.AutoDepthStencilFormat			= D3DFMT_LIN_D24S8;
    d3dpp.FullScreen_RefreshRateInHz		= m_pd3ddm[m_uDisplayMode].RefreshRate;

    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;
    }
    else {
        d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    }

//    m_pDevice->PersistDisplay();

    Log("Resetting the device to mode %d:\n", m_uDisplayMode);
    Log("    %d x %d @ %d Hz\n", m_pd3ddm[m_uDisplayMode].Width, m_pd3ddm[m_uDisplayMode].Height, m_pd3ddm[m_uDisplayMode].RefreshRate);
    switch (m_pd3ddm[m_uDisplayMode].Format) {
        case D3DFMT_LIN_A8R8G8B8:
            Log("    D3DFMT_LIN_A8R8G8B8\n");
            break;
        case D3DFMT_LIN_X8R8G8B8:
            Log("    D3DFMT_LIN_X8R8G8B8\n");
            break;
        case D3DFMT_LIN_R5G6B5:
            Log("    D3DFMT_LIN_R5G6B5\n");
            break;
        case D3DFMT_LIN_X1R5G5B5:
            Log("    D3DFMT_LIN_X1R5G5B5\n");
            break;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        Log("    D3DPRESENTFLAG_WIDESCREEN\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_INTERLACED) {
        Log("    D3DPRESENTFLAG_INTERLACED\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_PROGRESSIVE) {
        Log("    D3DPRESENTFLAG_PROGRESSIVE\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        Log("    D3DPRESENTFLAG_FIELD\n");
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        Log("    D3DPRESENTFLAG_10X11PIXELASPECTRATIO\n");
    }
    Log("\n");

    hr = m_pDevice->Reset(&d3dpp);
    if (FAILED(hr)) {
        __asm int 3;
    }

    fFieldOfView = 45.0f;
    fAspectWidth = (float)(m_pd3ddm[m_uDisplayMode].Width);
    fAspectHeight = (float)(m_pd3ddm[m_uDisplayMode].Height);
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        fAspectHeight *= 2.0f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_10X11PIXELASPECTRATIO) {
        fFieldOfView *= 0.90909f;
        fAspectWidth *= 1.1f;
    }
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_WIDESCREEN) {
        fFieldOfView *= 1.33333f;
    }
    if (m_pd3ddm[m_uDisplayMode].Width == 720) {
        fFieldOfView *= 1.125f;
    }

    // Update the projection matrix, etc. as specified by the display mode flags
	m_camera.SetPerspectiveFov(fFieldOfView, fAspectWidth / fAspectHeight, 0.99f * m_radius, 3.01f * m_radius);

    // Update the text quad
    if (m_pd3ddm[m_uDisplayMode].Flags & D3DPRESENTFLAG_FIELD) {
        m_prText[0].y = 240.0f;
        m_prText[3].y = 240.0f;
    }
    else {
        m_prText[0].y = 480.0f;
        m_prText[3].y = 480.0f;
    }

    if (++m_uDisplayMode >= m_uNumDisplayModes) {
        m_uDisplayMode = 0;
    }
}

//------------------------------------------------------------------------------
//	CScene::IntersectRaySphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRaySphere(
						   IN const XGVECTOR3&	rayU, 
						   IN const XGVECTOR3&	rayV, 
						   IN const XGVECTOR3&	center,
						   IN float				radius,
						   OUT XGVECTOR3&		point
						   )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	uc(center - rayU);
	float		v = XGVec3Dot(&uc, &rayV);
	float		d = (radius * radius) - (XGVec3Dot(&uc, &uc) - (v * v));

	if(d < 0.0f)
		return FALSE;

	d = (float)sqrt(d);
	point = rayU + (rayV * (v - d));
	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::IntersectRayInSphere
//------------------------------------------------------------------------------
BOOL
CScene::IntersectRayInSphere(
						     IN const XGVECTOR3&	rayU, 
						     IN const XGVECTOR3&	rayV, 
						     IN const XGVECTOR3&	center,
						     IN float				radius,
						     OUT XGVECTOR3&			point
						     )
/*++

Routine Description:

	Calculates the intersection of a sphere and a line segment within the sphere

Arguments:

	IN rayU -	Ray origin
	IN rayV -	Ray direction	(must be normalized)
	IN center -	Center of sphere
	IN radius -	Radius of sphere
	OUT point -	Point of intersection

Return Value:

	TRUE if the ray intersects the sphere, FALSE otherwise

--*/
{
	XGVECTOR3	p;
	float		d;

	// Point on line closest to center of sphere
	p	= rayU + (rayV * (-(-XGVec3Dot(&center, &rayV) + XGVec3Dot(&rayU, &rayV)) / 
		  XGVec3Dot(&rayV, &rayV)));

	// Distance from center of sphere to point
	d	= XGVec3Length(&XGVECTOR3(center - p));
	
	// Is the point outside of the sphere?
	if(d > radius)
		return FALSE;

	// Distance from point to point on sphere edge
	d = (float)sqrt((radius * radius) - (d * d));

	// Point on sphere
	point = p + (rayV * d);

	return TRUE;
}

//------------------------------------------------------------------------------
//	CScene::GetSphereIntersection
//------------------------------------------------------------------------------
BOOL
CScene::GetSphereIntersection(
							  IN const XGVECTOR3&	s0,
							  IN float				s0r,
							  IN const XGVECTOR3&	v,
							  IN const XGVECTOR3&	s1,
							  IN float				s1r,
							  OUT float&			t
							  )
/*++

Routine Description:

	Calculates the intersection of two sphere. Sphere 0 is moving in the 
	direction v. Sphere 1 is stationary. For the complete derivation of
	this equation, see robheit

Arguments:

	IN s0 -		Starting location of sphere 0
	IN s0r -	Radius of sphere 0
	IN v -		Direction of travel for sphere 0
	IN s1 -		Location of sphere 1
	IN s1r -	Radius of sphere 1
	OUT t -		Distance along path the sphere touch

Return Value:

	TRUE if the spheres will touch, FALSE otherwise

--*/
{
	float	a;
	float	b;
	float	c;
	float	d;
//	float	t1;

	// Quick dot product check
	if(XGVec3Dot(&v, &XGVECTOR3(s1 - s0)) <= 0.0f)
		return FALSE;

	a = ((v.x * v.x) + (v.y * v.y) + (v.z * v.z));
	b = 2.0f * ((s0.x * v.x) - (s1.x * v.x) + (s0.y * v.y) - 
		        (s1.y * v.y) + (s0.z * v.z) - (s1.z * v.z));
	c = ((s0r + s1r) * (s0r + s1r)) - (s0.x * s0.x) + 
		(2.0f * ((s1.x * s0.x) + (s1.y * s0.y) + (s1.z * s0.z))) - 
		(s1.x * s1.x) - (s0.y * s0.y) - (s1.y * s1.y) - (s0.z * s0.z) - 
		(s1.z * s1.z);

	if(a != 0.0f) {
		d = (b * b) + 4.0f * a * c;
		if(d >= 0.0f) {
			d = (float)sqrt(d);
			t = (-d - b) / (2.0f * a);
			if(t < 0.000001f)
				t = 0.0f;

			// Second solution to quadratic equation
			//t1 = (d - b) / (2.0f * a);
			return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//	CScene::RandomColor
//------------------------------------------------------------------------------
DWORD
CScene::RandomColor(void)
/*++

Routine Description:

	Returns a random color

Arguments:

	None

Return Value:

	A random color 0xaarrggbb

--*/
{
	DWORD	a = (DWORD)(rand() % 0xff);
	DWORD	r = (DWORD)(rand() % 0xff);
	DWORD	g = (DWORD)(rand() % 0xff);
	DWORD	b = (DWORD)(rand() % 0xff);

	return (a << 24) | (r << 16) | (g << 8) | b;
}

//------------------------------------------------------------------------------
//	CScene::BallHitBall
//------------------------------------------------------------------------------
void 
CScene::BallHitBall(
					IN UINT	ball0,
					IN UINT ball1
					)
/*++

Routine Description:

	Called whenever 2 balls touch

Arguments:

	IN ball0 -	First ball (0 - m_numBalls-1)
	IN ball1 -	Second ball (0 - m_numBalls-1)

Return Value:

	None

--*/
{
	//
	// play the audio buffer on one of the balls that was hit
	//
	for(UINT i = 0; i < g_TestParams.dwSparksPerCollision; i++) {
		m_sparks.AddSpark((m_balls[ball0].GetLocation() + m_balls[ball1].GetLocation()) / 2);
	}

    m_balls[ball0].PlayBuffer((MAX2(m_balls[ball0].GetSpeed(), m_balls[ball1].GetSpeed()) - m_currentMinSpeed) / m_dSpeed,
							   ADJUST(XGVec3Dot(&m_balls[ball0].GetDirection(), &m_balls[ball1].GetDirection())));


    //
    // Set up an async file write
    //
    if(g_TestParams.dwFileIOSize != 0)
        {
        FileIOHandle *info = new FileIOHandle;
        OVERLAPPED *overlapped = new OVERLAPPED;
        if(!info || !overlapped)
            {
            delete info;
            delete overlapped;
            return;
            }

        info->buffSize = g_TestParams.dwFileIOSize;
        info->buffer = new char[info->buffSize];
        if(!info->buffer)
            {
            delete info;
            delete overlapped;
            return;
            }

        // open the initial file if necessary
        if(m_hFile == INVALID_HANDLE_VALUE)
            {
            m_hFile = CreateFile("t:\\randomdata.dat", GENERIC_WRITE|GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);
            SetFilePointer(m_hFile, (m_numBalls+1) * 4096, NULL, FILE_BEGIN);
            SetEndOfFile(m_hFile);
            }

        overlapped->Internal = 0;
        overlapped->InternalHigh = 0;
        overlapped->Offset = ball0*info->buffSize + ball1;
        overlapped->OffsetHigh = 0;
        overlapped->hEvent = info;

        for(unsigned i=0; i<info->buffSize; i++)
            {
            info->buffer[i] = (char)i;
            }

        if(WriteFileEx(m_hFile, info->buffer, info->buffSize, overlapped, CompleteIO) == 0)
            {
            // error
            }
        SleepEx(15000, true); // allows the CompleteIO function to be called
        }

}

//------------------------------------------------------------------------------
//	CScene::BallHitWall
//------------------------------------------------------------------------------
void 
CScene::BallHitWall(
					IN UINT				ball,
					IN const XGVECTOR3&	normal
					)
/*++

Routine Description:

	Called whenever a ball hits the wall

Arguments:

	IN ball -	Ball (0 - m_numBalls-1)
	IN normal -	Normal at point on wall that was hit

Return Value:

	None

--*/
{
	//
	// play the audio buffer on the ball that was hit
	//
    m_balls[ball].PlayBuffer((m_balls[ball].GetSpeed() - m_currentMinSpeed) / m_dSpeed,
							 ADJUST(XGVec3Dot(&m_balls[ball].GetDirection(), &normal)));
}

//------------------------------------------------------------------------------
//	CScene::BallSpeedChanged
//------------------------------------------------------------------------------
void 
CScene::BallSpeedChanged(
						 IN UINT	ball,
						 IN float	oldSpeed,
						 IN float	newSpeed
						 )
/*++

Routine Description:

	Called whenever a ball's speed changes

Arguments:

	IN ball -		Ball (0 - m_numBalls-1)
	IN oldSpeed -	Old speed
	IN newSpeed -	New speed

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::BallDirectionChanged
//------------------------------------------------------------------------------
void 
CScene::BallDirectionChanged(
							 IN UINT				ball,
							 IN const XGVECTOR3&	oldDirection,
							 IN const XGVECTOR3&	newDirection
							 )
/*++

Routine Description:

	Called whenever a ball's direction changes

Arguments:

	IN ball -			Ball (0 - m_numBalls-1)
	IN oldDirection -	Old direction
	IN newDirection -	New direction

Return Value:

	None

--*/
{
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddBall(void)
/*++

Routine Description:

	Adds a ball to the scene (up to m_maxBalls)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numBalls < m_maxBalls)
	{
		// Find a good place to insert the ball
		// (Make sure the new ball is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_numBalls].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_numBalls].SetPosition(loc);
		m_balls[m_numBalls].SetDirection(dir);
		m_balls[m_numBalls].SetSpeed(speed);

		m_numTris += m_balls[m_numBalls].GetNumTris();

		// Increase the number of balls
		++m_numBalls;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveBall
//------------------------------------------------------------------------------
void
CScene::RemoveBall(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numBalls > 0)
	{
		--m_numBalls;
		m_numTris -= m_balls[m_numBalls].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::AddBall
//------------------------------------------------------------------------------
void
CScene::AddLight(void)
/*++

Routine Description:

	Adds a light to the scene (up to m_maxLights)

Arguments:

	None

Return Value:

	None

--*/
{
	BOOL		goodLoc;
	XGVECTOR3	loc;
	XGVECTOR3	dir;
	float		speed;
	UINT		i;

	// Don't add past the end of the array
	if(m_numLights < m_maxLights)
	{
		// Find a good place to insert the light
		// (Make sure the new light is not within 1 unit of another)
		do 
		{
			goodLoc = TRUE;
			loc.x = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.y = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			loc.z = (1.0f - (2.0f * (float)rand() / (float)RAND_MAX)) * (m_radius / 2.0f);
			for(i=0; goodLoc && i<m_numBalls; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
			for(i=m_maxBalls; goodLoc && i<m_maxBalls + m_numLights; ++i) 
			{
				if(XGVec3Length(&XGVECTOR3(loc - m_balls[i].GetLocation())) <= m_balls[m_maxBalls + m_numLights].GetRadius() + m_balls[i].GetRadius())
					goodLoc = FALSE;
			}
		}
		while(!goodLoc);

		dir.x = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.y = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		dir.z = 1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
		XGVec3Normalize(&dir, &dir);
		speed = (float)rand() / (float)RAND_MAX * (m_maxSpeed - m_minSpeed) + m_minSpeed;

		
		// Set the new balls information
		m_balls[m_maxBalls + m_numLights].SetPosition(loc);
		m_balls[m_maxBalls + m_numLights].SetDirection(dir);
		m_balls[m_maxBalls + m_numLights].SetSpeed(speed);

		m_numTris += m_balls[m_maxBalls + m_numLights].GetNumTris();

		// Increase the number of balls
		++m_numLights;

		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::RemoveLight
//------------------------------------------------------------------------------
void
CScene::RemoveLight(void)
/*++

Routine Description:

	Removes a ball from the scene

Arguments:

	None

Return Value:

	None

--*/
{
	if(m_numLights > 0)
	{
		--m_numLights;
		m_numTris -= m_balls[m_maxBalls + m_numLights].GetNumTris();
		RecalculateSpeeds();
	}
}

//------------------------------------------------------------------------------
//	CScene::CollideBalls
//------------------------------------------------------------------------------
void 
CScene::CollideBalls(
					 IN const XGVECTOR3&	locA,
					 IN OUT XGVECTOR3&		dirA, 
					 IN OUT float&			speedA, 
					 IN float				massA,
					 IN const XGVECTOR3&	locB,
					 IN OUT XGVECTOR3&		dirB, 
					 IN OUT float&			speedB,
					 IN float				massB
					 )
/*++

Routine Description:

	Collides two balls and adjusts their velocities

Arguments:

	IN locA -		Location of ball A
	IN OUT dirA -	Direction of Ball A
	IN OUT speedA -	Speed of Ball A
	IN massA -		Mass of Ball A
	IN locB -		Location of ball B
	IN OUT dirB -	Direction of Ball B
	IN OUT speedB -	Speed of Ball B
	IN massB -		Mass of Ball B
	
Return Value:

	None

--*/
{
	XGVECTOR3	AB;
	XGVECTOR3	BA;
	float		dot;
	XGVECTOR3	momentumAB;	// Momentum of A in the direction of B
	XGVECTOR3	momentumBA;	// Momentum of B in the direction of A
	float		totalMomentum = (speedA * massA) + (speedB * massB);
	float		mass = MIN2(massA, massB);

	// Vector of interection
	AB = locB - locA;
	XGVec3Normalize(&AB, &AB);
	BA = -AB;

	// Momentum of A in the direction of B
	dot = XGVec3Dot(&AB, &dirA);
	if(dot > 0.0f)
		momentumAB = AB * speedA * mass * dot;
	else
	{
		momentumAB.x = 0.0f;
		momentumAB.y = 0.0f;
		momentumAB.z = 0.0f;
	}

	// Momentum of B in the direction of A
	dot = XGVec3Dot(&BA, &dirB);
	if(dot > 0.0f)
		momentumBA = BA * speedB * mass * dot;
	else
	{
		momentumBA.x = 0.0f;
		momentumBA.y = 0.0f;
		momentumBA.z = 0.0f;
	}

	// Calculate the momentum of each ball
	dirA = (dirA * speedA * massA) - momentumAB + momentumBA;
	dirB = (dirB * speedB * massB) - momentumBA + momentumAB;

	// Calculate the speed (magnitude of the momentum vector)
	speedA = XGVec3Length(&dirA);
	speedB = XGVec3Length(&dirB);

	// Floating point error remover
	// At this point the following should be true: momentumA + momentumB == totalMomentum
	// but do to floating point error probably will not be
	speedA	= (speedA / (speedA + speedB)) * totalMomentum;
	speedB	= (totalMomentum - speedA) / massB;
	speedA	/= massA;

	// Normalize the direction vectors
	XGVec3Normalize(&dirA, &dirA);
	XGVec3Normalize(&dirB, &dirB);
}

//******************************************************************************
HRESULT CScene::CreateShaders(IDirect3DDevice8* pDevice) {

    LPXGBUFFER          pxgbufShader;
    HANDLE              hFile;
    DWORD               dwRead;
    D3DPIXELSHADERDEF   d3dpsd;
    DWORD               dwSize;
    LPBYTE              pData;
    HRESULT             hr;

    DWORD dwSDecl[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT2),
            D3DVSD_REG(2, D3DVSDT_FLOAT3),
            D3DVSD_REG(3, D3DVSDT_FLOAT3),
            D3DVSD_REG(4, D3DVSDT_FLOAT3),
            D3DVSD_END()
    };
    DWORD dwSDecl2[] = {
            D3DVSD_STREAM(0),
            D3DVSD_REG(0, D3DVSDT_FLOAT3),
            D3DVSD_REG(1, D3DVSDT_FLOAT1),
            D3DVSD_END()
    };

    hFile = CreateFile(g_TestParams.szLightVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader, 0);
//	m_dwVShaderAddress = pDevice->GetVertexShaderSize(&dwVShader);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }


    hFile = CreateFile(g_TestParams.szSparkVSH, GENERIC_READ, FILE_SHARE_READ, NULL, 
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return E_FAIL;
    }

    // Get the size of the file
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0xFFFFFFFF) {
        return E_FAIL;
    }

    // Allocate a buffer for the file data
    pData = (LPBYTE)HeapAlloc(GetProcessHeap(), 0, dwSize);
    if (!pData) {
        CloseHandle(hFile);
        return E_FAIL;
    }                

    // Read the file into the buffer
    if (!ReadFile(hFile, pData, dwSize, &dwRead, NULL)
        || dwSize != dwRead)
    {
        HeapFree(GetProcessHeap(), 0, pData);
        CloseHandle(hFile);
        return E_FAIL;
    }

    // Close the file
    CloseHandle(hFile);

    hr = AssembleShader("", pData, dwSize, 0, NULL, 
                        &pxgbufShader, NULL, NULL, NULL, NULL, NULL);
    if (FAILED(hr)) {
        HeapFree(GetProcessHeap(), 0, pData);
        return hr;
    }

    hr = pDevice->CreateVertexShader(dwSDecl2, (LPDWORD)pxgbufShader->GetBufferPointer(), &m_dwVShader2, 0);
//	m_dwVShaderAddress2 = m_dwVShaderAddress + pDevice->GetVertexShaderSize(&dwVShader2);

    pxgbufShader->Release();
    HeapFree(GetProcessHeap(), 0, pData);

    if (FAILED(hr)) {
        return E_FAIL;
    }

//	pDevice->LoadVertexShader(m_dwVShader, m_dwVShaderAddress);
//	pDevice->LoadVertexShader(m_dwVShader2, m_dwVShaderAddress2);


    // Complete light with specular power of 16
    memset(&d3dpsd, 0, sizeof(D3DPIXELSHADERDEF));
    d3dpsd.PSCombinerCount = PS_COMBINERCOUNT(4, PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    d3dpsd.PSTextureModes = PS_TEXTUREMODES(PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_PROJECT2D, 
                                            PS_TEXTUREMODES_CUBEMAP, 
                                            PS_TEXTUREMODES_CUBEMAP);

    d3dpsd.PSRGBInputs[0] = PS_COMBINERINPUTS(
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T2 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB,
                                PS_REGISTER_T3 | PS_INPUTMAPPING_EXPAND_NORMAL | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[0] = PS_COMBINEROUTPUTS(PS_REGISTER_R0, PS_REGISTER_R1, PS_REGISTER_DISCARD,
                                PS_COMBINEROUTPUT_AB_DOT_PRODUCT | PS_COMBINEROUTPUT_CD_DOT_PRODUCT |
                                PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA);

    d3dpsd.PSRGBInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_T1, PS_REGISTER_T2, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSAlphaInputs[1] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[1] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_V0 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T1 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[2] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[2] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSRGBInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_C0 | PS_CHANNEL_RGB,
                                PS_REGISTER_T0 | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSRGBOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, PS_REGISTER_R0, 0);

    d3dpsd.PSAlphaInputs[3] = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA,
                                PS_REGISTER_ZERO | PS_CHANNEL_ALPHA);

    d3dpsd.PSAlphaOutputs[3] = PS_COMBINEROUTPUTS(PS_REGISTER_R1, PS_REGISTER_DISCARD, PS_REGISTER_DISCARD, 0);

    d3dpsd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS(
                                PS_REGISTER_T2 | PS_CHANNEL_RGB, 
                                PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                PS_REGISTER_ZERO | PS_CHANNEL_RGB,
                                PS_REGISTER_R0 | PS_CHANNEL_RGB);

    d3dpsd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS(
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_R1 | PS_CHANNEL_ALPHA,
                                PS_REGISTER_T0 | PS_CHANNEL_ALPHA,
                                0);

    hr = pDevice->CreatePixelShader(&d3dpsd, &m_dwPShader);
    if (FAILED(hr)) {
        return hr;
    }

    return TRUE;
}

//******************************************************************************
void CScene::ReleaseShaders() {

    if (m_dwVShader) {
        m_pDevice->DeleteVertexShader(m_dwVShader);
    }
    if (m_dwPShader) {
        m_pDevice->DeletePixelShader(m_dwPShader);
    }
}

//******************************************************************************
//
// Function:
//
//     CreateNormalMap
//
// Description:
//
//     Create a cube map and populate it with normal vector information.
//
// Arguments:
//
//     IDirect3DDevice8* pDevice       - Pointer to the device object
//
//     UINT uLength                    - Dimensions of the map
//
//     float fBumpDelta                - Maximum component offset to randomly 
//                                       perturb the surface normals
//
//     D3DFORMAT fmt                   - Format of the texture
//
//     BOOL bMipmap                    - Indicates whether or not to
//                                       use a mip map
//
//     D3DPOOL pool                    - Memory pool in which to create the map
//
// Return Value:
//
//     A pointer to the created diffuse map on success, NULL on failure.
//
//******************************************************************************
HRESULT CScene::CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc)
{
    IDirect3DCubeTexture8* pd3dtc;
    Swizzler        swz(uLength, uLength, 1);
    D3DLOCKED_RECT  d3dlr;
    LPDWORD         pdwPixel;
    XGVECTOR3       vDir;
    float           fU, fV;
    UINT            i, j, u, v;
    HRESULT         hr;

    if (!ppd3dtc) {
        return E_FAIL;
    }

    *ppd3dtc = NULL;

    hr = pDevice->CreateCubeTexture(uLength, uLevels, 0, D3DFMT_X8R8G8B8, 0, &pd3dtc);
    if (FAILED(hr)) {
        return hr;
    }

    uLevels = pd3dtc->GetLevelCount();

    // Generate the normals
    for (i = 0; i < uLevels; i++) {

        for (j = 0; j < 6; j++) {

            pd3dtc->LockRect((D3DCUBEMAP_FACES)j, i, &d3dlr, NULL, 0);

            pdwPixel = (LPDWORD)d3dlr.pBits;

            if (uLevels > 1) {
                uLength = 0x1 << ((uLevels - 1) - i);
            }

            Swizzler swz(uLength, uLength, 1);
            swz.SetU(0);
            swz.SetV(0);

            for (v = 0; v < uLength; v++) {

                for (u = 0; u < uLength; u++) {

                    if (uLength > 1) {
                        fU = (float)u / (float)(uLength - 1);
                        fV = (float)v / (float)(uLength - 1);
                    }
                    else {
                        fU = 0.5f;
                        fV = 0.5f;
                    }

                    switch ((D3DCUBEMAP_FACES)j) {
                        case D3DCUBEMAP_FACE_POSITIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f, 1.0f - (fV * 2.0f), 1.0f - (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_X:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f, 1.0f - (fV * 2.0f), -1.0f + (fU * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f, -1.0f + (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Y:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), -1.0f, 1.0f - (fV * 2.0f)));
                            break;
                        case D3DCUBEMAP_FACE_POSITIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(-1.0f + (fU * 2.0f), 1.0f - (fV * 2.0f), 1.0f));
                            break;
                        case D3DCUBEMAP_FACE_NEGATIVE_Z:
                            XGVec3Normalize(&vDir, &XGVECTOR3(1.0f - (fU * 2.0f), 1.0f - (fV * 2.0f), -1.0f));
                            break;
                    }
                    vDir = -vDir;
				    XGVec3Normalize(&vDir, &vDir);

                    pdwPixel[swz.Get2D()] = VectorToColor(&vDir);

                    swz.IncU();
                }

                swz.IncV();
            }

            pd3dtc->UnlockRect((D3DCUBEMAP_FACES)j, i);
        }
    }

    *ppd3dtc = pd3dtc;

    return D3D_OK;
}

//------------------------------------------------------------------------------
//	CScene::RecalculateSpeeds
//------------------------------------------------------------------------------
void
CScene::RecalculateSpeeds(void)
{
	UINT i;

	m_currentMinSpeed	= 1.0e30f;
	m_currentMaxSpeed	= -1.0e30f;
	for(i=0; i<m_numBalls; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	for(i=m_maxBalls; i<m_maxBalls+m_numLights; ++i)
	{
		if(m_balls[i].GetSpeed() < m_currentMinSpeed)
			m_currentMinSpeed = m_balls[i].GetSpeed();
		if(m_balls[i].GetSpeed() > m_currentMaxSpeed)
			m_currentMaxSpeed = m_balls[i].GetSpeed();
	}
	m_dSpeed = m_currentMaxSpeed - m_currentMinSpeed;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\scene.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	scene.h

Abstract:

	3D scene

Author:

	Robert Heitkamp (robheit) 27-Apr-2001

Environment:

	Xbox only

Revision History:

	27-Apr-2001 robheit
		Initial Version

--*/
#ifndef __SCENE_H__
#define __SCENE_H__

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"
#include "Camera.h"
#include "Ball.h"
#include "InvertedBall.h"
#include "bitfont.h"
#include "spark.h"

namespace WFVO {

//------------------------------------------------------------------------------
//	Vertex for background triangles
//------------------------------------------------------------------------------
#define FVF_CSCENE_BACKGROUND_VERTEX (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)

//------------------------------------------------------------------------------
//	Number of selectable items in UI
//------------------------------------------------------------------------------
#define NUM_SELECTIONS 13

//------------------------------------------------------------------------------
//	CScene:
//------------------------------------------------------------------------------
class CScene {

public:

	struct Vertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
		DWORD color;        // The vertex color
	};

	struct TVertex
	{
		FLOAT x, y, z, rhw; // The transformed position for the vertex
        float u, v;         // Texture coordinates
	};

	enum Hit
	{
		HIT_NOTHING,
		HIT_WALL,
		HIT_BALL
	};

public:

	CScene(void);
    ~CScene(void);

    HRESULT Initialize(IDirect3DDevice8* pDevice);
	void Render(IDirect3DDevice8* pDevice);
	void NextFrame(void);

	void AddBall(void);
	void RemoveBall(void);

	void AddLight(void);
	void RemoveLight(void);

	BOOL DrawText( void ) { return m_bDrawText; }
	void SetDrawText( BOOL bDrawText ) { m_bDrawText = bDrawText; }

private:

	BOOL IntersectRaySphere(const XGVECTOR3&, const XGVECTOR3&, 
							const XGVECTOR3&, float, XGVECTOR3&);
	BOOL IntersectRayInSphere(const XGVECTOR3&, const XGVECTOR3&, 
							  const XGVECTOR3&, float, XGVECTOR3&);
	BOOL GetSphereIntersection(const XGVECTOR3&, float, const XGVECTOR3&,
							   const XGVECTOR3&, float, float&);
	DWORD RandomColor(void);
	void CollideBalls(const XGVECTOR3&, XGVECTOR3&, float&, float,
					  const XGVECTOR3&, XGVECTOR3&, float&, float);

	void BallHitBall(UINT, UINT);
	void BallHitWall(UINT, const XGVECTOR3&);
	void BallSpeedChanged(UINT, float, float);
	void BallDirectionChanged(UINT, const XGVECTOR3&, const XGVECTOR3&);

    HRESULT CreateShaders(IDirect3DDevice8*);
    void ReleaseShaders();
    HRESULT CreateNormalMap(IDirect3DDevice8* pDevice, UINT uLength, UINT uLevels, IDirect3DCubeTexture8** ppd3dtc);
	void RecalculateSpeeds(void);
	
    void CycleDisplayMode(void);

public:
	CCamera				m_camera;

private:
    HANDLE              m_hFile;
	UINT				m_numBalls;
	UINT				m_maxBalls;
    UINT                m_numLights;
    UINT                m_maxLights;
	CBall*				m_balls;
	XGMATRIX			m_identityMatrix;
	float				m_radius;
	float				m_radius2;
	CInvertedBall		m_invertedSphere;
	UINT				m_numLayers;
	Vertex*				m_backgroundTriangles;
	IDirect3DSurface8*	m_backBuffer;
	BitFont				m_font;
	double				m_elapsedTime;
	double				m_lastTime;
	double				m_avgFrameRate;
	double				m_currentFrameRate;
	double				m_frequency;
	double				m_startTime;
	double				m_lastCycle;
	UINT				m_frame;
	int					m_ballDetail;
    int                 m_lightDetail;
	int					m_wallDetail;
	float				m_maxSpeed;
	float				m_minSpeed;
	double				m_drawRate;
	UINT				m_numTris;
    DWORD               m_dwVShader;
    DWORD               m_dwVShader2;
    DWORD               m_dwVShaderAddress;
    DWORD               m_dwVShaderAddress2;
    DWORD               m_dwPShader;
    IDirect3DCubeTexture8* m_pd3dtcNormal;
    D3DCOLORVALUE       m_dcvAmbient;
    IDirect3DDevice8*   m_pDevice;
	BOOL				m_bDrawWireframe;
	BOOL				m_bRelativeSpeed;
	BOOL				m_bDrawText;
	CSpark				m_sparks;
    IDirect3DTexture8*  m_pd3dtText;
    TVertex            m_prText[4];
	float				m_dSpeed;
	float				m_currentMaxSpeed;
	float				m_currentMinSpeed;
    D3DDISPLAYMODE*     m_pd3ddm;
    UINT                m_uNumDisplayModes;
    UINT                m_uDisplayMode;

    //
    // audio debug variables
    //

    DWORD               m_dwAudioReadPtr;
    DWORD               m_dwAudioWritePtr;
    DWORD               m_dwAudioReadTotal;
    DWORD               m_dwAudioWriteTotal;

    DWORD               m_dwAudioDelta;

};


//------------------------------------------------------------------------------
//	File IO event handler
//------------------------------------------------------------------------------
struct FileIOHandle
    {
    DWORD buffSize;
    char *buffer;
    };
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\spark.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

Ball.cpp

Abstract:

spark (from ball collisions

Author:

Jason Gould (jgould) 18-May-2001

Revision History:

18-May-2001 jgould
	Initial Version

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <stdlib.h>
#include <xtl.h>
#include <xdbg.h>
#include <xgraphics.h>
#include "spark.h"
#include "helpers.h"

using namespace WFVO;

namespace WFVO {

//D3DFVF_XYZRHW
#ifndef PI 
#	define PI 3.14159265359f
#endif
#define M_PI PI
#define M_2PI 6.28318530718f
#define SAFE_RELEASE(x) do { if (x != NULL) { x->Release(); x = NULL; } } while(0)
#define FRAND(Min, Max) ((float)rand() / (float)RAND_MAX * (Max - Min) + Min)
#define FABS(x)     ((x) < 0.0f ? -(x) : (x))

D3DVertexBuffer* CSpark::m_pVB = NULL;

HRESULT CSpark::Create (IN D3DDevice* pDevice) {
	m_Next = 0;
	m_First = 0;
	HRESULT hr;

	if(m_pVB == NULL) {
		hr = pDevice->CreateVertexBuffer(g_TestParams.dwMaxSparks * 4*sizeof(float), 0, 0, D3DPOOL_DEFAULT, &m_pVB);
	}
	if(!FAILED(hr)) {
		//This gets us our pointer for adding new sparks. Note: nothing keeps track of what is locked...
		hr = m_pVB->Lock(0,0,(BYTE**)&m_pVertex,D3DLOCK_NOOVERWRITE); 
	}
	if(!FAILED(hr)) {
		m_pDirection = new XGVECTOR3[g_TestParams.dwMaxSparks];
		m_pSpeed = new float[g_TestParams.dwMaxSparks];
		if(!m_pDirection || !m_pSpeed) hr = E_OUTOFMEMORY;
	}
	if(FAILED(hr)) {
		Release();
	}

	return hr;
}

void CSpark::Release() {
	SAFE_RELEASE(m_pVB);
	delete[] m_pDirection;
	delete[] m_pSpeed;
}

void CSpark::AddSpark(XGVECTOR3& loc) {
	if(m_Next + 1 == m_First || m_Next + 1 - g_TestParams.dwMaxSparks == m_First) {
		return;
	}
	

	m_pVertex[m_Next].age = 0;
	m_pVertex[m_Next].location = loc;
	m_pDirection[m_Next].x = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].y = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	m_pDirection[m_Next].z = FRAND(-1.0f, 1.0f);//1.0f - (2.0f * (float)rand() / (float)RAND_MAX);
	XGVec3Normalize(&m_pDirection[m_Next], &m_pDirection[m_Next]);
	m_pSpeed[m_Next] = FRAND(.001f, .01f);//g_TestParams.fMinSpeed, g_TestParams.fMaxSpeed);
	//(float)rand() / (float)RAND_MAX * (g_TestParams.fMaxSpeed - g_TestParams.fMinSpeed) + g_TestParams.fMinSpeed;
	m_Next = (m_Next + 1) % g_TestParams.dwMaxSparks;
}

//all sparks live the same length of time, so the first one created is the first one dead. 
//Just incriment "first", to point to the next living spark.
void CSpark::RemoveSpark() {
	m_First = (m_First + 1) % g_TestParams.dwMaxSparks;
}

void CSpark::Update(IN float amount) {
	UINT i;
	amount *= 200; //sparks will live about half a second, with maxage==100
	for(i = m_First; i != m_Next; i = (i + 1) % g_TestParams.dwMaxSparks) {
		m_pVertex[i].age += amount;
		if(m_pVertex[i].age > g_TestParams.dwSparkMaxAge) {
			RemoveSpark();
			continue;
		} 

		//no collision detection... they don't live that long anyway...
		m_pVertex[i].location += m_pDirection[i] * m_pSpeed[i] * amount;
	}
}

void CSpark::Render(
	D3DDevice* pDevice,
	XGMATRIX*  pmViewProj
	) 
{
	if(m_First == m_Next) {
		return;
	}
	XGMATRIX id;
   	pDevice->SetTransform(D3DTS_WORLD, XGMatrixIdentity(&id));
	XGMATRIX mtViewProj;
    XGMatrixTranspose(&mtViewProj, pmViewProj);

    pDevice->SetVertexShaderConstant(0, &mtViewProj, 4);

//    pDevice->SetVertexShader(D3DFVF_XYZ);


    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_MODULATE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
    pDevice->SetRenderState(D3DRS_TEXTUREFACTOR, rand()+ (rand() << 16));

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_LINEAR);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_NONE);

	float m_radius = 0.04f;
    pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW(m_radius * 2.0f));

//        pDevice->SetTexture(3, m_pd3dtLight);
	
	pDevice->SetStreamSource(0,m_pVB, sizeof(Vertex));

	if(m_First < m_Next) {
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, m_Next-m_First);
	} else {
		if(m_Next) pDevice->DrawPrimitive(D3DPT_POINTLIST, 0, m_Next);
		pDevice->DrawPrimitive(D3DPT_POINTLIST, m_First, g_TestParams.dwMaxSparks - m_First);
	}
//        pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 1, &vOrigin, sizeof(XGVECTOR3)+sizeof(float));

    pDevice->SetTextureStageState(3, D3DTSS_MINFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MAGFILTER, D3DTEXF_POINT);
    pDevice->SetTextureStageState(3, D3DTSS_MIPFILTER, D3DTEXF_POINT);

    pDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
    pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
    pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

    pDevice->SetTextureStageState(3, D3DTSS_COLORARG1, D3DTA_TEXTURE);
    pDevice->SetTextureStageState(3, D3DTSS_COLOROP, D3DTOP_DISABLE);
    pDevice->SetTextureStageState(3, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

}

int CSpark::GetNumSparks()
{
	int i = m_First>m_Next ? m_Next-m_First +g_TestParams.dwMaxSparks: m_Next-m_First;
	return i;
}


D3DLIGHT8* CSpark::GetLight(int iSpark)
{
	if(m_LastLight == iSpark) {
		return &m_light;
	}
	
	m_LastLight = iSpark;
	int index = (iSpark + m_First) % g_TestParams.dwMaxSparks;

	XGVECTOR3 vColor, vSpecular, vOrange (1.0f, 0.25f, 0.0f);

    XGVec3Normalize(&vColor, &(FRAND(0.6f, 1.0f) * vOrange));
    XGVec3Normalize(&vSpecular, &XGVECTOR3(vColor.x + 0.2f, vColor.y + 0.2f, vColor.z + 0.2f));

    memset(&m_light, 0, sizeof(D3DLIGHT8));
    m_light.Type = D3DLIGHT_POINT;
    m_light.Diffuse.r = vColor.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.g = vColor.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.b = vColor.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Diffuse.a = 1.0f;//FRND(1.0f);
    m_light.Specular.r = vSpecular.x * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.g = vSpecular.y * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.b = vSpecular.z * (1 - (m_pVertex[index].age / g_TestParams.dwSparkMaxAge));
    m_light.Specular.a = 1.0f;
    m_light.Range = 100.0f;
//    m_light.Attenuation0 = 1.0f;
//    m_light.Attenuation1 = 1.0f;
//    m_light.Attenuation2 = 2.0f;
    m_light.Attenuation0 = 0.0f;
    m_light.Attenuation1 = 0.0f;
    m_light.Attenuation2 = 6.4f + (float)rand() / (float)RAND_MAX * 3.2f;

    m_light.Position = m_pVertex[index].location;
	
	return &m_light;

}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\spark.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Spark.cpp

Abstract:

	sparks

Author:

	Jason Gould (jgould) 19-May-2001

Revision History:

	19-May-2001	jgould
		Initial Version

--*/

#ifndef __SPARK_H__
#define __SPARK_H__

//------------------------------------------------------------------------------
//	Includes
//------------------------------------------------------------------------------
#include "xtl.h"
#include "xgmath.h"

namespace WFVO {

class CSpark
{
public:
	struct Vertex {
		XGVECTOR3 location;
		float age;
	};


private:
	Vertex* m_pVertex;
	XGVECTOR3 *m_pDirection;
	float *m_pSpeed;

	static D3DVertexBuffer* m_pVB;
	UINT m_Next;
	UINT m_First;
	void RemoveSpark();
    D3DLIGHT8               m_light; //use GetLight to set this up
	UINT m_LastLight;

public:
	CSpark() {}
	~CSpark() { Release(); }

	HRESULT Create (IN D3DDevice* pDevice);
	void Release();
	void AddSpark(XGVECTOR3& loc);
	void Update(IN float amount);
	void Render(D3DDevice* pDevice, XGMATRIX* pmViewProj);
	int GetNumSparks();
    D3DLIGHT8* GetLight(int iSpark);
};
}


#endif //__SPARK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\MusicHeapTrack.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	MusicHeapTrack.cpp

Abstract:

	User-defined DirectMusic heap object 

Author:

	Dan Haffner(danhaff) 05-Jul-2001

Environment:

	Xbox only

Revision History:

	05-Jul-2001 danhaff
		Initial Version; copied out of dmusic/debug.cpp and modified.

--*/

//------------------------------------------------------------------------------
//	Includes:
//------------------------------------------------------------------------------
#include <xtl.h>
#include "macros.h"
#include "MusicHeap.h"
#include "assert.h"

using namespace WFVO;


namespace WFVO
{


//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
class CMusicHeapTrack : public IMusicHeap
{

   //LOCALALLOC_NEWDELETE What the heck is this?
public:

    CMusicHeapTrack(void);
    ~CMusicHeapTrack(void);
    HRESULT Initialize(bool bIsPhysicalHeap);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    /*  IDirectMusicHeap */
    STDMETHOD(Allocate) (DWORD dwSize, PVOID* ppData);
    STDMETHOD(GetSize) (THIS_ PVOID pData, LPDWORD pcbSize);
    STDMETHOD(Free)(void *pv);

    // IMusicHeap
    STDMETHOD(GetHeapAllocation          )(DWORD *pdwHeapAllocation);
    STDMETHOD(GetHeapAllocationPeak      )(DWORD *pdwHeapAllocationPeak);
    STDMETHOD(GetHeapAllocationBlocks    )(DWORD *pdwHeapAllocationBlocks);
    STDMETHOD(GetHeapAllocationBlocksPeak)(DWORD *pdwHeapAllocationBlocksPeak);

private:
    void* Alloc(size_t cb);

    CRITICAL_SECTION m_csHeap;
    DWORD m_dwHeapAllocation;
    DWORD m_dwHeapAllocationPeak;
    DWORD m_dwHeapAllocationBlocks;
    DWORD m_dwHeapAllocationBlocksPeak;
    bool m_bPhysicalHeap;
//    char m_sNameBuffer[100];
    LONG m_cRef;
};


CMusicHeapTrack::CMusicHeapTrack(void)
{
    InitializeCriticalSection(&m_csHeap);
    m_cRef = 1;
    m_bPhysicalHeap = false;
    m_dwHeapAllocation = 0;
    m_dwHeapAllocationPeak = 0;
    m_dwHeapAllocationBlocks = 0;
    m_dwHeapAllocationBlocksPeak = 0;
}

CMusicHeapTrack::~CMusicHeapTrack(void)
{
    DeleteCriticalSection(&m_csHeap);
}

HRESULT CMusicHeapTrack::Initialize(bool bIsPhysicalHeap)
{
    m_bPhysicalHeap = bIsPhysicalHeap;
    return S_OK;
}

ULONG STDMETHODCALLTYPE CMusicHeapTrack::AddRef( void)         
{
return InterlockedIncrement(&m_cRef);
}



ULONG STDMETHODCALLTYPE CMusicHeapTrack::Release(void) 
{
    ULONG cRef;            
    cRef = InterlockedDecrement(&m_cRef);
    if (cRef == 0)
        delete this;
    return cRef;
}

STDMETHODIMP CMusicHeapTrack::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
return E_NOTIMPL;
}



STDMETHODIMP CMusicHeapTrack::Allocate(DWORD dwSize, PVOID* ppData)
{
    PVOID pData = Alloc(dwSize);
    if(!pData){
        return E_OUTOFMEMORY;
    }
    *ppData = pData;
    return S_OK;
}



void* CMusicHeapTrack::Alloc(size_t cb)
{
    DWORD* pBlock = 0;
    
    
    if (!m_bPhysicalHeap)
        pBlock = (DWORD *)LocalAlloc(LMEM_FIXED, cb + sizeof(DWORD));
    else
        pBlock = (DWORD *)XPhysicalAlloc(cb + sizeof(DWORD), MAXULONG_PTR, 0, PAGE_READWRITE);

    if(!pBlock){
        return NULL;
    }
    EnterCriticalSection(&m_csHeap);
    m_dwHeapAllocation += (cb + sizeof(DWORD));
    if(m_dwHeapAllocation > m_dwHeapAllocationPeak){
        m_dwHeapAllocationPeak = m_dwHeapAllocation;
    }
    ++m_dwHeapAllocationBlocks;
    if(m_dwHeapAllocationBlocks > m_dwHeapAllocationBlocksPeak){
        m_dwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocks;
    }

    LeaveCriticalSection(&m_csHeap);

    *pBlock = cb;
    return pBlock + 1;
}

STDMETHODIMP CMusicHeapTrack::GetSize(PVOID pData, LPDWORD pcbSize)
{
    assert(pData);
    DWORD* pBlock = ((DWORD*) pData) - 1;
    *pcbSize = *pBlock;

    return S_OK;
}

STDMETHODIMP CMusicHeapTrack::Free(void *pv)
{
    assert(pv);
    DWORD* pBlock = ((DWORD*) pv) - 1;
    DWORD cb = *pBlock;
    EnterCriticalSection(&m_csHeap);
    assert(cb+sizeof(DWORD) < 64 * 1024 * 1024);
    
    //Update our stats
    m_dwHeapAllocation -= (cb + sizeof(DWORD));
    --m_dwHeapAllocationBlocks;

    //Set all block memory to a certain value.
    memset((void *)pBlock, 0xFE, cb+sizeof(DWORD));

    LeaveCriticalSection(&m_csHeap);
    if (m_bPhysicalHeap)
        XPhysicalFree(pBlock);
    else
        LocalFree(pBlock);

    return S_OK;
}

/*
char* CMusicHeapTrack::Name(const char* sBase)
{
    _snprintf(m_sNameBuffer, sizeof(m_sNameBuffer), "DM heap %s %s", m_bPhysicalHeap ? "physical" : "normal" , sBase);
    return m_sNameBuffer;
}
*/




STDMETHODIMP CMusicHeapTrack::GetHeapAllocation          (DWORD *pdwHeapAllocation)
{
    *pdwHeapAllocation = m_dwHeapAllocation;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationPeak      (DWORD *pdwHeapAllocationPeak)
{
    *pdwHeapAllocationPeak = m_dwHeapAllocationPeak;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocks    (DWORD *pdwHeapAllocationBlocks)
{
    *pdwHeapAllocationBlocks = m_dwHeapAllocationBlocks;
    return S_OK;
};

STDMETHODIMP CMusicHeapTrack::GetHeapAllocationBlocksPeak(DWORD *pdwHeapAllocationBlocksPeak)
{
    *pdwHeapAllocationBlocksPeak = m_dwHeapAllocationBlocksPeak;
    return S_OK;
};


HRESULT CreateMusicHeapTrack(IMusicHeap** ppHeap, bool bPhysical)
{
    HRESULT hr = S_OK;
    CMusicHeapTrack* pHeap = new CMusicHeapTrack();
    if(!pHeap)
    {
        hr = E_OUTOFMEMORY;
    }
    if(SUCCEEDED(hr))
    {
        hr = pHeap->Initialize(bPhysical);
        if(SUCCEEDED(hr))
            *ppHeap = pHeap;
        else
            pHeap->Release();
    }
    return hr;
}




}//end "namespace WFVO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\WFVO\texture.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	texture.h

Abstract:

	Texture data for test

Author:

	Robert Heitkamp (robheit) 13-Feb-2001

Revision History:

	13-Feb-2001	robheit
		Initial version

--*/

namespace WFVO {

static BYTE g_texture[] = {

	0x42, 0x4D, 0x36, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 
	0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x27, 0x27, 0x0F, 0x28, 0x28, 0x2C, 0x19, 0x19, 0x11, 
	0x28, 0x28, 0x11, 0x27, 0x28, 0x2E, 0x1E, 0x1B, 0x29, 0x1D, 0x1B, 0x30, 0x29, 0x20, 0x09, 0x27, 
	0x29, 0x34, 0x27, 0x1B, 0x1F, 0x1F, 0x20, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 0x1C, 
	0x2A, 0x27, 0x23, 0x32, 0x2F, 0x23, 0x25, 0x19, 0x1B, 0x26, 0x1C, 0x1C, 0x25, 0x1A, 0x1B, 0x2B, 
	0x27, 0x23, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x39, 0x32, 0x2F, 0x27, 0x34, 
	0x36, 0x2A, 0x24, 0x1F, 0x2B, 0x25, 0x20, 0x29, 0x25, 0x22, 0x35, 0x31, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x34, 0x2F, 0x27, 0x39, 0x37, 0x2E, 0x3B, 
	0x39, 0x30, 0x38, 0x39, 0x2F, 0x36, 0x2C, 0x2F, 0x36, 0x30, 0x2F, 0x38, 0x38, 0x30, 0x3B, 0x39, 
	0x2E, 0x22, 0x35, 0x3E, 0x18, 0x2A, 0x30, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x13, 0x2A, 0x30, 0x46, 0x38, 0x34, 0x59, 0x50, 0x45, 0x24, 0x27, 0x29, 0x11, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x13, 0x26, 0x25, 0x15, 0x28, 0x29, 0x18, 0x2B, 0x31, 0x1E, 0x1D, 0x1B, 0x19, 0x2C, 
	0x33, 0x12, 0x25, 0x23, 0x14, 0x29, 0x2F, 0x3F, 0x3A, 0x34, 0x52, 0x44, 0x3B, 0x5F, 0x53, 0x45, 
	0x11, 0x08, 0x0B, 0x00, 0x00, 0x00, 0x0D, 0x07, 0x08, 0x1F, 0x24, 0x1F, 0x81, 0x70, 0x62, 0x58, 
	0x51, 0x4A, 0x59, 0x51, 0x48, 0x55, 0x4C, 0x43, 0x4E, 0x46, 0x3F, 0x48, 0x42, 0x36, 0x13, 0x28, 
	0x2F, 0x15, 0x28, 0x2A, 0x12, 0x24, 0x22, 0x15, 0x2E, 0x32, 0x19, 0x29, 0x2E, 0x12, 0x25, 0x23, 
	0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x1D, 
	0x20, 0x20, 0x32, 0x26, 0x1A, 0x30, 0x32, 0x28, 0x2B, 0x26, 0x22, 0x28, 0x1D, 0x1C, 0x2A, 0x20, 
	0x1D, 0x30, 0x24, 0x1A, 0x30, 0x32, 0x27, 0x2A, 0x25, 0x22, 0x2A, 0x23, 0x1D, 0x26, 0x1B, 0x1C, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 0x0E, 0x29, 0x29, 0x29, 0x1B, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x13, 0x27, 0x27, 0x2C, 0x19, 0x19, 
	0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x22, 0x20, 0x20, 0x18, 0x25, 0x25, 0x13, 
	0x27, 0x27, 0x13, 0x27, 0x27, 0x16, 0x25, 0x25, 0x25, 0x24, 0x22, 0x37, 0x35, 0x2C, 0x27, 0x16, 
	0x18, 0x31, 0x28, 0x1D, 0x2A, 0x1D, 0x1B, 0x11, 0x27, 0x27, 0x27, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 
	0x33, 0x30, 0x24, 0x23, 0x16, 0x1A, 0x33, 0x37, 0x2B, 0x28, 0x20, 0x1F, 0x32, 0x2E, 0x22, 0x29, 
	0x23, 0x1F, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x23, 0x13, 0x18, 0x30, 0x32, 0x27, 0x29, 0x22, 
	0x1E, 0x31, 0x32, 0x28, 0x29, 0x30, 0x2C, 0x2F, 0x29, 0x1D, 0x3A, 0x30, 0x33, 0x2C, 0x2F, 0x24, 
	0x37, 0x31, 0x2F, 0x3A, 0x32, 0x32, 0x38, 0x30, 0x2A, 0x15, 0x2E, 0x38, 0x14, 0x29, 0x30, 0x1C, 
	0x2B, 0x30, 0x34, 0x37, 0x32, 0x46, 0x38, 0x34, 0x49, 0x40, 0x37, 0x35, 0x37, 0x2E, 0x30, 0x31, 
	0x30, 0x12, 0x27, 0x29, 0x16, 0x29, 0x2B, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 
	0x14, 0x2A, 0x32, 0x2E, 0x2A, 0x23, 0x52, 0x47, 0x46, 0x24, 0x2A, 0x27, 0x11, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x15, 0x28, 0x2A, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x32, 0x3B, 0x13, 0x26, 
	0x26, 0x1F, 0x32, 0x3D, 0x1E, 0x2F, 0x39, 0x19, 0x3F, 0x44, 0x1A, 0x3D, 0x43, 0x1C, 0x38, 0x42, 
	0x04, 0x0D, 0x0C, 0x00, 0x00, 0x00, 0x0C, 0x07, 0x07, 0x3A, 0x2F, 0x2A, 0x82, 0x73, 0x62, 0x62, 
	0x5A, 0x4A, 0x62, 0x5D, 0x59, 0x60, 0x5A, 0x55, 0x5F, 0x57, 0x4C, 0x5C, 0x50, 0x45, 0x0F, 0x25, 
	0x2C, 0x19, 0x2A, 0x2F, 0x1F, 0x3E, 0x49, 0x1E, 0x2F, 0x38, 0x1D, 0x3C, 0x46, 0x1B, 0x30, 0x37, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x15, 0x28, 0x2A, 0x15, 0x28, 
	0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x18, 0x2B, 0x2F, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 
	0x2B, 0x33, 0x2F, 0x2A, 0x23, 0x31, 0x31, 0x27, 0x25, 0x25, 0x26, 0x33, 0x24, 0x18, 0x16, 0x31, 
	0x3A, 0x13, 0x22, 0x22, 0x3D, 0x32, 0x31, 0x31, 0x31, 0x24, 0x3C, 0x32, 0x34, 0x27, 0x20, 0x1E, 
	0x25, 0x1A, 0x1B, 0x33, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x0F, 0x28, 0x28, 0x2B, 0x1A, 0x1A, 0x29, 0x1B, 0x1B, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2C, 0x19, 0x19, 0x0E, 0x29, 0x29, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x13, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x18, 0x24, 0x25, 0x1C, 0x1E, 0x1E, 0x23, 0x28, 
	0x30, 0x33, 0x27, 0x1A, 0x2C, 0x26, 0x1E, 0x2C, 0x25, 0x20, 0x31, 0x34, 0x28, 0x27, 0x1E, 0x1E, 
	0x2A, 0x25, 0x20, 0x28, 0x20, 0x1F, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x30, 0x32, 0x28, 0x35, 
	0x31, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x31, 0x32, 0x28, 0x2F, 0x2F, 0x26, 0x30, 0x29, 
	0x1F, 0x2F, 0x28, 0x1F, 0x35, 0x3B, 0x35, 0x33, 0x3B, 0x34, 0x38, 0x2F, 0x30, 0x37, 0x2F, 0x2F, 
	0x38, 0x3A, 0x30, 0x37, 0x37, 0x2E, 0x23, 0x2C, 0x2A, 0x11, 0x25, 0x25, 0x13, 0x26, 0x26, 0x11, 
	0x24, 0x23, 0x13, 0x29, 0x31, 0x33, 0x37, 0x31, 0x4E, 0x43, 0x39, 0x4F, 0x43, 0x39, 0x33, 0x36, 
	0x32, 0x0E, 0x24, 0x24, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x19, 0x2B, 0x30, 0x11, 0x25, 0x24, 
	0x1B, 0x2A, 0x2A, 0x44, 0x39, 0x32, 0x53, 0x45, 0x42, 0x27, 0x36, 0x3A, 0x0E, 0x25, 0x25, 0x13, 
	0x26, 0x26, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3B, 0x1B, 0x30, 
	0x37, 0x0F, 0x23, 0x1F, 0x18, 0x2A, 0x2E, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x37, 0x19, 0x30, 0x34, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x20, 0x1F, 0x78, 0x6B, 0x5C, 0x51, 
	0x49, 0x3E, 0x68, 0x61, 0x56, 0x66, 0x67, 0x62, 0x6A, 0x60, 0x50, 0x6E, 0x62, 0x54, 0x14, 0x32, 
	0x33, 0x11, 0x23, 0x20, 0x18, 0x29, 0x2E, 0x14, 0x26, 0x25, 0x1D, 0x32, 0x3B, 0x1E, 0x31, 0x3A, 
	0x14, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1B, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 
	0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x0C, 0x19, 0x19, 0x14, 0x27, 0x27, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x1C, 0x31, 0x3D, 0x36, 
	0x33, 0x26, 0x34, 0x30, 0x2B, 0x34, 0x31, 0x28, 0x19, 0x33, 0x3F, 0x1C, 0x1D, 0x1C, 0x1E, 0x33, 
	0x3E, 0x11, 0x26, 0x25, 0x1B, 0x1E, 0x1E, 0x14, 0x2F, 0x39, 0x3B, 0x31, 0x2E, 0x2A, 0x27, 0x22, 
	0x25, 0x18, 0x1A, 0x2A, 0x33, 0x2F, 0x31, 0x33, 0x27, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x23, 0x1F, 0x1F, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x34, 0x38, 
	0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0E, 0x29, 0x29, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x12, 0x27, 0x27, 0x0F, 0x27, 
	0x27, 0x25, 0x1F, 0x1C, 0x3D, 0x33, 0x35, 0x2E, 0x2A, 0x20, 0x3B, 0x31, 0x33, 0x2B, 0x2A, 0x23, 
	0x35, 0x31, 0x2C, 0x31, 0x33, 0x28, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x2F, 0x31, 0x26, 0x3B, 
	0x30, 0x33, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x32, 0x38, 0x32, 0x35, 0x3B, 
	0x36, 0x2E, 0x2F, 0x25, 0x30, 0x2E, 0x27, 0x36, 0x32, 0x2C, 0x39, 0x2F, 0x31, 0x2B, 0x2F, 0x23, 
	0x39, 0x31, 0x31, 0x37, 0x35, 0x29, 0x14, 0x2A, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x20, 
	0x33, 0x3F, 0x12, 0x25, 0x23, 0x0F, 0x28, 0x2F, 0x44, 0x3D, 0x33, 0x4E, 0x42, 0x38, 0x2C, 0x37, 
	0x35, 0x15, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3C, 0x14, 0x28, 0x2C, 
	0x2C, 0x42, 0x46, 0x5A, 0x4C, 0x40, 0x36, 0x49, 0x4B, 0x28, 0x3A, 0x3A, 0x2B, 0x1B, 0x18, 0x0F, 
	0x26, 0x26, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 
	0x45, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x37, 0x1B, 0x32, 0x3B, 0x1A, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x1A, 0x13, 0x11, 0x4E, 0x50, 0x50, 0x4B, 
	0x3F, 0x39, 0x57, 0x4D, 0x42, 0x7A, 0x6B, 0x5C, 0x74, 0x6B, 0x5A, 0x75, 0x66, 0x5A, 0x23, 0x25, 
	0x25, 0x15, 0x31, 0x38, 0x1E, 0x30, 0x39, 0x14, 0x32, 0x38, 0x1E, 0x2F, 0x38, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x15, 0x2C, 0x31, 0x15, 0x2C, 0x30, 0x13, 0x26, 0x25, 0x1E, 
	0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 0x15, 0x28, 
	0x29, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1C, 0x2F, 0x37, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x13, 0x29, 0x2F, 0x36, 
	0x32, 0x29, 0x3A, 0x33, 0x32, 0x2E, 0x20, 0x1D, 0x16, 0x2C, 0x32, 0x11, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x11, 0x27, 0x27, 0x2F, 0x18, 0x18, 0x0F, 0x28, 0x29, 0x31, 0x32, 0x30, 0x2C, 0x2B, 0x23, 
	0x2B, 0x25, 0x20, 0x29, 0x24, 0x1F, 0x37, 0x33, 0x2F, 0x25, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 
	0x1B, 0x27, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x2B, 0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x0D, 0x26, 0x27, 0x3C, 0x32, 0x2A, 0x0E, 0x2A, 0x33, 0x3C, 0x31, 0x2F, 0x2F, 0x31, 0x26, 
	0x3A, 0x30, 0x32, 0x32, 0x32, 0x29, 0x24, 0x16, 0x19, 0x31, 0x33, 0x28, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x34, 0x35, 
	0x2B, 0x37, 0x2F, 0x2F, 0x39, 0x36, 0x31, 0x38, 0x2F, 0x30, 0x35, 0x2F, 0x2C, 0x33, 0x31, 0x2A, 
	0x37, 0x31, 0x2C, 0x28, 0x33, 0x35, 0x16, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2B, 0x12, 0x25, 0x24, 0x15, 0x2B, 0x35, 0x45, 0x3D, 0x33, 0x4C, 0x40, 0x37, 0x3F, 0x44, 
	0x45, 0x15, 0x2A, 0x31, 0x1C, 0x30, 0x3B, 0x0F, 0x23, 0x20, 0x16, 0x2A, 0x2F, 0x1A, 0x2B, 0x30, 
	0x4A, 0x3E, 0x33, 0x5A, 0x52, 0x4A, 0x59, 0x4F, 0x45, 0x52, 0x46, 0x42, 0x3C, 0x38, 0x30, 0x0E, 
	0x25, 0x29, 0x12, 0x25, 0x23, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 0x36, 0x1D, 0x2C, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1E, 0x3B, 0x40, 0x11, 0x3A, 0x43, 0x1B, 0x37, 0x3E, 
	0x03, 0x06, 0x04, 0x00, 0x00, 0x00, 0x02, 0x03, 0x03, 0x20, 0x14, 0x0F, 0x45, 0x4F, 0x50, 0x3E, 
	0x3E, 0x37, 0x2A, 0x2A, 0x28, 0x2B, 0x3D, 0x43, 0x58, 0x55, 0x50, 0x3F, 0x48, 0x45, 0x14, 0x30, 
	0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x11, 0x3A, 0x43, 0x1C, 0x32, 0x3B, 0x11, 0x24, 0x20, 
	0x1F, 0x32, 0x3C, 0x1E, 0x30, 0x38, 0x18, 0x35, 0x3D, 0x12, 0x3C, 0x47, 0x1E, 0x2F, 0x38, 0x1D, 
	0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x12, 0x25, 0x23, 0x18, 0x2A, 
	0x2F, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x30, 0x39, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3C, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x3A, 0x20, 0x30, 0x36, 0x3B, 
	0x3B, 0x30, 0x37, 0x36, 0x30, 0x2F, 0x24, 0x23, 0x0E, 0x25, 0x24, 0x16, 0x29, 0x2C, 0x12, 0x25, 
	0x24, 0x14, 0x27, 0x27, 0x0F, 0x26, 0x25, 0x1E, 0x32, 0x3D, 0x16, 0x27, 0x23, 0x39, 0x32, 0x2E, 
	0x23, 0x31, 0x33, 0x2E, 0x2A, 0x23, 0x33, 0x31, 0x2A, 0x29, 0x25, 0x20, 0x32, 0x2B, 0x1F, 0x26, 
	0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 
	0x1C, 0x23, 0x1F, 0x1F, 0x0F, 0x28, 0x28, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x12, 0x27, 0x26, 0x25, 0x25, 0x2B, 0x0F, 0x26, 0x25, 0x1F, 0x26, 0x23, 0x22, 0x22, 0x1F, 
	0x3A, 0x31, 0x32, 0x34, 0x31, 0x2B, 0x29, 0x25, 0x20, 0x30, 0x31, 0x27, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x22, 0x1E, 0x2F, 0x2F, 
	0x26, 0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x3A, 0x30, 
	0x3A, 0x37, 0x31, 0x27, 0x26, 0x1F, 0x14, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2B, 0x31, 0x27, 0x3B, 0x42, 0x43, 0x3B, 0x32, 0x4C, 0x42, 0x39, 0x50, 0x42, 
	0x37, 0x1A, 0x32, 0x3C, 0x33, 0x39, 0x35, 0x1E, 0x34, 0x3E, 0x0F, 0x28, 0x33, 0x4D, 0x42, 0x39, 
	0x5F, 0x57, 0x4F, 0x5F, 0x56, 0x4D, 0x54, 0x52, 0x4D, 0x52, 0x48, 0x3D, 0x4E, 0x4F, 0x4C, 0x2C, 
	0x37, 0x3A, 0x0F, 0x23, 0x22, 0x1E, 0x36, 0x3F, 0x19, 0x30, 0x38, 0x22, 0x46, 0x49, 0x1D, 0x3E, 
	0x42, 0x1B, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 0x30, 0x18, 0x35, 0x3E, 0x1B, 0x2C, 0x31, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x03, 0x02, 0x02, 0x13, 0x1D, 0x24, 0x34, 0x5C, 0x5F, 0x46, 
	0x39, 0x34, 0x14, 0x2C, 0x38, 0x19, 0x2F, 0x38, 0x24, 0x3B, 0x3F, 0x18, 0x2E, 0x38, 0x19, 0x31, 
	0x39, 0x20, 0x34, 0x3B, 0x30, 0x2B, 0x27, 0x12, 0x39, 0x43, 0x16, 0x37, 0x40, 0x12, 0x24, 0x20, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3A, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 
	0x3A, 0x18, 0x29, 0x2C, 0x18, 0x29, 0x2E, 0x1D, 0x3E, 0x45, 0x1B, 0x2B, 0x33, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x11, 0x24, 0x20, 0x1B, 0x2F, 0x37, 0x1E, 0x23, 0x1D, 0x3C, 
	0x31, 0x30, 0x31, 0x23, 0x14, 0x32, 0x33, 0x30, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x20, 0x33, 
	0x3E, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x0E, 0x25, 0x26, 0x33, 0x24, 0x16, 
	0x2A, 0x31, 0x2E, 0x30, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x31, 0x32, 0x28, 0x25, 
	0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 
	0x1C, 0x25, 0x1E, 0x1E, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x1F, 0x26, 0x23, 
	0x3B, 0x31, 0x32, 0x36, 0x30, 0x2E, 0x2F, 0x31, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 
	0x30, 0x2A, 0x2E, 0x30, 0x25, 0x36, 0x30, 0x2E, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x36, 0x38, 
	0x2E, 0x36, 0x32, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 
	0x3C, 0x3A, 0x2F, 0x1E, 0x2E, 0x2F, 0x14, 0x27, 0x29, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x13, 
	0x26, 0x25, 0x11, 0x25, 0x24, 0x1A, 0x29, 0x2E, 0x4B, 0x40, 0x37, 0x38, 0x38, 0x30, 0x4B, 0x40, 
	0x37, 0x36, 0x39, 0x30, 0x42, 0x3B, 0x31, 0x50, 0x43, 0x37, 0x38, 0x37, 0x2B, 0x57, 0x4D, 0x40, 
	0x67, 0x62, 0x54, 0x60, 0x5E, 0x5E, 0x61, 0x58, 0x4D, 0x53, 0x4B, 0x42, 0x66, 0x5B, 0x51, 0x47, 
	0x52, 0x54, 0x07, 0x19, 0x18, 0x18, 0x36, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x40, 0x18, 0x33, 
	0x3D, 0x11, 0x39, 0x42, 0x1E, 0x38, 0x3E, 0x1B, 0x34, 0x3C, 0x1E, 0x2C, 0x36, 0x1A, 0x31, 0x35, 
	0x03, 0x07, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0E, 0x1E, 0x20, 0x33, 0x4E, 0x51, 0x59, 
	0x45, 0x3A, 0x26, 0x39, 0x3D, 0x1B, 0x2C, 0x36, 0x1B, 0x40, 0x44, 0x1C, 0x2C, 0x35, 0x20, 0x39, 
	0x40, 0x2A, 0x40, 0x3E, 0x51, 0x40, 0x35, 0x1C, 0x3B, 0x44, 0x0F, 0x38, 0x42, 0x1C, 0x2B, 0x32, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x1B, 0x32, 
	0x3B, 0x15, 0x32, 0x38, 0x14, 0x25, 0x25, 0x1D, 0x3B, 0x42, 0x1D, 0x35, 0x3E, 0x18, 0x29, 0x2E, 
	0x19, 0x2B, 0x30, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x26, 0x1D, 0x32, 0x3C, 0x13, 
	0x29, 0x2E, 0x11, 0x28, 0x2A, 0x15, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x1A, 0x2C, 
	0x32, 0x13, 0x26, 0x25, 0x15, 0x28, 0x2A, 0x1F, 0x32, 0x3D, 0x0F, 0x24, 0x24, 0x2F, 0x32, 0x2C, 
	0x2F, 0x2C, 0x20, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x27, 
	0x1D, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1C, 0x1C, 0x23, 0x1F, 
	0x1F, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x26, 0x26, 
	0x38, 0x32, 0x2B, 0x39, 0x30, 0x32, 0x30, 0x30, 0x27, 0x34, 0x30, 0x2B, 0x2E, 0x2F, 0x25, 0x2E, 
	0x2F, 0x25, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x35, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 0x39, 0x32, 
	0x31, 0x38, 0x2E, 0x30, 0x38, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x38, 0x31, 0x30, 0x39, 0x39, 0x2F, 
	0x2A, 0x34, 0x37, 0x0D, 0x23, 0x22, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x14, 0x27, 0x27, 0x20, 
	0x32, 0x3C, 0x12, 0x26, 0x27, 0x2A, 0x34, 0x35, 0x4F, 0x43, 0x39, 0x43, 0x3C, 0x34, 0x2E, 0x32, 
	0x2C, 0x11, 0x27, 0x2E, 0x1D, 0x2C, 0x30, 0x24, 0x2C, 0x2C, 0x24, 0x2E, 0x2F, 0x2E, 0x31, 0x2E, 
	0x70, 0x5E, 0x4D, 0x74, 0x6D, 0x5C, 0x66, 0x5D, 0x50, 0x5A, 0x52, 0x4B, 0x65, 0x61, 0x5D, 0x71, 
	0x63, 0x53, 0x15, 0x24, 0x24, 0x16, 0x33, 0x3D, 0x1D, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x1F, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3F, 0x43, 0x19, 0x34, 0x35, 
	0x03, 0x06, 0x06, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x2A, 0x53, 0x5B, 0x23, 
	0x3A, 0x3B, 0x1A, 0x2B, 0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x16, 0x31, 0x3A, 0x32, 0x37, 
	0x33, 0x3F, 0x39, 0x2E, 0x3D, 0x3A, 0x2F, 0x2A, 0x2A, 0x2C, 0x1C, 0x44, 0x44, 0x1D, 0x2F, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1E, 0x30, 0x38, 0x18, 0x34, 
	0x3D, 0x14, 0x42, 0x4A, 0x1E, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x15, 0x28, 0x2A, 0x1A, 0x31, 0x3E, 
	0x38, 0x31, 0x2B, 0x2E, 0x29, 0x1E, 0x35, 0x2F, 0x2C, 0x2F, 0x2F, 0x26, 0x35, 0x35, 0x2C, 0x33, 
	0x2C, 0x25, 0x25, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x2A, 0x23, 0x20, 0x25, 0x1D, 
	0x1D, 0x12, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 
	0x25, 0x22, 0x1F, 0x3A, 0x2F, 0x2C, 0x38, 0x31, 0x2F, 0x39, 0x2F, 0x31, 0x36, 0x32, 0x2E, 0x36, 
	0x37, 0x2E, 0x3A, 0x3A, 0x31, 0x36, 0x38, 0x2E, 0x39, 0x2E, 0x31, 0x39, 0x3B, 0x31, 0x38, 0x2E, 
	0x30, 0x39, 0x34, 0x2E, 0x2F, 0x44, 0x43, 0x39, 0x34, 0x2C, 0x38, 0x39, 0x30, 0x39, 0x38, 0x2F, 
	0x33, 0x34, 0x2E, 0x16, 0x2A, 0x31, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 0x1C, 0x34, 0x3E, 0x18, 
	0x36, 0x3F, 0x15, 0x2F, 0x36, 0x31, 0x34, 0x2F, 0x4D, 0x42, 0x39, 0x4A, 0x3E, 0x34, 0x24, 0x38, 
	0x3E, 0x1B, 0x34, 0x3F, 0x13, 0x24, 0x24, 0x1D, 0x38, 0x40, 0x18, 0x2B, 0x34, 0x1A, 0x29, 0x29, 
	0x3F, 0x42, 0x3E, 0x81, 0x72, 0x60, 0x74, 0x68, 0x5B, 0x6D, 0x62, 0x57, 0x69, 0x67, 0x5E, 0x72, 
	0x62, 0x52, 0x12, 0x28, 0x2B, 0x16, 0x33, 0x3C, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 
	0x40, 0x1D, 0x32, 0x3C, 0x1E, 0x3D, 0x40, 0x1E, 0x36, 0x40, 0x1C, 0x3F, 0x3F, 0x24, 0x40, 0x49, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x55, 0x59, 0x22, 
	0x40, 0x4B, 0x1C, 0x3D, 0x3F, 0x1D, 0x3B, 0x42, 0x1B, 0x30, 0x38, 0x1B, 0x35, 0x3E, 0x31, 0x45, 
	0x43, 0x4B, 0x43, 0x43, 0x42, 0x43, 0x43, 0x14, 0x35, 0x3F, 0x1D, 0x2E, 0x38, 0x1D, 0x43, 0x43, 
	0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x40, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x15, 0x25, 
	0x25, 0x19, 0x37, 0x3F, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x1E, 
	0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x12, 0x28, 0x2A, 
	0x34, 0x2A, 0x24, 0x2E, 0x29, 0x1E, 0x37, 0x38, 0x30, 0x2F, 0x2F, 0x26, 0x38, 0x39, 0x30, 0x35, 
	0x33, 0x2C, 0x27, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x2B, 0x23, 0x1F, 0x0E, 0x28, 
	0x28, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x0F, 0x27, 0x27, 0x1F, 0x26, 0x24, 0x23, 0x20, 0x1E, 0x39, 0x35, 0x30, 0x39, 0x30, 0x31, 0x3A, 
	0x2F, 0x31, 0x25, 0x2E, 0x29, 0x34, 0x2E, 0x2A, 0x2B, 0x2F, 0x23, 0x39, 0x31, 0x31, 0x38, 0x2F, 
	0x30, 0x35, 0x2E, 0x2C, 0x39, 0x2F, 0x2C, 0x32, 0x40, 0x3C, 0x39, 0x31, 0x2C, 0x38, 0x3C, 0x34, 
	0x1E, 0x35, 0x3F, 0x16, 0x29, 0x2C, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x23, 0x15, 0x27, 0x28, 0x18, 
	0x27, 0x2A, 0x14, 0x30, 0x3B, 0x40, 0x44, 0x43, 0x50, 0x42, 0x36, 0x40, 0x43, 0x44, 0x1F, 0x35, 
	0x3D, 0x0F, 0x20, 0x1C, 0x19, 0x35, 0x40, 0x1B, 0x40, 0x43, 0x1B, 0x2E, 0x34, 0x14, 0x27, 0x2B, 
	0x1D, 0x3B, 0x42, 0x66, 0x5D, 0x55, 0x95, 0x81, 0x73, 0x98, 0x83, 0x78, 0x86, 0x79, 0x70, 0x74, 
	0x6D, 0x69, 0x28, 0x38, 0x3D, 0x18, 0x30, 0x3A, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x3F, 0x22, 0x47, 0x48, 0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x40, 0x1C, 0x3B, 0x3E, 0x23, 0x3F, 0x46, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1B, 0x1A, 0x30, 0x54, 0x58, 0x22, 
	0x40, 0x4A, 0x1C, 0x3B, 0x3E, 0x1E, 0x44, 0x40, 0x0F, 0x37, 0x40, 0x1E, 0x3E, 0x42, 0x19, 0x28, 
	0x33, 0x1C, 0x32, 0x39, 0x37, 0x3F, 0x3A, 0x18, 0x3D, 0x42, 0x1A, 0x2E, 0x37, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x12, 0x22, 
	0x1E, 0x13, 0x3C, 0x47, 0x11, 0x22, 0x1D, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 
	0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x1A, 0x2C, 
	0x33, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 
	0x19, 0x32, 0x3E, 0x37, 0x30, 0x2A, 0x3A, 0x3B, 0x32, 0x28, 0x22, 0x1E, 0x28, 0x23, 0x1F, 0x39, 
	0x36, 0x31, 0x31, 0x33, 0x28, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1D, 0x28, 0x1B, 0x1B, 0x13, 0x2B, 
	0x2F, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x12, 0x27, 0x27, 0x12, 0x26, 0x26, 0x0F, 0x27, 0x27, 0x25, 0x22, 0x1F, 0x30, 0x2B, 0x26, 0x37, 
	0x30, 0x2F, 0x3A, 0x3A, 0x31, 0x38, 0x3A, 0x30, 0x36, 0x2E, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x33, 
	0x30, 0x35, 0x34, 0x2C, 0x38, 0x31, 0x30, 0x39, 0x30, 0x2E, 0x30, 0x3B, 0x39, 0x32, 0x35, 0x2F, 
	0x28, 0x20, 0x1E, 0x1C, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1C, 0x2E, 0x35, 0x16, 
	0x3D, 0x46, 0x2E, 0x39, 0x38, 0x40, 0x39, 0x30, 0x23, 0x34, 0x37, 0x25, 0x3B, 0x3F, 0x1B, 0x3D, 
	0x44, 0x1E, 0x31, 0x3A, 0x18, 0x34, 0x3C, 0x14, 0x35, 0x3E, 0x1E, 0x3A, 0x44, 0x1D, 0x2F, 0x38, 
	0x1A, 0x2C, 0x36, 0x1F, 0x2C, 0x36, 0x4F, 0x4B, 0x42, 0x50, 0x55, 0x57, 0x50, 0x52, 0x4F, 0x28, 
	0x3B, 0x3C, 0x18, 0x29, 0x34, 0x20, 0x45, 0x48, 0x1B, 0x3F, 0x3D, 0x1D, 0x3D, 0x3E, 0x11, 0x35, 
	0x40, 0x1E, 0x3B, 0x3F, 0x1C, 0x40, 0x40, 0x0F, 0x34, 0x3E, 0x20, 0x4A, 0x4D, 0x1F, 0x45, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x64, 0x22, 
	0x40, 0x49, 0x1D, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x1E, 0x3A, 0x40, 0x1C, 0x3D, 0x3F, 0x24, 0x45, 
	0x4D, 0x1B, 0x2E, 0x37, 0x1A, 0x3F, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x36, 
	0x3F, 0x12, 0x3A, 0x43, 0x1F, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1A, 
	0x2B, 0x32, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x28, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x23, 0x13, 0x26, 
	0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x28, 0x2B, 0x32, 0x29, 0x23, 0x3A, 0x37, 0x31, 0x32, 0x39, 0x36, 0x28, 0x22, 0x1E, 0x2F, 
	0x30, 0x26, 0x2F, 0x29, 0x23, 0x08, 0x29, 0x2A, 0x2B, 0x1D, 0x1A, 0x27, 0x1B, 0x1C, 0x1E, 0x22, 
	0x20, 0x12, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x12, 0x27, 0x27, 
	0x1F, 0x20, 0x1F, 0x15, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x0E, 0x27, 0x27, 0x26, 0x23, 0x20, 0x31, 
	0x2A, 0x25, 0x35, 0x31, 0x29, 0x39, 0x3A, 0x30, 0x39, 0x2E, 0x31, 0x36, 0x38, 0x2E, 0x3A, 0x3A, 
	0x31, 0x3A, 0x39, 0x2F, 0x3A, 0x3A, 0x2F, 0x3C, 0x2F, 0x2C, 0x11, 0x28, 0x2F, 0x18, 0x2C, 0x35, 
	0x1C, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x0D, 0x22, 0x1F, 0x2C, 
	0x34, 0x31, 0x43, 0x4A, 0x4B, 0x47, 0x40, 0x39, 0x16, 0x2C, 0x37, 0x1D, 0x2E, 0x37, 0x16, 0x26, 
	0x28, 0x1E, 0x3B, 0x45, 0x1E, 0x2E, 0x36, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x37, 0x1D, 0x30, 0x37, 0x20, 0x3E, 0x46, 0x0E, 0x3C, 0x3F, 0x1B, 
	0x2B, 0x35, 0x1C, 0x2C, 0x36, 0x1F, 0x44, 0x46, 0x2A, 0x4E, 0x58, 0x20, 0x48, 0x4C, 0x0F, 0x35, 
	0x3E, 0x1C, 0x3D, 0x40, 0x1E, 0x39, 0x40, 0x1D, 0x3C, 0x3F, 0x25, 0x40, 0x45, 0x23, 0x46, 0x4F, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x5A, 0x63, 0x1F, 
	0x3F, 0x49, 0x0F, 0x36, 0x3E, 0x1E, 0x31, 0x3A, 0x1D, 0x37, 0x3C, 0x1D, 0x29, 0x33, 0x1C, 0x4F, 
	0x54, 0x1D, 0x2F, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3D, 0x42, 0x1D, 
	0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x15, 0x2C, 
	0x30, 0x19, 0x35, 0x3E, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x16, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x1E, 0x33, 0x3C, 0x1D, 
	0x3C, 0x42, 0x16, 0x28, 0x2B, 0x1E, 0x31, 0x3A, 0x1B, 0x34, 0x3D, 0x1F, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 
	0x11, 0x25, 0x24, 0x20, 0x32, 0x39, 0x39, 0x33, 0x2E, 0x39, 0x3A, 0x30, 0x34, 0x2F, 0x2B, 0x37, 
	0x38, 0x2F, 0x35, 0x34, 0x2E, 0x2B, 0x1C, 0x18, 0x32, 0x35, 0x2A, 0x28, 0x1C, 0x1A, 0x1F, 0x25, 
	0x28, 0x19, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x11, 0x28, 0x28, 
	0x2F, 0x19, 0x19, 0x0F, 0x26, 0x25, 0x20, 0x33, 0x3E, 0x16, 0x29, 0x2B, 0x0F, 0x26, 0x25, 0x20, 
	0x2B, 0x35, 0x1F, 0x30, 0x36, 0x35, 0x37, 0x32, 0x37, 0x33, 0x29, 0x2A, 0x20, 0x1B, 0x28, 0x28, 
	0x25, 0x20, 0x33, 0x3A, 0x20, 0x35, 0x3E, 0x13, 0x29, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1F, 0x34, 0x3D, 0x4F, 
	0x43, 0x36, 0x3E, 0x40, 0x43, 0x1F, 0x34, 0x35, 0x1D, 0x2C, 0x36, 0x0F, 0x3B, 0x44, 0x1A, 0x34, 
	0x3C, 0x18, 0x33, 0x3B, 0x1B, 0x31, 0x39, 0x16, 0x34, 0x3C, 0x1E, 0x37, 0x40, 0x1D, 0x3A, 0x43, 
	0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1C, 0x2F, 0x37, 0x1C, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x31, 0x39, 0x1D, 0x31, 0x39, 0x1C, 0x2B, 0x36, 0x1B, 0x3E, 0x3E, 0x1C, 0x40, 0x3E, 0x1F, 0x3C, 
	0x40, 0x11, 0x36, 0x40, 0x11, 0x36, 0x40, 0x12, 0x36, 0x40, 0x37, 0x42, 0x3E, 0x24, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x1F, 
	0x42, 0x48, 0x16, 0x43, 0x4D, 0x1D, 0x3F, 0x3E, 0x1C, 0x4D, 0x53, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 
	0x3F, 0x1D, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x40, 0x44, 0x1D, 0x29, 0x34, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x37, 0x1B, 0x2B, 0x33, 0x11, 0x22, 
	0x1E, 0x1F, 0x30, 0x3A, 0x13, 0x26, 0x26, 0x1E, 0x33, 0x3C, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x29, 0x2E, 0x1E, 
	0x36, 0x3F, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x29, 0x2C, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 
	0x3A, 0x19, 0x2B, 0x31, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x0E, 0x25, 0x24, 0x2A, 0x19, 0x15, 0x3B, 0x33, 0x33, 0x2B, 0x2E, 0x23, 0x39, 
	0x2E, 0x31, 0x33, 0x30, 0x2B, 0x30, 0x2A, 0x1F, 0x30, 0x31, 0x28, 0x32, 0x29, 0x1E, 0x23, 0x1C, 
	0x1D, 0x11, 0x27, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 
	0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x11, 0x27, 0x27, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 
	0x26, 0x24, 0x14, 0x28, 0x29, 0x1B, 0x30, 0x3B, 0x1A, 0x30, 0x3A, 0x1B, 0x31, 0x3B, 0x1A, 0x32, 
	0x3D, 0x32, 0x23, 0x19, 0x14, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x15, 0x2A, 0x35, 0x5A, 
	0x4C, 0x43, 0x46, 0x3D, 0x34, 0x0D, 0x39, 0x44, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x12, 0x39, 
	0x42, 0x12, 0x37, 0x40, 0x14, 0x36, 0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2C, 0x35, 0x1E, 0x35, 0x3D, 0x1D, 0x2E, 0x36, 0x18, 0x31, 0x3A, 0x1E, 0x2E, 0x36, 0x16, 
	0x39, 0x43, 0x1D, 0x3E, 0x40, 0x22, 0x45, 0x48, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 
	0x40, 0x1F, 0x43, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x36, 0x40, 0x23, 0x42, 0x3F, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x42, 0x49, 0x1C, 0x3A, 0x3C, 0x1C, 0x2B, 0x36, 0x28, 0x4D, 0x53, 0x1C, 0x3E, 0x3F, 0x1B, 0x39, 
	0x3D, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x29, 0x34, 0x1D, 0x3B, 0x43, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3C, 0x44, 0x1E, 0x38, 
	0x3D, 0x1D, 0x3C, 0x43, 0x1B, 0x2E, 0x35, 0x16, 0x28, 0x2B, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 0x14, 0x27, 0x27, 0x18, 
	0x29, 0x2E, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 
	0x13, 0x25, 0x24, 0x1D, 0x36, 0x42, 0x0C, 0x25, 0x24, 0x37, 0x33, 0x2B, 0x3A, 0x3B, 0x32, 0x37, 
	0x36, 0x2F, 0x36, 0x31, 0x2E, 0x2E, 0x30, 0x26, 0x30, 0x2A, 0x20, 0x31, 0x32, 0x28, 0x22, 0x29, 
	0x25, 0x12, 0x26, 0x27, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 
	0x16, 0x29, 0x2B, 0x1F, 0x32, 0x3D, 0x15, 0x28, 0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 
	0x29, 0x2C, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 
	0x2F, 0x15, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x38, 0x14, 0x27, 0x28, 
	0x11, 0x24, 0x20, 0x1E, 0x31, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x39, 0x42, 0x11, 0x31, 0x3A, 0x54, 
	0x4C, 0x48, 0x18, 0x3C, 0x42, 0x1D, 0x2C, 0x35, 0x1B, 0x31, 0x39, 0x18, 0x38, 0x42, 0x12, 0x37, 
	0x40, 0x1F, 0x44, 0x40, 0x1E, 0x3C, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 
	0x1B, 0x3A, 0x43, 0x0F, 0x39, 0x42, 0x16, 0x33, 0x3B, 0x2E, 0x3A, 0x3C, 0x15, 0x34, 0x3D, 0x18, 
	0x33, 0x3B, 0x1E, 0x31, 0x3A, 0x0E, 0x35, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 
	0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x11, 0x35, 0x40, 0x1D, 0x42, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x1A, 0x19, 0x30, 0x59, 0x63, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x52, 0x1C, 0x28, 0x32, 0x1C, 0x37, 0x3A, 0x1B, 0x3A, 0x3E, 0x2B, 0x4E, 
	0x58, 0x1E, 0x3F, 0x43, 0x1C, 0x3B, 0x3F, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x12, 0x25, 0x24, 0x1F, 0x31, 0x3A, 0x12, 0x27, 0x29, 0x33, 0x2A, 0x24, 0x30, 0x2B, 0x27, 0x47, 
	0x42, 0x38, 0x37, 0x3A, 0x30, 0x34, 0x33, 0x2B, 0x25, 0x1B, 0x1C, 0x31, 0x32, 0x28, 0x28, 0x28, 
	0x24, 0x0F, 0x25, 0x24, 0x14, 0x29, 0x2C, 0x2B, 0x33, 0x33, 0x11, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 0x26, 
	0x25, 0x19, 0x2B, 0x31, 0x1E, 0x33, 0x3D, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x15, 
	0x28, 0x2A, 0x19, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 0x14, 0x27, 
	0x28, 0x18, 0x2A, 0x2F, 0x18, 0x29, 0x2C, 0x1D, 0x35, 0x3E, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x38, 
	0x1E, 0x30, 0x3A, 0x16, 0x29, 0x2B, 0x1A, 0x2B, 0x31, 0x1D, 0x39, 0x43, 0x19, 0x33, 0x3C, 0x26, 
	0x40, 0x40, 0x19, 0x37, 0x40, 0x1A, 0x31, 0x39, 0x1C, 0x2C, 0x38, 0x18, 0x43, 0x44, 0x13, 0x37, 
	0x42, 0x14, 0x3A, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1F, 0x32, 0x3B, 0x0F, 0x38, 0x42, 0x19, 0x2F, 0x38, 0x1E, 0x2E, 0x36, 0x18, 
	0x33, 0x3C, 0x1E, 0x42, 0x42, 0x1E, 0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x40, 0x3F, 0x23, 0x3E, 0x47, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x0C, 0x19, 0x18, 0x2F, 0x59, 0x62, 0x22, 
	0x44, 0x47, 0x1C, 0x4C, 0x56, 0x20, 0x45, 0x44, 0x1C, 0x4E, 0x59, 0x1D, 0x3B, 0x3C, 0x1A, 0x49, 
	0x50, 0x2B, 0x4D, 0x57, 0x1B, 0x30, 0x36, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x30, 
	0x39, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1B, 0x2E, 0x35, 
	0x19, 0x2A, 0x2E, 0x18, 0x37, 0x42, 0x1B, 0x2E, 0x35, 0x1E, 0x2B, 0x35, 0x26, 0x22, 0x20, 0x30, 
	0x25, 0x1C, 0x38, 0x2E, 0x31, 0x39, 0x2F, 0x31, 0x2F, 0x31, 0x26, 0x30, 0x31, 0x27, 0x2E, 0x25, 
	0x1E, 0x1E, 0x34, 0x40, 0x0F, 0x25, 0x25, 0x34, 0x25, 0x1E, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x16, 0x29, 
	0x2C, 0x14, 0x28, 0x2A, 0x20, 0x1E, 0x1C, 0x12, 0x27, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x12, 0x25, 0x24, 0x19, 
	0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x38, 0x1B, 0x32, 0x3B, 0x1D, 0x3B, 0x44, 0x1B, 0x29, 0x2F, 0x1C, 
	0x2A, 0x34, 0x11, 0x39, 0x42, 0x15, 0x33, 0x3D, 0x30, 0x2E, 0x25, 0x40, 0x2E, 0x2A, 0x2A, 0x30, 
	0x2F, 0x12, 0x38, 0x43, 0x1B, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x42, 0x42, 0x1D, 0x43, 0x40, 0x1D, 0x42, 0x42, 0x1D, 0x30, 0x39, 0x18, 
	0x32, 0x3B, 0x14, 0x3A, 0x40, 0x1E, 0x3C, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x40, 0x3F, 0x27, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x0F, 0x23, 0x28, 0x32, 0x5D, 0x66, 0x22, 
	0x44, 0x47, 0x14, 0x3F, 0x49, 0x1D, 0x33, 0x3D, 0x1D, 0x48, 0x4B, 0x1C, 0x3C, 0x3D, 0x1D, 0x3B, 
	0x3C, 0x19, 0x48, 0x4E, 0x28, 0x4C, 0x52, 0x1C, 0x39, 0x3E, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x35, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x13, 0x25, 0x25, 0x18, 0x2A, 
	0x2E, 0x1D, 0x30, 0x39, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2F, 0x1B, 0x2E, 0x35, 0x1E, 0x31, 0x3A, 
	0x1C, 0x2F, 0x36, 0x12, 0x24, 0x20, 0x16, 0x29, 0x2B, 0x14, 0x28, 0x2A, 0x1F, 0x2B, 0x35, 0x32, 
	0x37, 0x32, 0x38, 0x3A, 0x2F, 0x38, 0x31, 0x30, 0x31, 0x2F, 0x28, 0x31, 0x32, 0x27, 0x26, 0x22, 
	0x20, 0x11, 0x26, 0x25, 0x14, 0x27, 0x27, 0x11, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 
	0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x12, 0x25, 
	0x24, 0x20, 0x33, 0x3F, 0x11, 0x26, 0x25, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x19, 
	0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x2B, 0x32, 0x2E, 0x35, 0x32, 0x1C, 0x2C, 0x36, 0x0E, 0x3A, 0x43, 0x23, 
	0x42, 0x48, 0x11, 0x36, 0x3F, 0x1F, 0x3B, 0x42, 0x16, 0x32, 0x3C, 0x23, 0x46, 0x4B, 0x35, 0x31, 
	0x28, 0x20, 0x40, 0x43, 0x1C, 0x3F, 0x43, 0x1D, 0x2A, 0x35, 0x1D, 0x3F, 0x43, 0x1A, 0x2F, 0x38, 
	0x14, 0x36, 0x3E, 0x1D, 0x37, 0x40, 0x22, 0x38, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1E, 
	0x3B, 0x42, 0x11, 0x36, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x38, 0x40, 0x1B, 0x40, 0x3E, 0x27, 0x4A, 
	0x52, 0x1C, 0x3E, 0x3D, 0x1C, 0x40, 0x3F, 0x20, 0x44, 0x47, 0x1A, 0x3B, 0x3C, 0x26, 0x43, 0x4D, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1E, 0x23, 0x34, 0x64, 0x6D, 0x20, 
	0x3F, 0x46, 0x24, 0x4D, 0x57, 0x1B, 0x3C, 0x3B, 0x1C, 0x3B, 0x3B, 0x24, 0x47, 0x4B, 0x1B, 0x3B, 
	0x3C, 0x2A, 0x4C, 0x56, 0x1E, 0x42, 0x44, 0x1B, 0x3F, 0x3D, 0x2B, 0x4E, 0x5A, 0x1A, 0x3D, 0x3B, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3C, 0x40, 0x24, 0x4B, 0x4E, 
	0x1C, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1E, 0x3A, 0x45, 0x1B, 0x2C, 
	0x34, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x20, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2F, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x20, 
	0x26, 0x26, 0x44, 0x39, 0x35, 0x37, 0x3A, 0x30, 0x3A, 0x32, 0x32, 0x2E, 0x23, 0x22, 0x11, 0x29, 
	0x2C, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 
	0x27, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1E, 0x31, 
	0x3B, 0x13, 0x26, 0x25, 0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 
	0x1D, 0x2E, 0x36, 0x1C, 0x38, 0x42, 0x28, 0x12, 0x0F, 0x1C, 0x31, 0x3A, 0x1E, 0x2E, 0x37, 0x22, 
	0x45, 0x47, 0x11, 0x36, 0x3F, 0x1C, 0x3B, 0x42, 0x1D, 0x2B, 0x34, 0x1F, 0x44, 0x49, 0x18, 0x2C, 
	0x38, 0x37, 0x45, 0x42, 0x1A, 0x2C, 0x37, 0x1D, 0x3A, 0x42, 0x1D, 0x43, 0x40, 0x1E, 0x3D, 0x40, 
	0x11, 0x36, 0x3F, 0x12, 0x37, 0x40, 0x38, 0x43, 0x40, 0x1A, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 
	0x3F, 0x40, 0x1B, 0x3F, 0x40, 0x12, 0x39, 0x40, 0x35, 0x3C, 0x3A, 0x1A, 0x39, 0x3E, 0x2A, 0x4C, 
	0x56, 0x1A, 0x42, 0x43, 0x1B, 0x3E, 0x3C, 0x1A, 0x42, 0x42, 0x29, 0x4D, 0x57, 0x25, 0x40, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x34, 0x5D, 0x5F, 0x20, 
	0x3D, 0x48, 0x1E, 0x40, 0x3F, 0x2A, 0x4C, 0x55, 0x1B, 0x4C, 0x55, 0x1C, 0x4C, 0x55, 0x1B, 0x3A, 
	0x3A, 0x29, 0x4C, 0x56, 0x1A, 0x3D, 0x3B, 0x1D, 0x40, 0x40, 0x1A, 0x3D, 0x3A, 0x2A, 0x4D, 0x58, 
	0x1B, 0x39, 0x3D, 0x1C, 0x3C, 0x3E, 0x1B, 0x3F, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1B, 
	0x38, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x39, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x2F, 0x3A, 0x1C, 0x43, 0x3F, 
	0x1D, 0x31, 0x3B, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2C, 0x33, 0x18, 0x29, 0x2C, 0x11, 0x24, 
	0x20, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x12, 
	0x29, 0x2B, 0x1E, 0x16, 0x18, 0x38, 0x38, 0x2E, 0x38, 0x3A, 0x30, 0x38, 0x34, 0x2B, 0x15, 0x2B, 
	0x32, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 
	0x29, 0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x16, 0x29, 
	0x2B, 0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x30, 0x37, 0x34, 0x19, 0x30, 0x39, 0x0F, 0x39, 0x42, 0x1F, 
	0x39, 0x3F, 0x13, 0x37, 0x40, 0x12, 0x38, 0x42, 0x1F, 0x2E, 0x36, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 
	0x42, 0x1A, 0x39, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1E, 0x3B, 0x40, 0x1C, 0x3B, 0x3F, 
	0x1F, 0x44, 0x47, 0x11, 0x35, 0x3F, 0x19, 0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x35, 0x40, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x48, 
	0x4E, 0x29, 0x4B, 0x54, 0x28, 0x4B, 0x54, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x2B, 0x50, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x3A, 0x69, 0x75, 0x26, 
	0x48, 0x4A, 0x19, 0x4A, 0x54, 0x2A, 0x4B, 0x55, 0x1B, 0x3F, 0x3E, 0x1F, 0x48, 0x4F, 0x24, 0x48, 
	0x4B, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1B, 0x3E, 0x3C, 0x1B, 0x45, 0x4A, 0x29, 0x4C, 0x56, 
	0x1D, 0x3E, 0x40, 0x26, 0x4A, 0x51, 0x2A, 0x4D, 0x58, 0x1B, 0x3E, 0x3C, 0x1D, 0x40, 0x40, 0x1B, 
	0x3F, 0x3D, 0x1B, 0x3B, 0x3C, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2B, 0x35, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x31, 
	0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 0x1B, 0x2E, 0x35, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3B, 0x11, 0x24, 0x22, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1F, 
	0x32, 0x3C, 0x16, 0x2E, 0x35, 0x30, 0x2F, 0x30, 0x3A, 0x2F, 0x31, 0x2F, 0x1F, 0x1C, 0x16, 0x2C, 
	0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x15, 0x29, 0x2B, 0x22, 
	0x2C, 0x35, 0x1B, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x31, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1A, 0x30, 0x39, 
	0x1C, 0x2F, 0x37, 0x1E, 0x2E, 0x36, 0x1B, 0x32, 0x3C, 0x1E, 0x3F, 0x42, 0x1A, 0x37, 0x40, 0x12, 
	0x37, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x39, 0x42, 0x12, 0x38, 0x42, 0x1C, 0x40, 
	0x40, 0x1E, 0x37, 0x40, 0x1D, 0x36, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x3F, 0x1C, 0x3C, 0x40, 0x0F, 0x34, 0x40, 0x1F, 0x43, 0x40, 0x0F, 0x35, 0x40, 0x1E, 
	0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x3D, 0x2A, 0x4C, 
	0x56, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x53, 0x2A, 0x4F, 0x50, 
	0x00, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x12, 0x1F, 0x24, 0x32, 0x5B, 0x5E, 0x28, 
	0x4B, 0x4B, 0x2A, 0x4A, 0x54, 0x19, 0x3F, 0x3E, 0x1B, 0x4C, 0x56, 0x28, 0x49, 0x4E, 0x19, 0x2C, 
	0x37, 0x26, 0x4A, 0x51, 0x1A, 0x42, 0x42, 0x1D, 0x3B, 0x3D, 0x1B, 0x49, 0x50, 0x1E, 0x40, 0x40, 
	0x29, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x28, 0x4B, 0x53, 0x1B, 0x3B, 0x3C, 0x2A, 
	0x4D, 0x58, 0x24, 0x45, 0x4C, 0x1B, 0x38, 0x3C, 0x1D, 0x42, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 0x11, 0x24, 0x22, 0x18, 
	0x2A, 0x2F, 0x1B, 0x30, 0x3B, 0x38, 0x35, 0x29, 0x3A, 0x3B, 0x30, 0x23, 0x2A, 0x2E, 0x13, 0x28, 
	0x29, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x27, 
	0x1C, 0x1B, 0x1F, 0x1F, 0x1D, 0x14, 0x29, 0x2A, 0x1F, 0x32, 0x3C, 0x15, 0x28, 0x2A, 0x13, 0x26, 
	0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 
	0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x32, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x1B, 0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1A, 0x33, 
	0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2A, 0x18, 0x39, 0x43, 0x37, 0x46, 0x43, 
	0x20, 0x31, 0x38, 0x0F, 0x39, 0x42, 0x1F, 0x3F, 0x42, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x37, 
	0x40, 0x15, 0x38, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1F, 0x3D, 0x40, 0x1D, 0x35, 0x40, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3D, 0x3E, 0x1F, 0x43, 0x40, 0x1C, 0x3F, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1C, 0x3F, 0x3E, 0x19, 0x40, 
	0x40, 0x27, 0x4A, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 0x53, 0x28, 0x43, 0x4A, 
	0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x68, 0x73, 0x2C, 
	0x4D, 0x50, 0x18, 0x49, 0x52, 0x2A, 0x4B, 0x54, 0x27, 0x47, 0x4D, 0x19, 0x4A, 0x53, 0x26, 0x49, 
	0x4F, 0x20, 0x44, 0x46, 0x26, 0x49, 0x50, 0x1A, 0x3D, 0x3A, 0x2A, 0x4C, 0x56, 0x19, 0x3C, 0x39, 
	0x28, 0x4B, 0x54, 0x27, 0x4A, 0x53, 0x2A, 0x4D, 0x57, 0x1A, 0x3D, 0x3A, 0x1D, 0x39, 0x3E, 0x1A, 
	0x46, 0x49, 0x1B, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1A, 0x3E, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x39, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x29, 0x34, 
	0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1C, 
	0x2C, 0x36, 0x1D, 0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1E, 0x31, 0x3A, 
	0x1A, 0x2C, 0x32, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x13, 
	0x26, 0x26, 0x19, 0x2E, 0x35, 0x24, 0x24, 0x1F, 0x3C, 0x3A, 0x30, 0x18, 0x31, 0x3C, 0x1F, 0x32, 
	0x3C, 0x15, 0x28, 0x29, 0x1D, 0x30, 0x39, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 
	0x26, 0x24, 0x19, 0x2E, 0x34, 0x12, 0x25, 0x24, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x14, 0x27, 
	0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 
	0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x16, 0x27, 0x29, 0x1D, 0x3B, 0x45, 0x1D, 0x2C, 
	0x35, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x38, 0x19, 0x31, 0x39, 0x20, 0x32, 0x39, 
	0x32, 0x3B, 0x39, 0x13, 0x38, 0x42, 0x19, 0x32, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 
	0x3E, 0x12, 0x37, 0x40, 0x1D, 0x42, 0x3E, 0x1E, 0x3D, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x3A, 0x3E, 0x1E, 0x49, 0x4D, 0x0E, 0x33, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3C, 0x3F, 0x1D, 
	0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x1E, 0x42, 0x43, 0x29, 0x4B, 
	0x55, 0x28, 0x4C, 0x52, 0x38, 0x53, 0x50, 0x1C, 0x48, 0x52, 0x1A, 0x4A, 0x53, 0x1A, 0x49, 0x50, 
	0x03, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x39, 0x67, 0x71, 0x20, 
	0x43, 0x49, 0x29, 0x4A, 0x52, 0x1A, 0x4B, 0x54, 0x1E, 0x40, 0x3F, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x4E, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 0x3B, 0x38, 0x28, 0x4B, 0x54, 0x19, 0x3D, 0x3A, 0x2B, 
	0x4D, 0x59, 0x1A, 0x3D, 0x3B, 0x1A, 0x3E, 0x3B, 0x1D, 0x3D, 0x40, 0x1A, 0x3E, 0x3B, 0x1C, 0x3D, 
	0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x42, 
	0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1C, 0x2C, 0x36, 0x20, 
	0x46, 0x49, 0x1C, 0x44, 0x40, 0x20, 0x46, 0x49, 0x1C, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x25, 0x2F, 0x30, 0x44, 0x3F, 0x34, 0x1B, 0x1B, 0x1A, 0x14, 0x29, 
	0x2B, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x31, 0x1F, 
	0x32, 0x3D, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2B, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 
	0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x16, 0x29, 0x2C, 0x1D, 
	0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x37, 0x1D, 0x39, 0x43, 0x1D, 0x3C, 
	0x43, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x16, 0x2B, 0x37, 
	0x3B, 0x3E, 0x36, 0x0E, 0x38, 0x42, 0x1C, 0x31, 0x3A, 0x13, 0x38, 0x40, 0x14, 0x38, 0x40, 0x14, 
	0x38, 0x40, 0x14, 0x38, 0x40, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x13, 0x36, 0x3E, 0x19, 0x43, 
	0x4B, 0x11, 0x35, 0x3D, 0x26, 0x4A, 0x4E, 0x1C, 0x2E, 0x38, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x44, 0x46, 0x1E, 0x40, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 
	0x40, 0x40, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x1E, 0x46, 0x4A, 0x29, 0x4B, 0x54, 0x18, 0x4A, 
	0x52, 0x2A, 0x47, 0x4D, 0x37, 0x3E, 0x3C, 0x32, 0x56, 0x53, 0x2A, 0x4C, 0x53, 0x28, 0x4E, 0x50, 
	0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x4A, 0x52, 0x1B, 0x47, 0x4D, 0x22, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4B, 0x55, 0x18, 0x3B, 0x37, 0x28, 0x4B, 0x54, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x38, 0x2B, 0x4E, 0x59, 0x19, 
	0x3C, 0x39, 0x29, 0x4C, 0x56, 0x2A, 0x4D, 0x58, 0x19, 0x3C, 0x39, 0x2B, 0x4E, 0x59, 0x1E, 0x42, 
	0x42, 0x1F, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1D, 0x42, 0x40, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 
	0x3F, 0x42, 0x1D, 0x31, 0x3C, 0x1C, 0x3F, 0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x11, 
	0x23, 0x1F, 0x16, 0x2B, 0x31, 0x27, 0x30, 0x31, 0x3C, 0x31, 0x2F, 0x15, 0x2E, 0x37, 0x12, 0x25, 
	0x23, 0x16, 0x29, 0x2C, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x13, 0x26, 0x26, 0x1A, 0x2C, 0x32, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x19, 
	0x2B, 0x31, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x16, 0x29, 
	0x2B, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x1F, 0x32, 0x3C, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x1D, 
	0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 
	0x37, 0x1D, 0x2C, 0x35, 0x1D, 0x30, 0x39, 0x13, 0x35, 0x3E, 0x19, 0x38, 0x42, 0x32, 0x3B, 0x39, 
	0x38, 0x3C, 0x36, 0x0E, 0x36, 0x42, 0x1F, 0x42, 0x40, 0x13, 0x37, 0x40, 0x13, 0x36, 0x3E, 0x13, 
	0x37, 0x3F, 0x13, 0x36, 0x3E, 0x1D, 0x48, 0x4D, 0x1C, 0x46, 0x4C, 0x0F, 0x33, 0x3C, 0x2A, 0x4F, 
	0x57, 0x0D, 0x32, 0x3B, 0x22, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x3E, 
	0x1D, 0x45, 0x47, 0x1D, 0x3F, 0x3E, 0x1B, 0x3E, 0x3D, 0x1B, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 
	0x3E, 0x3C, 0x1B, 0x45, 0x49, 0x2A, 0x4C, 0x56, 0x25, 0x47, 0x4D, 0x27, 0x4A, 0x52, 0x29, 0x4A, 
	0x52, 0x18, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x2B, 0x4F, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1E, 0x22, 0x38, 0x66, 0x70, 0x2C, 
	0x53, 0x5B, 0x19, 0x49, 0x51, 0x1B, 0x4A, 0x52, 0x29, 0x4A, 0x53, 0x19, 0x47, 0x4C, 0x28, 0x4A, 
	0x52, 0x26, 0x49, 0x52, 0x2F, 0x50, 0x52, 0x18, 0x46, 0x4C, 0x29, 0x4B, 0x54, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x2A, 0x4B, 0x55, 0x1D, 0x40, 0x3F, 0x1E, 
	0x42, 0x42, 0x2A, 0x4C, 0x56, 0x18, 0x3B, 0x37, 0x2B, 0x4E, 0x59, 0x19, 0x3C, 0x39, 0x29, 0x4C, 
	0x57, 0x28, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x1B, 0x39, 0x3D, 0x2B, 0x50, 0x5A, 0x1B, 0x38, 0x3D, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x43, 0x1D, 
	0x2A, 0x35, 0x15, 0x26, 0x28, 0x1D, 0x2B, 0x36, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x1D, 0x30, 0x38, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x14, 0x27, 0x27, 0x1E, 0x30, 0x39, 0x1C, 
	0x36, 0x42, 0x0F, 0x23, 0x22, 0x20, 0x29, 0x23, 0x3C, 0x37, 0x2F, 0x29, 0x38, 0x3B, 0x1A, 0x2E, 
	0x35, 0x16, 0x29, 0x2B, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x13, 
	0x26, 0x25, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x30, 0x18, 0x2A, 
	0x2F, 0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x11, 0x24, 0x22, 0x18, 0x2A, 0x2F, 
	0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x28, 0x2A, 0x1D, 
	0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x3B, 0x43, 0x1D, 0x3E, 0x42, 0x1E, 0x44, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3C, 0x42, 
	0x36, 0x3F, 0x3B, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x35, 0x3E, 0x1D, 0x4A, 0x52, 0x19, 
	0x3E, 0x45, 0x12, 0x35, 0x3E, 0x12, 0x34, 0x3C, 0x1C, 0x46, 0x4C, 0x1B, 0x40, 0x44, 0x27, 0x49, 
	0x50, 0x28, 0x4B, 0x51, 0x1B, 0x3D, 0x3C, 0x1D, 0x44, 0x45, 0x1C, 0x39, 0x3E, 0x20, 0x45, 0x47, 
	0x1C, 0x3F, 0x3E, 0x1B, 0x3E, 0x3C, 0x29, 0x4C, 0x56, 0x29, 0x4C, 0x56, 0x1D, 0x45, 0x49, 0x2A, 
	0x4B, 0x55, 0x1B, 0x4B, 0x55, 0x1A, 0x43, 0x45, 0x1A, 0x4A, 0x53, 0x29, 0x4D, 0x52, 0x26, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x02, 0x00, 0x11, 0x1D, 0x22, 0x38, 0x67, 0x71, 0x28, 
	0x49, 0x4E, 0x29, 0x49, 0x52, 0x1A, 0x4A, 0x52, 0x28, 0x49, 0x52, 0x1D, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x28, 
	0x4B, 0x54, 0x18, 0x44, 0x46, 0x2A, 0x4C, 0x56, 0x1D, 0x40, 0x40, 0x1B, 0x3E, 0x3C, 0x1E, 0x42, 
	0x42, 0x28, 0x4C, 0x55, 0x1A, 0x3B, 0x3B, 0x1B, 0x3D, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x20, 
	0x43, 0x47, 0x20, 0x40, 0x48, 0x1C, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x0F, 0x23, 0x1E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2F, 0x1E, 0x32, 0x3C, 0x16, 
	0x40, 0x45, 0x19, 0x2B, 0x33, 0x20, 0x31, 0x38, 0x34, 0x3F, 0x3B, 0x37, 0x32, 0x26, 0x1B, 0x30, 
	0x3C, 0x11, 0x24, 0x22, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 
	0x26, 0x25, 0x18, 0x2A, 0x2F, 0x1C, 0x31, 0x3C, 0x14, 0x27, 0x27, 0x1F, 0x32, 0x3D, 0x1B, 0x2E, 
	0x35, 0x1A, 0x2C, 0x33, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1D, 0x46, 0x43, 0x1D, 0x28, 0x34, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x28, 0x3F, 0x42, 
	0x35, 0x3F, 0x3C, 0x18, 0x33, 0x3E, 0x1E, 0x43, 0x40, 0x1B, 0x3D, 0x3E, 0x18, 0x40, 0x4B, 0x1C, 
	0x45, 0x4B, 0x1F, 0x48, 0x4B, 0x18, 0x42, 0x4B, 0x16, 0x38, 0x3B, 0x14, 0x3A, 0x45, 0x14, 0x38, 
	0x3B, 0x20, 0x45, 0x49, 0x1E, 0x45, 0x48, 0x1C, 0x4D, 0x57, 0x1D, 0x44, 0x45, 0x1B, 0x3E, 0x3C, 
	0x1D, 0x3E, 0x3D, 0x1B, 0x45, 0x49, 0x28, 0x4B, 0x54, 0x20, 0x43, 0x46, 0x20, 0x44, 0x47, 0x29, 
	0x4B, 0x55, 0x1A, 0x43, 0x45, 0x2A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x19, 0x49, 0x52, 0x2A, 0x4C, 
	0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x28, 0x39, 0x67, 0x71, 0x1E, 
	0x44, 0x49, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x2B, 0x4C, 0x52, 0x18, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 
	0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x29, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x1A, 0x40, 
	0x3F, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 
	0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x40, 0x3F, 0x1C, 0x3F, 0x3E, 0x1E, 
	0x40, 0x46, 0x20, 0x45, 0x46, 0x1C, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1E, 0x30, 0x39, 0x11, 0x24, 0x22, 0x14, 0x28, 0x2E, 0x40, 
	0x3C, 0x32, 0x20, 0x30, 0x36, 0x42, 0x35, 0x30, 0x3D, 0x3A, 0x31, 0x3B, 0x39, 0x2F, 0x1A, 0x2F, 
	0x3A, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1A, 
	0x2C, 0x32, 0x1C, 0x31, 0x3C, 0x33, 0x30, 0x26, 0x16, 0x2A, 0x31, 0x11, 0x24, 0x22, 0x12, 0x25, 
	0x24, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 
	0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x42, 0x1E, 0x3C, 0x40, 0x0F, 0x36, 0x40, 0x15, 0x33, 0x3C, 
	0x3F, 0x37, 0x2A, 0x15, 0x31, 0x3C, 0x18, 0x3C, 0x40, 0x1E, 0x40, 0x3D, 0x15, 0x38, 0x3E, 0x11, 
	0x33, 0x3C, 0x18, 0x3D, 0x45, 0x1D, 0x47, 0x4A, 0x2C, 0x4C, 0x56, 0x1C, 0x4C, 0x55, 0x24, 0x46, 
	0x4A, 0x35, 0x51, 0x4F, 0x2C, 0x48, 0x4F, 0x1C, 0x43, 0x44, 0x1B, 0x3E, 0x3C, 0x2A, 0x4C, 0x57, 
	0x1B, 0x45, 0x49, 0x1B, 0x4B, 0x55, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x53, 0x29, 0x4B, 0x55, 0x22, 
	0x44, 0x46, 0x1B, 0x4B, 0x55, 0x22, 0x47, 0x4C, 0x28, 0x4A, 0x52, 0x1A, 0x49, 0x52, 0x2E, 0x4F, 
	0x52, 0x27, 0x4A, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x2A, 0x51, 0x50, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x28, 
	0x4A, 0x4F, 0x27, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x1D, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x27, 0x49, 
	0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x18, 0x4A, 0x52, 0x28, 0x4A, 0x52, 
	0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2E, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x28, 0x4A, 0x52, 0x24, 0x47, 0x4C, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x19, 0x4A, 
	0x53, 0x28, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 0x3D, 
	0x2B, 0x4E, 0x59, 0x1B, 0x39, 0x3D, 0x1C, 0x42, 0x3F, 0x1F, 0x3C, 0x45, 0x1D, 0x40, 0x45, 0x31, 
	0x3A, 0x3B, 0x1B, 0x3D, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 
	0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 
	0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x1B, 0x32, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x3A, 0x2B, 
	0x39, 0x3A, 0x15, 0x3A, 0x40, 0x45, 0x3C, 0x32, 0x48, 0x3F, 0x37, 0x36, 0x35, 0x2A, 0x16, 0x2C, 
	0x35, 0x11, 0x24, 0x22, 0x1A, 0x2C, 0x33, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x30, 0x1B, 0x30, 0x3A, 0x1D, 0x30, 0x39, 0x1F, 0x32, 0x3C, 0x15, 0x28, 
	0x29, 0x12, 0x25, 0x23, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1D, 0x2C, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x40, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 
	0x43, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x3F, 0x19, 0x3C, 0x43, 
	0x3A, 0x39, 0x31, 0x28, 0x3D, 0x43, 0x0E, 0x34, 0x3D, 0x1F, 0x4F, 0x58, 0x11, 0x33, 0x3B, 0x1F, 
	0x4F, 0x57, 0x1B, 0x40, 0x43, 0x18, 0x3C, 0x44, 0x1C, 0x44, 0x47, 0x1D, 0x48, 0x4F, 0x18, 0x3A, 
	0x3B, 0x20, 0x43, 0x48, 0x1B, 0x4A, 0x51, 0x18, 0x39, 0x3D, 0x1C, 0x3F, 0x3D, 0x28, 0x4B, 0x55, 
	0x1E, 0x40, 0x40, 0x1B, 0x3F, 0x3F, 0x1B, 0x4A, 0x53, 0x1C, 0x4A, 0x53, 0x22, 0x44, 0x46, 0x28, 
	0x4B, 0x55, 0x20, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x29, 0x4A, 0x52, 0x18, 0x49, 0x52, 0x2C, 0x4E, 
	0x52, 0x32, 0x54, 0x52, 0x2B, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x53, 0x2A, 0x4D, 0x4E, 
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x66, 0x70, 0x2A, 
	0x4C, 0x4F, 0x26, 0x49, 0x52, 0x2B, 0x4D, 0x52, 0x1A, 0x49, 0x52, 0x20, 0x49, 0x52, 0x28, 0x49, 
	0x52, 0x18, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x52, 0x26, 0x49, 0x52, 
	0x28, 0x4C, 0x53, 0x31, 0x55, 0x53, 0x19, 0x47, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4A, 0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3F, 0x3D, 0x1D, 0x39, 0x3E, 
	0x1B, 0x47, 0x4A, 0x1D, 0x3A, 0x3E, 0x1B, 0x39, 0x3D, 0x2A, 0x4E, 0x57, 0x2A, 0x4D, 0x57, 0x1A, 
	0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3D, 
	0x3F, 0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x39, 0x1C, 0x3C, 0x42, 
	0x19, 0x30, 0x39, 0x11, 0x3A, 0x43, 0x19, 0x35, 0x3D, 0x19, 0x2A, 0x2F, 0x16, 0x29, 0x2B, 0x19, 
	0x34, 0x3E, 0x14, 0x3E, 0x43, 0x52, 0x42, 0x39, 0x4B, 0x40, 0x38, 0x3E, 0x3A, 0x31, 0x1F, 0x30, 
	0x36, 0x18, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x31, 0x13, 
	0x26, 0x26, 0x12, 0x25, 0x23, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 0x1F, 0x32, 
	0x3C, 0x18, 0x2A, 0x2E, 0x1A, 0x2F, 0x36, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3D, 0x43, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1D, 0x40, 0x43, 0x1D, 0x31, 
	0x3B, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3A, 0x3F, 0x1F, 0x44, 0x45, 0x20, 0x3B, 0x3D, 
	0x36, 0x3B, 0x36, 0x2B, 0x42, 0x42, 0x1C, 0x3C, 0x3D, 0x1E, 0x4D, 0x56, 0x11, 0x33, 0x3B, 0x1E, 
	0x4D, 0x55, 0x16, 0x3C, 0x42, 0x15, 0x3B, 0x44, 0x1E, 0x4D, 0x56, 0x1B, 0x4B, 0x54, 0x1D, 0x43, 
	0x47, 0x23, 0x51, 0x56, 0x1B, 0x3D, 0x42, 0x11, 0x35, 0x3E, 0x15, 0x39, 0x3D, 0x28, 0x4B, 0x54, 
	0x29, 0x4C, 0x53, 0x26, 0x4F, 0x54, 0x1B, 0x48, 0x52, 0x1B, 0x4A, 0x53, 0x29, 0x47, 0x4D, 0x26, 
	0x4A, 0x52, 0x26, 0x49, 0x53, 0x29, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x2B, 0x4C, 0x52, 0x24, 0x47, 
	0x52, 0x2E, 0x50, 0x52, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4F, 0x51, 0x2F, 0x5A, 0x61, 
	0x04, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x24, 0x27, 0x38, 0x65, 0x6F, 0x2A, 
	0x4C, 0x4E, 0x26, 0x49, 0x52, 0x27, 0x49, 0x52, 0x18, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x29, 0x4C, 
	0x52, 0x27, 0x49, 0x52, 0x31, 0x53, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x26, 0x4A, 0x53, 
	0x29, 0x43, 0x47, 0x49, 0x47, 0x47, 0x31, 0x55, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x1B, 0x3E, 0x3C, 0x1C, 0x38, 0x3C, 
	0x24, 0x48, 0x4C, 0x1B, 0x3C, 0x3C, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x1B, 0x3C, 0x3D, 0x1D, 
	0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3F, 0x22, 0x46, 
	0x47, 0x1C, 0x3C, 0x40, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x44, 0x1C, 0x45, 0x40, 0x1F, 0x40, 0x49, 
	0x2B, 0x2E, 0x2A, 0x19, 0x31, 0x3A, 0x1B, 0x33, 0x3B, 0x13, 0x26, 0x25, 0x1F, 0x32, 0x3C, 0x16, 
	0x28, 0x2A, 0x1A, 0x30, 0x3A, 0x3D, 0x42, 0x44, 0x52, 0x48, 0x3D, 0x43, 0x3D, 0x34, 0x27, 0x24, 
	0x23, 0x0F, 0x25, 0x24, 0x20, 0x33, 0x3E, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 
	0x14, 0x26, 0x26, 0x14, 0x2C, 0x2F, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x31, 0x16, 0x29, 0x2B, 0x12, 
	0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x16, 0x29, 
	0x2C, 0x1D, 0x32, 0x3C, 0x23, 0x18, 0x15, 0x1A, 0x2F, 0x36, 0x13, 0x26, 0x25, 0x1D, 0x2F, 0x38, 
	0x1D, 0x40, 0x44, 0x1D, 0x40, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1C, 0x2B, 0x35, 0x1D, 0x30, 0x39, 0x1D, 0x38, 0x42, 0x1D, 0x2B, 
	0x35, 0x1D, 0x40, 0x42, 0x1D, 0x3D, 0x40, 0x1B, 0x3A, 0x3D, 0x2B, 0x4F, 0x59, 0x18, 0x36, 0x3E, 
	0x37, 0x3B, 0x35, 0x31, 0x40, 0x40, 0x1A, 0x43, 0x45, 0x1D, 0x4C, 0x55, 0x15, 0x3A, 0x43, 0x1D, 
	0x4D, 0x56, 0x28, 0x4A, 0x4F, 0x0F, 0x33, 0x3C, 0x16, 0x3C, 0x42, 0x2B, 0x48, 0x4F, 0x2C, 0x4F, 
	0x51, 0x5D, 0x53, 0x4D, 0x30, 0x50, 0x53, 0x13, 0x3C, 0x44, 0x20, 0x44, 0x44, 0x26, 0x49, 0x53, 
	0x2C, 0x54, 0x53, 0x58, 0x4F, 0x4A, 0x43, 0x51, 0x4D, 0x13, 0x44, 0x4E, 0x22, 0x4A, 0x53, 0x29, 
	0x4C, 0x52, 0x2A, 0x4E, 0x52, 0x3E, 0x4E, 0x4C, 0x1A, 0x48, 0x52, 0x2C, 0x4E, 0x52, 0x32, 0x54, 
	0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4D, 0x53, 0x19, 0x43, 0x4D, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x78, 0x80, 0x2A, 
	0x50, 0x58, 0x27, 0x4A, 0x51, 0x2F, 0x51, 0x52, 0x2B, 0x4D, 0x52, 0x2B, 0x4E, 0x52, 0x2E, 0x4F, 
	0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 
	0x28, 0x4C, 0x53, 0x30, 0x55, 0x53, 0x28, 0x4B, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 
	0x4F, 0x52, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4E, 0x56, 
	0x1B, 0x31, 0x3A, 0x2B, 0x50, 0x58, 0x1B, 0x2C, 0x37, 0x1C, 0x3B, 0x3E, 0x1D, 0x3E, 0x40, 0x1C, 
	0x40, 0x40, 0x1A, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3F, 0x12, 0x3E, 
	0x48, 0x1E, 0x3A, 0x3D, 0x1A, 0x29, 0x30, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x38, 0x19, 0x3C, 0x40, 
	0x40, 0x46, 0x44, 0x22, 0x33, 0x39, 0x1C, 0x2F, 0x37, 0x1F, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x1E, 
	0x31, 0x3A, 0x19, 0x2E, 0x38, 0x3E, 0x3C, 0x33, 0x4C, 0x40, 0x38, 0x46, 0x3D, 0x35, 0x3E, 0x3A, 
	0x30, 0x0D, 0x24, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x31, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 
	0x2B, 0x31, 0x15, 0x28, 0x29, 0x18, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2F, 0x39, 0x37, 0x37, 0x2E, 0x1B, 0x2F, 0x39, 0x1A, 0x32, 0x3B, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x44, 0x1D, 
	0x2E, 0x37, 0x1C, 0x2C, 0x36, 0x20, 0x46, 0x49, 0x1C, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x2E, 
	0x38, 0x1D, 0x3C, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3B, 0x40, 0x1B, 0x3C, 0x3C, 0x23, 0x49, 0x4E, 
	0x30, 0x40, 0x40, 0x35, 0x3C, 0x39, 0x1E, 0x42, 0x44, 0x1D, 0x4C, 0x55, 0x11, 0x33, 0x3C, 0x15, 
	0x37, 0x39, 0x2B, 0x4C, 0x56, 0x19, 0x43, 0x48, 0x15, 0x3F, 0x4A, 0x22, 0x3C, 0x3B, 0x56, 0x50, 
	0x4C, 0x5A, 0x55, 0x4E, 0x4F, 0x51, 0x4B, 0x1B, 0x43, 0x4B, 0x1B, 0x42, 0x42, 0x26, 0x4A, 0x54, 
	0x29, 0x4B, 0x51, 0x69, 0x59, 0x4E, 0x5A, 0x53, 0x4E, 0x1F, 0x3C, 0x3F, 0x27, 0x4A, 0x53, 0x2E, 
	0x4F, 0x52, 0x29, 0x4E, 0x52, 0x3C, 0x4D, 0x4C, 0x2B, 0x4E, 0x52, 0x28, 0x4B, 0x52, 0x24, 0x47, 
	0x52, 0x28, 0x4B, 0x52, 0x25, 0x48, 0x52, 0x2C, 0x4F, 0x52, 0x2C, 0x4E, 0x52, 0x1C, 0x49, 0x53, 
	0x09, 0x12, 0x11, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x22, 0x26, 0x38, 0x75, 0x7E, 0x29, 
	0x4E, 0x57, 0x31, 0x53, 0x51, 0x30, 0x52, 0x52, 0x31, 0x53, 0x52, 0x2B, 0x4D, 0x52, 0x15, 0x48, 
	0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x25, 0x48, 0x52, 0x32, 0x54, 0x52, 0x26, 0x49, 0x52, 
	0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4B, 0x54, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 
	0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x25, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 
	0x1B, 0x3D, 0x39, 0x1B, 0x4C, 0x56, 0x1B, 0x3B, 0x3B, 0x27, 0x4B, 0x52, 0x1A, 0x3B, 0x3C, 0x20, 
	0x3E, 0x3D, 0x3B, 0x43, 0x43, 0x19, 0x40, 0x3F, 0x18, 0x3C, 0x40, 0x1E, 0x32, 0x3B, 0x1A, 0x26, 
	0x2C, 0x1D, 0x3E, 0x43, 0x1D, 0x39, 0x3F, 0x1D, 0x2B, 0x35, 0x1D, 0x3B, 0x42, 0x1D, 0x3D, 0x42, 
	0x1A, 0x2A, 0x35, 0x1C, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x20, 0x12, 0x25, 0x23, 0x1B, 
	0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x18, 0x3D, 0x44, 0x4A, 0x3D, 0x33, 0x54, 0x4B, 0x42, 0x45, 0x3C, 
	0x33, 0x15, 0x2B, 0x34, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x1A, 0x2C, 0x32, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x1F, 
	0x31, 0x3B, 0x18, 0x28, 0x2B, 0x18, 0x37, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x30, 0x39, 0x1B, 0x30, 0x3A, 0x1C, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x39, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2F, 0x39, 0x1C, 0x3B, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 
	0x42, 0x1D, 0x3C, 0x40, 0x1C, 0x34, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x37, 0x40, 0x18, 0x3F, 0x3D, 
	0x35, 0x3C, 0x39, 0x2B, 0x3D, 0x3B, 0x1A, 0x46, 0x4A, 0x1D, 0x4B, 0x54, 0x18, 0x3E, 0x47, 0x1E, 
	0x4E, 0x56, 0x1E, 0x48, 0x4D, 0x28, 0x4C, 0x54, 0x1A, 0x4C, 0x55, 0x27, 0x40, 0x44, 0x5F, 0x59, 
	0x52, 0x62, 0x58, 0x4F, 0x58, 0x54, 0x50, 0x27, 0x40, 0x42, 0x19, 0x4A, 0x51, 0x29, 0x49, 0x4F, 
	0x3B, 0x44, 0x43, 0x48, 0x4C, 0x4A, 0x43, 0x55, 0x53, 0x1D, 0x48, 0x4F, 0x28, 0x4A, 0x53, 0x18, 
	0x4A, 0x53, 0x2C, 0x4F, 0x53, 0x31, 0x55, 0x53, 0x2B, 0x4E, 0x52, 0x30, 0x51, 0x52, 0x32, 0x54, 
	0x52, 0x2B, 0x4D, 0x52, 0x2C, 0x4E, 0x52, 0x2B, 0x4D, 0x51, 0x2F, 0x53, 0x57, 0x2E, 0x59, 0x5F, 
	0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x11, 0x20, 0x25, 0x3B, 0x7C, 0x88, 0x30, 
	0x54, 0x5B, 0x2A, 0x4C, 0x50, 0x31, 0x54, 0x53, 0x2E, 0x4F, 0x51, 0x2E, 0x50, 0x52, 0x2C, 0x4E, 
	0x51, 0x2C, 0x4E, 0x52, 0x29, 0x4B, 0x52, 0x29, 0x4B, 0x52, 0x2C, 0x50, 0x53, 0x26, 0x4A, 0x53, 
	0x27, 0x4A, 0x53, 0x27, 0x4C, 0x55, 0x23, 0x39, 0x36, 0x31, 0x55, 0x55, 0x26, 0x4A, 0x53, 0x27, 
	0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x28, 0x4B, 0x53, 0x27, 0x4B, 0x53, 0x27, 0x4A, 
	0x53, 0x27, 0x4B, 0x53, 0x28, 0x4C, 0x54, 0x1C, 0x44, 0x46, 0x28, 0x4B, 0x54, 0x28, 0x4B, 0x53, 
	0x28, 0x4B, 0x54, 0x25, 0x47, 0x4D, 0x1D, 0x44, 0x47, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x26, 
	0x4A, 0x54, 0x37, 0x4F, 0x4D, 0x2E, 0x3F, 0x3E, 0x0E, 0x35, 0x40, 0x1A, 0x3C, 0x3F, 0x22, 0x42, 
	0x49, 0x1C, 0x3E, 0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3B, 0x43, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3B, 0x14, 0x27, 0x28, 0x14, 
	0x27, 0x27, 0x1B, 0x2C, 0x33, 0x19, 0x3C, 0x44, 0x3B, 0x3A, 0x33, 0x54, 0x4B, 0x40, 0x48, 0x3E, 
	0x34, 0x1E, 0x33, 0x3B, 0x16, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x19, 0x2B, 0x31, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x32, 0x1C, 0x2E, 0x36, 0x18, 
	0x35, 0x3D, 0x18, 0x35, 0x3E, 0x1E, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x14, 0x27, 0x27, 0x16, 0x29, 0x2C, 0x23, 0x2F, 0x33, 0x1C, 0x37, 0x3F, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x42, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x2F, 
	0x3A, 0x1B, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x1C, 0x3F, 0x3F, 0x1B, 0x3F, 0x3D, 0x29, 0x4E, 0x59, 
	0x2B, 0x44, 0x47, 0x50, 0x3C, 0x30, 0x19, 0x49, 0x52, 0x1C, 0x4B, 0x54, 0x1E, 0x4C, 0x51, 0x16, 
	0x43, 0x4D, 0x1E, 0x3E, 0x48, 0x1A, 0x42, 0x4B, 0x1A, 0x46, 0x4C, 0x50, 0x5E, 0x61, 0x69, 0x5B, 
	0x4A, 0x55, 0x4C, 0x3F, 0x49, 0x4B, 0x46, 0x22, 0x48, 0x50, 0x24, 0x3E, 0x48, 0x23, 0x3E, 0x49, 
	0x24, 0x46, 0x4B, 0x43, 0x44, 0x3D, 0x40, 0x47, 0x44, 0x22, 0x3F, 0x48, 0x31, 0x4E, 0x4E, 0x22, 
	0x3D, 0x47, 0x25, 0x40, 0x48, 0x26, 0x43, 0x4B, 0x1C, 0x49, 0x53, 0x1C, 0x47, 0x52, 0x29, 0x53, 
	0x58, 0x28, 0x53, 0x57, 0x28, 0x53, 0x57, 0x28, 0x52, 0x57, 0x2B, 0x56, 0x5D, 0x30, 0x54, 0x5F, 
	0x03, 0x08, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x12, 0x24, 0x25, 0x39, 0x71, 0x7F, 0x2E, 
	0x56, 0x5D, 0x27, 0x53, 0x57, 0x27, 0x46, 0x4B, 0x2A, 0x57, 0x5F, 0x34, 0x51, 0x55, 0x2A, 0x56, 
	0x5D, 0x27, 0x52, 0x56, 0x28, 0x52, 0x56, 0x28, 0x54, 0x58, 0x24, 0x3E, 0x46, 0x25, 0x43, 0x4A, 
	0x29, 0x50, 0x4D, 0x25, 0x43, 0x4A, 0x28, 0x45, 0x4A, 0x28, 0x43, 0x47, 0x23, 0x44, 0x4D, 0x24, 
	0x3E, 0x48, 0x23, 0x3E, 0x48, 0x27, 0x45, 0x4B, 0x18, 0x42, 0x4B, 0x27, 0x40, 0x48, 0x29, 0x4D, 
	0x4D, 0x25, 0x44, 0x4A, 0x23, 0x3E, 0x48, 0x24, 0x3E, 0x49, 0x23, 0x40, 0x4A, 0x23, 0x40, 0x4A, 
	0x28, 0x4C, 0x54, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x47, 0x4E, 0x35, 0x3F, 0x3E, 0x1B, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1C, 0x3E, 
	0x3F, 0x1D, 0x35, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x1E, 
	0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1B, 0x31, 0x3B, 0x2B, 0x3C, 0x3D, 0x4E, 0x40, 0x37, 0x4E, 0x40, 
	0x37, 0x28, 0x42, 0x46, 0x0E, 0x22, 0x1F, 0x1A, 0x2C, 0x32, 0x12, 0x25, 0x24, 0x14, 0x27, 0x27, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x1A, 0x2C, 0x32, 0x11, 0x24, 0x22, 0x15, 0x27, 0x28, 0x19, 
	0x36, 0x40, 0x19, 0x35, 0x3D, 0x16, 0x35, 0x3E, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x18, 0x29, 0x2C, 0x1B, 0x39, 0x45, 0x37, 0x35, 0x2A, 0x1A, 0x2C, 0x37, 0x1C, 0x2F, 0x37, 
	0x1A, 0x2A, 0x31, 0x1D, 0x3F, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3F, 0x43, 0x1D, 
	0x2C, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x38, 
	0x3E, 0x28, 0x4D, 0x54, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1D, 0x3F, 0x3E, 0x1A, 0x3D, 0x3B, 
	0x24, 0x3F, 0x40, 0x4D, 0x3D, 0x33, 0x37, 0x44, 0x44, 0x1E, 0x48, 0x4C, 0x1A, 0x2B, 0x32, 0x13, 
	0x12, 0x0E, 0x07, 0x03, 0x00, 0x07, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x00, 0x06, 0x03, 0x09, 0x0B, 
	0x09, 0x07, 0x00, 0x00, 0x00, 0x08, 0x07, 0x06, 0x09, 0x06, 0x0B, 0x07, 0x02, 0x0B, 0x03, 0x00, 
	0x06, 0x03, 0x00, 0x0B, 0x02, 0x00, 0x06, 0x06, 0x02, 0x14, 0x09, 0x0D, 0x03, 0x08, 0x03, 0x14, 
	0x09, 0x0D, 0x0F, 0x06, 0x06, 0x09, 0x02, 0x00, 0x07, 0x09, 0x04, 0x07, 0x08, 0x04, 0x06, 0x07, 
	0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x06, 0x07, 0x03, 0x09, 0x0B, 0x0B, 0x06, 0x03, 0x00, 
	0x0E, 0x0D, 0x11, 0x0B, 0x0B, 0x0E, 0x09, 0x0B, 0x0E, 0x0F, 0x09, 0x0D, 0x08, 0x0C, 0x08, 0x06, 
	0x06, 0x02, 0x06, 0x07, 0x03, 0x06, 0x08, 0x04, 0x06, 0x06, 0x02, 0x0C, 0x0E, 0x12, 0x08, 0x09, 
	0x08, 0x0C, 0x0D, 0x0F, 0x0C, 0x0D, 0x0F, 0x0C, 0x0E, 0x11, 0x13, 0x08, 0x0B, 0x13, 0x08, 0x0B, 
	0x0B, 0x0F, 0x12, 0x13, 0x08, 0x09, 0x13, 0x08, 0x0C, 0x0F, 0x0C, 0x0E, 0x0D, 0x11, 0x13, 0x06, 
	0x06, 0x00, 0x0E, 0x03, 0x00, 0x06, 0x02, 0x00, 0x07, 0x07, 0x03, 0x09, 0x00, 0x00, 0x08, 0x0C, 
	0x0C, 0x14, 0x09, 0x0C, 0x0F, 0x06, 0x04, 0x0C, 0x08, 0x07, 0x0B, 0x0E, 0x12, 0x04, 0x0C, 0x08, 
	0x24, 0x47, 0x4D, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x18, 0x3D, 0x3C, 0x1F, 0x43, 0x45, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 
	0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x14, 0x27, 0x27, 0x1B, 0x2B, 0x33, 0x16, 0x3F, 0x45, 0x3C, 0x3C, 0x34, 0x4D, 0x40, 
	0x37, 0x44, 0x47, 0x44, 0x15, 0x2B, 0x34, 0x14, 0x27, 0x28, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x1F, 0x32, 0x3D, 0x14, 0x27, 0x27, 0x15, 
	0x27, 0x28, 0x19, 0x2A, 0x2E, 0x1B, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x39, 0x16, 0x29, 0x2B, 0x1D, 0x2F, 0x38, 0x1B, 0x2E, 0x38, 0x1C, 0x3D, 0x40, 0x27, 0x31, 0x34, 
	0x1C, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x44, 0x42, 0x1D, 
	0x2B, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x43, 0x40, 0x1B, 0x3A, 
	0x3D, 0x1B, 0x37, 0x3D, 0x1C, 0x3A, 0x3E, 0x25, 0x48, 0x4C, 0x1B, 0x48, 0x4F, 0x1C, 0x4C, 0x56, 
	0x1F, 0x44, 0x46, 0x37, 0x36, 0x2E, 0x36, 0x3A, 0x34, 0x1A, 0x49, 0x4E, 0x1B, 0x28, 0x32, 0x33, 
	0x66, 0x71, 0x3A, 0x95, 0xA7, 0x3B, 0x95, 0xA6, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x94, 
	0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 
	0x3B, 0x94, 0xA5, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3A, 0x93, 0xA3, 0x3B, 0x93, 0xA4, 0x3A, 
	0x94, 0xA4, 0x3A, 0x93, 0xA4, 0x3B, 0x95, 0xA5, 0x3B, 0x94, 0xA5, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 
	0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x94, 0xA5, 
	0x3A, 0x93, 0xA4, 0x3B, 0x94, 0xA4, 0x3B, 0x94, 0xA4, 0x3A, 0x94, 0xA4, 0x3A, 0x92, 0xA3, 0x3B, 
	0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x92, 0xA3, 0x3A, 0x91, 
	0xA2, 0x3D, 0x97, 0xAC, 0x3A, 0x92, 0xA2, 0x3A, 0x92, 0xA3, 0x3A, 0x93, 0xA3, 0x39, 0x92, 0xA2, 
	0x3A, 0x91, 0xA1, 0x3D, 0x99, 0xAD, 0x39, 0x92, 0xA2, 0x3A, 0x93, 0xA3, 0x3A, 0x92, 0xA3, 0x3A, 
	0x92, 0xA3, 0x3A, 0x93, 0xA4, 0x3B, 0x93, 0xA4, 0x3A, 0x91, 0xA2, 0x42, 0xA3, 0xB0, 0x3A, 0x91, 
	0xA2, 0x3A, 0x93, 0xA3, 0x39, 0x91, 0xA2, 0x43, 0x9C, 0xB0, 0x5C, 0xB6, 0xC5, 0x0B, 0x0F, 0x12, 
	0x24, 0x40, 0x4A, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 
	0x48, 0x4E, 0x27, 0x4A, 0x53, 0x22, 0x45, 0x49, 0x28, 0x4C, 0x56, 0x24, 0x47, 0x4B, 0x1C, 0x3C, 
	0x3E, 0x1D, 0x42, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x38, 0x1B, 0x2E, 0x34, 0x18, 0x2A, 0x2E, 0x1C, 0x31, 0x3A, 0x1E, 0x31, 0x37, 0x4A, 0x3F, 
	0x35, 0x4F, 0x40, 0x39, 0x1F, 0x2F, 0x34, 0x1A, 0x2C, 0x34, 0x1B, 0x2E, 0x35, 0x13, 0x26, 0x25, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 0x23, 0x1F, 0x31, 0x3B, 0x1C, 0x35, 0x3F, 0x15, 
	0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1A, 0x33, 0x3C, 0x1E, 0x31, 0x3A, 0x1A, 0x2A, 0x31, 0x1D, 0x3E, 0x44, 0x1C, 0x2E, 0x37, 
	0x1A, 0x2B, 0x31, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3C, 0x43, 0x1D, 
	0x2C, 0x35, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x1B, 0x39, 0x3D, 0x2A, 0x4F, 
	0x59, 0x1E, 0x40, 0x43, 0x1C, 0x37, 0x3E, 0x1F, 0x3D, 0x44, 0x29, 0x4C, 0x56, 0x1D, 0x49, 0x53, 
	0x1D, 0x42, 0x43, 0x35, 0x49, 0x4C, 0x33, 0x3D, 0x3A, 0x1B, 0x46, 0x4D, 0x19, 0x29, 0x32, 0x3B, 
	0x77, 0x84, 0x3C, 0xA1, 0xBB, 0x40, 0xA4, 0xBD, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBB, 0x40, 0xA2, 
	0xBC, 0x40, 0xA2, 0xBC, 0x3F, 0xA1, 0xBB, 0x3F, 0xA1, 0xBC, 0x3F, 0xA1, 0xBB, 0x44, 0xAA, 0xC2, 
	0x44, 0xAA, 0xC2, 0x3F, 0xA0, 0xBA, 0x44, 0xA9, 0xC1, 0x46, 0xB1, 0xC5, 0x47, 0xB2, 0xC6, 0x3E, 
	0x9F, 0xB9, 0x47, 0xB3, 0xC7, 0x3F, 0xA0, 0xBA, 0x3F, 0xA0, 0xBA, 0x47, 0xB2, 0xC5, 0x46, 0xB1, 
	0xC5, 0x43, 0xA8, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 0xB1, 0xC5, 0x43, 0xA8, 0xC0, 0x43, 0xA8, 0xC0, 
	0x47, 0xB2, 0xC5, 0x43, 0xA8, 0xC0, 0x44, 0xA9, 0xC1, 0x43, 0xA9, 0xC0, 0x46, 0xB1, 0xC5, 0x46, 
	0xB1, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x46, 0xB1, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 
	0xCD, 0x49, 0xBA, 0xCC, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xAF, 0xC4, 0x49, 0xBB, 0xCD, 
	0x49, 0xBB, 0xCD, 0x45, 0xAF, 0xC4, 0x46, 0xB0, 0xC5, 0x46, 0xB0, 0xC5, 0x45, 0xAF, 0xC4, 0x4A, 
	0xBC, 0xCE, 0x46, 0xAF, 0xC4, 0x46, 0xB0, 0xC4, 0x45, 0xB5, 0xC9, 0x4C, 0xC0, 0xCF, 0x45, 0xB2, 
	0xC6, 0x46, 0xAF, 0xC4, 0x4A, 0xBE, 0xCF, 0x40, 0xA3, 0xBE, 0x43, 0xA7, 0xBB, 0x0C, 0x0E, 0x11, 
	0x23, 0x3D, 0x47, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x18, 
	0x35, 0x38, 0x28, 0x4C, 0x55, 0x1D, 0x40, 0x42, 0x2A, 0x4A, 0x51, 0x1E, 0x3C, 0x45, 0x1C, 0x40, 
	0x3F, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 0x3E, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x44, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1E, 0x2F, 0x39, 0x13, 0x25, 0x25, 0x1D, 0x32, 0x3B, 0x18, 0x3E, 0x44, 0x3C, 0x3B, 
	0x33, 0x57, 0x4B, 0x3F, 0x30, 0x3F, 0x44, 0x1A, 0x2E, 0x38, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2A, 0x2F, 0x18, 
	0x2A, 0x2F, 0x1B, 0x2E, 0x34, 0x1E, 0x30, 0x39, 0x13, 0x26, 0x25, 0x1C, 0x30, 0x39, 0x28, 0x33, 
	0x35, 0x1A, 0x2C, 0x34, 0x0F, 0x23, 0x1E, 0x1E, 0x31, 0x3A, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 
	0x30, 0x39, 0x1D, 0x37, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x1E, 0x43, 
	0x43, 0x2A, 0x4E, 0x59, 0x1B, 0x3F, 0x3D, 0x1B, 0x3D, 0x3F, 0x27, 0x39, 0x3B, 0x34, 0x57, 0x56, 
	0x1B, 0x42, 0x44, 0x1A, 0x3E, 0x3E, 0x37, 0x3A, 0x34, 0x12, 0x40, 0x48, 0x1A, 0x2A, 0x33, 0x3A, 
	0x75, 0x81, 0x3B, 0x9D, 0xB6, 0x47, 0xB3, 0xC5, 0x4B, 0xC3, 0xD2, 0x4B, 0xC0, 0xCF, 0x48, 0xB5, 
	0xC6, 0x48, 0xB5, 0xC6, 0x4B, 0xC0, 0xCF, 0x4B, 0xBC, 0xCB, 0x4B, 0xC0, 0xCF, 0x4A, 0xBC, 0xCB, 
	0x4A, 0xBB, 0xCA, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4B, 0xC1, 0xD0, 0x4A, 0xBF, 0xCF, 0x4B, 
	0xC0, 0xCF, 0x4A, 0xC3, 0xD3, 0x4B, 0xC0, 0xCF, 0x4B, 0xC0, 0xCF, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 
	0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 0xD2, 0x4A, 0xBD, 0xCC, 0x4A, 0xBD, 0xCC, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBF, 0xCE, 0x4A, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4A, 0xC4, 0xD3, 0x4F, 0xC5, 0xD9, 
	0x4D, 0xC4, 0xD5, 0x49, 0xC4, 0xD3, 0x4D, 0xC4, 0xD4, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4C, 
	0xC3, 0xD5, 0x4A, 0xC4, 0xD3, 0x4D, 0xC4, 0xD5, 0x4D, 0xC4, 0xD5, 0x49, 0xC3, 0xD3, 0x4A, 0xC4, 
	0xD3, 0x4A, 0xC5, 0xD4, 0x4B, 0xC3, 0xD1, 0x3A, 0x98, 0xB2, 0x3B, 0x94, 0xA4, 0x06, 0x08, 0x03, 
	0x28, 0x48, 0x4E, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 
	0x4B, 0x54, 0x27, 0x4A, 0x53, 0x1C, 0x42, 0x42, 0x35, 0x3E, 0x3D, 0x20, 0x3F, 0x3D, 0x1C, 0x40, 
	0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3F, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x3E, 0x43, 0x1C, 0x42, 0x3F, 0x1D, 0x3A, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 
	0x2E, 0x37, 0x1D, 0x3D, 0x44, 0x1D, 0x3B, 0x42, 0x1D, 0x2C, 0x36, 0x1B, 0x3C, 0x44, 0x25, 0x33, 
	0x36, 0x53, 0x48, 0x3D, 0x4D, 0x42, 0x36, 0x1A, 0x28, 0x28, 0x18, 0x2A, 0x30, 0x1A, 0x2C, 0x32, 
	0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 
	0x31, 0x3A, 0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1E, 0x2F, 0x38, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 
	0x38, 0x1D, 0x30, 0x38, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x40, 0x43, 0x1D, 0x2A, 0x34, 0x1D, 0x38, 0x3F, 0x1D, 
	0x3D, 0x42, 0x1D, 0x44, 0x40, 0x1D, 0x3C, 0x40, 0x1C, 0x40, 0x3E, 0x20, 0x45, 0x46, 0x1C, 0x33, 
	0x3E, 0x1B, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1B, 0x3F, 0x3E, 0x25, 0x43, 0x46, 0x32, 0x50, 0x4F, 
	0x2B, 0x40, 0x44, 0x48, 0x4C, 0x4D, 0x4D, 0x3D, 0x34, 0x1D, 0x34, 0x3D, 0x14, 0x29, 0x2F, 0x3A, 
	0x75, 0x82, 0x3B, 0x9C, 0xB5, 0x49, 0xBB, 0xCC, 0x4A, 0xBF, 0xCF, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xB9, 0xC9, 
	0x4A, 0xBB, 0xCB, 0x4A, 0xC5, 0xD4, 0x49, 0xBE, 0xD0, 0x46, 0xB5, 0xCB, 0x4B, 0xC6, 0xD5, 0x4A, 
	0xC4, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC4, 0xD4, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x4A, 0xC4, 0xD2, 0x52, 0xBE, 0xD9, 
	0x48, 0xBE, 0xD0, 0x4C, 0xC3, 0xD4, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4C, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 
	0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC3, 0xD1, 0x34, 0x8C, 0xA6, 0x3B, 0x95, 0xA4, 0x0E, 0x11, 0x14, 
	0x1C, 0x44, 0x4D, 0x28, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1B, 0x40, 0x40, 0x2A, 0x4D, 0x59, 0x1B, 0x3F, 
	0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x3E, 0x43, 0x1C, 0x29, 0x34, 0x20, 0x45, 0x49, 0x1C, 0x43, 0x40, 0x1E, 0x30, 0x39, 0x1D, 
	0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x16, 0x2B, 
	0x37, 0x4C, 0x42, 0x36, 0x5C, 0x51, 0x4B, 0x2A, 0x3E, 0x3F, 0x0E, 0x22, 0x20, 0x15, 0x28, 0x2A, 
	0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2F, 0x1D, 
	0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x45, 0x1A, 0x2A, 0x30, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x3F, 0x40, 0x1D, 
	0x3B, 0x40, 0x1D, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x1C, 0x47, 0x4C, 0x25, 0x47, 0x4C, 0x1C, 0x40, 
	0x3E, 0x1C, 0x3F, 0x3E, 0x22, 0x45, 0x4A, 0x20, 0x46, 0x4B, 0x19, 0x3A, 0x3C, 0x26, 0x48, 0x50, 
	0x38, 0x40, 0x3E, 0x2B, 0x51, 0x51, 0x45, 0x47, 0x44, 0x32, 0x31, 0x29, 0x1F, 0x1E, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 
	0x4A, 0xC5, 0xD4, 0x49, 0xC0, 0xD4, 0x37, 0x82, 0x93, 0x31, 0x69, 0x78, 0x46, 0xB8, 0xD0, 0x4B, 
	0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 
	0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 0xD4, 0x50, 0xC5, 0xD7, 0x4D, 0xB8, 0xD0, 0x00, 0x00, 0x00, 
	0x3B, 0x9C, 0xB1, 0x59, 0xCD, 0xE4, 0x48, 0xC5, 0xD4, 0x4F, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB1, 0x42, 0xA1, 0xB7, 0x06, 0x08, 0x03, 
	0x28, 0x42, 0x48, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x1B, 0x3B, 
	0x3D, 0x1D, 0x40, 0x40, 0x1B, 0x38, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 
	0x1D, 0x3D, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2E, 0x37, 0x1E, 0x3E, 0x42, 0x0F, 0x39, 0x43, 0x1B, 
	0x31, 0x39, 0x1B, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x12, 0x35, 
	0x3F, 0x3C, 0x36, 0x2A, 0x4F, 0x44, 0x39, 0x3F, 0x42, 0x44, 0x1B, 0x31, 0x36, 0x19, 0x2E, 0x35, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1F, 0x32, 0x3D, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x32, 0x3A, 0x1D, 0x31, 0x39, 0x1D, 0x3C, 0x45, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1A, 0x32, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x3B, 0x44, 
	0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 
	0x42, 0x40, 0x1C, 0x3A, 0x3E, 0x1D, 0x39, 0x3D, 0x1D, 0x3F, 0x3D, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 
	0x3F, 0x1E, 0x42, 0x44, 0x28, 0x4E, 0x56, 0x3D, 0x4C, 0x4B, 0x22, 0x43, 0x45, 0x16, 0x48, 0x4F, 
	0x23, 0x48, 0x4F, 0x20, 0x48, 0x50, 0x23, 0x4D, 0x57, 0x25, 0x39, 0x40, 0x14, 0x28, 0x2E, 0x3A, 
	0x75, 0x82, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD2, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC6, 0xD5, 
	0x4F, 0xC0, 0xD7, 0x36, 0x6E, 0x7B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x2C, 0x52, 0x58, 0x46, 
	0xB9, 0xD0, 0x4B, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xBA, 0xCA, 
	0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 0x4A, 0xBC, 0xCC, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 
	0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC3, 0xD2, 0x4B, 0xC2, 0xD4, 0x2F, 0x76, 0x82, 0x02, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x24, 0x51, 0x5B, 0x4F, 0xBF, 0xD5, 0x50, 0xC8, 0xD9, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x54, 0xC2, 0xDC, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3E, 0x9B, 0xAE, 0x07, 0x09, 0x04, 
	0x24, 0x45, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x53, 0x1F, 0x43, 0x45, 0x27, 0x4A, 0x53, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x42, 0x2A, 0x4D, 
	0x58, 0x1A, 0x3D, 0x3B, 0x2B, 0x4F, 0x5A, 0x1B, 0x38, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x42, 0x1D, 0x2A, 0x35, 0x1D, 0x3D, 0x43, 0x1D, 0x2B, 0x35, 0x18, 0x34, 0x3C, 0x1B, 
	0x31, 0x39, 0x11, 0x3B, 0x44, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2C, 
	0x36, 0x25, 0x34, 0x38, 0x4D, 0x40, 0x37, 0x4D, 0x40, 0x36, 0x31, 0x3B, 0x36, 0x2B, 0x2E, 0x30, 
	0x1D, 0x31, 0x3B, 0x14, 0x27, 0x27, 0x15, 0x28, 0x29, 0x14, 0x27, 0x28, 0x1E, 0x31, 0x3B, 0x1D, 
	0x30, 0x39, 0x1A, 0x2B, 0x31, 0x1D, 0x36, 0x3F, 0x16, 0x28, 0x2A, 0x1D, 0x2E, 0x37, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x38, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3D, 0x42, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1C, 
	0x3A, 0x3E, 0x28, 0x4B, 0x52, 0x1B, 0x4C, 0x56, 0x1C, 0x47, 0x4B, 0x20, 0x44, 0x46, 0x1B, 0x3E, 
	0x3D, 0x20, 0x45, 0x49, 0x29, 0x45, 0x4A, 0x49, 0x3E, 0x39, 0x2E, 0x3B, 0x39, 0x39, 0x50, 0x53, 
	0x28, 0x48, 0x4B, 0x37, 0x35, 0x2A, 0x36, 0x43, 0x45, 0x1A, 0x46, 0x4C, 0x19, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC4, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC8, 0xD7, 0x4C, 0xB5, 0xCE, 
	0x0B, 0x0B, 0x07, 0x00, 0x00, 0x00, 0x07, 0x04, 0x04, 0x06, 0x03, 0x03, 0x03, 0x04, 0x00, 0x42, 
	0x98, 0xAB, 0x49, 0xC0, 0xD2, 0x4A, 0xC3, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 
	0xBD, 0xCD, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD4, 0x51, 0xC7, 0xDC, 0x40, 0xA7, 0xBB, 0x02, 0x03, 0x02, 0x07, 0x03, 0x03, 
	0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x0E, 0x29, 0x2E, 0x4B, 0xB2, 0xC9, 0x4B, 0xC6, 0xD6, 0x4C, 
	0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4D, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD0, 0x3A, 0x98, 0xB2, 0x3B, 0x95, 0xA5, 0x07, 0x09, 0x06, 
	0x24, 0x44, 0x4E, 0x27, 0x4B, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4B, 0x54, 0x19, 0x3C, 0x39, 0x1B, 0x3E, 0x3D, 0x23, 0x46, 
	0x4B, 0x1B, 0x3F, 0x3D, 0x1B, 0x3B, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 0x40, 0x40, 0x1D, 0x2F, 0x38, 0x1B, 0x31, 0x39, 0x1E, 
	0x2F, 0x37, 0x1B, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3D, 
	0x43, 0x15, 0x3B, 0x44, 0x50, 0x42, 0x37, 0x52, 0x49, 0x3E, 0x34, 0x3A, 0x33, 0x27, 0x31, 0x31, 
	0x18, 0x32, 0x3B, 0x1E, 0x30, 0x39, 0x14, 0x27, 0x28, 0x1F, 0x32, 0x3C, 0x13, 0x26, 0x26, 0x18, 
	0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x3A, 
	0x43, 0x1D, 0x31, 0x39, 0x1D, 0x2C, 0x36, 0x1D, 0x43, 0x43, 0x1A, 0x2E, 0x38, 0x1D, 0x38, 0x42, 
	0x1D, 0x3D, 0x40, 0x1D, 0x3D, 0x42, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 
	0x36, 0x40, 0x1B, 0x3C, 0x3D, 0x24, 0x46, 0x4B, 0x1C, 0x3E, 0x3D, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4B, 0x27, 0x4B, 0x55, 0x27, 0x46, 0x4B, 0x4F, 0x3F, 0x35, 0x4D, 0x3E, 0x34, 0x3E, 0x3A, 0x36, 
	0x54, 0x53, 0x4F, 0x46, 0x3A, 0x39, 0x45, 0x48, 0x48, 0x3C, 0x50, 0x51, 0x1E, 0x1B, 0x1D, 0x3A, 
	0x76, 0x83, 0x3B, 0x9C, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 0xCA, 0x4A, 0xBA, 
	0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC7, 0xD6, 0x4C, 0xB5, 0xCE, 0x0C, 0x0D, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x0F, 
	0x25, 0x27, 0x50, 0xBE, 0xD5, 0x4A, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC5, 0xD4, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4D, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 0xC2, 0xD7, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x4B, 0xC3, 0xD4, 0x4E, 0xC4, 0xD8, 0x30, 0x6C, 0x79, 0x02, 0x03, 0x00, 0x07, 0x06, 0x06, 
	0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x07, 0x00, 0x00, 0x00, 0x13, 0x22, 0x23, 0x47, 0xB1, 0xC8, 0x54, 
	0xC6, 0xDF, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4F, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x09, 0x06, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x27, 
	0x4A, 0x52, 0x27, 0x4A, 0x52, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1E, 0x42, 0x43, 0x1A, 0x3D, 
	0x3C, 0x23, 0x46, 0x4B, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1B, 
	0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 
	0x39, 0x19, 0x2C, 0x37, 0x3D, 0x37, 0x2A, 0x4D, 0x42, 0x39, 0x36, 0x35, 0x2F, 0x38, 0x2E, 0x27, 
	0x18, 0x32, 0x3C, 0x1B, 0x2B, 0x31, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 0x1A, 
	0x2C, 0x32, 0x1D, 0x35, 0x3D, 0x1D, 0x38, 0x40, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 
	0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x36, 0x1A, 0x45, 0x43, 0x3B, 0x35, 0x2B, 0x1A, 0x38, 0x43, 
	0x1D, 0x31, 0x3A, 0x1D, 0x40, 0x40, 0x1A, 0x39, 0x40, 0x1D, 0x39, 0x40, 0x1D, 0x44, 0x40, 0x1D, 
	0x35, 0x40, 0x1D, 0x43, 0x40, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3E, 0x23, 0x46, 
	0x4A, 0x28, 0x4B, 0x54, 0x29, 0x46, 0x4B, 0x44, 0x3B, 0x30, 0x50, 0x52, 0x53, 0x20, 0x19, 0x15, 
	0x4F, 0x49, 0x3E, 0x50, 0x45, 0x3D, 0x47, 0x4B, 0x49, 0x2E, 0x5A, 0x5C, 0x15, 0x28, 0x32, 0x3B, 
	0x76, 0x82, 0x3B, 0x9D, 0xB6, 0x46, 0xAE, 0xC3, 0x4A, 0xBB, 0xCB, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 
	0xC9, 0x4A, 0xBB, 0xCB, 0x4B, 0xC5, 0xD4, 0x4E, 0xBB, 0xD1, 0x0B, 0x0B, 0x08, 0x00, 0x00, 0x00, 
	0x0C, 0x0F, 0x0F, 0x0B, 0x0E, 0x0E, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x08, 0x09, 0x09, 0x00, 
	0x00, 0x00, 0x2F, 0x68, 0x76, 0x4B, 0xC3, 0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC4, 0xD4, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 0xCC, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC1, 
	0xD5, 0x54, 0xCC, 0xE0, 0x3A, 0x8C, 0x9C, 0x00, 0x00, 0x00, 0x08, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x07, 0x07, 0x07, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x12, 0x18, 0x15, 0x4A, 
	0xB5, 0xCB, 0x51, 0xC6, 0xDC, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xDC, 0x51, 0xC2, 
	0xD3, 0x47, 0xC2, 0xD1, 0x50, 0xC2, 0xD5, 0x3A, 0x98, 0xB2, 0x3B, 0x96, 0xA6, 0x0D, 0x02, 0x00, 
	0x29, 0x4A, 0x4E, 0x2E, 0x50, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 
	0x4A, 0x52, 0x27, 0x4B, 0x54, 0x19, 0x43, 0x45, 0x28, 0x4A, 0x53, 0x28, 0x4B, 0x54, 0x23, 0x46, 
	0x4A, 0x29, 0x4C, 0x56, 0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1E, 0x3C, 0x40, 0x1D, 
	0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1D, 0x2E, 0x36, 0x1B, 0x33, 0x3C, 0x53, 0x44, 0x39, 0x37, 0x32, 0x2F, 0x2B, 0x2F, 0x2B, 
	0x16, 0x32, 0x3D, 0x15, 0x39, 0x43, 0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 
	0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x3F, 0x43, 0x1A, 0x31, 0x3B, 0x1D, 0x39, 0x42, 
	0x1D, 0x31, 0x3A, 0x1A, 0x3C, 0x40, 0x38, 0x44, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x36, 0x40, 0x1D, 
	0x44, 0x40, 0x1D, 0x37, 0x40, 0x1C, 0x40, 0x3E, 0x1C, 0x3F, 0x3E, 0x1C, 0x3F, 0x3E, 0x24, 0x46, 
	0x4A, 0x18, 0x4B, 0x55, 0x1C, 0x46, 0x4C, 0x45, 0x3B, 0x31, 0x90, 0x89, 0x82, 0x54, 0x4E, 0x42, 
	0x43, 0x3B, 0x33, 0x4F, 0x46, 0x3C, 0x61, 0x52, 0x48, 0x4E, 0x75, 0x82, 0x1A, 0x1E, 0x22, 0x34, 
	0x70, 0x7B, 0x3B, 0x9D, 0xB6, 0x49, 0xB6, 0xC7, 0x4A, 0xBA, 0xCA, 0x4A, 0xB9, 0xC9, 0x4A, 0xBB, 
	0xCB, 0x4A, 0xC5, 0xD5, 0x4B, 0xC5, 0xD8, 0x26, 0x53, 0x5E, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x03, 0x03, 0x06, 0x09, 0x09, 0x43, 0xAB, 0xC0, 0x4C, 0xC5, 0xD4, 0x4A, 0xC2, 0xD2, 0x4A, 0xC3, 
	0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x49, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xB9, 0xC9, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC5, 
	0xD8, 0x55, 0xC1, 0xDA, 0x03, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 
	0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x13, 
	0x18, 0x15, 0x47, 0xB0, 0xC7, 0x51, 0xC5, 0xDA, 0x4B, 0xC2, 0xD4, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 
	0xD1, 0x4F, 0xC2, 0xD7, 0x50, 0xC2, 0xD4, 0x3A, 0x97, 0xB1, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x47, 0x4E, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4A, 0x52, 0x28, 
	0x46, 0x4D, 0x2E, 0x44, 0x47, 0x1A, 0x4B, 0x54, 0x26, 0x4A, 0x52, 0x29, 0x4B, 0x54, 0x19, 0x3C, 
	0x38, 0x2A, 0x4D, 0x58, 0x1B, 0x3C, 0x3D, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x42, 0x40, 0x1D, 
	0x42, 0x42, 0x1D, 0x2F, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x34, 0x3C, 0x11, 0x3A, 
	0x43, 0x1E, 0x32, 0x3A, 0x19, 0x2E, 0x38, 0x38, 0x3B, 0x32, 0x38, 0x3A, 0x2F, 0x3B, 0x2F, 0x31, 
	0x29, 0x28, 0x25, 0x13, 0x26, 0x27, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x32, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2B, 0x35, 0x1D, 0x3A, 0x43, 0x1D, 0x31, 0x3A, 
	0x1D, 0x3D, 0x42, 0x1C, 0x3E, 0x3F, 0x1A, 0x35, 0x40, 0x1D, 0x37, 0x40, 0x1D, 0x37, 0x40, 0x1D, 
	0x3B, 0x40, 0x1B, 0x40, 0x3D, 0x23, 0x46, 0x4A, 0x20, 0x43, 0x4B, 0x18, 0x38, 0x3D, 0x23, 0x44, 
	0x46, 0x30, 0x46, 0x49, 0x47, 0x45, 0x3F, 0x28, 0x29, 0x1F, 0x65, 0x62, 0x5D, 0x61, 0x57, 0x4D, 
	0x32, 0x2E, 0x2C, 0x36, 0x36, 0x2C, 0x51, 0x48, 0x3E, 0x5B, 0x52, 0x4A, 0x1F, 0x28, 0x27, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4A, 0xBB, 0xCB, 0x4A, 0xB8, 0xC8, 0x4A, 0xC5, 
	0xD4, 0x4C, 0xC4, 0xD7, 0x2F, 0x74, 0x80, 0x07, 0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x02, 0x00, 0x1D, 0x43, 0x49, 0x47, 0xBA, 0xD1, 0x4B, 0xC0, 0xCF, 0x4A, 0xB6, 
	0xC6, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC3, 0xD3, 
	0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD6, 0x4F, 0xC3, 
	0xDB, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x00, 
	0x00, 0x00, 0x15, 0x29, 0x2E, 0x4F, 0xBC, 0xD3, 0x4F, 0xC5, 0xD9, 0x4A, 0xC2, 0xD3, 0x4C, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC1, 0xD4, 0x3C, 0x9D, 0xB6, 0x3B, 0x96, 0xA6, 0x09, 0x07, 0x03, 
	0x26, 0x43, 0x4A, 0x27, 0x4B, 0x53, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x49, 0x52, 0x38, 
	0x54, 0x52, 0x2B, 0x44, 0x48, 0x1D, 0x4B, 0x54, 0x1A, 0x4A, 0x53, 0x1E, 0x47, 0x4D, 0x2A, 0x4D, 
	0x57, 0x19, 0x3C, 0x39, 0x1C, 0x3F, 0x3F, 0x20, 0x44, 0x46, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x43, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 
	0x3D, 0x42, 0x1D, 0x3F, 0x43, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1E, 0x2F, 0x37, 0x1B, 0x32, 
	0x3A, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x37, 0x1E, 0x3A, 0x43, 0x38, 0x31, 0x2B, 0x38, 0x2E, 0x30, 
	0x3D, 0x3C, 0x30, 0x19, 0x2F, 0x3B, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x31, 0x39, 0x1D, 
	0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 
	0x37, 0x1D, 0x43, 0x45, 0x1D, 0x2C, 0x36, 0x1D, 0x3F, 0x43, 0x1D, 0x36, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x3C, 0x3F, 0x20, 0x44, 0x46, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1C, 0x3A, 0x3F, 0x1C, 
	0x40, 0x3E, 0x23, 0x47, 0x4B, 0x27, 0x4C, 0x57, 0x35, 0x4F, 0x4E, 0x3A, 0x47, 0x47, 0x29, 0x39, 
	0x35, 0x51, 0x42, 0x37, 0x47, 0x3F, 0x38, 0x34, 0x30, 0x2B, 0x69, 0x5F, 0x4F, 0x6F, 0x69, 0x58, 
	0x6A, 0x62, 0x54, 0x45, 0x3E, 0x37, 0x48, 0x3C, 0x34, 0x58, 0x4D, 0x43, 0x1F, 0x29, 0x28, 0x39, 
	0x75, 0x82, 0x3B, 0x9D, 0xB6, 0x45, 0xAB, 0xC0, 0x4A, 0xC5, 0xD5, 0x4A, 0xBA, 0xCA, 0x4C, 0xC8, 
	0xD8, 0x42, 0x9A, 0xAE, 0x03, 0x08, 0x07, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x08, 0x08, 0x00, 0x00, 0x00, 0x42, 0x9B, 0xAE, 0x49, 0xC0, 0xD3, 0x4A, 0xC4, 
	0xD4, 0x4A, 0xC2, 0xD2, 0x49, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x4A, 0xC0, 0xD0, 0x4A, 0xBC, 0xCC, 
	0x4A, 0xC3, 0xD3, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC6, 0xDA, 0x48, 0xB2, 
	0xC5, 0x02, 0x02, 0x02, 0x03, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x00, 0x00, 0x00, 0x25, 0x52, 0x5C, 0x52, 0xC6, 0xDE, 0x55, 0xC3, 0xDA, 0x47, 0xC2, 
	0xD0, 0x4F, 0xC2, 0xD6, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3B, 0x95, 0xA5, 0x0D, 0x00, 0x00, 
	0x29, 0x57, 0x5A, 0x26, 0x48, 0x52, 0x30, 0x52, 0x52, 0x26, 0x49, 0x52, 0x25, 0x4A, 0x54, 0x31, 
	0x3B, 0x39, 0x2E, 0x40, 0x43, 0x2C, 0x44, 0x47, 0x2B, 0x48, 0x4F, 0x1E, 0x42, 0x43, 0x20, 0x44, 
	0x47, 0x29, 0x4C, 0x57, 0x1A, 0x3D, 0x3A, 0x25, 0x48, 0x4D, 0x1C, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 
	0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3C, 0x42, 0x1D, 
	0x2A, 0x34, 0x18, 0x32, 0x3B, 0x1E, 0x3A, 0x43, 0x1D, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x1E, 0x30, 
	0x38, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x38, 0x13, 0x35, 0x3F, 0x33, 0x2B, 0x22, 0x39, 0x30, 0x31, 
	0x34, 0x2E, 0x29, 0x23, 0x2F, 0x2F, 0x1D, 0x2F, 0x37, 0x1D, 0x31, 0x39, 0x1D, 0x3B, 0x45, 0x1A, 
	0x29, 0x30, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3D, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 
	0x1C, 0x2E, 0x38, 0x22, 0x49, 0x4D, 0x37, 0x3F, 0x3D, 0x20, 0x46, 0x4B, 0x20, 0x44, 0x46, 0x1A, 
	0x3F, 0x3E, 0x23, 0x43, 0x45, 0x13, 0x38, 0x3B, 0x42, 0x3C, 0x34, 0x50, 0x40, 0x3D, 0x3E, 0x39, 
	0x30, 0x54, 0x4B, 0x43, 0x78, 0x73, 0x6E, 0x4E, 0x45, 0x3C, 0x68, 0x5F, 0x4F, 0x61, 0x5F, 0x5F, 
	0x73, 0x6A, 0x59, 0x62, 0x58, 0x4E, 0x40, 0x46, 0x44, 0x4E, 0x45, 0x39, 0x1A, 0x1D, 0x23, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC1, 0xD0, 0x4A, 0xB9, 0xC9, 0x4A, 0xC6, 0xD5, 0x51, 0xBF, 
	0xD6, 0x03, 0x04, 0x03, 0x02, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x13, 0x25, 0x27, 0x4A, 0xB9, 0xCE, 0x4B, 0xC0, 
	0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xB6, 0xC6, 0x4A, 0xC3, 0xD3, 0x4A, 0xB9, 0xC9, 0x4A, 0xC3, 0xD3, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x55, 0xCB, 0xE2, 0x29, 0x56, 
	0x60, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x07, 0x08, 0x08, 0x00, 0x00, 0x00, 0x36, 0x86, 0x92, 0x51, 0xCA, 0xDF, 0x4E, 0xC2, 
	0xD3, 0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x39, 0x96, 0xB0, 0x3C, 0x96, 0xA6, 0x06, 0x0B, 0x07, 
	0x26, 0x45, 0x4D, 0x26, 0x49, 0x53, 0x33, 0x55, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4C, 0x52, 0x23, 
	0x49, 0x54, 0x29, 0x50, 0x54, 0x25, 0x4A, 0x54, 0x2A, 0x48, 0x4E, 0x1A, 0x3D, 0x3B, 0x28, 0x4B, 
	0x55, 0x27, 0x4A, 0x52, 0x29, 0x4C, 0x56, 0x1B, 0x3E, 0x3C, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 
	0x1D, 0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3E, 0x40, 0x1E, 
	0x3D, 0x42, 0x11, 0x38, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x3F, 0x42, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x39, 0x30, 0x2B, 0x38, 0x2F, 0x30, 
	0x39, 0x3B, 0x31, 0x3B, 0x3A, 0x31, 0x1C, 0x30, 0x38, 0x16, 0x2E, 0x33, 0x1E, 0x2C, 0x35, 0x1D, 
	0x3E, 0x44, 0x1D, 0x39, 0x43, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 
	0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x34, 0x3D, 0x1D, 0x3B, 0x42, 0x1D, 0x3C, 0x40, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3C, 0x40, 0x1C, 0x3D, 0x3E, 0x19, 0x3C, 0x3D, 0x2A, 0x4E, 0x59, 0x19, 0x3E, 0x3D, 0x25, 
	0x3E, 0x3E, 0x4C, 0x4E, 0x4D, 0x2E, 0x3F, 0x3F, 0x52, 0x3F, 0x37, 0x38, 0x37, 0x2E, 0x4D, 0x3F, 
	0x36, 0x51, 0x4A, 0x3D, 0x84, 0x7C, 0x74, 0x4F, 0x47, 0x3F, 0x54, 0x4C, 0x44, 0x4E, 0x45, 0x3F, 
	0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4B, 0x5C, 0x52, 0x4A, 0x47, 0x43, 0x37, 0x1B, 0x1E, 0x24, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC4, 0xD4, 0x4A, 0xC0, 0xD3, 0x2F, 0x75, 
	0x81, 0x02, 0x00, 0x00, 0x07, 0x06, 0x06, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x00, 0x00, 0x32, 0x66, 0x73, 0x4B, 0xC4, 
	0xD6, 0x4A, 0xC3, 0xD3, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x49, 0xBF, 0xCE, 0x4C, 0xC2, 0xD4, 0x54, 0xCC, 0xE0, 0x3A, 0x8B, 0x9B, 0x00, 0x00, 
	0x00, 0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x08, 0x07, 0x13, 0x1A, 0x1C, 0x4B, 0xB9, 0xD0, 0x51, 0xC5, 
	0xDB, 0x54, 0xC2, 0xDC, 0x4F, 0xC1, 0xD4, 0x40, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x31, 0x54, 0x52, 0x35, 
	0x52, 0x51, 0x48, 0x49, 0x48, 0x29, 0x4A, 0x4E, 0x27, 0x4B, 0x56, 0x1A, 0x42, 0x43, 0x28, 0x4A, 
	0x53, 0x27, 0x4A, 0x53, 0x28, 0x4B, 0x55, 0x1A, 0x3D, 0x3B, 0x1C, 0x40, 0x3F, 0x1E, 0x40, 0x3E, 
	0x1D, 0x49, 0x4D, 0x1D, 0x39, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 
	0x3C, 0x40, 0x1E, 0x36, 0x40, 0x1F, 0x3E, 0x40, 0x1D, 0x38, 0x42, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 
	0x38, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x12, 0x35, 0x3E, 0x3C, 0x2F, 0x2F, 0x33, 0x30, 0x2A, 
	0x2E, 0x2F, 0x25, 0x2F, 0x2F, 0x26, 0x20, 0x2E, 0x32, 0x12, 0x3C, 0x44, 0x15, 0x36, 0x3E, 0x1B, 
	0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2C, 
	0x36, 0x1A, 0x32, 0x3A, 0x1D, 0x2F, 0x37, 0x1C, 0x2F, 0x38, 0x1A, 0x37, 0x40, 0x1E, 0x3C, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3C, 0x3D, 0x1B, 0x40, 0x3D, 0x1F, 0x40, 0x40, 0x32, 
	0x42, 0x43, 0x20, 0x3F, 0x40, 0x22, 0x3D, 0x3E, 0x33, 0x57, 0x58, 0x32, 0x37, 0x31, 0x30, 0x44, 
	0x49, 0x4E, 0x40, 0x39, 0x56, 0x4C, 0x3D, 0x51, 0x49, 0x3E, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3A, 
	0x4B, 0x42, 0x3F, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4A, 0x48, 0x3A, 0x32, 0x1C, 0x1E, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xC5, 0xD5, 0x4D, 0xB8, 0xD0, 0x04, 0x09, 
	0x08, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 
	0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x09, 0x43, 0xAC, 
	0xC1, 0x4B, 0xC5, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC5, 0xD3, 0x55, 0xC1, 0xDB, 0x03, 0x06, 0x04, 0x03, 0x00, 
	0x00, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x02, 0x02, 0x00, 0x00, 0x00, 0x2E, 0x63, 0x70, 0x53, 0xC7, 
	0xDF, 0x48, 0xC3, 0xD1, 0x4D, 0xC1, 0xD2, 0x3C, 0x9C, 0xB5, 0x3E, 0x9B, 0xAE, 0x06, 0x08, 0x06, 
	0x29, 0x4D, 0x4E, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x52, 0x33, 0x55, 0x52, 0x2B, 0x48, 0x4D, 0x28, 
	0x43, 0x48, 0x40, 0x47, 0x46, 0x29, 0x44, 0x49, 0x28, 0x40, 0x42, 0x19, 0x3D, 0x3B, 0x27, 0x4D, 
	0x57, 0x1C, 0x40, 0x42, 0x1D, 0x40, 0x40, 0x2C, 0x4F, 0x57, 0x1A, 0x3F, 0x44, 0x0D, 0x34, 0x3F, 
	0x18, 0x3A, 0x3D, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 
	0x35, 0x40, 0x1F, 0x40, 0x40, 0x11, 0x37, 0x40, 0x1E, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 
	0x36, 0x1D, 0x3B, 0x44, 0x1B, 0x2C, 0x37, 0x1F, 0x33, 0x3B, 0x3A, 0x31, 0x2E, 0x39, 0x2F, 0x31, 
	0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x3D, 0x31, 0x2E, 0x23, 0x42, 0x3D, 0x0F, 0x38, 0x42, 0x18, 
	0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x31, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x37, 0x1D, 0x48, 
	0x44, 0x1B, 0x2E, 0x38, 0x19, 0x2B, 0x36, 0x27, 0x3E, 0x43, 0x0E, 0x38, 0x3F, 0x0F, 0x34, 0x3E, 
	0x1E, 0x42, 0x40, 0x1C, 0x3C, 0x3D, 0x2B, 0x50, 0x5A, 0x18, 0x33, 0x3E, 0x2E, 0x40, 0x3E, 0x38, 
	0x35, 0x2A, 0x36, 0x38, 0x31, 0x3F, 0x45, 0x44, 0x25, 0x45, 0x4C, 0x34, 0x50, 0x50, 0x20, 0x40, 
	0x44, 0x3E, 0x40, 0x42, 0x3B, 0x3E, 0x3B, 0x4C, 0x42, 0x42, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 
	0x50, 0x48, 0x3D, 0x5C, 0x53, 0x4B, 0x5F, 0x56, 0x4F, 0x24, 0x43, 0x47, 0x16, 0x2A, 0x34, 0x3A, 
	0x75, 0x81, 0x3A, 0x9B, 0xB5, 0x4B, 0xC3, 0xD1, 0x4A, 0xC2, 0xD4, 0x39, 0x8A, 0x97, 0x00, 0x00, 
	0x00, 0x03, 0x02, 0x02, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0F, 0x0F, 
	0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x15, 0x35, 
	0x38, 0x4E, 0xBF, 0xD9, 0x4D, 0xC5, 0xD6, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x4E, 0xC3, 0xD6, 0x50, 0xC3, 0xDC, 0x35, 0x81, 0x87, 0x02, 0x00, 0x00, 0x04, 0x03, 
	0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x07, 0x07, 0x06, 0x07, 0x02, 0x43, 0xA1, 
	0xB2, 0x4D, 0xC7, 0xD9, 0x50, 0xC5, 0xD8, 0x39, 0x96, 0xAF, 0x3E, 0x9B, 0xAF, 0x06, 0x09, 0x06, 
	0x26, 0x45, 0x4C, 0x26, 0x4A, 0x53, 0x27, 0x4A, 0x52, 0x26, 0x49, 0x52, 0x1F, 0x4A, 0x53, 0x29, 
	0x46, 0x4D, 0x35, 0x52, 0x50, 0x28, 0x4E, 0x53, 0x3E, 0x4F, 0x4E, 0x1E, 0x46, 0x4B, 0x33, 0x3D, 
	0x3C, 0x2B, 0x43, 0x46, 0x20, 0x46, 0x4B, 0x33, 0x51, 0x4F, 0x39, 0x50, 0x4F, 0x32, 0x3C, 0x38, 
	0x14, 0x44, 0x4F, 0x1D, 0x3A, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x3C, 0x40, 0x1E, 
	0x36, 0x40, 0x1E, 0x3C, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x31, 
	0x39, 0x18, 0x30, 0x39, 0x2E, 0x34, 0x32, 0x2C, 0x43, 0x40, 0x39, 0x39, 0x2E, 0x36, 0x37, 0x2E, 
	0x2C, 0x2E, 0x24, 0x37, 0x2F, 0x2F, 0x33, 0x2E, 0x29, 0x3B, 0x39, 0x33, 0x15, 0x30, 0x3B, 0x18, 
	0x36, 0x3F, 0x1A, 0x43, 0x42, 0x1D, 0x35, 0x3E, 0x1D, 0x2C, 0x36, 0x1D, 0x2F, 0x37, 0x1A, 0x2A, 
	0x35, 0x35, 0x45, 0x43, 0x33, 0x3F, 0x3C, 0x42, 0x44, 0x3D, 0x45, 0x4C, 0x4C, 0x1B, 0x4D, 0x55, 
	0x12, 0x3A, 0x40, 0x16, 0x3E, 0x42, 0x15, 0x3F, 0x3F, 0x22, 0x43, 0x44, 0x37, 0x34, 0x29, 0x50, 
	0x44, 0x3B, 0x36, 0x36, 0x2E, 0x35, 0x35, 0x2B, 0x38, 0x34, 0x28, 0x40, 0x4C, 0x4B, 0x3A, 0x4D, 
	0x4E, 0x32, 0x38, 0x37, 0x2B, 0x23, 0x1B, 0x46, 0x3E, 0x35, 0x4F, 0x47, 0x3C, 0x5D, 0x55, 0x4D, 
	0x52, 0x4A, 0x42, 0x62, 0x57, 0x4D, 0x3E, 0x57, 0x58, 0x2C, 0x50, 0x52, 0x1B, 0x22, 0x28, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD4, 0x4C, 0xB6, 0xCE, 0x03, 0x07, 0x06, 0x07, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0E, 0x0E, 0x0B, 0x09, 0x09, 
	0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x08, 0x08, 0x00, 0x00, 
	0x00, 0x3B, 0x8E, 0x9E, 0x4A, 0xC3, 0xD4, 0x4A, 0xC3, 0xD2, 0x49, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 
	0x54, 0xC2, 0xDC, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x52, 0xC6, 0xDB, 0x48, 0xB2, 0xC6, 0x02, 0x03, 0x02, 0x03, 0x00, 0x00, 0x04, 0x04, 
	0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x00, 0x02, 0x00, 0x2A, 0x67, 
	0x74, 0x56, 0xC8, 0xDF, 0x4F, 0xC1, 0xD4, 0x3F, 0xA2, 0xBC, 0x3A, 0x95, 0xA4, 0x0D, 0x00, 0x00, 
	0x2B, 0x58, 0x5F, 0x2C, 0x4E, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x1B, 
	0x49, 0x52, 0x32, 0x54, 0x52, 0x31, 0x53, 0x52, 0x30, 0x53, 0x53, 0x1D, 0x47, 0x4F, 0x33, 0x3F, 
	0x3E, 0x18, 0x3E, 0x3D, 0x19, 0x3F, 0x3E, 0x1C, 0x3E, 0x44, 0x22, 0x3F, 0x46, 0x38, 0x3C, 0x38, 
	0x1A, 0x3C, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x34, 0x40, 0x1E, 
	0x3F, 0x40, 0x1D, 0x42, 0x40, 0x1C, 0x3F, 0x40, 0x0F, 0x38, 0x42, 0x1E, 0x2B, 0x35, 0x19, 0x31, 
	0x39, 0x1E, 0x38, 0x3F, 0x39, 0x2E, 0x2A, 0x39, 0x34, 0x2E, 0x38, 0x2E, 0x30, 0x36, 0x34, 0x2E, 
	0x39, 0x3A, 0x31, 0x38, 0x30, 0x30, 0x31, 0x2F, 0x28, 0x3A, 0x35, 0x32, 0x34, 0x2F, 0x25, 0x33, 
	0x2C, 0x2C, 0x15, 0x35, 0x42, 0x1E, 0x3E, 0x40, 0x1E, 0x43, 0x42, 0x1D, 0x30, 0x39, 0x1A, 0x2F, 
	0x38, 0x1F, 0x42, 0x43, 0x36, 0x3B, 0x3A, 0x2F, 0x24, 0x1C, 0x35, 0x35, 0x2A, 0x3B, 0x37, 0x2B, 
	0x3C, 0x37, 0x2C, 0x33, 0x3C, 0x39, 0x4B, 0x3D, 0x34, 0x4E, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x33, 0x35, 0x2C, 0x4F, 0x43, 0x3A, 0x39, 0x38, 0x2F, 0x38, 0x39, 0x35, 0x5E, 0x59, 
	0x55, 0x6C, 0x61, 0x54, 0x31, 0x2C, 0x27, 0x3F, 0x3B, 0x38, 0x4E, 0x46, 0x42, 0x51, 0x49, 0x3E, 
	0x51, 0x49, 0x3F, 0x4E, 0x44, 0x3B, 0x2B, 0x40, 0x42, 0x2E, 0x40, 0x3F, 0x1A, 0x25, 0x2B, 0x3A, 
	0x76, 0x82, 0x3A, 0x9B, 0xB5, 0x4D, 0xC5, 0xD4, 0x3D, 0x9B, 0xA9, 0x03, 0x03, 0x00, 0x03, 0x02, 
	0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x09, 0x08, 
	0x08, 0x0C, 0x0F, 0x0D, 0x47, 0xAB, 0xC2, 0x4D, 0xC7, 0xD9, 0x4C, 0xC2, 0xD4, 0x4C, 0xC2, 0xD1, 
	0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4E, 
	0xC3, 0xD4, 0x51, 0xC3, 0xDB, 0x26, 0x4D, 0x53, 0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x09, 0x0B, 0x09, 0x0D, 0x0E, 
	0x0F, 0x4E, 0xB7, 0xCD, 0x50, 0xC6, 0xDA, 0x3F, 0xA1, 0xBB, 0x3B, 0x95, 0xA5, 0x04, 0x09, 0x06, 
	0x28, 0x53, 0x57, 0x2C, 0x4E, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2E, 0x4F, 0x52, 0x19, 
	0x49, 0x52, 0x29, 0x4B, 0x52, 0x2A, 0x4D, 0x52, 0x32, 0x54, 0x52, 0x25, 0x4A, 0x54, 0x33, 0x3C, 
	0x39, 0x26, 0x4D, 0x58, 0x34, 0x3D, 0x3B, 0x26, 0x48, 0x4D, 0x19, 0x3B, 0x3D, 0x1D, 0x48, 0x4D, 
	0x24, 0x46, 0x4B, 0x1C, 0x40, 0x3E, 0x1D, 0x3A, 0x40, 0x1D, 0x3A, 0x40, 0x1E, 0x43, 0x40, 0x1C, 
	0x3C, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1F, 0x44, 0x40, 0x1D, 0x38, 0x3E, 0x15, 0x34, 
	0x3E, 0x3E, 0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x30, 0x2E, 0x30, 0x2E, 0x27, 
	0x39, 0x37, 0x31, 0x39, 0x3A, 0x31, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x3A, 
	0x37, 0x30, 0x33, 0x2F, 0x2B, 0x0F, 0x36, 0x40, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x3A, 0x2F, 0x46, 
	0x44, 0x13, 0x2E, 0x3B, 0x39, 0x31, 0x2A, 0x36, 0x32, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x2C, 0x30, 
	0x34, 0x30, 0x2B, 0x3D, 0x3A, 0x31, 0x4E, 0x43, 0x3A, 0x4B, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x31, 
	0x34, 0x2B, 0x3A, 0x39, 0x31, 0x4B, 0x40, 0x38, 0x4A, 0x3F, 0x37, 0x54, 0x49, 0x3F, 0x6C, 0x77, 
	0x7A, 0x75, 0x6A, 0x5D, 0x48, 0x43, 0x38, 0x44, 0x3C, 0x33, 0x4E, 0x46, 0x43, 0x52, 0x4A, 0x3F, 
	0x5B, 0x53, 0x4B, 0x4D, 0x45, 0x40, 0x51, 0x45, 0x3D, 0x54, 0x46, 0x3D, 0x1A, 0x1D, 0x22, 0x3A, 
	0x76, 0x83, 0x3A, 0x9B, 0xB5, 0x4C, 0xC5, 0xD6, 0x33, 0x72, 0x83, 0x02, 0x02, 0x00, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 
	0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 0x09, 
	0x09, 0x04, 0x07, 0x06, 0x28, 0x56, 0x60, 0x4F, 0xC5, 0xD9, 0x4F, 0xC3, 0xD7, 0x48, 0xC2, 0xD1, 
	0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x50, 
	0xC6, 0xDB, 0x3F, 0x9D, 0xAA, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 0x00, 0x03, 0x06, 
	0x03, 0x37, 0x86, 0x98, 0x4D, 0xCD, 0xDB, 0x3D, 0x9C, 0xB5, 0x3B, 0x96, 0xA6, 0x0D, 0x00, 0x00, 
	0x2B, 0x57, 0x5E, 0x2B, 0x4D, 0x51, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x2C, 0x4E, 0x52, 0x18, 
	0x49, 0x52, 0x29, 0x49, 0x52, 0x26, 0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x52, 0x26, 0x4B, 
	0x54, 0x26, 0x4A, 0x52, 0x28, 0x4A, 0x51, 0x33, 0x3D, 0x3C, 0x2E, 0x40, 0x40, 0x19, 0x3E, 0x3C, 
	0x1C, 0x46, 0x4B, 0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3C, 0x3E, 0x22, 
	0x48, 0x4D, 0x1C, 0x39, 0x3E, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3E, 0x42, 0x22, 0x33, 
	0x38, 0x37, 0x2F, 0x2B, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x2F, 0x30, 0x26, 
	0x2F, 0x2F, 0x26, 0x2E, 0x2F, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x27, 0x34, 0x31, 0x2B, 0x38, 
	0x39, 0x30, 0x3A, 0x39, 0x2F, 0x28, 0x2B, 0x2F, 0x16, 0x43, 0x4B, 0x16, 0x45, 0x4A, 0x37, 0x3A, 
	0x38, 0x3C, 0x37, 0x2E, 0x35, 0x2E, 0x2C, 0x38, 0x39, 0x30, 0x36, 0x38, 0x2F, 0x38, 0x3A, 0x30, 
	0x38, 0x2C, 0x30, 0x37, 0x38, 0x2F, 0x34, 0x36, 0x2E, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x4D, 
	0x42, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x46, 0x3C, 0x34, 0x5A, 0x51, 0x48, 0x6F, 0x7C, 
	0x79, 0x5D, 0x56, 0x50, 0x40, 0x39, 0x37, 0x4A, 0x3F, 0x36, 0x4C, 0x43, 0x39, 0x4D, 0x45, 0x3A, 
	0x53, 0x4B, 0x42, 0x4A, 0x42, 0x38, 0x51, 0x49, 0x3F, 0x4E, 0x47, 0x3B, 0x1A, 0x1E, 0x23, 0x39, 
	0x75, 0x81, 0x3E, 0xA4, 0xBB, 0x49, 0xC0, 0xD5, 0x2B, 0x57, 0x5E, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 
	0x07, 0x07, 0x04, 0x03, 0x00, 0x02, 0x00, 0x37, 0x89, 0x99, 0x50, 0xC3, 0xD6, 0x4E, 0xC2, 0xD4, 
	0x4E, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD0, 0x4A, 
	0xC2, 0xD4, 0x53, 0xC7, 0xDF, 0x31, 0x5D, 0x66, 0x00, 0x00, 0x00, 0x0B, 0x09, 0x09, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0x03, 0x02, 
	0x00, 0x2A, 0x54, 0x5B, 0x4A, 0xC0, 0xD5, 0x3D, 0x9E, 0xB7, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x28, 0x52, 0x57, 0x32, 0x54, 0x52, 0x25, 0x48, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x2B, 
	0x4C, 0x52, 0x18, 0x49, 0x52, 0x27, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x26, 0x4B, 0x55, 0x1C, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x34, 0x3E, 0x3C, 0x29, 0x47, 0x4C, 
	0x1B, 0x4A, 0x52, 0x1D, 0x3F, 0x3E, 0x1D, 0x3D, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3B, 0x40, 0x36, 
	0x40, 0x3F, 0x1B, 0x42, 0x40, 0x1E, 0x43, 0x40, 0x1C, 0x37, 0x40, 0x1E, 0x35, 0x3D, 0x3C, 0x33, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 
	0x2F, 0x30, 0x26, 0x38, 0x30, 0x30, 0x30, 0x30, 0x27, 0x2F, 0x28, 0x1F, 0x33, 0x35, 0x2B, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x2F, 0x38, 0x2B, 0x2B, 0x33, 0x29, 0x20, 0x3C, 0x39, 0x2F, 0x30, 0x2C, 
	0x25, 0x36, 0x2F, 0x2E, 0x35, 0x2E, 0x2C, 0x36, 0x38, 0x2F, 0x51, 0x45, 0x3B, 0x35, 0x38, 0x2F, 
	0x39, 0x31, 0x2C, 0x39, 0x37, 0x2C, 0x3D, 0x39, 0x31, 0x48, 0x3F, 0x36, 0x4B, 0x40, 0x38, 0x3D, 
	0x3A, 0x32, 0x4B, 0x40, 0x38, 0x3D, 0x39, 0x31, 0x5B, 0x52, 0x4A, 0x56, 0x4E, 0x43, 0x71, 0x6C, 
	0x5E, 0x5F, 0x57, 0x4F, 0x4A, 0x40, 0x39, 0x4C, 0x44, 0x44, 0x49, 0x3F, 0x35, 0x4C, 0x44, 0x44, 
	0x48, 0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x47, 0x3D, 0x43, 0x39, 0x32, 0x1B, 0x1F, 0x23, 0x39, 
	0x78, 0x87, 0x43, 0xAE, 0xC2, 0x4E, 0xBB, 0xD2, 0x02, 0x02, 0x00, 0x07, 0x08, 0x07, 0x0C, 0x0F, 
	0x0F, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 
	0x0B, 0x00, 0x00, 0x00, 0x15, 0x19, 0x1A, 0x40, 0xA9, 0xB9, 0x52, 0xC5, 0xDD, 0x50, 0xC2, 0xD8, 
	0x51, 0xC4, 0xD7, 0x4F, 0xC6, 0xDC, 0x52, 0xC4, 0xD8, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x53, 
	0xC2, 0xD2, 0x54, 0xC5, 0xDF, 0x4E, 0xBA, 0xD1, 0x11, 0x2B, 0x30, 0x03, 0x00, 0x00, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x04, 
	0x04, 0x06, 0x06, 0x02, 0x4A, 0xB5, 0xC8, 0x40, 0xA5, 0xBF, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x32, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 
	0x49, 0x52, 0x27, 0x49, 0x52, 0x2A, 0x4C, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4D, 0x53, 0x2C, 0x44, 
	0x48, 0x34, 0x3C, 0x39, 0x26, 0x4B, 0x55, 0x27, 0x4B, 0x54, 0x20, 0x46, 0x4B, 0x1B, 0x3F, 0x3D, 
	0x1D, 0x3F, 0x3E, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x42, 0x40, 0x12, 0x36, 0x40, 0x34, 
	0x3C, 0x3A, 0x19, 0x38, 0x40, 0x0F, 0x36, 0x40, 0x22, 0x3A, 0x42, 0x32, 0x34, 0x2E, 0x39, 0x3A, 
	0x30, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x39, 0x30, 0x31, 0x2C, 0x30, 0x24, 0x30, 0x30, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x31, 0x2F, 0x28, 0x36, 0x31, 0x2E, 0x38, 
	0x35, 0x2F, 0x31, 0x3F, 0x3C, 0x2E, 0x27, 0x1D, 0x31, 0x2F, 0x28, 0x39, 0x3A, 0x31, 0x35, 0x31, 
	0x2C, 0x38, 0x2E, 0x30, 0x38, 0x3A, 0x2F, 0x37, 0x2E, 0x2E, 0x3C, 0x35, 0x32, 0x39, 0x30, 0x2A, 
	0x2E, 0x47, 0x4B, 0x1D, 0x42, 0x4A, 0x37, 0x3C, 0x36, 0x32, 0x38, 0x32, 0x4C, 0x42, 0x38, 0x4A, 
	0x40, 0x37, 0x4E, 0x44, 0x42, 0x2F, 0x33, 0x29, 0x4C, 0x43, 0x3F, 0x4F, 0x47, 0x3F, 0x55, 0x4C, 
	0x44, 0x55, 0x4D, 0x45, 0x4D, 0x45, 0x3A, 0x4C, 0x44, 0x39, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 
	0x49, 0x3F, 0x37, 0x4C, 0x43, 0x3A, 0x52, 0x4A, 0x3F, 0x42, 0x39, 0x32, 0x1C, 0x1D, 0x22, 0x34, 
	0x8B, 0x9C, 0x43, 0xA8, 0xC3, 0x3A, 0x92, 0xA1, 0x03, 0x04, 0x02, 0x07, 0x04, 0x04, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x08, 0x08, 
	0x07, 0x0F, 0x16, 0x14, 0x4A, 0xB5, 0xCB, 0x51, 0xC6, 0xDB, 0x4E, 0xC4, 0xD7, 0x51, 0xC4, 0xDA, 
	0x53, 0xBF, 0xD7, 0x3C, 0x9B, 0xA4, 0x53, 0xBF, 0xD8, 0x53, 0xC6, 0xDE, 0x52, 0xC5, 0xD8, 0x4D, 
	0xC2, 0xD6, 0x4D, 0xC2, 0xD2, 0x4C, 0xC7, 0xD9, 0x4F, 0xBD, 0xD2, 0x04, 0x07, 0x06, 0x06, 0x06, 
	0x06, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x00, 
	0x00, 0x07, 0x07, 0x08, 0x45, 0x9E, 0xB1, 0x42, 0xA8, 0xC2, 0x3B, 0x95, 0xA5, 0x06, 0x08, 0x06, 
	0x29, 0x53, 0x58, 0x2A, 0x4C, 0x52, 0x2E, 0x50, 0x52, 0x31, 0x53, 0x52, 0x28, 0x4B, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4B, 0x52, 0x32, 0x54, 0x52, 0x1E, 0x4B, 0x52, 0x1A, 0x49, 0x52, 0x26, 0x4A, 
	0x53, 0x1F, 0x48, 0x4E, 0x26, 0x4B, 0x54, 0x29, 0x48, 0x4E, 0x1E, 0x46, 0x4A, 0x16, 0x3A, 0x3E, 
	0x1D, 0x40, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1E, 0x42, 0x40, 0x0F, 0x35, 0x40, 0x1C, 
	0x3B, 0x40, 0x1E, 0x43, 0x40, 0x0F, 0x36, 0x40, 0x26, 0x3C, 0x42, 0x4F, 0x43, 0x37, 0x33, 0x2F, 
	0x2B, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x37, 0x30, 0x2F, 0x2E, 0x2F, 0x25, 
	0x30, 0x31, 0x27, 0x26, 0x1C, 0x1D, 0x33, 0x30, 0x28, 0x3C, 0x34, 0x30, 0x38, 0x30, 0x30, 0x36, 
	0x32, 0x2F, 0x4B, 0x42, 0x37, 0x2E, 0x2C, 0x27, 0x36, 0x2F, 0x2E, 0x36, 0x31, 0x2E, 0x38, 0x3A, 
	0x30, 0x39, 0x32, 0x2E, 0x36, 0x37, 0x33, 0x33, 0x3E, 0x39, 0x39, 0x30, 0x2A, 0x32, 0x40, 0x3E, 
	0x15, 0x42, 0x40, 0x36, 0x40, 0x3F, 0x13, 0x34, 0x42, 0x32, 0x3B, 0x36, 0x48, 0x3E, 0x36, 0x4A, 
	0x3F, 0x37, 0x52, 0x4A, 0x43, 0x4E, 0x44, 0x42, 0x49, 0x3E, 0x35, 0x4E, 0x46, 0x3B, 0x4C, 0x44, 
	0x39, 0x5B, 0x53, 0x4B, 0x4E, 0x46, 0x3C, 0x44, 0x3C, 0x34, 0x4B, 0x40, 0x38, 0x4C, 0x44, 0x3A, 
	0x49, 0x3F, 0x37, 0x48, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x4E, 0x47, 0x3B, 0x1B, 0x1C, 0x20, 0x34, 
	0x89, 0x9A, 0x43, 0xA9, 0xC3, 0x3D, 0x9B, 0xAB, 0x04, 0x06, 0x03, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x09, 0x08, 0x00, 0x00, 
	0x00, 0x3F, 0x9A, 0xAD, 0x52, 0xC9, 0xDE, 0x48, 0xC5, 0xD3, 0x53, 0xC8, 0xDE, 0x2E, 0x6E, 0x77, 
	0x00, 0x02, 0x00, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x28, 0x51, 0x59, 0x44, 0xA3, 0xB8, 0x56, 
	0xC9, 0xE1, 0x4E, 0xC3, 0xD7, 0x4E, 0xC3, 0xD5, 0x52, 0xC4, 0xDB, 0x31, 0x6F, 0x7D, 0x04, 0x06, 
	0x04, 0x0B, 0x09, 0x09, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 
	0x09, 0x04, 0x08, 0x06, 0x3A, 0x7A, 0x88, 0x3C, 0xA0, 0xBA, 0x42, 0x99, 0xA8, 0x0D, 0x00, 0x00, 
	0x28, 0x53, 0x58, 0x31, 0x53, 0x52, 0x31, 0x53, 0x52, 0x2A, 0x4D, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x2A, 0x4F, 0x52, 0x3B, 0x4D, 0x4D, 0x3D, 0x4F, 0x4D, 0x18, 0x4A, 0x53, 0x1C, 0x4A, 
	0x52, 0x19, 0x4A, 0x53, 0x2E, 0x44, 0x47, 0x36, 0x40, 0x3F, 0x25, 0x47, 0x4B, 0x0D, 0x34, 0x3E, 
	0x1E, 0x46, 0x47, 0x1D, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1E, 0x42, 0x40, 0x1E, 0x42, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x0E, 0x35, 0x40, 0x27, 0x3D, 0x43, 0x38, 0x32, 0x2C, 0x32, 0x2F, 
	0x29, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x3A, 0x3B, 0x32, 
	0x37, 0x32, 0x2F, 0x2F, 0x31, 0x26, 0x1E, 0x22, 0x29, 0x1C, 0x3B, 0x42, 0x3A, 0x38, 0x2E, 0x35, 
	0x37, 0x2F, 0x4F, 0x43, 0x3A, 0x36, 0x38, 0x2F, 0x39, 0x37, 0x31, 0x2C, 0x2E, 0x24, 0x3A, 0x32, 
	0x2F, 0x32, 0x42, 0x3E, 0x30, 0x43, 0x43, 0x2F, 0x40, 0x42, 0x30, 0x43, 0x43, 0x36, 0x3E, 0x39, 
	0x18, 0x30, 0x39, 0x2E, 0x40, 0x3E, 0x20, 0x45, 0x47, 0x44, 0x48, 0x49, 0x33, 0x34, 0x2A, 0x48, 
	0x3F, 0x37, 0x49, 0x3F, 0x37, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x40, 0x4F, 0x47, 0x42, 0x4B, 0x42, 
	0x38, 0x4E, 0x45, 0x3A, 0x64, 0x5A, 0x4F, 0x34, 0x34, 0x2B, 0x3E, 0x3A, 0x32, 0x50, 0x47, 0x3D, 
	0x4D, 0x45, 0x3B, 0x4C, 0x44, 0x3A, 0x47, 0x3C, 0x42, 0x54, 0x4A, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x42, 0xA8, 0xC3, 0x2F, 0x65, 0x6D, 0x02, 0x03, 0x02, 0x0B, 0x09, 0x09, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x04, 0x03, 0x1B, 0x3E, 
	0x43, 0x56, 0xC9, 0xE1, 0x4E, 0xC5, 0xD8, 0x4F, 0xC5, 0xDB, 0x28, 0x50, 0x5A, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2A, 
	0x67, 0x70, 0x4F, 0xC8, 0xDE, 0x51, 0xC4, 0xD9, 0x54, 0xC6, 0xDD, 0x49, 0xAE, 0xBE, 0x06, 0x04, 
	0x04, 0x07, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x03, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x08, 
	0x08, 0x02, 0x04, 0x02, 0x29, 0x66, 0x6F, 0x3D, 0xA2, 0xBD, 0x44, 0x9D, 0xB0, 0x04, 0x08, 0x04, 
	0x28, 0x53, 0x58, 0x2F, 0x51, 0x52, 0x2C, 0x4E, 0x52, 0x2C, 0x4F, 0x52, 0x26, 0x49, 0x52, 0x26, 
	0x49, 0x52, 0x28, 0x4C, 0x52, 0x35, 0x4C, 0x4A, 0x42, 0x47, 0x46, 0x29, 0x44, 0x47, 0x1A, 0x4A, 
	0x53, 0x2A, 0x4A, 0x52, 0x1A, 0x4A, 0x54, 0x43, 0x48, 0x46, 0x4B, 0x4C, 0x4B, 0x20, 0x3A, 0x3E, 
	0x1B, 0x3C, 0x3D, 0x1D, 0x40, 0x40, 0x1E, 0x3E, 0x40, 0x0F, 0x35, 0x40, 0x1C, 0x3F, 0x40, 0x1D, 
	0x40, 0x40, 0x1E, 0x42, 0x40, 0x1C, 0x43, 0x40, 0x26, 0x3C, 0x43, 0x3A, 0x31, 0x2E, 0x35, 0x2E, 
	0x2C, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x37, 0x34, 0x30, 0x34, 0x30, 0x2C, 0x2C, 0x2E, 0x24, 
	0x37, 0x2F, 0x2F, 0x39, 0x30, 0x31, 0x3B, 0x33, 0x27, 0x15, 0x2C, 0x39, 0x3A, 0x38, 0x2E, 0x34, 
	0x36, 0x2E, 0x49, 0x3F, 0x37, 0x35, 0x36, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2E, 0x24, 0x38, 0x36, 
	0x30, 0x1D, 0x33, 0x3B, 0x1E, 0x32, 0x39, 0x34, 0x43, 0x40, 0x1D, 0x37, 0x3E, 0x20, 0x42, 0x4D, 
	0x20, 0x48, 0x4C, 0x1F, 0x42, 0x4D, 0x23, 0x3E, 0x3D, 0x42, 0x48, 0x47, 0x3C, 0x38, 0x30, 0x31, 
	0x34, 0x2B, 0x4B, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x49, 0x3F, 0x36, 0x48, 0x3E, 0x3E, 0x4D, 0x43, 
	0x3E, 0x44, 0x48, 0x45, 0x79, 0x77, 0x6F, 0x4F, 0x49, 0x43, 0x43, 0x3C, 0x36, 0x48, 0x3C, 0x33, 
	0x57, 0x4F, 0x49, 0x6A, 0x62, 0x4E, 0x51, 0x49, 0x3F, 0x4C, 0x45, 0x39, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3E, 0xA2, 0xBD, 0x2C, 0x6B, 0x77, 0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 
	0x0C, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x03, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0C, 0x0B, 0x09, 0x06, 0x07, 0x08, 0x47, 0xA1, 
	0xB5, 0x4A, 0xC5, 0xD4, 0x52, 0xC8, 0xDD, 0x36, 0x82, 0x93, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x0B, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x02, 
	0x02, 0x03, 0x2C, 0x71, 0x7D, 0x51, 0xC3, 0xD9, 0x53, 0xC5, 0xDC, 0x53, 0xC3, 0xDE, 0x03, 0x08, 
	0x06, 0x07, 0x07, 0x06, 0x0B, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C, 0x04, 0x04, 0x04, 0x0C, 0x0C, 0x0C, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x14, 
	0x14, 0x03, 0x02, 0x02, 0x25, 0x4C, 0x4E, 0x44, 0xA1, 0xBA, 0x4E, 0xA6, 0xBD, 0x06, 0x02, 0x00, 
	0x28, 0x52, 0x58, 0x25, 0x49, 0x4C, 0x15, 0x44, 0x4D, 0x1D, 0x49, 0x52, 0x2E, 0x4F, 0x51, 0x26, 
	0x49, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4C, 0x53, 0x29, 0x43, 0x47, 0x29, 0x47, 0x4E, 0x19, 0x4A, 
	0x52, 0x29, 0x4A, 0x52, 0x19, 0x4A, 0x52, 0x28, 0x47, 0x4E, 0x25, 0x45, 0x49, 0x1A, 0x38, 0x3C, 
	0x28, 0x4B, 0x53, 0x1B, 0x3F, 0x3D, 0x1C, 0x3A, 0x3E, 0x1C, 0x39, 0x3F, 0x0F, 0x35, 0x3F, 0x19, 
	0x3C, 0x40, 0x0F, 0x34, 0x3E, 0x1C, 0x3B, 0x3F, 0x24, 0x40, 0x43, 0x38, 0x2B, 0x2C, 0x38, 0x3B, 
	0x30, 0x38, 0x2C, 0x30, 0x37, 0x3A, 0x30, 0x3C, 0x3A, 0x32, 0x4A, 0x42, 0x38, 0x2E, 0x2C, 0x26, 
	0x2C, 0x2F, 0x24, 0x36, 0x2F, 0x2E, 0x1A, 0x34, 0x3E, 0x18, 0x34, 0x3B, 0x3E, 0x38, 0x33, 0x48, 
	0x3E, 0x36, 0x3D, 0x39, 0x31, 0x3E, 0x39, 0x34, 0x40, 0x38, 0x35, 0x2E, 0x29, 0x22, 0x15, 0x3A, 
	0x47, 0x20, 0x42, 0x4B, 0x1F, 0x42, 0x4B, 0x23, 0x39, 0x3D, 0x24, 0x39, 0x3E, 0x20, 0x40, 0x45, 
	0x35, 0x3F, 0x3C, 0x2A, 0x3C, 0x39, 0x28, 0x40, 0x43, 0x43, 0x3A, 0x30, 0x3D, 0x39, 0x31, 0x4A, 
	0x43, 0x3A, 0x4A, 0x40, 0x3B, 0x47, 0x3C, 0x3B, 0x4A, 0x40, 0x37, 0x4D, 0x44, 0x3A, 0x39, 0x36, 
	0x30, 0x49, 0x3F, 0x38, 0x37, 0x42, 0x46, 0x4F, 0x45, 0x3E, 0x71, 0x6A, 0x5D, 0x3A, 0x48, 0x4A, 
	0x4E, 0x44, 0x39, 0x4E, 0x46, 0x3C, 0x58, 0x50, 0x46, 0x56, 0x4B, 0x3E, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x42, 0xA8, 0xC3, 0x2C, 0x64, 0x6C, 0x00, 0x00, 0x00, 0x07, 0x08, 0x07, 0x07, 0x06, 
	0x04, 0x00, 0x00, 0x00, 0x08, 0x06, 0x04, 0x07, 0x04, 0x04, 0x04, 0x00, 0x00, 0x07, 0x06, 0x04, 
	0x03, 0x00, 0x00, 0x07, 0x04, 0x04, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x04, 0x02, 0x02, 0x03, 
	0x00, 0x00, 0x07, 0x04, 0x04, 0x0B, 0x09, 0x08, 0x00, 0x00, 0x00, 0x08, 0x09, 0x09, 0x45, 0xB4, 
	0xC7, 0x4A, 0xC6, 0xD5, 0x46, 0xB5, 0xCB, 0x2A, 0x65, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x0B, 0x0B, 0x0B, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x0D, 0x0D, 0x00, 0x00, 0x00, 0x06, 
	0x02, 0x00, 0x0C, 0x16, 0x19, 0x4F, 0xB9, 0xD2, 0x54, 0xC5, 0xDD, 0x51, 0xC3, 0xD9, 0x2F, 0x6A, 
	0x77, 0x00, 0x00, 0x00, 0x07, 0x03, 0x03, 0x08, 0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x07, 0x06, 0x06, 0x03, 0x02, 0x00, 0x04, 0x00, 0x00, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x03, 
	0x02, 0x00, 0x07, 0x04, 0x04, 0x09, 0x07, 0x07, 0x09, 0x0F, 0x0E, 0x09, 0x06, 0x06, 0x09, 0x0D, 
	0x0D, 0x08, 0x06, 0x04, 0x0E, 0x22, 0x20, 0x4D, 0xA2, 0xBA, 0x43, 0xA1, 0xAE, 0x0C, 0x03, 0x02, 
	0x4E, 0x5D, 0x5B, 0x24, 0x3C, 0x47, 0x16, 0x3B, 0x42, 0x1E, 0x46, 0x4E, 0x2B, 0x50, 0x59, 0x2A, 
	0x4C, 0x4E, 0x2A, 0x4C, 0x4F, 0x2A, 0x4C, 0x4F, 0x2A, 0x4D, 0x50, 0x2A, 0x4D, 0x4F, 0x26, 0x4A, 
	0x4F, 0x1E, 0x47, 0x50, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x50, 0x14, 0x43, 0x4D, 0x1E, 0x44, 0x47, 
	0x1D, 0x43, 0x46, 0x22, 0x43, 0x47, 0x1E, 0x45, 0x48, 0x1B, 0x3C, 0x43, 0x27, 0x3D, 0x44, 0x11, 
	0x36, 0x3C, 0x1D, 0x40, 0x4A, 0x1B, 0x3C, 0x45, 0x3C, 0x3D, 0x39, 0x43, 0x37, 0x33, 0x31, 0x30, 
	0x2A, 0x35, 0x38, 0x2F, 0x32, 0x31, 0x2B, 0x37, 0x36, 0x2C, 0x4B, 0x40, 0x3A, 0x3F, 0x38, 0x35, 
	0x30, 0x31, 0x28, 0x30, 0x32, 0x28, 0x1B, 0x32, 0x36, 0x2A, 0x54, 0x58, 0x32, 0x52, 0x56, 0x58, 
	0x4A, 0x42, 0x59, 0x50, 0x46, 0x68, 0x5E, 0x53, 0x65, 0x5C, 0x53, 0x59, 0x4E, 0x42, 0x4D, 0x4E, 
	0x4E, 0x2B, 0x51, 0x55, 0x2C, 0x50, 0x55, 0x45, 0x54, 0x53, 0x45, 0x53, 0x52, 0x30, 0x51, 0x51, 
	0x45, 0x42, 0x3C, 0x48, 0x42, 0x40, 0x70, 0x69, 0x65, 0x6C, 0x61, 0x55, 0x5D, 0x53, 0x4A, 0x66, 
	0x5D, 0x4F, 0x67, 0x5E, 0x50, 0x67, 0x5E, 0x50, 0x66, 0x5D, 0x52, 0x73, 0x6A, 0x5B, 0x67, 0x5E, 
	0x56, 0x67, 0x5E, 0x4F, 0x65, 0x5A, 0x4E, 0x6A, 0x60, 0x54, 0x68, 0x62, 0x56, 0x70, 0x6B, 0x65, 
	0x6C, 0x62, 0x53, 0x63, 0x5B, 0x54, 0x6E, 0x65, 0x54, 0x6C, 0x5E, 0x52, 0x1C, 0x22, 0x24, 0x36, 
	0x84, 0x94, 0x43, 0xAB, 0xC1, 0x4B, 0xBB, 0xCF, 0x12, 0x29, 0x2A, 0x00, 0x02, 0x02, 0x09, 0x07, 
	0x0B, 0x0B, 0x07, 0x0B, 0x06, 0x09, 0x0D, 0x02, 0x0D, 0x11, 0x03, 0x0D, 0x11, 0x07, 0x09, 0x0D, 
	0x02, 0x0E, 0x12, 0x06, 0x09, 0x0D, 0x06, 0x09, 0x0D, 0x03, 0x0E, 0x12, 0x09, 0x06, 0x09, 0x06, 
	0x0B, 0x0E, 0x09, 0x07, 0x0B, 0x08, 0x06, 0x09, 0x04, 0x06, 0x09, 0x12, 0x2C, 0x2B, 0x51, 0xBE, 
	0xDA, 0x54, 0xC3, 0xD4, 0x58, 0xD1, 0xE4, 0x2A, 0x5E, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0C, 0x00, 0x04, 0x03, 0x02, 0x04, 0x04, 0x0C, 
	0x09, 0x09, 0x00, 0x00, 0x00, 0x43, 0xA4, 0xB3, 0x4F, 0xC6, 0xDA, 0x4F, 0xC5, 0xD7, 0x3E, 0xA0, 
	0xB3, 0x14, 0x32, 0x35, 0x07, 0x04, 0x07, 0x04, 0x09, 0x0C, 0x09, 0x07, 0x0B, 0x08, 0x07, 0x0B, 
	0x08, 0x06, 0x09, 0x09, 0x07, 0x09, 0x00, 0x0E, 0x12, 0x09, 0x04, 0x07, 0x04, 0x0B, 0x0E, 0x09, 
	0x07, 0x09, 0x08, 0x06, 0x09, 0x08, 0x0C, 0x0E, 0x04, 0x08, 0x0C, 0x08, 0x0D, 0x0F, 0x08, 0x0C, 
	0x0F, 0x07, 0x06, 0x08, 0x0F, 0x16, 0x1A, 0x44, 0xA6, 0xB9, 0x38, 0x93, 0xA4, 0x11, 0x12, 0x09, 
	0xC3, 0xB1, 0xA3, 0xD5, 0xBD, 0xAB, 0x59, 0x74, 0x77, 0x38, 0x70, 0x7A, 0x38, 0x77, 0x81, 0x38, 
	0x65, 0x6E, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x66, 0x70, 0x38, 0x67, 0x70, 0x39, 0x67, 
	0x71, 0x33, 0x5F, 0x65, 0x39, 0x62, 0x65, 0x39, 0x68, 0x73, 0x35, 0x5D, 0x60, 0x32, 0x5B, 0x61, 
	0x32, 0x5E, 0x67, 0x35, 0x64, 0x6C, 0x33, 0x61, 0x6B, 0x22, 0x53, 0x5B, 0x34, 0x5F, 0x65, 0x2A, 
	0x4E, 0x58, 0x34, 0x5E, 0x65, 0x2E, 0x55, 0x59, 0x38, 0x53, 0x56, 0x58, 0x4B, 0x43, 0x56, 0x4C, 
	0x43, 0x57, 0x4D, 0x43, 0x51, 0x47, 0x3C, 0x4C, 0x46, 0x3B, 0x5F, 0x56, 0x4C, 0x69, 0x60, 0x54, 
	0x52, 0x48, 0x44, 0x54, 0x4A, 0x42, 0x08, 0x09, 0x09, 0x11, 0x20, 0x23, 0x13, 0x12, 0x11, 0x15, 
	0x0D, 0x0F, 0x16, 0x1B, 0x1A, 0x18, 0x19, 0x14, 0x1B, 0x19, 0x14, 0x1A, 0x22, 0x1D, 0x19, 0x1B, 
	0x18, 0x19, 0x11, 0x11, 0x19, 0x12, 0x12, 0x1E, 0x0C, 0x0B, 0x0E, 0x23, 0x29, 0x18, 0x13, 0x13, 
	0x1F, 0x12, 0x0E, 0x1A, 0x1E, 0x19, 0x1D, 0x24, 0x1E, 0x1D, 0x24, 0x1F, 0x1B, 0x1F, 0x1E, 0x16, 
	0x18, 0x13, 0x1D, 0x1E, 0x20, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1F, 0x1A, 0x1B, 0x1D, 0x1E, 
	0x1F, 0x1D, 0x1E, 0x1F, 0x1D, 0x1E, 0x1F, 0x1C, 0x1D, 0x1F, 0x27, 0x24, 0x22, 0x1B, 0x23, 0x1D, 
	0x1B, 0x23, 0x1E, 0x31, 0x2A, 0x26, 0x25, 0x26, 0x22, 0x25, 0x25, 0x1F, 0x13, 0x13, 0x14, 0x3B, 
	0x81, 0x92, 0x39, 0x96, 0xB1, 0x4C, 0xC6, 0xD4, 0x46, 0xB4, 0xC7, 0x46, 0xAA, 0xBC, 0x45, 0xAF, 
	0xC0, 0x46, 0xAE, 0xC0, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 
	0x46, 0xAE, 0xBF, 0x46, 0xAE, 0xC0, 0x45, 0xAE, 0xBF, 0x45, 0xAE, 0xBE, 0x4B, 0xAE, 0xBF, 0x45, 
	0xAE, 0xC0, 0x48, 0xAE, 0xC0, 0x4B, 0xAE, 0xC0, 0x44, 0xAD, 0xBD, 0x4B, 0xB3, 0xCB, 0x4F, 0xC4, 
	0xD4, 0x50, 0xC2, 0xD6, 0x53, 0xC9, 0xDE, 0x2B, 0x66, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x02, 0x02, 0x0B, 0x0C, 0x0C, 0x12, 0x1F, 0x1E, 0x43, 0x57, 0x62, 0x13, 0x1F, 0x1E, 0x06, 
	0x06, 0x06, 0x03, 0x03, 0x00, 0x3C, 0x97, 0xA5, 0x4F, 0xC7, 0xDB, 0x53, 0xC2, 0xDB, 0x50, 0xC5, 
	0xD9, 0x4A, 0xB8, 0xD3, 0x49, 0xAB, 0xC0, 0x50, 0xBB, 0xD2, 0x49, 0xAD, 0xC3, 0x4D, 0xB2, 0xC4, 
	0x4F, 0xB5, 0xC4, 0x49, 0xAE, 0xC4, 0x49, 0xAB, 0xC1, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x49, 
	0xAE, 0xC4, 0x4F, 0xB3, 0xC3, 0x4F, 0xC0, 0xDA, 0x49, 0xAC, 0xC2, 0x4A, 0xAE, 0xC3, 0x49, 0xAE, 
	0xC4, 0x4C, 0xB0, 0xC2, 0x4C, 0xBB, 0xD3, 0x39, 0x99, 0xB3, 0x3E, 0x9B, 0xAF, 0x09, 0x0E, 0x14, 
	0x49, 0x42, 0x36, 0x44, 0x39, 0x33, 0x36, 0x27, 0x24, 0x0C, 0x27, 0x26, 0x11, 0x20, 0x25, 0x11, 
	0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x23, 0x27, 0x11, 0x1F, 0x24, 0x11, 0x1C, 0x20, 0x11, 0x24, 
	0x28, 0x12, 0x1D, 0x22, 0x11, 0x1D, 0x23, 0x11, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x12, 0x1E, 0x23, 
	0x12, 0x1E, 0x23, 0x12, 0x1D, 0x22, 0x12, 0x1E, 0x23, 0x14, 0x1F, 0x25, 0x0C, 0x19, 0x16, 0x0D, 
	0x1A, 0x19, 0x0C, 0x19, 0x18, 0x0C, 0x1A, 0x19, 0x0D, 0x1E, 0x22, 0x1B, 0x14, 0x12, 0x1A, 0x16, 
	0x0F, 0x16, 0x0E, 0x0F, 0x1B, 0x0F, 0x11, 0x18, 0x0E, 0x0F, 0x19, 0x1B, 0x16, 0x18, 0x1A, 0x15, 
	0x1B, 0x15, 0x13, 0x14, 0x15, 0x16, 0x00, 0x00, 0x00, 0x06, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x03, 0x03, 0x03, 0x02, 0x02, 0x03, 0x06, 0x06, 0x07, 0x02, 0x02, 0x02, 0x03, 0x02, 
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x02, 0x04, 0x04, 0x04, 0x02, 0x00, 0x03, 0x03, 0x03, 
	0x02, 0x03, 0x04, 0x02, 0x02, 0x03, 0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x03, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x02, 0x02, 0x00, 0x02, 
	0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 
	0x81, 0x92, 0x48, 0xB7, 0xCA, 0x50, 0xC5, 0xD9, 0x50, 0xC5, 0xD6, 0x4A, 0xC5, 0xD4, 0x51, 0xC5, 
	0xD8, 0x4A, 0xC5, 0xD4, 0x4D, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4B, 0xC5, 0xD5, 0x4A, 0xC5, 0xD4, 
	0x51, 0xC5, 0xD8, 0x4A, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x55, 0xC5, 0xDF, 0x51, 0xC5, 0xDA, 0x4D, 
	0xC5, 0xD4, 0x49, 0xC5, 0xD5, 0x50, 0xC5, 0xD4, 0x4F, 0xC5, 0xDA, 0x52, 0xC5, 0xD8, 0x47, 0xC2, 
	0xD1, 0x4E, 0xC2, 0xD4, 0x52, 0xC6, 0xDB, 0x44, 0xA1, 0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x06, 0x0C, 0x0C, 0x31, 0x36, 0x34, 0xA1, 0xB4, 0xC4, 0x2A, 0x3A, 0x39, 0x00, 
	0x02, 0x00, 0x00, 0x03, 0x03, 0x46, 0xA6, 0xB4, 0x54, 0xC5, 0xDD, 0x4F, 0xC2, 0xD4, 0x4F, 0xC2, 
	0xD3, 0x53, 0xC4, 0xDD, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDC, 0x54, 0xC5, 0xDE, 0x4D, 0xC5, 0xD8, 
	0x54, 0xC5, 0xDE, 0x52, 0xC5, 0xDC, 0x5E, 0xD1, 0xE4, 0x5B, 0xCC, 0xE3, 0x53, 0xC5, 0xDD, 0x53, 
	0xC5, 0xDE, 0x53, 0xC5, 0xD2, 0x52, 0xC3, 0xDC, 0x53, 0xC5, 0xDD, 0x53, 0xC5, 0xDE, 0x53, 0xC5, 
	0xD2, 0x52, 0xC5, 0xDE, 0x5A, 0xCF, 0xE0, 0x49, 0x9F, 0xB8, 0x3A, 0x94, 0xA2, 0x09, 0x11, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x00, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x00, 
	0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 
	0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x00, 0x04, 0x02, 0x02, 0x04, 
	0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x04, 0x02, 0x02, 0x02, 0x03, 0x03, 0x02, 0x03, 
	0x04, 0x03, 0x04, 0x04, 0x02, 0x04, 0x04, 0x03, 0x04, 0x04, 0x02, 0x02, 0x03, 0x02, 0x02, 0x03, 
	0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3D, 
	0x82, 0x93, 0x3C, 0x9D, 0xB7, 0x4A, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD6, 0x4E, 0xC2, 0xD1, 0x48, 
	0xC2, 0xD2, 0x55, 0xC2, 0xD2, 0x47, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4A, 0xC2, 0xD1, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD1, 0x4F, 0xC3, 0xD7, 0x51, 0xC5, 0xDC, 0x1E, 0x3E, 0x46, 0x03, 0x00, 0x00, 
	0x08, 0x06, 0x06, 0x09, 0x08, 0x08, 0x09, 0x12, 0x15, 0x24, 0x2E, 0x2C, 0x0E, 0x08, 0x08, 0x02, 
	0x00, 0x00, 0x18, 0x33, 0x37, 0x4E, 0xBC, 0xD6, 0x53, 0xC4, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD0, 0x52, 0xC2, 0xCF, 0x53, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD1, 0x53, 0xC1, 0xDA, 0x57, 0xC6, 0xD8, 0x4B, 0xC0, 0xD4, 0x4C, 0xC2, 0xD1, 0x52, 
	0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 
	0xDA, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3C, 0xA1, 0xB9, 0x42, 0xA0, 0xB6, 0x09, 0x12, 0x14, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x0D, 0x0D, 0x03, 0x06, 0x06, 0x03, 0x07, 0x06, 0x03, 
	0x07, 0x06, 0x02, 0x06, 0x06, 0x00, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x06, 0x07, 0x00, 0x07, 
	0x07, 0x00, 0x04, 0x04, 0x00, 0x04, 0x04, 0x03, 0x06, 0x06, 0x00, 0x06, 0x07, 0x00, 0x04, 0x06, 
	0x00, 0x03, 0x04, 0x00, 0x04, 0x06, 0x00, 0x04, 0x06, 0x00, 0x03, 0x04, 0x12, 0x0B, 0x0C, 0x0F, 
	0x09, 0x0B, 0x0D, 0x07, 0x08, 0x08, 0x08, 0x09, 0x00, 0x03, 0x04, 0x14, 0x0B, 0x0C, 0x00, 0x03, 
	0x04, 0x13, 0x0C, 0x0C, 0x11, 0x0B, 0x0B, 0x0F, 0x09, 0x0B, 0x11, 0x0B, 0x0C, 0x0F, 0x09, 0x0B, 
	0x0F, 0x09, 0x0B, 0x0E, 0x08, 0x09, 0x0E, 0x08, 0x09, 0x13, 0x09, 0x09, 0x1A, 0x29, 0x2E, 0x35, 
	0x8B, 0x9B, 0x3B, 0x98, 0xB3, 0x4B, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x4C, 0xC2, 
	0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x4C, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x53, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDD, 0x4F, 0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x52, 0xC5, 0xD9, 0x50, 0xBD, 0xD4, 0x0D, 0x27, 0x2B, 
	0x00, 0x00, 0x00, 0x09, 0x06, 0x04, 0x06, 0x03, 0x02, 0x02, 0x00, 0x00, 0x03, 0x06, 0x04, 0x11, 
	0x15, 0x13, 0x49, 0xB2, 0xC8, 0x51, 0xC7, 0xDD, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x53, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x53, 0xC2, 0xDA, 0x49, 0xC2, 0xCE, 0x52, 0xC1, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x53, 0xC3, 
	0xD9, 0x5D, 0xCD, 0xD9, 0x52, 0xC7, 0xDB, 0x46, 0x99, 0xB2, 0x3D, 0x9B, 0xAD, 0x0D, 0x0B, 0x0E, 
	0x0E, 0x08, 0x09, 0x0F, 0x0F, 0x09, 0x06, 0x08, 0x09, 0x00, 0x09, 0x09, 0x02, 0x03, 0x02, 0x02, 
	0x03, 0x02, 0x04, 0x09, 0x08, 0x04, 0x08, 0x08, 0x08, 0x12, 0x12, 0x03, 0x02, 0x00, 0x02, 0x03, 
	0x02, 0x00, 0x02, 0x02, 0x00, 0x02, 0x02, 0x00, 0x03, 0x02, 0x02, 0x04, 0x03, 0x02, 0x04, 0x03, 
	0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x04, 0x03, 0x02, 0x04, 0x03, 0x02, 
	0x04, 0x03, 0x03, 0x04, 0x04, 0x02, 0x04, 0x03, 0x00, 0x03, 0x03, 0x02, 0x04, 0x03, 0x03, 0x04, 
	0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x04, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 0x03, 0x06, 0x06, 
	0x03, 0x07, 0x06, 0x03, 0x07, 0x06, 0x1A, 0x31, 0x35, 0x1B, 0x2F, 0x34, 0x1B, 0x2F, 0x33, 0x19, 
	0x31, 0x35, 0x1E, 0x36, 0x3C, 0x34, 0x39, 0x33, 0x39, 0x39, 0x2E, 0x3C, 0x3A, 0x33, 0x31, 0x26, 
	0x25, 0x4B, 0x46, 0x40, 0x2E, 0x40, 0x3F, 0x1A, 0x31, 0x3A, 0x32, 0x35, 0x2B, 0x49, 0x43, 0x38, 
	0x4D, 0x49, 0x3D, 0x48, 0x3D, 0x39, 0x47, 0x3C, 0x38, 0x4A, 0x46, 0x3A, 0x4A, 0x47, 0x3C, 0x4D, 
	0x43, 0x40, 0x70, 0x68, 0x57, 0x3C, 0x35, 0x2E, 0x44, 0x3E, 0x38, 0x4C, 0x49, 0x3D, 0x43, 0x3A, 
	0x3A, 0x45, 0x3D, 0x36, 0x48, 0x45, 0x3D, 0x4B, 0x48, 0x3C, 0x44, 0x39, 0x36, 0x4A, 0x47, 0x3C, 
	0x48, 0x45, 0x3B, 0x5B, 0x51, 0x48, 0x5B, 0x51, 0x48, 0x4C, 0x47, 0x3C, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3B, 0x99, 0xB3, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD4, 0x48, 0xC2, 0xD0, 0x55, 0xC2, 
	0xDC, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 
	0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x4E, 0xC5, 0xD7, 0x51, 0xBA, 0xD0, 
	0x2C, 0x67, 0x73, 0x0E, 0x16, 0x18, 0x03, 0x04, 0x07, 0x08, 0x13, 0x15, 0x26, 0x4C, 0x53, 0x4B, 
	0xB8, 0xCC, 0x52, 0xC5, 0xDC, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xCF, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x54, 0xC2, 0xDB, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x4C, 0xC2, 0xD2, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xDA, 0x5D, 0xCD, 
	0xD9, 0x4F, 0xBE, 0xD9, 0x4E, 0xC5, 0xD8, 0x38, 0x96, 0xB0, 0x38, 0x93, 0xA2, 0x0F, 0x09, 0x08, 
	0x95, 0x86, 0x7C, 0x87, 0x86, 0x7F, 0x6B, 0x67, 0x60, 0x37, 0x4E, 0x52, 0x19, 0x46, 0x50, 0x1F, 
	0x48, 0x4F, 0x2E, 0x59, 0x61, 0x28, 0x4E, 0x4D, 0x2A, 0x4F, 0x4E, 0x15, 0x44, 0x4F, 0x28, 0x4E, 
	0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x50, 0x4F, 0x2A, 0x4F, 0x50, 0x25, 0x3F, 0x4A, 0x1F, 0x45, 0x4F, 
	0x1F, 0x40, 0x4A, 0x20, 0x45, 0x4E, 0x1C, 0x3B, 0x46, 0x1F, 0x3E, 0x45, 0x26, 0x42, 0x4D, 0x23, 
	0x3E, 0x46, 0x1E, 0x3C, 0x40, 0x26, 0x3E, 0x47, 0x44, 0x4F, 0x4D, 0x20, 0x3E, 0x47, 0x1F, 0x3E, 
	0x42, 0x1F, 0x38, 0x42, 0x20, 0x39, 0x43, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 0x1A, 0x33, 0x37, 
	0x1A, 0x31, 0x35, 0x1A, 0x2F, 0x33, 0x1E, 0x31, 0x3A, 0x14, 0x27, 0x27, 0x18, 0x2A, 0x2E, 0x1A, 
	0x30, 0x3A, 0x3F, 0x2F, 0x2E, 0x3A, 0x2F, 0x31, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x3A, 0x38, 
	0x32, 0x3A, 0x38, 0x2C, 0x13, 0x34, 0x40, 0x0E, 0x39, 0x44, 0x28, 0x2F, 0x2F, 0x4C, 0x3F, 0x36, 
	0x4E, 0x40, 0x3A, 0x39, 0x46, 0x45, 0x40, 0x35, 0x32, 0x46, 0x3E, 0x36, 0x4A, 0x3F, 0x37, 0x50, 
	0x48, 0x42, 0x69, 0x60, 0x54, 0x42, 0x3B, 0x39, 0x4B, 0x40, 0x37, 0x4C, 0x40, 0x39, 0x4B, 0x42, 
	0x38, 0x4B, 0x40, 0x37, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 
	0x4F, 0x46, 0x3C, 0x4D, 0x44, 0x3B, 0x50, 0x48, 0x3E, 0x54, 0x49, 0x3E, 0x1A, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x51, 0xC6, 0xDB, 0x4C, 0xC2, 0xD4, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 
	0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x50, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x55, 0xBF, 0xCE, 0x4E, 0xC5, 0xDA, 0x50, 0xC2, 0xD5, 0x53, 0xC5, 0xDB, 
	0x53, 0xC6, 0xDC, 0x5A, 0xBD, 0xD6, 0x4D, 0xB7, 0xCF, 0x4E, 0xB5, 0xCC, 0x56, 0xCB, 0xE1, 0x4D, 
	0xCB, 0xDD, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x4D, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 0x54, 0xC2, 0xDB, 0x46, 0xC2, 0xCE, 0x53, 0xC2, 0xDA, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDB, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 0xCF, 0x52, 0xC2, 0xDA, 0x52, 
	0xC2, 0xDA, 0x51, 0xC0, 0xCE, 0x5E, 0xCE, 0xDA, 0x51, 0xC0, 0xDA, 0x4B, 0xC1, 0xCE, 0x55, 0xC5, 
	0xDA, 0x5D, 0xCD, 0xD9, 0x53, 0xC7, 0xDA, 0x3D, 0xA1, 0xB9, 0x4F, 0xA6, 0xBD, 0x02, 0x04, 0x03, 
	0x7F, 0x70, 0x61, 0x8F, 0x7C, 0x6C, 0x75, 0x6E, 0x66, 0x63, 0x5D, 0x58, 0x1C, 0x3C, 0x45, 0x12, 
	0x3D, 0x48, 0x34, 0x56, 0x53, 0x2B, 0x4E, 0x53, 0x32, 0x54, 0x53, 0x2E, 0x4F, 0x53, 0x26, 0x49, 
	0x53, 0x28, 0x4A, 0x53, 0x27, 0x4A, 0x53, 0x27, 0x4A, 0x54, 0x22, 0x46, 0x49, 0x1C, 0x43, 0x44, 
	0x1D, 0x4A, 0x51, 0x1C, 0x4C, 0x55, 0x1D, 0x43, 0x43, 0x19, 0x49, 0x53, 0x20, 0x44, 0x44, 0x1C, 
	0x49, 0x4D, 0x1B, 0x3A, 0x3F, 0x25, 0x3E, 0x40, 0x31, 0x40, 0x40, 0x1A, 0x40, 0x40, 0x1D, 0x30, 
	0x39, 0x1A, 0x31, 0x39, 0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3A, 0x1D, 0x3B, 0x44, 
	0x1D, 0x32, 0x3B, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1C, 
	0x2F, 0x38, 0x24, 0x30, 0x30, 0x2F, 0x30, 0x24, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x31, 0x2E, 
	0x28, 0x3A, 0x31, 0x2E, 0x30, 0x43, 0x3E, 0x11, 0x3A, 0x42, 0x22, 0x30, 0x36, 0x27, 0x3C, 0x38, 
	0x42, 0x37, 0x2B, 0x24, 0x42, 0x43, 0x44, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4B, 0x40, 0x38, 0x43, 
	0x3C, 0x33, 0x43, 0x3B, 0x36, 0x4A, 0x3F, 0x36, 0x4D, 0x43, 0x40, 0x31, 0x34, 0x2B, 0x4D, 0x42, 
	0x38, 0x4A, 0x40, 0x40, 0x49, 0x3F, 0x36, 0x4F, 0x47, 0x43, 0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x40, 
	0x4E, 0x45, 0x3B, 0x4D, 0x44, 0x3B, 0x51, 0x48, 0x3E, 0x46, 0x42, 0x37, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB1, 0x4E, 0xC7, 0xD8, 0x49, 0xBC, 0xCB, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x4E, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x53, 0xC2, 0xDD, 0x4E, 0xC2, 
	0xD0, 0x4C, 0xC5, 0xD6, 0x42, 0xAD, 0xC3, 0x46, 0xA7, 0xB7, 0x56, 0xCB, 0xE2, 0x52, 0xC7, 0xDB, 
	0x51, 0xCA, 0xDE, 0x57, 0xCE, 0xE4, 0x5A, 0xCF, 0xE4, 0x57, 0xD1, 0xE3, 0x51, 0xC5, 0xDD, 0x39, 
	0x8E, 0x9C, 0x53, 0xC8, 0xDD, 0x50, 0xC3, 0xD9, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xD0, 0x49, 0xC2, 
	0xCF, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 
	0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x4D, 0xC0, 0xD7, 0x5C, 0xCC, 
	0xD9, 0x4E, 0xBE, 0xD9, 0x5A, 0xCC, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x93, 0xA3, 0x00, 0x06, 0x04, 
	0x68, 0x5C, 0x54, 0x91, 0x80, 0x6E, 0x81, 0x6F, 0x62, 0x85, 0x77, 0x68, 0x36, 0x47, 0x47, 0x18, 
	0x4B, 0x54, 0x2A, 0x46, 0x4C, 0x25, 0x49, 0x52, 0x28, 0x4B, 0x52, 0x2B, 0x4E, 0x52, 0x29, 0x4B, 
	0x52, 0x18, 0x49, 0x52, 0x29, 0x4A, 0x52, 0x27, 0x4A, 0x52, 0x25, 0x48, 0x4F, 0x1B, 0x3B, 0x3C, 
	0x1D, 0x3B, 0x3C, 0x1D, 0x4A, 0x51, 0x1D, 0x3E, 0x3C, 0x1D, 0x3A, 0x3E, 0x1D, 0x3B, 0x3F, 0x1C, 
	0x3A, 0x3E, 0x20, 0x40, 0x3E, 0x39, 0x3B, 0x35, 0x39, 0x3B, 0x35, 0x1A, 0x3A, 0x43, 0x1D, 0x2E, 
	0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x32, 0x3B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x16, 
	0x36, 0x40, 0x2B, 0x30, 0x29, 0x36, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x2E, 
	0x24, 0x36, 0x42, 0x3C, 0x3D, 0x30, 0x2A, 0x13, 0x39, 0x42, 0x1D, 0x46, 0x48, 0x19, 0x3F, 0x3F, 
	0x23, 0x45, 0x48, 0x26, 0x45, 0x49, 0x45, 0x36, 0x32, 0x3F, 0x3B, 0x33, 0x4C, 0x42, 0x39, 0x4D, 
	0x42, 0x39, 0x31, 0x34, 0x2B, 0x50, 0x47, 0x3D, 0x61, 0x58, 0x4D, 0x32, 0x34, 0x2B, 0x3F, 0x3B, 
	0x32, 0x4A, 0x3F, 0x40, 0x49, 0x3F, 0x36, 0x4B, 0x43, 0x3E, 0x51, 0x49, 0x3E, 0x58, 0x50, 0x47, 
	0x4E, 0x43, 0x3E, 0x54, 0x4C, 0x42, 0x53, 0x4B, 0x42, 0x54, 0x49, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x89, 0x99, 0x45, 0xAD, 0xC4, 0x4A, 0xBF, 0xCE, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4B, 
	0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x4E, 0xC2, 0xD3, 0x53, 0xC2, 0xDC, 0x52, 0xC2, 0xCF, 0x4C, 0xC1, 
	0xD4, 0x55, 0xCD, 0xE1, 0x31, 0x78, 0x87, 0x00, 0x00, 0x00, 0x29, 0x53, 0x5B, 0x38, 0x87, 0x9B, 
	0x40, 0xA2, 0xAF, 0x3E, 0xA0, 0xAB, 0x47, 0xA9, 0xB8, 0x32, 0x82, 0x94, 0x27, 0x52, 0x58, 0x00, 
	0x00, 0x00, 0x31, 0x7B, 0x85, 0x54, 0xCC, 0xE3, 0x53, 0xC3, 0xDB, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 
	0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x4E, 0xC1, 0xD1, 0x4E, 
	0xC1, 0xD1, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD8, 0x5A, 0xCA, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x5D, 0xCD, 0xDA, 0x52, 0xC7, 0xDA, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x68, 0x5B, 0x50, 0x90, 0x7E, 0x70, 0x8E, 0x7D, 0x6F, 0x84, 0x75, 0x68, 0x4D, 0x54, 0x53, 0x18, 
	0x49, 0x53, 0x28, 0x47, 0x4C, 0x29, 0x4C, 0x52, 0x25, 0x48, 0x52, 0x29, 0x4B, 0x52, 0x33, 0x55, 
	0x52, 0x27, 0x4B, 0x52, 0x18, 0x49, 0x52, 0x28, 0x4A, 0x52, 0x27, 0x4A, 0x53, 0x26, 0x49, 0x50, 
	0x1B, 0x3E, 0x3C, 0x1D, 0x43, 0x45, 0x1D, 0x46, 0x4B, 0x1E, 0x3D, 0x3D, 0x0E, 0x35, 0x3F, 0x1C, 
	0x3B, 0x3D, 0x2A, 0x4E, 0x59, 0x1F, 0x3C, 0x3E, 0x20, 0x3D, 0x40, 0x1C, 0x3D, 0x42, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x1D, 0x32, 0x3B, 0x16, 0x28, 0x2A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x1F, 
	0x2F, 0x35, 0x31, 0x29, 0x1D, 0x31, 0x30, 0x28, 0x34, 0x2F, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x30, 
	0x24, 0x11, 0x2C, 0x3C, 0x3D, 0x37, 0x2E, 0x34, 0x3F, 0x3B, 0x38, 0x43, 0x43, 0x1C, 0x45, 0x47, 
	0x19, 0x36, 0x3E, 0x2B, 0x3B, 0x34, 0x3B, 0x33, 0x30, 0x4B, 0x40, 0x38, 0x3E, 0x38, 0x33, 0x49, 
	0x40, 0x37, 0x34, 0x36, 0x2E, 0x47, 0x3F, 0x37, 0x5E, 0x56, 0x4A, 0x37, 0x36, 0x2E, 0x46, 0x3D, 
	0x35, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x49, 0x3F, 0x3C, 0x3B, 0x37, 0x2E, 0x5B, 0x4F, 0x47, 
	0x33, 0x4D, 0x50, 0x4A, 0x3C, 0x36, 0x4F, 0x47, 0x3C, 0x4D, 0x46, 0x3A, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9D, 0xB6, 0x4B, 0xC1, 0xD0, 0x4A, 0xC3, 0xD3, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x4B, 0xC2, 0xD1, 0x49, 
	0xC2, 0xD1, 0x4B, 0xC2, 0xD3, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x53, 0xC2, 0xD9, 0x53, 0xC3, 
	0xD4, 0x54, 0xC5, 0xE1, 0x04, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x07, 0x04, 
	0x04, 0x03, 0x02, 0x03, 0x02, 0x00, 0x03, 0x02, 0x00, 0x06, 0x08, 0x06, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x04, 0x00, 0x00, 0x32, 0x76, 0x85, 0x51, 0xC5, 0xDC, 0x52, 0xC2, 0xD7, 0x52, 0xC2, 
	0xD9, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4C, 0xC2, 0xCE, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 
	0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC1, 0xD9, 0x57, 0xC7, 0xD9, 0x5A, 
	0xCA, 0xDC, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xD8, 0x5D, 0xCD, 0xE4, 0x4F, 0xBE, 0xD8, 0x51, 0xC0, 
	0xD7, 0x51, 0xC0, 0xCF, 0x4F, 0xC5, 0xD8, 0x49, 0x9E, 0xB7, 0x3A, 0x96, 0xA6, 0x04, 0x00, 0x00, 
	0x62, 0x54, 0x47, 0x71, 0x6C, 0x5E, 0x8F, 0x7C, 0x6B, 0x88, 0x75, 0x69, 0x63, 0x5C, 0x4F, 0x23, 
	0x42, 0x48, 0x18, 0x4A, 0x53, 0x31, 0x52, 0x53, 0x2C, 0x4E, 0x52, 0x16, 0x49, 0x52, 0x29, 0x4B, 
	0x53, 0x33, 0x55, 0x52, 0x2A, 0x4C, 0x52, 0x26, 0x49, 0x52, 0x27, 0x4A, 0x53, 0x28, 0x4A, 0x53, 
	0x26, 0x49, 0x50, 0x1C, 0x3E, 0x3C, 0x1D, 0x4A, 0x51, 0x1C, 0x49, 0x50, 0x23, 0x43, 0x46, 0x1C, 
	0x38, 0x3F, 0x1F, 0x44, 0x45, 0x1B, 0x40, 0x3E, 0x22, 0x46, 0x47, 0x1C, 0x3D, 0x40, 0x1D, 0x2E, 
	0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 0x1E, 0x31, 0x3A, 
	0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x16, 0x32, 0x3C, 0x3B, 
	0x2F, 0x2B, 0x2E, 0x30, 0x25, 0x3A, 0x35, 0x32, 0x39, 0x37, 0x31, 0x30, 0x2E, 0x27, 0x34, 0x2F, 
	0x2B, 0x35, 0x30, 0x26, 0x27, 0x26, 0x24, 0x2A, 0x3E, 0x42, 0x3D, 0x4E, 0x4D, 0x34, 0x3E, 0x3D, 
	0x22, 0x49, 0x4D, 0x27, 0x45, 0x49, 0x42, 0x39, 0x2F, 0x61, 0x58, 0x4A, 0x31, 0x2C, 0x24, 0x33, 
	0x2F, 0x2C, 0x37, 0x38, 0x2F, 0x46, 0x3D, 0x34, 0x48, 0x3E, 0x36, 0x4D, 0x42, 0x39, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x49, 0x3E, 0x35, 0x56, 0x4D, 0x40, 0x46, 0x40, 0x42, 0x60, 0x56, 0x46, 
	0x46, 0x4C, 0x4B, 0x48, 0x42, 0x40, 0x48, 0x3D, 0x34, 0x54, 0x4A, 0x3E, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC2, 0xD1, 0x4A, 0xB9, 0xC9, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 
	0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x48, 0xC2, 0xD1, 0x4D, 0xC1, 0xD5, 0x53, 0xCB, 
	0xDF, 0x3A, 0x8D, 0x9D, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x04, 0x03, 0x03, 0x0C, 0x0B, 0x0B, 
	0x00, 0x00, 0x00, 0x08, 0x07, 0x07, 0x04, 0x02, 0x02, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0C, 
	0x0B, 0x0B, 0x04, 0x00, 0x00, 0x0F, 0x1E, 0x20, 0x4E, 0xBC, 0xD2, 0x53, 0xC5, 0xDA, 0x52, 0xC2, 
	0xDA, 0x4D, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4F, 0xC0, 0xD6, 0x5E, 0xCE, 0xE4, 0x51, 0xC0, 0xD6, 
	0x52, 0xC2, 0xCE, 0x52, 0xC2, 0xDA, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5A, 
	0xCA, 0xD8, 0x50, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5E, 0xCE, 0xD9, 0x51, 0xC0, 
	0xD9, 0x51, 0xC1, 0xD7, 0x59, 0xCC, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x5E, 0x54, 0x47, 0x62, 0x5A, 0x48, 0x74, 0x6E, 0x66, 0x81, 0x71, 0x66, 0x6D, 0x5F, 0x51, 0x4C, 
	0x5C, 0x5D, 0x11, 0x43, 0x4C, 0x28, 0x44, 0x47, 0x2E, 0x50, 0x54, 0x29, 0x4A, 0x53, 0x22, 0x44, 
	0x47, 0x27, 0x4D, 0x53, 0x27, 0x49, 0x52, 0x28, 0x4B, 0x54, 0x1D, 0x43, 0x45, 0x19, 0x4A, 0x53, 
	0x2A, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3C, 0x3C, 0x1D, 0x4D, 0x56, 0x13, 0x34, 0x3C, 0x1D, 
	0x2E, 0x38, 0x1D, 0x44, 0x40, 0x1E, 0x3A, 0x42, 0x0F, 0x36, 0x3F, 0x1E, 0x38, 0x42, 0x1D, 0x2F, 
	0x37, 0x1D, 0x30, 0x39, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2C, 
	0x18, 0x2A, 0x2E, 0x15, 0x28, 0x2A, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1A, 0x2E, 0x37, 0x3C, 
	0x32, 0x30, 0x30, 0x2F, 0x27, 0x30, 0x2E, 0x27, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x3A, 0x35, 
	0x31, 0x29, 0x2F, 0x29, 0x19, 0x31, 0x3C, 0x23, 0x1E, 0x22, 0x1E, 0x45, 0x4F, 0x19, 0x33, 0x3D, 
	0x1B, 0x3D, 0x3F, 0x1C, 0x3B, 0x3E, 0x45, 0x3C, 0x33, 0x76, 0x6C, 0x5B, 0x4C, 0x46, 0x3D, 0x30, 
	0x30, 0x26, 0x29, 0x33, 0x32, 0x51, 0x4A, 0x49, 0x4F, 0x40, 0x36, 0x3A, 0x37, 0x2E, 0x4E, 0x40, 
	0x36, 0x4E, 0x43, 0x42, 0x48, 0x42, 0x40, 0x49, 0x4B, 0x46, 0x3F, 0x40, 0x42, 0x53, 0x4A, 0x46, 
	0x49, 0x4C, 0x4A, 0x40, 0x47, 0x49, 0x55, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x49, 0xB5, 0xCA, 0x4A, 0xBF, 0xCF, 0x49, 0xC3, 0xD3, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x4D, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x55, 0xC2, 0xDD, 0x4E, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD2, 0x4D, 
	0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD0, 0x48, 0xC2, 0xD1, 0x51, 0xC4, 0xD7, 0x54, 0xC5, 
	0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 
	0x0C, 0x0C, 0x0B, 0x13, 0x13, 0x03, 0x02, 0x00, 0x31, 0x65, 0x72, 0x55, 0xC9, 0xE0, 0x52, 0xC2, 
	0xDA, 0x4C, 0xC2, 0xD1, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD6, 0x52, 0xC2, 0xDA, 
	0x51, 0xC1, 0xDA, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x50, 
	0xC0, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xCA, 0xD9, 0x53, 0xC3, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 0xC1, 
	0xD9, 0x50, 0xC0, 0xD9, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x08, 0x07, 
	0x63, 0x57, 0x49, 0x5B, 0x53, 0x48, 0x6B, 0x62, 0x52, 0x6E, 0x6E, 0x66, 0x74, 0x60, 0x4D, 0x60, 
	0x64, 0x61, 0x1E, 0x3F, 0x49, 0x13, 0x3C, 0x47, 0x18, 0x40, 0x40, 0x19, 0x49, 0x50, 0x0D, 0x31, 
	0x3B, 0x19, 0x46, 0x4F, 0x1F, 0x49, 0x4F, 0x1F, 0x3B, 0x42, 0x27, 0x4A, 0x50, 0x26, 0x4B, 0x55, 
	0x19, 0x3C, 0x39, 0x1D, 0x42, 0x40, 0x1D, 0x39, 0x3D, 0x1D, 0x4E, 0x57, 0x18, 0x43, 0x4B, 0x1E, 
	0x2A, 0x33, 0x11, 0x39, 0x43, 0x1F, 0x2A, 0x34, 0x12, 0x38, 0x42, 0x1E, 0x3F, 0x42, 0x1D, 0x2E, 
	0x36, 0x1D, 0x30, 0x38, 0x1E, 0x31, 0x3A, 0x16, 0x29, 0x2B, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x24, 0x1D, 0x2F, 0x37, 0x1D, 0x3A, 0x43, 0x16, 0x30, 0x3A, 0x3B, 
	0x3A, 0x2E, 0x38, 0x31, 0x31, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x29, 0x36, 0x32, 0x2E, 0x39, 0x32, 
	0x31, 0x34, 0x2F, 0x25, 0x16, 0x32, 0x3C, 0x1A, 0x2C, 0x36, 0x3B, 0x46, 0x43, 0x20, 0x48, 0x4C, 
	0x1F, 0x40, 0x3F, 0x24, 0x34, 0x38, 0x30, 0x2C, 0x25, 0x4E, 0x48, 0x3F, 0x5C, 0x52, 0x4A, 0x46, 
	0x3A, 0x2F, 0x13, 0x3B, 0x3F, 0x2A, 0x39, 0x33, 0x23, 0x40, 0x42, 0x1B, 0x3A, 0x42, 0x29, 0x40, 
	0x42, 0x46, 0x4A, 0x4A, 0x34, 0x46, 0x47, 0x4F, 0x4D, 0x4A, 0x29, 0x4B, 0x4B, 0x1E, 0x3B, 0x3A, 
	0x30, 0x51, 0x53, 0x3C, 0x4A, 0x4B, 0x54, 0x4A, 0x3F, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4A, 0xC1, 0xCF, 0x4C, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD1, 0x54, 0xC2, 0xDD, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x4D, 0xC2, 0xD2, 0x54, 
	0xC2, 0xD1, 0x47, 0xC2, 0xD1, 0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD3, 0x53, 0xC6, 0xD8, 0x3A, 0x8D, 
	0x9D, 0x04, 0x06, 0x03, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 
	0x15, 0x15, 0x0B, 0x14, 0x14, 0x09, 0x0F, 0x0E, 0x04, 0x08, 0x06, 0x46, 0xAB, 0xC2, 0x54, 0xCA, 
	0xDF, 0x52, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xDA, 0x52, 0xC2, 0xCF, 0x51, 0xC1, 0xD4, 
	0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xC0, 0xD9, 0x51, 
	0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x50, 0xBF, 0xD9, 0x5C, 0xCC, 0xD8, 0x52, 0xC3, 0xD9, 0x53, 0xC3, 
	0xD8, 0x59, 0xC9, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x07, 0x06, 
	0x68, 0x5C, 0x4F, 0x63, 0x5B, 0x4C, 0x65, 0x5C, 0x4A, 0x65, 0x5E, 0x56, 0x70, 0x66, 0x59, 0x90, 
	0x7E, 0x6E, 0x62, 0x58, 0x4E, 0x38, 0x5B, 0x5E, 0x2E, 0x45, 0x4C, 0x38, 0x4F, 0x4F, 0x22, 0x3C, 
	0x3F, 0x1B, 0x40, 0x49, 0x19, 0x44, 0x4A, 0x0F, 0x34, 0x3E, 0x12, 0x37, 0x3C, 0x27, 0x49, 0x4F, 
	0x29, 0x4D, 0x56, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x3C, 0x1A, 0x49, 0x53, 0x1F, 
	0x3D, 0x3F, 0x11, 0x37, 0x40, 0x1F, 0x3A, 0x43, 0x12, 0x38, 0x40, 0x1D, 0x36, 0x3D, 0x1B, 0x31, 
	0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x13, 0x33, 0x3D, 0x39, 
	0x3B, 0x32, 0x42, 0x36, 0x33, 0x2C, 0x2C, 0x27, 0x2F, 0x26, 0x1C, 0x2F, 0x32, 0x26, 0x3A, 0x2F, 
	0x32, 0x36, 0x2F, 0x29, 0x16, 0x32, 0x3C, 0x13, 0x39, 0x44, 0x33, 0x40, 0x3F, 0x20, 0x4B, 0x54, 
	0x31, 0x40, 0x42, 0x35, 0x35, 0x30, 0x35, 0x33, 0x2C, 0x3A, 0x35, 0x2F, 0x52, 0x4B, 0x44, 0x34, 
	0x44, 0x48, 0x22, 0x48, 0x4E, 0x1A, 0x3F, 0x3F, 0x1E, 0x44, 0x47, 0x26, 0x40, 0x40, 0x48, 0x3A, 
	0x2F, 0x48, 0x40, 0x43, 0x2E, 0x38, 0x31, 0x25, 0x4C, 0x53, 0x49, 0x4A, 0x48, 0x1D, 0x4B, 0x56, 
	0x23, 0x47, 0x4E, 0x42, 0x40, 0x40, 0x54, 0x4B, 0x40, 0x52, 0x48, 0x3D, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9B, 0xB5, 0x4D, 0xC6, 0xD7, 0x4C, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD2, 0x47, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x54, 
	0xC2, 0xDD, 0x47, 0xC2, 0xD1, 0x53, 0xC2, 0xCF, 0x52, 0xC2, 0xD9, 0x56, 0xCB, 0xE2, 0x29, 0x53, 
	0x5A, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x0B, 0x09, 0x24, 0x4B, 0x52, 0x56, 0xCC, 
	0xE2, 0x52, 0xC2, 0xDA, 0x53, 0xC4, 0xD8, 0x5A, 0xCB, 0xD9, 0x51, 0xC1, 0xD7, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x54, 0xC4, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x59, 0xC9, 0xD9, 0x5D, 
	0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x53, 0xC3, 0xD8, 0x5B, 0xCB, 0xE4, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3D, 0xA0, 0xB8, 0x49, 0xA3, 0xBA, 0x00, 0x06, 0x03, 
	0x6B, 0x5D, 0x4F, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x6D, 0x64, 0x50, 0x4E, 0x47, 0x40, 0x73, 
	0x63, 0x54, 0x73, 0x6A, 0x58, 0x64, 0x5D, 0x5A, 0x6E, 0x67, 0x5D, 0x67, 0x5A, 0x4F, 0x69, 0x5C, 
	0x4E, 0x61, 0x58, 0x4E, 0x3F, 0x49, 0x4A, 0x3C, 0x47, 0x43, 0x0F, 0x37, 0x3F, 0x1D, 0x40, 0x44, 
	0x2A, 0x4D, 0x57, 0x1B, 0x40, 0x3D, 0x1B, 0x39, 0x3D, 0x1D, 0x3B, 0x40, 0x1B, 0x3B, 0x3E, 0x0F, 
	0x36, 0x40, 0x1D, 0x3C, 0x42, 0x1E, 0x2B, 0x34, 0x0F, 0x38, 0x42, 0x23, 0x47, 0x47, 0x0F, 0x36, 
	0x40, 0x18, 0x34, 0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3A, 0x13, 0x26, 0x25, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1C, 0x3A, 0x44, 0x23, 
	0x34, 0x38, 0x61, 0x57, 0x4A, 0x4C, 0x43, 0x3B, 0x29, 0x23, 0x1C, 0x25, 0x1C, 0x1C, 0x35, 0x31, 
	0x2C, 0x34, 0x32, 0x29, 0x22, 0x23, 0x29, 0x26, 0x2F, 0x2E, 0x32, 0x3B, 0x36, 0x35, 0x3B, 0x36, 
	0x33, 0x3D, 0x39, 0x39, 0x32, 0x2E, 0x38, 0x39, 0x30, 0x38, 0x31, 0x2E, 0x32, 0x32, 0x2C, 0x1E, 
	0x3B, 0x42, 0x1B, 0x3D, 0x3E, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 0x3F, 0x19, 0x3D, 0x42, 0x37, 0x3B, 
	0x36, 0x33, 0x3D, 0x3B, 0x1E, 0x40, 0x42, 0x24, 0x3E, 0x3D, 0x45, 0x4B, 0x4B, 0x1C, 0x47, 0x4E, 
	0x1A, 0x4A, 0x55, 0x48, 0x44, 0x45, 0x50, 0x47, 0x3F, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB5, 0xC9, 0x4F, 0xC4, 0xD8, 0x4C, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xBC, 
	0xCC, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4D, 0xC2, 0xD0, 0x54, 0xC2, 0xDC, 0x4A, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD1, 0x50, 0xC2, 0xD1, 0x52, 0xC2, 0xDC, 0x54, 0xC6, 0xD6, 0x46, 0xAF, 0xC4, 0x02, 0x04, 
	0x03, 0x07, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x07, 0x07, 0x07, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x06, 0x08, 0x03, 0x47, 0xA4, 
	0xBC, 0x53, 0xCA, 0xE0, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x5E, 0xCE, 0xD9, 
	0x50, 0xBF, 0xD9, 0x51, 0xC0, 0xD9, 0x52, 0xC2, 0xD9, 0x51, 0xC0, 0xD9, 0x5C, 0xCC, 0xD9, 0x52, 
	0xC3, 0xD9, 0x53, 0xC3, 0xD9, 0x5D, 0xCD, 0xD9, 0x4E, 0xBD, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 
	0xD9, 0x4E, 0xBE, 0xD8, 0x59, 0xCB, 0xDD, 0x3E, 0xA1, 0xBA, 0x3A, 0x94, 0xA3, 0x00, 0x04, 0x03, 
	0x69, 0x57, 0x4A, 0x61, 0x5B, 0x4B, 0x47, 0x3D, 0x36, 0x4A, 0x42, 0x39, 0x4C, 0x45, 0x3C, 0x69, 
	0x5E, 0x4B, 0x66, 0x63, 0x5E, 0x60, 0x5A, 0x56, 0x5E, 0x56, 0x4F, 0x60, 0x58, 0x52, 0x6A, 0x61, 
	0x52, 0x6A, 0x60, 0x53, 0x54, 0x4F, 0x49, 0x5C, 0x4C, 0x45, 0x14, 0x3B, 0x3E, 0x0E, 0x34, 0x3E, 
	0x1E, 0x42, 0x45, 0x1B, 0x3C, 0x3D, 0x2A, 0x4E, 0x58, 0x1B, 0x39, 0x3D, 0x1D, 0x3E, 0x40, 0x1C, 
	0x3C, 0x40, 0x0F, 0x37, 0x40, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x38, 0x20, 0x45, 0x48, 0x22, 0x46, 
	0x48, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 
	0x1E, 0x31, 0x3A, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1B, 0x30, 0x39, 0x23, 
	0x39, 0x3E, 0x5D, 0x52, 0x47, 0x7E, 0x6D, 0x5C, 0x48, 0x43, 0x3D, 0x2F, 0x27, 0x1F, 0x35, 0x31, 
	0x2E, 0x2B, 0x1E, 0x18, 0x11, 0x24, 0x25, 0x31, 0x29, 0x24, 0x36, 0x33, 0x2C, 0x38, 0x38, 0x2F, 
	0x38, 0x39, 0x2F, 0x38, 0x2C, 0x2F, 0x33, 0x38, 0x31, 0x36, 0x3D, 0x38, 0x18, 0x39, 0x3F, 0x1C, 
	0x39, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3D, 0x40, 0x1A, 0x40, 
	0x42, 0x1A, 0x40, 0x40, 0x1B, 0x40, 0x40, 0x23, 0x39, 0x40, 0x57, 0x48, 0x3D, 0x4E, 0x44, 0x40, 
	0x33, 0x50, 0x51, 0x4D, 0x4C, 0x48, 0x59, 0x4F, 0x46, 0x54, 0x4A, 0x3F, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4D, 0xC6, 0xD7, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x52, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD1, 0x4B, 0xC2, 0xD4, 0x55, 0xC2, 0xD9, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD1, 0x4D, 
	0xC2, 0xD2, 0x52, 0xC2, 0xD0, 0x53, 0xC3, 0xD6, 0x4F, 0xC2, 0xD9, 0x32, 0x70, 0x7D, 0x02, 0x03, 
	0x00, 0x03, 0x02, 0x02, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x09, 0x09, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x0B, 0x0D, 0x0D, 0x16, 0x33, 
	0x36, 0x54, 0xC9, 0xE1, 0x54, 0xC5, 0xDD, 0x50, 0xC0, 0xD8, 0x51, 0xC0, 0xD9, 0x51, 0xC0, 0xD9, 
	0x50, 0xC0, 0xD9, 0x5B, 0xCB, 0xD9, 0x51, 0xC1, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD9, 0x50, 
	0xBF, 0xD9, 0x59, 0xC9, 0xD9, 0x51, 0xC1, 0xD9, 0x58, 0xC8, 0xD9, 0x5B, 0xCB, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5B, 0xCB, 0xDB, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x59, 0x53, 0x45, 0x73, 0x64, 0x52, 0x4A, 0x43, 0x3A, 0x4E, 0x46, 0x3C, 0x4C, 0x44, 0x3A, 0x59, 
	0x52, 0x49, 0x6A, 0x5E, 0x4B, 0x70, 0x65, 0x52, 0x7C, 0x6F, 0x62, 0x65, 0x5E, 0x52, 0x6F, 0x62, 
	0x51, 0x69, 0x5F, 0x53, 0x47, 0x4A, 0x48, 0x62, 0x59, 0x50, 0x60, 0x55, 0x4D, 0x1C, 0x3D, 0x42, 
	0x0F, 0x35, 0x3F, 0x1C, 0x3A, 0x3D, 0x29, 0x4D, 0x57, 0x1B, 0x3C, 0x3D, 0x1D, 0x3D, 0x40, 0x1D, 
	0x3D, 0x40, 0x1F, 0x43, 0x40, 0x1E, 0x3E, 0x42, 0x1D, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x1C, 0x2B, 
	0x34, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x45, 0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 
	0x1E, 0x2F, 0x38, 0x14, 0x27, 0x28, 0x1D, 0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x16, 
	0x2B, 0x37, 0x3E, 0x38, 0x2F, 0x77, 0x69, 0x55, 0x42, 0x3F, 0x36, 0x38, 0x38, 0x32, 0x35, 0x33, 
	0x2C, 0x29, 0x23, 0x1E, 0x28, 0x1A, 0x18, 0x3B, 0x36, 0x33, 0x38, 0x3A, 0x30, 0x37, 0x39, 0x30, 
	0x35, 0x31, 0x2C, 0x39, 0x2E, 0x2F, 0x36, 0x35, 0x2F, 0x33, 0x44, 0x44, 0x1A, 0x42, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1B, 0x3F, 0x3E, 0x23, 0x38, 0x3E, 0x56, 0x57, 0x4D, 0x52, 0x48, 0x3D, 
	0x4F, 0x43, 0x3B, 0x50, 0x4D, 0x46, 0x51, 0x4F, 0x49, 0x57, 0x4D, 0x49, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x4B, 0xC1, 0xCF, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD2, 0x4B, 0xC2, 0xD2, 0x4C, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 0x4C, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDC, 0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x4D, 
	0xC2, 0xD0, 0x52, 0xC2, 0xDB, 0x51, 0xC5, 0xD9, 0x46, 0xAE, 0xC2, 0x02, 0x04, 0x03, 0x08, 0x04, 
	0x04, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x16, 0x16, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x0C, 0x0C, 0x04, 0x04, 
	0x04, 0x40, 0x97, 0xA9, 0x54, 0xC9, 0xDF, 0x5C, 0xCD, 0xDC, 0x5D, 0xCD, 0xD8, 0x50, 0xBF, 0xD9, 
	0x5D, 0xCD, 0xD9, 0x50, 0xC0, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x50, 0xBF, 0xD9, 0x53, 
	0xC3, 0xD9, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xD9, 0x4E, 0xBE, 0xD8, 0x5B, 0xCB, 
	0xD7, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3A, 0x95, 0xA4, 0x0E, 0x0B, 0x11, 
	0x48, 0x3D, 0x3A, 0x6F, 0x64, 0x51, 0x47, 0x3E, 0x37, 0x48, 0x3D, 0x36, 0x4F, 0x46, 0x3D, 0x4C, 
	0x44, 0x3A, 0x4E, 0x45, 0x3D, 0x53, 0x4C, 0x43, 0x82, 0x72, 0x65, 0x74, 0x6A, 0x5E, 0x69, 0x61, 
	0x50, 0x67, 0x5E, 0x53, 0x50, 0x4D, 0x48, 0x5C, 0x54, 0x4C, 0x64, 0x58, 0x4F, 0x2E, 0x46, 0x45, 
	0x0E, 0x35, 0x3F, 0x1D, 0x3D, 0x3E, 0x23, 0x45, 0x4C, 0x1C, 0x40, 0x3E, 0x1D, 0x40, 0x40, 0x1E, 
	0x42, 0x40, 0x11, 0x35, 0x40, 0x12, 0x38, 0x42, 0x1E, 0x2E, 0x36, 0x1C, 0x2C, 0x36, 0x22, 0x45, 
	0x4A, 0x1D, 0x30, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x2F, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 
	0x1D, 0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x1D, 0x2F, 0x37, 0x19, 0x31, 0x3A, 0x1D, 0x3A, 0x43, 0x1A, 
	0x39, 0x40, 0x36, 0x34, 0x29, 0x44, 0x38, 0x34, 0x46, 0x3E, 0x36, 0x28, 0x20, 0x19, 0x2F, 0x2E, 
	0x24, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x36, 0x34, 0x2C, 0x37, 0x2C, 0x2F, 0x3F, 0x35, 0x33, 
	0x35, 0x2C, 0x2B, 0x37, 0x33, 0x2F, 0x16, 0x38, 0x40, 0x1A, 0x33, 0x3D, 0x1A, 0x3B, 0x40, 0x1D, 
	0x3C, 0x40, 0x1D, 0x3E, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x40, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x23, 0x47, 0x4C, 0x20, 0x38, 0x3E, 0x5C, 0x4F, 0x46, 0x63, 0x5B, 0x4A, 
	0x4C, 0x44, 0x3A, 0x4D, 0x44, 0x3A, 0x55, 0x4C, 0x43, 0x57, 0x4D, 0x48, 0x1A, 0x1B, 0x1F, 0x34, 
	0x8A, 0x9A, 0x3D, 0x9C, 0xB5, 0x4B, 0xC6, 0xD5, 0x49, 0xC2, 0xD2, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 
	0xD2, 0x4F, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 
	0xC2, 0xD4, 0x52, 0xC2, 0xDA, 0x53, 0xCA, 0xDD, 0x35, 0x7E, 0x8B, 0x02, 0x02, 0x00, 0x00, 0x00, 
	0x00, 0x04, 0x04, 0x04, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x08, 0x08, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0B, 0x15, 
	0x14, 0x16, 0x2A, 0x2A, 0x4E, 0xBF, 0xDB, 0x54, 0xC5, 0xDE, 0x4F, 0xBF, 0xD8, 0x50, 0xC0, 0xD9, 
	0x57, 0xC6, 0xD9, 0x50, 0xC0, 0xD9, 0x5A, 0xCA, 0xD8, 0x59, 0xC9, 0xDC, 0x4F, 0xBE, 0xD7, 0x5D, 
	0xCE, 0xD9, 0x4E, 0xBD, 0xD9, 0x5B, 0xCB, 0xD9, 0x52, 0xC2, 0xD8, 0x52, 0xC3, 0xDA, 0x5A, 0xCA, 
	0xE3, 0x5A, 0xCA, 0xDC, 0x58, 0xCA, 0xE1, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x07, 0x02, 0x00, 
	0x4B, 0x47, 0x3C, 0x52, 0x4A, 0x43, 0x53, 0x4B, 0x40, 0x4D, 0x44, 0x3B, 0x49, 0x3E, 0x37, 0x4A, 
	0x40, 0x38, 0x3B, 0x32, 0x30, 0x47, 0x43, 0x3A, 0x72, 0x65, 0x58, 0x77, 0x67, 0x59, 0x73, 0x65, 
	0x55, 0x71, 0x63, 0x52, 0x5D, 0x54, 0x4D, 0x57, 0x4F, 0x47, 0x63, 0x58, 0x4C, 0x2E, 0x47, 0x4A, 
	0x0E, 0x34, 0x3E, 0x22, 0x46, 0x46, 0x1B, 0x2C, 0x37, 0x1D, 0x3C, 0x40, 0x1D, 0x3D, 0x40, 0x1D, 
	0x42, 0x40, 0x1D, 0x3D, 0x40, 0x12, 0x37, 0x40, 0x1E, 0x3A, 0x3C, 0x1B, 0x30, 0x39, 0x0F, 0x38, 
	0x42, 0x1C, 0x3C, 0x42, 0x1D, 0x2F, 0x38, 0x1A, 0x2B, 0x31, 0x1D, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 
	0x1D, 0x2E, 0x36, 0x1A, 0x32, 0x3A, 0x15, 0x35, 0x3E, 0x2C, 0x2E, 0x29, 0x1B, 0x31, 0x3A, 0x1B, 
	0x36, 0x40, 0x2C, 0x2F, 0x29, 0x39, 0x31, 0x28, 0x5C, 0x54, 0x4B, 0x2C, 0x26, 0x24, 0x32, 0x2A, 
	0x24, 0x2F, 0x30, 0x26, 0x38, 0x34, 0x2E, 0x35, 0x3D, 0x39, 0x36, 0x39, 0x34, 0x37, 0x2C, 0x2F, 
	0x3A, 0x3A, 0x2E, 0x25, 0x3D, 0x44, 0x1B, 0x3C, 0x40, 0x1A, 0x3D, 0x42, 0x36, 0x43, 0x40, 0x1A, 
	0x34, 0x40, 0x1D, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x39, 
	0x3F, 0x1F, 0x44, 0x45, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4D, 0x47, 0x43, 0x5C, 0x54, 0x46, 
	0x4D, 0x45, 0x3B, 0x48, 0x3D, 0x35, 0x58, 0x50, 0x48, 0x58, 0x4D, 0x4A, 0x1A, 0x1B, 0x1F, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC8, 0x4A, 0xBE, 0xCD, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD2, 0x48, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 
	0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD2, 0x52, 
	0xC2, 0xDA, 0x53, 0xC3, 0xD8, 0x54, 0xC5, 0xE1, 0x03, 0x07, 0x06, 0x07, 0x03, 0x03, 0x0C, 0x0C, 
	0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x08, 0x08, 
	0x0B, 0x0C, 0x0C, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x12, 
	0x11, 0x0F, 0x11, 0x15, 0x3D, 0x89, 0x98, 0x5A, 0xCF, 0xE4, 0x5B, 0xCC, 0xDB, 0x59, 0xC9, 0xD7, 
	0x4F, 0xBF, 0xD9, 0x51, 0xC1, 0xD9, 0x51, 0xC1, 0xD9, 0x4F, 0xBF, 0xD7, 0x5D, 0xCD, 0xE4, 0x4E, 
	0xBD, 0xD7, 0x59, 0xC9, 0xD8, 0x5B, 0xCB, 0xD8, 0x51, 0xC2, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 
	0xD9, 0x5A, 0xCA, 0xDE, 0x58, 0xCA, 0xDC, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x58, 0x51, 0x43, 0x61, 0x59, 0x4A, 0x4D, 0x45, 0x3D, 0x5B, 0x53, 0x49, 0x47, 0x3D, 0x35, 0x4B, 
	0x42, 0x38, 0x4B, 0x40, 0x38, 0x43, 0x3D, 0x34, 0x69, 0x5E, 0x54, 0x6F, 0x61, 0x4F, 0x61, 0x5A, 
	0x49, 0x78, 0x67, 0x55, 0x60, 0x5E, 0x5E, 0x62, 0x5D, 0x56, 0x60, 0x55, 0x48, 0x3F, 0x53, 0x51, 
	0x0F, 0x37, 0x3D, 0x22, 0x4C, 0x52, 0x1F, 0x42, 0x45, 0x1C, 0x3D, 0x3F, 0x1D, 0x42, 0x40, 0x1C, 
	0x3B, 0x40, 0x12, 0x37, 0x40, 0x13, 0x38, 0x40, 0x1C, 0x32, 0x3B, 0x1E, 0x37, 0x3C, 0x1F, 0x2B, 
	0x35, 0x11, 0x39, 0x43, 0x1E, 0x2F, 0x37, 0x18, 0x2F, 0x35, 0x1B, 0x2B, 0x32, 0x16, 0x29, 0x2C, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x18, 0x32, 0x3B, 0x1D, 0x2E, 0x36, 0x1B, 
	0x37, 0x3F, 0x1E, 0x34, 0x3B, 0x6F, 0x61, 0x55, 0x71, 0x64, 0x56, 0x2B, 0x26, 0x24, 0x31, 0x26, 
	0x22, 0x30, 0x2B, 0x20, 0x2F, 0x2F, 0x29, 0x1F, 0x46, 0x4A, 0x35, 0x3C, 0x37, 0x38, 0x30, 0x2F, 
	0x3D, 0x32, 0x2C, 0x18, 0x3D, 0x43, 0x1D, 0x3D, 0x42, 0x1A, 0x29, 0x34, 0x35, 0x43, 0x42, 0x22, 
	0x42, 0x40, 0x1C, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 
	0x40, 0x1B, 0x3E, 0x3D, 0x1E, 0x44, 0x47, 0x30, 0x3F, 0x3F, 0x50, 0x44, 0x3E, 0x60, 0x58, 0x4A, 
	0x4D, 0x45, 0x3B, 0x3B, 0x38, 0x30, 0x58, 0x4F, 0x46, 0x4C, 0x45, 0x39, 0x1B, 0x1C, 0x20, 0x33, 
	0x88, 0x99, 0x48, 0xB4, 0xC7, 0x4C, 0xC5, 0xD6, 0x4F, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x4E, 0xC2, 
	0xD1, 0x4C, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4F, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x49, 0xC2, 0xD2, 
	0x4E, 0xC2, 0xD0, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD3, 0x4E, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 
	0xC1, 0xD9, 0x52, 0xCB, 0xDE, 0x3D, 0x90, 0xA0, 0x00, 0x00, 0x00, 0x04, 0x03, 0x03, 0x03, 0x03, 
	0x03, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 
	0x13, 0x09, 0x15, 0x14, 0x18, 0x1F, 0x20, 0x4E, 0xBB, 0xD2, 0x5C, 0xCF, 0xE3, 0x5B, 0xCB, 0xE3, 
	0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD9, 0x50, 0xC0, 0xD8, 0x59, 0xC9, 0xDB, 0x5A, 0xCA, 0xD6, 0x5B, 
	0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 
	0xD7, 0x5B, 0xCB, 0xD8, 0x51, 0xC4, 0xD7, 0x49, 0x9E, 0xB7, 0x3A, 0x95, 0xA5, 0x02, 0x06, 0x04, 
	0x5D, 0x52, 0x45, 0x64, 0x5C, 0x4B, 0x66, 0x5E, 0x4C, 0x5C, 0x54, 0x47, 0x4F, 0x47, 0x3C, 0x3D, 
	0x34, 0x32, 0x4B, 0x42, 0x38, 0x4A, 0x3F, 0x37, 0x43, 0x3D, 0x3C, 0x67, 0x5E, 0x51, 0x59, 0x52, 
	0x4A, 0x6E, 0x60, 0x4E, 0x5E, 0x57, 0x48, 0x6F, 0x65, 0x53, 0x63, 0x5B, 0x49, 0x53, 0x49, 0x42, 
	0x14, 0x2B, 0x37, 0x15, 0x3E, 0x45, 0x23, 0x48, 0x4C, 0x22, 0x40, 0x3F, 0x19, 0x38, 0x3E, 0x33, 
	0x3B, 0x3A, 0x13, 0x36, 0x40, 0x13, 0x38, 0x40, 0x12, 0x39, 0x42, 0x12, 0x39, 0x42, 0x19, 0x33, 
	0x3B, 0x12, 0x39, 0x42, 0x1F, 0x2C, 0x35, 0x0F, 0x3B, 0x44, 0x1E, 0x31, 0x3A, 0x1A, 0x2C, 0x32, 
	0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1B, 
	0x2E, 0x36, 0x20, 0x34, 0x38, 0x6C, 0x64, 0x5A, 0x8F, 0x7C, 0x6C, 0x5A, 0x52, 0x47, 0x4F, 0x4A, 
	0x47, 0x2B, 0x34, 0x31, 0x18, 0x30, 0x3C, 0x24, 0x4D, 0x55, 0x31, 0x3F, 0x3D, 0x3B, 0x38, 0x2C, 
	0x20, 0x32, 0x38, 0x1C, 0x3D, 0x42, 0x1C, 0x3B, 0x3E, 0x1B, 0x35, 0x38, 0x1A, 0x3D, 0x3F, 0x1C, 
	0x3F, 0x3F, 0x1C, 0x3F, 0x3F, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x40, 0x40, 0x1C, 0x3F, 
	0x3E, 0x28, 0x4C, 0x54, 0x1A, 0x3E, 0x3D, 0x22, 0x3F, 0x3F, 0x4E, 0x48, 0x43, 0x5B, 0x52, 0x4A, 
	0x4D, 0x46, 0x3B, 0x4A, 0x3F, 0x37, 0x4F, 0x46, 0x3C, 0x47, 0x43, 0x38, 0x1B, 0x1C, 0x20, 0x34, 
	0x8A, 0x9A, 0x3C, 0x9C, 0xB5, 0x50, 0xC5, 0xD9, 0x48, 0xC2, 0xD1, 0x4C, 0xC2, 0xD1, 0x55, 0xC2, 
	0xDD, 0x47, 0xC2, 0xD0, 0x51, 0xC2, 0xD8, 0x4A, 0xC2, 0xD3, 0x49, 0xC2, 0xD1, 0x48, 0xC2, 0xD1, 
	0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x4F, 
	0xC3, 0xD8, 0x53, 0xC5, 0xE1, 0x02, 0x04, 0x02, 0x07, 0x03, 0x03, 0x0C, 0x0C, 0x0C, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x16, 0x16, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 
	0x14, 0x08, 0x0F, 0x0E, 0x0D, 0x12, 0x13, 0x31, 0x6B, 0x77, 0x5B, 0xCC, 0xE1, 0x4E, 0xBF, 0xD8, 
	0x5C, 0xCD, 0xD8, 0x4F, 0xBE, 0xD9, 0x50, 0xBF, 0xD8, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xE2, 0x5B, 0xCB, 0xD6, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5B, 0xCB, 0xDA, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDD, 0x3D, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x57, 0x50, 0x42, 0x66, 0x5E, 0x4C, 0x59, 0x51, 0x45, 0x4B, 0x43, 0x39, 0x4A, 0x3F, 0x37, 0x31, 
	0x30, 0x2C, 0x4C, 0x42, 0x39, 0x4C, 0x42, 0x39, 0x49, 0x3E, 0x36, 0x51, 0x49, 0x3F, 0x4C, 0x44, 
	0x3B, 0x57, 0x50, 0x47, 0x72, 0x66, 0x54, 0x62, 0x5A, 0x52, 0x66, 0x5D, 0x51, 0x51, 0x4C, 0x45, 
	0x16, 0x28, 0x34, 0x1A, 0x3F, 0x3F, 0x2B, 0x44, 0x46, 0x32, 0x42, 0x42, 0x26, 0x37, 0x3C, 0x36, 
	0x2E, 0x20, 0x18, 0x43, 0x4B, 0x12, 0x37, 0x3F, 0x1A, 0x32, 0x3A, 0x19, 0x33, 0x3B, 0x19, 0x34, 
	0x3C, 0x12, 0x3A, 0x43, 0x1B, 0x31, 0x39, 0x1E, 0x36, 0x3E, 0x1D, 0x3B, 0x45, 0x1D, 0x2F, 0x38, 
	0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x36, 0x1D, 0x3A, 0x44, 0x1D, 
	0x2E, 0x36, 0x18, 0x38, 0x42, 0x35, 0x3F, 0x40, 0x8A, 0x79, 0x67, 0x62, 0x58, 0x4D, 0x5D, 0x57, 
	0x50, 0x22, 0x3B, 0x42, 0x1B, 0x3D, 0x40, 0x1E, 0x35, 0x3D, 0x3B, 0x31, 0x2B, 0x3B, 0x38, 0x2E, 
	0x15, 0x35, 0x40, 0x1D, 0x3B, 0x3E, 0x27, 0x4C, 0x52, 0x27, 0x4D, 0x58, 0x1E, 0x45, 0x49, 0x1C, 
	0x42, 0x44, 0x20, 0x43, 0x45, 0x1C, 0x40, 0x3F, 0x1E, 0x42, 0x40, 0x1D, 0x40, 0x40, 0x1D, 0x3B, 
	0x40, 0x1C, 0x36, 0x3E, 0x1B, 0x42, 0x40, 0x23, 0x3F, 0x40, 0x53, 0x47, 0x3E, 0x53, 0x4B, 0x40, 
	0x48, 0x3D, 0x36, 0x4A, 0x40, 0x38, 0x49, 0x3F, 0x37, 0x53, 0x47, 0x3C, 0x1B, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 
	0xD1, 0x4B, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x54, 0xC2, 0xDB, 0x4E, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 
	0x54, 0xC2, 0xDC, 0x4D, 0xC2, 0xD2, 0x4F, 0xC2, 0xD2, 0x53, 0xC2, 0xDB, 0x4C, 0xC1, 0xD4, 0x55, 
	0xC9, 0xDD, 0x40, 0x90, 0x9F, 0x03, 0x06, 0x03, 0x03, 0x02, 0x02, 0x03, 0x03, 0x03, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x07, 0x07, 0x0B, 0x15, 0x15, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x08, 0x11, 
	0x11, 0x16, 0x2C, 0x2C, 0x09, 0x14, 0x13, 0x11, 0x0D, 0x0F, 0x4F, 0xBC, 0xD3, 0x5C, 0xCE, 0xE2, 
	0x51, 0xC1, 0xDB, 0x5C, 0xCC, 0xD8, 0x5C, 0xCC, 0xD9, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 0xD7, 0x5B, 
	0xCB, 0xD8, 0x4F, 0xBE, 0xD9, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD8, 0x50, 0xBF, 
	0xD8, 0x5B, 0xCB, 0xDE, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x06, 0x02, 0x00, 
	0x54, 0x4D, 0x42, 0x54, 0x4C, 0x46, 0x62, 0x5A, 0x4A, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3D, 0x40, 
	0x36, 0x33, 0x4D, 0x43, 0x39, 0x2F, 0x34, 0x2B, 0x4B, 0x3F, 0x38, 0x54, 0x4C, 0x43, 0x53, 0x4A, 
	0x40, 0x57, 0x4F, 0x46, 0x6A, 0x5E, 0x4D, 0x5F, 0x57, 0x51, 0x6C, 0x63, 0x50, 0x67, 0x59, 0x4E, 
	0x18, 0x31, 0x3A, 0x0F, 0x37, 0x40, 0x1E, 0x3B, 0x42, 0x36, 0x3C, 0x37, 0x3B, 0x39, 0x2E, 0x32, 
	0x2E, 0x25, 0x20, 0x35, 0x3C, 0x16, 0x3B, 0x42, 0x11, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1E, 0x2F, 
	0x38, 0x1B, 0x32, 0x3A, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x37, 0x16, 0x28, 0x2A, 0x18, 0x2A, 0x2E, 
	0x18, 0x2A, 0x2E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 0x3E, 0x44, 0x1D, 
	0x2E, 0x36, 0x1B, 0x2F, 0x38, 0x25, 0x3D, 0x43, 0x68, 0x5B, 0x4F, 0x3E, 0x45, 0x46, 0x49, 0x3B, 
	0x38, 0x12, 0x28, 0x35, 0x19, 0x3D, 0x43, 0x28, 0x42, 0x3F, 0x39, 0x37, 0x2E, 0x3B, 0x38, 0x2E, 
	0x14, 0x36, 0x42, 0x0F, 0x37, 0x40, 0x1A, 0x31, 0x3B, 0x3A, 0x44, 0x40, 0x26, 0x49, 0x51, 0x1A, 
	0x4B, 0x55, 0x20, 0x4C, 0x55, 0x1B, 0x39, 0x3D, 0x0F, 0x35, 0x40, 0x1E, 0x42, 0x40, 0x1D, 0x3D, 
	0x40, 0x1B, 0x40, 0x3D, 0x1B, 0x3D, 0x40, 0x1E, 0x3B, 0x3E, 0x62, 0x56, 0x4D, 0x4A, 0x42, 0x38, 
	0x4F, 0x47, 0x3D, 0x49, 0x3F, 0x37, 0x4A, 0x3F, 0x38, 0x40, 0x3B, 0x31, 0x1C, 0x1C, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD0, 0x4B, 0xC2, 0xD1, 0x4B, 0xC2, 0xD1, 
	0x4B, 0xC2, 0xD0, 0x47, 0xC2, 0xD0, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x54, 
	0xC8, 0xDF, 0x28, 0x51, 0x58, 0x00, 0x00, 0x00, 0x0C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x13, 0x13, 0x0C, 0x16, 
	0x16, 0x15, 0x29, 0x29, 0x09, 0x1D, 0x1D, 0x1A, 0x18, 0x19, 0x2C, 0x58, 0x65, 0x53, 0xC7, 0xDF, 
	0x5D, 0xCD, 0xDC, 0x52, 0xC2, 0xD8, 0x50, 0xC0, 0xD9, 0x52, 0xC2, 0xD7, 0x5A, 0xCA, 0xE3, 0x5B, 
	0xCB, 0xD7, 0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xD8, 0x5A, 0xCA, 0xD8, 0x5B, 0xCB, 0xD9, 0x4F, 0xBE, 
	0xD8, 0x5B, 0xCB, 0xDD, 0x58, 0xCA, 0xDF, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x06, 0x00, 0x00, 
	0x63, 0x59, 0x4B, 0x54, 0x4C, 0x42, 0x50, 0x48, 0x3E, 0x4A, 0x40, 0x42, 0x4A, 0x40, 0x37, 0x38, 
	0x30, 0x30, 0x4B, 0x42, 0x38, 0x4D, 0x43, 0x39, 0x4B, 0x40, 0x38, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x34, 0x50, 0x48, 0x3C, 0x78, 0x6D, 0x5A, 0x66, 0x63, 0x5D, 0x61, 0x58, 0x4F, 0x64, 0x58, 0x4A, 
	0x2A, 0x39, 0x39, 0x0C, 0x37, 0x42, 0x35, 0x39, 0x35, 0x36, 0x3D, 0x38, 0x38, 0x2F, 0x2E, 0x3A, 
	0x30, 0x33, 0x32, 0x2E, 0x20, 0x20, 0x36, 0x3C, 0x1A, 0x40, 0x40, 0x1B, 0x32, 0x3D, 0x14, 0x25, 
	0x25, 0x14, 0x2B, 0x30, 0x1D, 0x40, 0x44, 0x1D, 0x40, 0x43, 0x1D, 0x31, 0x3A, 0x1D, 0x30, 0x38, 
	0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x2E, 0x37, 0x1D, 
	0x30, 0x38, 0x19, 0x31, 0x39, 0x1C, 0x32, 0x39, 0x60, 0x53, 0x48, 0x44, 0x3A, 0x30, 0x3F, 0x44, 
	0x47, 0x38, 0x3E, 0x39, 0x34, 0x3D, 0x39, 0x2E, 0x2A, 0x1F, 0x39, 0x39, 0x31, 0x38, 0x38, 0x2F, 
	0x36, 0x2E, 0x2E, 0x1B, 0x46, 0x43, 0x1A, 0x37, 0x42, 0x2F, 0x40, 0x40, 0x33, 0x3D, 0x39, 0x24, 
	0x42, 0x42, 0x1D, 0x4B, 0x55, 0x35, 0x3E, 0x3C, 0x1B, 0x3A, 0x3F, 0x1D, 0x40, 0x40, 0x1B, 0x3F, 
	0x3D, 0x2A, 0x4D, 0x58, 0x18, 0x39, 0x3D, 0x39, 0x3B, 0x3E, 0x63, 0x5A, 0x4B, 0x5A, 0x52, 0x48, 
	0x4C, 0x44, 0x3A, 0x4B, 0x42, 0x39, 0x4F, 0x47, 0x3C, 0x57, 0x4C, 0x43, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9A, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x4A, 0xC2, 0xD2, 0x4A, 0xC2, 
	0xD2, 0x4A, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x4D, 0xC2, 0xD3, 0x53, 0xC2, 0xDA, 0x54, 0xC2, 0xDB, 
	0x4C, 0xC2, 0xD2, 0x54, 0xC2, 0xD9, 0x4C, 0xC2, 0xCF, 0x4D, 0xC2, 0xD0, 0x4D, 0xC4, 0xD6, 0x51, 
	0xBD, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x09, 0x09, 0x07, 0x06, 0x06, 0x0B, 0x0B, 
	0x0B, 0x0B, 0x09, 0x09, 0x0B, 0x0C, 0x0C, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x09, 0x11, 0x11, 0x16, 0x2B, 
	0x2B, 0x12, 0x29, 0x29, 0x2E, 0x1B, 0x1B, 0x22, 0x15, 0x14, 0x0D, 0x16, 0x18, 0x44, 0xA4, 0xB5, 
	0x5A, 0xCD, 0xE2, 0x5A, 0xCA, 0xDB, 0x50, 0xC0, 0xD8, 0x5C, 0xCD, 0xDB, 0x5B, 0xCB, 0xE0, 0x5B, 
	0xCB, 0xDA, 0x5B, 0xCB, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5B, 0xCB, 
	0xDA, 0x5A, 0xCA, 0xE2, 0x58, 0xCA, 0xDE, 0x3E, 0xA1, 0xB9, 0x3B, 0x95, 0xA5, 0x00, 0x07, 0x06, 
	0x70, 0x5F, 0x54, 0x65, 0x5C, 0x4D, 0x51, 0x49, 0x42, 0x50, 0x48, 0x40, 0x49, 0x3F, 0x36, 0x3D, 
	0x35, 0x32, 0x4C, 0x42, 0x39, 0x39, 0x33, 0x30, 0x3C, 0x3A, 0x31, 0x35, 0x36, 0x2E, 0x34, 0x36, 
	0x2E, 0x45, 0x3D, 0x35, 0x66, 0x5D, 0x52, 0x72, 0x63, 0x50, 0x61, 0x59, 0x52, 0x5B, 0x55, 0x4F, 
	0x35, 0x48, 0x47, 0x1B, 0x35, 0x3F, 0x22, 0x3F, 0x42, 0x1D, 0x3D, 0x43, 0x3A, 0x37, 0x34, 0x2E, 
	0x23, 0x15, 0x30, 0x31, 0x27, 0x2E, 0x28, 0x23, 0x1B, 0x49, 0x52, 0x1D, 0x44, 0x40, 0x1E, 0x31, 
	0x3C, 0x16, 0x29, 0x2B, 0x1D, 0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1D, 0x3B, 0x44, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x37, 0x1B, 0x2E, 0x37, 0x19, 
	0x2A, 0x31, 0x18, 0x35, 0x3E, 0x11, 0x3A, 0x45, 0x33, 0x3A, 0x3A, 0x4E, 0x40, 0x37, 0x51, 0x48, 
	0x42, 0x4E, 0x43, 0x39, 0x49, 0x3F, 0x35, 0x37, 0x2F, 0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2F, 
	0x31, 0x3C, 0x39, 0x1B, 0x2A, 0x36, 0x19, 0x30, 0x39, 0x44, 0x44, 0x40, 0x40, 0x31, 0x2B, 0x24, 
	0x48, 0x4E, 0x1D, 0x4B, 0x54, 0x37, 0x52, 0x52, 0x24, 0x3F, 0x45, 0x1C, 0x3D, 0x3E, 0x1B, 0x3D, 
	0x3D, 0x2A, 0x4E, 0x58, 0x18, 0x3A, 0x3D, 0x39, 0x3C, 0x3F, 0x66, 0x5C, 0x4B, 0x56, 0x4E, 0x43, 
	0x50, 0x48, 0x3F, 0x50, 0x48, 0x42, 0x47, 0x3D, 0x35, 0x53, 0x49, 0x3D, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x39, 0x98, 0xB2, 0x50, 0xC1, 0xD4, 0x49, 0xC2, 0xD2, 0x4A, 0xC2, 0xD2, 0x49, 0xC2, 
	0xD2, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 0xD1, 0x53, 0xC2, 0xDB, 0x53, 0xC2, 0xDA, 0x46, 0xC2, 0xCE, 
	0x54, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x53, 0xC2, 0xDA, 0x52, 0xC2, 0xDA, 0x52, 0xC1, 0xD9, 0x57, 
	0xCE, 0xE2, 0x4D, 0xBB, 0xCF, 0x12, 0x2E, 0x32, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x0B, 0x08, 
	0x08, 0x0B, 0x0F, 0x0F, 0x0B, 0x15, 0x15, 0x0B, 0x15, 0x15, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 
	0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 0x14, 0x14, 0x0B, 
	0x14, 0x14, 0x0B, 0x14, 0x14, 0x09, 0x11, 0x11, 0x18, 0x2F, 0x2F, 0x07, 0x0E, 0x0E, 0x0E, 0x1D, 
	0x1C, 0x0B, 0x1A, 0x19, 0x19, 0x15, 0x16, 0x0F, 0x12, 0x14, 0x2A, 0x4F, 0x55, 0x44, 0xAB, 0xBE, 
	0x5A, 0xCC, 0xDF, 0x4F, 0xBF, 0xD8, 0x51, 0xC0, 0xD9, 0x50, 0xBF, 0xD8, 0x50, 0xBF, 0xD8, 0x4F, 
	0xBE, 0xD8, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 
	0xE2, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDB, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x71, 0x62, 0x59, 0x66, 0x5E, 0x4D, 0x64, 0x5D, 0x4B, 0x53, 0x4B, 0x43, 0x4E, 0x46, 0x3E, 0x4A, 
	0x40, 0x37, 0x4E, 0x46, 0x3B, 0x39, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x37, 0x37, 0x2F, 0x36, 0x36, 
	0x2F, 0x43, 0x3E, 0x35, 0x62, 0x59, 0x4C, 0x76, 0x6C, 0x59, 0x6A, 0x60, 0x52, 0x51, 0x4B, 0x47, 
	0x1B, 0x31, 0x39, 0x19, 0x3D, 0x40, 0x1C, 0x3E, 0x40, 0x1B, 0x36, 0x40, 0x20, 0x39, 0x3C, 0x33, 
	0x26, 0x1D, 0x30, 0x30, 0x27, 0x2B, 0x30, 0x2A, 0x16, 0x2F, 0x3A, 0x18, 0x3E, 0x42, 0x1D, 0x33, 
	0x3C, 0x1D, 0x2F, 0x37, 0x1D, 0x3C, 0x46, 0x1D, 0x2E, 0x36, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 
	0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1A, 0x2E, 0x37, 0x1F, 0x35, 0x39, 0x24, 0x36, 0x3B, 0x20, 
	0x34, 0x37, 0x15, 0x29, 0x2B, 0x13, 0x24, 0x25, 0x1E, 0x37, 0x42, 0x40, 0x39, 0x2C, 0x46, 0x3C, 
	0x3C, 0x55, 0x4D, 0x43, 0x46, 0x3D, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x3B, 0x3E, 0x11, 0x36, 0x3F, 0x19, 0x2B, 0x36, 0x33, 0x3D, 0x39, 0x39, 0x37, 0x2C, 0x2B, 
	0x3D, 0x3B, 0x12, 0x38, 0x43, 0x20, 0x4C, 0x56, 0x31, 0x43, 0x45, 0x19, 0x42, 0x47, 0x1D, 0x34, 
	0x3E, 0x1B, 0x3B, 0x3D, 0x1C, 0x3B, 0x42, 0x1B, 0x35, 0x3E, 0x4C, 0x3D, 0x33, 0x4F, 0x47, 0x3E, 
	0x6A, 0x62, 0x4E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x40, 0x52, 0x48, 0x3C, 0x1A, 0x1C, 0x20, 0x34, 
	0x8A, 0x9B, 0x42, 0x9C, 0xB5, 0x50, 0xC6, 0xDA, 0x49, 0xC2, 0xD1, 0x49, 0xC2, 0xD2, 0x4F, 0xC2, 
	0xD1, 0x49, 0xC2, 0xD2, 0x48, 0xC2, 0xD1, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xD7, 0x53, 0xC2, 0xDB, 
	0x50, 0xC2, 0xD3, 0x4D, 0xC2, 0xD0, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x53, 0xC2, 0xDA, 0x4E, 
	0xC1, 0xD1, 0x56, 0xCA, 0xDF, 0x40, 0xA2, 0xB5, 0x2A, 0x67, 0x73, 0x0D, 0x0D, 0x0F, 0x02, 0x00, 
	0x00, 0x06, 0x07, 0x06, 0x07, 0x09, 0x08, 0x09, 0x06, 0x04, 0x09, 0x0E, 0x0D, 0x0B, 0x0D, 0x0D, 
	0x09, 0x0D, 0x0D, 0x09, 0x0D, 0x0D, 0x11, 0x0D, 0x0D, 0x08, 0x0F, 0x0F, 0x09, 0x13, 0x12, 0x09, 
	0x12, 0x12, 0x09, 0x12, 0x12, 0x08, 0x11, 0x11, 0x0D, 0x1B, 0x1A, 0x0E, 0x19, 0x1A, 0x14, 0x0F, 
	0x14, 0x1F, 0x19, 0x16, 0x29, 0x61, 0x6D, 0x3F, 0xA5, 0xBC, 0x56, 0xC9, 0xE1, 0x5A, 0xCD, 0xDD, 
	0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD8, 0x5B, 0xCB, 0xD9, 0x5B, 0xCB, 0xD8, 0x5B, 
	0xCB, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 
	0xD8, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x75, 0x67, 0x56, 0x61, 0x5A, 0x49, 0x53, 0x4C, 0x40, 0x4D, 0x45, 0x40, 0x49, 
	0x3F, 0x36, 0x49, 0x3E, 0x37, 0x4F, 0x46, 0x3B, 0x42, 0x39, 0x34, 0x3C, 0x3A, 0x32, 0x3E, 0x3B, 
	0x33, 0x2E, 0x29, 0x27, 0x3D, 0x36, 0x31, 0x6B, 0x61, 0x52, 0x60, 0x5B, 0x57, 0x57, 0x4B, 0x43, 
	0x12, 0x2C, 0x37, 0x1E, 0x3C, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3E, 0x40, 0x25, 0x43, 0x46, 0x38, 
	0x2B, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x25, 0x31, 0x2E, 0x2A, 0x11, 0x39, 0x44, 0x1B, 0x36, 
	0x3E, 0x1E, 0x2F, 0x37, 0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x14, 0x27, 0x27, 0x19, 0x2A, 0x2F, 0x1E, 0x34, 0x3A, 0x7A, 0x68, 0x59, 0x7D, 0x78, 0x6E, 0x89, 
	0x77, 0x63, 0x60, 0x5D, 0x55, 0x0F, 0x28, 0x2F, 0x12, 0x25, 0x25, 0x1F, 0x39, 0x43, 0x33, 0x38, 
	0x35, 0x57, 0x4D, 0x43, 0x3F, 0x3A, 0x38, 0x36, 0x38, 0x2F, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 
	0x28, 0x38, 0x3B, 0x19, 0x3A, 0x42, 0x2F, 0x3A, 0x39, 0x3F, 0x3A, 0x30, 0x34, 0x36, 0x2E, 0x54, 
	0x42, 0x3A, 0x1D, 0x3C, 0x45, 0x1F, 0x47, 0x4B, 0x36, 0x3B, 0x37, 0x34, 0x44, 0x44, 0x13, 0x3F, 
	0x47, 0x1D, 0x3C, 0x40, 0x1D, 0x29, 0x34, 0x1B, 0x3D, 0x40, 0x1D, 0x45, 0x4A, 0x44, 0x38, 0x2C, 
	0x52, 0x47, 0x42, 0x54, 0x4C, 0x44, 0x5D, 0x55, 0x46, 0x52, 0x4A, 0x42, 0x1A, 0x1B, 0x1F, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x48, 0xC2, 0xD1, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 
	0xDC, 0x4E, 0xC2, 0xD1, 0x48, 0xC2, 0xD2, 0x50, 0xC2, 0xD0, 0x52, 0xC2, 0xD0, 0x53, 0xC2, 0xD9, 
	0x4D, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x52, 0xC2, 0xDA, 0x53, 0xC2, 0xDB, 0x49, 0xC2, 0xCE, 0x53, 
	0xC2, 0xDB, 0x49, 0xC1, 0xCF, 0x58, 0xCA, 0xDD, 0x54, 0xC7, 0xDE, 0x4C, 0xB5, 0xCB, 0x44, 0x9C, 
	0xAE, 0x29, 0x5D, 0x6A, 0x1A, 0x28, 0x29, 0x07, 0x07, 0x09, 0x06, 0x04, 0x06, 0x02, 0x04, 0x02, 
	0x0C, 0x0E, 0x0C, 0x0C, 0x0F, 0x0D, 0x0B, 0x0F, 0x0D, 0x0E, 0x11, 0x11, 0x0D, 0x13, 0x13, 0x11, 
	0x11, 0x14, 0x0E, 0x0D, 0x11, 0x14, 0x0F, 0x0F, 0x14, 0x23, 0x20, 0x28, 0x56, 0x61, 0x3E, 0x89, 
	0x9A, 0x49, 0xB5, 0xCB, 0x5C, 0xCC, 0xE2, 0x5A, 0xCE, 0xE0, 0x5C, 0xCD, 0xDF, 0x5B, 0xCB, 0xDB, 
	0x4F, 0xBE, 0xD8, 0x5B, 0xCB, 0xDA, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xDA, 0x5A, 
	0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xE1, 0x5A, 0xCA, 0xD5, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x58, 0xCA, 0xDC, 0x3E, 0xA1, 0xBA, 0x3B, 0x95, 0xA5, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x57, 0x71, 0x67, 0x55, 0x60, 0x58, 0x48, 0x69, 0x60, 0x4E, 0x4B, 0x43, 0x3F, 0x48, 
	0x3E, 0x38, 0x4F, 0x47, 0x3C, 0x4F, 0x48, 0x3D, 0x3E, 0x35, 0x32, 0x3B, 0x33, 0x31, 0x35, 0x37, 
	0x2E, 0x37, 0x38, 0x2F, 0x3F, 0x3B, 0x33, 0x65, 0x5C, 0x50, 0x5F, 0x57, 0x4F, 0x51, 0x45, 0x38, 
	0x0F, 0x30, 0x3B, 0x18, 0x3D, 0x40, 0x1D, 0x42, 0x40, 0x1B, 0x3C, 0x43, 0x31, 0x2F, 0x26, 0x3B, 
	0x30, 0x33, 0x31, 0x30, 0x28, 0x2E, 0x30, 0x25, 0x37, 0x2F, 0x2A, 0x25, 0x37, 0x3B, 0x0F, 0x39, 
	0x42, 0x1B, 0x34, 0x3D, 0x1E, 0x30, 0x3A, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 
	0x15, 0x27, 0x28, 0x12, 0x2A, 0x2B, 0x24, 0x33, 0x35, 0x5B, 0x4F, 0x44, 0x49, 0x50, 0x51, 0x6A, 
	0x66, 0x5D, 0x54, 0x56, 0x55, 0x15, 0x30, 0x35, 0x14, 0x27, 0x2C, 0x0E, 0x3A, 0x44, 0x18, 0x32, 
	0x3B, 0x56, 0x4A, 0x40, 0x3F, 0x3B, 0x34, 0x36, 0x2E, 0x2F, 0x37, 0x38, 0x2F, 0x40, 0x3C, 0x33, 
	0x2B, 0x29, 0x27, 0x22, 0x3D, 0x47, 0x2F, 0x43, 0x43, 0x3F, 0x39, 0x2F, 0x3A, 0x39, 0x31, 0x42, 
	0x3A, 0x31, 0x47, 0x4F, 0x4F, 0x25, 0x45, 0x49, 0x1B, 0x49, 0x4F, 0x33, 0x28, 0x1B, 0x1B, 0x3A, 
	0x3F, 0x1D, 0x3F, 0x40, 0x1D, 0x36, 0x42, 0x1B, 0x3A, 0x3D, 0x1A, 0x3F, 0x3D, 0x1C, 0x42, 0x43, 
	0x31, 0x39, 0x3A, 0x4E, 0x44, 0x3F, 0x5B, 0x53, 0x4B, 0x4B, 0x44, 0x38, 0x1B, 0x1B, 0x20, 0x35, 
	0x8A, 0x9B, 0x3A, 0x98, 0xB2, 0x50, 0xC6, 0xDA, 0x4E, 0xC2, 0xD1, 0x4D, 0xC2, 0xD0, 0x53, 0xC2, 
	0xDB, 0x4D, 0xC2, 0xD0, 0x4E, 0xC2, 0xD1, 0x53, 0xC2, 0xDD, 0x50, 0xC2, 0xD0, 0x49, 0xC2, 0xD0, 
	0x4D, 0xC2, 0xD0, 0x53, 0xC2, 0xDC, 0x4C, 0xC2, 0xD2, 0x4A, 0xC2, 0xD0, 0x50, 0xC2, 0xD3, 0x53, 
	0xC2, 0xDA, 0x4C, 0xC1, 0xD4, 0x52, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x53, 0xC5, 0xDD, 0x54, 0xC8, 
	0xDB, 0x54, 0xC7, 0xDD, 0x50, 0xC0, 0xDA, 0x4A, 0xAE, 0xC0, 0x3E, 0x9F, 0xB0, 0x3D, 0x82, 0x94, 
	0x31, 0x6D, 0x7D, 0x27, 0x62, 0x6F, 0x2B, 0x62, 0x6E, 0x31, 0x74, 0x86, 0x33, 0x76, 0x87, 0x38, 
	0x86, 0x97, 0x3E, 0x9E, 0xAF, 0x45, 0xA9, 0xBA, 0x4F, 0xBF, 0xDA, 0x5C, 0xC9, 0xE0, 0x55, 0xCB, 
	0xDF, 0x5A, 0xCD, 0xDF, 0x51, 0xC2, 0xDA, 0x5C, 0xCC, 0xE3, 0x4E, 0xBD, 0xD7, 0x59, 0xC9, 0xD8, 
	0x4F, 0xBE, 0xD7, 0x5B, 0xCB, 0xE1, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE2, 0x5A, 
	0xCA, 0xD9, 0x5A, 0xCA, 0xD7, 0x5A, 0xCA, 0xD9, 0x5A, 0xCA, 0xE3, 0x5A, 0xCA, 0xD8, 0x5A, 0xCA, 
	0xE1, 0x5A, 0xCA, 0xE1, 0x57, 0xCA, 0xDB, 0x3E, 0xA0, 0xB9, 0x3A, 0x94, 0xA3, 0x00, 0x06, 0x04, 
	0x70, 0x61, 0x58, 0x71, 0x62, 0x52, 0x5F, 0x58, 0x48, 0x67, 0x5F, 0x4D, 0x4D, 0x45, 0x3E, 0x4D, 
	0x44, 0x40, 0x4D, 0x45, 0x40, 0x4E, 0x45, 0x3E, 0x4D, 0x45, 0x3A, 0x4D, 0x43, 0x39, 0x48, 0x3F, 
	0x37, 0x32, 0x34, 0x2C, 0x48, 0x42, 0x38, 0x6C, 0x62, 0x52, 0x5E, 0x56, 0x4F, 0x53, 0x47, 0x3F, 
	0x18, 0x35, 0x3E, 0x0F, 0x35, 0x3F, 0x1E, 0x43, 0x40, 0x1D, 0x3B, 0x42, 0x15, 0x31, 0x3D, 0x31, 
	0x25, 0x15, 0x3A, 0x30, 0x33, 0x35, 0x30, 0x2C, 0x30, 0x30, 0x25, 0x27, 0x2E, 0x2E, 0x0F, 0x3A, 
	0x44, 0x16, 0x31, 0x37, 0x14, 0x25, 0x25, 0x1B, 0x2E, 0x35, 0x1D, 0x30, 0x39, 0x1E, 0x30, 0x39, 
	0x18, 0x30, 0x36, 0x1E, 0x30, 0x3A, 0x1C, 0x32, 0x39, 0x50, 0x44, 0x3E, 0x57, 0x4E, 0x45, 0x58, 
	0x4F, 0x48, 0x5A, 0x51, 0x47, 0x53, 0x44, 0x3D, 0x3D, 0x36, 0x2E, 0x19, 0x33, 0x3D, 0x1C, 0x3C, 
	0x3F, 0x60, 0x54, 0x4B, 0x47, 0x3F, 0x39, 0x3A, 0x33, 0x30, 0x37, 0x38, 0x2F, 0x37, 0x37, 0x2F, 
	0x39, 0x3B, 0x34, 0x30, 0x43, 0x43, 0x2E, 0x3C, 0x3A, 0x30, 0x3C, 0x39, 0x4F, 0x43, 0x39, 0x39, 
	0x38, 0x2F, 0x3B, 0x3A, 0x33, 0x28, 0x44, 0x47, 0x18, 0x49, 0x4E, 0x36, 0x31, 0x26, 0x1A, 0x31, 
	0x3C, 0x1D, 0x3C, 0x40, 0x1B, 0x40, 0x3D, 0x2A, 0x4E, 0x58, 0x29, 0x4C, 0x56, 0x19, 0x3A, 0x3E, 
	0x1E, 0x35, 0x3C, 0x55, 0x4A, 0x40, 0x51, 0x49, 0x3F, 0x58, 0x4E, 0x45, 0x1D, 0x22, 0x23, 0x34, 
	0x8A, 0x9B, 0x3A, 0x97, 0xB0, 0x50, 0xC6, 0xDA, 0x4B, 0xC2, 0xD1, 0x4E, 0xC2, 0xD4, 0x53, 0xC2, 
	0xDB, 0x4E, 0xC2, 0xD4, 0x47, 0xC2, 0xD1, 0x51, 0xC2, 0xD0, 0x4D, 0xC2, 0xD6, 0x54, 0xC2, 0xDC, 
	0x4D, 0xC2, 0xD3, 0x50, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4D, 0xC2, 0xD4, 0x53, 0xC2, 0xDB, 0x4F, 
	0xC1, 0xD6, 0x59, 0xC7, 0xDD, 0x51, 0xC1, 0xD9, 0x52, 0xC2, 0xDA, 0x52, 0xC2, 0xD9, 0x52, 0xC2, 
	0xDA, 0x52, 0xC3, 0xDB, 0x53, 0xC4, 0xDC, 0x53, 0xC5, 0xDE, 0x57, 0xCD, 0xE0, 0x54, 0xC9, 0xDD, 
	0x55, 0xCB, 0xE0, 0x56, 0xCD, 0xE1, 0x55, 0xCD, 0xE1, 0x5B, 0xCB, 0xDF, 0x5A, 0xCA, 0xDE, 0x54, 
	0xC8, 0xDC, 0x56, 0xCC, 0xE0, 0x5B, 0xCD, 0xE0, 0x5C, 0xCD, 0xE2, 0x5B, 0xCC, 0xDF, 0x5B, 0xCB, 
	0xDB, 0x5A, 0xCA, 0xDD, 0x5B, 0xCB, 0xE3, 0x5A, 0xCA, 0xD9, 0x5C, 0xCC, 0xDE, 0x54, 0xC5, 0xDD, 
	0x5C, 0xCC, 0xE3, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xDA, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xE1, 0x5A, 
	0xCA, 0xDA, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 0xE2, 0x5A, 0xCA, 0xDC, 0x5A, 0xCA, 0xDD, 0x5A, 0xCA, 
	0xDC, 0x5A, 0xCA, 0xE2, 0x5A, 0xCD, 0xDF, 0x3E, 0x9F, 0xB5, 0x48, 0xA2, 0xBA, 0x00, 0x04, 0x02, 
	0x70, 0x60, 0x57, 0x73, 0x6A, 0x57, 0x65, 0x5D, 0x50, 0x62, 0x5A, 0x49, 0x55, 0x4D, 0x42, 0x57, 
	0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4C, 0x44, 0x40, 0x4A, 0x3F, 0x36, 0x30, 0x34, 0x2B, 0x48, 0x3F, 
	0x36, 0x4D, 0x42, 0x39, 0x4C, 0x44, 0x39, 0x67, 0x62, 0x5B, 0x60, 0x58, 0x50, 0x5A, 0x4F, 0x46, 
	0x48, 0x3D, 0x33, 0x16, 0x3D, 0x48, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x34, 0x1B, 0x38, 0x42, 0x27, 
	0x2F, 0x32, 0x3B, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x26, 0x1C, 0x2C, 0x30, 0x2A, 0x19, 0x37, 
	0x42, 0x12, 0x39, 0x43, 0x1D, 0x33, 0x3C, 0x14, 0x26, 0x26, 0x19, 0x2A, 0x2F, 0x14, 0x2C, 0x31, 
	0x19, 0x36, 0x3F, 0x1A, 0x2B, 0x32, 0x1B, 0x2F, 0x38, 0x1A, 0x2C, 0x32, 0x5C, 0x51, 0x46, 0x67, 
	0x5F, 0x4B, 0x56, 0x4C, 0x44, 0x37, 0x4A, 0x4D, 0x52, 0x46, 0x3E, 0x40, 0x38, 0x30, 0x37, 0x48, 
	0x4A, 0x5E, 0x54, 0x4B, 0x50, 0x48, 0x3D, 0x4F, 0x44, 0x3A, 0x34, 0x35, 0x2C, 0x3A, 0x38, 0x2F, 
	0x25, 0x2F, 0x30, 0x35, 0x3E, 0x3A, 0x36, 0x2E, 0x29, 0x36, 0x37, 0x2E, 0x4C, 0x42, 0x39, 0x4E, 
	0x43, 0x3A, 0x34, 0x35, 0x2A, 0x2B, 0x3B, 0x3C, 0x23, 0x3E, 0x47, 0x18, 0x35, 0x39, 0x1D, 0x3A, 
	0x3E, 0x1D, 0x3C, 0x40, 0x1D, 0x3B, 0x40, 0x1A, 0x3B, 0x3B, 0x29, 0x4E, 0x58, 0x1D, 0x3A, 0x40, 
	0x35, 0x35, 0x2F, 0x4E, 0x43, 0x40, 0x50, 0x48, 0x3D, 0x56, 0x4C, 0x42, 0x1C, 0x20, 0x23, 0x32, 
	0x87, 0x98, 0x45, 0xAE, 0xC5, 0x52, 0xC5, 0xD5, 0x4A, 0xC1, 0xD0, 0x4D, 0xC1, 0xD2, 0x4F, 0xC2, 
	0xD4, 0x50, 0xC2, 0xD5, 0x51, 0xC3, 0xD6, 0x50, 0xC3, 0xD6, 0x50, 0xC2, 0xD4, 0x4F, 0xC1, 0xD4, 
	0x4F, 0xC1, 0xD4, 0x4F, 0xC2, 0xD4, 0x4F, 0xC0, 0xD3, 0x4F, 0xC4, 0xD6, 0x4F, 0xC1, 0xD4, 0x4F, 
	0xC3, 0xD6, 0x51, 0xC3, 0xD5, 0x55, 0xC8, 0xDA, 0x4F, 0xC2, 0xD4, 0x52, 0xC5, 0xD7, 0x4E, 0xC0, 
	0xD3, 0x4F, 0xC2, 0xD4, 0x4E, 0xC0, 0xD3, 0x51, 0xC6, 0xD8, 0x54, 0xC5, 0xD8, 0x56, 0xC8, 0xDB, 
	0x59, 0xCB, 0xDE, 0x57, 0xC6, 0xD9, 0x53, 0xC5, 0xD8, 0x53, 0xC6, 0xD9, 0x59, 0xCB, 0xDE, 0x53, 
	0xCA, 0xDD, 0x59, 0xCA, 0xDD, 0x52, 0xC9, 0xDC, 0x59, 0xCA, 0xDC, 0x4F, 0xC5, 0xD7, 0x52, 0xC5, 
	0xD7, 0x58, 0xCA, 0xDD, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCA, 0xDC, 
	0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 
	0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xC9, 
	0xDC, 0x58, 0xC9, 0xDC, 0x58, 0xCB, 0xDE, 0x5C, 0xD3, 0xE7, 0x3B, 0x98, 0xA6, 0x00, 0x04, 0x03, 
	0x6F, 0x60, 0x57, 0x75, 0x6C, 0x5A, 0x72, 0x67, 0x56, 0x62, 0x5A, 0x4C, 0x50, 0x48, 0x40, 0x58, 
	0x50, 0x49, 0x4E, 0x46, 0x3D, 0x5E, 0x56, 0x46, 0x4F, 0x47, 0x42, 0x46, 0x3D, 0x34, 0x38, 0x37, 
	0x32, 0x37, 0x37, 0x2E, 0x49, 0x43, 0x38, 0x66, 0x5D, 0x52, 0x67, 0x60, 0x5B, 0x43, 0x49, 0x47, 
	0x1E, 0x33, 0x39, 0x1C, 0x3A, 0x40, 0x1D, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1B, 0x32, 0x3C, 0x2B, 
	0x33, 0x31, 0x2F, 0x26, 0x1A, 0x36, 0x32, 0x30, 0x30, 0x28, 0x1D, 0x31, 0x31, 0x27, 0x29, 0x2E, 
	0x2C, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x34, 0x19, 0x2A, 0x2E, 0x15, 0x25, 0x25, 
	0x19, 0x37, 0x42, 0x1E, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x39, 0x47, 0x3D, 0x31, 0x5D, 
	0x55, 0x48, 0x54, 0x4C, 0x44, 0x57, 0x4D, 0x44, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x46, 0x5A, 0x50, 
	0x47, 0x5E, 0x56, 0x4D, 0x4F, 0x46, 0x3D, 0x4C, 0x4F, 0x4C, 0x48, 0x3C, 0x36, 0x34, 0x37, 0x2F, 
	0x12, 0x2C, 0x3B, 0x3C, 0x36, 0x2E, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x3E, 
	0x3B, 0x33, 0x50, 0x44, 0x3B, 0x3C, 0x37, 0x2C, 0x35, 0x45, 0x45, 0x27, 0x4E, 0x5A, 0x1B, 0x40, 
	0x3D, 0x1B, 0x36, 0x40, 0x1D, 0x3C, 0x40, 0x1D, 0x3F, 0x40, 0x19, 0x3D, 0x3E, 0x36, 0x3B, 0x35, 
	0x4F, 0x40, 0x39, 0x3E, 0x4A, 0x4C, 0x50, 0x47, 0x42, 0x40, 0x34, 0x30, 0x1F, 0x25, 0x26, 0x46, 
	0x90, 0xA5, 0x3A, 0x9A, 0xB3, 0x33, 0x8A, 0xA4, 0x3C, 0x9B, 0xB5, 0x3F, 0xA1, 0xBA, 0x39, 0x96, 
	0xAF, 0x37, 0x92, 0xAB, 0x34, 0x8A, 0xA3, 0x33, 0x89, 0xA2, 0x39, 0x94, 0xAD, 0x3E, 0xA0, 0xB8, 
	0x3E, 0xA0, 0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x38, 0x92, 0xAB, 0x3E, 
	0x9F, 0xB7, 0x3E, 0xA0, 0xB8, 0x35, 0x8E, 0xA7, 0x33, 0x89, 0xA2, 0x36, 0x8E, 0xA7, 0x3F, 0xA1, 
	0xB9, 0x38, 0x92, 0xAB, 0x3E, 0x9F, 0xB7, 0x3E, 0x9F, 0xB7, 0x37, 0x92, 0xAB, 0x3E, 0x9F, 0xB8, 
	0x3D, 0x9F, 0xB8, 0x37, 0x92, 0xAC, 0x3E, 0xA0, 0xB8, 0x37, 0x92, 0xAB, 0x3D, 0x9E, 0xB6, 0x3D, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3E, 0x9E, 0xB6, 0x3D, 0x9E, 
	0xB6, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 
	0x3C, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB6, 0x3C, 0x9D, 0xB6, 0x3D, 0x9D, 0xB5, 0x3C, 
	0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3D, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 0xB5, 0x3C, 0x9D, 
	0xB5, 0x3C, 0x9E, 0xB6, 0x45, 0x98, 0xB2, 0x31, 0x71, 0x80, 0x3A, 0x95, 0xA9, 0x00, 0x04, 0x03, 
	0x71, 0x62, 0x5A, 0x70, 0x65, 0x54, 0x5D, 0x56, 0x46, 0x63, 0x5B, 0x49, 0x59, 0x51, 0x4A, 0x60, 
	0x58, 0x49, 0x66, 0x5E, 0x4B, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x4D, 0x44, 0x3A, 0x53, 0x4A, 
	0x43, 0x4B, 0x40, 0x45, 0x3B, 0x37, 0x2F, 0x5B, 0x52, 0x46, 0x5F, 0x53, 0x47, 0x27, 0x44, 0x48, 
	0x1E, 0x45, 0x47, 0x1C, 0x42, 0x3F, 0x1D, 0x40, 0x44, 0x1D, 0x2B, 0x35, 0x1D, 0x3F, 0x43, 0x19, 
	0x31, 0x3D, 0x33, 0x28, 0x1C, 0x30, 0x26, 0x1B, 0x23, 0x18, 0x1C, 0x32, 0x28, 0x1D, 0x28, 0x2F, 
	0x2F, 0x11, 0x39, 0x43, 0x19, 0x34, 0x3C, 0x1E, 0x2F, 0x38, 0x18, 0x36, 0x3E, 0x19, 0x37, 0x40, 
	0x11, 0x22, 0x1E, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x15, 0x28, 0x2A, 0x1A, 0x32, 0x3C, 0x53, 
	0x49, 0x3E, 0x67, 0x5F, 0x4C, 0x5E, 0x56, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5F, 0x57, 
	0x4F, 0x60, 0x58, 0x4F, 0x4F, 0x45, 0x40, 0x3A, 0x4A, 0x4B, 0x4E, 0x4C, 0x4A, 0x28, 0x42, 0x44, 
	0x36, 0x35, 0x30, 0x2F, 0x2B, 0x25, 0x38, 0x39, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 0x3B, 0x32, 
	0x32, 0x2C, 0x3A, 0x39, 0x31, 0x50, 0x44, 0x3B, 0x3C, 0x36, 0x2B, 0x26, 0x44, 0x47, 0x26, 0x42, 
	0x47, 0x0E, 0x35, 0x3E, 0x1E, 0x3A, 0x40, 0x1D, 0x32, 0x3C, 0x1A, 0x36, 0x42, 0x34, 0x3B, 0x36, 
	0x4C, 0x3F, 0x36, 0x4F, 0x45, 0x3D, 0x4C, 0x43, 0x39, 0x49, 0x45, 0x39, 0x1C, 0x23, 0x24, 0x6B, 
	0xB4, 0xCC, 0x45, 0xBC, 0xD2, 0x3D, 0x98, 0xAE, 0x46, 0xB3, 0xC5, 0x43, 0xA2, 0xB5, 0x3F, 0x9B, 
	0xB1, 0x3F, 0x9A, 0xB0, 0x47, 0xB8, 0xCE, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB0, 0xC3, 
	0x45, 0xA8, 0xB8, 0x46, 0xB6, 0xCC, 0x45, 0xB4, 0xC9, 0x44, 0xB5, 0xCA, 0x45, 0xB5, 0xCA, 0x45, 
	0xB4, 0xC9, 0x45, 0xB4, 0xC9, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x46, 0xB5, 0xCB, 0x45, 0xB4, 
	0xC9, 0x46, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x44, 0xB4, 0xC9, 0x45, 0xB6, 0xCC, 0x47, 0xAF, 0xC0, 
	0x4A, 0xB0, 0xC1, 0x46, 0xB3, 0xC5, 0x44, 0xB5, 0xCA, 0x44, 0xB5, 0xCA, 0x43, 0xB4, 0xC9, 0x43, 
	0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB3, 
	0xC9, 0x46, 0xB3, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB4, 0xC9, 0x43, 0xB3, 0xC9, 0x46, 0xB5, 0xCC, 
	0x49, 0xB5, 0xCC, 0x42, 0xB4, 0xC9, 0x4F, 0xB4, 0xC6, 0x52, 0xB3, 0xC6, 0x40, 0xB3, 0xC9, 0x49, 
	0xB3, 0xC9, 0x46, 0xB3, 0xC9, 0x42, 0xB3, 0xC9, 0x49, 0xB5, 0xCC, 0x48, 0xB8, 0xCF, 0x48, 0xB3, 
	0xC8, 0x42, 0xB4, 0xC9, 0x48, 0xB5, 0xC9, 0x49, 0xB7, 0xD1, 0x53, 0xC1, 0xDB, 0x00, 0x03, 0x07, 
	0x7F, 0x70, 0x58, 0x71, 0x6A, 0x59, 0x6E, 0x62, 0x52, 0x60, 0x58, 0x47, 0x56, 0x4E, 0x48, 0x6C, 
	0x60, 0x4F, 0x5C, 0x54, 0x46, 0x5A, 0x52, 0x4B, 0x53, 0x4B, 0x42, 0x4F, 0x47, 0x3D, 0x53, 0x4B, 
	0x40, 0x48, 0x3D, 0x37, 0x4C, 0x40, 0x37, 0x3F, 0x3F, 0x3D, 0x57, 0x4A, 0x42, 0x1B, 0x38, 0x3E, 
	0x19, 0x3E, 0x3F, 0x1D, 0x38, 0x3E, 0x1C, 0x2A, 0x34, 0x1D, 0x2C, 0x36, 0x1D, 0x40, 0x43, 0x1B, 
	0x33, 0x3D, 0x27, 0x20, 0x1F, 0x31, 0x27, 0x1B, 0x27, 0x1D, 0x1C, 0x31, 0x29, 0x1E, 0x28, 0x30, 
	0x30, 0x0F, 0x3A, 0x44, 0x19, 0x34, 0x3C, 0x1B, 0x2C, 0x32, 0x1E, 0x2F, 0x37, 0x1B, 0x33, 0x3C, 
	0x1F, 0x31, 0x3B, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x14, 0x28, 0x2B, 0x1C, 
	0x2B, 0x31, 0x5D, 0x52, 0x44, 0x62, 0x5A, 0x53, 0x51, 0x4E, 0x49, 0x52, 0x4F, 0x4A, 0x5D, 0x54, 
	0x4C, 0x5F, 0x57, 0x4F, 0x57, 0x4E, 0x45, 0x46, 0x48, 0x44, 0x50, 0x51, 0x4D, 0x48, 0x3C, 0x35, 
	0x3C, 0x39, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x4C, 
	0x42, 0x39, 0x35, 0x30, 0x2E, 0x3A, 0x39, 0x31, 0x51, 0x43, 0x39, 0x2F, 0x3D, 0x3C, 0x33, 0x3F, 
	0x3E, 0x1E, 0x45, 0x45, 0x1B, 0x3B, 0x3C, 0x12, 0x22, 0x26, 0x1A, 0x40, 0x45, 0x2F, 0x3F, 0x40, 
	0x4C, 0x3E, 0x37, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x36, 0x45, 0x40, 0x37, 0x1F, 0x1D, 0x1F, 0x1C, 
	0x2A, 0x28, 0x20, 0x20, 0x24, 0x22, 0x2E, 0x33, 0x18, 0x28, 0x2A, 0x19, 0x2A, 0x2C, 0x19, 0x2B, 
	0x2C, 0x19, 0x2C, 0x2F, 0x16, 0x28, 0x2B, 0x18, 0x28, 0x2A, 0x19, 0x29, 0x2B, 0x19, 0x29, 0x2B, 
	0x19, 0x2A, 0x2E, 0x19, 0x29, 0x2B, 0x18, 0x2A, 0x2C, 0x27, 0x24, 0x26, 0x1F, 0x28, 0x2A, 0x18, 
	0x29, 0x2B, 0x19, 0x29, 0x2B, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x18, 0x28, 0x2A, 0x1C, 0x2B, 
	0x2A, 0x15, 0x28, 0x2A, 0x1E, 0x1E, 0x22, 0x1A, 0x2B, 0x2A, 0x1D, 0x22, 0x23, 0x00, 0x00, 0x00, 
	0x02, 0x00, 0x00, 0x0F, 0x16, 0x1A, 0x25, 0x30, 0x31, 0x29, 0x30, 0x29, 0x22, 0x29, 0x2B, 0x26, 
	0x2E, 0x2B, 0x27, 0x2E, 0x28, 0x28, 0x2F, 0x2A, 0x29, 0x33, 0x2B, 0x29, 0x33, 0x2B, 0x28, 0x32, 
	0x2A, 0x28, 0x32, 0x2A, 0x27, 0x2A, 0x31, 0x27, 0x2F, 0x2E, 0x28, 0x32, 0x2A, 0x29, 0x33, 0x2B, 
	0x27, 0x32, 0x29, 0x25, 0x28, 0x2F, 0x25, 0x2E, 0x2C, 0x25, 0x31, 0x29, 0x28, 0x32, 0x2A, 0x28, 
	0x32, 0x2A, 0x27, 0x31, 0x2A, 0x28, 0x32, 0x2A, 0x28, 0x32, 0x2A, 0x27, 0x31, 0x29, 0x29, 0x31, 
	0x2C, 0x24, 0x29, 0x2E, 0x23, 0x28, 0x2E, 0x27, 0x2C, 0x2C, 0x22, 0x2E, 0x2F, 0x0F, 0x0B, 0x0B, 
	0x7E, 0x71, 0x5E, 0x72, 0x6A, 0x5C, 0x76, 0x6E, 0x5F, 0x71, 0x65, 0x54, 0x5F, 0x58, 0x52, 0x71, 
	0x65, 0x53, 0x5F, 0x58, 0x49, 0x59, 0x51, 0x4A, 0x57, 0x4F, 0x47, 0x4C, 0x43, 0x3B, 0x50, 0x4D, 
	0x46, 0x4D, 0x4A, 0x48, 0x46, 0x3F, 0x35, 0x33, 0x2F, 0x2B, 0x45, 0x3A, 0x30, 0x29, 0x46, 0x48, 
	0x18, 0x3E, 0x40, 0x1D, 0x2C, 0x37, 0x22, 0x44, 0x49, 0x1C, 0x39, 0x3E, 0x1C, 0x2A, 0x34, 0x20, 
	0x47, 0x4A, 0x19, 0x32, 0x3E, 0x33, 0x27, 0x1B, 0x30, 0x27, 0x1C, 0x30, 0x28, 0x1C, 0x20, 0x27, 
	0x2B, 0x16, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x11, 0x23, 0x1F, 
	0x1B, 0x2E, 0x35, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x26, 0x1E, 0x31, 0x3A, 0x1C, 0x33, 0x3C, 0x1D, 
	0x2B, 0x2E, 0x4E, 0x45, 0x3A, 0x66, 0x5E, 0x54, 0x5B, 0x52, 0x47, 0x4C, 0x49, 0x44, 0x4E, 0x4C, 
	0x47, 0x5A, 0x51, 0x4A, 0x51, 0x4E, 0x48, 0x59, 0x4F, 0x45, 0x4F, 0x4B, 0x49, 0x46, 0x3D, 0x34, 
	0x4A, 0x40, 0x38, 0x36, 0x31, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x35, 
	0x37, 0x2F, 0x38, 0x39, 0x30, 0x35, 0x33, 0x2E, 0x3C, 0x3A, 0x31, 0x3E, 0x37, 0x2C, 0x23, 0x44, 
	0x48, 0x27, 0x4B, 0x56, 0x2E, 0x51, 0x55, 0x3D, 0x4D, 0x4B, 0x49, 0x4C, 0x4B, 0x42, 0x4C, 0x4C, 
	0x48, 0x43, 0x46, 0x49, 0x3E, 0x34, 0x49, 0x3F, 0x40, 0x4B, 0x40, 0x37, 0x42, 0x3E, 0x34, 0x45, 
	0x36, 0x32, 0x42, 0x3D, 0x3A, 0x1E, 0x50, 0x57, 0x1C, 0x43, 0x48, 0x1C, 0x3F, 0x49, 0x22, 0x45, 
	0x4C, 0x1E, 0x34, 0x39, 0x39, 0x3F, 0x3A, 0x22, 0x40, 0x4B, 0x1C, 0x36, 0x39, 0x1C, 0x3D, 0x42, 
	0x1C, 0x36, 0x3A, 0x1C, 0x37, 0x3B, 0x1C, 0x37, 0x3A, 0x14, 0x25, 0x28, 0x16, 0x28, 0x30, 0x20, 
	0x3D, 0x44, 0x1C, 0x3C, 0x3F, 0x23, 0x48, 0x4B, 0x23, 0x43, 0x49, 0x1F, 0x40, 0x49, 0x1B, 0x40, 
	0x4A, 0x24, 0x45, 0x4A, 0x5F, 0x56, 0x4C, 0x73, 0x65, 0x57, 0x73, 0x64, 0x59, 0x7A, 0x6D, 0x5F, 
	0x0F, 0x0C, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3B, 0x2F, 0x2A, 0x9D, 0x8A, 0x7F, 0x67, 
	0x5A, 0x52, 0x47, 0x3E, 0x35, 0x3A, 0x33, 0x2C, 0x59, 0x4E, 0x48, 0x50, 0x44, 0x39, 0x55, 0x49, 
	0x47, 0x57, 0x4B, 0x3F, 0x65, 0x57, 0x48, 0x5F, 0x54, 0x45, 0x54, 0x48, 0x43, 0x4E, 0x3F, 0x38, 
	0x5B, 0x50, 0x47, 0x7D, 0x6D, 0x58, 0x69, 0x5C, 0x4E, 0x66, 0x5B, 0x4E, 0x59, 0x4E, 0x45, 0x53, 
	0x47, 0x45, 0x61, 0x56, 0x4B, 0x54, 0x48, 0x45, 0x54, 0x48, 0x45, 0x59, 0x4E, 0x45, 0x63, 0x58, 
	0x4A, 0x79, 0x69, 0x58, 0x82, 0x72, 0x5B, 0x75, 0x66, 0x5D, 0x6E, 0x62, 0x54, 0x82, 0x74, 0x61, 
	0x7F, 0x6D, 0x5E, 0x5A, 0x53, 0x45, 0x63, 0x5D, 0x56, 0x73, 0x6C, 0x58, 0x63, 0x5A, 0x51, 0x60, 
	0x59, 0x53, 0x5B, 0x53, 0x49, 0x5A, 0x52, 0x4B, 0x50, 0x47, 0x3C, 0x4A, 0x4C, 0x49, 0x49, 0x4B, 
	0x48, 0x64, 0x5A, 0x4B, 0x5C, 0x53, 0x49, 0x39, 0x37, 0x2E, 0x33, 0x3C, 0x38, 0x1D, 0x3F, 0x48, 
	0x1E, 0x43, 0x3F, 0x18, 0x32, 0x3B, 0x0F, 0x38, 0x40, 0x1B, 0x33, 0x3C, 0x1D, 0x2E, 0x36, 0x1C, 
	0x3F, 0x43, 0x1B, 0x31, 0x3A, 0x27, 0x31, 0x31, 0x31, 0x25, 0x19, 0x32, 0x32, 0x2C, 0x4D, 0x43, 
	0x39, 0x18, 0x22, 0x24, 0x11, 0x24, 0x22, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x15, 0x28, 0x29, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x18, 0x29, 0x2C, 0x1E, 0x33, 0x3C, 0x18, 
	0x2C, 0x37, 0x3A, 0x3F, 0x42, 0x66, 0x5C, 0x4B, 0x5B, 0x52, 0x47, 0x5C, 0x53, 0x4B, 0x5D, 0x54, 
	0x4D, 0x67, 0x5E, 0x4A, 0x44, 0x46, 0x44, 0x51, 0x4D, 0x4A, 0x46, 0x3D, 0x36, 0x31, 0x31, 0x2A, 
	0x36, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x3F, 
	0x3C, 0x34, 0x36, 0x34, 0x2F, 0x4A, 0x40, 0x38, 0x33, 0x36, 0x2E, 0x50, 0x43, 0x3A, 0x4A, 0x3F, 
	0x38, 0x1E, 0x47, 0x4C, 0x15, 0x4B, 0x55, 0x27, 0x47, 0x4F, 0x18, 0x3C, 0x3B, 0x3E, 0x45, 0x45, 
	0x50, 0x42, 0x39, 0x4A, 0x3F, 0x37, 0x4D, 0x44, 0x3F, 0x49, 0x3F, 0x3F, 0x4C, 0x42, 0x38, 0x40, 
	0x3A, 0x31, 0x43, 0x4C, 0x4C, 0x1F, 0x49, 0x53, 0x1C, 0x4A, 0x53, 0x1B, 0x4B, 0x53, 0x2A, 0x49, 
	0x50, 0x35, 0x40, 0x3E, 0x1C, 0x40, 0x3F, 0x1F, 0x3C, 0x46, 0x1C, 0x39, 0x3F, 0x1D, 0x3E, 0x40, 
	0x1D, 0x42, 0x40, 0x1B, 0x3A, 0x3E, 0x29, 0x4E, 0x57, 0x27, 0x49, 0x4D, 0x2E, 0x40, 0x3D, 0x1E, 
	0x4F, 0x58, 0x19, 0x2B, 0x35, 0x28, 0x4B, 0x51, 0x1A, 0x4C, 0x55, 0x2B, 0x4C, 0x56, 0x19, 0x45, 
	0x48, 0x31, 0x48, 0x4E, 0x72, 0x5F, 0x52, 0x70, 0x6A, 0x58, 0x83, 0x71, 0x65, 0x89, 0x7B, 0x69, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x04, 0x06, 0x38, 0x2E, 0x2A, 0xA1, 0x91, 0x84, 0x7A, 
	0x6B, 0x58, 0x72, 0x67, 0x5A, 0x32, 0x32, 0x2A, 0x4C, 0x42, 0x39, 0x50, 0x48, 0x3D, 0x5D, 0x55, 
	0x4D, 0x51, 0x49, 0x40, 0x63, 0x5C, 0x4B, 0x5B, 0x53, 0x49, 0x64, 0x5A, 0x52, 0x33, 0x45, 0x49, 
	0x5F, 0x55, 0x4E, 0x73, 0x68, 0x55, 0x63, 0x5B, 0x53, 0x67, 0x5F, 0x4B, 0x59, 0x51, 0x4A, 0x5C, 
	0x53, 0x4A, 0x5D, 0x53, 0x4A, 0x5C, 0x54, 0x4B, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x56, 0x4E, 
	0x47, 0x5C, 0x54, 0x48, 0x75, 0x65, 0x50, 0x90, 0x7E, 0x6E, 0x72, 0x67, 0x57, 0x7E, 0x6D, 0x64, 
	0x75, 0x6A, 0x5E, 0x6E, 0x66, 0x58, 0x71, 0x67, 0x54, 0x7F, 0x6E, 0x68, 0x66, 0x5D, 0x51, 0x66, 
	0x5D, 0x4A, 0x56, 0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x59, 0x50, 0x48, 0x4C, 0x4E, 0x4B, 0x43, 0x3D, 
	0x40, 0x54, 0x4C, 0x46, 0x5B, 0x53, 0x4B, 0x4B, 0x42, 0x38, 0x3A, 0x36, 0x2B, 0x12, 0x33, 0x3E, 
	0x11, 0x38, 0x42, 0x1C, 0x30, 0x38, 0x18, 0x34, 0x3C, 0x1A, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1D, 
	0x2E, 0x37, 0x1D, 0x2F, 0x37, 0x1A, 0x31, 0x3C, 0x29, 0x1D, 0x16, 0x3F, 0x35, 0x2B, 0x47, 0x5A, 
	0x5C, 0x11, 0x26, 0x2B, 0x19, 0x2A, 0x30, 0x18, 0x29, 0x2C, 0x1E, 0x31, 0x3B, 0x15, 0x28, 0x2A, 
	0x12, 0x25, 0x23, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x11, 0x24, 0x22, 0x16, 0x29, 0x2C, 0x20, 
	0x35, 0x3C, 0x43, 0x3A, 0x32, 0x57, 0x4D, 0x44, 0x3D, 0x42, 0x46, 0x4F, 0x46, 0x3C, 0x56, 0x54, 
	0x4F, 0x5B, 0x52, 0x4A, 0x4B, 0x4E, 0x4B, 0x54, 0x4B, 0x47, 0x3F, 0x36, 0x31, 0x37, 0x2C, 0x30, 
	0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x35, 0x2C, 0x2C, 0x37, 0x33, 0x30, 0x2E, 0x2C, 0x26, 0x2B, 
	0x2C, 0x23, 0x33, 0x32, 0x2C, 0x51, 0x44, 0x3B, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x3D, 0x3A, 
	0x31, 0x37, 0x37, 0x30, 0x31, 0x43, 0x40, 0x39, 0x51, 0x51, 0x2E, 0x4F, 0x4F, 0x0C, 0x2A, 0x33, 
	0x22, 0x28, 0x29, 0x49, 0x40, 0x37, 0x4A, 0x40, 0x3A, 0x4A, 0x40, 0x3F, 0x47, 0x3C, 0x35, 0x3A, 
	0x32, 0x2A, 0x3D, 0x4E, 0x4E, 0x20, 0x4A, 0x53, 0x1C, 0x4A, 0x52, 0x1B, 0x4B, 0x54, 0x2C, 0x45, 
	0x4A, 0x1D, 0x3F, 0x3E, 0x35, 0x40, 0x40, 0x18, 0x38, 0x3F, 0x1D, 0x36, 0x40, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1B, 0x39, 0x3D, 0x28, 0x4C, 0x56, 0x2B, 0x45, 0x49, 0x36, 0x40, 0x3F, 0x1C, 
	0x4C, 0x55, 0x1A, 0x3E, 0x45, 0x1C, 0x3F, 0x3D, 0x1B, 0x3D, 0x3B, 0x1B, 0x3E, 0x3C, 0x19, 0x48, 
	0x4F, 0x28, 0x47, 0x4D, 0x74, 0x63, 0x55, 0x6E, 0x68, 0x55, 0x81, 0x6F, 0x60, 0x81, 0x74, 0x64, 
	0x0F, 0x11, 0x0D, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x6E, 
	0x62, 0x57, 0x73, 0x68, 0x55, 0x50, 0x48, 0x40, 0x4D, 0x44, 0x3A, 0x49, 0x3F, 0x37, 0x57, 0x4F, 
	0x47, 0x5A, 0x52, 0x4A, 0x50, 0x48, 0x40, 0x5D, 0x56, 0x49, 0x79, 0x6A, 0x56, 0x61, 0x57, 0x50, 
	0x61, 0x59, 0x52, 0x60, 0x58, 0x52, 0x62, 0x5A, 0x54, 0x57, 0x4F, 0x48, 0x5B, 0x52, 0x4A, 0x49, 
	0x4A, 0x47, 0x39, 0x48, 0x4B, 0x52, 0x48, 0x3C, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x58, 0x50, 
	0x48, 0x4A, 0x49, 0x43, 0x55, 0x4D, 0x48, 0x84, 0x73, 0x5D, 0x75, 0x6A, 0x64, 0x88, 0x78, 0x65, 
	0x7F, 0x6E, 0x5B, 0x72, 0x6A, 0x5E, 0x72, 0x6B, 0x58, 0x66, 0x5F, 0x51, 0x5D, 0x55, 0x4E, 0x67, 
	0x5E, 0x51, 0x4F, 0x47, 0x40, 0x59, 0x51, 0x48, 0x5A, 0x52, 0x4A, 0x5D, 0x53, 0x4A, 0x56, 0x53, 
	0x4D, 0x49, 0x3F, 0x3E, 0x53, 0x4A, 0x44, 0x34, 0x33, 0x2C, 0x3B, 0x38, 0x2F, 0x28, 0x3E, 0x44, 
	0x0F, 0x37, 0x40, 0x1B, 0x39, 0x42, 0x1D, 0x2B, 0x35, 0x1D, 0x48, 0x44, 0x1D, 0x30, 0x39, 0x1D, 
	0x2E, 0x36, 0x1D, 0x30, 0x38, 0x1B, 0x30, 0x3A, 0x32, 0x27, 0x19, 0x39, 0x2E, 0x24, 0x77, 0x6F, 
	0x6B, 0x1C, 0x28, 0x24, 0x13, 0x33, 0x3A, 0x1B, 0x33, 0x3C, 0x1A, 0x2C, 0x33, 0x14, 0x27, 0x28, 
	0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2E, 0x1D, 0x31, 0x3B, 0x14, 
	0x2A, 0x32, 0x46, 0x3C, 0x32, 0x51, 0x49, 0x3E, 0x4E, 0x45, 0x3F, 0x4F, 0x44, 0x3F, 0x4F, 0x46, 
	0x3A, 0x55, 0x4D, 0x45, 0x5C, 0x52, 0x48, 0x53, 0x4B, 0x48, 0x40, 0x36, 0x32, 0x2E, 0x2E, 0x26, 
	0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x39, 0x2F, 0x4A, 0x40, 0x38, 0x4B, 0x42, 0x39, 0x37, 
	0x35, 0x30, 0x36, 0x34, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x33, 0x2C, 0x36, 0x36, 
	0x2C, 0x38, 0x38, 0x30, 0x3D, 0x38, 0x2F, 0x4B, 0x44, 0x3C, 0x67, 0x5C, 0x54, 0x22, 0x42, 0x48, 
	0x0D, 0x24, 0x2A, 0x3B, 0x38, 0x2E, 0x47, 0x3F, 0x36, 0x4D, 0x3E, 0x3A, 0x39, 0x50, 0x54, 0x43, 
	0x4A, 0x49, 0x33, 0x50, 0x52, 0x1E, 0x48, 0x4E, 0x1C, 0x4B, 0x54, 0x13, 0x3A, 0x40, 0x40, 0x40, 
	0x3E, 0x1E, 0x40, 0x40, 0x2C, 0x40, 0x40, 0x36, 0x42, 0x40, 0x1A, 0x38, 0x40, 0x1D, 0x3A, 0x40, 
	0x1D, 0x42, 0x40, 0x1D, 0x3A, 0x3E, 0x19, 0x46, 0x49, 0x2A, 0x4A, 0x4F, 0x46, 0x4A, 0x49, 0x29, 
	0x4C, 0x50, 0x15, 0x40, 0x4B, 0x1C, 0x42, 0x43, 0x2A, 0x4C, 0x57, 0x19, 0x3C, 0x39, 0x28, 0x4B, 
	0x55, 0x28, 0x42, 0x45, 0x8C, 0x7B, 0x6C, 0x7D, 0x6E, 0x66, 0x81, 0x76, 0x69, 0x7B, 0x6D, 0x60, 
	0x0F, 0x12, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0C, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x75, 
	0x6A, 0x57, 0x67, 0x5E, 0x52, 0x5B, 0x4F, 0x44, 0x55, 0x4D, 0x45, 0x4B, 0x44, 0x3C, 0x49, 0x40, 
	0x38, 0x4F, 0x47, 0x3D, 0x55, 0x4D, 0x45, 0x57, 0x4F, 0x48, 0x64, 0x5C, 0x53, 0x60, 0x59, 0x46, 
	0x71, 0x65, 0x54, 0x61, 0x59, 0x48, 0x64, 0x5C, 0x49, 0x5A, 0x51, 0x4A, 0x5C, 0x53, 0x4A, 0x4E, 
	0x4F, 0x4B, 0x3B, 0x4A, 0x4B, 0x4D, 0x42, 0x3A, 0x5C, 0x54, 0x4C, 0x4F, 0x47, 0x3C, 0x59, 0x51, 
	0x49, 0x59, 0x51, 0x49, 0x4A, 0x43, 0x3B, 0x7A, 0x6A, 0x54, 0x6E, 0x64, 0x55, 0x8C, 0x7A, 0x6C, 
	0x90, 0x7F, 0x6E, 0x8B, 0x79, 0x6A, 0x67, 0x60, 0x56, 0x4E, 0x46, 0x3D, 0x4B, 0x42, 0x3E, 0x4F, 
	0x46, 0x3E, 0x46, 0x42, 0x43, 0x4F, 0x46, 0x3F, 0x63, 0x5B, 0x53, 0x53, 0x4B, 0x42, 0x51, 0x48, 
	0x42, 0x4B, 0x40, 0x3A, 0x48, 0x3F, 0x36, 0x2F, 0x2C, 0x27, 0x2F, 0x2E, 0x23, 0x26, 0x38, 0x3B, 
	0x1A, 0x34, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x2C, 0x35, 0x1A, 0x30, 0x39, 0x1D, 0x31, 0x39, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x19, 0x32, 0x3B, 0x24, 0x2F, 0x30, 0x40, 0x34, 0x31, 0x7C, 0x75, 
	0x6B, 0x1B, 0x2F, 0x30, 0x14, 0x2B, 0x30, 0x1A, 0x33, 0x3C, 0x25, 0x30, 0x32, 0x1E, 0x32, 0x3C, 
	0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x38, 0x19, 0x2C, 0x34, 0x2B, 0x30, 0x2B, 0x19, 
	0x2E, 0x39, 0x28, 0x35, 0x33, 0x50, 0x46, 0x42, 0x51, 0x47, 0x3E, 0x39, 0x4A, 0x4D, 0x4D, 0x48, 
	0x44, 0x5F, 0x55, 0x4B, 0x44, 0x48, 0x46, 0x58, 0x4F, 0x44, 0x3F, 0x3B, 0x38, 0x32, 0x2E, 0x2A, 
	0x39, 0x36, 0x31, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 
	0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x25, 0x28, 
	0x28, 0x33, 0x33, 0x29, 0x35, 0x37, 0x2F, 0x51, 0x47, 0x3C, 0x5B, 0x51, 0x48, 0x51, 0x57, 0x52, 
	0x25, 0x3F, 0x44, 0x3C, 0x33, 0x2F, 0x33, 0x2B, 0x2B, 0x3B, 0x40, 0x3B, 0x30, 0x5B, 0x64, 0x27, 
	0x51, 0x55, 0x18, 0x3D, 0x45, 0x0F, 0x32, 0x3A, 0x23, 0x4C, 0x55, 0x1C, 0x49, 0x4F, 0x16, 0x39, 
	0x3E, 0x1B, 0x3E, 0x40, 0x1A, 0x37, 0x40, 0x1A, 0x40, 0x3F, 0x1C, 0x40, 0x3E, 0x1D, 0x42, 0x40, 
	0x1D, 0x40, 0x40, 0x1C, 0x3A, 0x3E, 0x23, 0x47, 0x4B, 0x28, 0x50, 0x55, 0x4F, 0x4D, 0x4A, 0x23, 
	0x37, 0x3C, 0x19, 0x3D, 0x3D, 0x1F, 0x47, 0x4B, 0x2B, 0x4E, 0x54, 0x27, 0x4B, 0x55, 0x24, 0x4B, 
	0x54, 0x26, 0x40, 0x46, 0x7F, 0x6D, 0x53, 0x80, 0x6E, 0x5F, 0x76, 0x70, 0x6A, 0x86, 0x76, 0x62, 
	0x0F, 0x13, 0x0E, 0x00, 0x00, 0x00, 0x04, 0x0C, 0x0D, 0x38, 0x2E, 0x29, 0xA1, 0x90, 0x83, 0x77, 
	0x6B, 0x57, 0x56, 0x50, 0x4C, 0x2C, 0x4C, 0x4F, 0x70, 0x60, 0x54, 0x7C, 0x67, 0x55, 0x65, 0x5B, 
	0x4F, 0x63, 0x5C, 0x49, 0x60, 0x58, 0x49, 0x62, 0x5A, 0x54, 0x61, 0x5A, 0x53, 0x61, 0x5A, 0x53, 
	0x68, 0x60, 0x51, 0x59, 0x51, 0x48, 0x57, 0x4E, 0x47, 0x4F, 0x4D, 0x48, 0x53, 0x4B, 0x42, 0x4F, 
	0x45, 0x3C, 0x47, 0x49, 0x45, 0x4F, 0x4C, 0x46, 0x5C, 0x54, 0x4B, 0x4E, 0x46, 0x3F, 0x4D, 0x45, 
	0x3E, 0x59, 0x51, 0x49, 0x5F, 0x57, 0x4C, 0x48, 0x40, 0x38, 0x4C, 0x44, 0x3F, 0x57, 0x4E, 0x43, 
	0x5A, 0x52, 0x4B, 0x80, 0x71, 0x64, 0x6D, 0x62, 0x4F, 0x3D, 0x37, 0x30, 0x4C, 0x43, 0x3E, 0x51, 
	0x48, 0x40, 0x31, 0x34, 0x2A, 0x47, 0x3D, 0x35, 0x4C, 0x43, 0x3C, 0x4D, 0x44, 0x3A, 0x47, 0x3E, 
	0x35, 0x35, 0x34, 0x2E, 0x37, 0x39, 0x30, 0x2E, 0x2F, 0x25, 0x2F, 0x2E, 0x24, 0x2F, 0x38, 0x36, 
	0x13, 0x3B, 0x43, 0x1D, 0x37, 0x40, 0x1D, 0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x43, 0x1D, 0x2E, 0x36, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x2E, 0x39, 0x30, 0x29, 0x5C, 0x55, 
	0x4B, 0x16, 0x2B, 0x2F, 0x14, 0x27, 0x29, 0x1B, 0x2C, 0x33, 0x1A, 0x2E, 0x34, 0x13, 0x26, 0x26, 
	0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3A, 0x1C, 0x30, 0x3A, 0x1D, 
	0x32, 0x39, 0x4A, 0x44, 0x3D, 0x52, 0x49, 0x3E, 0x58, 0x4F, 0x45, 0x49, 0x4B, 0x47, 0x4B, 0x4E, 
	0x4B, 0x52, 0x4E, 0x48, 0x53, 0x49, 0x3D, 0x4D, 0x44, 0x40, 0x47, 0x3E, 0x3D, 0x2C, 0x25, 0x1D, 
	0x32, 0x31, 0x2A, 0x38, 0x39, 0x30, 0x36, 0x37, 0x2F, 0x49, 0x3F, 0x37, 0x3D, 0x3A, 0x32, 0x35, 
	0x36, 0x2E, 0x35, 0x37, 0x2F, 0x35, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x34, 0x2F, 0x2A, 0x24, 0x28, 
	0x27, 0x3B, 0x3B, 0x32, 0x34, 0x2F, 0x2C, 0x3F, 0x3A, 0x32, 0x54, 0x4B, 0x40, 0x51, 0x48, 0x40, 
	0x6C, 0x60, 0x54, 0x6F, 0x66, 0x5B, 0x40, 0x3C, 0x32, 0x3B, 0x3A, 0x37, 0x6D, 0x6B, 0x6B, 0x5B, 
	0x6F, 0x77, 0x33, 0x5F, 0x6A, 0x12, 0x37, 0x3F, 0x1A, 0x47, 0x4F, 0x1E, 0x4C, 0x56, 0x35, 0x3F, 
	0x3D, 0x1E, 0x3E, 0x3E, 0x20, 0x40, 0x3F, 0x1D, 0x44, 0x46, 0x25, 0x43, 0x4D, 0x1C, 0x3A, 0x3E, 
	0x1D, 0x3E, 0x40, 0x1D, 0x3C, 0x40, 0x1A, 0x3C, 0x3E, 0x2E, 0x44, 0x46, 0x4E, 0x4E, 0x4B, 0x29, 
	0x44, 0x43, 0x1B, 0x3F, 0x40, 0x1F, 0x3E, 0x46, 0x20, 0x43, 0x4A, 0x25, 0x46, 0x4A, 0x35, 0x3E, 
	0x3C, 0x4B, 0x57, 0x53, 0x88, 0x73, 0x61, 0x8A, 0x78, 0x6B, 0x65, 0x62, 0x55, 0x69, 0x61, 0x53, 
	0x0C, 0x04, 0x07, 0x00, 0x00, 0x00, 0x04, 0x06, 0x06, 0x38, 0x2F, 0x2A, 0xA3, 0x92, 0x82, 0x74, 
	0x66, 0x59, 0x51, 0x50, 0x4D, 0x18, 0x40, 0x47, 0x25, 0x4B, 0x50, 0x69, 0x5D, 0x4F, 0x64, 0x5C, 
	0x53, 0x62, 0x5A, 0x52, 0x62, 0x5A, 0x47, 0x69, 0x60, 0x54, 0x60, 0x58, 0x47, 0x61, 0x57, 0x4F, 
	0x5F, 0x57, 0x47, 0x67, 0x5E, 0x55, 0x56, 0x4F, 0x47, 0x54, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x5D, 
	0x55, 0x4C, 0x57, 0x4E, 0x45, 0x57, 0x4E, 0x46, 0x5D, 0x55, 0x4C, 0x4B, 0x43, 0x38, 0x52, 0x4A, 
	0x3F, 0x50, 0x48, 0x3E, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x5F, 0x56, 0x48, 0x46, 0x48, 0x47, 
	0x25, 0x37, 0x37, 0x74, 0x65, 0x5A, 0x72, 0x69, 0x58, 0x46, 0x3C, 0x34, 0x44, 0x42, 0x3F, 0x4A, 
	0x3F, 0x36, 0x3B, 0x39, 0x31, 0x33, 0x36, 0x2E, 0x34, 0x36, 0x2E, 0x3C, 0x39, 0x31, 0x34, 0x37, 
	0x2E, 0x30, 0x2C, 0x27, 0x34, 0x2F, 0x2B, 0x2F, 0x2F, 0x26, 0x35, 0x32, 0x2C, 0x3C, 0x3A, 0x2F, 
	0x22, 0x35, 0x3B, 0x1C, 0x38, 0x42, 0x1D, 0x38, 0x40, 0x1D, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x39, 0x42, 0x1B, 0x31, 0x39, 0x15, 0x35, 0x3E, 0x26, 0x2F, 0x30, 0x33, 0x33, 0x27, 0x4E, 0x4C, 
	0x4B, 0x13, 0x2A, 0x34, 0x11, 0x24, 0x20, 0x1F, 0x32, 0x3C, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 
	0x1E, 0x31, 0x3B, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 0x13, 0x26, 0x27, 0x25, 
	0x38, 0x3C, 0x52, 0x53, 0x4F, 0x5D, 0x54, 0x4B, 0x5C, 0x53, 0x4A, 0x5B, 0x52, 0x4A, 0x5D, 0x53, 
	0x4A, 0x45, 0x48, 0x45, 0x54, 0x51, 0x4A, 0x4D, 0x43, 0x3E, 0x4C, 0x50, 0x4C, 0x43, 0x39, 0x36, 
	0x37, 0x30, 0x2F, 0x38, 0x30, 0x30, 0x34, 0x37, 0x2E, 0x4F, 0x43, 0x3A, 0x31, 0x34, 0x2B, 0x51, 
	0x44, 0x3B, 0x33, 0x36, 0x2E, 0x52, 0x45, 0x3C, 0x36, 0x37, 0x2C, 0x36, 0x31, 0x2E, 0x35, 0x32, 
	0x2B, 0x2C, 0x2E, 0x24, 0x32, 0x2C, 0x29, 0x3C, 0x3A, 0x34, 0x4D, 0x44, 0x3C, 0x47, 0x3D, 0x3F, 
	0x51, 0x49, 0x3F, 0x77, 0x6E, 0x5C, 0x3C, 0x35, 0x33, 0x34, 0x32, 0x2B, 0x43, 0x3F, 0x38, 0x57, 
	0x49, 0x3E, 0x32, 0x54, 0x55, 0x18, 0x46, 0x4E, 0x13, 0x38, 0x40, 0x1F, 0x43, 0x49, 0x39, 0x43, 
	0x42, 0x39, 0x51, 0x50, 0x32, 0x3F, 0x3E, 0x35, 0x42, 0x3F, 0x1A, 0x35, 0x3E, 0x1D, 0x3C, 0x40, 
	0x1D, 0x3E, 0x3E, 0x1D, 0x2F, 0x3A, 0x1C, 0x3B, 0x3F, 0x1E, 0x47, 0x4C, 0x49, 0x4C, 0x4B, 0x2B, 
	0x40, 0x3F, 0x1B, 0x2A, 0x35, 0x1C, 0x30, 0x39, 0x1A, 0x3B, 0x3F, 0x35, 0x3F, 0x3D, 0x29, 0x4B, 
	0x50, 0x29, 0x4A, 0x4F, 0x67, 0x5E, 0x4F, 0x89, 0x77, 0x65, 0x7A, 0x6A, 0x58, 0x5F, 0x56, 0x49, 
	0x0D, 0x07, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x35, 0x2B, 0x2A, 0x87, 0x78, 0x68, 0x65, 
	0x5E, 0x4E, 0x5D, 0x51, 0x46, 0x32, 0x42, 0x46, 0x2B, 0x49, 0x4E, 0x6A, 0x5E, 0x53, 0x69, 0x60, 
	0x50, 0x56, 0x4F, 0x48, 0x5D, 0x55, 0x4E, 0x63, 0x5B, 0x54, 0x57, 0x52, 0x49, 0x2A, 0x3F, 0x42, 
	0x5B, 0x55, 0x4F, 0x6C, 0x63, 0x55, 0x58, 0x50, 0x45, 0x4E, 0x43, 0x39, 0x51, 0x49, 0x3E, 0x4D, 
	0x4B, 0x46, 0x57, 0x4F, 0x46, 0x4B, 0x43, 0x3B, 0x52, 0x4A, 0x44, 0x52, 0x4A, 0x3F, 0x57, 0x4F, 
	0x47, 0x51, 0x49, 0x3F, 0x51, 0x47, 0x3F, 0x39, 0x40, 0x3F, 0x5E, 0x55, 0x48, 0x76, 0x6B, 0x59, 
	0x34, 0x44, 0x49, 0x72, 0x66, 0x59, 0x85, 0x72, 0x69, 0x62, 0x57, 0x48, 0x5A, 0x52, 0x47, 0x4F, 
	0x47, 0x3C, 0x40, 0x3B, 0x33, 0x4E, 0x43, 0x3A, 0x3B, 0x39, 0x31, 0x34, 0x36, 0x2E, 0x53, 0x45, 
	0x3C, 0x32, 0x33, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x29, 0x1F, 0x31, 0x2F, 0x28, 
	0x3C, 0x31, 0x2B, 0x1A, 0x33, 0x3D, 0x1D, 0x39, 0x42, 0x1D, 0x36, 0x3E, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3A, 0x44, 0x16, 0x2E, 0x33, 0x18, 0x32, 0x3C, 0x35, 0x31, 0x23, 0x28, 0x23, 0x1F, 0x51, 0x47, 
	0x46, 0x29, 0x4D, 0x4E, 0x14, 0x2A, 0x2F, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x14, 0x27, 0x27, 
	0x19, 0x2B, 0x31, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x16, 0x29, 0x2C, 0x1E, 
	0x33, 0x3B, 0x4C, 0x40, 0x34, 0x5A, 0x51, 0x47, 0x4B, 0x4E, 0x4C, 0x5D, 0x53, 0x4A, 0x57, 0x4F, 
	0x47, 0x4D, 0x4A, 0x42, 0x4F, 0x43, 0x3E, 0x55, 0x4B, 0x3F, 0x58, 0x4E, 0x45, 0x4A, 0x43, 0x38, 
	0x36, 0x39, 0x2F, 0x33, 0x2C, 0x27, 0x4C, 0x44, 0x3A, 0x47, 0x3E, 0x36, 0x50, 0x45, 0x3B, 0x3A, 
	0x39, 0x31, 0x37, 0x37, 0x2F, 0x36, 0x36, 0x2C, 0x2F, 0x42, 0x42, 0x39, 0x32, 0x2E, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x39, 0x3A, 0x31, 0x32, 0x30, 0x2A, 0x4C, 0x42, 0x38, 0x49, 0x3F, 0x42, 
	0x45, 0x3B, 0x37, 0x6A, 0x61, 0x53, 0x5B, 0x52, 0x4B, 0x2A, 0x2A, 0x22, 0x44, 0x3B, 0x3B, 0x33, 
	0x4B, 0x4C, 0x43, 0x4D, 0x4B, 0x18, 0x4A, 0x54, 0x1B, 0x4C, 0x55, 0x1E, 0x49, 0x50, 0x18, 0x39, 
	0x3A, 0x18, 0x42, 0x4C, 0x22, 0x3B, 0x3E, 0x22, 0x39, 0x40, 0x1C, 0x37, 0x40, 0x1D, 0x3B, 0x3E, 
	0x1A, 0x4A, 0x54, 0x1D, 0x3C, 0x3E, 0x1D, 0x3F, 0x40, 0x1B, 0x3B, 0x3F, 0x23, 0x3F, 0x47, 0x22, 
	0x42, 0x42, 0x1B, 0x2A, 0x34, 0x25, 0x4C, 0x50, 0x1A, 0x3D, 0x3E, 0x1A, 0x39, 0x3E, 0x24, 0x48, 
	0x4F, 0x2B, 0x55, 0x5A, 0x42, 0x45, 0x45, 0x73, 0x6E, 0x62, 0x84, 0x73, 0x65, 0x58, 0x52, 0x47, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x09, 0x09, 0x0B, 0x35, 0x2A, 0x27, 0x8F, 0x80, 0x70, 0x52, 
	0x4B, 0x45, 0x59, 0x51, 0x4A, 0x60, 0x55, 0x49, 0x5D, 0x52, 0x49, 0x5D, 0x55, 0x4E, 0x63, 0x5C, 
	0x4B, 0x58, 0x50, 0x48, 0x64, 0x5C, 0x55, 0x62, 0x59, 0x4B, 0x4D, 0x4D, 0x4A, 0x30, 0x42, 0x43, 
	0x38, 0x47, 0x4A, 0x59, 0x4F, 0x46, 0x4F, 0x4C, 0x49, 0x2E, 0x38, 0x34, 0x5A, 0x50, 0x48, 0x53, 
	0x4B, 0x42, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3B, 0x4A, 0x40, 0x39, 0x4D, 0x44, 0x3F, 0x58, 0x50, 
	0x47, 0x53, 0x4A, 0x3F, 0x4D, 0x45, 0x3C, 0x09, 0x25, 0x34, 0x55, 0x4A, 0x40, 0x6F, 0x63, 0x53, 
	0x53, 0x48, 0x40, 0x5A, 0x55, 0x4D, 0x7C, 0x6C, 0x5B, 0x74, 0x69, 0x56, 0x53, 0x4B, 0x3F, 0x45, 
	0x3C, 0x38, 0x33, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x43, 0x3C, 0x34, 0x36, 0x37, 0x2F, 0x36, 0x37, 
	0x2F, 0x34, 0x35, 0x2B, 0x28, 0x22, 0x1F, 0x30, 0x32, 0x28, 0x30, 0x29, 0x1F, 0x2F, 0x30, 0x27, 
	0x31, 0x2F, 0x24, 0x18, 0x31, 0x3D, 0x16, 0x36, 0x40, 0x16, 0x3A, 0x45, 0x1A, 0x2E, 0x38, 0x1B, 
	0x31, 0x3B, 0x1C, 0x30, 0x3A, 0x1B, 0x31, 0x3A, 0x1E, 0x23, 0x2B, 0x31, 0x31, 0x26, 0x34, 0x32, 
	0x27, 0x1F, 0x36, 0x3E, 0x13, 0x39, 0x43, 0x14, 0x26, 0x25, 0x1E, 0x31, 0x3B, 0x1C, 0x2F, 0x37, 
	0x12, 0x25, 0x24, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x18, 
	0x2E, 0x38, 0x37, 0x38, 0x34, 0x43, 0x3C, 0x35, 0x33, 0x3B, 0x3B, 0x4E, 0x4E, 0x4C, 0x68, 0x5F, 
	0x4B, 0x50, 0x45, 0x42, 0x34, 0x48, 0x48, 0x3D, 0x42, 0x40, 0x4D, 0x42, 0x36, 0x3D, 0x37, 0x31, 
	0x3A, 0x35, 0x2C, 0x15, 0x31, 0x3E, 0x2F, 0x1F, 0x1C, 0x2E, 0x36, 0x30, 0x37, 0x2B, 0x2F, 0x37, 
	0x36, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x32, 0x3D, 0x3A, 0x38, 0x32, 0x2F, 0x38, 0x39, 
	0x30, 0x38, 0x38, 0x30, 0x39, 0x37, 0x2E, 0x36, 0x37, 0x2F, 0x47, 0x3E, 0x36, 0x53, 0x4B, 0x3F, 
	0x47, 0x3D, 0x42, 0x58, 0x50, 0x45, 0x6A, 0x62, 0x54, 0x5A, 0x52, 0x46, 0x60, 0x55, 0x4C, 0x32, 
	0x3E, 0x40, 0x2C, 0x3F, 0x3F, 0x26, 0x47, 0x4C, 0x2C, 0x42, 0x44, 0x28, 0x46, 0x4C, 0x2C, 0x3E, 
	0x40, 0x0E, 0x35, 0x3E, 0x1B, 0x3D, 0x40, 0x1C, 0x3C, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 0x3C, 0x40, 
	0x1E, 0x3E, 0x3E, 0x1D, 0x36, 0x40, 0x1D, 0x3B, 0x42, 0x1D, 0x2A, 0x35, 0x1C, 0x2B, 0x35, 0x1C, 
	0x2C, 0x36, 0x1D, 0x30, 0x39, 0x1A, 0x3D, 0x40, 0x38, 0x42, 0x40, 0x1A, 0x3E, 0x3F, 0x1F, 0x43, 
	0x45, 0x20, 0x47, 0x49, 0x43, 0x4A, 0x4B, 0x4C, 0x4C, 0x49, 0x66, 0x62, 0x60, 0x43, 0x45, 0x3D, 
	0x12, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x04, 0x0D, 0x0E, 0x38, 0x2B, 0x28, 0x8B, 0x79, 0x6B, 0x5C, 
	0x54, 0x47, 0x58, 0x50, 0x49, 0x64, 0x5C, 0x55, 0x59, 0x51, 0x49, 0x59, 0x51, 0x49, 0x59, 0x51, 
	0x49, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x57, 0x4F, 0x47, 0x4E, 0x4B, 0x45, 0x60, 0x54, 0x4B, 
	0x5D, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x51, 0x48, 0x39, 0x4A, 0x4D, 0x57, 0x4D, 0x45, 0x58, 
	0x50, 0x47, 0x4D, 0x45, 0x3D, 0x5F, 0x57, 0x4E, 0x4D, 0x44, 0x3F, 0x44, 0x40, 0x44, 0x50, 0x48, 
	0x3F, 0x4E, 0x45, 0x40, 0x4D, 0x3F, 0x35, 0x1C, 0x43, 0x45, 0x51, 0x3F, 0x35, 0x3F, 0x3A, 0x33, 
	0x37, 0x37, 0x2F, 0x36, 0x47, 0x48, 0x37, 0x42, 0x40, 0x53, 0x48, 0x3D, 0x4D, 0x43, 0x3A, 0x3A, 
	0x38, 0x30, 0x35, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x3B, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x38, 0x39, 
	0x30, 0x36, 0x33, 0x2E, 0x2F, 0x31, 0x27, 0x30, 0x29, 0x20, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 
	0x2F, 0x2F, 0x26, 0x3A, 0x32, 0x2E, 0x3A, 0x31, 0x2C, 0x37, 0x34, 0x29, 0x37, 0x35, 0x29, 0x2F, 
	0x33, 0x2E, 0x26, 0x23, 0x24, 0x22, 0x2A, 0x2F, 0x32, 0x32, 0x27, 0x30, 0x2A, 0x20, 0x30, 0x31, 
	0x27, 0x27, 0x23, 0x22, 0x1B, 0x32, 0x3C, 0x1C, 0x32, 0x3C, 0x1B, 0x2E, 0x34, 0x12, 0x25, 0x23, 
	0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x12, 0x25, 0x23, 0x19, 0x2E, 0x35, 0x23, 
	0x30, 0x34, 0x27, 0x2A, 0x27, 0x2E, 0x20, 0x23, 0x31, 0x35, 0x2C, 0x3A, 0x46, 0x45, 0x67, 0x5C, 
	0x4B, 0x5B, 0x4E, 0x42, 0x18, 0x2E, 0x34, 0x12, 0x26, 0x2C, 0x23, 0x38, 0x3C, 0x26, 0x30, 0x31, 
	0x1E, 0x24, 0x20, 0x18, 0x2B, 0x31, 0x14, 0x2B, 0x30, 0x1A, 0x27, 0x2E, 0x36, 0x31, 0x2A, 0x39, 
	0x2E, 0x32, 0x35, 0x36, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x37, 0x2F, 0x38, 0x39, 0x30, 0x38, 0x32, 
	0x30, 0x39, 0x38, 0x2E, 0x25, 0x45, 0x49, 0x39, 0x37, 0x2E, 0x34, 0x36, 0x2E, 0x4B, 0x40, 0x38, 
	0x4A, 0x40, 0x36, 0x45, 0x3E, 0x3B, 0x5A, 0x52, 0x46, 0x58, 0x50, 0x48, 0x47, 0x3F, 0x36, 0x36, 
	0x35, 0x2C, 0x38, 0x36, 0x2C, 0x3E, 0x38, 0x31, 0x4F, 0x40, 0x37, 0x4E, 0x3F, 0x36, 0x48, 0x3B, 
	0x30, 0x0F, 0x37, 0x42, 0x12, 0x36, 0x40, 0x1E, 0x44, 0x40, 0x1D, 0x37, 0x40, 0x1E, 0x3D, 0x40, 
	0x0F, 0x36, 0x40, 0x1C, 0x3B, 0x40, 0x1D, 0x36, 0x40, 0x1D, 0x3E, 0x42, 0x1D, 0x3C, 0x43, 0x1A, 
	0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2A, 0x34, 0x1A, 0x3F, 0x43, 0x1D, 0x30, 0x3A, 0x1D, 0x3C, 
	0x3F, 0x19, 0x37, 0x3F, 0x30, 0x3C, 0x39, 0x3A, 0x45, 0x45, 0x5F, 0x53, 0x49, 0x39, 0x48, 0x47, 
	0x08, 0x06, 0x06, 0x00, 0x00, 0x00, 0x0F, 0x07, 0x08, 0x16, 0x1F, 0x1C, 0x86, 0x79, 0x67, 0x55, 
	0x4E, 0x48, 0x59, 0x51, 0x49, 0x65, 0x5D, 0x55, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x58, 0x50, 0x48, 0x4F, 0x45, 0x3C, 0x4E, 0x4F, 0x4C, 
	0x59, 0x4E, 0x44, 0x5C, 0x52, 0x49, 0x57, 0x4C, 0x42, 0x52, 0x48, 0x3D, 0x65, 0x5D, 0x4D, 0x49, 
	0x40, 0x3A, 0x4C, 0x43, 0x3F, 0x51, 0x49, 0x3E, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3F, 0x51, 0x48, 
	0x3F, 0x45, 0x43, 0x43, 0x4C, 0x40, 0x36, 0x31, 0x3A, 0x36, 0x2B, 0x3D, 0x3E, 0x1B, 0x28, 0x2A, 
	0x15, 0x31, 0x3C, 0x1A, 0x2A, 0x35, 0x18, 0x37, 0x3F, 0x49, 0x3D, 0x34, 0x38, 0x37, 0x30, 0x36, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 0x33, 0x35, 0x2C, 0x38, 0x38, 0x30, 0x36, 0x31, 
	0x2F, 0x39, 0x38, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x32, 0x27, 0x22, 0x13, 0x18, 0x32, 0x34, 0x29, 
	0x30, 0x30, 0x27, 0x2F, 0x2F, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x29, 0x1F, 0x2F, 0x30, 0x27, 0x30, 
	0x31, 0x27, 0x31, 0x2B, 0x20, 0x32, 0x33, 0x28, 0x30, 0x28, 0x1E, 0x30, 0x25, 0x1B, 0x30, 0x33, 
	0x29, 0x28, 0x1E, 0x1D, 0x27, 0x19, 0x18, 0x29, 0x26, 0x24, 0x1B, 0x34, 0x3F, 0x14, 0x29, 0x2B, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x18, 0x2B, 0x31, 0x1A, 0x2E, 0x35, 0x2A, 0x30, 0x2E, 0x1E, 
	0x32, 0x38, 0x2B, 0x24, 0x1E, 0x2B, 0x26, 0x20, 0x28, 0x33, 0x34, 0x18, 0x32, 0x3B, 0x53, 0x52, 
	0x4E, 0x44, 0x47, 0x42, 0x13, 0x27, 0x2C, 0x13, 0x26, 0x25, 0x12, 0x25, 0x25, 0x11, 0x25, 0x25, 
	0x12, 0x27, 0x27, 0x12, 0x25, 0x23, 0x20, 0x33, 0x3E, 0x0D, 0x25, 0x24, 0x33, 0x2A, 0x25, 0x2E, 
	0x2C, 0x22, 0x39, 0x31, 0x32, 0x36, 0x33, 0x2E, 0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 
	0x30, 0x38, 0x2F, 0x30, 0x39, 0x32, 0x2E, 0x37, 0x38, 0x2F, 0x35, 0x37, 0x2F, 0x4E, 0x43, 0x3A, 
	0x48, 0x3F, 0x37, 0x32, 0x35, 0x2B, 0x46, 0x3D, 0x38, 0x4C, 0x40, 0x37, 0x38, 0x37, 0x30, 0x37, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4B, 0x40, 0x38, 0x44, 0x3B, 
	0x32, 0x1D, 0x37, 0x3E, 0x11, 0x37, 0x40, 0x1E, 0x3C, 0x40, 0x1A, 0x36, 0x40, 0x1D, 0x3C, 0x40, 
	0x1C, 0x3A, 0x40, 0x0F, 0x36, 0x40, 0x1E, 0x40, 0x40, 0x1E, 0x3D, 0x40, 0x1D, 0x31, 0x3A, 0x1D, 
	0x44, 0x43, 0x1D, 0x29, 0x34, 0x1D, 0x3C, 0x45, 0x1D, 0x2A, 0x34, 0x1E, 0x3D, 0x43, 0x0E, 0x37, 
	0x40, 0x23, 0x42, 0x42, 0x32, 0x3B, 0x36, 0x60, 0x54, 0x46, 0x5F, 0x55, 0x4A, 0x43, 0x4A, 0x46, 
	0x00, 0x0B, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x57, 
	0x50, 0x42, 0x5A, 0x52, 0x4B, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 
	0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5C, 0x53, 0x4B, 0x53, 0x4E, 0x4A, 0x27, 0x40, 0x42, 
	0x3E, 0x3D, 0x3E, 0x34, 0x3E, 0x3E, 0x2B, 0x42, 0x44, 0x4F, 0x49, 0x43, 0x64, 0x5C, 0x4B, 0x58, 
	0x50, 0x49, 0x54, 0x4C, 0x43, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 
	0x42, 0x49, 0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x24, 0x38, 0x3E, 0x19, 0x32, 0x3C, 
	0x1A, 0x32, 0x3A, 0x1A, 0x32, 0x3A, 0x13, 0x2F, 0x3A, 0x51, 0x43, 0x38, 0x4D, 0x42, 0x39, 0x35, 
	0x37, 0x2F, 0x35, 0x37, 0x2F, 0x4D, 0x42, 0x39, 0x50, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 
	0x38, 0x31, 0x2C, 0x29, 0x33, 0x33, 0x2A, 0x37, 0x2F, 0x2F, 0x33, 0x34, 0x2A, 0x22, 0x13, 0x18, 
	0x31, 0x32, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x28, 0x30, 0x29, 0x1F, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x23, 0x16, 0x1B, 0x31, 0x28, 0x1C, 0x30, 0x27, 0x1C, 0x30, 0x28, 
	0x1F, 0x31, 0x2F, 0x24, 0x25, 0x1A, 0x1C, 0x27, 0x1B, 0x1B, 0x28, 0x1A, 0x19, 0x25, 0x1E, 0x1E, 
	0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x24, 0x25, 0x29, 0x15, 0x38, 0x44, 0x28, 0x32, 0x31, 0x2F, 
	0x23, 0x1C, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1D, 0x27, 0x25, 0x24, 0x1D, 0x34, 0x3C, 0x51, 0x42, 
	0x3A, 0x2F, 0x47, 0x47, 0x0F, 0x30, 0x35, 0x14, 0x26, 0x25, 0x13, 0x26, 0x26, 0x18, 0x2A, 0x2E, 
	0x13, 0x26, 0x26, 0x16, 0x29, 0x2C, 0x15, 0x28, 0x2A, 0x0F, 0x26, 0x26, 0x26, 0x31, 0x33, 0x30, 
	0x2F, 0x25, 0x37, 0x38, 0x2F, 0x2C, 0x2C, 0x24, 0x39, 0x3A, 0x31, 0x2F, 0x2C, 0x26, 0x35, 0x34, 
	0x2C, 0x38, 0x3A, 0x30, 0x37, 0x2C, 0x2F, 0x3F, 0x3C, 0x33, 0x37, 0x37, 0x2F, 0x35, 0x37, 0x2F, 
	0x34, 0x36, 0x2E, 0x38, 0x38, 0x30, 0x34, 0x36, 0x2E, 0x3A, 0x3A, 0x31, 0x50, 0x44, 0x3B, 0x35, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x49, 0x3E, 
	0x34, 0x26, 0x3C, 0x42, 0x11, 0x36, 0x40, 0x19, 0x40, 0x40, 0x37, 0x42, 0x3F, 0x1B, 0x3C, 0x40, 
	0x1D, 0x36, 0x40, 0x1E, 0x3F, 0x40, 0x1E, 0x3D, 0x40, 0x0F, 0x38, 0x42, 0x1B, 0x31, 0x39, 0x1D, 
	0x31, 0x3A, 0x1D, 0x45, 0x44, 0x1E, 0x2A, 0x34, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x18, 0x34, 
	0x3C, 0x1A, 0x29, 0x34, 0x2B, 0x3B, 0x44, 0x65, 0x5A, 0x4B, 0x67, 0x5E, 0x57, 0x52, 0x4B, 0x42, 
	0x11, 0x08, 0x09, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x1A, 0x22, 0x1E, 0x84, 0x72, 0x63, 0x4B, 
	0x44, 0x43, 0x55, 0x4D, 0x44, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x5B, 0x53, 0x4B, 0x4C, 0x44, 0x3D, 0x58, 0x4F, 0x47, 0x4E, 0x3D, 0x34, 0x1C, 0x3F, 0x3F, 
	0x20, 0x49, 0x4E, 0x16, 0x37, 0x3F, 0x34, 0x3E, 0x39, 0x3F, 0x42, 0x44, 0x56, 0x4D, 0x45, 0x5C, 
	0x54, 0x4C, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x51, 0x49, 
	0x3F, 0x49, 0x3F, 0x37, 0x4B, 0x40, 0x37, 0x44, 0x3D, 0x33, 0x1C, 0x2A, 0x2C, 0x13, 0x2C, 0x30, 
	0x1E, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x19, 0x2E, 0x38, 0x44, 0x3C, 0x32, 0x4D, 0x43, 0x39, 0x36, 
	0x35, 0x2F, 0x37, 0x30, 0x30, 0x3C, 0x3B, 0x32, 0x33, 0x35, 0x2C, 0x35, 0x37, 0x2F, 0x51, 0x45, 
	0x3B, 0x33, 0x30, 0x2B, 0x38, 0x2F, 0x30, 0x39, 0x2F, 0x31, 0x38, 0x31, 0x30, 0x30, 0x32, 0x27, 
	0x30, 0x30, 0x27, 0x30, 0x29, 0x20, 0x30, 0x27, 0x1D, 0x30, 0x32, 0x29, 0x30, 0x31, 0x28, 0x30, 
	0x27, 0x1E, 0x31, 0x27, 0x1C, 0x31, 0x28, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x20, 0x1D, 0x30, 0x27, 
	0x1C, 0x30, 0x2A, 0x1F, 0x28, 0x22, 0x20, 0x25, 0x1A, 0x1C, 0x2A, 0x24, 0x20, 0x27, 0x1B, 0x1C, 
	0x25, 0x1E, 0x1E, 0x0F, 0x28, 0x28, 0x29, 0x27, 0x27, 0x0C, 0x27, 0x25, 0x28, 0x1E, 0x23, 0x08, 
	0x28, 0x29, 0x27, 0x19, 0x1A, 0x26, 0x1B, 0x1C, 0x28, 0x1A, 0x19, 0x14, 0x2F, 0x38, 0x2E, 0x37, 
	0x33, 0x1F, 0x33, 0x3D, 0x0F, 0x24, 0x23, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 
	0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 0x1A, 0x1B, 0x2A, 0x31, 0x2C, 0x2F, 
	0x2F, 0x25, 0x35, 0x35, 0x2C, 0x2E, 0x2E, 0x25, 0x39, 0x37, 0x31, 0x35, 0x2F, 0x2C, 0x38, 0x2F, 
	0x30, 0x38, 0x35, 0x30, 0x38, 0x2F, 0x30, 0x34, 0x30, 0x2B, 0x37, 0x38, 0x30, 0x35, 0x37, 0x2F, 
	0x51, 0x44, 0x3B, 0x34, 0x36, 0x2E, 0x4A, 0x42, 0x38, 0x30, 0x29, 0x2A, 0x44, 0x3D, 0x35, 0x36, 
	0x37, 0x2F, 0x38, 0x38, 0x30, 0x35, 0x36, 0x2E, 0x3A, 0x39, 0x31, 0x4D, 0x42, 0x39, 0x50, 0x42, 
	0x38, 0x25, 0x42, 0x42, 0x11, 0x37, 0x40, 0x16, 0x30, 0x3A, 0x27, 0x45, 0x48, 0x0F, 0x36, 0x3F, 
	0x1E, 0x37, 0x40, 0x1D, 0x45, 0x42, 0x1B, 0x2C, 0x37, 0x1B, 0x31, 0x39, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1E, 0x2F, 0x38, 0x0F, 0x3B, 0x44, 0x1B, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 
	0x38, 0x1A, 0x3B, 0x44, 0x2B, 0x39, 0x33, 0x51, 0x46, 0x3C, 0x59, 0x51, 0x49, 0x5E, 0x56, 0x4A, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x75, 0x6F, 0x60, 0x50, 
	0x47, 0x43, 0x58, 0x50, 0x48, 0x59, 0x51, 0x49, 0x66, 0x5E, 0x56, 0x58, 0x50, 0x48, 0x50, 0x47, 
	0x3C, 0x57, 0x4F, 0x46, 0x50, 0x48, 0x3D, 0x5C, 0x54, 0x4D, 0x19, 0x3D, 0x47, 0x1B, 0x3A, 0x3F, 
	0x1C, 0x40, 0x3E, 0x1C, 0x3B, 0x40, 0x1D, 0x35, 0x3D, 0x3B, 0x3E, 0x3F, 0x5E, 0x54, 0x46, 0x55, 
	0x4D, 0x46, 0x51, 0x49, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x42, 0x48, 0x3E, 
	0x35, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x45, 0x46, 0x3D, 0x32, 0x12, 0x29, 0x30, 0x18, 0x2A, 0x2E, 
	0x16, 0x29, 0x2C, 0x1D, 0x30, 0x38, 0x18, 0x2E, 0x38, 0x46, 0x3D, 0x33, 0x48, 0x3F, 0x37, 0x31, 
	0x2C, 0x29, 0x33, 0x2F, 0x2A, 0x35, 0x35, 0x2F, 0x53, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x33, 0x33, 0x2A, 0x24, 0x1B, 0x1B, 0x30, 0x32, 0x28, 
	0x30, 0x30, 0x27, 0x30, 0x32, 0x29, 0x30, 0x27, 0x1D, 0x30, 0x28, 0x1E, 0x30, 0x27, 0x1E, 0x31, 
	0x34, 0x2A, 0x23, 0x16, 0x1B, 0x32, 0x2A, 0x1D, 0x26, 0x1D, 0x1D, 0x32, 0x29, 0x1D, 0x30, 0x27, 
	0x1D, 0x30, 0x26, 0x1C, 0x31, 0x28, 0x1C, 0x32, 0x29, 0x1C, 0x25, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x27, 0x1C, 0x1C, 0x2B, 0x1A, 0x1A, 0x29, 0x23, 0x1F, 0x28, 0x1A, 0x1B, 0x2B, 0x20, 0x1D, 0x31, 
	0x2E, 0x25, 0x28, 0x22, 0x1F, 0x28, 0x22, 0x1F, 0x26, 0x1B, 0x1C, 0x2B, 0x20, 0x1C, 0x29, 0x2B, 
	0x29, 0x26, 0x31, 0x32, 0x28, 0x22, 0x1D, 0x0E, 0x27, 0x27, 0x14, 0x2A, 0x2E, 0x13, 0x26, 0x26, 
	0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x1C, 0x33, 0x3E, 0x32, 0x27, 0x20, 0x39, 0x33, 0x30, 0x35, 
	0x2F, 0x2C, 0x2E, 0x2F, 0x25, 0x31, 0x2F, 0x28, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 
	0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x34, 0x30, 0x3E, 0x3C, 0x33, 0x36, 0x38, 0x2F, 
	0x3C, 0x3A, 0x32, 0x35, 0x37, 0x2E, 0x4E, 0x43, 0x3A, 0x40, 0x3C, 0x34, 0x39, 0x38, 0x30, 0x3C, 
	0x3A, 0x32, 0x35, 0x36, 0x2E, 0x4E, 0x43, 0x3A, 0x4E, 0x43, 0x3A, 0x39, 0x38, 0x30, 0x3E, 0x38, 
	0x2F, 0x26, 0x43, 0x43, 0x11, 0x37, 0x40, 0x1C, 0x30, 0x38, 0x1A, 0x32, 0x3A, 0x11, 0x39, 0x42, 
	0x1B, 0x30, 0x38, 0x1B, 0x2E, 0x38, 0x38, 0x48, 0x44, 0x1B, 0x2B, 0x35, 0x1A, 0x33, 0x3B, 0x1D, 
	0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1E, 0x31, 0x39, 0x1D, 0x3B, 0x44, 0x1C, 0x2F, 0x38, 0x18, 0x3D, 
	0x42, 0x1B, 0x39, 0x3B, 0x3F, 0x48, 0x49, 0x4F, 0x45, 0x3F, 0x4F, 0x47, 0x3F, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x76, 0x6C, 0x5D, 0x58, 
	0x50, 0x45, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x57, 0x4F, 0x47, 0x4F, 0x46, 0x3A, 0x47, 0x4A, 
	0x4A, 0x4A, 0x40, 0x3C, 0x5D, 0x53, 0x4B, 0x3E, 0x42, 0x3C, 0x0E, 0x38, 0x3F, 0x1D, 0x3D, 0x3F, 
	0x1D, 0x47, 0x48, 0x1D, 0x40, 0x3F, 0x18, 0x39, 0x42, 0x43, 0x44, 0x3F, 0x66, 0x5C, 0x4B, 0x53, 
	0x4B, 0x43, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x49, 0x3E, 
	0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 0x37, 0x45, 0x42, 0x3A, 0x0B, 0x20, 0x1E, 0x1E, 0x31, 0x3B, 
	0x1D, 0x30, 0x38, 0x1A, 0x33, 0x3B, 0x1A, 0x2E, 0x38, 0x37, 0x37, 0x2C, 0x4B, 0x42, 0x38, 0x32, 
	0x2E, 0x2A, 0x2C, 0x30, 0x24, 0x39, 0x2E, 0x31, 0x30, 0x33, 0x29, 0x3A, 0x34, 0x32, 0x38, 0x36, 
	0x30, 0x38, 0x39, 0x30, 0x38, 0x39, 0x30, 0x39, 0x35, 0x32, 0x2F, 0x28, 0x1D, 0x30, 0x24, 0x1A, 
	0x30, 0x28, 0x1F, 0x30, 0x27, 0x1E, 0x30, 0x33, 0x2A, 0x30, 0x2C, 0x24, 0x30, 0x26, 0x1C, 0x31, 
	0x27, 0x1B, 0x32, 0x29, 0x1D, 0x23, 0x18, 0x1D, 0x33, 0x2A, 0x1C, 0x26, 0x1D, 0x1D, 0x30, 0x27, 
	0x1C, 0x31, 0x2F, 0x25, 0x23, 0x16, 0x1B, 0x2C, 0x2A, 0x25, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 
	0x2B, 0x1A, 0x1A, 0x0B, 0x29, 0x29, 0x26, 0x1C, 0x1C, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x32, 
	0x2F, 0x26, 0x2A, 0x1E, 0x1D, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x26, 0x19, 
	0x1A, 0x31, 0x2C, 0x23, 0x1E, 0x34, 0x3C, 0x2C, 0x1E, 0x1B, 0x2A, 0x27, 0x27, 0x12, 0x2A, 0x2E, 
	0x14, 0x2A, 0x2E, 0x0F, 0x26, 0x25, 0x1D, 0x2A, 0x35, 0x31, 0x2E, 0x23, 0x2F, 0x30, 0x26, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3A, 0x35, 0x32, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x31, 0x39, 0x38, 
	0x31, 0x38, 0x3B, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x31, 0x2F, 0x38, 0x32, 0x30, 
	0x37, 0x39, 0x2F, 0x36, 0x2F, 0x2F, 0x48, 0x40, 0x37, 0x4D, 0x43, 0x39, 0x4E, 0x43, 0x3A, 0x48, 
	0x3F, 0x37, 0x32, 0x35, 0x2C, 0x4D, 0x42, 0x39, 0x39, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x38, 0x37, 
	0x2E, 0x2C, 0x3D, 0x37, 0x11, 0x37, 0x42, 0x12, 0x39, 0x42, 0x1B, 0x30, 0x38, 0x1E, 0x3A, 0x43, 
	0x1D, 0x2C, 0x35, 0x1D, 0x2E, 0x36, 0x1A, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1D, 0x2E, 0x36, 0x1D, 
	0x3B, 0x44, 0x1D, 0x3B, 0x44, 0x1D, 0x2C, 0x35, 0x1C, 0x30, 0x38, 0x1D, 0x3E, 0x43, 0x42, 0x42, 
	0x3E, 0x3F, 0x4B, 0x4E, 0x54, 0x48, 0x3E, 0x4E, 0x45, 0x40, 0x4D, 0x45, 0x3F, 0x5A, 0x52, 0x48, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1E, 0x6F, 0x6B, 0x63, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x55, 0x4D, 0x45, 0x4C, 0x43, 0x3B, 0x4C, 0x4F, 
	0x4C, 0x5E, 0x55, 0x4C, 0x57, 0x4E, 0x46, 0x40, 0x3C, 0x35, 0x0E, 0x34, 0x3F, 0x1D, 0x44, 0x42, 
	0x1D, 0x28, 0x34, 0x1D, 0x45, 0x42, 0x1C, 0x2E, 0x38, 0x1B, 0x30, 0x38, 0x4B, 0x3F, 0x35, 0x53, 
	0x4B, 0x40, 0x50, 0x48, 0x40, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x40, 0x4B, 0x42, 0x3F, 0x49, 0x3F, 
	0x36, 0x4A, 0x40, 0x37, 0x4D, 0x42, 0x38, 0x2C, 0x3A, 0x38, 0x18, 0x32, 0x3D, 0x1D, 0x2F, 0x37, 
	0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x18, 0x2E, 0x38, 0x40, 0x3B, 0x31, 0x36, 0x37, 0x2F, 0x35, 
	0x32, 0x2C, 0x39, 0x2F, 0x31, 0x39, 0x30, 0x31, 0x2E, 0x30, 0x25, 0x27, 0x20, 0x1E, 0x31, 0x30, 
	0x28, 0x37, 0x31, 0x2F, 0x33, 0x34, 0x2A, 0x37, 0x32, 0x2F, 0x2F, 0x31, 0x27, 0x30, 0x32, 0x2A, 
	0x31, 0x26, 0x1B, 0x30, 0x27, 0x1C, 0x29, 0x1E, 0x1A, 0x26, 0x1B, 0x1B, 0x32, 0x2A, 0x1D, 0x23, 
	0x18, 0x1D, 0x31, 0x28, 0x1D, 0x31, 0x28, 0x1C, 0x29, 0x23, 0x1F, 0x27, 0x1C, 0x1B, 0x32, 0x29, 
	0x1C, 0x27, 0x1C, 0x1B, 0x32, 0x30, 0x24, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 
	0x0B, 0x29, 0x29, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0B, 0x28, 0x29, 0x2A, 
	0x18, 0x19, 0x08, 0x29, 0x2A, 0x2E, 0x27, 0x22, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1B, 
	0x1C, 0x28, 0x22, 0x1F, 0x2C, 0x26, 0x1F, 0x28, 0x22, 0x1F, 0x2C, 0x29, 0x23, 0x27, 0x19, 0x1A, 
	0x2F, 0x20, 0x1A, 0x23, 0x23, 0x22, 0x2F, 0x2A, 0x22, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 
	0x30, 0x27, 0x30, 0x30, 0x27, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x2C, 0x2F, 0x24, 0x2C, 0x2E, 
	0x24, 0x36, 0x31, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x31, 0x30, 0x38, 0x39, 0x30, 
	0x37, 0x32, 0x2F, 0x36, 0x30, 0x2F, 0x30, 0x2C, 0x28, 0x36, 0x32, 0x2F, 0x37, 0x38, 0x2C, 0x45, 
	0x37, 0x34, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x3A, 0x39, 0x31, 0x37, 0x37, 0x2F, 0x39, 0x38, 
	0x2F, 0x2A, 0x37, 0x36, 0x0F, 0x38, 0x42, 0x13, 0x39, 0x42, 0x18, 0x34, 0x3C, 0x1E, 0x31, 0x39, 
	0x1D, 0x3A, 0x43, 0x1D, 0x3A, 0x43, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 0x37, 0x1A, 0x2B, 0x31, 0x1D, 
	0x2F, 0x37, 0x1D, 0x2C, 0x35, 0x1A, 0x3B, 0x44, 0x14, 0x33, 0x3C, 0x2A, 0x34, 0x37, 0x68, 0x5C, 
	0x4A, 0x5B, 0x51, 0x45, 0x4D, 0x45, 0x3F, 0x48, 0x3D, 0x40, 0x50, 0x47, 0x3F, 0x4C, 0x48, 0x3D, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1C, 0x23, 0x1F, 0x75, 0x6B, 0x5B, 0x5D, 
	0x55, 0x4D, 0x59, 0x51, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x4E, 0x45, 0x3D, 0x4E, 0x4B, 
	0x45, 0x4F, 0x47, 0x3C, 0x5B, 0x52, 0x4B, 0x45, 0x3C, 0x31, 0x18, 0x28, 0x35, 0x1D, 0x44, 0x44, 
	0x1A, 0x2F, 0x39, 0x1E, 0x3E, 0x42, 0x1E, 0x32, 0x3A, 0x0C, 0x39, 0x43, 0x2A, 0x31, 0x32, 0x57, 
	0x4D, 0x42, 0x47, 0x3C, 0x40, 0x54, 0x4C, 0x40, 0x48, 0x3E, 0x3F, 0x49, 0x3F, 0x36, 0x4A, 0x40, 
	0x37, 0x4A, 0x40, 0x45, 0x47, 0x3E, 0x34, 0x28, 0x31, 0x32, 0x1C, 0x2F, 0x39, 0x1D, 0x30, 0x38, 
	0x16, 0x28, 0x2A, 0x1D, 0x30, 0x39, 0x1D, 0x33, 0x3B, 0x4C, 0x40, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2E, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x2F, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x2F, 0x2F, 0x26, 0x2F, 0x2F, 0x26, 0x30, 0x32, 0x27, 0x31, 0x28, 0x1E, 0x31, 0x2A, 0x1F, 
	0x23, 0x18, 0x1C, 0x32, 0x2B, 0x1F, 0x31, 0x34, 0x2A, 0x31, 0x2E, 0x24, 0x23, 0x18, 0x1C, 0x33, 
	0x2B, 0x1D, 0x27, 0x1D, 0x1C, 0x31, 0x2A, 0x1F, 0x31, 0x34, 0x29, 0x32, 0x34, 0x29, 0x27, 0x1E, 
	0x1E, 0x25, 0x1A, 0x1B, 0x32, 0x35, 0x29, 0x2B, 0x28, 0x24, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x0D, 0x28, 0x28, 0x36, 0x27, 0x20, 0x27, 0x1D, 0x1D, 0x28, 0x19, 0x1A, 0x35, 0x35, 0x29, 0x2A, 
	0x25, 0x22, 0x2A, 0x1F, 0x1E, 0x2A, 0x1E, 0x1D, 0x33, 0x37, 0x2B, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 
	0x25, 0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x24, 0x25, 0x19, 0x1B, 0x29, 0x23, 0x20, 0x27, 0x1C, 0x1B, 
	0x31, 0x29, 0x1E, 0x30, 0x32, 0x27, 0x38, 0x30, 0x30, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 
	0x30, 0x26, 0x2F, 0x2F, 0x26, 0x3B, 0x35, 0x33, 0x2C, 0x2F, 0x24, 0x3A, 0x35, 0x32, 0x39, 0x37, 
	0x31, 0x38, 0x31, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x31, 0x2E, 0x37, 0x39, 0x30, 
	0x3D, 0x3B, 0x32, 0x4A, 0x42, 0x38, 0x30, 0x2C, 0x28, 0x3C, 0x35, 0x2F, 0x15, 0x2E, 0x3A, 0x1D, 
	0x2E, 0x34, 0x30, 0x34, 0x2F, 0x4F, 0x43, 0x39, 0x47, 0x3E, 0x36, 0x36, 0x37, 0x2F, 0x35, 0x37, 
	0x2F, 0x3C, 0x38, 0x2C, 0x14, 0x37, 0x42, 0x19, 0x2C, 0x32, 0x1E, 0x30, 0x38, 0x16, 0x29, 0x2B, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2E, 0x36, 0x1D, 0x3C, 0x42, 0x1A, 0x2A, 0x30, 0x1D, 0x38, 0x42, 0x1D, 
	0x2F, 0x37, 0x1A, 0x32, 0x3A, 0x1D, 0x2C, 0x35, 0x1B, 0x2C, 0x36, 0x2C, 0x32, 0x36, 0x65, 0x5B, 
	0x4D, 0x58, 0x50, 0x46, 0x49, 0x40, 0x3F, 0x49, 0x3F, 0x3B, 0x65, 0x5C, 0x53, 0x3F, 0x4A, 0x47, 
	0x12, 0x09, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x23, 0x1E, 0x74, 0x6D, 0x68, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4A, 0x58, 0x50, 0x48, 0x5C, 0x53, 
	0x4B, 0x5C, 0x54, 0x4C, 0x5C, 0x53, 0x4B, 0x52, 0x51, 0x4E, 0x1E, 0x3F, 0x42, 0x15, 0x26, 0x2E, 
	0x1E, 0x2C, 0x36, 0x12, 0x38, 0x42, 0x1A, 0x38, 0x43, 0x12, 0x37, 0x42, 0x32, 0x3A, 0x3A, 0x53, 
	0x49, 0x3E, 0x4B, 0x42, 0x3B, 0x54, 0x4C, 0x42, 0x42, 0x3A, 0x32, 0x4A, 0x40, 0x38, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x37, 0x4D, 0x40, 0x38, 0x33, 0x3E, 0x39, 0x12, 0x27, 0x2B, 0x1B, 0x33, 0x3C, 
	0x1B, 0x33, 0x3C, 0x15, 0x28, 0x2C, 0x2A, 0x33, 0x34, 0x4A, 0x3F, 0x36, 0x36, 0x38, 0x2F, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x30, 
	0x27, 0x31, 0x32, 0x28, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1C, 0x28, 0x1E, 0x1C, 
	0x33, 0x2B, 0x1D, 0x24, 0x19, 0x1C, 0x27, 0x1E, 0x1E, 0x32, 0x29, 0x1C, 0x28, 0x1E, 0x1D, 0x24, 
	0x1A, 0x1C, 0x25, 0x1A, 0x1B, 0x25, 0x19, 0x1B, 0x24, 0x18, 0x1A, 0x28, 0x1F, 0x1E, 0x32, 0x35, 
	0x29, 0x25, 0x1A, 0x1B, 0x28, 0x20, 0x1F, 0x32, 0x2B, 0x1F, 0x26, 0x1B, 0x1C, 0x29, 0x1B, 0x1B, 
	0x11, 0x28, 0x28, 0x0E, 0x27, 0x28, 0x28, 0x1B, 0x1B, 0x09, 0x2A, 0x2B, 0x2A, 0x1E, 0x1D, 0x32, 
	0x35, 0x29, 0x2C, 0x25, 0x20, 0x08, 0x29, 0x2A, 0x27, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x29, 0x23, 
	0x1F, 0x29, 0x23, 0x20, 0x24, 0x18, 0x1A, 0x2C, 0x2A, 0x25, 0x25, 0x19, 0x1A, 0x32, 0x36, 0x2A, 
	0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2E, 0x2F, 0x25, 0x3A, 0x38, 0x32, 0x34, 0x2F, 0x2B, 0x30, 0x2E, 0x27, 0x39, 0x37, 
	0x31, 0x38, 0x3A, 0x30, 0x38, 0x2F, 0x30, 0x36, 0x2F, 0x2E, 0x2B, 0x2E, 0x23, 0x36, 0x31, 0x2E, 
	0x35, 0x35, 0x2F, 0x50, 0x45, 0x3B, 0x37, 0x33, 0x2F, 0x30, 0x2E, 0x2F, 0x1B, 0x31, 0x3B, 0x15, 
	0x29, 0x2C, 0x1E, 0x34, 0x3E, 0x3B, 0x3D, 0x35, 0x4E, 0x42, 0x39, 0x33, 0x36, 0x2E, 0x51, 0x44, 
	0x3B, 0x3F, 0x3A, 0x30, 0x1A, 0x2B, 0x36, 0x16, 0x3C, 0x45, 0x1F, 0x30, 0x39, 0x14, 0x2C, 0x30, 
	0x1D, 0x35, 0x3D, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x1D, 0x38, 0x42, 0x1D, 
	0x2E, 0x36, 0x1D, 0x37, 0x3F, 0x1D, 0x3A, 0x43, 0x1B, 0x39, 0x43, 0x27, 0x2F, 0x2E, 0x5F, 0x53, 
	0x4A, 0x5B, 0x53, 0x45, 0x4F, 0x47, 0x3F, 0x4E, 0x46, 0x3B, 0x5F, 0x57, 0x4F, 0x53, 0x4D, 0x43, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x11, 0x08, 0x09, 0x19, 0x20, 0x1D, 0x86, 0x7A, 0x68, 0x56, 
	0x4E, 0x47, 0x58, 0x50, 0x48, 0x4C, 0x44, 0x3C, 0x53, 0x4B, 0x45, 0x5B, 0x53, 0x4B, 0x52, 0x4A, 
	0x40, 0x50, 0x48, 0x3D, 0x51, 0x49, 0x3E, 0x50, 0x46, 0x3E, 0x51, 0x4F, 0x4B, 0x2C, 0x3E, 0x42, 
	0x14, 0x39, 0x42, 0x1A, 0x32, 0x38, 0x4A, 0x3C, 0x30, 0x24, 0x31, 0x31, 0x3F, 0x49, 0x4B, 0x4F, 
	0x46, 0x3A, 0x47, 0x3C, 0x35, 0x53, 0x4B, 0x42, 0x55, 0x4D, 0x44, 0x49, 0x3E, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4B, 0x3F, 0x35, 0x1F, 0x31, 0x38, 0x16, 0x29, 0x2C, 
	0x1C, 0x34, 0x3E, 0x15, 0x29, 0x2E, 0x2F, 0x33, 0x2E, 0x4F, 0x43, 0x3A, 0x35, 0x37, 0x2F, 0x35, 
	0x2E, 0x2C, 0x38, 0x30, 0x30, 0x38, 0x30, 0x30, 0x39, 0x30, 0x31, 0x2F, 0x30, 0x26, 0x30, 0x32, 
	0x27, 0x23, 0x13, 0x18, 0x32, 0x34, 0x29, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x26, 0x1A, 0x1B, 0x32, 0x35, 0x2A, 0x23, 0x18, 0x1B, 0x32, 0x29, 0x1C, 0x32, 
	0x2B, 0x1F, 0x32, 0x35, 0x2A, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x32, 0x34, 
	0x29, 0x25, 0x1A, 0x1B, 0x25, 0x1A, 0x1C, 0x32, 0x28, 0x1B, 0x25, 0x1B, 0x1C, 0x2B, 0x1A, 0x1A, 
	0x0C, 0x28, 0x29, 0x25, 0x1E, 0x1E, 0x29, 0x23, 0x1F, 0x28, 0x1B, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 
	0x1F, 0x1E, 0x33, 0x36, 0x2A, 0x29, 0x16, 0x19, 0x34, 0x31, 0x24, 0x28, 0x20, 0x1F, 0x26, 0x1B, 
	0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x28, 0x20, 0x1F, 0x26, 0x1C, 0x1C, 0x25, 0x18, 0x1A, 
	0x32, 0x34, 0x29, 0x30, 0x32, 0x27, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x2E, 0x2F, 0x25, 0x2E, 0x30, 0x25, 0x2F, 0x2F, 0x26, 0x36, 0x31, 
	0x2E, 0x38, 0x39, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x38, 0x31, 0x3A, 0x38, 0x32, 0x2F, 0x2C, 0x26, 
	0x36, 0x34, 0x2E, 0x36, 0x38, 0x2F, 0x39, 0x31, 0x30, 0x31, 0x32, 0x30, 0x15, 0x2A, 0x30, 0x19, 
	0x2A, 0x2E, 0x14, 0x28, 0x2C, 0x2F, 0x2B, 0x2C, 0x4F, 0x44, 0x3A, 0x33, 0x36, 0x2E, 0x35, 0x36, 
	0x2E, 0x3E, 0x3E, 0x37, 0x16, 0x31, 0x3B, 0x1C, 0x2B, 0x31, 0x14, 0x27, 0x27, 0x14, 0x2B, 0x30, 
	0x1E, 0x3C, 0x46, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x16, 0x28, 0x2B, 0x1B, 
	0x34, 0x3D, 0x1D, 0x2E, 0x36, 0x1D, 0x31, 0x39, 0x1C, 0x39, 0x42, 0x1D, 0x31, 0x38, 0x42, 0x49, 
	0x47, 0x69, 0x5E, 0x4C, 0x4E, 0x46, 0x3D, 0x59, 0x51, 0x4A, 0x5C, 0x54, 0x4B, 0x58, 0x50, 0x4A, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x65, 0x56, 
	0x4F, 0x47, 0x5B, 0x53, 0x4B, 0x53, 0x4B, 0x45, 0x4D, 0x45, 0x3D, 0x5C, 0x54, 0x4C, 0x56, 0x4E, 
	0x45, 0x5A, 0x52, 0x4A, 0x4E, 0x46, 0x3F, 0x50, 0x48, 0x40, 0x56, 0x4D, 0x43, 0x53, 0x48, 0x3F, 
	0x50, 0x49, 0x44, 0x4F, 0x4A, 0x45, 0x50, 0x46, 0x42, 0x43, 0x3F, 0x43, 0x4A, 0x3D, 0x33, 0x50, 
	0x48, 0x42, 0x53, 0x4B, 0x42, 0x53, 0x4B, 0x42, 0x48, 0x3D, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x3B, 0x36, 0x2A, 0x11, 0x27, 0x29, 
	0x15, 0x28, 0x29, 0x15, 0x2A, 0x30, 0x33, 0x38, 0x33, 0x50, 0x44, 0x3A, 0x3A, 0x39, 0x31, 0x33, 
	0x30, 0x2B, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x36, 0x30, 0x2E, 0x2C, 0x30, 0x24, 0x35, 0x30, 
	0x2C, 0x30, 0x32, 0x27, 0x30, 0x32, 0x28, 0x28, 0x1F, 0x1E, 0x25, 0x1A, 0x1B, 0x33, 0x36, 0x2A, 
	0x33, 0x36, 0x2A, 0x25, 0x18, 0x1A, 0x32, 0x35, 0x29, 0x28, 0x1F, 0x1E, 0x25, 0x1B, 0x1C, 0x26, 
	0x1B, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1F, 0x1E, 0x28, 0x22, 0x1F, 0x32, 0x36, 0x2A, 0x2A, 0x20, 0x1E, 0x0B, 0x28, 0x29, 
	0x35, 0x2F, 0x25, 0x28, 0x1A, 0x1A, 0x2B, 0x28, 0x23, 0x26, 0x1B, 0x1C, 0x28, 0x1B, 0x1B, 0x28, 
	0x1E, 0x1C, 0x29, 0x1E, 0x1E, 0x09, 0x29, 0x2A, 0x26, 0x1F, 0x1D, 0x33, 0x2F, 0x23, 0x28, 0x1A, 
	0x1B, 0x09, 0x2A, 0x2B, 0x28, 0x19, 0x1A, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x25, 0x19, 0x1B, 0x24, 0x16, 0x1A, 0x2F, 0x32, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x35, 0x30, 0x2C, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x25, 0x31, 0x2E, 
	0x28, 0x39, 0x3A, 0x31, 0x2F, 0x2E, 0x26, 0x30, 0x2E, 0x27, 0x36, 0x31, 0x2E, 0x39, 0x37, 0x31, 
	0x35, 0x2C, 0x2C, 0x38, 0x3B, 0x30, 0x39, 0x2E, 0x30, 0x31, 0x36, 0x31, 0x0E, 0x23, 0x20, 0x19, 
	0x37, 0x43, 0x1A, 0x33, 0x3C, 0x1C, 0x34, 0x3C, 0x4A, 0x3F, 0x35, 0x4E, 0x43, 0x3A, 0x3A, 0x39, 
	0x31, 0x39, 0x36, 0x2B, 0x0F, 0x36, 0x42, 0x19, 0x35, 0x3E, 0x15, 0x25, 0x25, 0x1C, 0x34, 0x3D, 
	0x14, 0x2B, 0x2F, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x14, 
	0x27, 0x27, 0x1F, 0x31, 0x3B, 0x1A, 0x2A, 0x30, 0x1D, 0x3A, 0x43, 0x1B, 0x2C, 0x36, 0x1A, 0x39, 
	0x3E, 0x4B, 0x46, 0x42, 0x62, 0x59, 0x49, 0x54, 0x4C, 0x45, 0x4F, 0x47, 0x3D, 0x58, 0x50, 0x47, 
	0x0F, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x61, 0x57, 
	0x50, 0x48, 0x58, 0x50, 0x48, 0x5D, 0x55, 0x4D, 0x51, 0x48, 0x3E, 0x56, 0x4E, 0x46, 0x50, 0x48, 
	0x3E, 0x50, 0x48, 0x3E, 0x4F, 0x47, 0x3F, 0x46, 0x3C, 0x3A, 0x53, 0x4B, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x3F, 0x52, 0x4A, 0x40, 0x51, 0x48, 0x40, 0x50, 0x48, 0x42, 0x52, 
	0x4A, 0x40, 0x52, 0x4A, 0x40, 0x4B, 0x42, 0x39, 0x49, 0x3F, 0x36, 0x4A, 0x40, 0x45, 0x4A, 0x40, 
	0x37, 0x44, 0x3D, 0x35, 0x4E, 0x42, 0x38, 0x4B, 0x42, 0x38, 0x45, 0x3D, 0x34, 0x13, 0x29, 0x31, 
	0x12, 0x25, 0x23, 0x18, 0x2C, 0x33, 0x23, 0x1D, 0x1A, 0x3C, 0x39, 0x2E, 0x50, 0x45, 0x3B, 0x4A, 
	0x42, 0x38, 0x34, 0x2F, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x39, 0x2F, 0x31, 0x37, 0x30, 
	0x2F, 0x2F, 0x31, 0x27, 0x30, 0x2A, 0x20, 0x31, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x25, 0x18, 0x1A, 
	0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 0x28, 0x1F, 0x1E, 0x32, 0x35, 0x29, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x32, 
	0x28, 0x32, 0x2F, 0x23, 0x25, 0x1A, 0x1C, 0x25, 0x18, 0x1B, 0x2A, 0x1D, 0x1A, 0x0D, 0x29, 0x29, 
	0x26, 0x1C, 0x1C, 0x13, 0x26, 0x26, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0B, 0x29, 0x2A, 0x34, 
	0x27, 0x1E, 0x32, 0x2B, 0x1F, 0x27, 0x20, 0x1D, 0x0C, 0x27, 0x28, 0x34, 0x34, 0x28, 0x26, 0x1A, 
	0x1B, 0x29, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1C, 0x31, 0x27, 0x1B, 0x2F, 0x31, 0x27, 0x35, 0x30, 0x2C, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2E, 0x2F, 
	0x25, 0x39, 0x37, 0x31, 0x39, 0x37, 0x31, 0x34, 0x31, 0x2B, 0x2C, 0x2E, 0x24, 0x39, 0x3A, 0x31, 
	0x35, 0x34, 0x2C, 0x35, 0x2C, 0x2C, 0x38, 0x2F, 0x30, 0x37, 0x33, 0x29, 0x15, 0x2B, 0x32, 0x11, 
	0x29, 0x2A, 0x15, 0x29, 0x2E, 0x1D, 0x2E, 0x35, 0x37, 0x37, 0x2E, 0x48, 0x3F, 0x37, 0x4F, 0x43, 
	0x39, 0x4B, 0x3F, 0x36, 0x1E, 0x32, 0x37, 0x18, 0x35, 0x3E, 0x18, 0x36, 0x3E, 0x1B, 0x33, 0x3C, 
	0x15, 0x27, 0x27, 0x11, 0x24, 0x20, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x39, 0x18, 0x2A, 0x2F, 0x12, 
	0x24, 0x22, 0x11, 0x2A, 0x2A, 0x1B, 0x32, 0x3B, 0x1D, 0x39, 0x42, 0x1D, 0x2F, 0x37, 0x15, 0x2B, 
	0x33, 0x34, 0x43, 0x44, 0x6B, 0x60, 0x4C, 0x5F, 0x57, 0x4B, 0x58, 0x50, 0x48, 0x5A, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x78, 0x69, 0x4B, 
	0x44, 0x42, 0x4B, 0x43, 0x3B, 0x51, 0x49, 0x3E, 0x4B, 0x49, 0x44, 0x56, 0x4E, 0x45, 0x55, 0x4D, 
	0x44, 0x5C, 0x54, 0x4C, 0x57, 0x4F, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 0x52, 0x4A, 0x40, 
	0x52, 0x4A, 0x40, 0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 0x4B, 0x40, 0x53, 
	0x4B, 0x42, 0x54, 0x4C, 0x43, 0x48, 0x3E, 0x36, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 
	0x38, 0x49, 0x3F, 0x36, 0x22, 0x31, 0x33, 0x4C, 0x3D, 0x36, 0x50, 0x44, 0x3A, 0x1A, 0x2A, 0x2A, 
	0x1B, 0x2F, 0x36, 0x13, 0x26, 0x26, 0x1C, 0x32, 0x3C, 0x16, 0x2F, 0x3B, 0x39, 0x2C, 0x2A, 0x37, 
	0x36, 0x30, 0x4C, 0x43, 0x39, 0x33, 0x33, 0x2B, 0x36, 0x2F, 0x2E, 0x39, 0x36, 0x31, 0x31, 0x30, 
	0x29, 0x30, 0x29, 0x1E, 0x30, 0x26, 0x1B, 0x31, 0x29, 0x1E, 0x32, 0x35, 0x2A, 0x33, 0x36, 0x2A, 
	0x25, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x24, 0x18, 0x1A, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x31, 0x33, 
	0x28, 0x27, 0x1E, 0x1E, 0x28, 0x19, 0x1A, 0x31, 0x30, 0x27, 0x32, 0x2F, 0x24, 0x26, 0x20, 0x1D, 
	0x09, 0x29, 0x2A, 0x35, 0x26, 0x20, 0x2B, 0x28, 0x23, 0x28, 0x1A, 0x1B, 0x0E, 0x29, 0x29, 0x0C, 
	0x27, 0x29, 0x32, 0x25, 0x1B, 0x20, 0x1C, 0x1E, 0x0E, 0x27, 0x28, 0x32, 0x2F, 0x26, 0x26, 0x1B, 
	0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2A, 0x27, 0x1E, 0x1E, 
	0x31, 0x2F, 0x25, 0x30, 0x25, 0x1B, 0x30, 0x31, 0x28, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 
	0x2E, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x2E, 0x28, 0x39, 0x37, 0x31, 0x36, 0x35, 0x2E, 0x2C, 0x2F, 0x24, 0x39, 0x33, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x36, 0x30, 0x2A, 0x16, 0x23, 0x26, 0x1A, 
	0x2F, 0x36, 0x24, 0x29, 0x2B, 0x39, 0x31, 0x2B, 0x38, 0x38, 0x30, 0x39, 0x38, 0x2E, 0x2A, 0x37, 
	0x36, 0x4E, 0x42, 0x36, 0x2C, 0x34, 0x33, 0x12, 0x25, 0x26, 0x1F, 0x30, 0x39, 0x1A, 0x2B, 0x31, 
	0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1A, 0x2C, 0x33, 0x1F, 
	0x32, 0x3C, 0x18, 0x2A, 0x2E, 0x1E, 0x2F, 0x38, 0x1D, 0x3B, 0x44, 0x1A, 0x2B, 0x31, 0x1A, 0x2B, 
	0x31, 0x18, 0x39, 0x43, 0x4D, 0x3F, 0x35, 0x63, 0x5B, 0x4B, 0x5A, 0x52, 0x4B, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x70, 0x62, 0x58, 
	0x51, 0x49, 0x53, 0x4B, 0x42, 0x56, 0x4E, 0x46, 0x50, 0x47, 0x3D, 0x58, 0x50, 0x48, 0x5B, 0x53, 
	0x4B, 0x56, 0x4E, 0x46, 0x50, 0x48, 0x3E, 0x58, 0x50, 0x47, 0x4F, 0x47, 0x3F, 0x4F, 0x47, 0x40, 
	0x52, 0x4A, 0x40, 0x53, 0x4B, 0x40, 0x47, 0x3D, 0x40, 0x49, 0x3D, 0x36, 0x4C, 0x43, 0x39, 0x48, 
	0x3E, 0x36, 0x49, 0x3E, 0x37, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x45, 0x3D, 0x33, 0x11, 0x29, 0x34, 0x1B, 0x2E, 0x32, 0x50, 0x43, 0x37, 0x32, 0x31, 0x2F, 
	0x1B, 0x30, 0x3A, 0x1E, 0x31, 0x3A, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 0x2B, 0x2B, 0x22, 
	0x1E, 0x1C, 0x38, 0x37, 0x30, 0x39, 0x34, 0x31, 0x2C, 0x2F, 0x24, 0x35, 0x2F, 0x2C, 0x30, 0x32, 
	0x28, 0x24, 0x18, 0x1B, 0x32, 0x28, 0x1B, 0x24, 0x19, 0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x25, 0x18, 0x1A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x32, 0x34, 
	0x29, 0x2F, 0x26, 0x22, 0x0D, 0x28, 0x28, 0x15, 0x23, 0x25, 0x30, 0x25, 0x1B, 0x2C, 0x23, 0x1C, 
	0x20, 0x1C, 0x1E, 0x31, 0x33, 0x29, 0x29, 0x23, 0x1F, 0x26, 0x1C, 0x1C, 0x2A, 0x1B, 0x1B, 0x1B, 
	0x23, 0x23, 0x26, 0x19, 0x1B, 0x32, 0x2E, 0x25, 0x0B, 0x28, 0x29, 0x28, 0x1A, 0x1B, 0x26, 0x1C, 
	0x1C, 0x2A, 0x24, 0x20, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x27, 0x1E, 0x1F, 0x33, 0x30, 0x24, 
	0x23, 0x18, 0x1B, 0x31, 0x26, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x31, 0x27, 0x26, 
	0x1B, 0x1C, 0x30, 0x31, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x33, 0x30, 0x2A, 0x2F, 0x30, 
	0x26, 0x2F, 0x30, 0x26, 0x31, 0x30, 0x28, 0x37, 0x30, 0x2F, 0x39, 0x2F, 0x31, 0x38, 0x33, 0x30, 
	0x38, 0x38, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x36, 0x2E, 0x2C, 0x30, 0x33, 0x2C, 0x15, 
	0x2E, 0x3B, 0x31, 0x34, 0x2F, 0x39, 0x39, 0x30, 0x3A, 0x39, 0x30, 0x1D, 0x2F, 0x32, 0x18, 0x2F, 
	0x39, 0x2B, 0x2E, 0x32, 0x1E, 0x35, 0x3D, 0x16, 0x29, 0x2C, 0x16, 0x36, 0x3E, 0x1E, 0x30, 0x39, 
	0x1A, 0x2C, 0x32, 0x1E, 0x31, 0x3B, 0x16, 0x29, 0x2C, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x39, 0x16, 
	0x29, 0x2C, 0x14, 0x27, 0x27, 0x1B, 0x2E, 0x35, 0x1D, 0x2F, 0x38, 0x1D, 0x30, 0x39, 0x1D, 0x2F, 
	0x38, 0x1B, 0x36, 0x3F, 0x1B, 0x35, 0x3C, 0x48, 0x3D, 0x32, 0x5A, 0x52, 0x4A, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x85, 0x71, 0x63, 0x55, 
	0x4E, 0x40, 0x5A, 0x52, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 
	0x4B, 0x4F, 0x47, 0x3D, 0x52, 0x4A, 0x40, 0x50, 0x48, 0x3E, 0x52, 0x4A, 0x40, 0x53, 0x4A, 0x3F, 
	0x53, 0x4B, 0x42, 0x52, 0x4A, 0x40, 0x4F, 0x46, 0x3F, 0x3E, 0x4A, 0x4D, 0x4B, 0x3D, 0x33, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4B, 0x40, 
	0x38, 0x3C, 0x39, 0x30, 0x2A, 0x32, 0x32, 0x0D, 0x23, 0x22, 0x23, 0x30, 0x3A, 0x2C, 0x2C, 0x20, 
	0x19, 0x2E, 0x36, 0x18, 0x2A, 0x2E, 0x1E, 0x31, 0x3A, 0x1E, 0x31, 0x3B, 0x15, 0x2A, 0x2E, 0x13, 
	0x2F, 0x39, 0x3B, 0x3A, 0x2F, 0x38, 0x2E, 0x30, 0x38, 0x30, 0x30, 0x2E, 0x30, 0x26, 0x31, 0x29, 
	0x1E, 0x25, 0x19, 0x1B, 0x32, 0x36, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x26, 0x1A, 0x1B, 0x32, 0x34, 0x29, 0x33, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 0x1B, 0x1C, 0x29, 0x20, 
	0x1E, 0x27, 0x24, 0x22, 0x12, 0x27, 0x27, 0x0D, 0x28, 0x28, 0x2C, 0x1D, 0x1B, 0x29, 0x1F, 0x1D, 
	0x26, 0x1B, 0x1C, 0x32, 0x2B, 0x1F, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x32, 0x36, 0x2A, 0x2A, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 
	0x1C, 0x26, 0x1C, 0x1C, 0x26, 0x1C, 0x1C, 0x28, 0x1F, 0x1C, 0x32, 0x28, 0x1C, 0x29, 0x20, 0x1C, 
	0x27, 0x1D, 0x1C, 0x30, 0x28, 0x1E, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x30, 
	0x31, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x30, 0x2E, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x2F, 0x30, 
	0x26, 0x31, 0x32, 0x28, 0x29, 0x24, 0x20, 0x30, 0x2B, 0x27, 0x37, 0x33, 0x2F, 0x39, 0x3A, 0x31, 
	0x38, 0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2E, 0x30, 0x39, 0x3A, 0x30, 0x2C, 0x32, 0x30, 0x3C, 
	0x39, 0x2F, 0x39, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x34, 0x2C, 0x14, 0x20, 0x24, 0x1D, 0x31, 
	0x3A, 0x15, 0x2B, 0x32, 0x34, 0x3A, 0x36, 0x15, 0x2B, 0x34, 0x1B, 0x33, 0x3C, 0x14, 0x2C, 0x30, 
	0x1F, 0x30, 0x3A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x30, 0x1B, 0x2E, 0x34, 0x1D, 0x30, 0x38, 0x1D, 
	0x30, 0x39, 0x1E, 0x31, 0x3B, 0x13, 0x26, 0x26, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 
	0x33, 0x1B, 0x2C, 0x36, 0x1A, 0x36, 0x3F, 0x39, 0x3E, 0x40, 0x59, 0x50, 0x46, 0x5D, 0x55, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1B, 0x22, 0x1E, 0x7E, 0x70, 0x61, 0x5C, 
	0x54, 0x4E, 0x58, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5C, 0x54, 0x4C, 0x50, 0x48, 0x3E, 0x5B, 0x53, 0x4B, 0x4E, 0x44, 0x3E, 0x4F, 0x4B, 0x44, 
	0x4A, 0x3D, 0x34, 0x54, 0x4C, 0x43, 0x4B, 0x42, 0x38, 0x4D, 0x40, 0x3E, 0x3B, 0x4E, 0x51, 0x4B, 
	0x3E, 0x35, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x43, 0x4A, 0x40, 0x37, 0x4C, 0x42, 
	0x39, 0x45, 0x3D, 0x34, 0x2B, 0x35, 0x36, 0x0F, 0x24, 0x23, 0x14, 0x28, 0x29, 0x16, 0x2B, 0x32, 
	0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 0x18, 0x2A, 0x2F, 0x1A, 0x2E, 0x34, 0x1F, 0x2C, 0x35, 0x2F, 
	0x1E, 0x13, 0x36, 0x38, 0x2F, 0x37, 0x32, 0x2F, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x20, 
	0x1F, 0x26, 0x1B, 0x1C, 0x28, 0x1F, 0x1E, 0x33, 0x37, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1A, 0x1B, 0x32, 0x2B, 0x1F, 0x2A, 0x1F, 
	0x1E, 0x0C, 0x28, 0x28, 0x11, 0x27, 0x27, 0x33, 0x27, 0x20, 0x11, 0x27, 0x27, 0x28, 0x1B, 0x1C, 
	0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1B, 0x1C, 0x2A, 0x1C, 0x1A, 0x33, 0x29, 0x1C, 0x27, 0x1D, 0x1C, 0x29, 0x23, 
	0x20, 0x25, 0x1A, 0x1B, 0x28, 0x22, 0x20, 0x28, 0x20, 0x1F, 0x31, 0x2A, 0x1F, 0x31, 0x28, 0x1C, 
	0x31, 0x27, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 0x30, 0x2C, 0x2F, 
	0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x36, 0x31, 
	0x2E, 0x27, 0x1F, 0x1E, 0x26, 0x1B, 0x1C, 0x25, 0x1A, 0x1B, 0x2A, 0x26, 0x20, 0x2F, 0x29, 0x26, 
	0x39, 0x37, 0x31, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x39, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x2F, 0x2F, 0x37, 0x35, 0x14, 0x31, 
	0x3D, 0x16, 0x2C, 0x38, 0x43, 0x3C, 0x31, 0x2E, 0x2A, 0x27, 0x18, 0x2E, 0x36, 0x11, 0x23, 0x1E, 
	0x18, 0x36, 0x3F, 0x1C, 0x33, 0x3D, 0x15, 0x27, 0x28, 0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1A, 
	0x2C, 0x33, 0x1D, 0x30, 0x39, 0x1E, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x12, 0x25, 0x24, 0x1D, 0x30, 
	0x3A, 0x25, 0x38, 0x3D, 0x4E, 0x40, 0x34, 0x4F, 0x44, 0x3F, 0x4F, 0x47, 0x44, 0x5D, 0x54, 0x48, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x73, 0x64, 0x59, 
	0x52, 0x4C, 0x65, 0x5D, 0x49, 0x59, 0x51, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 0x4A, 0x66, 0x5E, 
	0x4A, 0x5A, 0x52, 0x4B, 0x51, 0x49, 0x3E, 0x54, 0x4B, 0x40, 0x39, 0x34, 0x28, 0x22, 0x33, 0x37, 
	0x33, 0x39, 0x37, 0x50, 0x44, 0x3A, 0x49, 0x3E, 0x36, 0x52, 0x4A, 0x43, 0x49, 0x3D, 0x34, 0x4A, 
	0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4A, 0x40, 0x3D, 0x4B, 0x40, 0x38, 0x3A, 0x39, 
	0x31, 0x38, 0x38, 0x2F, 0x26, 0x30, 0x31, 0x1D, 0x32, 0x3D, 0x14, 0x27, 0x28, 0x19, 0x2B, 0x30, 
	0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x18, 0x2A, 0x2F, 0x16, 0x2B, 0x30, 0x1E, 0x24, 0x1F, 0x3C, 
	0x34, 0x33, 0x39, 0x35, 0x31, 0x31, 0x2F, 0x28, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x25, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x36, 0x2A, 0x28, 0x19, 0x1A, 0x12, 0x25, 0x26, 0x33, 0x34, 0x29, 0x2A, 0x25, 
	0x20, 0x26, 0x23, 0x20, 0x0C, 0x29, 0x29, 0x28, 0x1A, 0x1B, 0x28, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1B, 0x1C, 0x32, 0x2F, 0x26, 0x08, 0x27, 0x29, 0x26, 0x1F, 0x1D, 0x32, 0x2F, 0x24, 0x27, 0x1F, 
	0x1F, 0x32, 0x30, 0x24, 0x32, 0x2B, 0x1F, 0x27, 0x1E, 0x1E, 0x2B, 0x29, 0x24, 0x25, 0x1A, 0x1C, 
	0x2A, 0x20, 0x1B, 0x30, 0x31, 0x28, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x35, 
	0x30, 0x2C, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x32, 
	0x27, 0x25, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 0x29, 0x26, 0x20, 
	0x3A, 0x34, 0x32, 0x38, 0x3A, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 
	0x38, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 0x3C, 0x35, 0x37, 0x2F, 0x39, 0x38, 0x30, 0x35, 0x31, 
	0x25, 0x2A, 0x3B, 0x3D, 0x4C, 0x40, 0x37, 0x40, 0x3C, 0x32, 0x28, 0x2F, 0x32, 0x1E, 0x31, 0x3C, 
	0x18, 0x34, 0x3C, 0x19, 0x36, 0x40, 0x12, 0x24, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3A, 0x16, 
	0x29, 0x2C, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x1D, 0x30, 
	0x3A, 0x23, 0x37, 0x3B, 0x5A, 0x4E, 0x48, 0x5C, 0x54, 0x49, 0x4F, 0x47, 0x3F, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x20, 0x1D, 0x84, 0x78, 0x68, 0x63, 
	0x59, 0x4C, 0x57, 0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x59, 0x51, 
	0x4A, 0x5B, 0x53, 0x4B, 0x52, 0x49, 0x3E, 0x4E, 0x49, 0x45, 0x1F, 0x37, 0x3E, 0x1A, 0x2E, 0x37, 
	0x13, 0x2F, 0x3A, 0x3E, 0x3D, 0x34, 0x48, 0x3E, 0x35, 0x4E, 0x46, 0x3C, 0x4F, 0x47, 0x40, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x37, 0x4C, 0x42, 0x39, 0x33, 0x36, 
	0x2E, 0x37, 0x38, 0x30, 0x40, 0x39, 0x2F, 0x13, 0x29, 0x2F, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 
	0x19, 0x2B, 0x31, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1A, 0x2E, 0x35, 0x14, 0x27, 0x24, 0x3B, 
	0x30, 0x31, 0x33, 0x2E, 0x2A, 0x2F, 0x30, 0x26, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x33, 0x35, 0x29, 0x1B, 0x1F, 0x20, 0x16, 0x24, 0x25, 0x33, 0x25, 0x19, 0x33, 0x32, 
	0x2B, 0x32, 0x34, 0x28, 0x2B, 0x1D, 0x1A, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 
	0x1A, 0x1B, 0x32, 0x35, 0x29, 0x33, 0x2B, 0x24, 0x08, 0x27, 0x2A, 0x34, 0x2A, 0x1E, 0x25, 0x1B, 
	0x1C, 0x25, 0x1A, 0x1C, 0x28, 0x20, 0x1F, 0x33, 0x36, 0x2A, 0x27, 0x1F, 0x1F, 0x25, 0x1B, 0x1C, 
	0x32, 0x28, 0x1B, 0x31, 0x33, 0x29, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x3A, 
	0x30, 0x32, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2B, 0x27, 0x23, 0x26, 0x19, 0x1A, 0x29, 0x23, 0x20, 0x26, 0x1B, 0x1C, 0x2A, 0x26, 0x22, 
	0x34, 0x35, 0x2B, 0x38, 0x39, 0x30, 0x38, 0x2C, 0x30, 0x38, 0x3A, 0x30, 0x35, 0x30, 0x2C, 0x38, 
	0x30, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x38, 0x38, 0x30, 0x36, 0x37, 0x2F, 0x4D, 0x42, 
	0x39, 0x34, 0x39, 0x33, 0x3D, 0x39, 0x31, 0x32, 0x3B, 0x35, 0x31, 0x24, 0x22, 0x0D, 0x24, 0x20, 
	0x1C, 0x34, 0x3D, 0x19, 0x2A, 0x2F, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x30, 0x1D, 0x30, 0x39, 0x1F, 
	0x32, 0x3C, 0x11, 0x24, 0x22, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2F, 0x1A, 0x2C, 0x32, 0x16, 0x29, 
	0x2C, 0x15, 0x2B, 0x37, 0x53, 0x4D, 0x4A, 0x67, 0x5E, 0x4B, 0x53, 0x4B, 0x43, 0x48, 0x45, 0x3A, 
	0x11, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1E, 0x24, 0x1F, 0x7D, 0x75, 0x68, 0x58, 
	0x50, 0x49, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 0x4B, 0x5B, 0x53, 
	0x4B, 0x59, 0x51, 0x49, 0x4F, 0x47, 0x3F, 0x52, 0x47, 0x42, 0x29, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x16, 0x3A, 0x43, 0x14, 0x2F, 0x3A, 0x27, 0x31, 0x31, 0x54, 0x4A, 0x3E, 0x4F, 0x47, 0x3C, 0x49, 
	0x3F, 0x37, 0x4A, 0x40, 0x38, 0x4A, 0x40, 0x38, 0x4C, 0x42, 0x39, 0x4A, 0x40, 0x37, 0x49, 0x3F, 
	0x37, 0x36, 0x37, 0x2E, 0x4B, 0x40, 0x35, 0x13, 0x29, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x13, 0x26, 0x25, 0x18, 0x2B, 0x30, 0x20, 0x2A, 0x33, 0x31, 0x32, 0x2F, 0x39, 
	0x2F, 0x30, 0x39, 0x38, 0x31, 0x2F, 0x2F, 0x26, 0x31, 0x32, 0x28, 0x25, 0x19, 0x1B, 0x27, 0x1D, 
	0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x25, 
	0x1A, 0x1B, 0x2B, 0x1F, 0x1D, 0x0F, 0x28, 0x28, 0x11, 0x27, 0x28, 0x27, 0x22, 0x1D, 0x31, 0x32, 
	0x28, 0x2A, 0x25, 0x22, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x25, 0x19, 0x1B, 0x30, 0x30, 0x27, 0x28, 0x18, 0x19, 0x32, 0x2B, 0x1F, 0x25, 0x1B, 
	0x1C, 0x26, 0x1A, 0x1B, 0x26, 0x1B, 0x1C, 0x2A, 0x1F, 0x1E, 0x33, 0x2A, 0x1C, 0x26, 0x1B, 0x1D, 
	0x25, 0x19, 0x1B, 0x25, 0x19, 0x1B, 0x31, 0x2B, 0x22, 0x30, 0x29, 0x20, 0x2F, 0x31, 0x27, 0x3A, 
	0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x2A, 0x24, 0x1F, 0x25, 0x34, 0x34, 0x2C, 0x27, 0x22, 0x25, 0x18, 0x1A, 0x2A, 0x26, 0x22, 
	0x35, 0x33, 0x2C, 0x38, 0x39, 0x30, 0x38, 0x31, 0x30, 0x38, 0x2E, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x2C, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x34, 0x36, 
	0x2E, 0x36, 0x36, 0x2E, 0x35, 0x36, 0x2E, 0x50, 0x43, 0x39, 0x3C, 0x3F, 0x38, 0x13, 0x28, 0x2F, 
	0x1F, 0x31, 0x3B, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3B, 0x18, 
	0x2A, 0x2F, 0x12, 0x25, 0x23, 0x1C, 0x35, 0x40, 0x15, 0x28, 0x29, 0x12, 0x25, 0x23, 0x1F, 0x32, 
	0x3D, 0x0D, 0x25, 0x29, 0x56, 0x4A, 0x47, 0x62, 0x5A, 0x4A, 0x5B, 0x53, 0x4C, 0x53, 0x4D, 0x44, 
	0x0F, 0x09, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3A, 0x2E, 0x2A, 0x8D, 0x7B, 0x6C, 0x59, 
	0x51, 0x47, 0x58, 0x50, 0x49, 0x4F, 0x47, 0x3C, 0x50, 0x48, 0x3E, 0x50, 0x48, 0x3E, 0x50, 0x48, 
	0x3E, 0x52, 0x49, 0x3E, 0x4C, 0x44, 0x3C, 0x51, 0x47, 0x43, 0x27, 0x31, 0x31, 0x1B, 0x2E, 0x37, 
	0x1D, 0x3A, 0x43, 0x1A, 0x31, 0x39, 0x14, 0x31, 0x3C, 0x3C, 0x34, 0x2A, 0x4C, 0x42, 0x39, 0x49, 
	0x3F, 0x37, 0x4B, 0x40, 0x38, 0x49, 0x3F, 0x36, 0x33, 0x36, 0x2B, 0x51, 0x43, 0x3E, 0x45, 0x3A, 
	0x33, 0x2C, 0x36, 0x34, 0x28, 0x31, 0x32, 0x16, 0x2B, 0x31, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x30, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x0F, 0x26, 0x25, 0x24, 0x20, 0x1C, 0x3A, 
	0x31, 0x32, 0x39, 0x32, 0x31, 0x2E, 0x2F, 0x25, 0x30, 0x31, 0x27, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x34, 
	0x37, 0x2A, 0x27, 0x23, 0x20, 0x12, 0x27, 0x27, 0x12, 0x26, 0x27, 0x23, 0x29, 0x25, 0x32, 0x32, 
	0x28, 0x31, 0x33, 0x28, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 
	0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x18, 0x1A, 0x11, 0x26, 0x27, 0x31, 0x2F, 0x27, 0x28, 0x1D, 
	0x1B, 0x34, 0x37, 0x2B, 0x27, 0x20, 0x1D, 0x09, 0x29, 0x2A, 0x28, 0x1A, 0x1B, 0x26, 0x1A, 0x1B, 
	0x34, 0x38, 0x2B, 0x24, 0x16, 0x1A, 0x32, 0x34, 0x29, 0x31, 0x33, 0x29, 0x29, 0x24, 0x20, 0x34, 
	0x31, 0x2B, 0x37, 0x30, 0x2F, 0x2F, 0x30, 0x26, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x2F, 0x30, 
	0x26, 0x32, 0x31, 0x26, 0x1D, 0x32, 0x3A, 0x2F, 0x2A, 0x23, 0x32, 0x33, 0x27, 0x2A, 0x24, 0x1F, 
	0x28, 0x24, 0x1F, 0x3A, 0x38, 0x32, 0x38, 0x37, 0x30, 0x38, 0x2F, 0x30, 0x38, 0x2F, 0x30, 0x38, 
	0x3A, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 0x2F, 0x50, 0x44, 
	0x3B, 0x4E, 0x43, 0x3A, 0x33, 0x36, 0x2E, 0x4C, 0x42, 0x39, 0x4B, 0x40, 0x36, 0x1C, 0x2B, 0x2E, 
	0x18, 0x2B, 0x30, 0x12, 0x25, 0x24, 0x1D, 0x30, 0x38, 0x19, 0x2B, 0x30, 0x18, 0x2A, 0x2F, 0x16, 
	0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x25, 0x24, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 0x27, 
	0x28, 0x27, 0x35, 0x39, 0x5F, 0x55, 0x46, 0x5B, 0x53, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x09, 0x20, 0x23, 0x1F, 0x82, 0x75, 0x63, 0x56, 
	0x4F, 0x48, 0x4E, 0x46, 0x3B, 0x5C, 0x54, 0x4D, 0x52, 0x4A, 0x40, 0x59, 0x51, 0x49, 0x5B, 0x52, 
	0x4A, 0x4D, 0x4F, 0x4D, 0x53, 0x4A, 0x3F, 0x53, 0x4A, 0x3E, 0x35, 0x3A, 0x37, 0x1A, 0x2C, 0x37, 
	0x1D, 0x2F, 0x37, 0x1D, 0x2F, 0x37, 0x19, 0x32, 0x3B, 0x1F, 0x2E, 0x36, 0x45, 0x36, 0x32, 0x53, 
	0x4B, 0x42, 0x4A, 0x3F, 0x35, 0x2C, 0x38, 0x36, 0x27, 0x2F, 0x2F, 0x22, 0x3F, 0x45, 0x28, 0x30, 
	0x2F, 0x16, 0x2C, 0x35, 0x16, 0x2A, 0x30, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x31, 0x1F, 0x32, 0x3D, 
	0x16, 0x29, 0x2B, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x16, 0x29, 0x2B, 0x1A, 0x33, 0x3F, 0x3A, 
	0x2E, 0x29, 0x39, 0x30, 0x31, 0x34, 0x30, 0x2B, 0x2F, 0x30, 0x26, 0x31, 0x33, 0x28, 0x26, 0x1A, 
	0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x28, 
	0x19, 0x1A, 0x0F, 0x28, 0x28, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x1E, 0x20, 0x22, 0x2B, 0x22, 
	0x1D, 0x32, 0x33, 0x29, 0x1C, 0x16, 0x18, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x27, 
	0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x38, 0x2B, 0x26, 0x16, 0x19, 0x25, 0x1A, 0x1C, 0x25, 0x1A, 
	0x1B, 0x27, 0x16, 0x19, 0x09, 0x28, 0x29, 0x27, 0x20, 0x1D, 0x27, 0x1C, 0x1C, 0x26, 0x1A, 0x1B, 
	0x25, 0x19, 0x1B, 0x2C, 0x2A, 0x25, 0x24, 0x18, 0x1B, 0x24, 0x18, 0x1A, 0x27, 0x1E, 0x1D, 0x2F, 
	0x31, 0x26, 0x3A, 0x30, 0x32, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x39, 0x30, 
	0x31, 0x30, 0x32, 0x27, 0x27, 0x1B, 0x1A, 0x32, 0x32, 0x27, 0x23, 0x2F, 0x32, 0x26, 0x35, 0x36, 
	0x29, 0x23, 0x1E, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x31, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x39, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x50, 0x44, 0x3B, 0x33, 0x36, 0x2E, 0x4D, 0x42, 0x39, 0x48, 0x3E, 0x35, 0x1D, 0x30, 0x38, 
	0x11, 0x25, 0x26, 0x13, 0x26, 0x29, 0x12, 0x25, 0x24, 0x16, 0x29, 0x2B, 0x1A, 0x2C, 0x32, 0x13, 
	0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x25, 0x1A, 0x2C, 0x33, 0x16, 0x29, 0x2B, 0x11, 0x25, 
	0x25, 0x1D, 0x2C, 0x2A, 0x6C, 0x5A, 0x4D, 0x60, 0x59, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x55, 0x4B, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x20, 0x1D, 0x87, 0x78, 0x67, 0x5C, 
	0x54, 0x4D, 0x5A, 0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5C, 0x53, 0x4B, 0x5A, 0x52, 0x49, 0x4B, 0x42, 
	0x37, 0x33, 0x46, 0x47, 0x55, 0x4D, 0x49, 0x52, 0x44, 0x39, 0x30, 0x3C, 0x36, 0x1A, 0x3D, 0x45, 
	0x1D, 0x2E, 0x37, 0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1A, 0x2F, 0x38, 0x25, 0x31, 0x32, 0x5A, 
	0x4E, 0x43, 0x20, 0x2B, 0x29, 0x16, 0x31, 0x3C, 0x1C, 0x2F, 0x39, 0x1B, 0x31, 0x3A, 0x1C, 0x30, 
	0x3A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x19, 0x2B, 0x31, 0x12, 0x25, 0x23, 0x12, 0x25, 0x23, 
	0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x29, 0x2B, 0x23, 
	0x1E, 0x1A, 0x38, 0x2E, 0x2B, 0x31, 0x30, 0x29, 0x2F, 0x30, 0x26, 0x30, 0x32, 0x27, 0x25, 0x19, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x28, 0x2F, 0x24, 
	0x1D, 0x32, 0x35, 0x2A, 0x26, 0x1B, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1C, 0x1D, 0x29, 0x1E, 0x1B, 0x26, 
	0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x28, 0x1C, 0x1A, 0x32, 0x37, 0x2B, 0x32, 0x27, 0x1A, 0x32, 0x35, 
	0x2A, 0x32, 0x34, 0x29, 0x34, 0x33, 0x28, 0x32, 0x34, 0x2A, 0x25, 0x18, 0x1A, 0x34, 0x38, 0x2B, 
	0x25, 0x19, 0x1B, 0x32, 0x29, 0x1C, 0x32, 0x28, 0x1C, 0x32, 0x2F, 0x24, 0x31, 0x33, 0x28, 0x2F, 
	0x30, 0x26, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x2E, 0x30, 0x25, 0x30, 0x30, 0x27, 0x30, 0x33, 
	0x27, 0x29, 0x23, 0x20, 0x32, 0x32, 0x26, 0x31, 0x30, 0x26, 0x30, 0x2F, 0x24, 0x39, 0x2F, 0x2F, 
	0x2F, 0x32, 0x26, 0x34, 0x2F, 0x2B, 0x38, 0x37, 0x30, 0x38, 0x39, 0x2F, 0x38, 0x2C, 0x30, 0x38, 
	0x39, 0x30, 0x38, 0x39, 0x30, 0x38, 0x32, 0x30, 0x38, 0x39, 0x30, 0x38, 0x38, 0x30, 0x35, 0x37, 
	0x2F, 0x35, 0x37, 0x2F, 0x36, 0x37, 0x2F, 0x48, 0x3F, 0x37, 0x50, 0x45, 0x3B, 0x4D, 0x3F, 0x34, 
	0x28, 0x42, 0x46, 0x32, 0x42, 0x45, 0x11, 0x25, 0x28, 0x13, 0x26, 0x25, 0x16, 0x29, 0x2C, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x1B, 0x2E, 0x34, 0x13, 0x26, 0x25, 0x13, 0x26, 0x26, 0x11, 0x24, 
	0x24, 0x22, 0x37, 0x3E, 0x66, 0x57, 0x48, 0x63, 0x5C, 0x4A, 0x59, 0x51, 0x4A, 0x5D, 0x54, 0x4C, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x02, 0x00, 0x02, 0x1A, 0x22, 0x1E, 0x84, 0x75, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x4D, 0x4B, 0x45, 0x57, 0x4D, 0x4B, 0x2B, 0x26, 
	0x1C, 0x15, 0x2F, 0x3A, 0x23, 0x38, 0x3C, 0x2A, 0x32, 0x32, 0x19, 0x31, 0x3C, 0x1D, 0x2E, 0x36, 
	0x1D, 0x30, 0x38, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1B, 0x2F, 0x38, 0x29, 0x33, 0x33, 0x53, 
	0x45, 0x3A, 0x13, 0x22, 0x25, 0x1B, 0x34, 0x3E, 0x16, 0x29, 0x2B, 0x1E, 0x30, 0x39, 0x18, 0x2A, 
	0x2F, 0x12, 0x25, 0x23, 0x19, 0x2B, 0x30, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3B, 
	0x15, 0x28, 0x29, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x11, 0x27, 0x26, 0x18, 
	0x26, 0x2A, 0x3A, 0x31, 0x30, 0x2E, 0x30, 0x25, 0x38, 0x30, 0x30, 0x35, 0x31, 0x2C, 0x29, 0x24, 
	0x1F, 0x32, 0x35, 0x2A, 0x28, 0x1F, 0x1E, 0x26, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x0C, 
	0x2A, 0x2A, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x27, 0x27, 0x24, 0x1D, 
	0x1E, 0x26, 0x19, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x33, 0x37, 0x2B, 0x28, 
	0x1E, 0x1B, 0x26, 0x1C, 0x1D, 0x26, 0x1C, 0x1D, 0x25, 0x18, 0x1A, 0x26, 0x1B, 0x1C, 0x27, 0x1A, 
	0x1B, 0x26, 0x1A, 0x1B, 0x26, 0x19, 0x1B, 0x30, 0x26, 0x1B, 0x25, 0x1A, 0x1B, 0x25, 0x18, 0x1A, 
	0x27, 0x1D, 0x1D, 0x25, 0x1A, 0x1D, 0x26, 0x1B, 0x1D, 0x24, 0x19, 0x1B, 0x2B, 0x26, 0x22, 0x30, 
	0x31, 0x27, 0x2E, 0x30, 0x25, 0x37, 0x30, 0x2F, 0x37, 0x30, 0x2F, 0x30, 0x33, 0x27, 0x23, 0x13, 
	0x18, 0x33, 0x34, 0x27, 0x1C, 0x31, 0x39, 0x24, 0x2F, 0x31, 0x2C, 0x33, 0x2F, 0x30, 0x30, 0x25, 
	0x28, 0x22, 0x1E, 0x34, 0x30, 0x2B, 0x38, 0x31, 0x30, 0x35, 0x3C, 0x36, 0x38, 0x39, 0x2F, 0x38, 
	0x39, 0x30, 0x38, 0x30, 0x30, 0x38, 0x3A, 0x30, 0x38, 0x32, 0x30, 0x35, 0x37, 0x2F, 0x52, 0x45, 
	0x3C, 0x33, 0x36, 0x2E, 0x39, 0x36, 0x30, 0x35, 0x32, 0x2A, 0x39, 0x40, 0x3F, 0x42, 0x3B, 0x30, 
	0x31, 0x35, 0x2C, 0x57, 0x55, 0x51, 0x2B, 0x31, 0x30, 0x0E, 0x24, 0x24, 0x13, 0x26, 0x26, 0x14, 
	0x27, 0x27, 0x13, 0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x13, 0x26, 0x26, 0x14, 0x28, 
	0x2A, 0x24, 0x37, 0x3C, 0x51, 0x4C, 0x4A, 0x64, 0x5C, 0x49, 0x5B, 0x53, 0x4B, 0x5C, 0x54, 0x45, 
	0x0E, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x22, 0x1E, 0x87, 0x79, 0x67, 0x55, 
	0x4E, 0x47, 0x5A, 0x52, 0x4A, 0x5B, 0x53, 0x4A, 0x4D, 0x49, 0x46, 0x4C, 0x3F, 0x36, 0x1D, 0x2F, 
	0x36, 0x1C, 0x2F, 0x38, 0x1C, 0x2F, 0x38, 0x15, 0x29, 0x2E, 0x16, 0x29, 0x2B, 0x1E, 0x31, 0x3A, 
	0x1D, 0x2F, 0x37, 0x1A, 0x33, 0x3B, 0x1D, 0x2F, 0x37, 0x1B, 0x2F, 0x38, 0x2A, 0x33, 0x33, 0x48, 
	0x40, 0x36, 0x1B, 0x1C, 0x1C, 0x18, 0x2B, 0x31, 0x18, 0x2A, 0x2F, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 
	0x2F, 0x15, 0x28, 0x2A, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2F, 0x18, 0x2A, 0x2E, 0x1D, 0x30, 0x39, 
	0x1E, 0x31, 0x3B, 0x1A, 0x2C, 0x32, 0x13, 0x26, 0x25, 0x19, 0x2E, 0x34, 0x1F, 0x1E, 0x1E, 0x14, 
	0x28, 0x26, 0x34, 0x30, 0x29, 0x2F, 0x30, 0x27, 0x2F, 0x30, 0x26, 0x2F, 0x30, 0x26, 0x30, 0x31, 
	0x28, 0x30, 0x2A, 0x20, 0x32, 0x36, 0x2A, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x26, 0x1A, 0x1B, 0x34, 0x38, 0x2B, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x2B, 
	0x1A, 0x1A, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0E, 0x28, 
	0x28, 0x30, 0x24, 0x1B, 0x26, 0x1C, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 0x1B, 0x1B, 0x28, 0x1B, 0x1B, 0x28, 0x22, 0x1F, 0x2B, 
	0x1E, 0x1B, 0x28, 0x1B, 0x1B, 0x29, 0x1E, 0x1B, 0x34, 0x37, 0x2A, 0x24, 0x25, 0x23, 0x12, 0x27, 
	0x27, 0x29, 0x1B, 0x1B, 0x19, 0x24, 0x24, 0x26, 0x19, 0x1B, 0x33, 0x36, 0x2A, 0x33, 0x36, 0x2A, 
	0x24, 0x19, 0x1B, 0x33, 0x2A, 0x1C, 0x25, 0x1A, 0x1D, 0x33, 0x2A, 0x1C, 0x24, 0x18, 0x1B, 0x32, 
	0x34, 0x29, 0x30, 0x2E, 0x24, 0x2E, 0x30, 0x26, 0x36, 0x32, 0x2E, 0x28, 0x23, 0x1F, 0x33, 0x36, 
	0x2A, 0x27, 0x1E, 0x1D, 0x2C, 0x25, 0x1F, 0x32, 0x32, 0x27, 0x33, 0x2F, 0x28, 0x28, 0x30, 0x2C, 
	0x32, 0x30, 0x28, 0x36, 0x30, 0x2E, 0x38, 0x2F, 0x30, 0x38, 0x2E, 0x30, 0x35, 0x2E, 0x2C, 0x38, 
	0x2F, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x31, 0x2C, 0x38, 0x3A, 0x30, 0x38, 0x38, 0x30, 0x33, 0x36, 
	0x2E, 0x53, 0x45, 0x3C, 0x2E, 0x33, 0x2E, 0x23, 0x28, 0x2B, 0x1A, 0x30, 0x3B, 0x11, 0x29, 0x30, 
	0x2C, 0x28, 0x29, 0x5E, 0x52, 0x45, 0x51, 0x47, 0x3A, 0x19, 0x30, 0x38, 0x12, 0x25, 0x24, 0x13, 
	0x26, 0x26, 0x18, 0x2A, 0x2E, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x12, 0x25, 
	0x24, 0x1F, 0x34, 0x3D, 0x4F, 0x43, 0x39, 0x68, 0x5F, 0x55, 0x65, 0x5D, 0x4A, 0x5C, 0x54, 0x4C, 
	0x0D, 0x07, 0x08, 0x00, 0x00, 0x00, 0x0F, 0x08, 0x08, 0x19, 0x22, 0x1D, 0x8B, 0x7C, 0x6A, 0x5C, 
	0x54, 0x4D, 0x59, 0x51, 0x49, 0x5B, 0x52, 0x4A, 0x52, 0x52, 0x4D, 0x06, 0x23, 0x2B, 0x0F, 0x24, 
	0x20, 0x1E, 0x31, 0x3B, 0x1E, 0x31, 0x3A, 0x18, 0x2A, 0x2E, 0x1F, 0x32, 0x3C, 0x18, 0x2A, 0x2E, 
	0x1E, 0x31, 0x3A, 0x1D, 0x2F, 0x37, 0x1D, 0x30, 0x38, 0x1C, 0x2F, 0x38, 0x23, 0x32, 0x38, 0x3F, 
	0x3A, 0x2C, 0x14, 0x2B, 0x32, 0x12, 0x25, 0x24, 0x19, 0x2B, 0x31, 0x1E, 0x31, 0x3B, 0x19, 0x2B, 
	0x30, 0x19, 0x2B, 0x30, 0x1F, 0x32, 0x3C, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x29, 0x1E, 0x31, 0x3B, 
	0x19, 0x2B, 0x30, 0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x12, 0x26, 0x26, 0x20, 0x26, 0x24, 0x3E, 
	0x30, 0x2E, 0x2F, 0x30, 0x26, 0x30, 0x2C, 0x24, 0x30, 0x30, 0x27, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x28, 0x27, 0x1C, 0x1B, 0x25, 0x1A, 0x1B, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x11, 0x28, 
	0x28, 0x28, 0x1B, 0x1B, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x11, 0x28, 0x28, 0x15, 0x26, 0x26, 0x2A, 0x1A, 0x1A, 0x0E, 
	0x28, 0x29, 0x0E, 0x29, 0x29, 0x28, 0x1B, 0x1B, 0x26, 0x1A, 0x1B, 0x27, 0x1C, 0x1C, 0x28, 0x1C, 
	0x1C, 0x27, 0x1D, 0x1D, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x26, 0x1A, 0x1B, 0x25, 0x1A, 0x1B, 
	0x29, 0x23, 0x20, 0x28, 0x22, 0x20, 0x26, 0x1B, 0x1C, 0x28, 0x22, 0x20, 0x29, 0x23, 0x20, 0x25, 
	0x19, 0x1B, 0x27, 0x1F, 0x1E, 0x31, 0x32, 0x28, 0x29, 0x23, 0x1F, 0x32, 0x34, 0x29, 0x25, 0x18, 
	0x1A, 0x26, 0x1C, 0x1C, 0x26, 0x1B, 0x1C, 0x27, 0x1E, 0x1E, 0x30, 0x31, 0x27, 0x2F, 0x2F, 0x25, 
	0x37, 0x32, 0x2F, 0x38, 0x2F, 0x30, 0x38, 0x30, 0x30, 0x35, 0x2F, 0x2C, 0x38, 0x3B, 0x30, 0x38, 
	0x2F, 0x30, 0x38, 0x30, 0x30, 0x38, 0x2F, 0x30, 0x35, 0x30, 0x2C, 0x38, 0x38, 0x30, 0x38, 0x38, 
	0x30, 0x38, 0x37, 0x2C, 0x1E, 0x34, 0x3E, 0x13, 0x27, 0x29, 0x15, 0x28, 0x2A, 0x12, 0x25, 0x24, 
	0x12, 0x29, 0x30, 0x34, 0x36, 0x32, 0x4D, 0x40, 0x38, 0x46, 0x42, 0x39, 0x14, 0x29, 0x31, 0x13, 
	0x26, 0x26, 0x13, 0x26, 0x26, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x26, 
	0x26, 0x13, 0x26, 0x27, 0x18, 0x33, 0x3D, 0x52, 0x46, 0x42, 0x58, 0x50, 0x49, 0x59, 0x51, 0x45, 
	0x1A, 0x15, 0x13, 0x08, 0x09, 0x09, 0x07, 0x07, 0x07, 0x1B, 0x1F, 0x1D, 0x57, 0x4E, 0x46, 0x5A, 
	0x52, 0x4A, 0x5A, 0x52, 0x4A, 0x5B, 0x52, 0x4A, 0x51, 0x4D, 0x49, 0x47, 0x3B, 0x35, 0x14, 0x2A, 
	0x30, 0x15, 0x28, 0x29, 0x15, 0x28, 0x29, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x12, 0x25, 0x24, 
	0x18, 0x2A, 0x2F, 0x1D, 0x30, 0x39, 0x1D, 0x30, 0x38, 0x1D, 0x30, 0x39, 0x12, 0x26, 0x26, 0x1B, 
	0x30, 0x3B, 0x19, 0x2B, 0x30, 0x13, 0x26, 0x26, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 0x12, 0x25, 
	0x24, 0x15, 0x28, 0x2A, 0x19, 0x2B, 0x30, 0x15, 0x28, 0x2A, 0x13, 0x26, 0x25, 0x19, 0x2B, 0x31, 
	0x13, 0x26, 0x25, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x0F, 0x27, 0x27, 0x23, 
	0x22, 0x20, 0x31, 0x31, 0x27, 0x30, 0x30, 0x27, 0x30, 0x29, 0x1F, 0x30, 0x30, 0x27, 0x30, 0x31, 
	0x27, 0x28, 0x20, 0x1F, 0x25, 0x1B, 0x1C, 0x33, 0x2A, 0x1D, 0x26, 0x1B, 0x1D, 0x27, 0x1D, 0x1D, 
	0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x29, 
	0x1B, 0x1B, 0x11, 0x28, 0x28, 0x14, 0x27, 0x27, 0x14, 0x27, 0x27, 0x13, 0x27, 0x27, 0x19, 0x25, 
	0x25, 0x28, 0x1C, 0x1C, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 0x27, 0x1D, 0x1D, 
	0x28, 0x1C, 0x1C, 0x15, 0x26, 0x26, 

};

static UINT g_sizeofTexture = sizeof(g_texture);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wma\bvt\wmabvt.cpp ===
#include <dsutil.h>

VOID WINAPI WMABVTStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danrose", "WMA", "Bvt", "PlayWmaFile" );
	EXECUTE( PlayWmaFile( WMA_BVT_FILE ) );
}

VOID WINAPI WMABVTEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WMABVT )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WMABVT )
    EXPORT_TABLE_ENTRY( "StartTest", WMABVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WMABVTEndTest )
END_EXPORT_TABLE( WMABVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wma\stress\wmastress.cpp ===
#include <xtl.h>
#include <dsutil.h>

HRESULT WMAStress( void )
{
	HRESULT hr;
	WIN32_FIND_DATA findData;
	BOOL bMore;
	HANDLE hFiles;

	CHAR szFullName[MAX_PATH];
	LPSTR szFiles = NULL;

	bMore = TRUE;

	hFiles = FindFirstFile( WMA_FILES, &findData );

	while ( INVALID_HANDLE_VALUE != hFiles && TRUE == bMore )
	{

		sprintf( szFullName, "%s\\%s", WMA_DRIVE, findData.cFileName );

		hr = PlayWmaFile( szFullName, true );

		bMore = FindNextFile( hFiles, &findData );
	}

	FindClose( hFiles );

	return hr;
}

VOID WINAPI WMAStressStartTest( HANDLE LogHandle )
{
	SETLOG( LogHandle, "danrose", "Wma", "Stress", "StartTest" );

	HRESULT hr = S_OK;

	EXECUTE( WMAStress() );
}

VOID WINAPI WMAStressEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( wmaStress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( wmaStress )
    EXPORT_TABLE_ENTRY( "StartTest", WMAStressStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WMAStressEndTest )
END_EXPORT_TABLE( wmaStress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wma\wavout\waveout.h ===
///////////////////////////////////////////////////////////////////////////////
//
// File: waveout.h
//
// Date: 2/16/2001
//
// Author: danrose
//
// Purpose: Interface class decleration for Wave Out file writer XMO
//
///////////////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>

///////////////////////////////////////////////////////////////////////////////
//
// The Wave writer xmo inherits off the generic XMO interface, and exposes
// no other functionality
//
///////////////////////////////////////////////////////////////////////////////

class CWaveOutMediaObject : public XMediaObject
{
public:

	// Constructor / Destructor

    CWaveOutMediaObject( void );
    virtual ~CWaveOutMediaObject( void );

public:
    // Initialization

    HRESULT STDMETHODCALLTYPE Initialize( LPCSTR pszFileName, LPCWAVEFORMATEX pwfxFormat );

    // IUnknown methods

    virtual ULONG STDMETHODCALLTYPE AddRef( void );
    virtual ULONG STDMETHODCALLTYPE Release( void );

    // XMediaObject methods

    virtual HRESULT STDMETHODCALLTYPE GetInfo( LPXMEDIAINFO pInfo );
    virtual HRESULT STDMETHODCALLTYPE GetStatus( LPDWORD pdwStatus );
    virtual HRESULT STDMETHODCALLTYPE Process( LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput );
    virtual HRESULT STDMETHODCALLTYPE Discontinuity( void );
    virtual HRESULT STDMETHODCALLTYPE Flush( void );

protected:

	// Method to write out a wave file header

	HRESULT STDMETHODCALLTYPE WriteWaveHeader( void );

	// keep around a ref count, number of bytes written, the chunk size, the waveformatex, and a file handle

	ULONG m_ulRefCount;
	DWORD m_dwBufferBytesWritten;
	DWORD m_dwChunkSize;
	WAVEFORMATEX m_wfx;
	HANDLE m_hFile;
};

///////////////////////////////////////////////////////////////////////////////
//
// Standard prototype for the creation method for the XMO
//
///////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI XWaveOutCreateMediaObject( LPCSTR pszFileName, LPCWAVEFORMATEX pwfxFormat, XMediaObject **ppMediaObject );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wma\regression\wmareg.cpp ===
#include <dsutil.h>

VOID WINAPI WMARegStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danrose", "WMA", "Regression", "WMAMultiThreaded" );
	EXECUTE( TestMultiThreaded( WMAThreadTest ) ); 
}

VOID WINAPI WMARegEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WMAReg )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WMAReg )
    EXPORT_TABLE_ENTRY( "StartTest", WMARegStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WMARegEndTest )
END_EXPORT_TABLE( WMAReg )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wma\wavout\waveout.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// File: waveout.cpp
//
// Date: 2/16/2001
//
// Author: danrose
//
// Purpose: Implementation of the Wave File Writer XMO
//
///////////////////////////////////////////////////////////////////////////////

#include "waveout.h"

///////////////////////////////////////////////////////////////////////////////
//
// Function: XWaveOutCreateMediaObject
// 
// Input: pszFileName   - the name of the file that will be created and written
//        pwfxFormat    - the format of the wavedata in memory
//        ppMediaObject - the created WaveOut XMO
//
// Output: a standard HRESULT
//
// Purpose: to make creation of the WaveOut XMO very easy
//
///////////////////////////////////////////////////////////////////////////////

HRESULT XWaveOutCreateMediaObject( LPCSTR pszFileName, LPCWAVEFORMATEX pwfxFormat, XMediaObject** ppMediaObject )
{
	// Check the inputted parameters

	if ( NULL == pszFileName || NULL == pwfxFormat || NULL == ppMediaObject )
		return E_POINTER;

	// Allocate the return HR and the XMO

    CWaveOutMediaObject* pMediaObject = NULL;
    HRESULT hr = S_OK;
    
	// Create the XMO, check for failures

    pMediaObject = new CWaveOutMediaObject();

	if ( NULL == pMediaObject )
		hr = E_OUTOFMEMORY;

	// Initalize the XMO with the inputted file name and wave format

    if( SUCCEEDED( hr ) )
    {
        hr = pMediaObject->Initialize( pszFileName, pwfxFormat );
    }

	// Set the output XMO pointer to the created one

    if( SUCCEEDED( hr ) )
    {
        *ppMediaObject = pMediaObject;
    }

	// If an error occured but the XMO was created, release it

	if ( FAILED( hr ) && NULL != pMediaObject )
	{
		pMediaObject->Release();
	}

    // Return the final Hr

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Constructor
//
// Input: None
//
// Output: None
//
// Purpose: allocate all stack variables, and zero them out
//
///////////////////////////////////////////////////////////////////////////////

CWaveOutMediaObject::CWaveOutMediaObject( void )
	: m_wfx(),
	  m_ulRefCount( 1 ),
	  m_dwBufferBytesWritten( 0 ),
	  m_dwChunkSize( 0 ),
	  m_hFile( NULL )
{
	ZeroMemory( &m_wfx, sizeof( WAVEFORMATEX ) );
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Destructor
//
// Input: None
//
// Output: None
//
// Purpose: Close the allocated file handle if no errors had occured
//
///////////////////////////////////////////////////////////////////////////////
    
CWaveOutMediaObject::~CWaveOutMediaObject( void )
{
	if ( NULL != m_hFile && INVALID_HANDLE_VALUE != m_hFile )
	{
		CloseHandle( m_hFile );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Initialize
//
// Input: pszFileName - the name of the wave file to be created
//        pwfxFormat  - the wave format of the buffer that will be passed in
//
// Output: a standard HRESULT
//
// Purpose: to set up the Wave out xmo by saving the waveformat, creating the
//          underlying file handle, and writing out the wave header to the file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT STDMETHODCALLTYPE CWaveOutMediaObject::Initialize( LPCSTR pszFileName, LPCWAVEFORMATEX pwfxFormat )
{
	// Check the parameters passed in

	if ( NULL == pszFileName || NULL == pwfxFormat )
		return E_POINTER;

	HRESULT hr = S_OK;
	
	// Copy over the wave format

	memcpy( &m_wfx, pwfxFormat, sizeof( WAVEFORMATEX ) );

	// create the file handle, check for errors

	m_hFile = CreateFile( pszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );

	if ( INVALID_HANDLE_VALUE == m_hFile )
	{
		hr = E_FAIL;
	}

	// Write out the wave header

	if ( SUCCEEDED( hr ) )
	{
		hr = WriteWaveHeader();
	}

	// Close the file handle if an error occured

	if ( FAILED( hr ) || NULL == m_hFile || INVALID_HANDLE_VALUE == m_hFile )
	{
		CloseHandle( m_hFile );
	}

	// return the final hr

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO AddRef
//
// Input: None
//
// Output: the new reference count
//
// Purpose: to reference count the XMO
//
///////////////////////////////////////////////////////////////////////////////

__inline ULONG CWaveOutMediaObject::AddRef( void )
{
    return ++m_ulRefCount;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Release
//
// Input: None
//
// Output: the new reference count
//
// Purpose: to reference count the XMO
//
///////////////////////////////////////////////////////////////////////////////

__inline ULONG CWaveOutMediaObject::Release( void )
{
    if( m_ulRefCount )
    {
        if( !--m_ulRefCount )
        {
            delete this;
            return 0;
        }
    }

    return m_ulRefCount;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Discontinuity
//
// Input: None
//
// Output: always S_OK
//
// Purpose: not needed, just a stub
//
///////////////////////////////////////////////////////////////////////////////

__inline HRESULT CWaveOutMediaObject::Discontinuity( void )
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Flush
//
// Input: None
//
// Output: always S_OK
//
// Purpose: not needed, just a stub
//
///////////////////////////////////////////////////////////////////////////////

__inline HRESULT CWaveOutMediaObject::Flush( void )
{
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO GetStatus
//
// Input: pdwStatus - a pointer to a dword that will contain the status
//
// Output: either E_POINTER or S_OK
//
// Purpose: to find out the status of the XMO
//
///////////////////////////////////////////////////////////////////////////////

__inline HRESULT CWaveOutMediaObject::GetStatus( LPDWORD pdwStatus )
{

	// Check for invalid params

	if ( NULL == pdwStatus )
		return E_POINTER;

	// set the status to be acccept input data since this is a 
	// rendering sync XMO

    *pdwStatus = XMO_STATUSF_ACCEPT_INPUT_DATA;

	// always return S_OK if we've made it here

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO GetInfo
//
// Input: pInfo - a pointer ot the XMO info structure
//
// Output: either S_OK or E_POINTER
//
// Purpose: to get properties of the xmo to build a valid XMO graph
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CWaveOutMediaObject::GetInfo( LPXMEDIAINFO pInfo )
{

	// Check for bad params

	if ( NULL == pInfo )
		return E_POINTER;

	// setup the info structure. We only take WHOLE, FIXED size samples
	// there is no lookahead
	// no input size
	// and the outputsize is whatever the block alignment of the waveform is

    pInfo->dwFlags = XMO_STREAMF_FIXED_SAMPLE_SIZE;
    pInfo->dwMaxLookahead = 0;
    pInfo->dwInputSize = 0;
    pInfo->dwOutputSize = m_wfx.nBlockAlign;

	// always return S_OK if the param was good

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO Process
//
// Input: pxmbInput  - the input media packet
//        pxmbOutput - the output media packet, always NULL
//
// Output: a valid HRESULT
//
// Purpose: the actual work horse function. Process is called every time
//          new data is ready to be written out to the wave file
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CWaveOutMediaObject::Process( LPCXMEDIAPACKET pxmbInput, LPCXMEDIAPACKET pxmbOutput )
{
	// Check the paramters

	if ( NULL != pxmbOutput || NULL == pxmbInput || NULL == pxmbInput->pvBuffer )
		return E_INVALIDARG;
		
	// allocate stack variables

	HRESULT hr = S_OK;

	BOOL bMoved = TRUE;
	
	DWORD dwBytesWritten = 0;
	DWORD dwWritten = 0;

	// write the inputted buffer to the file, check for failure

	DWORD dwWrite = WriteFile( m_hFile, pxmbInput->pvBuffer, pxmbInput->dwMaxSize, &dwBytesWritten, NULL );

	if ( 0 == dwWrite )
	{
		hr = E_FAIL;
	}

	// update the number of bytes written and the chunk size

	m_dwBufferBytesWritten += dwBytesWritten;
    m_dwChunkSize += dwBytesWritten;

	// Move the file pointer to the location in the header to update the data chunk size
	// and check for failure
	
	if ( SUCCEEDED( hr ) )
	{
		bMoved = SetFilePointer( m_hFile, 4, NULL, FILE_BEGIN );
	}

	if ( !bMoved )
	{
		hr = E_FAIL;
	}

	// Write out the new data chunk size, chekc for any failures

	if ( SUCCEEDED( hr ) )
	{
		dwWrite = WriteFile( m_hFile, &m_dwBufferBytesWritten, sizeof( DWORD ), &dwWritten, NULL );
	}

	if ( 0 == dwWrite )
	{
		hr = E_FAIL;
	}

	// more the file pointer to the location of the WAVE chunk size, and check for failure

	if ( SUCCEEDED( hr ) )
	{
		bMoved = SetFilePointer( m_hFile, 40, NULL, FILE_BEGIN );
	}

	if ( !bMoved )
	{
		hr = E_FAIL;
	}

	// write the new chunk size to the file, and check for failure

	if ( SUCCEEDED( hr ) )
	{
		dwWrite = WriteFile( m_hFile, &m_dwChunkSize, sizeof( DWORD ), &dwWritten, NULL );
	}

	if ( 0 == dwWrite )
	{
		hr = E_FAIL;
	}

	// move the file pointer to the end of the file, for the next call to process, chekc for failure

	if ( SUCCEEDED( hr ) )
	{
		bMoved = SetFilePointer( m_hFile, 0, NULL, FILE_END );
	}

	if ( !bMoved )
	{
		hr = E_FAIL;
	}

	// if the completed size, status and / or completion event are desired, act on them

	if ( pxmbInput->pdwCompletedSize )
	{
		*pxmbInput->pdwCompletedSize = dwBytesWritten;
	}

	if ( pxmbInput->pdwStatus )
	{
		*pxmbInput->pdwStatus = SUCCEEDED( hr ) ? XMEDIAPACKET_STATUS_SUCCESS : XMEDIAPACKET_STATUS_FAILURE;
	}

	if ( pxmbInput->hCompletionEvent )
	{
		SetEvent( pxmbInput->hCompletionEvent );
	}

	// return the final hr

	return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CWaveOut XMO WriteWaveHeader
//
// Input: None
//
// Output: a valid HRESULT
//
// Purpose: to calculate and write out the wave file header
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CWaveOutMediaObject::WriteWaveHeader( void )
{

// set up the compiler to pack on byte boundries

#pragma pack( push )
#pragma pack( 1 )

	// A local variable that represnts the header of a wave file

    struct
    {

		// first the Riff Chunk

        struct
        {
            DWORD           dwChunkId;
            DWORD           dwChunkSize;
            DWORD           dwRiffType;
        } RiffChunk;

		// then the format chunk

        struct
        {
            DWORD           dwChunkId;
            DWORD           dwChunkSize;
            
			// witch has an embedded wave format

            struct
            {
                WORD        wFormatTag;
                WORD        nChannels;
                DWORD       nSamplesPerSec;
                DWORD       nAvgBytesPerSec;
                WORD        nBlockAlign;
                WORD        wBitsPerSample;
            } PcmWaveFormat;
                
        } FormatChunk;

		// and finaly the data chunk

        struct
        {
            DWORD           dwChunkId;
            DWORD           dwChunkSize;
        } DataChunk;

    } RiffHeader;

#pragma pack( pop )

	// Set up the Data chunk

    RiffHeader.DataChunk.dwChunkId = 'atad';
    RiffHeader.DataChunk.dwChunkSize = 0;

	// then the Format Chunk preamble

    RiffHeader.FormatChunk.dwChunkId = ' tmf';
    RiffHeader.FormatChunk.dwChunkSize = sizeof( RiffHeader.FormatChunk.PcmWaveFormat );

	// then the wave format

    RiffHeader.FormatChunk.PcmWaveFormat.wFormatTag = m_wfx.wFormatTag;
    RiffHeader.FormatChunk.PcmWaveFormat.nChannels = m_wfx.nChannels;
    RiffHeader.FormatChunk.PcmWaveFormat.nSamplesPerSec = m_wfx.nSamplesPerSec;
    RiffHeader.FormatChunk.PcmWaveFormat.nAvgBytesPerSec = m_wfx.nAvgBytesPerSec;
    RiffHeader.FormatChunk.PcmWaveFormat.nBlockAlign = m_wfx.nBlockAlign;
    RiffHeader.FormatChunk.PcmWaveFormat.wBitsPerSample = m_wfx.wBitsPerSample;

	// then the riff chunk

    RiffHeader.RiffChunk.dwChunkId = 'FFIR';
    RiffHeader.RiffChunk.dwChunkSize = sizeof( RiffHeader.RiffChunk.dwRiffType ) + sizeof( RiffHeader.FormatChunk ) + RiffHeader.FormatChunk.dwChunkSize + sizeof( RiffHeader.DataChunk ) + RiffHeader.DataChunk.dwChunkSize;
	RiffHeader.RiffChunk.dwRiffType = 'EVAW';

	// write out the header to the file

	DWORD dwWritten = 0;
    DWORD dwWrite = WriteFile( m_hFile, &RiffHeader, sizeof( RiffHeader ), &dwWritten, NULL );

	// and decide if everything went ok

	return 0 == dwWrite ? E_FAIL : S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>
#ifdef _XBOX
#include <xgraphics.h>
#endif
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

#if 0

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const WCHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}

#endif 0

//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };
    D3DLOCKED_RECT lockRect;
    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);

    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_TILED) != S_OK)
    {
        assert(FALSE);
        return;
    }

    UINT BitsPerPixel =

#ifdef _XBOX
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;
#else
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8) ? 32 : 16;
#endif

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );
    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_A8R8G8B8:
#endif
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
#ifdef _XBOX
    case D3DFMT_LIN_X8R8G8B8:
#endif
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
#ifdef _XBOX
    case D3DFMT_LIN_R5G6B5:
#endif
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_X1R5G5B5:
#endif
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
#ifdef _XBOX
    case D3DFMT_LIN_A4R4G4B4:
#endif
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
#ifdef _XBOX
    case D3DFMT_LIN_A1R5G5B5:
#endif
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\Test.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.cpp

Abstract:

	Abstract class implementation to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#include "Test.h"

#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <stdio.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;


//------------------------------------------------------------------------------
//	Inititialize static variable to FALSE so that XInitDevices() is called
//------------------------------------------------------------------------------

BOOL CTest::m_bInitDevicesCalled = FALSE;


/*++

	CTest constructor

Routine Description:

	constructor

Arguments:

	None

Return Value:

	None

--*/

CTest::CTest()
{
	m_bQuit = FALSE;
}


/*++

	CTest destructor

Routine Description:

	destructor

Arguments:

	None

Return Value:

	None

--*/

CTest::~CTest()
{
}


/*++

	Run

Routine Description:

	The test's main loop: initialize, enter loop, destroy

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Run()
{
	HRESULT hr = S_OK;

	// initialize all resources/devices
	EXECUTE( Init() );
	if ( FAILED( hr ) )
	{
		Destroy();
		return hr;
	}
	
	// loop for as long as test needs to run
	while ( !m_bQuit )
	{
		// calculate time change since last frame and update time variables
		DWORD dwTempTime = timeGetTime();
		m_dwDeltaTime = dwTempTime - m_dwCurrentTime;
		m_dwCurrentTime = dwTempTime;
		
		// do the real work of the test inside these functions
		EXECUTE( ProcessInput() )
		EXECUTE( Update() )
		EXECUTE( Render() )
	}
	
	// clean up 
	EXECUTE( Destroy() )

	return hr;
}


/*++

	Init

Routine Description:

	Common initialization function for all tests, calls inheritable functions to do
	initialization and starts timers

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Init()
{
	HRESULT hr = S_OK;

	EXECUTE( ReadIni() )
	if ( FAILED( hr ) )
	{
		return hr;
	}

	EXECUTE( InitGraphics() )
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	EXECUTE( InitAudio() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		return hr;
	}

	if ( !m_bInitDevicesCalled )
	{
		// we only need to call this once for all tests, hence static declaration of m_bInitDevicesCalled
		XInitDevices( 0, NULL );
		m_bInitDevicesCalled = TRUE;
	}

	EXECUTE( InitInput() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		return hr;
	}

	EXECUTE( InitResources() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		DestroyInput();
		return hr;
	}

	m_dwStartTime = m_dwCurrentTime = timeGetTime(); 

	return hr;
}


/*++

	Destroy

Routine Description:

	Common de-allocation function for all tests, calls inheritable functions to do
	un-initialization/deletion

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Destroy()
{
	HRESULT hr = S_OK;

	EXECUTE( DestroyGraphics() )
	EXECUTE( DestroyAudio() )
	EXECUTE( DestroyInput() )
	EXECUTE( DestroyResources() )

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\Test.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.h

Abstract:

	Abstract class to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#ifndef __TEST_H__
#define __TEST_H__

#include <xtl.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

class CTest
{
public:

	CTest();												//	constructor: for now only sets m_bQuit to FALSE
	virtual ~CTest();										//	virtually destroy class (and inherited class)
	HRESULT Run();											//	the test's main loop

protected:

	//------------------------------------------------------------------------------
	//	Overridable functions to do the test's initialization/cleanup (before and
	//	after main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ReadIni() { return S_OK; }				//	get initialization parameters from an ini file
	virtual HRESULT InitGraphics() { return S_OK; }			//	init d3d here (i.e., create a device, etc.)
	virtual HRESULT DestroyGraphics() { return S_OK; }		//	cleanup anything created in InitGraphics() here
	virtual HRESULT InitInput() { return S_OK; }			//	init input devices (i.e., call XInputOpen(), not XInitDevices())
	virtual HRESULT DestroyInput() { return S_OK; }			//	cleanup anything created in InitInput() here
	virtual HRESULT InitAudio() { return S_OK; }			//	init audio devices here
	virtual HRESULT DestroyAudio() { return S_OK; }			//	cleanup anything created in InitAudio() here
	virtual HRESULT InitResources() { return S_OK; }		//	init resources (models, textures, sound files, etc.) here
	virtual HRESULT DestroyResources() { return S_OK; }		//	cleanup anything created in InitResources() here


	//------------------------------------------------------------------------------
	//	Overidable functions to do the test's real work (inside the main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ProcessInput() { return S_OK; }			//	should be used to get any input from devices and process it
	virtual HRESULT Update() { return S_OK; }				//	any updates that need to be performed each frame are done here
	virtual HRESULT Render() { return S_OK; }				//	draw everything to the screen here


	//------------------------------------------------------------------------------
	//	Protected data members that are useful to the inherited classes
	//------------------------------------------------------------------------------

	BOOL				m_bQuit;							//	loop continues while FALSE
	DWORD				m_dwStartTime;						//	start time of test
	DWORD				m_dwCurrentTime;					//	current time of test
	DWORD				m_dwDeltaTime;						//	time between current frame and previous
	//UINT				m_wLoops;							//	number of times to execute the test
	//UINT				m_wLoop;							//	current loop

private:

	//------------------------------------------------------------------------------
	//	Private data member that should not be visible to inherited classes
	//------------------------------------------------------------------------------

	HRESULT Init();											//	calls overridable functions to do all initialization
	HRESULT Destroy();										//	calls overridable functions to do all cleanup

	static BOOL			m_bInitDevicesCalled;				//	keeps track of whether XInitDevices() has been called
};
	
#endif // #ifndef __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\Test.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.h

Abstract:

	Abstract class to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#ifndef __TEST_H__
#define __TEST_H__

#include <xtl.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

class CTest
{
public:

	CTest();												//	constructor: for now only sets m_bQuit to FALSE
	virtual ~CTest();										//	virtually destroy class (and inherited class)
	HRESULT Run();											//	the test's main loop

protected:

	//------------------------------------------------------------------------------
	//	Overridable functions to do the test's initialization/cleanup (before and
	//	after main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ReadIni() { return S_OK; }				//	get initialization parameters from an ini file
	virtual HRESULT InitGraphics() { return S_OK; }			//	init d3d here (i.e., create a device, etc.)
	virtual HRESULT DestroyGraphics() { return S_OK; }		//	cleanup anything created in InitGraphics() here
	virtual HRESULT InitInput() { return S_OK; }			//	init input devices (i.e., call XInputOpen(), not XInitDevices())
	virtual HRESULT DestroyInput() { return S_OK; }			//	cleanup anything created in InitInput() here
	virtual HRESULT InitAudio() { return S_OK; }			//	init audio devices here
	virtual HRESULT DestroyAudio() { return S_OK; }			//	cleanup anything created in InitAudio() here
	virtual HRESULT InitResources() { return S_OK; }		//	init resources (models, textures, sound files, etc.) here
	virtual HRESULT DestroyResources() { return S_OK; }		//	cleanup anything created in InitResources() here


	//------------------------------------------------------------------------------
	//	Overidable functions to do the test's real work (inside the main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ProcessInput() { return S_OK; }			//	should be used to get any input from devices and process it
	virtual HRESULT Update() { return S_OK; }				//	any updates that need to be performed each frame are done here
	virtual HRESULT Render() { return S_OK; }				//	draw everything to the screen here


	//------------------------------------------------------------------------------
	//	Protected data members that are useful to the inherited classes
	//------------------------------------------------------------------------------

	BOOL				m_bQuit;							//	loop continues while FALSE
	DWORD				m_dwStartTime;						//	start time of test
	DWORD				m_dwCurrentTime;					//	current time of test
	DWORD				m_dwDeltaTime;						//	time between current frame and previous
	//UINT				m_wLoops;							//	number of times to execute the test
	//UINT				m_wLoop;							//	current loop

private:

	//------------------------------------------------------------------------------
	//	Private data member that should not be visible to inherited classes
	//------------------------------------------------------------------------------

	HRESULT Init();											//	calls overridable functions to do all initialization
	HRESULT Destroy();										//	calls overridable functions to do all cleanup

	static BOOL			m_bInitDevicesCalled;				//	keeps track of whether XInitDevices() has been called
};
	
#endif // #ifndef __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\Test.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.cpp

Abstract:

	Abstract class implementation to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#include "Test.h"

#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <stdio.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;


//------------------------------------------------------------------------------
//	Inititialize static variable to FALSE so that XInitDevices() is called
//------------------------------------------------------------------------------

BOOL CTest::m_bInitDevicesCalled = FALSE;


/*++

	CTest constructor

Routine Description:

	constructor

Arguments:

	None

Return Value:

	None

--*/

CTest::CTest()
{
	m_bQuit = FALSE;
}


/*++

	CTest destructor

Routine Description:

	destructor

Arguments:

	None

Return Value:

	None

--*/

CTest::~CTest()
{
}


/*++

	Run

Routine Description:

	The test's main loop: initialize, enter loop, destroy

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Run()
{
	HRESULT hr = S_OK;

	// initialize all resources/devices
	EXECUTE( Init() );
	if ( FAILED( hr ) )
	{
		Destroy();
		return hr;
	}
	
	// loop for as long as test needs to run
	while ( !m_bQuit )
	{
		// calculate time change since last frame and update time variables
		DWORD dwTempTime = timeGetTime();
		m_dwDeltaTime = dwTempTime - m_dwCurrentTime;
		m_dwCurrentTime = dwTempTime;
		
		// do the real work of the test inside these functions
		EXECUTE( ProcessInput() )
		EXECUTE( Update() )
		EXECUTE( Render() )
	}
	
	// clean up 
	EXECUTE( Destroy() )

	return hr;
}


/*++

	Init

Routine Description:

	Common initialization function for all tests, calls inheritable functions to do
	initialization and starts timers

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Init()
{
	HRESULT hr = S_OK;

	EXECUTE( ReadIni() )
	if ( FAILED( hr ) )
	{
		return hr;
	}

	EXECUTE( InitGraphics() )
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	EXECUTE( InitAudio() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		return hr;
	}

	if ( !m_bInitDevicesCalled )
	{
		// we only need to call this once for all tests, hence static declaration of m_bInitDevicesCalled
		XInitDevices( 0, NULL );
		m_bInitDevicesCalled = TRUE;
	}

	EXECUTE( InitInput() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		return hr;
	}

	EXECUTE( InitResources() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		DestroyInput();
		return hr;
	}

	m_dwStartTime = m_dwCurrentTime = timeGetTime(); 

	return hr;
}


/*++

	Destroy

Routine Description:

	Common de-allocation function for all tests, calls inheritable functions to do
	un-initialization/deletion

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Destroy()
{
	HRESULT hr = S_OK;

	EXECUTE( DestroyGraphics() )
	EXECUTE( DestroyAudio() )
	EXECUTE( DestroyInput() )
	EXECUTE( DestroyResources() )

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\utils.h ===
//-----------------------------------------------------------------------------
// FILE: UTILS.H
//
// Desc: utils header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef __UTILS_H__
#define __UTILS_H__

#define ARRAYSIZE(_a)     (sizeof(_a) / sizeof((_a)[0]))

//=========================================================================
// Release helper function
//=========================================================================
#if 0
template <class T> inline void RELEASE(T& punk)
{
    if(punk)
    {
        punk->Release();
        punk = NULL;
    }
}
#endif


//=========================================================================
// Class to help time things
//=========================================================================
class CTimer
{
public:
    // constructor
    CTimer()
    {
        QueryPerformanceFrequency((LARGE_INTEGER*)&ticksPerSecond);
        ticksPerSecond /= 1000;
    }

    ~CTimer() {};

    void Start()
        { frunning = true; QueryPerformanceCounter((LARGE_INTEGER *)&ticksstart); }

    void Stop()
        { frunning = false; QueryPerformanceCounter((LARGE_INTEGER *)&ticksend); }

    float getTime()
        {
            if(frunning)
                QueryPerformanceCounter((LARGE_INTEGER *)&ticksend);
            return ((ticksend - ticksstart) * 1.0f / ticksPerSecond);
        }

    bool frunning;
    _int64 ticksstart;
    _int64 ticksend;
    _int64 ticksPerSecond;
};

//=========================================================================
// Screen Text helper class
//=========================================================================
class CScrText
{
public:
    CScrText()
        { cls(); }

    ~CScrText() {}

    void cls()
    {
        m_iLine = 0;
        for(int i = 0; i < NUM_LINES; i++)
            m_rgText[i][0] = 0;
    }
    void _cdecl printf(LPCSTR lpFmt, ...);
    void drawtext(bool fDebugSquirty);

private:
    enum { LINE_WIDTH = 80, NUM_LINES = 40 };
    char m_rgText[NUM_LINES][LINE_WIDTH];
    int m_iLine;
};

// redefine these guys to make them shorter and remove the misleading D3DMULTISAMPLE_ part
#define D3DMS_NONE                                         D3DMULTISAMPLE_NONE
#define D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX               D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX
#define D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR      D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR
#define D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR        D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR
#define D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR                 D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR
#define D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN
#define D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN               D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN
#define D3DMS_PREFILTER_FORMAT_DEFAULT                     D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT
#define D3DMS_PREFILTER_FORMAT_X1R5G5B5                    D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5
#define D3DMS_PREFILTER_FORMAT_R5G6B5                      D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5
#define D3DMS_PREFILTER_FORMAT_X8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8
#define D3DMS_PREFILTER_FORMAT_A8R8G8B8                    D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8

// utils.cpp
bool IsLinearFormat(DWORD Format);
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format);
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc);
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat);
LPCSTR GetMultiSampleStr(DWORD mstype);
LPCSTR GetTextureModeStr(DWORD TextureMode);
UINT64 GetFileTime(LPCSTR lpFileName);

void DisplayError(const char *szCall, HRESULT hr);
#define CheckHR(x) { HRESULT _hr = (x); if (FAILED(_hr)) { DisplayError(#x, _hr); } }
void _cdecl dprintf(LPCSTR lpFmt, ...);

#endif // #ifndef __UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\FrameQueue.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	FrameQueue.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 04-Sep-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	04-Sep-2001 jeffsul
		Initial Version

--*/

#include "FrameQueue.h"
#include <xdbg.h>
#include <macros.h>


CFrameQueue::CFrameQueue()
{ 
	m_pHead = m_pTail = NULL; 
}

BOOL 
CFrameQueue::IsEmpty()
{ 
	return m_pHead == NULL; 
}

//-----------------------------------------------------------------------------
// Name: FrameQueue::Enqueue
// Desc: Adds a frame to tail of queue
//-----------------------------------------------------------------------------
VOID
CFrameQueue::Enqueue( VIDEOFRAME * pFrame )
{ 
    pFrame->pNext = NULL;

    if( m_pTail ) 
    {
        m_pTail->pNext = pFrame;
        m_pTail = pFrame;
    }
    else
        m_pHead = m_pTail = pFrame;
}



//-----------------------------------------------------------------------------
// Name: FrameQueue::Dequeue
// Desc: Returns the head of the queue
//-----------------------------------------------------------------------------
VIDEOFRAME *
CFrameQueue::Dequeue()
{
    ASSERT( m_pHead );
    VIDEOFRAME * pPacket = m_pHead;

    m_pHead = m_pHead->pNext;
    if( !m_pHead )
        m_pTail = NULL;

    pPacket->pNext = NULL;
    return pPacket;
}

/*
VOID
CFrameQueue::Destroy()
{
	ASSERT( m_pHead );
	VIDEOFRAME* pPacket = m_pHead;
	
	while ( pPacket )
	{
		VIDEOFRAME* pNext = pPacket->pNext;
		SAFEDELETE( pPacket );
		pPacket = pNext;
    }

	m_pHead = NULL;
}*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#include <xtl.h>


// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

#if 0

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const WCHAR* filename);

#endif 0

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\common\FrameQueue.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	FrameQueue.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 04-Sep-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	04-Sep-2001 jeffsul
		Initial Version

--*/

#ifndef __FRAMEQUEUE_H__
#define __FRAMEQUEUE_H__

#include <xtl.h>

// Define a video frame structure:
typedef struct _VIDEOFRAME {
    struct _VIDEOFRAME *pNext;          // Next pending video frame
    LPDIRECT3DTEXTURE8  pTexture;       // Texture data
    REFERENCE_TIME      rtTimeStamp;    // Time stamp of video frame
    DWORD               dwSetAtVBlank;  // VBlank count at which frame was started
    BYTE *              pBits;          // Pointer to texture data
    DWORD               dwFrameNumber;  // Frame sequence number (debug)
} VIDEOFRAME;

//-------------------------------------------------------------------------
// Name: class CFrameQueue
// Desc: Maintains a queue of video frames
//-------------------------------------------------------------------------
class CFrameQueue
{
public:
	VIDEOFRAME * m_pHead;
	VIDEOFRAME * m_pTail;
	
	CFrameQueue();

	BOOL	
	IsEmpty();

	VOID	
	Enqueue( VIDEOFRAME* pFrame );

	/*VOID
	Destroy();*/

	VIDEOFRAME* 
	Dequeue(); 
};

#endif // #ifndef __FRAMEQUEUE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\utils.cpp ===
//-----------------------------------------------------------------------------
// FILE: FILLRATE.CPP
//
// Desc: a stupid fillrate test
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <stdio.h>

#include "bitfont.h"
#include "utils.h"

// CScrText font class
BitFont g_bitfont;

//=========================================================================
// Stringtize PS_TEXTUREMODES_*
//=========================================================================
LPCSTR GetTextureModeStr(DWORD TextureMode)
{
    #undef XTAG
    #define XTAG(_tag) { PS_TEXTUREMODES##_tag, "PS_TM" #_tag }
    static const struct
    {
        DWORD texturemode;
        const char *szD3DMSStr;
    } rgszTMStr[] =
    {
        XTAG(_NONE), XTAG(_PROJECT2D), XTAG(_PROJECT3D),
        XTAG(_CUBEMAP), XTAG(_PASSTHRU), XTAG(_CLIPPLANE),
        XTAG(_BUMPENVMAP), XTAG(_BUMPENVMAP_LUM), XTAG(_BRDF),
        XTAG(_DOT_ST), XTAG(_DOT_ZW), XTAG(_DOT_RFLCT_DIFF),
        XTAG(_DOT_RFLCT_SPEC), XTAG(_DOT_STR_3D), XTAG(_DOT_STR_CUBE),
        XTAG(_DPNDNT_AR), XTAG(_DPNDNT_GB), XTAG(_DOTPRODUCT),
        XTAG(_DOT_RFLCT_SPEC_CONST),
    };
    static const int cFmts = sizeof(rgszTMStr) / sizeof(rgszTMStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszTMStr[ifmt].texturemode == TextureMode)
            return rgszTMStr[ifmt].szD3DMSStr;
    }

    return rgszTMStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DMS_*
//=========================================================================
LPCSTR GetMultiSampleStr(DWORD mstype)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        DWORD mstype;
        const char *szD3DMSStr;
    } rgszMSStr[] =
    {
        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),
    };
    static const int cFmts = sizeof(rgszMSStr) / sizeof(rgszMSStr[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszMSStr[ifmt].mstype == mstype)
            return rgszMSStr[ifmt].szD3DMSStr;
    }

    return rgszMSStr[cFmts - 1].szD3DMSStr;
}

//=========================================================================
// Stringtize D3DCMP_*
//=========================================================================
LPCSTR GetD3DCMPStr(D3DCMPFUNC d3dcmpfunc)
{
    static const char *rgszD3DCmp[] =
    {
        "D3DCMP_NEVER",         // 0x200,
        "D3DCMP_LESS",          // 0x201,
        "D3DCMP_EQUAL",         // 0x202,
        "D3DCMP_LESSEQUAL",     // 0x203,
        "D3DCMP_GREATER",       // 0x204,
        "D3DCMP_NOTEQUAL",      // 0x205,
        "D3DCMP_GREATEREQUAL",  // 0x206,
        "D3DCMP_ALWAYS",        // 0x207,
        "??",
    };

    DWORD id3dcmp = min(d3dcmpfunc & 0xf, sizeof(rgszD3DCmp) / sizeof(rgszD3DCmp[0]));
    return rgszD3DCmp[id3dcmp];
}

//=========================================================================
// Stringtize D3DFMT_*
//=========================================================================
LPCSTR GetD3DFormatStr(D3DFORMAT d3dformat)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        D3DFORMAT d3dformat;
        const char *szD3DFormat;
    } rgszD3DFmt[] =
    {
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5),
        XTAG(D3DFMT_R6G5B5), XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5),
        XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8), XTAG(D3DFMT_A8B8G8R8),
        XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8),
        XTAG(D3DFMT_P8), XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8),
        XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16), XTAG(D3DFMT_V8U8),
        XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16),
        XTAG(D3DFMT_D24S8), XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8),
        XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2), XTAG(D3DFMT_DXT1),
        XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4),
        XTAG(D3DFMT_LIN_A8), XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8),
        XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8), XTAG(D3DFMT_LIN_R4G4B4A4),
        XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5),
        XTAG(D3DFMT_LIN_X8R8G8B8), XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8),
        XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8), XTAG(D3DFMT_LIN_D24S8),
        XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),
        XTAG(D3DFMT_UNKNOWN),
    };
    static const int cFmts = sizeof(rgszD3DFmt) / sizeof(rgszD3DFmt[0]);

    for(int ifmt = 0; ifmt < cFmts; ifmt++)
    {
        if(rgszD3DFmt[ifmt].d3dformat == d3dformat)
            return rgszD3DFmt[ifmt].szD3DFormat;
    }

    return rgszD3DFmt[cFmts - 1].szD3DFormat;
}

//=========================================================================
// Check whether specified format is linear
//=========================================================================
bool IsLinearFormat(DWORD Format)
{
    switch(Format)
    {
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_X8R8G8B8:

    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_L8:

    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        return true;
    }

    return false;
}

//=========================================================================
// Return number of bits per pixel/texel.
//=========================================================================
DWORD BitsPerPixelOfD3DFORMAT(DWORD Format)
{
    DWORD retval = 0;

    switch(Format)
    {
    case D3DFMT_A8R8G8B8:   // Q8W8V8U8
    case D3DFMT_X8R8G8B8:   // X8L8V8U8
    case D3DFMT_A8B8G8R8:
    case D3DFMT_B8G8R8A8:
    case D3DFMT_R8G8B8A8:
    case D3DFMT_V16U16:
    case D3DFMT_D24S8:
    case D3DFMT_F24S8:
    case D3DFMT_UYVY:
    case D3DFMT_YUY2:
    case D3DFMT_LIN_A8B8G8R8:
    case D3DFMT_LIN_A8R8G8B8:
    case D3DFMT_LIN_B8G8R8A8:
    case D3DFMT_LIN_R8G8B8A8:
    case D3DFMT_LIN_X8R8G8B8:
    case D3DFMT_LIN_D24S8:
    case D3DFMT_LIN_F24S8:
        retval = 32;
        break;

    case D3DFMT_R5G6B5:
    case D3DFMT_X1R5G5B5:
    case D3DFMT_A1R5G5B5:
    case D3DFMT_A4R4G4B4:
    case D3DFMT_R4G4B4A4:
    case D3DFMT_R5G5B5A1:
    case D3DFMT_R8B8:
    case D3DFMT_G8B8:   // V8U8
    case D3DFMT_A8L8:
    case D3DFMT_L16:
    case D3DFMT_L6V5U5:
    case D3DFMT_D16_LOCKABLE:  // D16
    case D3DFMT_F16:
    case D3DFMT_LIN_A1R5G5B5:
    case D3DFMT_LIN_A4R4G4B4:
    case D3DFMT_LIN_G8B8:
    case D3DFMT_LIN_R4G4B4A4:
    case D3DFMT_LIN_R5G5B5A1:
    case D3DFMT_LIN_R5G6B5:
    case D3DFMT_LIN_R6G5B5:
    case D3DFMT_LIN_R8B8:
    case D3DFMT_LIN_X1R5G5B5:
    case D3DFMT_LIN_A8L8:
    case D3DFMT_LIN_L16:
    case D3DFMT_LIN_D16:
    case D3DFMT_LIN_F16:
        retval = 16;
        break;

    case D3DFMT_A8:
    case D3DFMT_P8:
    case D3DFMT_L8:
    case D3DFMT_AL8:
    case D3DFMT_LIN_A8:
    case D3DFMT_LIN_AL8:
    case D3DFMT_LIN_L8:
        retval = 8;
        break;

    case D3DFMT_DXT1:
        retval = 4;
        break;

    case D3DFMT_DXT2: // DXT3
    case D3DFMT_DXT4: // DXT5
        retval = 8;
        break;

    default:
        CheckHR(E_FAIL);
        retval = 0;
        break;
    }

    return retval;
}

//=========================================================================
// Return file's last write time
//=========================================================================
UINT64 GetFileTime(LPCSTR lpFileName)
{
    WIN32_FILE_ATTRIBUTE_DATA fad;

    GetFileAttributesExA(lpFileName, GetFileExInfoStandard, &fad);
    return *(UINT64 *)&fad.ftLastWriteTime;
}

//=========================================================================
// Display d3d error then break into debugger
//=========================================================================
void DisplayError(const char *szCall, HRESULT hr)
{
    char szErr[512];

    if(hr)
    {
        UINT cch = _snprintf(szErr, sizeof(szErr), "FATAL: %s failed 0x%08lX: ", szCall, hr);

        D3DXGetErrorStringA(hr, &szErr[cch], sizeof(szErr) - cch - 1);
    }
    else
    {
        lstrcpynA(szErr, szCall, sizeof(szErr) - 1);
    }

    lstrcatA(szErr, "\n");
    OutputDebugStringA(szErr);

    _asm int 3;
}

//=========================================================================
// Formatted debug squirty
//=========================================================================
void _cdecl dprintf(LPCSTR lpFmt, ...)
{
    va_list arglist;
    char lpOutput[256];

    va_start(arglist, lpFmt);
    _vsnprintf(lpOutput, sizeof(lpOutput), lpFmt, arglist);
    va_end(arglist);

    OutputDebugStringA(lpOutput);
}

//=========================================================================
// Draw CScrText text buffer to front buffer
//=========================================================================
void CScrText::drawtext(bool fDebugSquirty)
{
    IDirect3DSurface8 *pFrontBuffer = NULL;

    D3DDevice_GetBackBuffer(-1, D3DBACKBUFFER_TYPE_MONO, &pFrontBuffer);
    if(pFrontBuffer)
    {
        // render results to the frontbuffer
        DWORD dx = 40;
        DWORD dy = 20;
        DWORD dwHeight;

        g_bitfont.GetTextStringLength(NULL, &dwHeight, NULL);
        dwHeight += 2;

        for(int iBuf = 0; iBuf < m_iLine; iBuf++)
        {
            if(fDebugSquirty)
                dprintf("%s\n", m_rgText[iBuf]);

            if(m_rgText[iBuf][0])
//                g_bitfont.DrawText(pFrontBuffer, m_rgText[iBuf], dx, dy, 0, 0xff9f9f9f, 0);

            dy += dwHeight;
        }

        RELEASE(pFrontBuffer);
    }
}

//=========================================================================
// Add a string to the CScrText string buffer
//=========================================================================
void _cdecl CScrText::printf(LPCSTR lpFmt, ...)
{
    va_list arglist;

    va_start(arglist, lpFmt);
    _vsnprintf(m_rgText[m_iLine], LINE_WIDTH, lpFmt, arglist);
    va_end(arglist);

    m_iLine = (m_iLine + 1) % NUM_LINES;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\wmvfunc.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wmvfunc.h

Abstract:

    wmvfunc utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\wmvfunc.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    wmvfunc.cpp

Abstract:

    wmvfunc tests

--*/

#include "wmvfunc.h"
#include "WMVTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
wmvfunc_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for wmvfunc

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CWMVTest	WMVTest;
	EXECUTE( WMVTest.Run() );

	XLaunchNewImage( NULL, NULL );

    //
    // Return the Hresult
    //

    return hr;
}

VOID 
WINAPI 
wmvfunc_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the wmvfunc tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test wmvfunc in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "wmvfunc", "Basic" );
    EXECUTE( wmvfunc_BasicTest() );

}

VOID 
WINAPI 
wmvfunc_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    wmvfunc_StartTest( NULL );
    wmvfunc_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( wmvfunc )
#pragma data_seg()

BEGIN_EXPORT_TABLE( wmvfunc )
    EXPORT_TABLE_ENTRY( "StartTest", wmvfunc_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", wmvfunc_EndTest )
END_EXPORT_TABLE( wmvfunc )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\Ini.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ini.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 11-Jul-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	11-Jul-2001 jeffsul
		Initial Version

--*/

#ifndef __INI_H__
#define __INI_H__

#include <xtl.h>
INT	GetIniInt( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  INT nDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
);

FLOAT GetIniFloat( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  FLOAT fDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
);

INT GetIniString( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  LPCTSTR lpDefault,       // return value if key name not found
  LPTSTR lpReturnedString,
  DWORD	nSize,
  LPCTSTR lpFileName  // initialization file name
);

DWORD GetIniConst( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  DWORD dwDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
);
	
#endif // #ifndef __INI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\Ini.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Ini.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 11-Jul-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	11-Jul-2001 jeffsul
		Initial Version

--*/

#include "Ini.h"
#include "utils.h"
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <stdio.h>
#include <assert.h>

#include <d3d8perf.h>
#include <d3d8types.h>

BOOL GetConst(const char *szStr, int cchStr, DWORD *pval);

INT	GetIniInt( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  INT nDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
)
{
	return GetPrivateProfileInt( lpAppName, lpKeyName, nDefault, lpFileName );
}


FLOAT GetIniFloat( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  FLOAT fDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
)
{
	CHAR szBuf[256];
	CHAR szDefault[256];

	FLOAT fVal = 0.0f;

	sprintf( szDefault, "%f", fDefault );

	GetPrivateProfileStringA( (LPCSTR)lpAppName, (LPCSTR)lpKeyName, szDefault, szBuf, 256, (LPCSTR)lpFileName );

	fVal = (FLOAT)atof( szBuf );

	return fVal;
}

INT GetIniString( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  LPCTSTR lpDefault,       // return value if key name not found
  LPTSTR lpReturnedString,
  DWORD	nSize,
  LPCTSTR lpFileName  // initialization file name
)
{
	INT nNumChars = 0;
	CHAR* pChar;

	nNumChars = GetPrivateProfileStringA( lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName );
	if ( 0 == nNumChars )
	{
		//lpReturnedString = lpDefault;
		return nNumChars;
	}

	pChar = strtok( lpReturnedString, " \t\n;" );
	strcpy( lpReturnedString, pChar );
	nNumChars = strlen( lpReturnedString );
	return nNumChars;
}

DWORD GetIniConst( LPCTSTR lpAppName,  // section name
  LPCTSTR lpKeyName,  // key name
  DWORD dwDefault,       // return value if key name not found
  LPCTSTR lpFileName  // initialization file name
)
{
	CHAR szBuf[256];
	CHAR* pChar;
	//CHAR szDefault[256];

	DWORD dwVal = 0L;
	INT	nNumChars = 0;
	BOOL bFound = FALSE;

	//sprintf( szDefault, "%d", fDefault );

	nNumChars = GetPrivateProfileStringA( (LPCSTR)lpAppName, (LPCSTR)lpKeyName, "", szBuf, 256, (LPCSTR)lpFileName );
	if ( 0 == nNumChars )
	{
		return dwDefault;
	}

	pChar = strtok( szBuf, " \t\n;" );

	bFound = GetConst( pChar, 256, &dwVal );
	if ( FALSE == bFound )
	{
		return dwDefault;
	}

	return dwVal;
}

// macros to help us define the size of our texcoords in fillrate.ini
static const DWORD T0_SIZE1 = D3DFVF_TEXCOORDSIZE1(0);
static const DWORD T0_SIZE2 = D3DFVF_TEXCOORDSIZE2(0);
static const DWORD T0_SIZE3 = D3DFVF_TEXCOORDSIZE3(0);
static const DWORD T0_SIZE4 = D3DFVF_TEXCOORDSIZE4(0);

static const DWORD T1_SIZE1 = D3DFVF_TEXCOORDSIZE1(1);
static const DWORD T1_SIZE2 = D3DFVF_TEXCOORDSIZE2(1);
static const DWORD T1_SIZE3 = D3DFVF_TEXCOORDSIZE3(1);
static const DWORD T1_SIZE4 = D3DFVF_TEXCOORDSIZE4(1);

static const DWORD T2_SIZE1 = D3DFVF_TEXCOORDSIZE1(2);
static const DWORD T2_SIZE2 = D3DFVF_TEXCOORDSIZE2(2);
static const DWORD T2_SIZE3 = D3DFVF_TEXCOORDSIZE3(2);
static const DWORD T2_SIZE4 = D3DFVF_TEXCOORDSIZE4(2);

static const DWORD T3_SIZE1 = D3DFVF_TEXCOORDSIZE1(3);
static const DWORD T3_SIZE2 = D3DFVF_TEXCOORDSIZE2(3);
static const DWORD T3_SIZE3 = D3DFVF_TEXCOORDSIZE3(3);
static const DWORD T3_SIZE4 = D3DFVF_TEXCOORDSIZE4(3);

enum { TEX_None, TEX_2d, TEX_Cubemap, TEX_Volume, TEX_Max };
enum { TIME_Present = 0x1, TIME_Render = 0x2 };

//=========================================================================
// Callback from inifile.cpp to get int string value
//=========================================================================
BOOL GetConst(const char *szStr, int cchStr, DWORD *pval)
{
    #undef XTAG
    #define XTAG(_tag) { _tag, #_tag }
    static const struct
    {
        int Val;
        const char *szStr;
    } rgszConsts[] =
    {
        // Pixel Shaders
        XTAG(PS_TEXTUREMODES_NONE), XTAG(PS_TEXTUREMODES_PROJECT2D), XTAG(PS_TEXTUREMODES_PROJECT3D),
        XTAG(PS_TEXTUREMODES_CUBEMAP), XTAG(PS_TEXTUREMODES_PASSTHRU), XTAG(PS_TEXTUREMODES_CLIPPLANE),
        XTAG(PS_TEXTUREMODES_BUMPENVMAP), XTAG(PS_TEXTUREMODES_BUMPENVMAP_LUM), XTAG(PS_TEXTUREMODES_BRDF),
        XTAG(PS_TEXTUREMODES_DOT_ST), XTAG(PS_TEXTUREMODES_DOT_ZW), XTAG(PS_TEXTUREMODES_DOT_RFLCT_DIFF),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC), XTAG(PS_TEXTUREMODES_DOT_STR_3D), XTAG(PS_TEXTUREMODES_DOT_STR_CUBE),
        XTAG(PS_TEXTUREMODES_DPNDNT_AR), XTAG(PS_TEXTUREMODES_DPNDNT_GB), XTAG(PS_TEXTUREMODES_DOTPRODUCT),
        XTAG(PS_TEXTUREMODES_DOT_RFLCT_SPEC_CONST), XTAG(PS_COMPAREMODE_S_LT), XTAG(PS_COMPAREMODE_S_GE),
        XTAG(PS_COMPAREMODE_T_LT), XTAG(PS_COMPAREMODE_T_GE), XTAG(PS_COMPAREMODE_R_LT),
        XTAG(PS_COMPAREMODE_R_GE), XTAG(PS_COMPAREMODE_Q_LT), XTAG(PS_COMPAREMODE_Q_GE),
        XTAG(PS_COMBINERCOUNT_MUX_LSB), XTAG(PS_COMBINERCOUNT_MUX_MSB), XTAG(PS_COMBINERCOUNT_SAME_C0),
        XTAG(PS_COMBINERCOUNT_UNIQUE_C0), XTAG(PS_COMBINERCOUNT_SAME_C1), XTAG(PS_COMBINERCOUNT_UNIQUE_C1),
        XTAG(PS_INPUTMAPPING_UNSIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_UNSIGNED_INVERT), XTAG(PS_INPUTMAPPING_EXPAND_NORMAL),
        XTAG(PS_INPUTMAPPING_EXPAND_NEGATE), XTAG(PS_INPUTMAPPING_HALFBIAS_NORMAL), XTAG(PS_INPUTMAPPING_HALFBIAS_NEGATE),
        XTAG(PS_INPUTMAPPING_SIGNED_IDENTITY), XTAG(PS_INPUTMAPPING_SIGNED_NEGATE), XTAG(PS_REGISTER_ZERO),
        XTAG(PS_REGISTER_DISCARD), XTAG(PS_REGISTER_C0), XTAG(PS_REGISTER_C1),
        XTAG(PS_REGISTER_FOG), XTAG(PS_REGISTER_V0), XTAG(PS_REGISTER_V1),
        XTAG(PS_REGISTER_T0), XTAG(PS_REGISTER_T1), XTAG(PS_REGISTER_T2),
        XTAG(PS_REGISTER_T3), XTAG(PS_REGISTER_R0), XTAG(PS_REGISTER_R1),
        XTAG(PS_REGISTER_V1R0_SUM), XTAG(PS_REGISTER_EF_PROD), XTAG(PS_REGISTER_ONE),
        XTAG(PS_REGISTER_NEGATIVE_ONE), XTAG(PS_REGISTER_ONE_HALF), XTAG(PS_REGISTER_NEGATIVE_ONE_HALF),
        XTAG(PS_CHANNEL_RGB), XTAG(PS_CHANNEL_BLUE), XTAG(PS_CHANNEL_ALPHA),
        XTAG(PS_FINALCOMBINERSETTING_CLAMP_SUM), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_V1), XTAG(PS_FINALCOMBINERSETTING_COMPLEMENT_R0),
        XTAG(PS_COMBINEROUTPUT_IDENTITY), XTAG(PS_COMBINEROUTPUT_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1),
        XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_1_BIAS), XTAG(PS_COMBINEROUTPUT_SHIFTLEFT_2), XTAG(PS_COMBINEROUTPUT_SHIFTRIGHT_1),
        XTAG(PS_COMBINEROUTPUT_AB_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_CD_BLUE_TO_ALPHA), XTAG(PS_COMBINEROUTPUT_AB_MULTIPLY),
        XTAG(PS_COMBINEROUTPUT_AB_DOT_PRODUCT), XTAG(PS_COMBINEROUTPUT_CD_MULTIPLY), XTAG(PS_COMBINEROUTPUT_CD_DOT_PRODUCT),
        XTAG(PS_COMBINEROUTPUT_AB_CD_SUM), XTAG(PS_COMBINEROUTPUT_AB_CD_MUX),
        XTAG(PS_DOTMAPPING_ZERO_TO_ONE), XTAG(PS_DOTMAPPING_MINUS1_TO_1_D3D), XTAG(PS_DOTMAPPING_MINUS1_TO_1_GL),
        XTAG(PS_DOTMAPPING_MINUS1_TO_1), XTAG(PS_DOTMAPPING_HILO_1), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_D3D), XTAG(PS_DOTMAPPING_HILO_HEMISPHERE_GL),
        XTAG(PS_DOTMAPPING_HILO_HEMISPHERE),

        // D3DFORMATs
        XTAG(D3DFMT_A8R8G8B8), XTAG(D3DFMT_X8R8G8B8), XTAG(D3DFMT_R5G6B5), XTAG(D3DFMT_R6G5B5),
        XTAG(D3DFMT_X1R5G5B5), XTAG(D3DFMT_A1R5G5B5), XTAG(D3DFMT_A4R4G4B4), XTAG(D3DFMT_A8),
        XTAG(D3DFMT_A8B8G8R8), XTAG(D3DFMT_B8G8R8A8), XTAG(D3DFMT_R4G4B4A4), XTAG(D3DFMT_R5G5B5A1),
        XTAG(D3DFMT_R8G8B8A8), XTAG(D3DFMT_R8B8), XTAG(D3DFMT_G8B8), XTAG(D3DFMT_P8),
        XTAG(D3DFMT_L8), XTAG(D3DFMT_A8L8), XTAG(D3DFMT_AL8), XTAG(D3DFMT_L16),
        XTAG(D3DFMT_V8U8), XTAG(D3DFMT_L6V5U5), XTAG(D3DFMT_X8L8V8U8), XTAG(D3DFMT_Q8W8V8U8),
        XTAG(D3DFMT_V16U16), XTAG(D3DFMT_D16_LOCKABLE), XTAG(D3DFMT_D16), XTAG(D3DFMT_D24S8),
        XTAG(D3DFMT_F16), XTAG(D3DFMT_F24S8), XTAG(D3DFMT_UYVY), XTAG(D3DFMT_YUY2),
        XTAG(D3DFMT_DXT1), XTAG(D3DFMT_DXT2), XTAG(D3DFMT_DXT3), XTAG(D3DFMT_DXT4),
        XTAG(D3DFMT_DXT5), XTAG(D3DFMT_LIN_A1R5G5B5), XTAG(D3DFMT_LIN_A4R4G4B4), XTAG(D3DFMT_LIN_A8),
        XTAG(D3DFMT_LIN_A8B8G8R8), XTAG(D3DFMT_LIN_A8R8G8B8), XTAG(D3DFMT_LIN_B8G8R8A8), XTAG(D3DFMT_LIN_G8B8),
        XTAG(D3DFMT_LIN_R4G4B4A4), XTAG(D3DFMT_LIN_R5G5B5A1), XTAG(D3DFMT_LIN_R5G6B5), XTAG(D3DFMT_LIN_R6G5B5),
        XTAG(D3DFMT_LIN_R8B8), XTAG(D3DFMT_LIN_R8G8B8A8), XTAG(D3DFMT_LIN_X1R5G5B5), XTAG(D3DFMT_LIN_X8R8G8B8),
        XTAG(D3DFMT_LIN_A8L8), XTAG(D3DFMT_LIN_AL8), XTAG(D3DFMT_LIN_L16), XTAG(D3DFMT_LIN_L8),
        XTAG(D3DFMT_LIN_D24S8), XTAG(D3DFMT_LIN_F24S8), XTAG(D3DFMT_LIN_D16), XTAG(D3DFMT_LIN_F16),

        XTAG(D3DMULTISAMPLE_NONE), XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMULTISAMPLE_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMULTISAMPLE_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMULTISAMPLE_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMULTISAMPLE_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DMS_NONE), XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_2_SAMPLES_MULTISAMPLE_QUINCUNX), XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_HORIZONTAL_LINEAR),
        XTAG(D3DMS_2_SAMPLES_SUPERSAMPLE_VERTICAL_LINEAR), XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_MULTISAMPLE_GAUSSIAN), XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_LINEAR),
        XTAG(D3DMS_4_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_9_SAMPLES_MULTISAMPLE_GAUSSIAN),
        XTAG(D3DMS_9_SAMPLES_SUPERSAMPLE_GAUSSIAN), XTAG(D3DMS_PREFILTER_FORMAT_DEFAULT),
        XTAG(D3DMS_PREFILTER_FORMAT_X1R5G5B5), XTAG(D3DMS_PREFILTER_FORMAT_R5G6B5),
        XTAG(D3DMS_PREFILTER_FORMAT_X8R8G8B8), XTAG(D3DMS_PREFILTER_FORMAT_A8R8G8B8),

        XTAG(D3DCLEAR_TARGET), XTAG(D3DCLEAR_ZBUFFER), XTAG(D3DCLEAR_STENCIL),

        // FVFs
        XTAG(D3DFVF_XYZ), XTAG(D3DFVF_XYZRHW), XTAG(D3DFVF_NORMAL), XTAG(D3DFVF_DIFFUSE),
        XTAG(D3DFVF_SPECULAR), XTAG(D3DFVF_TEX0), XTAG(D3DFVF_TEX1), XTAG(D3DFVF_TEX2),
        XTAG(D3DFVF_TEX3), XTAG(D3DFVF_TEX4),

        // textcoord sizes
        XTAG(T0_SIZE1), XTAG(T0_SIZE2), XTAG(T0_SIZE3), XTAG(T0_SIZE4),
        XTAG(T1_SIZE1), XTAG(T1_SIZE2), XTAG(T1_SIZE3), XTAG(T1_SIZE4),
        XTAG(T2_SIZE1), XTAG(T2_SIZE2), XTAG(T2_SIZE3), XTAG(T2_SIZE4),
        XTAG(T3_SIZE1), XTAG(T3_SIZE2), XTAG(T3_SIZE3), XTAG(T3_SIZE4),

        // D3DCMPs
        XTAG(D3DCMP_NEVER), XTAG(D3DCMP_LESS), XTAG(D3DCMP_EQUAL), XTAG(D3DCMP_LESSEQUAL),
        XTAG(D3DCMP_GREATER), XTAG(D3DCMP_NOTEQUAL), XTAG(D3DCMP_GREATEREQUAL), XTAG(D3DCMP_ALWAYS),

		// STENCILOPs
		XTAG(D3DSTENCILOP_KEEP),
		XTAG(D3DSTENCILOP_ZERO),
		XTAG(D3DSTENCILOP_REPLACE),
		XTAG(D3DSTENCILOP_INCRSAT),
		XTAG(D3DSTENCILOP_DECRSAT),
		XTAG(D3DSTENCILOP_INVERT),
		XTAG(D3DSTENCILOP_INCR),
		XTAG(D3DSTENCILOP_DECR),

		// D3DZBUFFERTYPE
		XTAG(D3DZB_TRUE), XTAG(D3DZB_USEW), XTAG(D3DZB_FALSE),

        XTAG(D3DTEXF_NONE), XTAG(D3DTEXF_POINT), XTAG(D3DTEXF_LINEAR), XTAG(D3DTEXF_ANISOTROPIC),
        XTAG(D3DTEXF_QUINCUNX), XTAG(D3DTEXF_GAUSSIANCUBIC),

        XTAG(TEX_None), XTAG(TEX_2d), XTAG(TEX_Cubemap), XTAG(TEX_Volume),

        XTAG(TIME_Present), XTAG(TIME_Render),

        // swaths
        XTAG(D3DSWATH_8), XTAG(D3DSWATH_16), XTAG(D3DSWATH_32),
        XTAG(D3DSWATH_64), XTAG(D3DSWATH_128), XTAG(D3DSWATH_OFF),

        XTAG(D3DCOLORWRITEENABLE_RED), XTAG(D3DCOLORWRITEENABLE_GREEN), XTAG(D3DCOLORWRITEENABLE_BLUE),
        XTAG(D3DCOLORWRITEENABLE_ALPHA), XTAG(D3DCOLORWRITEENABLE_ALL),

        // misc
        XTAG(FALSE), XTAG(TRUE)
    };

    for(int ifmt = 0; ifmt < ARRAYSIZE(rgszConsts); ifmt++)
    {
        if(!_strnicmp(rgszConsts[ifmt].szStr, szStr, cchStr))
        {
            // set val
            *pval = (DWORD)rgszConsts[ifmt].Val;
            return true;
        }
    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\WMVTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WMVTest.h

Abstract:

	Created to test WMV on the xbox

Author:

	Jeff Sullivan (jeffsul) 18-Jul-2001

Revision History:

	18-Jul-2001 jeffsul
		Initial Version

--*/

#ifndef __WMVTEST_H__
#define __WMVTEST_H__

#include "Test.h"

#define WMVTEST_APP_NAME	"WMVTEST"
#define	WMVTEST_INI_PATH	"D:\\WMVTest.ini"

class CWMVTest : public CTest
{
public:
	CWMVTest();
	~CWMVTest();

protected:
	HRESULT ReadIni();
	HRESULT InitGraphics();
	HRESULT DestroyGraphics();

	HRESULT Update();
	HRESULT Render();

private:
	LPDIRECT3DDEVICE8		m_pDevice;
	CHAR					m_szPath[MAX_PATH];
	UINT					m_nNumFilesPlayed;
	HANDLE					m_hFiles;
	WIN32_FIND_DATA			m_FindData;
};
	
#endif // #ifndef __WMVTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvApi\WmvApi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvApi.h

Abstract:

    WmvApi utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\func\wmvfunc\WMVTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WMVTest.cpp

Abstract:

	Created to test WMV on the xbox

Author:

	Jeff Sullivan (jeffsul) 18-Jul-2001

Revision History:

	18-Jul-2001 jeffsul
		Initial Version

--*/

#include "WMVTest.h"
#include "Ini.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <xgmath.h>

#include <stdio.h>

/*++

Routine Description:

	Test constructor

Arguments:

	None

Return Value:

	None

--*/
CWMVTest::CWMVTest()
{
	m_pDevice = NULL;
	m_nNumFilesPlayed = 0;
}


/*++

Routine Description:

	Test destructor

Arguments:

	None

Return Value:

	None

--*/
CWMVTest::~CWMVTest()
{
	RELEASE( m_pDevice );
}


/*++

Routine Description:

	read initialization variables from an ini file

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWMVTest::ReadIni()
{
	HRESULT hr = S_OK;

	CHAR	szSearchPath[MAX_PATH];

#define GetInt( var, def )			GetIniInt( WMVTEST_APP_NAME, #var, def, WMVTEST_INI_PATH )
#define GetFloat( var, def )		GetIniFloat( WMVTEST_APP_NAME, #var, def, WMVTEST_INI_PATH )
#define GetString( var, def, ret )	GetIniString( WMVTEST_APP_NAME, #var, def, ret, strlen(ret), WMVTEST_INI_PATH )
#define GetConst( var, def )		GetIniConst( WMVTEST_APP_NAME, #var, def, WMVTEST_INI_PATH )

	GetString( WMVFileDirectory, "D:\\Media\\", m_szPath );

	sprintf( szSearchPath, "%s*.wma", m_szPath );
	
	m_hFiles = FindFirstFile( szSearchPath, &m_FindData );

	return hr;
}


/*++

Routine Description:

	initialize graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWMVTest::InitGraphics()
{
	HRESULT hr = S_OK;

	D3DPRESENT_PARAMETERS	d3dpp;

	// Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	EXECUTE( Direct3D_CreateDevice(	D3DADAPTER_DEFAULT, 
									D3DDEVTYPE_HAL,
									NULL, 
									D3DCREATE_HARDWARE_VERTEXPROCESSING, 
									&d3dpp, 
									&m_pDevice) );
    if ( FAILED ( hr ) )
	{
        return hr;
    }

	// set up view and projection matrices
	XGMATRIX	matWorld, matView, matProj;

	// world matrix is simply identity
	XGMatrixIdentity( &matWorld );

	// camera is at (0,0,-1) looking at origin
    XGMatrixLookAtLH( &matView, &XGVECTOR3( 0.0f, 0.0f, -1.0f ),
                                  &XGVECTOR3( 0.0f, 0.0f, 0.0f ), 
                                  &XGVECTOR3( 0.0f, 1.0f, 0.0f ) );
	// view volume is 12x10x10, near clip plane at z=0 and far clip at z=10
	XGMatrixOrthoLH( &matProj, 12.0f, 10.0f, 1.0f, 11.0f );

	// apply the matrices to d3d
	m_pDevice->SetTransform( D3DTS_WORLD, &matWorld );
    m_pDevice->SetTransform( D3DTS_VIEW, &matView );
	m_pDevice->SetTransform( D3DTS_PROJECTION, &matProj );

	// no lighting
	m_pDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

	// no culling
	m_pDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

	return hr;
}


/*++

Routine Description:

	cleanup graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWMVTest::DestroyGraphics()
{
	HRESULT hr = S_OK;

	RELEASE( m_pDevice );

	return hr;
}


/*++

Routine Description:

	update the scene each frame

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWMVTest::Update()
{
	HRESULT hr = S_OK;
	
	CHAR szFullName[MAX_PATH];
	
	sprintf( szFullName, "%s%s", m_szPath, m_FindData.cFileName );
	
//	EXECUTE( PlayWmvFile( szFullName, true ) );
//	if ( SUCCEEDED( hr ) )
//	{
//		m_nNumFilesPlayed++;
//	}
	
	m_bQuit = FindNextFile( m_hFiles, &m_FindData );

	return hr;
}


/*++

Routine Description:

	render the scene to the screen

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWMVTest::Render()
{
	HRESULT hr = S_OK;
			
#if 0
	// clear the rendering surface
	EXECUTE( m_pDevice->Clear( 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( 0, 0, 255 ), 1.0f, 0L ) );

	// begin the scene
	EXECUTE( m_pDevice->BeginScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// submit each bit of geometry


	// render the scene to the surface
	EXECUTE( m_pDevice->EndScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// flip the surface to the screen
	EXECUTE( m_pDevice->Present( NULL, NULL, NULL, NULL ) );
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvApi\WmvApi.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvApi.cpp

Abstract:

    WmvApi tests

--*/

#include "WmvApi.h"
#include "WmvApiTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
WmvApi_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for WmvApi

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CWmvApiTest			ApiTest;
	EXECUTE( ApiTest.Run() );

    //
    // Return the Hresult
    //
	XLaunchNewImage( NULL, NULL );

    return hr;
}

VOID 
WINAPI 
WmvApi_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the WmvApi tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test WmvApi in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "WmvApi", "Basic" );
    EXECUTE( WmvApi_BasicTest() );

}

VOID 
WINAPI 
WmvApi_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    WmvApi_StartTest( NULL );
    WmvApi_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WmvApi )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WmvApi )
    EXPORT_TABLE_ENTRY( "StartTest", WmvApi_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WmvApi_EndTest )
END_EXPORT_TABLE( WmvApi )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvApi\WmvApiTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvApiTest.h

Abstract:

	General API tests including parameter tests.

Author:

	Jeff Sullivan (jeffsul) 13-Sep-2001

Revision History:

	13-Sep-2001 jeffsul
		Initial Version

--*/

#ifndef __WMVAPITEST_H__
#define __WMVAPITEST_H__

#include "..\WmvCommon\Test.h"

#include <wmvxmo.h>

//#include "..\WmvCommon\FrameQueue.h"
//#include "..\WmvCommon\bitfont.h"

#define WMV_API_TEST_NUM_FRAMES		16
#define WMV_API_TEST_NUM_PACKETS	48
#define WMV_API_TEST_PACKET_SIZE	4096

// Vertex definition for the screen-space quad
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)
typedef struct {
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;

typedef struct _TVERTEX
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
	FLOAT u, v;         // Texture coordinates
} TVERTEX;

class CWmvApiTest : public CTest
{
public:
	CWmvApiTest();
	~CWmvApiTest();

protected:
	HRESULT ReadIni();

private:
	VOID ExecuteParameterChecks();
};	
#endif // #ifndef __WMVAPITEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvApi\WmvApiTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvApiTest.cpp

Abstract:

	General API tests including parameter tests.

Author:

	Jeff Sullivan (jeffsul) 13-Sep-2001

Revision History:

	13-Sep-2001 jeffsul
		Initial Version

--*/

#include "WmvApiTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

/*++

Routine Description:

	Test constructor

Arguments:

	None

Return Value:

	None

--*/
CWmvApiTest::CWmvApiTest()
{
}


/*++

Routine Description:

	Test destructor

Arguments:

	None

Return Value:

	None

--*/
CWmvApiTest::~CWmvApiTest()
{
}


/*++

Routine Description:

	read initialization variables from an ini file

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvApiTest::ReadIni()
{
	HRESULT hr = S_OK;

	// grab media files from server
#define CREATE_FLAG	MLCOPY_IFNEWER
	MLSetErrorLevel( 3 );
	MEDIAFILEDESC MediaFiles[] =
	{
		{"ml test/",	"T:\\ml test\\",			CREATE_FLAG},
		{NULL,									NULL,								0}
	};
	EXECUTE( LoadMedia( MediaFiles ) );

	ExecuteParameterChecks();

	m_bQuit = TRUE;

	return hr;
}


#define CHECKEXPECTED( expected, func )		\
	hr = func;								\
	if ( expected != hr )					\
	{										\
		DbgPrint( #func ## " returned %d, expected %d\n", hr, expected );	\
		ASSERT( 0 );						\
	}										\
	if ( SUCCEEDED( hr ) )					\
	{										\
		RELEASE( pWmvDecoder );				\
	}

LPBYTE g_AllocBuffer = NULL;
HANDLE g_File = INVALID_HANDLE_VALUE;
DWORD CALLBACK ExampleCallback(
    LPVOID pvContext,
    DWORD dwOffset,
    DWORD dwByteCount,
    LPVOID* ppvData
    )
{
	DWORD cb;
	ASSERT(dwByteCount <= 512);
	if (SetFilePointer(g_File, dwOffset, NULL, FILE_BEGIN) != dwOffset ||
		!ReadFile(g_File, g_AllocBuffer, dwByteCount, &cb, NULL)) {
		XDBGWRN("WMVDEC", "ReadFile failed: %d", GetLastError());
		return 0;
	}

	if ( NULL != pvContext && 64 != *(INT*)pvContext )
	{
		DbgPrint( "pvContext passed improperly (value = %d)\n", *(INT*)pvContext );
		ASSERT( 0 );	
	}
	
	*ppvData = g_AllocBuffer;
	return cb;
}

VOID
CWmvApiTest::ExecuteParameterChecks()
{
	HRESULT				hr					= S_OK;
	HRESULT				hrExpected			= S_OK;
	LPWMVDECODER		pWmvDecoder			= NULL;
	LPWMVVIDEOINFO		pWmvVideoInfo		= NULL;
	CHAR				szBadFileName[]		= "test.file";
	CHAR				szFileName[]		= "T:\\WMV\\test.asf";
	INT					nTest				= 64;

	// set up variables for callback function
	g_File = CreateFile( szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == g_File )
	{
		DbgPrint( "Unable to open file %s\n", szFileName );
		return;
	}
	DWORD bufsize = 2 * ( 2*1024 + 64*1024 );
    g_AllocBuffer = (LPBYTE) VirtualAlloc( NULL, bufsize, MEM_COMMIT|MEM_RESERVE, PAGE_READWRITE);
	if ( NULL == g_AllocBuffer )
	{
		CloseHandle( g_File );
		DbgPrint( "Ran out of memory allocating buffer\n" );
	}

	// check IN LPCSTR pszFileName
	hrExpected = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szBadFileName, NULL, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szBadFileName, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szBadFileName, ExampleCallback, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szBadFileName, ExampleCallback, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
	hrExpected = S_OK;
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, ExampleCallback, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, ExampleCallback, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
	// needs better handling of this case:
	//CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, NULL, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	//CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );

	// check IN LPFNWMVXMODATACALLBACK pfnCallback
	hrExpected = S_OK;
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, ExampleCallback, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, ExampleCallback, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
	// check IN LPVOID pvContext
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, ExampleCallback, WMVVIDEOFORMAT_RGB32, &nTest, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( NULL, ExampleCallback, WMVVIDEOFORMAT_YUY2, &nTest, &pWmvDecoder ) );


	// check IN DWORD dwVideoOutputFormat
	hrExpected = S_OK;
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, 0, NULL, &pWmvDecoder ) ); // zero maps to WMVVIDEOFORMAT_RGB32
//	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_RGB32, NULL, &pWmvDecoder ) );
	CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder ) );
	hrExpected = E_FAIL;
	// needs better handling of this case:
	//CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, ULONG_MAX, NULL, &pWmvDecoder ) );

    // check OUT LPWMVDECODER* ppWmvDecoder
	hrExpected = E_FAIL;
	// unhandled exception: passing NULL for OUT LPWMVDECODER* ppWmvDecoder
	//CHECKEXPECTED( E_FAIL, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_RGB32, NULL, NULL ) );
	// produces compiler error (as expected):
	//CHECKEXPECTED( hrExpected, WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_RGB32, NULL, &pWmvVideoInfo ) );


	// destroy variables for callback function
	VirtualFree( g_AllocBuffer, 0, MEM_RELEASE );
	CloseHandle( g_File );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvCommon\Test.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.cpp

Abstract:

	Abstract class implementation to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#include "Test.h"

#include <xdbg.h>
#include <xlog.h>
#include <macros.h>

#include <stdio.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;


//------------------------------------------------------------------------------
//	Inititialize static variable to FALSE so that XInitDevices() is called
//------------------------------------------------------------------------------

BOOL CTest::m_bInitDevicesCalled = FALSE;


/*++

	CTest constructor

Routine Description:

	constructor

Arguments:

	None

Return Value:

	None

--*/

CTest::CTest()
{
	m_bQuit = FALSE;
}


/*++

	CTest destructor

Routine Description:

	destructor

Arguments:

	None

Return Value:

	None

--*/

CTest::~CTest()
{
}


/*++

	Run

Routine Description:

	The test's main loop: initialize, enter loop, destroy

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Run()
{
	HRESULT hr = S_OK;

	// initialize all resources/devices
	EXECUTE( Init() );
	if ( FAILED( hr ) )
	{
		Destroy();
		return hr;
	}
	
	// loop for as long as test needs to run
	while ( !m_bQuit )
	{
		// calculate time change since last frame and update time variables
		DWORD dwTempTime = timeGetTime();
		m_dwDeltaTime = dwTempTime - m_dwCurrentTime;
		m_dwCurrentTime = dwTempTime;
		
		// do the real work of the test inside these functions
		EXECUTE( ProcessInput() )
		EXECUTE( Update() )
		EXECUTE( Render() )
	}
	
	// clean up 
	EXECUTE( Destroy() )

	return hr;
}


/*++

	Init

Routine Description:

	Common initialization function for all tests, calls inheritable functions to do
	initialization and starts timers

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Init()
{
	HRESULT hr = S_OK;

	EXECUTE( ReadIni() )
	if ( FAILED( hr ) )
	{
		return hr;
	}

	EXECUTE( InitGraphics() )
	if ( FAILED ( hr ) )
	{
		return hr;
	}

	EXECUTE( InitAudio() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		return hr;
	}

	if ( !m_bInitDevicesCalled )
	{
		// we only need to call this once for all tests, hence static declaration of m_bInitDevicesCalled
		XInitDevices( 0, NULL );
		m_bInitDevicesCalled = TRUE;
	}

	EXECUTE( InitInput() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		return hr;
	}

	EXECUTE( InitResources() )
	if ( FAILED ( hr ) )
	{
		DestroyGraphics();
		DestroyAudio();
		DestroyInput();
		return hr;
	}

	m_dwStartTime = m_dwCurrentTime = timeGetTime(); 

	return hr;
}


/*++

	Destroy

Routine Description:

	Common de-allocation function for all tests, calls inheritable functions to do
	un-initialization/deletion

Arguments:

	None

Return Value:

	None

--*/

HRESULT CTest::Destroy()
{
	HRESULT hr = S_OK;

	EXECUTE( DestroyGraphics() )
	EXECUTE( DestroyAudio() )
	EXECUTE( DestroyInput() )
	EXECUTE( DestroyResources() )

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CTest::InitD3DDevice( 
	LPDIRECT3DDEVICE8* ppDevice 
)
{
	D3DPRESENT_PARAMETERS	d3dpp;

	// Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_ONE;

	return Direct3D_CreateDevice(	D3DADAPTER_DEFAULT, 
									D3DDEVTYPE_HAL,
									NULL, 
									D3DCREATE_HARDWARE_VERTEXPROCESSING, 
									&d3dpp, 
									ppDevice);
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT	CTest::GetNextInputState( 
	HANDLE* phInputDevice, 
	XINPUT_STATE* pInputState 
)
{
	HRESULT hr = S_OK;

	DWORD dwDeviceMap;
	DWORD dwSuccess;
	BOOL bDeviceChanges;
	DWORD dwInsertions;
	DWORD dwRemovals;

	bDeviceChanges = XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );
	if ( bDeviceChanges )
	{
		if ( dwInsertions & XDEVICE_PORT0_MASK )
		{
			*phInputDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
			if ( *phInputDevice == NULL )
			{
				DbgPrint( "Error Opening Input\n" );
				return E_FAIL;
			}
		}
		
		if ( dwRemovals & XDEVICE_PORT0_MASK )
		{
			DbgPrint( "Gamepad removed from Port 0\n" );
			return E_FAIL;
		}
	}

	dwDeviceMap = XGetDevices( XDEVICE_TYPE_GAMEPAD );
	if ( !(dwDeviceMap & XDEVICE_PORT0_MASK) ) 
	{
		return S_OK;
	}
	else if ( NULL == *phInputDevice )
	{
		*phInputDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
		if ( *phInputDevice == NULL )
		{
			DWORD dwError;
			dwError = GetLastError();
			DbgPrint( "Error Opening Input. Error#: %d\n", dwError);
			return E_FAIL;
		}
	}

	dwSuccess = XInputGetState( *phInputDevice, pInputState );
	if ( dwSuccess != ERROR_SUCCESS )
	{
		DbgPrint( "Error Getting Input State\n" );
		return dwSuccess;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvCommon\Test.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	Test.h

Abstract:

	Abstract class to inherit from for individual tests

Author:

	Jeff Sullivan (jeffsul) 14-Jun-2001

Revision History:

	14-Jun-2001 jeffsul
		Initial Version

--*/

#ifndef __TEST_H__
#define __TEST_H__

#include <xtl.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

class CTest
{
public:

	CTest();												//	constructor: for now only sets m_bQuit to FALSE
	virtual ~CTest();										//	virtually destroy class (and inherited class)
	HRESULT Run();											//	the test's main loop

protected:

	//------------------------------------------------------------------------------
	//	Overridable functions to do the test's initialization/cleanup (before and
	//	after main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ReadIni() { return S_OK; }				//	get initialization parameters from an ini file
	virtual HRESULT InitGraphics() { return S_OK; }			//	init d3d here (i.e., create a device, etc.)
	virtual HRESULT DestroyGraphics() { return S_OK; }		//	cleanup anything created in InitGraphics() here
	virtual HRESULT InitInput() { return S_OK; }			//	init input devices (i.e., call XInputOpen(), not XInitDevices())
	virtual HRESULT DestroyInput() { return S_OK; }			//	cleanup anything created in InitInput() here
	virtual HRESULT InitAudio() { return S_OK; }			//	init audio devices here
	virtual HRESULT DestroyAudio() { return S_OK; }			//	cleanup anything created in InitAudio() here
	virtual HRESULT InitResources() { return S_OK; }		//	init resources (models, textures, sound files, etc.) here
	virtual HRESULT DestroyResources() { return S_OK; }		//	cleanup anything created in InitResources() here


	//------------------------------------------------------------------------------
	//	Overidable functions to do the test's real work (inside the main loop)
	//------------------------------------------------------------------------------

	virtual HRESULT ProcessInput() { return S_OK; }			//	should be used to get any input from devices and process it
	virtual HRESULT Update() { return S_OK; }				//	any updates that need to be performed each frame are done here
	virtual HRESULT Render() { return S_OK; }				//	draw everything to the screen here


	//------------------------------------------------------------------------------
	//	Utility functions for common use
	//------------------------------------------------------------------------------

	HRESULT InitD3DDevice( LPDIRECT3DDEVICE8* ppDevice );							// Creates a d3d device with default parameters
	HRESULT	GetNextInputState( HANDLE* phInputDevice, XINPUT_STATE* pInputState );	// Polls the next input state while checking for insertions/removals


	//------------------------------------------------------------------------------
	//	Protected data members that are useful to the inherited classes
	//------------------------------------------------------------------------------

	BOOL				m_bQuit;							//	loop continues while FALSE
	DWORD				m_dwStartTime;						//	start time of test
	DWORD				m_dwCurrentTime;					//	current time of test
	DWORD				m_dwDeltaTime;						//	time between current frame and previous

private:

	//------------------------------------------------------------------------------
	//	Private data member that should not be visible to inherited classes
	//------------------------------------------------------------------------------

	HRESULT Init();											//	calls overridable functions to do all initialization
	HRESULT Destroy();										//	calls overridable functions to do all cleanup

	static BOOL			m_bInitDevicesCalled;				//	keeps track of whether XInitDevices() has been called
};
	
#endif // #ifndef __TEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvCommon\WMVPlayer.h ===
//-----------------------------------------------------------------------------
// File: WMVPlayer.h
//
// Desc: Definition of WMV playback helper class
//
// Hist: 10.10.01 - New for Novermber XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include <xtl.h>
#include <wmvxmo.h>


// This structure is used to hold data about a video frame
typedef struct {
    LPDIRECT3DTEXTURE8  pTexture;
    REFERENCE_TIME      rtTimestamp;
    BYTE*               pBits;
} VIDEOFRAME;

// You'll need to adjust NUM_PACKETS based off your video content
// to ensure that you never run out during the course of playback
// There is an assert that will fire if the class runs out of 
// packets
// Packet Size needs to be large enough to hold at least 2048
// decoded samples
#define NUM_PACKETS 256
#define PACKET_SIZE 2048 * 2 * 2


class CWMVPlayer
{
public:
    CWMVPlayer();
    ~CWMVPlayer();

    HRESULT Initialize( LPDIRECT3DDEVICE8 pd3dDevice, 
                        LPDIRECTSOUND8 pDSound );       // Initialize the player
    HRESULT OpenFile( CHAR* strFilename );              // Open a file for playback
    HRESULT CloseFile();                                // Close file
    HRESULT GetVideoInfo( WMVVIDEOINFO* pVideoInfo );   // Get video info

    BOOL    IsReady();                                  // Ready to switch?
    HRESULT GetTexture( LPDIRECT3DTEXTURE8 pTexture );  // Copy to texture
    HRESULT DecodeNext();                               // Decode next frame

	DWORD				m_dwDroppedFrames;

private:
    BOOL FindFreePacket( DWORD * pdwIndex );            // Find a free audio packet

    LPDIRECT3DDEVICE8   m_pd3dDevice;                   // Direct3D device
    LPWMVDECODER        m_pWMVDecoder;                  // WMV Decoder XMO
    WMVVIDEOINFO        m_wmvVideoInfo;                 // Video format info
    WAVEFORMATEX        m_wfx;                          // Audio format info
    REFERENCE_TIME      m_rtDuration;                   // Video duration

    REFERENCE_TIME      m_rtStartTime;                  // Start time
    BOOL                m_bFirstFrame;                  // BOOL to track first frame

    VIDEOFRAME          m_VideoFrame;                   // Video frame

    LPDIRECTSOUND8      m_pDSound;                      // DirectSound object
    LPDIRECTSOUNDSTREAM m_pStream;                      // Stream for playback
    DWORD               m_adwStatus[NUM_PACKETS];       // Packet status
    BYTE*               m_pbSampleData;                 // Audio buffer

	BOOL				m_bGotTexture;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvMemory\WmvMemory.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvMemory.h

Abstract:

    WmvMemory utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvMemory\WmvMemoryTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvMemTest.cpp

Abstract:

	General MEM tests including parameter tests.

Author:

	Jeff Sullivan (jeffsul) 13-Sep-2001

Revision History:

	13-Sep-2001 jeffsul
		Initial Version

--*/

#include "WmvMemoryTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

#define WMVTEST_APP_NAME	"WMVTEST"
#define	WMVTEST_INI_PATH	"D:\\WMVTest.ini"

/*++

Routine Description:

	Test constructor

Arguments:

	None

Return Value:

	None

--*/
CWmvMemTest::CWmvMemTest()
{
}


/*++

Routine Description:

	Test destructor

Arguments:

	None

Return Value:

	None

--*/
CWmvMemTest::~CWmvMemTest()
{
}


/*++

Routine Description:

	read initialization variables from an ini file

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvMemTest::ReadIni()
{
	HRESULT hr = S_OK;

	
	MLSetErrorLevel( 1 );
#define CREATE_FLAG	MLCOPY_IFNEWER
	MEDIAFILEDESC MediaFiles[] =
	{
		{"wmv/ms_wmv_v8/(\\w*).(\\w*)%1",	"T:\\WMV\\Mem\\",			CREATE_FLAG},
		{NULL,									NULL,								0}
	};
	EXECUTE( LoadMedia( MediaFiles ) );

	// get initial memory status before tests
	DWORD				dwAvailPhys			= 0;
	MEMORYSTATUS		MemStatus			= {0};

	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwAvailPhys = MemStatus.dwAvailPhys;

	// check memory under poor conditions
	LPVOID	pvBuffer = NULL;
	DWORD	dwMemSize = WMV_MEM_TEST_LARGE_MEMORY_SIZE;
	while ( NULL == pvBuffer )
	{
		pvBuffer = malloc( dwMemSize );
		dwMemSize = dwMemSize >> 1;
	}

	ExecuteMemoryChecks();
	free( pvBuffer );

	// check memory under optimal conditions
	ExecuteMemoryChecks();

	// get memory status after all tests have been done
	Sleep( 5000 );
	GlobalMemoryStatus( &MemStatus );
	DbgPrint( "[WmvMemoryTest] info: available memory\n\tinitial = %d\n\tending  = %d\n\tdifference = %d\n", MemStatus.dwAvailPhys, dwAvailPhys, dwAvailPhys-MemStatus.dwAvailPhys );

	m_bQuit = TRUE;

	return hr;
}

VOID
CWmvMemTest::ExecuteMemoryChecks()
{
	HRESULT				hr					= S_OK;
	HRESULT				hrExpected			= S_OK;
	LPWMVDECODER		pWmvDecoder			= NULL;
	LPWMVVIDEOINFO		pWmvVideoInfo		= NULL;
	MEMORYSTATUS		MemStatus			= {0};
	CHAR				szBadFileName[]		= "test.file";
	CHAR				szFileName[MAX_PATH];//= "T:\\WMV\\test.asf";
	INT					nTest				= 64;
	DWORD				dwInitAvailPhys		= 0;
	DWORD				dwAvailPhys 		= 0;
	UINT				i					= 0;


	WIN32_FIND_DATA	FindData;
	HANDLE hFiles = FindFirstFile( "T:\\WMV\\Mem\\*.*", &FindData );
	if ( INVALID_HANDLE_VALUE == hFiles )
	{
		DbgPrint( "[WmvMemoryTest] error: no files to open.\n" );
		return;
	}
	sprintf( szFileName, "T:\\WMV\\Mem\\%s", FindData.cFileName );

	//------------------------------------------------------------------------------
	//	see how WmvCreateDecoder()/Release() affect memory
	//------------------------------------------------------------------------------

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwInitAvailPhys = dwAvailPhys  = MemStatus.dwAvailPhys;
	DbgPrint( "[WmvMemoryTest] info: initial available memory = %d\n", MemStatus.dwAvailPhys );

	// run WmvCreateDecoder()/Release()
	DbgPrint( "[WmvMemoryTest] info: testing WmvCreateDecoder()/Release()...\n" );
	for ( i=0; i < 10*WMV_MEM_TEST_NUM_TESTS; i++ )
	{
		hr = WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder );
		if ( FAILED( hr ) )
		{
			DbgPrint( "[WmvMemoryTest] error: WmvCreateDecoder failed (error %d)\n", hr );
		}
		RELEASE( pWmvDecoder );
	}

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[WmvMemoryTest] warning: Possible leak in WmvCreateDecoder.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}

	//------------------------------------------------------------------------------
	//	create a decoder to test other functions
	//------------------------------------------------------------------------------

	hr = WmvCreateDecoder( szFileName, NULL, WMVVIDEOFORMAT_YUY2, NULL, &pWmvDecoder );
	if ( FAILED( hr ) )
	{
		DbgPrint( "[WmvMemoryTest] error: WmvCreateDecoder failed (error %d)\n", hr );
		DbgPrint( "[WmvMemoryTest] error: Unable to test Get... functions\n" );
		return;
	}

	XMEDIAINFO		Info;
	WAVEFORMATEX	AudioInfo;
	WMVVIDEOINFO	VideoInfo;
	REFERENCE_TIME	rtPlayDuration, rtPreroll;
	DWORD			dwStatus;

	//------------------------------------------------------------------------------
	//	see how Get...() functions affect memory
	//------------------------------------------------------------------------------

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwAvailPhys  = MemStatus.dwAvailPhys;

	// run Get...() functions
	DbgPrint( "[WmvMemoryTest] info: testing Get...()...\n" );
	for ( i=0; i < WMV_MEM_TEST_NUM_TESTS; i++ )
	{
		pWmvDecoder->GetAudioInfo( &AudioInfo );
		pWmvDecoder->GetVideoInfo( &VideoInfo );
		pWmvDecoder->GetPlayDuration( &rtPlayDuration, &rtPreroll );
		pWmvDecoder->GetInfo( &Info );
		pWmvDecoder->GetStatus( &dwStatus );
	}

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[WmvMemoryTest] warning: Possible leak in IWMVDecoder::Get... functions.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, WMV_MEM_TEST_NUM_TESTS );
	}

	//------------------------------------------------------------------------------
	//	create buffers for decoding tests
	//------------------------------------------------------------------------------

	XMEDIAPACKET	VideoOutputPacket, AudioOutputPacket;
	DWORD			dwVideoStatus, dwAudioStatus;
	DWORD			dwVideoCompletedSize, dwAudioCompletedSize;
	LPVOID			pvVideoBuffer, pvAudioBuffer;
	REFERENCE_TIME	rtVideo, rtAudio;
	DWORD			dwMaxVideoSize = VideoInfo.dwWidth * VideoInfo.dwHeight * VideoInfo.dwOutputBitsPerPixel / 8;
	
	pvVideoBuffer = malloc( dwMaxVideoSize );
	if ( NULL == pvVideoBuffer )
	{
		DbgPrint( "[WmvMemoryTest] error: Unable to allocate video buffer\n" );
		RELEASE( pWmvDecoder );
		return;
	}
	pvAudioBuffer = malloc( WMV_MEM_TEST_PACKET_SIZE );
	if ( NULL == pvAudioBuffer )
	{
		DbgPrint( "[WmvMemoryTest] error: Unable to allocate audio buffer\n" );
		free( pvVideoBuffer );
		RELEASE( pWmvDecoder );
		return;
	}


	VideoOutputPacket.pdwStatus = &dwVideoStatus;
	AudioOutputPacket.pdwStatus = &dwAudioStatus;
	VideoOutputPacket.pdwCompletedSize = &dwVideoCompletedSize;
	AudioOutputPacket.pdwCompletedSize = &dwAudioCompletedSize;
	VideoOutputPacket.pvBuffer = pvVideoBuffer;
	AudioOutputPacket.pvBuffer = pvAudioBuffer;
	AudioOutputPacket.dwMaxSize = WMV_MEM_TEST_PACKET_SIZE;
	VideoOutputPacket.dwMaxSize = dwMaxVideoSize;
	VideoOutputPacket.prtTimestamp = &rtVideo;
	AudioOutputPacket.prtTimestamp = &rtAudio;

	//------------------------------------------------------------------------------
	//	see how ProcessMultiple()/Flush() affect memory
	//------------------------------------------------------------------------------

	CheckProcessMultiple( pWmvDecoder, &VideoOutputPacket, &AudioOutputPacket, 250, FALSE );
	CheckProcessMultiple( pWmvDecoder, &VideoOutputPacket, &AudioOutputPacket, 100, TRUE );

	free( pvVideoBuffer );
	free( pvAudioBuffer );

	//------------------------------------------------------------------------------
	//	see how AddRef()/Release affects memory/refcount
	//------------------------------------------------------------------------------
	
	DWORD		dwRefCount;

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwAvailPhys  = MemStatus.dwAvailPhys;

	// run AddRef()/Release()
	pWmvDecoder->AddRef();
	dwRefCount = pWmvDecoder->Release();
	if ( 1 != dwRefCount )
	{
		DbgPrint( "[WmvMemoryTest] warning: Unexpected RefCount: %d\n", dwRefCount );
	}
	
	for ( i=0; i < WMV_MEM_TEST_NUM_TESTS; i++ )
	{
		pWmvDecoder->AddRef();
	}
	for ( i=0; i < WMV_MEM_TEST_NUM_TESTS; i++ )
	{
		pWmvDecoder->Release();
	}

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[WmvMemoryTest] warning: Possible leak in IWMVDecoder::AddRef()/Release() functions.  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, WMV_MEM_TEST_NUM_TESTS );
	}

	//------------------------------------------------------------------------------
	//	Compare overall memory usage during this run
	//------------------------------------------------------------------------------

	dwRefCount = pWmvDecoder->Release();
	if ( 0 != dwRefCount )
	{
		DbgPrint( "[WmvMemoryTest] warning: Unexpected RefCount: %d\n", dwRefCount );
	}

	// check overall memory usage
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	DbgPrint( "[WmvMemoryTest] info: available memory\n\tinitial = %d\n\tending  = %d\n\tdifference = %d\n", MemStatus.dwAvailPhys, dwInitAvailPhys, dwInitAvailPhys-MemStatus.dwAvailPhys );
}


VOID 
CWmvMemTest::CheckProcessMultiple( 
	LPWMVDECODER	pWmvDecoder,
	LPCXMEDIAPACKET pVideoOutputPacket,
    LPCXMEDIAPACKET pAudioOutputPacket,
	UINT			nNumRuns, 
	BOOL			bDecodeEntire 
)
{
	HRESULT				hr					= DS_OK;
	MEMORYSTATUS		MemStatus			= {0};
	DWORD				dwAvailPhys 		= 0;

	// get current memory status
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	dwAvailPhys  = MemStatus.dwAvailPhys;

	// run ProcessMultiple()/Flush()
	for ( UINT i=0; i < nNumRuns; i++ )
	{
		DbgPrint( "[WmvMemoryTest] info: testing ProcessMultiple()... (run %d/%d)\n", i, nNumRuns );
		hr = DS_OK;
		while ( DS_OK == hr )
		{
			hr = pWmvDecoder->ProcessMultiple( pVideoOutputPacket, pAudioOutputPacket );
			if ( FALSE == bDecodeEntire && rand()%100 > 97 )
			{
				DbgPrint( "[WmvMemoryTest] info: ending stream early (run %d/%d)\n", i, nNumRuns );
				hr = S_FALSE;
			}
		}

		if ( S_FALSE != hr )
		{
			DbgPrint( "[WmvMemoryTest] warning: ProcessMultiple() failed (error %d) after %d tests\n", hr, i );
		}

		hr = pWmvDecoder->Flush();
		if ( FAILED( hr ) )
		{
			DbgPrint( "[WmvMemoryTest] warning: Flush() failed (error %x) after %d tests\n", hr, i );
			break;
		}
	}

	// compare memory
	Sleep( 100 );
	GlobalMemoryStatus( &MemStatus );
	if ( dwAvailPhys > MemStatus.dwAvailPhys )
	{
		DbgPrint( "[WmvMemoryTest] warning: Possible leak in IWMVDecoder::ProcessMultiple()/Flush().  Available memory shrunk by %d bytes (%d runs).\n", dwAvailPhys-MemStatus.dwAvailPhys, i );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvMemory\WmvMemory.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvMemory.cpp

Abstract:

    WmvMemory tests

--*/

#include "WmvMemory.h"
#include "WmvMemoryTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
WmvMemory_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for WmvMemory

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CWmvMemTest theTest;
	EXECUTE( theTest.Run() );
    //
    // Return the Hresult
    //

    return hr;
}

VOID 
WINAPI 
WmvMemory_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the WmvMemory tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test WmvMemory in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "WmvMemory", "Basic" );
    EXECUTE( WmvMemory_BasicTest() );

#ifdef NOLOGGING
	XLaunchNewImage( NULL, NULL );
#endif

}

VOID 
WINAPI 
WmvMemory_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    WmvMemory_StartTest( NULL );
    WmvMemory_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WmvMemory )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WmvMemory )
    EXPORT_TABLE_ENTRY( "StartTest", WmvMemory_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WmvMemory_EndTest )
END_EXPORT_TABLE( WmvMemory )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvPerf\WmvPerf.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvPerf.cpp

Abstract:

    WmvPerf tests

--*/

#include "WmvPerf.h"
#include "WmvPerfTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
WmvPerf_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for WmvPerf

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CWmvPerfTest	theTest;
	hr = theTest.Run();

	XLaunchNewImage( NULL, NULL );

    //
    // Return the Hresult
    //

    return hr;
}

VOID 
WINAPI 
WmvPerf_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the WmvPerf tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test WmvPerf in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "WmvPerf", "Basic" );
    EXECUTE( WmvPerf_BasicTest() );

}

VOID 
WINAPI 
WmvPerf_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    WmvPerf_StartTest( NULL );
    WmvPerf_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WmvPerf )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WmvPerf )
    EXPORT_TABLE_ENTRY( "StartTest", WmvPerf_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WmvPerf_EndTest )
END_EXPORT_TABLE( WmvPerf )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvCommon\WMVPlayer.cpp ===
//-----------------------------------------------------------------------------
// File: WMVPlayer.cpp
//
// Desc: This helper class provides simple WMV decoding and playback 
//       functionality.  It will be expanded as new playback methods are 
//       exposed
//
// Hist: 10.10.01 - New for Novermber XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "wmvplayer.h"
#include <assert.h>
#include <stdio.h>
#include <tchar.h>




//-----------------------------------------------------------------------------
// Name: CWMVPlayer (ctor)
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CWMVPlayer::CWMVPlayer()
{
    m_pWMVDecoder   = NULL;
    m_pDSound       = NULL;
    m_pStream       = NULL;
    m_pbSampleData  = NULL;
	m_dwDroppedFrames = 0;
	m_bGotTexture	= TRUE;
}




//-----------------------------------------------------------------------------
// Name: ~CWMVPlayer (dtor)
// Desc: Performs whatever cleanup is necessary
//-----------------------------------------------------------------------------
CWMVPlayer::~CWMVPlayer()
{
    // Calling code should have already called CloseFile, which would 
    // release and NULL out these pointers
    assert( !m_pWMVDecoder );
    assert( !m_pStream );

    if( m_pDSound )
        m_pDSound->Release();
    if( m_pbSampleData )
        delete[] m_pbSampleData;
}




//-----------------------------------------------------------------------------
// Name: Initialize
// Desc: Initializes the player, using the given d3d device and directsound
//       object
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::Initialize( LPDIRECT3DDEVICE8 pd3dDevice, LPDIRECTSOUND8 pDSound )
{
    assert( pd3dDevice );
    m_pd3dDevice = pd3dDevice;
    m_pd3dDevice->AddRef();

    assert( pDSound );
    m_pDSound = pDSound;
    m_pDSound->AddRef();

    m_pbSampleData = new BYTE[ NUM_PACKETS * PACKET_SIZE ];
    assert( m_pbSampleData );

    for( int j = 0; j < NUM_PACKETS; j++ )
        m_adwStatus[ j ] = XMEDIAPACKET_STATUS_SUCCESS;
    
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: OpenFile
// Desc: Opens the specified WMV file.  This involves:
//       1) Creating the decoder XMO
//       2) Creating a texture to decode to based off the video size
//       3) Creating a direct sound stream for playback
//       4) Decoding the first chunk of video
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::OpenFile( CHAR* strFilename )
{
    HRESULT hr;
    
    hr = WmvCreateDecoder( strFilename,
                           NULL,
                           WMVVIDEOFORMAT_YUY2,
                           NULL,
                           &m_pWMVDecoder );
    if( FAILED( hr ) )
        return hr;

    // Get information about the video
    REFERENCE_TIME rtPreroll;
    m_pWMVDecoder->GetVideoInfo( &m_wmvVideoInfo );
    m_pWMVDecoder->GetAudioInfo( &m_wfx );
    m_pWMVDecoder->GetPlayDuration( &m_rtDuration, &rtPreroll );
    m_rtDuration -= rtPreroll;

    // Create our video frame
    m_pd3dDevice->CreateTexture( m_wmvVideoInfo.dwWidth,
                                 m_wmvVideoInfo.dwHeight,
                                 0,
                                 0,
                                 D3DFMT_YUY2,
                                 NULL,
                                 &m_VideoFrame.pTexture );

    D3DLOCKED_RECT lr;
    m_VideoFrame.pTexture->LockRect( 0, &lr, NULL, 0 );
    m_VideoFrame.pBits = (BYTE *)lr.pBits;
    m_VideoFrame.pTexture->UnlockRect( 0 );
    m_VideoFrame.rtTimestamp = 0;
    
    // Create a stream for audio playback
    DSSTREAMDESC dssd = {0};
    dssd.dwFlags = 0;
    dssd.dwMaxAttachedPackets = NUM_PACKETS;
    dssd.lpwfxFormat = &m_wfx;

    DirectSoundCreateStream( &dssd, &m_pStream );
    m_pStream->Pause( DSSTREAMPAUSE_PAUSE );

    m_bFirstFrame = TRUE;
    m_rtStartTime = 0;

    DecodeNext();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CloseFile
// Desc: Closes the currently opened WMV file.  This releases the decoder, the
//       video texture, and the directsound stream
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::CloseFile()
{
    if( m_pWMVDecoder )
    {
        m_pWMVDecoder->Release();
        m_pWMVDecoder = NULL;
    }

    if( m_VideoFrame.pTexture )
    {
        m_VideoFrame.pTexture->Release();
        m_VideoFrame.pTexture = NULL;
    }

    if( m_pStream )
    {
        m_pStream->Pause( DSSTREAMPAUSE_RESUME );
        m_pStream->Release();
        m_pStream = NULL;
    }

	m_dwDroppedFrames = 0;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetVideoInfo
// Desc: Returns information on the currently opened video file
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::GetVideoInfo( WMVVIDEOINFO* pVideoInfo )
{
    assert( m_pWMVDecoder );

    *pVideoInfo = m_wmvVideoInfo;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: IsReady
// Desc: Returns TRUE when the next video frame is ready to be displayed.
//-----------------------------------------------------------------------------
BOOL CWMVPlayer::IsReady()
{
    assert( m_pWMVDecoder );

    DirectSoundDoWork();

    // Calculate current time
    REFERENCE_TIME rtCurrent;
    m_pDSound->GetTime( &rtCurrent );
    rtCurrent -= m_rtStartTime;

    // If we're ready to display next frame, then skip
    if( rtCurrent >= m_VideoFrame.rtTimestamp )
    {
		m_bGotTexture = TRUE;
        return TRUE;
    }
    
    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: GetTexture
// Desc: Copies the texture that should currently be displayed into the 
//       new texture that is passed in.  When the first frame is retrieved, the
//       audio begins to play
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::GetTexture( LPDIRECT3DTEXTURE8 pTexture )
{
    assert( m_pWMVDecoder );

    D3DLOCKED_RECT lr;
    pTexture->LockRect( 0, &lr, NULL, 0 );
    memcpy( lr.pBits, m_VideoFrame.pBits, m_wmvVideoInfo.dwHeight * lr.Pitch );
    pTexture->UnlockRect( 0 );

    if( m_bFirstFrame )
    {
        m_bFirstFrame = FALSE;
        m_pStream->Pause( DSSTREAMPAUSE_RESUME );
        m_pDSound->GetTime( &m_rtStartTime );
    }

	m_bGotTexture = TRUE;

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: DecodeNext
// Desc: Decodes the next video frame, and all audio up to the following video
//       frame.  Except for the first time this is called (when opening the 
//       video), the first thing to be decoded should always be a video frame
//-----------------------------------------------------------------------------
HRESULT CWMVPlayer::DecodeNext()
{
    assert( m_pWMVDecoder );

    HRESULT hr;
    BOOL    bGotVideo = FALSE;

    do
    {
        DWORD dwIndex;

        // Verify that we can decode audio.  If this assert fires, then you
        // need to increase the amount of audio buffer for the stream
        BOOL bCanDecodeAudio = FindFreePacket( &dwIndex );
        assert( bCanDecodeAudio );

        // Audio packet
        DWORD audStat, audSize = 0;
        XMEDIAPACKET xmpAudio = {0};
        REFERENCE_TIME rtAudio;

        // Video packet
        DWORD vidStat, vidSize = 0;
        XMEDIAPACKET xmpVideo = {0};
        REFERENCE_TIME rtVideo;

        // Set up audio packet
        xmpAudio.dwMaxSize        = PACKET_SIZE;
        xmpAudio.pvBuffer         = m_pbSampleData + dwIndex * PACKET_SIZE;
        xmpAudio.pdwStatus        = &audStat;
        xmpAudio.pdwCompletedSize = &audSize;
        xmpAudio.prtTimestamp     = &rtAudio;

        // Set up video packet
        xmpVideo.dwMaxSize        = m_wmvVideoInfo.dwWidth *
                                    m_wmvVideoInfo.dwHeight *
                                    m_wmvVideoInfo.dwOutputBitsPerPixel / 8;
        xmpVideo.pdwStatus        = &vidStat;
        xmpVideo.pdwCompletedSize = &vidSize;
        xmpVideo.prtTimestamp     = &rtVideo;
        xmpVideo.pvBuffer         = m_VideoFrame.pBits;

        hr = m_pWMVDecoder->ProcessMultiple( bGotVideo ? NULL : &xmpVideo, &xmpAudio );
        if( hr == S_FALSE )
        {
            // Tell the stream we're done
            m_pStream->Discontinuity();
        }

        if( audSize > 0 )
        {
            xmpAudio.dwMaxSize        = audSize;
            xmpAudio.pdwCompletedSize = NULL;
            xmpAudio.pdwStatus        = &m_adwStatus[ dwIndex ];
            xmpAudio.prtTimestamp     = NULL;
            m_pStream->Process( &xmpAudio, NULL );
        }

        if( vidSize > 0 )
        {
			if ( FALSE == m_bGotTexture )
			{
				m_dwDroppedFrames++;
			}
			m_bGotTexture = FALSE;
            m_VideoFrame.rtTimestamp = rtVideo;
			//REFERENCE_TIME rtCurrent;
			//m_pDSound->GetTime( &rtCurrent );
			//rtCurrent -= m_rtStartTime;
			//if ( m_VideoFrame.rtTimestamp <= rtCurrent )
			//{
			//	m_dwDroppedFrames++;
			//}
            bGotVideo = TRUE;
        }

        assert( audSize == 0 || vidSize == 0 );
        assert( hr == DS_OK || ( audSize == 0 && vidSize == 0 ) );

    } while( DS_OK == hr );

    if( DS_OK == hr || E_PENDING == hr )
        return S_OK;
    else
        return S_FALSE;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Attempts to find a free audio packet (one that isn't currently 
//       submitted to the stream).  Returns TRUE if it found one
//-----------------------------------------------------------------------------
BOOL CWMVPlayer::FindFreePacket( DWORD * pdwIndex )
{
    // Check the status of each packet
    for( int i = 0; i < NUM_PACKETS; i++ )
    {
        // If we find a non-pending packet, return it
        if( m_adwStatus[ i ] != XMEDIAPACKET_STATUS_PENDING )
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvPerf\WmvPerf.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvPerf.h

Abstract:

    WmvPerf utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvMemory\WmvMemoryTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvMemTest.h

Abstract:

	General MEM tests including parameter tests.

Author:

	Jeff Sullivan (jeffsul) 13-Sep-2001

Revision History:

	13-Sep-2001 jeffsul
		Initial Version

--*/

#ifndef __WMVMEMTEST_H__
#define __WMVMEMTEST_H__

#include "..\WmvCommon\Test.h"

#include <wmvxmo.h>

//#include "..\WmvCommon\FrameQueue.h"
//#include "..\WmvCommon\bitfont.h"

#define WMV_MEM_TEST_NUM_FRAMES		16
#define WMV_MEM_TEST_NUM_PACKETS	48
#define WMV_MEM_TEST_PACKET_SIZE	4096
#define WMV_MEM_TEST_NUM_TESTS		1000
#define WMV_MEM_TEST_LARGE_MEMORY_SIZE	(1024*1024*120)

class CWmvMemTest : public CTest
{
public:
	CWmvMemTest();
	~CWmvMemTest();

protected:
	HRESULT ReadIni();

private:

	VOID ExecuteMemoryChecks();
	VOID 
	CheckProcessMultiple( 
		LPWMVDECODER	pWmvDecoder,
		LPCXMEDIAPACKET pVideoOutputPacket,
		LPCXMEDIAPACKET pAudioOutputPacket,
		UINT			nNumRuns, 
		BOOL			bDecodeEntire 
	);
};	
#endif // #ifndef __WMVMEMTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvPerf\WmvPerfTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvPerfTest.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 15-Oct-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	15-Oct-2001 jeffsul
		Initial Version

--*/

#ifndef _WMVPERFTEST_H_
#define _WMVPERFTEST_H_

#define USE_WMVPLAYER

#include "..\WmvCommon\Test.h"

#ifdef USE_WMVPLAYER
#include "..\WmvCommon\WMVPlayer.h"
#else
#include <wmvxmo.h>
#include "..\WmvCommon\FrameQueue.h"
#define WMV_PERF_TEST_NUM_FRAMES	16
#define WMV_PERF_TEST_NUM_PACKETS	48
#define WMV_PERF_TEST_PACKET_SIZE	4096
#endif

//#include "..\WmvCommon\bitfont.h"
#include <xfont.h>

// Vertex definition for the screen-space quad
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)
typedef struct {
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;

typedef struct _TVERTEX
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
	FLOAT u, v;         // Texture coordinates
} TVERTEX;

class CWmvPerfTest : public CTest
{
public:
	CWmvPerfTest();
	~CWmvPerfTest();

protected:
	HRESULT ReadIni();
	HRESULT InitGraphics();
	HRESULT DestroyGraphics();
	HRESULT InitAudio();
	HRESULT DestroyAudio();
	HRESULT InitResources();
	HRESULT DestroyResources();

	HRESULT ProcessInput();
	HRESULT Update();
	HRESULT Render();

private:

#ifdef USE_WMVPLAYER
	CWMVPlayer				m_WMVPlayer;		
	LPDIRECT3DTEXTURE8  m_pOverlay[2];  // Overlay textures
    LPDIRECT3DSURFACE8  m_pSurface[2];  // Overlay Surfaces
    DWORD               m_dwCurrent;    // Current surface
#else //
	LPWMVDECODER			m_pWMVDecoder;				// WMV decoder 
	VIDEOFRAME              m_aVideoFrames[WMV_PERF_TEST_NUM_FRAMES]; // Video frames
	DWORD                   m_adwStatus[WMV_PERF_TEST_NUM_PACKETS];   // Audio packet status
    BYTE *                  m_pbSampleData;             // Audio sample data
	LPDIRECTSOUNDSTREAM     m_pStream;                  // DirectSound Stream
	LPDIRECT3DVERTEXBUFFER8 m_pvbQuad;                  // Quad for rendering video
	CFrameQueue				m_fqFree;					// Free frames - these can be filled
    CFrameQueue				m_fqBusy;					// Busy frames - possibly being rendered
    CFrameQueue				m_fqReady;					// Ready frames - filled, and can be displayed
#endif //


	// resources
	LPDIRECT3DDEVICE8		m_pD3DDevice;				// rendering device
	LPDIRECTSOUND8			m_pDSound;					// sound device	
	WMVVIDEOINFO			m_wmvVideoInfo;             // Video info
	WAVEFORMATEX			m_wfx;                      // Audio format
    VIDEOFRAME *            m_pCurrentFrame;            // Frame to render

	LPDIRECT3DTEXTURE8		m_pd3dtText;				// texture to render text to
	TVERTEX					m_prText[4];				// geometry to display text on
	//BitFont					m_BitFont;					// font interface
	XFONT*					m_pFont;
	HANDLE                  m_hInpDevice;				// input device
	XINPUT_STATE			m_PrevInputState;           // previous input state

	// file io
	CHAR					m_szPath[MAX_PATH];			// file path of video to play
	UINT					m_nNumFilesPlayed;			// number of videos played so far
	HANDLE					m_hFiles;					// handle to file search data
	WIN32_FIND_DATA			m_FindData;					// info about the next file to open

	// test info
	DWORD					m_dwCurrentFrame;			// Current frame number
	DWORD					m_dwVideoFrames;			// Total number of video frames decoded so far
	DWORD					m_dwRenderedFrames;			// Total number of frames rendered
	DWORD					m_dwRenderedFPS;			// Number of frames rendered since last sample
	DWORD					m_dwVideoFPS;				// Number of video frames decoded since last sample
	DWORD					m_dwDroppedFrames;			// Number of dropped frames during this video
	DWORD					m_dwLastDroppedFrame;		// Frame number of last dropped frame

	// test state
	WCHAR					m_szWideFileName[MAX_PATH]; // the wide character file name of the current file
	BOOL					m_bDecode;                  // Set to FALSE at end of video
	BOOL					m_bReset;					// set to TRUE at end of video
	BOOL					m_bGotData;					// TRUE after we've gotten a packet
	BOOL					m_bDrawText;				// whether or not to display text info	
	BOOL					m_bFullScreen;				// whether to display the movie full screen or original size
	DWORD					m_dwLastFPS;				// Last time we sampled the FPS

	REFERENCE_TIME			m_rtStartTime;				// Reference time at start
	REFERENCE_TIME			m_rtDuration;               // Duration of video
    REFERENCE_TIME			m_rtCurrentTime;			// Reference time of current frame
    REFERENCE_TIME			m_rtPreroll;				// Preroll time
    REFERENCE_TIME			m_rtSeekAdjustment;			// Seek adjustment
	DWORD					m_dwRefreshInterval;

	// private member functions
#ifndef USE_WMVPLAYER
	BOOL FindFreePacket( DWORD * pdwIndex );			// Find a free audio packet
    BOOL FindFreeFrame( VIDEOFRAME ** ppFrame );		// Find a free video frame
    HRESULT ProcessVideoQueues();						// Processes our video queues
#endif
	VOID	DumpPerfData();
};	

#endif //#ifndef _WMVPERFTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvPerf\WmvPerfTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvPerfTest.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 15-Oct-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	15-Oct-2001 jeffsul
		Initial Version

--*/

#include "WmvPerfTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

#define WMVTEST_APP_NAME	"WMVTEST"
#define	WMVTEST_INI_PATH	"D:\\WMVTest.ini"

DWORD g_dwVBlankCount = 0;
//-----------------------------------------------------------------------------
// Name: VBlankCallback
// Desc: Called every vblank, so we can mantain a count of vblanks
//-----------------------------------------------------------------------------
VOID _cdecl VBlankCallback( D3DVBLANKDATA *pData/*DWORD dwContext*/ )
{
    g_dwVBlankCount++;
}

/*++

Routine Description:

	Test constructor

Arguments:

	None

Return Value:

	None

--*/
CWmvPerfTest::CWmvPerfTest()
{
	m_pD3DDevice = NULL;
	m_pDSound = NULL;

#ifndef USE_WMVPLAYER
	m_pWMVDecoder = NULL;
	for( UINT i = 0; i < WMV_PERF_TEST_NUM_FRAMES; i++ )
    {
		m_aVideoFrames[i].pTexture = NULL;
    }
	m_pbSampleData = NULL;
	m_pvbQuad = NULL;
	m_pStream = NULL;
#endif

	m_nNumFilesPlayed = 0;
	m_bReset = FALSE;

	m_bGotData = FALSE;
	m_bDrawText = TRUE;
	m_bFullScreen = TRUE;
	ZeroMemory( &m_PrevInputState, sizeof(XINPUT_STATE) );

	g_dwVBlankCount = 0;
}


/*++

Routine Description:

	Test destructor

Arguments:

	None

Return Value:

	None

--*/
CWmvPerfTest::~CWmvPerfTest()
{
}


/*++

Routine Description:

	read initialization variables from an ini file

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::ReadIni()
{
	HRESULT hr = S_OK;

	CHAR	szSearchPath[MAX_PATH];

	MLSetErrorLevel( 3 );
	// grab media files from server
#define CREATE_FLAG	MLCOPY_IFNEWER
	MEDIAFILEDESC MediaFiles[] =
	{
		{"wmv/ms_wmv_v8/%3",	"T:\\WMV\\Perf\\",			CREATE_FLAG},
		{NULL,									NULL,								0}
	};
	EXECUTE( LoadMedia( MediaFiles ) );

	// look for files on the xbox matching certain parameters
	//if ( CopyFile( "A:\\mad_audiovideo_filmvbr_quality97.wmv", "D:\\mad_audiovideo_filmvbr_quality97.wmv", FALSE ) )
	//{
	//	return E_FAIL;
	//}
	//if ( FALSE == CopyFile( "A:\\Office Space.wmv", "D:\\Office Space.wmv", FALSE ) )
	//{
	//	return E_FAIL;
	//}
	strcpy( m_szPath, "T:\\WMV\\Perf\\" );
	sprintf( szSearchPath, "%s*.wmv", m_szPath );
	
	m_hFiles = FindFirstFile( szSearchPath, &m_FindData );
	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
		return E_FAIL;
	}

	// create a wide character file name (for output later to screen)
	for( UINT i = 0; i < strlen( m_FindData.cFileName ); i++ )
	{
		m_szWideFileName[i] = (WCHAR)m_FindData.cFileName[i];
	}
	m_szWideFileName[i] = 0;

	return hr;
}


/*++

Routine Description:

	initialize graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::InitGraphics()
{
	HRESULT hr = S_OK;

	D3DPRESENT_PARAMETERS	d3dpp;

	// Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	EXECUTE( Direct3D_CreateDevice(	D3DADAPTER_DEFAULT, 
									D3DDEVTYPE_HAL,
									NULL, 
									D3DCREATE_HARDWARE_VERTEXPROCESSING, 
									&d3dpp, 
									&m_pD3DDevice) );
    if ( FAILED ( hr ) )
	{
        return hr;
    }

	m_pD3DDevice->SetVerticalBlankCallback( VBlankCallback );

	//m_pD3DDevice->EnableOverlay( TRUE );

	// Create a buffer for the text
    hr = m_pD3DDevice->CreateTexture(640, 480, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pd3dtText);
    if (FAILED(hr)) {
        return hr;
    }

    // Clear the texture
	D3DLOCKED_RECT d3dlr;
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for ( UINT i = 0; i < 480; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 640 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    m_prText[0].x = 0.0f;
    m_prText[0].y = 480.0f;
    m_prText[0].u = 0.0f;
    m_prText[0].v = 480.0f;

    m_prText[1].x = 0.0f;
    m_prText[1].y = 0.0f;
    m_prText[1].u = 0.0f;
    m_prText[1].v = 0.0f;

    m_prText[2].x = 640.0f;
    m_prText[2].y = 0.0f;
    m_prText[2].u = 640.0f;
    m_prText[2].v = 0.0f;

    m_prText[3].x = 640.0f;
    m_prText[3].y = 480.0f;
    m_prText[3].u = 640.0f;
    m_prText[3].v = 480.0f;

    for (i = 0; i < 4; i++) {
        m_prText[i].z = 0.0f; //0.000001f;
        m_prText[i].rhw = 1.0f; ///1000000.0f;
    }

	D3DDISPLAYMODE mode;
    hr = m_pD3DDevice->GetDisplayMode(&mode);
    if (SUCCEEDED(hr) && mode.RefreshRate) {
        m_dwRefreshInterval = 1000*10000 / mode.RefreshRate;
    } 
	else 
	{
        // Default to 16msecs
        m_dwRefreshInterval = 16*10000;
    }

	return hr;
}


/*++

Routine Description:

	cleanup graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::DestroyGraphics()
{
	HRESULT hr = S_OK;

	RELEASE( m_pD3DDevice );
	RELEASE( m_pd3dtText );

	return hr;
}


/*++

Routine Description:

	initialize audio device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::InitAudio()
{
	HRESULT hr = S_OK;

	hr = DirectSoundCreate( NULL, &m_pDSound, NULL );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create Direct Sound (error: %x)\n", hr );
		return hr;
	}
	m_pDSound->GetTime( &m_rtStartTime );

	hr = m_WMVPlayer.Initialize( m_pD3DDevice, m_pDSound );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to initialize WMVPlayer (error: %x)\n", hr );
		return hr;
	}

	return hr;
}


/*++

Routine Description:

	cleanup audio device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::DestroyAudio()
{
	HRESULT hr = S_OK;

	RELEASE( m_pDSound );

	return hr;
}


/*++

Routine Description:

	initialize wmv resources

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::InitResources()
{
	HRESULT hr = S_OK;
	
	m_rtStartTime = 0;
    m_rtSeekAdjustment = 0;
    m_pCurrentFrame = NULL;
	
	m_dwCurrentFrame =
	m_dwVideoFrames =
	m_dwRenderedFrames =
	m_dwVideoFPS	=
	m_dwRenderedFPS	=
	m_dwDroppedFrames =
	m_dwLastDroppedFrame = 0;

	m_pD3DDevice->EnableOverlay( TRUE );

	// Create the video decoder.  We only load
    // the section containing the decoder on demand
    XLoadSection("WMVDEC");
	CHAR	szFileName[MAX_PATH];
	sprintf( szFileName, "%s%s", m_szPath, m_FindData.cFileName );

	hr = XFONT_OpenDefaultFont( &m_pFont );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create font (error: %x)\n", hr );
		return E_FAIL;
	}
	m_pFont->SetTextHeight( 4 );
	m_pFont->SetIntercharacterSpacing( -2 );


#ifdef USE_WMVPLAYER
	hr = m_WMVPlayer.OpenFile( szFileName );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create WMVPlayer for '%s' (error: %x)\n", szFileName, hr );
		return E_FAIL;
	}

    m_WMVPlayer.GetVideoInfo( &m_wmvVideoInfo );

	// Create two textures based off the video format.  We need to
    // use two textures because the overlay surface reads directly
    // from the texture.  Updating a texture while it's being used
    // by the overlay will cause tearing
    for( int i = 0; i < 2; i++ )
    {
        m_pD3DDevice->CreateTexture( m_wmvVideoInfo.dwWidth,
                                     m_wmvVideoInfo.dwHeight,
                                     1,
                                     0,
                                     D3DFMT_YUY2,
                                     0,
                                     &m_pOverlay[i] );
        m_pOverlay[i]->GetSurfaceLevel( 0, &m_pSurface[i] );
    }
    m_dwCurrent = 0;

#else

    hr = WmvCreateDecoder( szFileName,
							NULL,
							WMVVIDEOFORMAT_YUY2,
							NULL,
							&m_pWMVDecoder );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create decoder for '%s' (error: %x)\n", szFileName, hr );
		return E_FAIL;
	}

	// If that succeeded, set up for decoding:
	CHECKEXECUTE( m_pWMVDecoder->GetPlayDuration( &m_rtDuration, &m_rtPreroll ) );
	CHECKEXECUTE( m_pWMVDecoder->GetAudioInfo( &m_wfx ) );
	if ( SUCCEEDED( hr ) )
	{
		// Set up a stream for audio playback
		DSSTREAMDESC dssd = {0};
		dssd.dwFlags =  0;
		dssd.dwMaxAttachedPackets = WMV_PERF_TEST_NUM_PACKETS;
		dssd.lpwfxFormat = &m_wfx;
		
		CHECKEXECUTE( DirectSoundCreateStream( &dssd, &m_pStream ) );
		
		// Allocate sample data
		if ( SUCCEEDED( hr ) )
		{
			m_pbSampleData = new BYTE[ WMV_PERF_TEST_NUM_PACKETS * WMV_PERF_TEST_PACKET_SIZE ];
			CHECKALLOC( m_pbSampleData );
			
			// Initialize audio packet status
			for( UINT i = 0; i < WMV_PERF_TEST_NUM_PACKETS; i++ )
			{
				m_adwStatus[ i ] = XMEDIAPACKET_STATUS_SUCCESS;
			}
		}
	}
	
	EXECUTE( m_pWMVDecoder->GetVideoInfo( &m_wmvVideoInfo ) );
	if ( SUCCEEDED( hr ) )
	{
		// Set up video frame buffers
		for( UINT i = 0; i < WMV_PERF_TEST_NUM_FRAMES; i++ )
		{
			// Create the texture
			hr = m_pD3DDevice->CreateTexture(
				m_wmvVideoInfo.dwWidth,
				m_wmvVideoInfo.dwHeight,
				0,
				0,
				D3DFMT_YUY2,
				NULL,
				&m_aVideoFrames[i].pTexture );
			if ( FAILED( hr ) )
			{
				DbgPrint( "Failed to create texture %d (error: %d)\n", i, hr );
				return E_FAIL;
			}
			
			// Get a pointer to the texture data
			D3DLOCKED_RECT lr;
			m_aVideoFrames[i].pTexture->LockRect( 0, &lr, NULL, 0 );
			m_aVideoFrames[i].pBits = (BYTE *)lr.pBits;
			m_aVideoFrames[i].pTexture->UnlockRect( 0 );
			
			m_aVideoFrames[i].dwSetAtVBlank = 0;
			m_fqFree.Enqueue( &m_aVideoFrames[i] );
		}
		
		// Create a vertex buffer for the quad
		FLOAT fLeft;
		FLOAT fRight;
		FLOAT fTop; 
		FLOAT fBottom;
		
		if ( FALSE == m_bFullScreen )
		{
			fLeft = 320.0f - m_wmvVideoInfo.dwWidth / 2;
			fRight = 320.0f + m_wmvVideoInfo.dwWidth / 2;
			fTop = 240.0f - m_wmvVideoInfo.dwHeight / 2;
			fBottom = 240.0f + m_wmvVideoInfo.dwHeight / 2;
		}
		else
		{
			fLeft = 0.0f;
			fRight = 640.0f;
			fTop = 240.0f - (m_wmvVideoInfo.dwHeight*320.0f/m_wmvVideoInfo.dwWidth);
			fBottom = 240.0f + (m_wmvVideoInfo.dwHeight*320.0f/m_wmvVideoInfo.dwWidth);
		}
		
		CHECKEXECUTE( m_pD3DDevice->CreateVertexBuffer( 4 * sizeof( CUSTOMVERTEX ), 0, 0, 0, &m_pvbQuad ) );
		if ( SUCCEEDED( hr ) )
		{
			CUSTOMVERTEX * pVertices;
			m_pvbQuad->Lock( 0, 0, (BYTE **)&pVertices, 0 );
			pVertices[ 0 ].p = D3DXVECTOR4( fLeft, fTop, 1.0f, 1.0f ); pVertices[0].t = D3DXVECTOR2( 0.0f, 0.0f );
			pVertices[ 1 ].p = D3DXVECTOR4( fRight, fTop, 1.0f, 1.0f ); pVertices[1].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, 0.0f );
			pVertices[ 2 ].p = D3DXVECTOR4( fRight, fBottom, 1.0f, 1.0f ); pVertices[2].t = D3DXVECTOR2( (FLOAT)m_wmvVideoInfo.dwWidth, (FLOAT)m_wmvVideoInfo.dwHeight );
			pVertices[ 3 ].p = D3DXVECTOR4( fLeft, fBottom, 1.0f, 1.0f ); pVertices[3].t = D3DXVECTOR2( 0.0f, (FLOAT)m_wmvVideoInfo.dwHeight );
			m_pvbQuad->Unlock();
		}
	}
#endif
	
	m_dwLastFPS = m_dwCurrentTime-1000;

	return hr;
}


/*++

Routine Description:

	cleanup wmv resources

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::DestroyResources()
{
	HRESULT hr = S_OK;

	m_pD3DDevice->EnableOverlay( FALSE );
	
#ifdef USE_WMVPLAYER
	for( UINT i = 0; i < 2; i++ )
    {
        RELEASE( m_pSurface[i] );
        RELEASE( m_pOverlay[i] );
    }
	m_WMVPlayer.CloseFile();

#else
	m_fqFree.m_pHead = m_fqFree.m_pTail = NULL;
	m_fqBusy.m_pHead = m_fqBusy.m_pTail = NULL;
	m_fqReady.m_pHead = m_fqReady.m_pTail = NULL;

	for( UINT i = 0; i < WMV_PERF_TEST_NUM_FRAMES; i++ )
    {
		RELEASE( m_aVideoFrames[i].pTexture );
    }
	RELEASE( m_pWMVDecoder );
	RELEASE( m_pvbQuad );
	RELEASE( m_pStream );
	if ( NULL != m_pbSampleData )
	{
		delete [] m_pbSampleData;
		m_pbSampleData = NULL;
	}
#endif

	XFreeSection("WMVDEC");

	m_pD3DDevice->EnableOverlay( FALSE );

	if ( !FindNextFile( m_hFiles, &m_FindData ) )
	{
		CHAR	szSearchPath[MAX_PATH];

		sprintf( szSearchPath, "%s*.wmv", m_szPath );
		
		m_hFiles = FindFirstFile( szSearchPath, &m_FindData );
	}

	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
			m_bQuit = TRUE;
	}
	else
	{
		for( UINT i = 0; i < strlen( m_FindData.cFileName ); i++ )
		{
			m_szWideFileName[i] = (WCHAR)m_FindData.cFileName[i];
		}
		m_szWideFileName[i] = 0;
	}

	return hr;
}


/*++

Routine Description:

	get the input state from the control pad

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::ProcessInput()
{
	HRESULT hr = S_OK;

	DWORD dwDeviceMap;
	DWORD dwSuccess;
	BOOL bDeviceChanges;
	DWORD dwInsertions;
	DWORD dwRemovals;

	XINPUT_STATE xinpstate;

	bDeviceChanges = XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );
	if ( bDeviceChanges )
	{
		if ( dwInsertions & XDEVICE_PORT0_MASK )
		{
			m_hInpDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
			if ( m_hInpDevice == NULL )
			{
				DbgPrint( "Error Opening Input\n" );
				return E_FAIL;
			}
		}
		
		if ( dwRemovals & XDEVICE_PORT0_MASK )
		{
			DbgPrint( "Gamepad removed from Port 0\n" );
			return E_FAIL;
		}
	}

	dwDeviceMap = XGetDevices( XDEVICE_TYPE_GAMEPAD );
	if ( !(dwDeviceMap & XDEVICE_PORT0_MASK) ) 
	{
		//DbgPrint( "No Device in Port 0\n" );
		return S_OK; // live with it!
	}
	else if ( NULL == m_hInpDevice )
	{
		m_hInpDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0, XDEVICE_NO_SLOT, NULL );
		if ( m_hInpDevice == NULL )
		{
			DWORD dwError;
			dwError = GetLastError();
			DbgPrint( "Error Opening Input. Error#: %d\n", dwError);
			return E_FAIL;
		}
	}

	dwSuccess = XInputGetState( m_hInpDevice, &xinpstate );
	if ( dwSuccess != ERROR_SUCCESS )
	{
		DbgPrint( "Error Getting Input State\n" );
		return dwSuccess;
	}

	// toggle the text display on/off
	if ( xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] > 15  && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A] <= 15 )
	{
		m_bDrawText = !m_bDrawText;
		if ( TRUE == m_bDrawText )
		{
			m_dwLastFPS = -1000;
		}
	}

	// toggle full screen display on/off
	if ( xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] > 15  && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_B] <= 15 )
	{
		m_bFullScreen = !m_bFullScreen;
	}

	// go to the next file
	if ( xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 15 && m_PrevInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] <= 15)
	{
		//m_rtSeekAdjustment += (xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER]-15)*320000/240;
		DumpPerfData();
		m_bReset = TRUE;
	}

	// quit the test
	if ( xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] &&
		 xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] && 
		 xinpstate.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] )
	{
		m_bQuit = TRUE;
	}

	// copy the current state to the previous state structure for use next time around
	memcpy( &m_PrevInputState, &xinpstate, sizeof(XINPUT_STATE) );

	return hr;
}


/*++

Routine Description:

	update the scene each frame

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvPerfTest::Update()
{
	HRESULT hr = S_OK;

	if ( m_bReset )
	{
#ifndef USE_WMVPLAYER
		HRESULT hrTemp = S_OK;
		// just checking discontuinuity to make sure it does what the doc says (just return DS_OK)
		hrTemp = m_pWMVDecoder->Discontinuity();
		if ( DS_OK != hrTemp )
		{
			DbgPrint( "IWMVDecoder::Discontinuity() returned %d, should always be DS_OK\n", hrTemp );
		}
		hrTemp = m_pWMVDecoder->Flush();
		if ( FAILED( hrTemp ) )
		{
			DbgPrint( "IWMVDecoder::Flush() failed (hr = %d)\n", hrTemp );
		}
#endif
		DestroyResources();
		if ( TRUE == m_bQuit )
		{
			return S_OK;
		}
		hr = InitResources();
		m_bReset = FALSE;
		m_bGotData = FALSE;
		g_dwVBlankCount = 0;

		if ( FAILED( hr ) )
		{
			m_bReset = TRUE;
			return hr;
		}
	}

#ifdef USE_WMVPLAYER
	// Set our time for this frame:
	// Video Time = Current Time - Start Time + Seek Adjustment
	if ( 0 == m_rtStartTime )
	{
		m_pDSound->GetTime( &m_rtStartTime );
	}
	m_pDSound->GetTime( &m_rtCurrentTime );
	m_rtCurrentTime = m_rtCurrentTime - m_rtStartTime + m_rtSeekAdjustment;

	if ( m_dwDroppedFrames != m_WMVPlayer.m_dwDroppedFrames )
	{
		m_dwVideoFrames += m_WMVPlayer.m_dwDroppedFrames-m_dwDroppedFrames;
		m_dwLastDroppedFrame = m_WMVPlayer.m_dwDroppedFrames;
		m_dwDroppedFrames = m_WMVPlayer.m_dwDroppedFrames;
	}

#else
	VIDEOFRAME *pFrame;
	DWORD dwIndex = 0;
	// See how we're doing on audio packets
	DWORD dwPending = 0;
	DWORD dwSucceeded = 0;
	for( int i = 0; i < WMV_PERF_TEST_NUM_PACKETS; i++ )
	{
		switch( m_adwStatus[ i ] )
		{
		case XMEDIAPACKET_STATUS_PENDING:
			dwPending++;
			break;
		case XMEDIAPACKET_STATUS_SUCCESS:
			dwSucceeded++;
			break;
		}
	}
	
	// Now check video frames
	DWORD dwBusy = 0;
	dwPending = dwSucceeded = 0;
	for( pFrame = m_fqFree.m_pHead; pFrame; pFrame = pFrame->pNext )
		dwSucceeded++;
	for( pFrame = m_fqReady.m_pHead; pFrame; pFrame = pFrame->pNext )
		dwPending++;
	for( pFrame = m_fqBusy.m_pHead; pFrame; pFrame = pFrame->pNext )
		dwBusy++;

	// Set our time for this frame:
    // Video Time = Current Time - Start Time + Seek Adjustment
    m_pDSound->GetTime( &m_rtCurrentTime );
    m_rtCurrentTime = m_rtCurrentTime - m_rtStartTime + m_rtSeekAdjustment;
    
    // Process our 3 video queues
    ProcessVideoQueues();

    // If we are actively decoding...
    if( m_bDecode )
    {
        // Find an audio packet and a video frame
        while( FindFreePacket( &dwIndex ) && FindFreeFrame( &pFrame ) )
        {
            //
            // Set up an audio packet:
            //
            DWORD audStat, audSize;
            XMEDIAPACKET xmpAudio = {0};
            REFERENCE_TIME rtAudio;

            xmpAudio.dwMaxSize = WMV_PERF_TEST_PACKET_SIZE;
            xmpAudio.pvBuffer  = m_pbSampleData + dwIndex * WMV_PERF_TEST_PACKET_SIZE;
            xmpAudio.pdwStatus = &audStat;
            xmpAudio.pdwCompletedSize = &audSize;
            xmpAudio.prtTimestamp = &rtAudio;

            //
            // Set up a video packet
            //
            DWORD vidStat, vidSize;
            XMEDIAPACKET xmpVideo = {0};
            REFERENCE_TIME rtVideo;

            xmpVideo.dwMaxSize = m_wmvVideoInfo.dwWidth * 
                                 m_wmvVideoInfo.dwHeight * 
                                 m_wmvVideoInfo.dwOutputBitsPerPixel / 8;
            xmpVideo.pdwStatus = &vidStat;
            xmpVideo.pdwCompletedSize = &vidSize;
            xmpVideo.prtTimestamp = &rtVideo;

            // We shouldn't have put the frame in the free queue
            // until we were sure the next one was being used
            if( pFrame->pTexture->IsBusy() )
                DbgPrint( "Writing to a busy frame.\n" );

            xmpVideo.pvBuffer  = pFrame->pBits;
			ZeroMemory( xmpVideo.pvBuffer, xmpVideo.dwMaxSize );
        
            // Process the decoder
            hr = m_pWMVDecoder->ProcessMultiple( &xmpVideo, &xmpAudio );

            // S_FALSE means that we hit the end of the video
            if( S_FALSE == hr )
            {
                //DbgPrint( "Done playing video\n" );
				DumpPerfData();
				m_bReset = TRUE;
                break;
            }

            // Get the system start time as of first packet, so 
            // that we can calculate the reference time 
            if( !m_bGotData && ( audSize > 0 || vidSize > 0 ) )
            {
                m_bGotData = TRUE;
                m_pDSound->GetTime( &m_rtStartTime );
                m_rtCurrentTime = m_rtSeekAdjustment;
				m_dwLastFPS = m_dwCurrentTime-1000;
				m_dwVideoFPS = 
				m_dwVideoFrames = 0;
            }
            
            // If we got a video frame, append it to the queue
            if( vidSize > 0 )
            {
                // TODO: Understand why decoder gives us these packets.
                if( rtVideo > m_rtDuration )
                {
                    DbgPrint( "Got RT: %I64d, but duration is only %I64d.  Ditching frame.\n", rtVideo, m_rtDuration );
                }
                else
                {
                    // Update the pending video frame queue
                    pFrame->rtTimeStamp = rtVideo;
                    pFrame->dwFrameNumber = m_dwVideoFrames++;//m_dwVidFrame++;
                    m_fqReady.Enqueue( m_fqFree.Dequeue() );
					m_dwVideoFPS++;
                }
            }

            // If we got an audio packet, send it to the stream
            if( audSize > 0 )
            {
                // Process the audio packet
                xmpAudio.dwMaxSize = audSize;
                xmpAudio.pdwCompletedSize = NULL;
                xmpAudio.pdwStatus = &( m_adwStatus[ dwIndex ] );
                m_pStream->Process( &xmpAudio, NULL );
            }
        }
    }
#endif

	m_dwRenderedFPS++;
	m_dwRenderedFrames++;

	// a second has gone by, lets update our onscreen text
	if ( 1000 < m_dwCurrentTime - m_dwLastFPS )
	{
		// Clear the texture
		D3DLOCKED_RECT d3dlr;
		m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
		for ( UINT i = 0; i < 480; i++) {
			memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 640 * 4);
		}
		m_pd3dtText->UnlockRect(0);
		
		LPDIRECT3DSURFACE8	pSurface = NULL;
		hr = m_pd3dtText->GetSurfaceLevel(0, &pSurface);
		if ( SUCCEEDED( hr ) && m_bDrawText )
		{

#define DRAWTEXT( x, y ) m_pFont->TextOut( pSurface, buffer, -1, x, y );
//#define DRAWTEXT( x, y ) m_BitFont.DrawText( pSurface, buffer, x, y, 0, D3DCOLOR_XRGB( 255, 255, 255 ), D3DCOLOR_XRGB( 0, 0, 0 ) );

			//m_BitFont.DrawText( pSurface, m_szWideFileName, 20, 15, 0, D3DCOLOR_XRGB( 255, 255, 255 ), D3DCOLOR_XRGB( 0, 0, 0 ) );
			m_pFont->SetTextAlignment( XFONT_TOP | XFONT_LEFT );
			m_pFont->TextOut( pSurface, m_szWideFileName, -1, 30, 20 );

			WCHAR buffer[MAX_PATH];
			UINT nCurrentTime = (UINT)(m_rtCurrentTime/10000000);
			UINT nTotalTime = (UINT)(m_rtDuration/10000000);

			swprintf( buffer, L"Time: %u / %u", nCurrentTime, nTotalTime );
			DRAWTEXT( 30, 40 );

			m_pFont->SetTextAlignment( XFONT_TOP | XFONT_RIGHT );
			swprintf( buffer, L"Decoding: %u fps", m_dwVideoFPS );
			DRAWTEXT( 640-30, 20 );
			swprintf( buffer, L"Rendering: %u fps", m_dwRenderedFPS );
			DRAWTEXT( 640-30, 40 );

			m_pFont->SetTextAlignment( XFONT_BOTTOM | XFONT_LEFT );
			swprintf( buffer, L"Dropped Frames: %d / %d (%d%%)", m_dwDroppedFrames, m_dwVideoFrames, (m_dwVideoFrames) ? m_dwDroppedFrames*100/m_dwVideoFrames : 0 );
			DRAWTEXT( 30, 480-40 );
			swprintf( buffer, L"Last Dropped: %d", m_dwLastDroppedFrame );
			DRAWTEXT( 30, 480-20 );
		}
		RELEASE( pSurface );

		m_dwRenderedFPS = 
		m_dwVideoFPS = 0;
		m_dwLastFPS = m_dwCurrentTime;
	}

	return hr;
}


/*++

Routine Description:

	render the scene to the screen

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
#define CLAMP( x, a, b ) \
if ( x < a ) x = a; \
else if ( x > b ) x = b;

HRESULT CWmvPerfTest::Render()
{
	HRESULT hr = S_OK;

	if ( TRUE == m_bQuit )
	{
		return S_OK;
	}

	RECT rcSrc = { 0, 0, m_wmvVideoInfo.dwWidth, m_wmvVideoInfo.dwHeight };
	RECT rcDest;
	if ( m_bFullScreen )
	{
		rcDest.left		= 0;
		rcDest.top		= 240- (m_wmvVideoInfo.dwHeight*320/m_wmvVideoInfo.dwWidth);
		CLAMP( rcDest.top, 0, 240 );
		rcDest.right	= 640;
		rcDest.bottom	= 240+ (m_wmvVideoInfo.dwHeight*320/m_wmvVideoInfo.dwWidth);
		CLAMP( rcDest.bottom, 240, 480 );
	}
	else 
	{
		rcDest.left		= 320-m_wmvVideoInfo.dwWidth / 2;
		CLAMP( rcDest.left, 0, 320 );
		rcDest.top		= 240-m_wmvVideoInfo.dwHeight / 2;
		CLAMP( rcDest.top, 0, 240 );
		rcDest.right	= 320+m_wmvVideoInfo.dwWidth / 2;
		CLAMP( rcDest.right, 320, 640 );
		rcDest.bottom	= 240+m_wmvVideoInfo.dwHeight / 2;
		CLAMP( rcDest.bottom, 240, 480 );
		//rcDest = { 320-m_wmvVideoInfo.dwWidth / 2, 240-m_wmvVideoInfo.dwHeight / 2, 320+m_wmvVideoInfo.dwWidth / 2, 240+m_wmvVideoInfo.dwHeight / 2 };
	}

	// clear the rendering surface
	EXECUTE( m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( 0, 0, 0 ), 1.0f, 0L ) );

	// begin the scene
	EXECUTE( m_pD3DDevice->BeginScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

#ifdef USE_WMVPLAYER
	// Get the next frame into our texture
	hr = m_WMVPlayer.GetTexture( m_pOverlay[m_dwCurrent] );
	if( FAILED( hr ) )
	{
		__asm int 3;
	}

	if ( m_WMVPlayer.IsReady() /*&& m_pD3DDevice->GetOverlayUpdateStatus()*/ )
    {
		m_pD3DDevice->BlockUntilVerticalBlank();
		m_pD3DDevice->UpdateOverlay( m_pSurface[m_dwCurrent], &rcSrc, &rcDest, FALSE, 0 );
		m_dwVideoFrames++;
		m_dwVideoFPS++;
		
		// Decode the next frame
		if( S_FALSE == m_WMVPlayer.DecodeNext() )
		{
			DumpPerfData();
			m_bReset = TRUE;
			return hr;
		}
		
		// We'll use the other texture next time
		m_dwCurrent ^= 1;
	}
	
#else

	DirectSoundDoWork();

	// draw the quad with the video texture
    if( m_pCurrentFrame )
    {
		LPDIRECT3DSURFACE8 pSurface;
		//D3DLOCKED_RECT LockedRect = {0};
		hr = m_pCurrentFrame->pTexture->GetSurfaceLevel( 0, &pSurface );
		if ( FAILED( hr ) )
		{
			return hr;
		}
		m_pD3DDevice->UpdateOverlay( pSurface, &rcSrc, &rcDest, FALSE, 0 );
		RELEASE( pSurface );

		// Remember when we attempted to render this frame.
        // The time it actually gets rendered depends on the method
        // For overlay: We can be sure it's been rendered after next vblank
        m_pCurrentFrame->dwSetAtVBlank = g_dwVBlankCount;
    }
#endif

	// draw the geometry with the text on it
	if ( m_bDrawText )
	{
		m_pD3DDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
		m_pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
		m_pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
		m_pD3DDevice->SetRenderState(D3DRS_ALPHAREF, 0);
		m_pD3DDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
		m_pD3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
		m_pD3DDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
		m_pD3DDevice->SetTexture(0, m_pd3dtText);
		
		m_pD3DDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prText, sizeof(TVERTEX));
	}

	// render the scene to the surface
	EXECUTE( m_pD3DDevice->EndScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// flip the surface to the screen
	EXECUTE( m_pD3DDevice->Present( NULL, NULL, NULL, NULL ) );

	if ( TRUE == m_bReset )
	{
		m_pD3DDevice->EnableOverlay( FALSE );
	}

	return hr;
}

#ifndef USE_WMVPLAYER
//-----------------------------------------------------------------------------
// Name: ProcessVideoQueues()
// Desc: Processes our video queues:
//       1) Free up any busy frames that we know are no longer in use.
//          For overlay, we know a frame is no longer in use if we're at
//          least one VBlank after updating with the next frame.
//          For textures, we could have up to 3 frames in the pushbuffer,
//          so we know a frame is no longer in use if we're at least 3 VBlanks
//          after rendering the next frame
//       2) Discard any frames from the ready queue that are obsolete.  A
//          frame is obsolete if the frame after it is displayable.
//       3) Figure out if we need to render a new frame - that is, is there
//          a frame in the ready queue with a timestamp less than current time
//-----------------------------------------------------------------------------
HRESULT
CWmvPerfTest::ProcessVideoQueues()
{
    // Step 1: Move packets from busy->free if they're not being used.
    // The only time the busy queue should be empty is starting up
    while( !m_fqBusy.IsEmpty() )
    {
        // If frame Y was submitted after frame X, and we're sure
        // frame Y is the one being displayed, free frame X
        if( m_fqBusy.m_pHead->pNext &&
            m_fqBusy.m_pHead->pNext->dwSetAtVBlank < g_dwVBlankCount )
        {
            m_fqFree.Enqueue( m_fqBusy.Dequeue() );
        }
        else
            break;
    }

    // Step 2: Discard dropped frames.  We drop frame X if there's 
    // frame Y after it, and frame Y is displayable
    while( !m_fqReady.IsEmpty() && 
            m_fqReady.m_pHead->pNext &&
            m_fqReady.m_pHead->pNext->rtTimeStamp <= m_rtCurrentTime
			/*(m_rtCurrentTime - (m_fqReady.m_pHead->rtTimeStamp+m_rtStartTime)) > m_dwRefreshInterval*/ )
    {
		m_dwDroppedFrames++;
		m_dwLastDroppedFrame = m_fqReady.m_pHead->dwFrameNumber;
        m_fqFree.Enqueue( m_fqReady.Dequeue() );
    }

    // Step 3: Now we have at most 1 frame starting before current time
    // See if he should be submitted to render
    if( !m_fqReady.IsEmpty() &&
        m_fqReady.m_pHead->rtTimeStamp <= m_rtCurrentTime )
    {
        // Render the packet
        m_pCurrentFrame = m_fqReady.Dequeue();
		m_dwCurrentFrame = m_pCurrentFrame->dwFrameNumber;
        m_fqBusy.Enqueue( m_pCurrentFrame );
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: FindFreePacket
// Desc: Attempts to find a free audio packet (one that isn't currently 
//       submitted to the stream).  Returns TRUE if it found one
//-----------------------------------------------------------------------------
BOOL
CWmvPerfTest::FindFreePacket( DWORD * pdwIndex )
{
    // Check the status of each packet
    for( int i = 0; i < WMV_PERF_TEST_NUM_PACKETS; i++ )
    {
        // If we find a non-pending packet, return it
        if( m_adwStatus[ i ] != XMEDIAPACKET_STATUS_PENDING )
        {
            *pdwIndex = i;
            return TRUE;
        }
    }

    return FALSE;
}



//-----------------------------------------------------------------------------
// Name: FindFreeFrame
// Desc: Attempts to find an available video frame (one that is not in the
//          pending video frame queue).  Returns TRUE if one was available
//-----------------------------------------------------------------------------
BOOL
CWmvPerfTest::FindFreeFrame( VIDEOFRAME ** ppFrame )
{
    // Do we have any frames in the free queue?
    if( !m_fqFree.IsEmpty() )
    {
        *ppFrame = m_fqFree.m_pHead;
        return TRUE;
    }

    return FALSE;
}
#endif

VOID
CWmvPerfTest::DumpPerfData()
{
	DbgPrint( "\n[WmvPerf] performance for %s:\n\
				Video Dimesions: %d x %d\n\
				Video Bitrate: %d bps\n\
				Audio Bits per sample: %d\n\
				Audio Samples per second: %d\n\
				Format: %s\n\
				Rendered FPS: %d\n\
				Decoded FPS: %d\n\
				Dropped Frames: %d / %d (%d%%)\n\
				Last Dropped: %d\n\n",
				m_FindData.cFileName,
				m_wmvVideoInfo.dwWidth, m_wmvVideoInfo.dwHeight,
				m_wmvVideoInfo.dwBitsPerSecond,
				m_wfx.wBitsPerSample, 
				m_wfx.nSamplesPerSec,
				"YUY2",
				(m_rtCurrentTime > 10000000) ? (INT)(m_dwRenderedFrames / (m_rtCurrentTime/10000000)) : 0,
				(m_rtCurrentTime > 10000000) ? (INT)(m_dwVideoFrames / (m_rtCurrentTime/10000000)) : 0,
				m_dwDroppedFrames, m_dwVideoFrames, (m_dwVideoFrames) ? m_dwDroppedFrames*100/m_dwVideoFrames : 0,
				m_dwLastDroppedFrame );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvRegression\WmvRegression.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvRegression.h

Abstract:

    WmvRegression utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvRegression\WmvRegressionTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvRegressionTest.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 07-Dec-2001

Revision History:

	07-Dec-2001 jeffsul
		Initial Version

--*/

#ifndef _WMVREGRESSIONTEST_H_
#define _WMVREGRESSIONTEST_H_

#include "..\WmvCommon\Test.h"
#include "..\WmvCommon\WMVPlayer.h"

#define WMV_REG_TEST_CRC_ELEMENTS	256

class CWmvRegTest : public CTest
{
public:
	CWmvRegTest();
	~CWmvRegTest();

protected:
	HRESULT ReadIni();
	HRESULT InitGraphics();
	HRESULT DestroyGraphics();
	HRESULT InitAudio();
	HRESULT DestroyAudio();
	HRESULT InitResources();
	HRESULT DestroyResources();
	
	HRESULT ProcessInput();
	HRESULT Update();
	HRESULT Render();

private:
	CWMVPlayer				m_WMVPlayer;		
	LPDIRECT3DTEXTURE8		m_pOverlay[2];				// Overlay textures
    LPDIRECT3DSURFACE8		m_pSurface[2];				// Overlay Surfaces
    DWORD					m_dwCurrent;				// Current surface

	LPDIRECT3DDEVICE8		m_pD3DDevice;				// rendering device
	LPDIRECTSOUND8			m_pDSound;					// sound device	
	HANDLE                  m_hInputDevice;				// input device
	XINPUT_STATE			m_PrevInputState;           // previous input state

	WMVVIDEOINFO			m_wmvVideoInfo;             // Video info
	WAVEFORMATEX			m_wfx;                      // Audio format

	REFERENCE_TIME			m_rtStartTime;				// Reference time at start
	REFERENCE_TIME			m_rtDuration;               // Duration of video
    REFERENCE_TIME			m_rtCurrentTime;			// Reference time of current frame

	CHAR					m_szPath[MAX_PATH];			// file path of video to play
	HANDLE					m_hFiles;					// handle to file search data
	WIN32_FIND_DATA			m_FindData;					// info about the next file to open
	HANDLE					m_hOutputFile;				// file to ouput crc data to
	HANDLE					m_hInputFile;				// file to read correct crc from

	BOOL					m_bReset;

	DWORD					m_dwCRCTable[WMV_REG_TEST_CRC_ELEMENTS];
	DWORD					m_dwChecksums[512];
	INT						m_nChecksumIndex;

	DWORD					ComputeCRC32( LPVOID pvData, UINT uNumBytes );
	BOOL					CompareCRC();
};


#endif //#ifndef _WMVREGRESSIONTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvVerification\WmvVerification.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvVerification.h

Abstract:

    WmvVerification utility interface

--*/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <xtestlib.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvVerification\WmvVerification.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvVerification.cpp

Abstract:

    WmvVerification tests

--*/

#include "WmvVerification.h"
#include "WmvVerificationTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
WmvVerification_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for WmvVerification

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

    //
    // Return the Hresult
    //
	CWmvVerificationTest theTest;
	EXECUTE( theTest.Run() );

	XLaunchNewImage( NULL, NULL );

    return hr;
}

VOID 
WINAPI 
WmvVerification_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the WmvVerification tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test WmvVerification in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "jeffsul", "MCPX", "WmvVerification", "Basic" );
    EXECUTE( WmvVerification_BasicTest() );

}

VOID 
WINAPI 
WmvVerification_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    WmvVerification_StartTest( NULL );
    WmvVerification_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WmvVerification )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WmvVerification )
    EXPORT_TABLE_ENTRY( "StartTest", WmvVerification_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WmvVerification_EndTest )
END_EXPORT_TABLE( WmvVerification )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvRegression\WmvRegression.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    WmvRegression.cpp

Abstract:

    WmvRegression tests

--*/

#include "WmvRegression.h"
#include "WmvRegressionTest.h"

//
// The Global Logging Handle
//

extern HANDLE g_hLog;

HRESULT
WmvRegression_BasicTest(
    void
    )
/*++

Routine Description:

    Basic Test for WmvRegression

Arguments:

    None

Return Value:

    S_OK on success
    E_XX on failure

--*/
{
    HRESULT             hr              = S_OK;

	CWmvRegTest		theTest;
	EXECUTE( theTest.Run() );

#ifdef NOLOGGING
	XLaunchNewImage( NULL, NULL );
#endif

    //
    // Return the Hresult
    //

    return hr;
}

VOID 
WINAPI 
WmvRegression_StartTest( 
    HANDLE              LogHandle 
    )
/*++

Routine Description:

    The harness entry into the WmvRegression tests

Arguments:

    LogHandle - a handle to a logging object

Return Value:

    None

--*/
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test WmvRegression in the mannor it was meant to be called
    //

    if ( SHOULDRUNTEST( "WmvRegression", "Basic" ) )
    {
        SETLOG( LogHandle, "jeffsul", "Online", "WmvRegression", "Basic" );
        EXECUTE( WmvRegression_BasicTest() );
    }

}

VOID 
WINAPI 
WmvRegression_EndTest( 
    VOID 
    )
/*++

Routine Description:

    The exit function for the test harness

Arguments:

    None

Return Value:

    None

--*/
{
}

#ifdef NOLOGGING
void 
__cdecl 
main( 
    void 
    )
/*++

Routine Description:

    the exe entry point

Arguments:

    None

Return Value:

    None

--*/
{
    WmvRegression_StartTest( NULL );
    WmvRegression_EndTest();
}
#endif // NOLOGGING

//
// Export Function Pointers for StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( WmvRegression )
#pragma data_seg()

BEGIN_EXPORT_TABLE( WmvRegression )
    EXPORT_TABLE_ENTRY( "StartTest", WmvRegression_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", WmvRegression_EndTest )
END_EXPORT_TABLE( WmvRegression )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvRegression\WmvRegressionTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvRegressionTest.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 28-Dec-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	28-Dec-2001 jeffsul
		Initial Version

--*/


#include "WmvRegressionTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

//#define	WMV_REG_GENERATE_CRC

CWmvRegTest::CWmvRegTest()
{
	m_bReset = FALSE;
	m_hOutputFile = INVALID_HANDLE_VALUE;
	m_hFiles = INVALID_HANDLE_VALUE;

	// Initialize the CRC table
	INT	i, j;
	DWORD dwCRC;
    for (i = 0; i < 256; i++) 
	{
        dwCRC = i;
        for (j = 0; j < 8; j++) 
		{
            dwCRC = (dwCRC & 1) ? ((dwCRC >> 1) ^ 0xEDB88320L) : (dwCRC >> 1);
        }
        m_dwCRCTable[i] = dwCRC;
    }
}


CWmvRegTest::~CWmvRegTest()
{
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::ReadIni()
{
	HRESULT		hr			= S_OK;

	CHAR	szSearchPath[MAX_PATH];
	
	//Initialize our network.
	// initialize the Xbox Secure Network Library (SNL).
	if ( 0 == XNetAddRef() )
	{
		DbgPrint( "[WMVREG] Error: Unable to initialize Xbox SNL (error %d)\n", nSuccess );
		return E_FAIL;
	}

	// grab media files from server
	MLSetErrorLevel( 3 );
#define CREATE_FLAG	COPY_IF_NEWER
	MEDIAFILEDESC MediaFiles[] =
	{
		{"wmv/ms_wmv_v8/%3",	"T:\\WMV\\Reg\\",			CREATE_FLAG},
		{NULL,									NULL,								0}
	};
	EXECUTE( LoadMedia( MediaFiles ) );

	// look for files on the xbox matching certain parameters
	strcpy( m_szPath, "T:\\WMV\\Reg\\" );
	sprintf( szSearchPath, "%s*.wmv", m_szPath );
	
	m_hFiles = FindFirstFile( szSearchPath, &m_FindData );
	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
		return E_FAIL;
	}

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::InitGraphics()
{
	HRESULT		hr			= S_OK;

	hr = InitD3DDevice( &m_pD3DDevice );

	m_pD3DDevice->EnableOverlay( TRUE );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::DestroyGraphics()
{
	HRESULT		hr			= S_OK;

	RELEASE( m_pD3DDevice );

	// call xnetcleanup here so it only happens one time
	XNetRelease();

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::InitAudio()
{
	HRESULT		hr			= S_OK;

	hr = DirectSoundCreate( NULL, &m_pDSound, NULL );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create Direct Sound (error: %x)\n", hr );
		return hr;
	}

	hr = m_WMVPlayer.Initialize( m_pD3DDevice, m_pDSound );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to initialize WMVPlayer (error: %x)\n", hr );
		return hr;
	}

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::DestroyAudio()
{
	HRESULT		hr			= S_OK;

	RELEASE( m_pDSound );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::InitResources()
{
	HRESULT		hr			= S_OK;

	m_rtStartTime = 0;
	m_nChecksumIndex = 0;

	// Create the video decoder.  We only load
    // the section containing the decoder on demand
    XLoadSection("WMVDEC");
	CHAR	szFileName[MAX_PATH];
	sprintf( szFileName, "%s%s", m_szPath, m_FindData.cFileName );

	hr = m_WMVPlayer.OpenFile( szFileName );
	if ( FAILED( hr ) )
	{
		DbgPrint( "Unable to create WMVPlayer for '%s' (error: %x)\n", szFileName, hr );
		return E_FAIL;
	}

    m_WMVPlayer.GetVideoInfo( &m_wmvVideoInfo );

	// Create two textures based off the video format.  We need to
    // use two textures because the overlay surface reads directly
    // from the texture.  Updating a texture while it's being used
    // by the overlay will cause tearing
    for( int i = 0; i < 2; i++ )
    {
        m_pD3DDevice->CreateTexture( m_wmvVideoInfo.dwWidth,
                                     m_wmvVideoInfo.dwHeight,
                                     1,
                                     0,
                                     D3DFMT_YUY2,
                                     0,
                                     &m_pOverlay[i] );
        m_pOverlay[i]->GetSurfaceLevel( 0, &m_pSurface[i] );
    }
    m_dwCurrent = 0;

	CHAR	szCrcFileName[MAX_PATH];
	LPSTR	lpszExtension;

	strcpy( szCrcFileName, szFileName );
	lpszExtension = strchr( szCrcFileName, '.' );
	strcpy( lpszExtension, ".crc" );

#ifdef WMV_REG_GENERATE_CRC
	m_hOutputFile = CreateFile( szCrcFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == m_hOutputFile )
	{
		return E_FAIL;
	}
#else

	// grab media files from server
	CHAR	szRemotePath[MAX_PATH];
	MLSetErrorLevel( 3 );
	MEDIAFILEDESC MediaFiles[] =
	{
		{szRemotePath,	"T:\\WMV\\Reg\\",			CREATE_FLAG},
		{NULL,									NULL,								0}
	};
	sprintf( szRemotePath, "wmv/crc/%s", m_FindData.cFileName );
	lpszExtension = strchr( szRemotePath, '.' );
	strcpy( lpszExtension, ".crc" );
	LoadMedia( MediaFiles );

	m_hInputFile = CreateFile( szCrcFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == m_hInputFile )
	{
		DbgPrint( "[WMVREG]: Unable to open input file %s (error: %x)\n", szCrcFileName, GetLastError() );
		return E_FAIL;
	}
#endif

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::DestroyResources()
{
	HRESULT		hr			= S_OK;

	for( UINT i = 0; i < 2; i++ )
    {
        RELEASE( m_pSurface[i] );
        RELEASE( m_pOverlay[i] );
    }
	m_WMVPlayer.CloseFile();

	XFreeSection("WMVDEC");

	if ( !FindNextFile( m_hFiles, &m_FindData ) )
	{
		CHAR	szSearchPath[MAX_PATH];

		sprintf( szSearchPath, "%s*.wmv", m_szPath );
		
		m_hFiles = FindFirstFile( szSearchPath, &m_FindData );
	}

	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
			m_bQuit = TRUE;
	}

	CloseHandle( m_hOutputFile );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::ProcessInput()
{
	HRESULT		hr			= S_OK;

	XINPUT_STATE		XInputState;
	ZeroMemory(	&XInputState, sizeof(XINPUT_STATE) );

	hr = GetNextInputState( &m_hInputDevice, &XInputState );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
HRESULT CWmvRegTest::Update()
{
	HRESULT		hr			= S_OK;

	if ( m_bReset )
	{
		DestroyResources();
		if ( TRUE == m_bQuit )
		{
			return S_OK;
		}
		hr = InitResources();
		m_bReset = FALSE;
		//m_bGotData = FALSE;
		//g_dwVBlankCount = 0;

		if ( FAILED( hr ) )
		{
			m_bReset = TRUE;
			return hr;
		}
	}

	// Set our time for this frame:
	// Video Time = Current Time - Start Time + Seek Adjustment
	if ( 0 == m_rtStartTime )
	{
		m_pDSound->GetTime( &m_rtStartTime );
	}
	m_pDSound->GetTime( &m_rtCurrentTime );
	m_rtCurrentTime = m_rtCurrentTime - m_rtStartTime;

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
#define CLAMP( x, a, b ) \
if ( x < a ) x = a; \
else if ( x > b ) x = b;
HRESULT CWmvRegTest::Render()
{
	HRESULT		hr			= S_OK;

	RECT rcSrc = { 0, 0, m_wmvVideoInfo.dwWidth, m_wmvVideoInfo.dwHeight };
	RECT rcDest;
	rcDest.left		= 320-m_wmvVideoInfo.dwWidth / 2;
	CLAMP( rcDest.left, 0, 320 );
	rcDest.top		= 240-m_wmvVideoInfo.dwHeight / 2;
	CLAMP( rcDest.top, 0, 240 );
	rcDest.right	= 320+m_wmvVideoInfo.dwWidth / 2;
	CLAMP( rcDest.right, 320, 640 );
	rcDest.bottom	= 240+m_wmvVideoInfo.dwHeight / 2;
	CLAMP( rcDest.bottom, 240, 480 );

	// clear the rendering surface
	EXECUTE( m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( 0, 0, 0 ), 1.0f, 0L ) );

	// begin the scene
	EXECUTE( m_pD3DDevice->BeginScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// Get the next frame into our texture
	hr = m_WMVPlayer.GetTexture( m_pOverlay[m_dwCurrent] );
	if( FAILED( hr ) )
	{
		__asm int 3;
	}

	if ( m_WMVPlayer.IsReady() )
    {
		m_pD3DDevice->BlockUntilVerticalBlank();
		m_pD3DDevice->UpdateOverlay( m_pSurface[m_dwCurrent], &rcSrc, &rcDest, FALSE, 0 );

		// generate checksum for frame
		DWORD	dwChecksum;
		D3DLOCKED_RECT	LockedRect;
		D3DSURFACE_DESC SurfaceDesc;

		hr = m_pSurface[m_dwCurrent]->LockRect( &LockedRect, NULL, D3DLOCK_READONLY );
		if ( FAILED( hr ) )
		{
			__asm int 3;
		}

		hr = m_pSurface[m_dwCurrent]->GetDesc( &SurfaceDesc );
		if ( FAILED( hr ) )
		{
			__asm int 3;
		}
		
		dwChecksum = ComputeCRC32( LockedRect.pBits, SurfaceDesc.Size );

#ifdef WMV_REG_GENERATE_CRC
		m_dwChecksums[m_nChecksumIndex] = dwChecksum;

		m_nChecksumIndex++;
		if ( 512 <= m_nChecksumIndex )
		{
			DWORD	dwNumBytesWritten;
			WriteFile( m_hOutputFile, m_dwChecksums, sizeof( DWORD )*512, &dwNumBytesWritten, NULL );
			if ( 512*sizeof( DWORD ) != dwNumBytesWritten )
			{
				__asm int 3;
			}
			m_nChecksumIndex = 0;
		}
#else
		DWORD	dwNumBytesRead, dwCorrectChecksum;
		ReadFile( m_hInputFile, &dwCorrectChecksum, sizeof( DWORD ), &dwNumBytesRead, NULL );
		if ( sizeof( DWORD ) != dwNumBytesRead )
		{
			__asm int 3;
		}

		if ( dwChecksum != dwCorrectChecksum )
		{
			DbgPrint( "[WMVREG]: Checksum failed.  Expected %x, got %x.\n", dwCorrectChecksum, dwChecksum );
		}
#endif
		
		// Decode the next frame
		if( S_FALSE == m_WMVPlayer.DecodeNext() )
		{
			m_bReset = TRUE;
#ifdef WMV_REG_GENERATE_CRC
			DWORD	dwNumBytesWritten;
			WriteFile( m_hOutputFile, m_dwChecksums, sizeof( DWORD )*m_nChecksumIndex, &dwNumBytesWritten, NULL );
			if ( m_nChecksumIndex*sizeof( DWORD ) != dwNumBytesWritten )
			{
				__asm int 3;
			}
			m_nChecksumIndex = 0;
#endif
			return hr;
		}
		
		// We'll use the other texture next time
		m_dwCurrent ^= 1;
	}

	// render the scene to the surface
	EXECUTE( m_pD3DDevice->EndScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// flip the surface to the screen
	EXECUTE( m_pD3DDevice->Present( NULL, NULL, NULL, NULL ) );

	return hr;
}


DWORD CWmvRegTest::ComputeCRC32( LPVOID pvData, UINT uNumBytes ) 
{
    LPBYTE pData = (LPBYTE)pvData;
    DWORD  dwCRC = 0;
    UINT   i;

    for (i = 0; i < uNumBytes; i++) {
        dwCRC = m_dwCRCTable[(dwCRC ^ pData[i]) & 0xFF] ^ (dwCRC >> 8);
    }

    return dwCRC;
}


BOOL CWmvRegTest::CompareCRC()
{
	BOOL		bSuccess		= FALSE;
	HANDLE		hFile			= INVALID_HANDLE_VALUE;

	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvVerification\WmvVerificationTest.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvVerificationTest.h

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 26-Sep-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	26-Sep-2001 jeffsul
		Initial Version

--*/

#ifndef _WMVVERIFICATION_H_
#define _WMVVERIFICATION_H_

#include "..\WmvCommon\Test.h"

#include <wmvxmo.h>

#include "..\WmvCommon\FrameQueue.h"
#include "..\WmvCommon\bitfont.h"

#define WMV_VER_TEST_NUM_FRAMES		16
#define WMV_VER_TEST_NUM_PACKETS	48
#define WMV_VER_TEST_PACKET_SIZE	4096

// Vertex definition for the screen-space quad
#define FVF_CUSTOMVERTEX (D3DFVF_XYZRHW|D3DFVF_TEX1)
typedef struct {
    D3DXVECTOR4 p;
    D3DXVECTOR2 t;
} CUSTOMVERTEX;

typedef struct _TVERTEX
{
	FLOAT x, y, z, rhw; // The transformed position for the vertex
	FLOAT u, v;         // Texture coordinates
} TVERTEX;

/*typedef enum {
	WMVTS_DECODE,
	WMVTS_COMPARE
} WMVTESTSTATE;*/

class CWmvVerificationTest : public CTest
{
public:
	CWmvVerificationTest();
	~CWmvVerificationTest();

protected:
	HRESULT ReadIni();
	HRESULT InitGraphics();
	HRESULT DestroyGraphics();
	HRESULT InitAudio();
	HRESULT DestroyAudio();
	HRESULT InitResources();
	HRESULT DestroyResources();

	HRESULT Update();
	HRESULT Render();

private:
	// resources
	LPDIRECT3DDEVICE8		m_pD3DDevice;				// rendering device
	LPDIRECTSOUND8			m_pDSound;					// sound device
	LPWMVDECODER			m_pWMVDecoder;				// WMV decoder 
	XMEDIAPACKET			m_xmpAudio, m_xmpVideo;		// decoded media packets
	DWORD					m_audStat, m_vidStat;		// decoded media status
	DWORD					m_audSize, m_vidSize;		// decoded media buffer size
	REFERENCE_TIME			m_rtAudio, m_rtVideo;		// decoded media timestamp
	LPDIRECT3DTEXTURE8		m_pd3dtText;				// texture to render text to
	TVERTEX					m_prText[4];				// geometry to display text on
	BitFont					m_BitFont;					// font interface

	// file io
	CHAR					m_szPath[MAX_PATH];			// file path of video to play
	WCHAR					m_szWideFileName[MAX_PATH]; // the wide character file name of the current file
	CHAR					m_szRawPath[MAX_PATH];		// file path to output .raw file
	CHAR					m_szPcmPath[MAX_PATH];		// file path to output .pcm file
	HANDLE					m_hRawFile;					// file to dump raw video frames to
	HANDLE					m_hPcmFile;					// file to dump raw audio stream to
	HANDLE					m_hFiles;					// handle to file search data
	WIN32_FIND_DATA			m_FindData;					// info about the next file to open

	// test state
	DWORD					m_dwVideoFrames;			// Total number of frames
	DWORD					m_dwAudioFrames;			// Total number of audio packets
	DWORD					m_dwBitsPerSample;			// Number of bits per audio sample
	BOOL					m_bReset;					// set to TRUE at end of video
	DWORD					m_dwLastFPS;				// Last time we sampled the FPS

	DWORD					m_dwMaxDiffAudio;
	DWORD					m_dwMaxDiffAudioFrame;
	DOUBLE					m_fMaxStdDevAudio;
	DWORD					m_dwMaxStdDevAudioFrame;

	DWORD					m_dwMaxDiffVideo;
	DWORD					m_dwMaxDiffVideoFrame;
	DOUBLE					m_fMaxStdDevVideo;
	DWORD					m_dwMaxStdDevVideoFrame;

	// private member functions
	HRESULT OutputRawData( IN LPCXMEDIAPACKET pVideoPacket );
	HRESULT OutputPcmData( IN LPCXMEDIAPACKET pAudioPacket );
	VOID	CompareFrames();
	VOID	CompareAudio();
};	

#endif //#ifndef _WMVVERIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xact\engine\devtest\devtest.h ===
#define MAX_SOUNDBANKS  5
#define MAX_WAVEBANKS  5
#define MAX_SOUNDSOURCES  5
#define MAX_CUES_PER_BANK  5

typedef struct _SOUND_BANK_CONTEXT {

    DWORD dwNumSoundCues;
    PXACTSOUNDBANK pSoundBank;
    PXACTSOUNDCUE paSoundCues[MAX_CUES_PER_BANK];
    PVOID   pvSoundBankData;

} SOUND_BANK_CONTEXT, *PSOUND_BANK_CONTEXT;

typedef struct _WAVE_BANK_CONTEXT {

    PXACTWAVEBANK pWaveBank;
    PVOID   pvWaveBankData;
    DWORD   dwSize;

} WAVE_BANK_CONTEXT, *PWAVE_BANK_CONTEXT;


class CXactTest {
public:

    CXactTest();
    ~CXactTest();

    HRESULT Initialize(DWORD dwNumSoundBanks,
        DWORD dwNumWaveBanks,
        DWORD dwNumSoundSources
        );

    //
    // tests
    //

    HRESULT BasicPlayStop();
    HRESULT RuntimeEvents();
    HRESULT Notifications();

    VOID    ThreadProc();
    VOID    LinkAll();

private:

    PXACTENGINE             m_pEngine;
    PVOID                   m_pvDspImage;
    DWORD                   m_dwNumSoundSources;
    DWORD                   m_dwNumSoundBanks;
    DWORD                   m_dwNumWaveBanks;


    SOUND_BANK_CONTEXT      m_aSoundBanks[MAX_SOUNDBANKS];
    PXACTSOUNDSOURCE        m_paSoundSources[MAX_SOUNDSOURCES];
    PXACTSOUNDCUE           m_paSoundCues[MAX_SOUNDSOURCES];
    WAVE_BANK_CONTEXT       m_aWaveBanks[MAX_WAVEBANKS];    
   
    HANDLE                  m_hThread;
    DWORD                   m_dwThreadId;
public:
    BOOL                    m_bTestNotifications;
    BOOL                    m_bTestBasicPlayStop;
    BOOL                    m_bTestRuntimeEvents;
    BOOL                    m_bTestPrematureWavebankUnregister;
};


HRESULT LoadBinaryData(const CHAR *pszName, PVOID *ppvData, PDWORD pdwSize);
VOID CreateRandomEvent(PXACT_TRACK_EVENT pEvent);

DWORD WINAPI XactTestThreadProc(
    LPVOID pParameter
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\wmv\WmvVerification\WmvVerificationTest.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

	WmvVerificationTest.cpp

Abstract:

	abstract-for-module

Author:

	Jeff Sullivan (jeffsul) 26-Sep-2001

[Environment:]

	optional-environment-info (e.g. kernel mode only...)

[Notes:]

	optional-notes

Revision History:

	26-Sep-2001 jeffsul
		Initial Version

--*/


#include "WmvVerificationTest.h"

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xgmath.h>
#include <medialoader.h>

#include <stdio.h>
#include <tchar.h>

#define WMVTEST_APP_NAME	"WMVTEST"
#define	WMVTEST_INI_PATH	"D:\\WMVTest.ini"

//BOOL g_bOverlay = TRUE;

/*++

Routine Description:

	Test constructor

Arguments:

	None

Return Value:

	None

--*/
CWmvVerificationTest::CWmvVerificationTest()
{
	m_pD3DDevice = NULL;
	m_pDSound = NULL;
	m_pWMVDecoder = NULL;
	m_bReset = FALSE;
}


/*++

Routine Description:

	Test destructor

Arguments:

	None

Return Value:

	None

--*/
CWmvVerificationTest::~CWmvVerificationTest()
{
}


/*++

Routine Description:

	read initialization variables from an ini file

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::ReadIni()
{
	HRESULT hr = S_OK;

	CHAR	szSearchPath[MAX_PATH];

	// grab media files from server
	MLSetErrorLevel( 3 );
	MEDIAFILEDESC MediaFiles[] =
	{
		{"wmv/dolphin(\\w*).wmv",	"T:\\WMV\\",			COPY_IF_NEWER},
		{NULL,									NULL,								0}
	};
	EXECUTE( LoadMedia( MediaFiles ) );

	// look for files on the xbox matching certain parameters
	GetIniString( WMVTEST_APP_NAME, "WMVFileDirectory", "T:\\WMV\\", m_szPath, MAX_PATH, WMVTEST_INI_PATH );

	sprintf( szSearchPath, "%sdolphin*.wmv", m_szPath );
	
	m_hFiles = FindFirstFile( szSearchPath, &m_FindData );
	if ( INVALID_HANDLE_VALUE == m_hFiles )
	{
		return E_FAIL;
	}

	// create a wide character file name (for output later to screen)
	for( UINT i = 0; i < strlen( m_FindData.cFileName ); i++ )
	{
		m_szWideFileName[i] = (WCHAR)m_FindData.cFileName[i];
	}
	m_szWideFileName[i] = 0;

	return hr;
}


/*++

Routine Description:

	initialize graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::InitGraphics()
{
	HRESULT hr = S_OK;

	D3DPRESENT_PARAMETERS	d3dpp;

	// Set the screen mode.
    ZeroMemory(&d3dpp, sizeof(d3dpp));

    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;   // Must be FALSE for Xbox.
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

	EXECUTE( Direct3D_CreateDevice(	D3DADAPTER_DEFAULT, 
									D3DDEVTYPE_HAL,
									NULL, 
									D3DCREATE_HARDWARE_VERTEXPROCESSING, 
									&d3dpp, 
									&m_pD3DDevice) );
    if ( FAILED ( hr ) )
	{
        return hr;
    }

	// Create a buffer for the text
    hr = m_pD3DDevice->CreateTexture(320, 240, 1, 0, D3DFMT_LIN_A8R8G8B8, 0, &m_pd3dtText);
    if (FAILED(hr)) {
        return hr;
    }

    // Clear the texture
	D3DLOCKED_RECT d3dlr;
    m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
    for ( UINT i = 0; i < 240; i++) {
        memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
    }
    m_pd3dtText->UnlockRect(0);

    m_prText[0].x = 0.0f;
    m_prText[0].y = 480.0f;
    m_prText[0].u = 0.0f;
    m_prText[0].v = 240.0f;

    m_prText[1].x = 0.0f;
    m_prText[1].y = 0.0f;
    m_prText[1].u = 0.0f;
    m_prText[1].v = 0.0f;

    m_prText[2].x = 640.0f;
    m_prText[2].y = 0.0f;
    m_prText[2].u = 320.0f;
    m_prText[2].v = 0.0f;

    m_prText[3].x = 640.0f;
    m_prText[3].y = 480.0f;
    m_prText[3].u = 320.0f;
    m_prText[3].v = 240.0f;

    for (i = 0; i < 4; i++) {
        m_prText[i].z = 0.0f; //0.000001f;
        m_prText[i].rhw = 1.0f; ///1000000.0f;
    }

	return hr;
}


/*++

Routine Description:

	cleanup graphics rendering device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::DestroyGraphics()
{
	HRESULT hr = S_OK;

	RELEASE( m_pD3DDevice );
	RELEASE( m_pd3dtText );

	return hr;
}


/*++

Routine Description:

	initialize audio device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::InitAudio()
{
	HRESULT hr = S_OK;

	hr = DirectSoundCreate( NULL, &m_pDSound, NULL );

	return hr;
}


/*++

Routine Description:

	cleanup audio device

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::DestroyAudio()
{
	HRESULT hr = S_OK;

	RELEASE( m_pDSound );

	return hr;
}


/*++

Routine Description:

	initialize wmv resources

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::InitResources()
{
	HRESULT hr = S_OK;
	
	m_dwLastFPS = m_dwCurrentTime-1000;

	m_dwVideoFrames = 0;
	m_dwAudioFrames = 0;

	m_dwMaxDiffAudio = 
	m_dwMaxDiffAudioFrame =
	m_dwMaxStdDevAudioFrame =
	m_dwMaxDiffVideo =
	m_dwMaxDiffVideoFrame =
	m_dwMaxStdDevVideoFrame = 0;

	m_fMaxStdDevAudio = 
	m_fMaxStdDevVideo = 0.0;

	m_audStat = 
	m_audSize =
	m_vidStat =
	m_vidSize = 0;
	m_rtAudio = 
	m_rtVideo = 0;

	m_hRawFile =
	m_hPcmFile = NULL;


	ZeroMemory( &m_xmpAudio, sizeof( XMEDIAPACKET ) );
	ZeroMemory( &m_xmpVideo, sizeof( XMEDIAPACKET ) );

	//------------------------------------------------------------------------------
	//	Load the section containg the WMV decoder
	//------------------------------------------------------------------------------
    XLoadSection("WMVDEC");

	//------------------------------------------------------------------------------
	//	Set up file io
	//------------------------------------------------------------------------------

	CHAR	szFileName[MAX_PATH];
	sprintf( szFileName, "%s%s", m_szPath, m_FindData.cFileName );
	strcpy( m_szRawPath, szFileName );
	strcpy( m_szPcmPath, szFileName );
	LPSTR	lpszTemp;
	lpszTemp = strrchr( m_szRawPath, '.' );
	CHECKPTR( lpszTemp );
	*lpszTemp = '\0';
	lpszTemp = strrchr( m_szPcmPath, '.' );
	CHECKPTR( lpszTemp );
	strcpy( lpszTemp, ".pcm" );

	m_hPcmFile = CreateFile( m_szPcmPath, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == m_hPcmFile )
	{
		DbgPrint( "Unable to open %s for writing (error %d)\n", m_szPcmPath, GetLastError() );
		return E_FAIL;
	}

	//------------------------------------------------------------------------------
	//	Create the video decoder.
	//------------------------------------------------------------------------------

    hr = WmvCreateDecoder( szFileName,
							NULL,
							/*g_bOverlay ? */WMVVIDEOFORMAT_YUY2/* : WMVVIDEOFORMAT_RGB32*/,
							NULL,
							&m_pWMVDecoder );
	if ( FAILED( hr ) )
	{
		SAFECLOSEHANDLE( m_hPcmFile );
		DbgPrint( "Unable to create decoder for '%s' (error: %d)\n", szFileName, hr );
		return E_FAIL;
	}

	//------------------------------------------------------------------------------
	//	set up for decoding
	//------------------------------------------------------------------------------

	WMVVIDEOINFO			wmvVideoInfo;             // Video info
	WAVEFORMATEX			wmvAudioInfo;             // Audio format

	CHECKEXECUTE( m_pWMVDecoder->GetVideoInfo( &wmvVideoInfo ) );
	CHECKEXECUTE( m_pWMVDecoder->GetAudioInfo( &wmvAudioInfo ) );
	
	// Set up an audio packet
	m_xmpAudio.dwMaxSize = WMV_VER_TEST_PACKET_SIZE;
	m_xmpAudio.pdwStatus = &m_audStat;
	m_xmpAudio.pdwCompletedSize = &m_audSize;
	m_xmpAudio.prtTimestamp = &m_rtAudio;
	m_dwBitsPerSample = wmvAudioInfo.wBitsPerSample;

	m_xmpAudio.pvBuffer  = new BYTE[ WMV_VER_TEST_PACKET_SIZE ];
	if ( NULL == m_xmpAudio.pvBuffer )
	{
		DbgPrint("");
		return E_FAIL;
	}
	ZeroMemory( m_xmpAudio.pvBuffer, m_xmpAudio.dwMaxSize );
	
	// Set up a video packet
	m_xmpVideo.dwMaxSize = wmvVideoInfo.dwWidth * wmvVideoInfo.dwHeight * wmvVideoInfo.dwOutputBitsPerPixel / 8;
	m_xmpVideo.pdwStatus = &m_vidStat;
	m_xmpVideo.pdwCompletedSize = &m_vidSize;
	m_xmpVideo.prtTimestamp = &m_rtVideo;
	
	m_xmpVideo.pvBuffer  = new BYTE [m_xmpVideo.dwMaxSize];
	if ( NULL == m_xmpVideo.pvBuffer )
	{
		DbgPrint("");
		return E_FAIL;
	}
	ZeroMemory( m_xmpVideo.pvBuffer, m_xmpVideo.dwMaxSize );

	return hr;
}


/*++

Routine Description:

	cleanup wmv resources

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::DestroyResources()
{
	HRESULT hr = S_OK;
	
	RELEASE( m_pWMVDecoder );
	XFreeSection("WMVDEC");

	SAFECLOSEHANDLE( m_hPcmFile );

	if ( !FindNextFile( m_hFiles, &m_FindData ) )
	{
		m_bQuit = TRUE;
	}
	else
	{
		for( UINT i = 0; i < strlen( m_FindData.cFileName ); i++ )
		{
			m_szWideFileName[i] = (WCHAR)m_FindData.cFileName[i];
		}
		m_szWideFileName[i] = 0;
	}

	SAFEDELETE( m_xmpAudio.pvBuffer );
	SAFEDELETE( m_xmpVideo.pvBuffer );

	return hr;
}


/*++

Routine Description:

	update the scene each frame

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::Update()
{
	HRESULT hr = S_OK;

	if ( m_bReset )
	{
		HRESULT hrTemp = S_OK;
		// just checking discontuinuity to make sure it does what the doc says (just return DS_OK)
		hrTemp = m_pWMVDecoder->Discontinuity();
		if ( DS_OK != hrTemp )
		{
			DbgPrint( "IWMVDecoder::Discontinuity() returned %d, should always be DS_OK\n", hrTemp );
		}
		hrTemp = m_pWMVDecoder->Flush();
		if ( FAILED( hrTemp ) )
		{
			DbgPrint( "IWMVDecoder::Flush() failed (hr = %d)\n", hrTemp );
		}

		CHAR	szBuf[MAX_PATH];
		sprintf( szBuf, "Max Diff Pixel: %d (Frame: %d)\tMax Std Dev: %f (Frame: %d)\nMax Diff Sample: %d (Frame: %d)\tMax Std Dev: %f (Frame %d)",
				m_dwMaxDiffVideo, m_dwMaxDiffVideoFrame,
				m_fMaxStdDevVideo, m_dwMaxStdDevVideoFrame,
				m_dwMaxDiffAudio, m_dwMaxDiffAudioFrame,
				m_fMaxStdDevAudio, m_dwMaxStdDevAudioFrame );

		DbgPrint( szBuf );

		DestroyResources();
		if ( TRUE == m_bQuit )
		{
			return hr;
		}
		InitResources();
		m_bReset = FALSE;
	}
	
	// Process the decoder
	hr = m_pWMVDecoder->ProcessMultiple( &m_xmpVideo, &m_xmpAudio );
	if( S_FALSE == hr )
	{
		m_bReset = TRUE;
		//m_State = WMVTS_COMPARE;
	}
	
	// If we got a video frame dump it to a file
	if( m_vidSize > 0 )
	{
		CompareFrames();
		//OutputRawData( &m_xmpVideo );
		m_dwVideoFrames++;
		m_vidSize = 0;
	}
	
	// If we got an audio packet dump it to the file
	if( m_audSize > 0 )
	{
		CompareAudio();
		m_dwAudioFrames++;
		m_xmpAudio.dwMaxSize = m_audSize;
		m_audSize = 0;
		OutputPcmData( &m_xmpAudio );
	}
	
	// a second has gone by, lets update our onscreen text
	if ( 1000 < m_dwCurrentTime - m_dwLastFPS )
	{
		// Clear the texture
		D3DLOCKED_RECT d3dlr;
		m_pd3dtText->LockRect(0, &d3dlr, NULL, 0);
		for ( UINT i = 0; i < 240; i++) {
			memset((LPBYTE)d3dlr.pBits + i * d3dlr.Pitch, 0, 320 * 4);
		}
		m_pd3dtText->UnlockRect(0);
		
		LPDIRECT3DSURFACE8	pSurface = NULL;
		hr = m_pd3dtText->GetSurfaceLevel(0, &pSurface);
		if ( SUCCEEDED( hr ) /*&& m_bDrawText*/ )
		{
			WCHAR buffer[MAX_PATH];
			swprintf( buffer, L"Frame: %d", m_dwVideoFrames );
			
			m_BitFont.DrawText( pSurface, m_szWideFileName, 20, 15, 0, D3DCOLOR_XRGB( 255, 255, 255 ), D3DCOLOR_XRGB( 0, 0, 0 ) );
			m_BitFont.DrawText( pSurface, buffer, 20, 25, 0, D3DCOLOR_XRGB( 255, 255, 255 ), D3DCOLOR_XRGB( 0, 0, 0 ) );
		}
		RELEASE( pSurface );
		m_dwLastFPS = m_dwCurrentTime;
	}

	return hr;
}


/*++

Routine Description:

	render the scene to the screen

Arguments:

	None

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT CWmvVerificationTest::Render()
{
	HRESULT hr = S_OK;
			
	// clear the rendering surface
	EXECUTE( m_pD3DDevice->Clear( 0, NULL, D3DCLEAR_STENCIL|D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB( 0, 0, 0 ), 1.0f, 0L ) );

	// begin the scene
	EXECUTE( m_pD3DDevice->BeginScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// draw the geometry with the text on it
	m_pD3DDevice->SetVertexShader(D3DFVF_XYZRHW | D3DFVF_TEX1);
	m_pD3DDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	m_pD3DDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	m_pD3DDevice->SetRenderState(D3DRS_ALPHAREF, 0);
	m_pD3DDevice->SetRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);
	m_pD3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE, TRUE);
	m_pD3DDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_FALSE);
	m_pD3DDevice->SetTexture(0, m_pd3dtText);
	
	m_pD3DDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prText, sizeof(TVERTEX));
	
	// render the scene to the surface
	EXECUTE( m_pD3DDevice->EndScene() );
	if ( FAILED( hr ) )
	{
		return hr;
	}

	// flip the surface to the screen
	EXECUTE( m_pD3DDevice->Present( NULL, NULL, NULL, NULL ) );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	LPCXMEDIAPACKET pVideoPacket

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT 
CWmvVerificationTest::OutputRawData( 
	IN LPCXMEDIAPACKET pVideoPacket
)
{
	HRESULT hr = S_OK;
	BOOL	bSuccess = FALSE;
	DWORD	dwNumBytesWritten = 0;

	CHAR	szRawFrameFile[MAX_PATH];
	sprintf( szRawFrameFile, "%s_%s_%d.xrw", m_szRawPath, /*g_bOverlay ? */"YUY2"/* : "RGB32"*/, m_dwVideoFrames );

	m_hRawFile = CreateFile( szRawFrameFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == m_hRawFile )
	{
		DbgPrint( "Unable to open %s for writing (error %d)\n", m_szRawPath, GetLastError() );
		return E_FAIL;
	}

	bSuccess = WriteFile( m_hRawFile, pVideoPacket->pvBuffer, pVideoPacket->dwMaxSize, &dwNumBytesWritten, NULL );
	if ( FALSE == bSuccess || pVideoPacket->dwMaxSize != dwNumBytesWritten )
	{
		DbgPrint( "Unable to ouput .xrw data correctly\n" );
		hr = E_FAIL;
	}

	SAFECLOSEHANDLE( m_hRawFile );

	return hr;
}


/*++

Routine Description:

	description-of-function

Arguments:

	LPCXMEDIAPACKET pAudioPacket

Return Value:

	S_OK on success
	E_XX on failure

--*/
HRESULT 
CWmvVerificationTest::OutputPcmData( 
	IN LPCXMEDIAPACKET pAudioPacket
)
{
	HRESULT hr = S_OK;
	BOOL	bSuccess = FALSE;
	DWORD	dwNumBytesWritten = 0;

	ASSERT( NULL != m_hPcmFile );
	ASSERT( INVALID_HANDLE_VALUE != m_hPcmFile );

	bSuccess = WriteFile( m_hPcmFile, pAudioPacket->pvBuffer, pAudioPacket->dwMaxSize, &dwNumBytesWritten, NULL );
	if ( FALSE == bSuccess || pAudioPacket->dwMaxSize != dwNumBytesWritten )
	{
		DbgPrint( "Unable to ouput .pcm data correctly\n" );
		hr = E_FAIL;
	}

	return hr;
}

#define SAFEDELETEARRAY( p )                                              \
{                                                                    \
	delete [] p;                                                        \
	p = NULL;                                                        \
}
/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
VOID
CWmvVerificationTest::CompareFrames()
{
	CHAR	szReferenceFrame[MAX_PATH];
	HANDLE	hReferenceFile;

	// not sure about this yet:
	sprintf( szReferenceFrame, "%s_%s_1_%d.raw", m_szRawPath, /*g_bOverlay ? */"YUY2"/* : "RGB32"*/, /*m_dwCurrentFrame*/m_dwVideoFrames );
	hReferenceFile = CreateFile( szReferenceFrame, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == hReferenceFile )
	{
		DbgPrint( "Ubable to open file %s (error %x)\n", szReferenceFrame, GetLastError() );
		return;
	}

	/*if ( g_bOverlay )
	{*/
		typedef struct {
			BYTE y0, u, y1, v;
		} YUY2MACROPIXEL;

		typedef struct {
			DOUBLE y0, u, y1, v;
		} YUY2STDDEV;

		BOOL	bSuccess;
		DWORD	dwBytesRead;
		DWORD	dwSize = m_xmpVideo.dwMaxSize;
		DWORD	dwNumPixels = dwSize / sizeof(YUY2MACROPIXEL);
		//DWORD	dwSize = dwNumPixels*sizeof(YUY2MACROPIXEL);

		YUY2MACROPIXEL*	decPixels;
		YUY2MACROPIXEL*	refPixels;
		YUY2MACROPIXEL	maxDiff = {0};
		YUY2STDDEV		stdDev = {0};

		refPixels = new YUY2MACROPIXEL [dwNumPixels];
		if ( NULL == refPixels )
		{
			SAFECLOSEHANDLE( hReferenceFile );
			return;
		}

		//ZeroMemory( decPixels, dwSize );
		ZeroMemory( refPixels, dwSize );
		decPixels = (YUY2MACROPIXEL*)m_xmpVideo.pvBuffer;

		bSuccess = ReadFile( hReferenceFile, refPixels, dwSize, &dwBytesRead, NULL );
		if ( FALSE == bSuccess || dwSize != dwBytesRead )
		{
			DbgPrint( "Unable to properly read %s. Expected %d bytes, got %d.\n", szReferenceFrame, dwSize, dwBytesRead );
			SAFECLOSEHANDLE( hReferenceFile );
			SAFEDELETEARRAY( refPixels );
			return;
		}

		SAFECLOSEHANDLE( hReferenceFile );

		for ( UINT i=0; i<dwNumPixels; i++ )
		{
			UINT nDiff;
			UINT nTotalDiff = 0;

			// get stats on y0
			nTotalDiff += nDiff = abs( decPixels[i].y0-refPixels[i].y0 );
			stdDev.y0 += pow( nDiff, 2 );
			if ( nDiff > maxDiff.y0 )
			{
				maxDiff.y0 = (BYTE)nDiff;
			}

			// get stats on u
			nTotalDiff += nDiff = abs( decPixels[i].u-refPixels[i].u );
			stdDev.u += pow( nDiff, 2 );
			if ( nDiff > maxDiff.u )
			{
				maxDiff.u = (BYTE)nDiff;
			}

			// get stats on y1
			nTotalDiff += nDiff = abs( decPixels[i].y1-refPixels[i].y1 );
			stdDev.y1 += pow( nDiff, 2 );
			if ( nDiff > maxDiff.y1 )
			{
				maxDiff.y1 = (BYTE)nDiff;
			}

			// get stats on v
			nTotalDiff += nDiff = abs( decPixels[i].v-refPixels[i].v );
			stdDev.v += pow( nDiff, 2 );
			if ( nDiff > maxDiff.v )
			{
				maxDiff.v = (BYTE)nDiff;
			}

			if ( nTotalDiff > m_dwMaxDiffVideo )
			{
				m_dwMaxDiffVideo = nTotalDiff;
				m_dwMaxDiffVideoFrame = m_dwVideoFrames;
			}
		}

		SAFEDELETEARRAY( refPixels );

		stdDev.y0 = sqrt( stdDev.y0 / dwNumPixels );
		stdDev.u  = sqrt( stdDev.u  / dwNumPixels );
		stdDev.y1 = sqrt( stdDev.y1 / dwNumPixels );
		stdDev.v  = sqrt( stdDev.v  / dwNumPixels );

		DOUBLE	fTotalStdDev = stdDev.y0 + stdDev.u + stdDev.y1 + stdDev.v;
		if ( fTotalStdDev > m_fMaxStdDevVideo )
		{
			m_fMaxStdDevVideo = fTotalStdDev;
			m_dwMaxStdDevVideoFrame = m_dwVideoFrames;
		}

		CHAR	szBuf[MAX_PATH];
		sprintf( szBuf, "Frame: %d\tMax Diff:\tStd Dev:\n\ty0:\t\t %d\t\t\t %f\n\tu:\t\t %d\t\t\t %f\n\ty1:\t\t %d\t\t\t %f\n\tv:\t\t %d\t\t\t %f\n\n",
				m_dwVideoFrames,
				maxDiff.y0, stdDev.y0,
				maxDiff.u, stdDev.u,
				maxDiff.y1, stdDev.y1,
				maxDiff.v, stdDev.v );

		DbgPrint( szBuf );

	/*}
	else
	{

	}*/

	return;
}


/*++

Routine Description:

	description-of-function

Arguments:

	None

Return Value:

	None

--*/
VOID
CWmvVerificationTest::CompareAudio()
{
	CHAR	szReferencePcm[MAX_PATH];
	HANDLE	hReferenceFile;

	// not sure about this yet:
	sprintf( szReferencePcm, "%s_%s_0.pcm", m_szRawPath, /*g_bOverlay ? */"YUY2"/* : "RGB32"*/ );
	hReferenceFile = CreateFile( szReferencePcm, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
	if ( INVALID_HANDLE_VALUE == hReferenceFile )
	{
		DbgPrint( "Ubable to open file %s (error %x)\n", szReferencePcm, GetLastError() );
		return;
	}

	if ( 16 == m_dwBitsPerSample )
	{
		SHORT*	decAudio;
		SHORT*	refAudio;

		DOUBLE	stdDev = 0;
		USHORT	maxDiff = 0;

		BOOL	bSuccess;
		DWORD	dwBytesRead;
		DWORD	dwSize = m_xmpAudio.dwMaxSize;
		DWORD	dwNumSamples = dwSize / sizeof(SHORT);

		refAudio = new SHORT [dwNumSamples];
		if ( NULL == refAudio )
		{
			SAFECLOSEHANDLE( hReferenceFile );
			return;
		}

		ZeroMemory( refAudio, dwSize );
		decAudio = (SHORT*)m_xmpAudio.pvBuffer;

		bSuccess = ReadFile( hReferenceFile, refAudio, dwSize, &dwBytesRead, NULL );
		if ( FALSE == bSuccess || dwSize != dwBytesRead )
		{
			DbgPrint( "Unable to properly read %s. Expected %d bytes, got %d.\n", szReferencePcm, dwSize, dwBytesRead );
			SAFECLOSEHANDLE( hReferenceFile );
			SAFEDELETEARRAY( refAudio );
			return;
		}

		SAFECLOSEHANDLE( hReferenceFile );

		for ( UINT i=0; i<dwNumSamples; i++ )
		{
			UINT nDiff;

			// get stats on sample
			nDiff = abs( decAudio[i]-refAudio[i] );
			stdDev += pow( nDiff, 2 );
			if ( nDiff > maxDiff )
			{
				maxDiff = (USHORT)nDiff;
			}
		}

		SAFEDELETEARRAY( refAudio );

		stdDev = sqrt( stdDev / dwNumSamples );
		
		// update global stat tracking variables
		if ( stdDev > m_fMaxStdDevAudio )
		{
			m_fMaxStdDevAudio = stdDev;
			m_dwMaxStdDevAudioFrame = m_dwAudioFrames;
		}
		if ( maxDiff > m_dwMaxDiffAudio )
		{
			m_dwMaxDiffAudio = maxDiff;
			m_dwMaxDiffAudioFrame = m_dwAudioFrames;
		}

		CHAR	szBuf[MAX_PATH];
		sprintf( szBuf, "Audio Frame: %d\tMax Diff: %d\tStd Dev: %f\n\n",
				m_dwAudioFrames, maxDiff, stdDev );

		DbgPrint( szBuf );

		return;
	}
	else
	{

	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xact\engine\devtest\util.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <xactp.h>
#include "devtest.h"
#include <dsstdfx.h>


HRESULT LoadBinaryData(const CHAR *pszName, PVOID *ppvData, PDWORD pdwSize)
{

    DWORD dwBytesRead;

    HANDLE hFile = CreateFile(
        pszName,
        GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {

        DbgPrint("Failed to load %s\n",pszName);
        return E_FAIL;
    }

    *pdwSize = SetFilePointer(hFile,0,0,FILE_END);


    *ppvData = new BYTE[*pdwSize];
    if (*ppvData == NULL) {

        return E_OUTOFMEMORY;

    }

    SetFilePointer(hFile,0,0,FILE_BEGIN);

    BOOL bSuccess = ReadFile(hFile,
        *ppvData,
        *pdwSize,
        &dwBytesRead,
        NULL);

    if (!bSuccess) {

        DbgPrint("Failed to read %s\n",pszName);
        return E_FAIL;

    }

    return S_OK;
}

VOID CreateRandomEvent(PXACT_TRACK_EVENT pEvent)
{

    FLOAT fTemp;    
    
    //
    // normalize rand value
    //
    
    fTemp = (FLOAT)rand()/(FLOAT)RAND_MAX;
    
    //
    // create an arbitrary event
    //
    
    switch (pEvent->Header.wType) {
    case eXACTEvent_Play:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_PLAY);
        break;
    case eXACTEvent_PlayWithPitchAndVolumeVariation:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_PLAY_WITH_PITCH_VOLUME_VAR);
        pEvent->EventData.PlayWithPitchAndVolumeVariation.PlayDesc.WaveSource.wWaveIndex = 1;
        pEvent->EventData.PlayWithPitchAndVolumeVariation.PlayDesc.WaveSource.wBankIndex = 0;
        pEvent->EventData.PlayWithPitchAndVolumeVariation.VarDesc.Pitch.sPitchHi=8;
        pEvent->EventData.PlayWithPitchAndVolumeVariation.VarDesc.Pitch.sPitchLo=-8;
        pEvent->EventData.PlayWithPitchAndVolumeVariation.VarDesc.Volume.sVolHi=0;
        pEvent->EventData.PlayWithPitchAndVolumeVariation.VarDesc.Volume.sVolLo=-2000;
        break;
        
    case eXACTEvent_Stop:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_STOP);
        break;
        
    case eXACTEvent_SetFrequency:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETFREQUENCY);
        fTemp = fTemp * 48000.0f;
        fTemp = max(DSBFREQUENCY_MIN,fTemp);
        pEvent->EventData.SetFrequency.wFrequency = (WORD)fTemp;
        break;
        
    case eXACTEvent_SetVolume:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETVOLUME);            
        fTemp = fTemp*(-2000.0f);
        pEvent->EventData.SetVolume.sVolume = (SHORT)fTemp;
        break;
        
    case eXACTEvent_SetHeadroom:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETHEADROOM);
        fTemp = fTemp*(2);
        pEvent->EventData.SetHeadroom.wHeadroom = (WORD)fTemp;
        break;
        
    case eXACTEvent_SetLFO:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETLFO);
        pEvent->EventData.SetLFO.Desc.dwLFO = DSLFO_PITCH;
        pEvent->EventData.SetLFO.Desc.dwDelay = 10;
        fTemp = fTemp*1000;
        pEvent->EventData.SetLFO.Desc.dwDelta = (DWORD)fTemp;
        pEvent->EventData.SetLFO.Desc.lPitchModulation = 0x1f;
        break;
    case eXACTEvent_SetEG:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETEG);
        pEvent->EventData.SetEG.Desc.dwEG = DSEG_AMPLITUDE;
        pEvent->EventData.SetEG.Desc.dwMode = DSEG_MODE_DELAY;
        pEvent->EventData.SetEG.Desc.dwDelay = 1;
        pEvent->EventData.SetEG.Desc.dwAttack = 100;
        pEvent->EventData.SetEG.Desc.dwHold = 0xa00;
        pEvent->EventData.SetEG.Desc.dwDecay = 100;
        pEvent->EventData.SetEG.Desc.dwSustain = 200;
        pEvent->EventData.SetEG.Desc.dwRelease = 1;
        
        break;
    case eXACTEvent_SetFilter:
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_SETFILTER);
        pEvent->EventData.SetFilter.Desc.dwMode = DSFILTER_MODE_PARAMEQ;
        pEvent->EventData.SetFilter.Desc.dwQCoefficient = DSFILTER_MODE_PARAMEQ;
        
        //
        // set the filter for Fc=701Hz, Gain = 20dB, Q = 1
        //
        
        pEvent->EventData.SetFilter.Desc.adwCoefficients[0] = 0xbe1d;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[1] = 0x8000;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[2] = 0xc8dc;
        pEvent->EventData.SetFilter.Desc.adwCoefficients[3] = 0x1fff;
        
        break;
    case eXACTEvent_LoopStart:    
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_LOOPSTART);
        break;

    case eXACTEvent_LoopEnd:    
        pEvent->Header.wSize = sizeof(XACT_TRACK_EVENT_LOOPEND);
        break;
        
    default:
        break;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xact\engine\devtest\main.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <xactp.h>
#include "devtest.h"
#include <dsstdfx.h>

#define BREAK_ON_START 1

#define NUM_SOUNDBANKS  1
#define NUM_WAVEBANKS 2

#define NUM_CUES 1
#define NUM_VOICES 2

char * g_aszSoundBankFileNames[] = 
{
    "D:\\Media\\soundbank1.bin"
};

// List of wavebanks
char * g_aszWaveBankFileNames[] = 
{
    "D:\\Media\\wavebank.xwb",
    "D:\\Media\\wavebank1.xwb"
};


// List of cues
char * g_aszCueNames[] = 
{
    "CUE0",
    "CUE1"
};

CXactTest::CXactTest()
{
    
    m_pEngine = NULL;
    memset(m_aSoundBanks,0,sizeof(m_aSoundBanks));
    memset(m_aWaveBanks,0,sizeof(m_aWaveBanks));
    memset(m_paSoundSources,0,sizeof(m_paSoundSources));
    
    m_dwNumSoundSources = 0;
    m_dwNumSoundBanks = 0;
    m_dwNumWaveBanks = 0;
    
    m_pvDspImage = NULL;
    m_hThread = NULL;
}

CXactTest::~CXactTest()
{
    
    DWORD i = 0, j = 0;
    
    for (i=0;i<m_dwNumSoundSources;i++)
    {
        PXACTSOUNDSOURCE pSoundSource = m_paSoundSources[i];
        m_paSoundSources[i]->Release();
    }
    
    for (i=0;i<m_dwNumSoundBanks;i++)
    {
        
        PXACTSOUNDBANK pSoundBank = m_aSoundBanks[i].pSoundBank;

        //
        // stop all cues
        //

        pSoundBank->Stop(XACT_SOUNDCUE_INDEX_UNUSED,0,NULL);        
        pSoundBank->Release();
        delete [] m_aSoundBanks[i].pvSoundBankData;
    }
    
    for (i=0;i<m_dwNumWaveBanks;i++)
    {
        if (m_aWaveBanks[i].pWaveBank)
            m_pEngine->UnRegisterWaveBank(m_aWaveBanks[i].pWaveBank);

        delete [] m_aWaveBanks[i].pvWaveBankData;
        
    }

    //
    // tell the thread to exit
    //

    if (m_hThread != INVALID_HANDLE_VALUE) {
        PXACTENGINE pEngine = m_pEngine;
        m_pEngine = NULL;
        
        WaitForSingleObject(m_hThread,INFINITE);    
        pEngine->Release();
    }
    
    delete [] m_pvDspImage;
}


HRESULT CXactTest::Initialize(DWORD dwNumSoundBanks,
                   DWORD dwNumWaveBanks,
                   DWORD dwNumVoices
                   )
{
    HRESULT hr = S_OK;

    DWORD i = 0;
    PVOID pvData;
    DWORD dwSize;

    DirectSoundUseLightHRTF();

    XACT_RUNTIME_PARAMETERS params;

    memset(&params,0,sizeof(params));
    params.dwMax2DHwVoices = 150;
    params.dwMax3DHwVoices = 64;
    params.dwMaxConcurrentStreams = 10;

    //
    // create the engine
    //

    hr = XACTEngineCreate(&m_pEngine,&params);

    //
    // load a DSP Image
    //

    if (SUCCEEDED(hr)) {

        hr = LoadBinaryData("d:\\media\\dsstdfx.bin",&m_pvDspImage,&dwSize);

    }

    if (SUCCEEDED(hr)) {

        DSEFFECTIMAGELOC effectLoc;
        memset(&effectLoc,0,sizeof(effectLoc));

        effectLoc.dwI3DL2ReverbIndex = I3DL2_CHAIN_I3DL2_REVERB;
        effectLoc.dwCrosstalkIndex = I3DL2_CHAIN_XTALK;

        hr = m_pEngine->LoadDspImage(m_pvDspImage,dwSize,&effectLoc);
    }

    if (SUCCEEDED(hr)) {
        
        ASSERT(m_dwNumSoundBanks <= MAX_SOUNDBANKS);
        ASSERT(m_dwNumWaveBanks <= MAX_WAVEBANKS);
        ASSERT(m_dwNumSoundSources <= MAX_SOUNDSOURCES);
        
        m_dwNumSoundBanks = dwNumSoundBanks;
        m_dwNumWaveBanks = dwNumWaveBanks;
        m_dwNumSoundSources = dwNumVoices;
        
    }

    if (SUCCEEDED(hr)) {

        //
        // load soundbank files
        //
        
        for (i=0;i<m_dwNumSoundBanks;i++)
        {
            if (SUCCEEDED(hr)) {
                
                hr = LoadBinaryData(g_aszSoundBankFileNames[i],&pvData,&dwSize);
                
            } else {
                break;
            }
            
            m_aSoundBanks[i].pvSoundBankData = pvData;

            //
            // create a soundbank object
            //
            
            if (SUCCEEDED(hr)) {
                
                hr = m_pEngine->CreateSoundBank(pvData,dwSize,&m_aSoundBanks[i].pSoundBank);
                
            } else {
                break;
            }
            
        }
        
    }

    if (SUCCEEDED(hr)) {
        
        //
        // load wavebank files
        //
        
        for (i=0;i<m_dwNumWaveBanks;i++)
        {
            if (SUCCEEDED(hr)) {
                
                hr = LoadBinaryData(g_aszWaveBankFileNames[i],&pvData,&dwSize);
                
            } else {
                break;
            }
            
            m_aWaveBanks[i].pvWaveBankData = pvData;
            m_aWaveBanks[i].dwSize = dwSize;
            
            //
            // register wavebank
            //
            
            if (SUCCEEDED(hr)) {
                
                hr = m_pEngine->RegisterWaveBank(m_aWaveBanks[i].pvWaveBankData,
                    m_aWaveBanks[i].dwSize,
                    &m_aWaveBanks[i].pWaveBank);
                
            } else {
                break;
            }
            
        }
        
    }

    if (SUCCEEDED(hr)) {

        //
        // create voice objects 
        //

        for (i=0;i<m_dwNumSoundSources;i++)
        {
                                   
            hr = m_pEngine->CreateSoundSource(XACT_FLAG_SOUNDSOURCE_3D,&m_paSoundSources[i]);
            
        }

    }

    if (SUCCEEDED(hr)) {
        //
        // create a thread for calling DoWork
        //
        
        m_hThread = CreateThread(NULL,
            4096,
            XactTestThreadProc,
            this,
            0,
            &m_dwThreadId);
        
        if (m_hThread == INVALID_HANDLE_VALUE) 
        {

            hr = E_FAIL;


        }
            
    }

    return hr;

}

DWORD WINAPI XactTestThreadProc(
    LPVOID pParameter
    )
{
    CXactTest *pThis = (CXactTest *) pParameter;
    pThis->ThreadProc();

    return 0;
}

VOID 
CXactTest::ThreadProc()
{

    while(m_pEngine) {

        //
        // simulate DoWork being called at 60FPS
        //

        Sleep(16);
        XACTEngineDoWork();

    }

}
    
#define NUM_EVENTS  7

HRESULT
CXactTest::RuntimeEvents()
{
    HRESULT hr = S_OK;
    DWORD dwSoundCueIndex = 0;
    DWORD i = 0;
    
    PXACTSOUNDBANK pSoundBank = m_aSoundBanks[0].pSoundBank;
    XACT_TRACK_EVENT aEventDesc[NUM_EVENTS];

    DWORD   aEventTable[NUM_EVENTS] = {        
        eXACTEvent_SetFrequency,
        eXACTEvent_PlayWithPitchAndVolumeVariation,
        eXACTEvent_SetVolume,
        eXACTEvent_SetHeadroom,
        eXACTEvent_SetLFO,
        eXACTEvent_SetEG,
        eXACTEvent_SetFilter
    };


    //
    // play a cue in manual release mode
    //
    
    if (SUCCEEDED(hr)) {
        hr = pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[0],&dwSoundCueIndex);
    }
    
    //
    // play the cue in manual release mode
    //
    
    if (SUCCEEDED(hr)) {
        hr = pSoundBank->Play(dwSoundCueIndex,
            m_paSoundSources[0],
            0,
            &m_aSoundBanks[0].paSoundCues[0]);
    }
    
    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].dwNumSoundCues ++;
    }
    
    //
    // submit random events for N seconds
    //
    
    i = 0;
    DWORD dwIndex = 0;

    do {
        
        memset(&aEventDesc[dwIndex],0,sizeof(XACT_TRACK_EVENT));
        aEventDesc[dwIndex].Header.wType = (WORD)aEventTable[dwIndex];
        
        
        CreateRandomEvent(&aEventDesc[dwIndex]);

        hr = m_pEngine->ScheduleEvent(&aEventDesc[dwIndex],
            m_aSoundBanks[0].paSoundCues[0],
            -1);

        i++;
        dwIndex ++;

        if (dwIndex >= NUM_EVENTS) {
            dwIndex = 0;
        }

        Sleep(500);
        
    } while( (i < 20) && SUCCEEDED(hr));
    
        
    //
    // force stop on all cues with the same index
    //
    
    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->Stop(dwSoundCueIndex,
            XACT_FLAG_SOUNDCUE_SYNCHRONOUS,
            NULL);
        
    }
    
        
    //
    // cue should be freed, NULL context
    //
    
    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].paSoundCues[i] = NULL;
        m_aSoundBanks[0].dwNumSoundCues--;
        
    }

    return hr;
    
}

HRESULT
CXactTest::BasicPlayStop()
{

    HRESULT hr = S_OK;
    DWORD dwSoundCueIndex = 0;
    DWORD i = 0;
    
    //
    // play the cue in manual release mode
    //

    for (i=0;i<NUM_CUES;i++)
    {
        
        if (SUCCEEDED(hr)) {
            hr = m_aSoundBanks[0].pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[i],&dwSoundCueIndex);
        }
        
        //
        // play the cue in manual release mode
        //

        if (SUCCEEDED(hr)) {
            hr = m_aSoundBanks[0].pSoundBank->Play(dwSoundCueIndex,
                m_paSoundSources[i],
                0,
                &m_aSoundBanks[0].paSoundCues[i]);
        }
        
        if (SUCCEEDED(hr)) {
            
            m_aSoundBanks[0].dwNumSoundCues ++;
        }

        //
        // release the wavebanks used by the cue
        //

        if (m_bTestPrematureWavebankUnregister) {

            for (i=0;i<m_dwNumWaveBanks;i++) {

                 if (SUCCEEDED(hr)) 
                     hr = m_pEngine->UnRegisterWaveBank(m_aWaveBanks[i].pWaveBank);

                 m_aWaveBanks[i].pWaveBank = NULL;

            }

        }

        Sleep(16);

        //
        // force stop on all cues with the same index
        //
        
        if (SUCCEEDED(hr)) {
            hr = m_aSoundBanks[0].pSoundBank->Stop(dwSoundCueIndex,
                0,
                NULL);
            
        }

        //
        // cue will be freed, NULL context
        //
        
        if (SUCCEEDED(hr)) {
            
            m_aSoundBanks[0].paSoundCues[i] = NULL;
            m_aSoundBanks[0].dwNumSoundCues--;

        }
        
    }

    if (m_bTestPrematureWavebankUnregister) {

        //
        // re-register the wavebanks
        //

        for (i=0;i<m_dwNumWaveBanks;i++) {
            if (SUCCEEDED(hr)) {
                
                hr = m_pEngine->RegisterWaveBank(m_aWaveBanks[i].pvWaveBankData,
                    m_aWaveBanks[i].dwSize,
                    &m_aWaveBanks[i].pWaveBank);
            }
            
        }

    }

    //
    // play cue in auto-release mode
    //

    if (SUCCEEDED(hr)) {
        
        for (i=0;i<NUM_CUES;i++)
        {
            
            if (SUCCEEDED(hr)) {
                hr = m_aSoundBanks[0].pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[i],&dwSoundCueIndex);
            }
            
            if (SUCCEEDED(hr)) {
                hr = m_aSoundBanks[0].pSoundBank->Play(dwSoundCueIndex,
                    m_paSoundSources[i],
                    XACT_FLAG_SOUNDCUE_AUTORELEASE,
                    NULL);
            }
            
            
        }
        
        //
        // wait for cues to finish on their own
        //

        Sleep(20*1000);
        
    }

    //
    // play cue with no voice specified and AUTORELEASE mode
    //

    if (SUCCEEDED(hr)) {
        
        for (i=0;i<NUM_CUES;i++)
        {
            
            if (SUCCEEDED(hr)) {
                hr = m_aSoundBanks[0].pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[i],&dwSoundCueIndex);
            }
            
            if (SUCCEEDED(hr)) {
                hr = m_aSoundBanks[0].pSoundBank->Play(dwSoundCueIndex,
                    NULL,
                    XACT_FLAG_SOUNDCUE_AUTORELEASE,
                    NULL);
            }
            
            
        }

        Sleep(100);

        //
        // release the wavebanks used by the cue
        //

        if (m_bTestPrematureWavebankUnregister) {

            for (i=0;i<m_dwNumWaveBanks;i++) {

                 if (SUCCEEDED(hr)) 
                     hr = m_pEngine->UnRegisterWaveBank(m_aWaveBanks[i].pWaveBank);

                 m_aWaveBanks[i].pWaveBank = NULL;

            }

        }

        //
        // wait for cues to finish on their own
        //

        Sleep(20000);
        
    }

    return hr;

}

HRESULT
CXactTest::Notifications()
{

    HRESULT hr = S_OK;
    XACT_NOTIFICATION_DESCRIPTION Desc;
    XACT_NOTIFICATION Notification;
    HANDLE hEvent;
    DWORD dwSoundCueIndex;
    DWORD i = 0;

    memset(&Desc,0,sizeof(Desc));

    hEvent = CreateEvent(NULL,
        FALSE,
        FALSE,
        NULL);

    if (hEvent == NULL) {

        hr = E_FAIL;
    }

    //
    // first test sounbank global notifications
    //

    if (SUCCEEDED(hr)) {

        //
        // register for a stop and a start
        Desc.pSoundBank = m_aSoundBanks[0].pSoundBank;
        Desc.dwType = eXACTNotification_Start; 
        Desc.hEvent = hEvent;
        Desc.dwSoundCueIndex = XACT_SOUNDCUE_INDEX_UNUSED;

        hr = m_pEngine->RegisterNotification(&Desc);

        Desc.pSoundBank = m_aSoundBanks[0].pSoundBank;
        Desc.dwType = eXACTNotification_Stop; 
        Desc.hEvent = NULL;
        Desc.dwSoundCueIndex = XACT_SOUNDCUE_INDEX_UNUSED;

        hr = m_pEngine->RegisterNotification(&Desc);

        
    }

    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[0],&dwSoundCueIndex);
    }

    //
    // play the cue in manual release mode
    //
    
    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->Play(dwSoundCueIndex,
            m_paSoundSources[i],
            0,
            &m_aSoundBanks[0].paSoundCues[0]);
    }
    
    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].dwNumSoundCues ++;
    }
    
    if (SUCCEEDED(hr)) {
        Desc.dwType = eXACTNotification_Start; 
        WaitForSingleObject(hEvent,INFINITE);
        hr = m_pEngine->GetNotification(&Desc,&Notification);
    }

    if (SUCCEEDED(hr)) {

        ASSERT(Notification.Header.dwType == Desc.dwType);
    }

    //
    // force stop on all cues with the same index
    //
    
    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->Stop(dwSoundCueIndex,
            0,
            NULL);
        
    }

    //
    // poll until stop notification is present
    //

    if (SUCCEEDED(hr)) {

        Desc.dwType = eXACTNotification_Stop;     
        do {
            hr = m_pEngine->GetNotification(&Desc,&Notification);
        } while (FAILED(hr));

    }

    //
    // cue will be freed, NULL context
    //
    
    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].paSoundCues[i] = NULL;
        m_aSoundBanks[0].dwNumSoundCues--;
        
    }

    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    //
    // now test cue specific notifications
    //
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////

    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->GetSoundCueIndexFromFriendlyName(g_aszCueNames[0],&dwSoundCueIndex);
    }

    if (SUCCEEDED(hr)) {

        memset(&Desc,0,sizeof(Desc));

        //
        // register for a stop and a start on the cue
        //

        Desc.dwSoundCueIndex = dwSoundCueIndex;
        Desc.pSoundBank = m_aSoundBanks[0].pSoundBank;
        Desc.dwType = eXACTNotification_Start; 
        Desc.hEvent = hEvent;
        Desc.dwSoundCueIndex = dwSoundCueIndex;

        hr = m_pEngine->RegisterNotification(&Desc);

        Desc.dwType = eXACTNotification_Stop; 
        Desc.dwSoundCueIndex = dwSoundCueIndex;
        Desc.pSoundBank = m_aSoundBanks[0].pSoundBank;
        Desc.hEvent = NULL;

        hr = m_pEngine->RegisterNotification(&Desc);
        
    }


    //
    // play the cue in manual release mode
    //
    
    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->Play(dwSoundCueIndex,
            m_paSoundSources[0],
            0,
            &m_aSoundBanks[0].paSoundCues[0]);
    }
    
    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].dwNumSoundCues ++;
    }
    
    if (SUCCEEDED(hr)) {

        memset(&Desc,0,sizeof(Desc));
        Desc.dwType = eXACTNotification_Start; 
        Desc.pSoundCue = m_aSoundBanks[0].paSoundCues[0];
        Desc.dwSoundCueIndex = XACT_SOUNDCUE_INDEX_UNUSED;

        WaitForSingleObject(hEvent,INFINITE);
        hr = m_pEngine->GetNotification(&Desc,&Notification);
    }

    if (SUCCEEDED(hr)) {

        ASSERT(Notification.Header.dwType == Desc.dwType);
    }

    //
    // force stop on all cues with the same index
    //
    
    if (SUCCEEDED(hr)) {
        hr = m_aSoundBanks[0].pSoundBank->Stop(dwSoundCueIndex,
            0,
            NULL);
        
    }

    //
    // poll until stop notification is present
    //

    if (SUCCEEDED(hr)) {

        Desc.dwType = eXACTNotification_Stop;     
        Desc.pSoundCue = m_aSoundBanks[0].paSoundCues[0];
        Desc.dwSoundCueIndex = XACT_SOUNDCUE_INDEX_UNUSED;

        do {
            hr = m_pEngine->GetNotification(&Desc,&Notification);
        } while (FAILED(hr));

    }

    if (SUCCEEDED(hr)) {
        
        m_aSoundBanks[0].paSoundCues[i] = NULL;
        m_aSoundBanks[0].dwNumSoundCues--;
        
    }

    return hr;
}


VOID __cdecl main()
{
    HRESULT hr = S_OK;
    CXactTest XactTest;

    XactTest.m_bTestNotifications = 0;
    XactTest.m_bTestBasicPlayStop = 1;
    XactTest.m_bTestRuntimeEvents = 0;
    XactTest.m_bTestPrematureWavebankUnregister = 0;
    
#ifdef BREAK_ON_START
    _asm int 3;
#endif

    hr = XactTest.Initialize(NUM_SOUNDBANKS,
        NUM_WAVEBANKS,
        NUM_VOICES);

    if (SUCCEEDED(hr) && XactTest.m_bTestRuntimeEvents){
        hr = XactTest.RuntimeEvents();
    }

    if (SUCCEEDED(hr) && XactTest.m_bTestBasicPlayStop ){
        hr = XactTest.BasicPlayStop();
    }

    if (SUCCEEDED(hr) && XactTest.m_bTestNotifications){
        hr = XactTest.Notifications();
    }

    if (SUCCEEDED(hr)) {

        DbgPrint("Test succeeded");

    }

    XactTest.LinkAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xmo\bvt\xmobvt.cpp ===
#include <xtl.h>
#include <dsutil.h>
#include <srcxmo.h>

VOID WINAPI XMOBVTStartTest( HANDLE LogHandle )
{
	HRESULT hr = S_OK;
	SETLOG( LogHandle, "danrose", "XMO", "BVT", "StartTest" );

	EXECUTE( PlayOneFile( BVT_FILE, PLAY_MODE_STREAM ) );
}

VOID WINAPI XMOBVTEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xmoBVT )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xmoBVT )
    EXPORT_TABLE_ENTRY( "StartTest", XMOBVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMOBVTEndTest )
END_EXPORT_TABLE( xmoBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\linkstat\main.cpp ===
#include <xtl.h>
#include "UserInterface.h"
#include "UserInterfaceScreen.h"
#include "UserInterfaceText.h"

class CLinkScreen : public CUserInterfaceScreen {

public:

    // Constructor / Destructor
    CLinkScreen(void);
    ~CLinkScreen(void);

    // Overloaded user input
    virtual CUserInterfaceScreen* Update(CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio);

private:

    // Update UI text
    void UpdateText(void);

    // UI text
    CUserInterfaceText m_DisconnectedText;
    CUserInterfaceText m_ConnectedText;

    CUserInterfaceText m_Speed100MbpsText;
    CUserInterfaceText m_Speed10MbpsText;
    CUserInterfaceText m_SpeedUnknownText;

    CUserInterfaceText m_ModeFullDuplexText;
    CUserInterfaceText m_ModeHalfDuplexText;
    CUserInterfaceText m_ModeUnknownText;

    // Link status
    DWORD  m_dwLinkStatus;
};



CLinkScreen::CLinkScreen(void)

    // Link screen
    : CUserInterfaceScreen(NULL, 0xFFFFFFFF, 0x00000000, 320, 60),

    // UI text
    m_DisconnectedText("Disconnected", 320, 180, 0xFFFF0000, 0xFF000000),
    m_ConnectedText("Connected", 320, 180, 0xFF00FF00, 0xFF000000),

    m_Speed100MbpsText("Speed: 100 Mbps", 320, 240, 0xFFFFFF00, 0xFF000000),
    m_Speed10MbpsText("Speed: 10 Mbps", 320, 240, 0xFFFFFF00, 0xFF000000),
    m_SpeedUnknownText("Speed: Unknown", 320, 240, 0xFFFF0000, 0xFF000000),

    m_ModeFullDuplexText("Mode: Full Duplex", 320, 270, 0xFFFFFF00, 0xFF000000),
    m_ModeHalfDuplexText("Mode: Half Duplex", 320, 270, 0xFFFFFF00, 0xFF000000),
    m_ModeUnknownText("Mode: Unknown", 320, 270, 0xFFFF0000, 0xFF000000)

{
    // Set the link screen text
    SetText("Ethernet Link Status");

    // Add the UI text
    AddUIText(&m_DisconnectedText);
    AddUIText(&m_ConnectedText);

    AddUIText(&m_Speed100MbpsText);
    AddUIText(&m_Speed10MbpsText);
    AddUIText(&m_SpeedUnknownText);

    AddUIText(&m_ModeFullDuplexText);
    AddUIText(&m_ModeHalfDuplexText);
    AddUIText(&m_ModeUnknownText);

    UpdateText();
}



CLinkScreen::~CLinkScreen(void)
{
}

void
CLinkScreen::UpdateText(void)
{
    m_dwLinkStatus = XNetGetEthernetLinkStatus();

    if (XNET_ETHERNET_LINK_ACTIVE & m_dwLinkStatus) {
        m_ConnectedText.Hide(FALSE);
        m_DisconnectedText.Hide(TRUE);

        if (XNET_ETHERNET_LINK_100MBPS & m_dwLinkStatus) {
            m_Speed100MbpsText.Hide(FALSE);
            m_Speed10MbpsText.Hide(TRUE);
            m_SpeedUnknownText.Hide(TRUE);
        }
        else if (XNET_ETHERNET_LINK_10MBPS & m_dwLinkStatus) {
            m_Speed10MbpsText.Hide(FALSE);
            m_Speed100MbpsText.Hide(TRUE);
            m_SpeedUnknownText.Hide(TRUE);
        }
        else {
            m_SpeedUnknownText.Hide(FALSE);
            m_Speed100MbpsText.Hide(TRUE);
            m_Speed10MbpsText.Hide(TRUE);
        }

        if (XNET_ETHERNET_LINK_FULL_DUPLEX & m_dwLinkStatus) {
            m_ModeFullDuplexText.Hide(FALSE);
            m_ModeHalfDuplexText.Hide(TRUE);
            m_ModeUnknownText.Hide(TRUE);
        }
        else if (XNET_ETHERNET_LINK_HALF_DUPLEX & m_dwLinkStatus) {
            m_ModeHalfDuplexText.Hide(FALSE);
            m_ModeFullDuplexText.Hide(TRUE);
            m_ModeUnknownText.Hide(TRUE);
        }
        else {
            m_ModeUnknownText.Hide(FALSE);
            m_ModeFullDuplexText.Hide(TRUE);
            m_ModeHalfDuplexText.Hide(TRUE);
        }
    }
    else {
        m_DisconnectedText.Hide(FALSE);
        m_ConnectedText.Hide(TRUE);

        m_Speed100MbpsText.Hide(TRUE);
        m_Speed10MbpsText.Hide(TRUE);
        m_SpeedUnknownText.Hide(TRUE);

        m_ModeFullDuplexText.Hide(TRUE);
        m_ModeHalfDuplexText.Hide(TRUE);
        m_ModeUnknownText.Hide(TRUE);
    }
}



CUserInterfaceScreen* 
CLinkScreen::Update(CUserInterfaceInput* pInput, CUserInterfaceAudio* pAudio)
{
    UpdateText();

    return NULL;
}



void __cdecl main(void)
{
    // hResult is the result of the user interface update
    HRESULT  hResult = S_OK;



    // Construct the link screen
    CLinkScreen linkScreen;

    // Setup the user interface
    hResult = CUserInterface::Instance()->Initialize(&linkScreen, 640, 480, 0, NULL);

    while (SUCCEEDED(hResult)) {
        hResult = CUserInterface::Instance()->Update();
    }

    XLaunchNewImage(NULL, NULL);

    __asm int 3;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xmo\regression\xmoreg.cpp ===
#include <dsutil.h>
#include <netXmo.h>
#include <echo.h>

#include <xnetref.h>

static const ULONG PACKET_COUNT       = 1;
static const ULONG PACKET_SIZE        = 1;
static const DWORD INVALID_PORT       = 0xFFFFFFFF;
static const WORD  SAMPLES_PER_BLOCK  = 1024;
static const ULONG TEST_PORT          = 600;
static const LPCSTR TEST_ADDRESS      = "157.56.11.66";

#define IMAADPCM_BITS_PER_SAMPLE            4
#define IMAADPCM_HEADER_LENGTH              4

struct PacketContext {
	XMEDIAPACKET axmp[2];
	DWORD adwCompletedSize[2];
	DWORD adwStatus[2];
	HANDLE ahEvent[2];

	XMEDIAINFO xmi;
};

enum XMO { 
//	XMO_FILE_READ = 0,
//	XMO_FILE_WRITE,
//	XMO_FILE_READ_WRITE,
	XMO_WAVE_FILE = 0,
	XMO_WMA_FILE,
//	XMO_ECHO_FILTER,
//	XMO_HAWK_HEAD,
//	XMO_HAWK_MIC,
//	XMO_VOX_ENC,
//	XMO_VOX_DEC,
//	XMO_NET,
//	XMO_MIXER_SRC,
//	XMO_MIXER_DEST,
//	XMO_WMA_MEMORY,
	XMO_AC97_ANALOG,
	XMO_AC97_DIGITAL,
	XMO_DSOUND
};

DWORD WmaCallback( LPVOID pvContext, DWORD dwOffset, DWORD dwByteCount, LPVOID *ppvData )
{
	return dwByteCount;
}

HRESULT OpenNet( void )
{
	HRESULT hr = S_OK;
	WSADATA wsadata;

	CHECK( XNetAddRef() );
	CHECK( WSAStartup( WINSOCK_VERSION, &wsadata ) );

	return hr;
}

HRESULT CloseNet( void )
{
	HRESULT hr = S_OK;

	CHECK( WSACleanup() );
	CHECK( XNetRelease() );

	return hr;
}

HRESULT InitWaveFormat( LPWAVEFORMATEX* ppFormat )
{
	if ( NULL == ppFormat )
		return E_INVALIDARG;

	LPWAVEFORMATEX pFormat = new WAVEFORMATEX;
	
	if ( NULL == pFormat )
		return E_OUTOFMEMORY;

	ZeroMemory( pFormat, sizeof( WAVEFORMATEX ) );

    pFormat->wFormatTag          = WAVE_FORMAT_PCM;
    pFormat->nSamplesPerSec      = 16000;
    pFormat->nChannels           = 1;
    pFormat->wBitsPerSample      = (WORD) 16;
    pFormat->nBlockAlign         = pFormat->wBitsPerSample * pFormat->nChannels / 8;
    pFormat->nAvgBytesPerSec     = pFormat->nSamplesPerSec * pFormat->nBlockAlign;
    pFormat->cbSize              = 0;

	*ppFormat = pFormat;

	return S_OK;
}

WORD CalculateEncodeAlignment
(
    WORD                    nChannels,
    WORD                    nSamplesPerBlock
)
{
    const WORD              nEncodedSampleBits  = nChannels * IMAADPCM_BITS_PER_SAMPLE;
    const WORD              nHeaderBytes        = nChannels * IMAADPCM_HEADER_LENGTH;
    WORD                    nBlockAlign;

    //
    // Calculate the raw block alignment that nSamplesPerBlock dictates.  This
    // value may include a partial encoded sample, so be sure to round up.
    //
    // Start with the samples-per-block, minus 1.  The first sample is actually
    // stored in the header.
    //

    nBlockAlign = nSamplesPerBlock - 1;

    //
    // Convert to encoded sample size
    //

    nBlockAlign *= nEncodedSampleBits;
    nBlockAlign += 7;
    nBlockAlign /= 8;

    //
    // The stereo encoder requires that there be at least two DWORDs to process
    //

    nBlockAlign += 7;
    nBlockAlign /= 8;
    nBlockAlign *= 8;

    //
    // Add the header
    //

    nBlockAlign += nHeaderBytes;

    return nBlockAlign;
}

HRESULT InitAdpcmWaveFormat
(
	LPXBOXADPCMWAVEFORMAT*   ppwfx
)

{
	if ( NULL == ppwfx )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	LPXBOXADPCMWAVEFORMAT pwfx = new XBOXADPCMWAVEFORMAT;
	CHECKALLOC( pwfx );

	if ( SUCCEEDED( hr ) )
	{

		pwfx->wfx.wFormatTag = WAVE_FORMAT_XBOX_ADPCM;
		pwfx->wfx.nChannels = 1;
		pwfx->wfx.nSamplesPerSec = 16000;
		pwfx->wfx.nBlockAlign = CalculateEncodeAlignment(pwfx->wfx.nChannels, SAMPLES_PER_BLOCK );
		pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec * pwfx->wfx.nBlockAlign / SAMPLES_PER_BLOCK;
		pwfx->wfx.wBitsPerSample = IMAADPCM_BITS_PER_SAMPLE;
		pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
		pwfx->wSamplesPerBlock = SAMPLES_PER_BLOCK;

		*ppwfx = pwfx;
	}

	return hr;
}
/*
HRESULT InitVolume( LPDSMXVOLUME* ppVol )
{
	if ( NULL == ppVol )
		return E_INVALIDARG;

	LPDSMXVOLUME pVol = new DSMXVOLUME;

	if ( NULL == pVol )
		return E_OUTOFMEMORY;

	ZeroMemory( pVol, sizeof( DSMXVOLUME ) );

	pVol->wLeft = 0x8000;
	pVol->wRight = 0x8000;

	*ppVol = pVol;

	return S_OK;
}
*/
HRESULT InitStream( LPDSSTREAMDESC* ppDesc, LPCWAVEFORMATEX pFormat )
{
	if ( NULL == ppDesc || NULL == pFormat )
		return E_INVALIDARG;

	LPDSSTREAMDESC pDesc = new DSSTREAMDESC;

	if ( NULL == pDesc )
		return E_OUTOFMEMORY;

	ZeroMemory( pDesc, sizeof( DSSTREAMDESC ) );

    pDesc->dwFlags = 0;
    pDesc->dwMaxAttachedPackets = PACKET_COUNT;
    pDesc->lpwfxFormat = (LPWAVEFORMATEX) pFormat;

	*ppDesc = pDesc;

	return S_OK;
}

DWORD GetHawkPort( void )
{
	DWORD dwCount = 0;
	DWORD dwInsertions = 0;
    DWORD dwSlot = 0;
    DWORD dwPort = INVALID_PORT;

    while ( dwCount++ < 2 ) {

        dwInsertions = XGetDevices( XDEVICE_TYPE_VOICE_MICROPHONE );

        if( dwInsertions )
        {
            for( DWORD i = 0; i < 32; i++ )
            {
                if( dwInsertions & ( 1 << i ) )
                {
                    if( i < 16 )
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }

                    dwCount = 2;
                    break;
                }   
            }
        }

        Sleep( 1000 );
    }

	return dwPort;
}

HRESULT InitPacketContext( PacketContext* pContext, bool bEmpty )
{
	if ( NULL == pContext )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	ZeroMemory( pContext, sizeof( PacketContext ) );

	ZeroMemory( pContext->axmp, sizeof( XMEDIAPACKET ) * 2 );
	ZeroMemory( pContext->adwCompletedSize, sizeof( DWORD ) * 2 );
	ZeroMemory( pContext->adwStatus, sizeof( DWORD ) * 2 );
	ZeroMemory( pContext->ahEvent, sizeof( HANDLE ) * 2 );
	ZeroMemory( &pContext->xmi, sizeof( XMEDIAINFO ) );

	for ( DWORD i = 0; i < 2 && SUCCEEDED( hr ) && false == bEmpty; i++ )
	{
		pContext->ahEvent[i] = CreateEvent( NULL, FALSE, FALSE, NULL );
		CHECKALLOC( pContext->ahEvent[i] );

		if ( SUCCEEDED( hr ) )
		{
			pContext->axmp[i].pdwStatus = &pContext->adwStatus[i];
			pContext->axmp[i].pdwCompletedSize = &pContext->adwCompletedSize[i];
			pContext->axmp[i].hCompletionEvent = pContext->ahEvent[i];
		}
	}

	return hr;
}

void DestroyPacketContext( PacketContext* pContext )
{
	for ( DWORD i = 0; i < 2; i++ )
	{
		if ( pContext->axmp[i].pvBuffer )
//#ifndef DVTSNOOPBUG
//			delete [] pContext->axmp[i].pvBuffer;
//#else // DVTSNOOPBUG
			XPhysicalFree( pContext->axmp[i].pvBuffer );
//#endif // DVTSNOOPBUG

		CloseHandle( pContext->ahEvent[i] );
	}
}

HRESULT GetStatus( XMediaObject* pXMO )
{
	HRESULT hr = S_OK;
	DWORD dwStatus = 0;
	char szTemp[512];

	CHECKEXECUTE( pXMO->GetStatus( &dwStatus ) );

	if ( SUCCEEDED( hr ) )
	{
		DbgPrint( "GetStatus:\n" );
		sprintf( szTemp, "  dwStatus: " );

		if ( 0 == dwStatus )
		{
			strcat( szTemp, "0x0" );
		}

		for ( DWORD dwMask = 0x00000001; 0 != dwMask; dwMask <<= 1 )
		{
			switch ( dwMask & dwStatus )
			{
				case XMO_STATUSF_ACCEPT_INPUT_DATA:
					strcat( szTemp, "XMO_STATUSF_ACCEPT_INPUT_DATA | " );
					break;

				case XMO_STATUSF_ACCEPT_OUTPUT_DATA:
					strcat( szTemp, "XMO_STATUSF_ACCEPT_OUTPUT_DATA | " );
					break;
			}
		}

		DbgPrint( "%s\n\n", szTemp );
	}

	return hr;
}

HRESULT InitBuffers( PacketContext* pContext )
{
	HRESULT hr = S_OK;

	for ( DWORD i = 0; i < 2 && SUCCEEDED( hr ); i++ )
	{
		pContext->axmp[i].dwMaxSize = 0 == i ? pContext->xmi.dwInputSize : pContext->xmi.dwOutputSize;

		if ( ( 0 == i && 0 == pContext->xmi.dwInputSize ) || ( 1 == i && 0 == pContext->xmi.dwOutputSize ) )
		{
			pContext->axmp[i].pvBuffer = NULL;
		}
		else
		{
//#ifndef DVTSNOOPBUG
//			pContext->axmp[i].pvBuffer = new BYTE[ 0 == i ? pContext->xmi.dwInputSize : pContext->xmi.dwOutputSize ];
//#else
			pContext->axmp[i].pvBuffer = XPhysicalAlloc( 0 == i ? pContext->xmi.dwInputSize : pContext->xmi.dwOutputSize, MAXULONG_PTR, 0, PAGE_READWRITE | PAGE_NOCACHE );
//#endif
			CHECKALLOC( pContext->axmp[i].pvBuffer );

			ZeroMemory( pContext->axmp[i].pvBuffer, 0 == i ? pContext->xmi.dwInputSize : pContext->xmi.dwOutputSize );
		}
	}

	return hr;
}

HRESULT GetInfo( XMediaObject* pXMO, PacketContext* pContext )
{
	HRESULT hr = S_OK;
	char szTemp[512];

	CHECKEXECUTE( pXMO->GetInfo( &pContext->xmi ) );

	if ( SUCCEEDED( hr ) )
	{
		DbgPrint( "GetInfo:\n" );
		DbgPrint( "  xmi: InputSize: %u OutputSize: %u MaxLookAhead: %u\n", pContext->xmi.dwInputSize, pContext->xmi.dwOutputSize, pContext->xmi.dwMaxLookahead ); 
		sprintf( szTemp, "       Flags: " );

		if ( 0 == pContext->xmi.dwFlags )
		{
			strcat( szTemp, "0x0" );
		}

		for ( DWORD dwMask = 0x000000001; 0 != dwMask; dwMask <<= 1 )
		{
			switch ( pContext->xmi.dwFlags & dwMask )
			{
				case XMO_STREAMF_FIXED_SAMPLE_SIZE:
					strcat( szTemp, "XMO_STREAMF_FIXED_SAMPLE_SIZE | " );
					break;

				case XMO_STREAMF_FIXED_PACKET_ALIGNMENT:
					strcat( szTemp, "XMO_STREAMF_FIXED_PACKET_ALIGNMENT | " );
					break;

				case XMO_STREAMF_INPUT_ASYNC:
					strcat( szTemp, "XMO_STREAMF_INPUT_ASYNC | " );
					break;

				case XMO_STREAMF_OUTPUT_ASYNC:
					strcat( szTemp, "XMO_STREAMF_OUTPUT_ASYNC | " );
					break;

				case XMO_STREAMF_IN_PLACE:
					strcat( szTemp, "XMO_STREAMF_IN_PLACE | " );
					break;
			}
		}
		
		DbgPrint( "%s\n\n", szTemp );
	}

	CHECKEXECUTE( InitBuffers( pContext ) );

	return hr;
}

HRESULT Process( XMediaObject* pXMO, PacketContext* pContext )
{
	HRESULT hr = S_OK;
	char szTemp[512];
	char szSize[64];

	CHECKEXECUTE( pXMO->Process( NULL == pContext->axmp[0].pvBuffer ? NULL : &pContext->axmp[0], NULL == pContext->axmp[1].pvBuffer ? NULL : &pContext->axmp[1] ) );
	
	if ( SUCCEEDED( hr ) )
	{
		DbgPrint( "Process:\n" );

		for ( DWORD i = 0; i < 2; i++ )
		{
			sprintf( szTemp, "  packet[%u]: pBuffer: 0x%x MaxSize: %u ", i, pContext->axmp[i].pvBuffer, pContext->axmp[i].dwMaxSize );
			
			if ( NULL != pContext->axmp[i].pdwCompletedSize )
			{
				sprintf( szSize, "Completed: %u ", *pContext->axmp[i].pdwCompletedSize );
				strcat( szTemp, szSize );
			}

			if ( NULL != pContext->axmp[i].pdwStatus )
			{
				strcat( szTemp, "Status: " );
				switch ( *pContext->axmp[i].pdwStatus )
				{
					case XMEDIAPACKET_STATUS_SUCCESS:
						strcat( szTemp, "XMEDIAPACKET_STATUS_SUCCESS" );
						break;

					case XMEDIAPACKET_STATUS_PENDING:
						strcat( szTemp, "XMEDIAPACKET_STATUS_PENDING" );
						break;

					case XMEDIAPACKET_STATUS_FLUSHED:
						strcat( szTemp, "XMEDIAPACKET_STATUS_FLUSHED" );
						break;

					case XMEDIAPACKET_STATUS_FAILURE:
						strcat( szTemp, "XMEDIAPACKET_STATUS_FAILURE" );
						break;
				}
			}

			DbgPrint( "%s\n", szTemp );
			
		}

		DbgPrint( "\n" );
	}

	return hr;
}

HRESULT Callback( PacketContext* pContext )
{
	HRESULT hr = S_OK;

	DWORD i = 0;
	DWORD dwNumToWait = 2;
	
	do {

		i = WaitForMultipleObjects( 2, pContext->ahEvent, FALSE, 10000 );

		if ( WAIT_OBJECT_0 == i )
		{
			DbgPrint( "Recieved callback on input\n" );
		}
		else if ( WAIT_TIMEOUT != i )
		{
			DbgPrint( "Recieved callback on output\n" );
		}
		else
		{
			DbgPrint( "Wait timed out on callback\n" );
		}

		if ( NULL == pContext->axmp[0].pvBuffer || NULL == pContext->axmp[1].pvBuffer )
		{
			dwNumToWait = 0;
		}
		else
		{
			dwNumToWait--;
		}

	} while ( 0 != dwNumToWait );

	DbgPrint( "\n" );

	return hr;
}

HRESULT CreateXMO( XMO xmo, XMediaObject** ppXMO )
{
	HRESULT hr = S_OK;
	LPCWAVEFORMATEX pWfxRaw = NULL;
	LPXBOXADPCMWAVEFORMAT pWfxAdpcm = NULL;
	LPWAVEFORMATEX pWfx = NULL;
//	LPDSMXVOLUME pVol = NULL;
	LPDSSTREAMDESC pdsDesc = NULL;

	DWORD dwOffset = 0;

	char* szName = NULL;

	switch ( xmo )
	{
/*		case XMO_FILE_READ:
			CHECKEXECUTE( XFileCreateMediaObject( "t:\\media\\audio\\pcm\\2000.wav", GENERIC_READ, FILE_SHARE_READ, OPEN_ALWAYS, 0, (XFileMediaObject**) ppXMO ) );
			szName = "XFileCreateMediaObject - Read";
			break;

		case XMO_FILE_WRITE:
			CHECKEXECUTE( XFileCreateMediaObject( "t:\\media\\audio\\pcm\\dumb.wav", GENERIC_WRITE, FILE_SHARE_WRITE, CREATE_ALWAYS, 0, (XFileMediaObject**) ppXMO ) );
			szName = "XFileCreateMediaObject - Write";
			break;

		case XMO_FILE_READ_WRITE:
			CHECKEXECUTE( XFileCreateMediaObject( "t:\\media\\audio\\pcm\\dumb.wav", GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, CREATE_ALWAYS, 0, (XFileMediaObject**) ppXMO ) );
			szName = "XFileCreateMediaObject - Read + Write";
			break;
*/
		case XMO_WAVE_FILE:
			CHECKEXECUTE( XWaveFileCreateMediaObject( "t:\\media\\audio\\pcm\\2111.wav", &pWfxRaw, (XFileMediaObject**) ppXMO ) );
			szName = "XWaveFileCreateMediaObject";
			break;

		case XMO_WMA_FILE:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( WmaCreateDecoder( "t:\\media\\audio\\wma\\test.wma", NULL, FALSE, (4096*16), 16, 0, pWfx, (XFileMediaObject**) ppXMO ) );
			szName = "WmaCreateDecoder";
			break;

/*		case XMO_ECHO_FILTER:
			CHECKEXECUTE( XCreateEchoFxMediaObject( PACKET_SIZE, 16 >> 3, ppXMO ) );
			szName = "XCreateEchoFxMediaObject";
			break;
*/
/*		case XMO_HAWK_HEAD:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_HEADPHONE, GetHawkPort(), PACKET_COUNT, pWfx, ppXMO ) );
			szName = "XVoiceCreateMediaObject - Head";
			break;

		case XMO_HAWK_MIC:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_MICROPHONE, GetHawkPort(), PACKET_COUNT, pWfx, ppXMO ) );
			szName = "XVoiceCreateMediaObject - Mic";
			break;
*/
//		case XMO_VOX_ENC:
//		case XMO_VOX_DEC:
//			break;

/*		case XMO_NET:
			CHECKEXECUTE( XnetCreateMediaObject( ppXMO, INVALID_SOCKET, TEST_ADDRESS, TEST_PORT, PACKET_SIZE, 0 ) );
			szName = "XNetCreateMediaObject";
			break;
*/
/*
		case XMO_MIXER_SRC:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( InitVolume( &pVol ) );
			CHECKEXECUTE( DirectSoundCreateMixerSource( pWfx, pWfx, pVol, (IDirectSoundMixerSource**) ppXMO ) );
			szName = "DirectSoundCreateMixerSource";
			break;


		case XMO_MIXER_DEST:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( DirectSoundCreateMixerDestination( pWfx, (IDirectSoundMixerDestination**) ppXMO ) );
			szName = "DirectSoundCreateMixerDestination";
			break;
*/
/*		case XMO_WMA_MEMORY:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( WmaCreateInMemoryDecoder( WmaCallback, NULL, pWfx, ppXMO ) );
			szName = "WmaCreateInMemoryDecoder";
			break;
*/

		case XMO_AC97_ANALOG:
			CHECKEXECUTE( Ac97CreateMediaObject( DSAC97_CHANNEL_ANALOG, NULL, NULL, (LPAC97MEDIAOBJECT *) ppXMO ) );
			szName = "Ac97CreateMediaObject - ANALOG";
			break;

		case XMO_AC97_DIGITAL:
			CHECKEXECUTE( Ac97CreateMediaObject( DSAC97_CHANNEL_DIGITAL, NULL, NULL, (LPAC97MEDIAOBJECT *) ppXMO ) );
			szName = "Ac97CreateMediaObject - DIGITAL";
			break;

		case XMO_DSOUND:
			CHECKEXECUTE( InitWaveFormat( &pWfx ) );
			CHECKEXECUTE( InitStream( &pdsDesc, pWfx ) );
			CHECKEXECUTE( DirectSoundCreateStream( pdsDesc, (LPDIRECTSOUNDSTREAM*) ppXMO ) );
			szName = "DirectSoundCreateStream";
			break;
	}

	CHECKALLOC( *ppXMO );

	if ( SUCCEEDED( hr ) )
	{
		DbgPrint( "\n" );
		DbgPrint( "%s:\n", szName );
		
		if ( NULL != pWfxRaw )
		{
			DbgPrint( "  WaveFormat: FormatTag: %u Channels: %u SamplesPerSec: %u AvgBytesPerSec: %u BlockAlign: %u BitsPerSample: %u Size %u\n", pWfxRaw->wFormatTag, pWfxRaw->nChannels, pWfxRaw->nSamplesPerSec, pWfxRaw->nAvgBytesPerSec, pWfxRaw->nBlockAlign, pWfxRaw->wBitsPerSample, pWfxRaw->cbSize );
		}

		if ( NULL != pWfx )
		{
			DbgPrint( "  WaveFormat: FormatTag: %u Channels: %u SamplesPerSec: %u AvgBytesPerSec: %u BlockAlign: %u BitsPerSample: %u Size %u\n", pWfx->wFormatTag, pWfx->nChannels, pWfx->nSamplesPerSec, pWfx->nAvgBytesPerSec, pWfx->nBlockAlign, pWfx->wBitsPerSample, pWfx->cbSize );
		}

		if ( NULL != pWfxAdpcm )
		{
			DbgPrint( "  ADPCMWaveFormat: FormatTag: %u Channels: %u SamplesPerSec: %u AvgBytesPerSec: %u BlockAlign: %u BitsPerSample: %u Size %u SamplesPerBlock: 0x%x\n", pWfxAdpcm->wfx.wFormatTag, pWfxAdpcm->wfx.nChannels, pWfxAdpcm->wfx.nSamplesPerSec, pWfxAdpcm->wfx.nAvgBytesPerSec, pWfxAdpcm->wfx.nBlockAlign, pWfxAdpcm->wfx.wBitsPerSample, pWfxAdpcm->wfx.cbSize, pWfxAdpcm->wSamplesPerBlock );
		}

/*		if ( NULL != pVol )
		{
			DbgPrint( "  Volume: Left: 0x%x Right 0x%x\n", pVol->wLeft, pVol->wRight );
		}
*/
		if ( NULL != pdsDesc )
		{
			DbgPrint( "  DSDESC: Flags: 0x%x\n", pdsDesc->dwFlags );
		}

		DbgPrint( "\n" );
	}

	delete pWfx;
	delete pWfxAdpcm;
//	delete pVol;
	delete pdsDesc;

	return hr;
}

HRESULT GetCompletedValue( PacketContext* pContext )
{
	if ( NULL == pContext )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	DbgPrint( "GetCompletedValue:\n" );
	DbgPrint( "  Completed Value[0]: %u\n", pContext->adwCompletedSize[0] );
	DbgPrint( "  Completed Value[1]: %u\n", pContext->adwCompletedSize[1] );
	DbgPrint( "  Status[0]: 0x%x\n", pContext->adwStatus[0] );
	DbgPrint( "  Status[1]: 0x%x\n", pContext->adwStatus[1] );
	DbgPrint( "\n" );

	return hr;
}

HRESULT TestXMO( XMO xmo )
{
	HRESULT hr = S_OK;

	PacketContext context;
	XMediaObject* pXMO = NULL;

	ZeroMemory( &context, sizeof( PacketContext ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "CreateXMO" );
	CHECKEXECUTE( CreateXMO( xmo, &pXMO ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "InitPacketContext" );
	CHECKEXECUTE( InitPacketContext( &context, false ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetStatus" );
	CHECKEXECUTE( GetStatus( pXMO ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetInfo" );
	CHECKEXECUTE( GetInfo( pXMO, &context ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "Process" );
	CHECKEXECUTE( Process( pXMO, &context ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetStatus" );
	CHECKEXECUTE( GetStatus( pXMO ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "Callback" );
	CHECKEXECUTE( Callback( &context ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetCompletedValue" );
	CHECKEXECUTE( GetCompletedValue( &context ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetStatus" );
	CHECKEXECUTE( GetStatus( pXMO ) );

	DestroyPacketContext( &context );
	RELEASE( pXMO );

	return hr;
}

HRESULT TestXMOEmptyPacket( XMO xmo )
{
	HRESULT hr = S_OK;

	PacketContext context;
	XMediaObject* pXMO = NULL;

	ZeroMemory( &context, sizeof( PacketContext ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "CreateXMO" );
	CHECKEXECUTE( CreateXMO( xmo, &pXMO ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "InitPacketContext" );
	CHECKEXECUTE( InitPacketContext( &context, true ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "GetInfo" );
	CHECKEXECUTE( GetInfo( pXMO, &context ) );

	SETLOG( g_hLog, "danrose", "XMO", "Regression", "Process" );
	CHECKEXECUTE( Process( pXMO, &context ) );

	DestroyPacketContext( &context );
	RELEASE( pXMO );

	return hr;
}

VOID WINAPI XMORegStartTest( HANDLE LogHandle )
{
	SETLOG( LogHandle, "danrose", "XMO", "Regression", "StartTest" );

	HRESULT hr = S_OK;

//	XMO Regression currently does nothing with the network.
//	However, it may need to in the future.
//	At such time, OpenNet and CloseNet should be uncommented.
//	CHECK( OpenNet() );

	for ( DWORD xmo = XMO_WAVE_FILE; xmo <= XMO_DSOUND; xmo++ )
//	for ( DWORD xmo = XMO_WMA_FILE; xmo <= XMO_WMA_FILE; xmo++ )
	{
		EXECUTE( TestXMO( (XMO) xmo ) );
		EXECUTE( TestXMOEmptyPacket( (XMO) xmo ) );
	}

//	XMO Regression currently does nothing with the network.
//	However, it may need to in the future.
//	At such time, OpenNet and CloseNet should be uncommented.
//	CHECK( CloseNet() );
}

VOID WINAPI XMORegEndTest( VOID )
{
}

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xmoReg )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xmoReg )
    EXPORT_TABLE_ENTRY( "StartTest", XMORegStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMORegEndTest )
END_EXPORT_TABLE( xmoReg )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\lib\precomp.h ===
#include "xnetp.h"
#include "icmp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\inc\commandstructs.h ===
/*
 * File : CommandStructs.h
 * Author : Sandeep Prabhu
 * Revision History
 *      28/4/2000       sandeep           Created
 *
 * Structures used by the stubs in AutoSrv and Controller to send and receive data
 */

#ifndef __COMMANDSTRUCTS__H
#define __COMMANDSTRUCTS__H

#include <windows.h>
#include "common.h"
 
#define ANY_SIZE 1

#pragma pack(1)
/*
 *  New data types
 */                              
typedef struct
{
    BYTE bAddr[MAX_IPADDR_LEN];
    int iLength;
} IPADDR, *PIPADDR;

typedef struct
{
    BYTE bAddr[MAX_MACADDR_LEN];
    int iLength;
} MACADDR, *PMACADDR;  
                 
/*
 * Valid command codes supported by AutoSrv
 */               
typedef enum {
    CC_Cleanup,
    CC_Reboot,
    CC_Ping,
    CC_GetArpCache,
    CC_FlushArpCache,
    CC_DeleteArpCacheEntry,
    CC_AddArpCacheEntry,
    CC_CheckArpCacheEntry,
    CC_GetRouteTable,
    CC_DeleteRouteTableEntry,
    CC_AddRouteTableEntry,
    CC_GetNumInterfaces,
    CC_GetInterfaceIndex,
    CC_DeleteIP,
    CC_AddIP,
    CC_SendArp,
    CC_CreateRegistryKey, 
    CC_DeleteRegistryKey,
    CC_SetRegistryKeyValue,
    CC_GetRegistryKeyValue,
    CC_Socket,
    CC_BindEx,
    CC_Bind,
    CC_SetSocketOption,
    CC_ConnectEx,
    CC_AsyncConnectEx,
    CC_AcceptEx,
    CC_AsyncAcceptEx,
    CC_Connect,
    CC_Accept,
    CC_Send,
    CC_AsyncSend,
    CC_Receive,
    CC_AsyncReceive,
    CC_GetSessionStats,
    CC_GetAsyncStatus,
    CC_GetAsyncCompletionStatus,
    CC_Stop,
    CC_Close,
    CC_Reset,
    CC_Shutdown,
    CC_AsyncClose,
    CC_AsyncReset,
    CC_AsyncShutdown,
    CC_Unknown
} tCommandCode;

/*
 *  Response structure
 */
#define RESPONSE_HEADER_LENGTH (sizeof(tCommandCode)+3*sizeof(DWORD))

typedef struct _tGenericResponse {         
    tCommandCode CommandCode;
    DWORD dwTID;         
    DWORD dwStatus;
    DWORD dwDataSize;
    BYTE  abData[ANY_SIZE];
 } tGenericResponse;


/* 
 * Generic portion command to all requests sent out by Controller
 */
typedef struct {
    tCommandCode CommandCode;
    DWORD dwTID;
} tGenericStruct;


/*
 * Structures for specific commands
 */

typedef struct {
    tGenericStruct GenericPart;
} tArgs_Cleanup, tArgs_Reboot, tArgs_Ping, tArgs_GetArpCache, tArgs_GetRouteTable, tArgs_GetNumInterfaces;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
} tArgs_FlushArpCache;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    MACADDR MacAddress;
    DWORD dwType;
} tArgs_DeleteArpCacheEntry, tArgs_AddArpCacheEntry;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    MACADDR MacAddress;
} tArgs_CheckArpCacheEntry;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR TargetIP;
    IPADDR GWIP;
    IPADDR Mask;
    DWORD dwMetric;
    DWORD dwType;
} tArgs_DeleteRouteTableEntry, tArgs_AddRouteTableEntry;


typedef struct
{
    tGenericStruct GenericPart;
    TCHAR pszFriendlyName[MAX_INTERFACE_NAME_LENGTH];
} tArgs_GetInterfaceIndex;

typedef struct
{
    tGenericStruct GenericPart;
    ULONG ulNTEContext;
} tArgs_DeleteIP;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    IPADDR Mask;
} tArgs_AddIP;

typedef struct
{
    tGenericStruct GenericPart;
    IPADDR DestIP;
    IPADDR SrcIP;
} tArgs_SendArp;


typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    DWORD dwOptions;
    REGSAM Sam;
} tArgs_CreateRegistryKey;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
} tArgs_DeleteRegistryKey;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
    DWORD dwType;
    BYTE abData[MAX_REG_VALUE_LENGTH];
    DWORD dwDataLen;
} tArgs_SetRegistryKeyValue;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
} tArgs_GetRegistryKeyValue;

/*
 * Session command structs
 */
typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;    
} tGenericSessionStruct, tArgs_GetSessionStats, tArgs_Close, tArgs_Reset, tArgs_Shutdown;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
} tArgs_Socket;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    IPADDR SrcIP;
    USHORT usSrcPort;
} tArgs_BindEx;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
} tArgs_Bind;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iOption;
    CHAR achValue[MAX_OPTION_SIZE];
    INT iSize;
} tArgs_SetSocketOption;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    IPADDR DestIP;
    USHORT usDestPort;
} tArgs_ConnectEx;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
    IPADDR DestIP;
    USHORT usDestPort;
} tArgs_Connect;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
    INT iListenQ;
} tArgs_Accept;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iListenQ;
} tArgs_AcceptEx;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwIterations;
    DWORD dwDelay;
    INT iBufferSize;
    BOOL fBufferSpecified;
    CHAR achBuffer[ANY_SIZE];
} tArgs_Send;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwIterations;
    DWORD dwDelay;
    INT iBufferSize;
} tArgs_Receive;


typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwAsyncTID;
} tArgs_GetAsyncStatus, tArgs_GetAsyncCompletionStatus, tArgs_Stop;

/*
 * Command specific responses
 */
typedef struct {
    DWORD dwBytesSent;
    DWORD dwBytesRcvd;
} tResponse_GetSessionStats;


typedef struct 
{
    DWORD dwType;
    DWORD dwDataLen;
    BYTE abValue[ANY_SIZE];
} tResponse_GetRegistryKeyValue;
#pragma pack()
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\sendping.h ===
WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpDefault,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize
    );

WINBASEAPI
DWORD
WINAPI
GetProfileStringW(
    IN LPCWSTR lpAppName,
    IN LPCWSTR lpKeyName,
    IN LPCWSTR lpDefault,
    OUT LPWSTR lpReturnedString,
    IN DWORD nSize
    );

#ifdef UNICODE
#define GetProfileString  GetProfileStringW
#else
#define GetProfileString  GetProfileStringA
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\sendping.c ===
/*
 * File             :       SendPing.cpp
 * Author           :       Jim Y
 * Revision History
 *      Aug/02/2000   JimY        Created
 *
 * This file contains code for sending a Ping
 */


#include "precomp.h"

#include <xbttcp.h>
#include <xtl.h>
#include <stdlib.h>
#include <xlog.h>
#include <xtestlib.h>

LPVOID lpHeapMemory = NULL;
HANDLE SendPingHeapHandle;

volatile BOOL quitFlag = FALSE;

#define RCVTIMEOUT  3
#define PINGBUFSIZE 2048
#define BuffLen 200
#define UNICAST 0
#define MULTICAST 1
#define IPADDRESSLENGTH 16
#define PASS 0
#define FAIL 1


//
// Functions local to this module
//
INT  OldPing(HANDLE, INT, CHAR *);
VOID SendIcmpMessage(SOCKET, struct sockaddr_in*, IcmpMessage*, INT);
BOOL RecvIcmpMessage(SOCKET, struct sockaddr_in*);
INT  Ping(HANDLE, INT, CHAR *);
INT  PingLoopback(HANDLE);
INT  PingUnicast(HANDLE, CHAR *);
INT  PingMulticast(HANDLE, CHAR *);

CHAR TESTADDR[IPADDRESSLENGTH];
CHAR UCASTTESTADDR[IPADDRESSLENGTH];


INT err, result, AddressType = 0;
CHAR databuf[PINGBUFSIZE];
INT rcvlen;
WORD id, seqno;

char szBuffer[BuffLen];
char iniBuffer[BuffLen];


#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())


__inline _bind(SOCKET s, struct sockaddr_in* addr) {
    return bind(s, (struct sockaddr*) addr, sizeof(*addr));
}

__inline INT _sendto(SOCKET s, CHAR* buf, DWORD buflen, struct sockaddr_in* to) {
    WSABUF wsabuf = { buflen, buf };
    return WSASendTo(s, &wsabuf, 1, &buflen, 0, (struct sockaddr*) to, sizeof(*to), 0, 0);
}

__inline INT _recvfrom(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* from) {
    WSABUF wsabuf = { *buflen, buf };
    INT fromlen = sizeof(*from);
    DWORD flags = 0;
    return WSARecvFrom(s, &wsabuf, 1, buflen, &flags, (struct sockaddr*) from, &fromlen, 0, 0);
}



/*
 * Main thread for SendPing
 *
 *
 */
void DoSendPing(HANDLE hLog) {

    int x = 0;
    int length = 0;
    WSADATA wsadata;


    OutputDebugString(L"SendPing: Loading XBox network stack...\n");
    err = XnetInitialize(NULL, TRUE);
    if (!NT_SUCCESS(err)) {
        OutputDebugString(L"SendPing: XNetInitialize failed...\n");
        WARNFAIL(XnetInitialize); goto stop;
    }


    Sleep(2000);
    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    if (err != NO_ERROR) {
        OutputDebugString(L"SendPing: WSAStartup failed...\n");
        WARNFAIL(WSAStartup); goto unload;
    }

    id = (WORD) (GetTickCount() >> 16);
    seqno = (WORD) (GetTickCount() & 0xffff);


    //
    // Test 1: Ping Loopback of 127.0.0.1
    //
    DbgPrint("SendPing: *****************\n");
    DbgPrint("SendPing: * Test 1        *\n");
    DbgPrint("SendPing: *****************\n");
    result = PingLoopback(hLog);
    if (result != PASS)
        xLog(hLog, XLL_FAIL, "The ping failed.");
    else
        xLog(hLog, XLL_PASS, "The Ping succeeded.");

    xEndVariation( hLog );



    //
    // Test 2: Unicast ping
    //

    DbgPrint("SendPing: *****************\n");
    DbgPrint("SendPing: * Test 2        *\n");
    DbgPrint("SendPing: *****************\n");

    ZeroMem(&iniBuffer,BuffLen);
    ZeroMem(&TESTADDR,IPADDRESSLENGTH);
    GetProfileStringA("sendping", "IpToPing", "127.0.0.1", iniBuffer, IPADDRESSLENGTH);
    IniRemoveStringCommentA( iniBuffer );
    xSetComponent(hLog, "Network", "ICMP");
    xSetFunctionName( hLog, "PING");
    xStartVariation( hLog, "Ping a valid address");

    DbgPrint("SendPing:  iniBuffer = [%s]\n", iniBuffer);
    strcpy(TESTADDR, iniBuffer);
    DbgPrint("SendPing:  TESTADDR = [%s]\n", TESTADDR);
//    DbgPrint("SendPing:  Run Ping Test, press 'g' to continue...\n");
//    BREAK_INTO_DEBUGGER

//
//  New code !
//
    result = PingUnicast(hLog, iniBuffer);
//    result = Ping(hLog, AddressType, TESTADDR);
    if (result != PASS)
        xLog(hLog, XLL_FAIL, "The ping failed.");
    else
        xLog(hLog, XLL_PASS, "The Ping succeeded.");

    xEndVariation( hLog );



    //
    // Test 3: multicast ping
    //

    DbgPrint("SendPing: *****************\n");
    DbgPrint("SendPing: * Test 3        *\n");
    DbgPrint("SendPing: *****************\n");

    ZeroMem(&iniBuffer,BuffLen);
    ZeroMem(&TESTADDR, IPADDRESSLENGTH);
    GetProfileStringA("sendping", "MCastIpToPing", "229.0.0.1", iniBuffer, IPADDRESSLENGTH);
    IniRemoveStringCommentA( iniBuffer );
    AddressType = MULTICAST;
    xSetComponent(hLog, "Network", "ICMP");
    xSetFunctionName( hLog, "PING");
    xStartVariation( hLog, "Ping a valid address");

    DbgPrint("SendPing:  iniBuffer = [%s]\n", iniBuffer);
    strcpy(TESTADDR, iniBuffer);
    xStartVariation( hLog, "Ping a valid Multicast address");
    DbgPrint("SendPing:  TESTADDR = [%s]\n", TESTADDR);
//    DbgPrint("SendPing:  Run McastPing Test, press 'g' to continue...\n");
//    BREAK_INTO_DEBUGGER


//
//  More New code !
//
    result = PingMulticast(hLog, iniBuffer);
//    result = Ping(hLog, AddressType, TESTADDR);
    if (result != PASS)
        xLog(hLog, XLL_FAIL, "The ping failed.");
    else
        xLog(hLog, XLL_PASS, "The Ping succeeded.");

    xEndVariation( hLog );



    WSACleanup();

unload:
    DbgPrint("SendPing: Unloading XBox network stack...\n");
    XnetCleanup();

stop:
    DbgPrint("SendPing: Test stopped, type .reboot now\n");
//    BREAK_INTO_DEBUGGER



}



// XBox entry point

BOOL WINAPI SendPingDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        SendPingHeapHandle = HeapCreate(0, 0, 0);

        if(!SendPingHeapHandle)
            {
            DbgPrint("SendPing: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(SendPingHeapHandle)
            {
            HeapDestroy(SendPingHeapHandle);
            }
        }

    return TRUE;
    }






/*
Xbox:
Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    bool stressmode - true for infinate loop

Return Value:

    DWORD

*/
DWORD RunAll(HANDLE hLog, BOOL stressmode /*=false*/)
    {

    DbgPrint("SendPing: Start of RunAll\n");

    do {

        } while(stressmode);

    DbgPrint("SendPing: End of RunAll\n");
    return 0;
    }





/*
XBox:
Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI SendPingStartTest(HANDLE hLog)
    {

    DoSendPing(hLog);
    RunAll(hLog, FALSE);
    DbgPrint("SendPing: Leaving StartTest()\n");

    }




/*
Xbox:
Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI SendPingEndTest(void)
    {
    }

INT
PingLoopback(HANDLE hLog)
{
    IcmpMessage *myIcmpMessage;
    CHAR databuf[PINGBUFSIZE];
    CHAR ResponseIP[IPADDRESSLENGTH];
    UINT myOffset = 0;
    INT result = FAIL;
    INT iphdrlen, iplen;
    CHAR *mypingmessage;
    CHAR ActualIP[IPADDRESSLENGTH];
    CHAR ExpectedIP[IPADDRESSLENGTH];


    // Clear memory
    ZeroMem(&ActualIP, IPADDRESSLENGTH);
    ZeroMem(&ExpectedIP, IPADDRESSLENGTH);
    ZeroMem(&iniBuffer,BuffLen);
    ZeroMem(&TESTADDR,IPADDRESSLENGTH);

    // Read data from .INI file
    GetProfileStringA("sendping", "bogusaddressxyzzy", "127.0.0.1", iniBuffer, IPADDRESSLENGTH);
    IniRemoveStringCommentA( iniBuffer );

    // Log some info
    xSetComponent(hLog, "Network", "ICMP");
    xSetFunctionName( hLog, "PING");
    xStartVariation( hLog, "Ping Loopback of 127.0.0.1");
    DbgPrint("SendPing.PingLoopback iniBuffer = [%s]\n", iniBuffer);
    strcpy(TESTADDR, iniBuffer);
    DbgPrint("SendPing.PingLoopback TESTADDR = [%s]\n", TESTADDR);
//    DbgPrint("SendPing.PingLoopback Run Ping Test, press 'g' to continue...\n");
//    BREAK_INTO_DEBUGGER

    // Send the ping packet
    mypingmessage = HeapAlloc(SendPingHeapHandle, 0, strlen("myping-a-roonie")+1);
    strcpy(mypingmessage, "myping-a-roonie");
    result = xbtUCastPing(TESTADDR, &myOffset, databuf, PINGBUFSIZE, ResponseIP, mypingmessage, strlen(mypingmessage)+1 );


    // Examine data returned from the ping
    myIcmpMessage = (IcmpMessage*) &databuf[myOffset];
    if (myIcmpMessage != NULL)  {
       DbgPrint("SendPing.PingLoopback  ResponseIP      = %s\n", ResponseIP);
       DbgPrint("SendPing.PingLoopback  myOffset        = %d\n", myOffset);
       DbgPrint("SendPing.PingLoopback  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
       DbgPrint("SendPing.PingLoopback  id = %d,  seqno = %d \n", myIcmpMessage->id, myIcmpMessage->seqno);
       iplen = GETIPLEN( (IpHeader*) databuf );
       iphdrlen = GETIPHDRLEN( (IpHeader*) databuf );
       rcvlen = iplen - iphdrlen;
       DbgPrint("SendPing.PingLoopback  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, myIcmpMessage->origdata);

       //  Compare for PASS vs FAIL
       strcpy(ExpectedIP, "127.0.0.1");
       DbgPrint("SendPing.PingLoopback  ResponseIP = [%s] ExpectedIP = [%s]\n", ResponseIP, ExpectedIP );
       DbgPrint("SendPing.PingLoopback  strcmp: = %d\n", strcmp(ResponseIP, ExpectedIP));
       if (!strcmp(ResponseIP, ExpectedIP))  {
           xLog(hLog, XLL_INFO, "ResponseIP matches ExpectedIP");
           DbgPrint("SendPing.PingLoopback: ResponseIP matches ExpectedIP\n");

           if (myIcmpMessage->type = ICMPTYPE_ECHO_REPLY)  {
               result = PASS;
           }
           else  {
               xLog(hLog, XLL_INFO, "MessageType is not what was expected");
               DbgPrint("SendPing.PingLoopback  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
           }
       }
       else {
           xLog(hLog, XLL_INFO, "ResponseIP does NOT match ExpectedIP");
           DbgPrint("SendPing.PingLoopback: ResponseIP does NOT match ExpectedIP\n");
       }

    }

    return result;
}



INT
PingUnicast(HANDLE hLog, CHAR *ExpectedIP)
{
    IcmpMessage *myIcmpMessage;
    CHAR databuf[PINGBUFSIZE];
    CHAR ResponseIP[IPADDRESSLENGTH];
    UINT myOffset = 0;
    INT result = FAIL;
    INT iphdrlen, iplen;
    CHAR *mypingmessage;
    CHAR ActualIP[IPADDRESSLENGTH];


    // Clear memory
    ZeroMem(&ActualIP, IPADDRESSLENGTH);


    // Log some info
    DbgPrint("SendPing.PingUnicast ExpectedIP = [%s]\n", ExpectedIP);
    strcpy(TESTADDR, ExpectedIP);
    DbgPrint("SendPing.PingUnicast TESTADDR = [%s]\n", TESTADDR);
//    DbgPrint("SendPing.PingUnicast Run Ping Test, press 'g' to continue...\n");
//    BREAK_INTO_DEBUGGER

    // Send the ping packet
    mypingmessage = HeapAlloc(SendPingHeapHandle, 0, strlen("myping-a-roonie")+1);
    strcpy(mypingmessage, "myping-a-roonie");
    result = xbtUCastPing(TESTADDR, &myOffset, databuf, PINGBUFSIZE, ResponseIP, mypingmessage, strlen(mypingmessage)+1 );


    // Examine data returned from the ping
    myIcmpMessage = (IcmpMessage*) &databuf[myOffset];
    if (myIcmpMessage != NULL)  {
       DbgPrint("SendPing.PingUnicast  ResponseIP      = %s\n", ResponseIP);
       DbgPrint("SendPing.PingUnicast  myOffset        = %d\n", myOffset);
       DbgPrint("SendPing.PingUnicast  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
       DbgPrint("SendPing.PingUnicast  id = %d,  seqno = %d \n", myIcmpMessage->id, myIcmpMessage->seqno);
       iplen = GETIPLEN( (IpHeader*) databuf );
       iphdrlen = GETIPHDRLEN( (IpHeader*) databuf );
       rcvlen = iplen - iphdrlen;
       DbgPrint("SendPing.PingUnicast  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, myIcmpMessage->origdata);

       //  Compare for PASS vs FAIL
       strcpy(ExpectedIP, iniBuffer);
       DbgPrint("SendPing.PingUnicast  ResponseIP = [%s] ExpectedIP = [%s]\n", ResponseIP, ExpectedIP );
       DbgPrint("SendPing.PingUnicast  strcmp: = %d\n", strcmp(ResponseIP, ExpectedIP));
       if (!strcmp(ResponseIP, ExpectedIP))  {
           xLog(hLog, XLL_INFO, "ResponseIP matches ExpectedIP");
           DbgPrint("SendPing.PingUnicast: ResponseIP matches ExpectedIP\n");

           if (myIcmpMessage->type = ICMPTYPE_ECHO_REPLY)  {
               result = PASS;
           }
           else  {
               xLog(hLog, XLL_INFO, "MessageType is not what was expected");
               DbgPrint("SendPing.PingUnicast  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
           }
       }
       else {
           xLog(hLog, XLL_INFO, "ResponseIP does NOT match ExpectedIP");
           DbgPrint("SendPing.PingUnicast: ResponseIP does NOT match ExpectedIP\n");
       }

    }

    return result;
}


INT
PingMulticast(HANDLE hLog, CHAR *ExpectedIP)
{
    IcmpMessage *myIcmpMessage;
    CHAR databuf[PINGBUFSIZE];
    CHAR ResponseIP[IPADDRESSLENGTH];
    UINT myOffset = 0;
    INT result = FAIL;
    INT iphdrlen, iplen;
    CHAR *mypingmessage;
    CHAR ActualIP[IPADDRESSLENGTH];


    // Clear memory
    ZeroMem(&ActualIP, IPADDRESSLENGTH);


    // Log some info
    DbgPrint("SendPing.PingMulticast ExpectedIP = [%s]\n", ExpectedIP);
    strcpy(TESTADDR, ExpectedIP);
    DbgPrint("SendPing.PingMulticast TESTADDR = [%s]\n", TESTADDR);
//    DbgPrint("SendPing.PingMulticast Run Ping Test, press 'g' to continue...\n");
//    BREAK_INTO_DEBUGGER

    // Send the ping packet
    mypingmessage = HeapAlloc(SendPingHeapHandle, 0, strlen("myping-a-roonie")+1);
    strcpy(mypingmessage, "myping-a-roonie");
    result = xbtMCastPing(TESTADDR, &myOffset, databuf, PINGBUFSIZE, ResponseIP, mypingmessage, strlen(mypingmessage)+1 );


    // Examine data returned from the ping
    myIcmpMessage = (IcmpMessage*) &databuf[myOffset];
    if (myIcmpMessage != NULL)  {
       DbgPrint("SendPing.PingMulticast  ResponseIP      = %s\n", ResponseIP);
       DbgPrint("SendPing.PingMulticast  myOffset        = %d\n", myOffset);
       DbgPrint("SendPing.PingMulticast  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
       DbgPrint("SendPing.PingMulticast  id = %d,  seqno = %d \n", myIcmpMessage->id, myIcmpMessage->seqno);
       iplen = GETIPLEN( (IpHeader*) databuf );
       iphdrlen = GETIPHDRLEN( (IpHeader*) databuf );
       rcvlen = iplen - iphdrlen;
       DbgPrint("  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, myIcmpMessage->origdata);

       //  Compare for PASS vs FAIL
       strcpy(ExpectedIP, iniBuffer);
       DbgPrint("SendPing.PingMulticast ResponseIP = [%s] ExpectedIP = [%s]\n", ResponseIP, ExpectedIP );
       DbgPrint("SendPing.PingMulticast strcmp: = %d\n", strcmp(ResponseIP, ExpectedIP));
       if (!strcmp(ResponseIP, ExpectedIP))  {
           xLog(hLog, XLL_INFO, "ResponseIP matches ExpectedIP");
           DbgPrint("SendPing.PingMulticast: ResponseIP matches ExpectedIP\n");

           if (myIcmpMessage->type = ICMPTYPE_ECHO_REPLY)  {
               result = PASS;
           }
           else  {
               xLog(hLog, XLL_INFO, "MessageType is not what was expected");
               DbgPrint("SendPing.PingMulticast  type = %d, code = %d\n", myIcmpMessage->type, myIcmpMessage->code);
           }
       }
       else {
           xLog(hLog, XLL_INFO, "ResponseIP does NOT match ExpectedIP");
           DbgPrint("SendPing.PingMulticast: ResponseIP does NOT match ExpectedIP\n");
       }

    }

    return result;
}






//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( sendping )
#pragma data_seg()

BEGIN_EXPORT_TABLE( sendping )
    EXPORT_TABLE_ENTRY( "StartTest", SendPingStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", SendPingEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", SendPingDllMain )
END_EXPORT_TABLE( sendping )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\inc\common.h ===
/*
 * File : Controller.cpp
 * Author : Sandeep Prabhu
 * Revision History
 *      28/4/2000       sandeep           Created
 *
 * Contains stuff shared between AutoSrv and Controller
 */
 
#ifndef __COMMON__H
#define __COMMON__H

 
/*********************************************************************************
 * Constants
 *********************************************************************************/ 
//
// Max size of a request/response packet
//
#define MAX_PACKET_LENGTH           65535
//
// Maximum length (in bytes) of IP address
//
#define MAX_IPADDR_LEN              12
//
// Maximum length (in bytes) of MAC addres
//
#define MAX_MACADDR_LEN             6
//
// Maximum lenght of friendly name for an interface
//
#define MAX_INTERFACE_NAME_LENGTH   256
//
// Maximum size of an option set on a socket
//
#define MAX_OPTION_SIZE             4
//
// Maximum size of the subkey
//
#define MAX_REG_SUBKEY_LENGTH       256
//
// Maximum size of value name
//
#define MAX_REG_VALUENAME_LENGTH    256
//
// Maximum size of value
//
#define MAX_REG_VALUE_LENGTH        256
//
// The port on which AutoSrv is listening
//
#define AUTOSRV_PORT                9000

  

                                                                                  
/*********************************************************************************
 * Error codes
 *********************************************************************************/ 
//
// Malloc failure
//
#define ERROR_MALLOC                ERROR_OUTOFMEMORY       
//
// An invalid (TID/Command code don't match with request) response is received from AutoSrv
//
#define ERROR_INVALID_RESPONSE      ERROR_INVALID_MESSAGE
//
// An invalid argument was passed to a command
//                                     
#define ERROR_INVALID_ARGUMENT      ERROR_INVALID_PARAMETER
//
// No error code has been specified
//
#define NO_ERROR_CODE               4
//
// Invalid command code
//
#define ERROR_INVALID_COMMAND       ERROR_BAD_COMMAND
//
// Session has been terminated
//
#define ERROR_SESSION_CLOSED        6

/**********************************************************************************
 * Debug levels and macros
 **********************************************************************************/

#ifndef DEBUGMSG1
 
#define DEBUGMSG1(level, format, arg) (printf(format, arg))

#endif

// JP - added temporarily, change as needed
#ifndef DEBUGMSG

#define DEBUGMSG(level, format) (printf(format))

#endif

//
// Debug levels
//
//#define DBG_AUTOSRV             1
//#define DBG_LIST                1
#define DBG_CONTROLLER_VERBOSE  3
#define DBG_VERBOSE             3
#define DBG_ERROR               2
#define DBG_WARNING             1


//
// Service specific stuff
//
#define DBG_SERVICE_ERROR        1         // Will report the errors in service
#define DBG_SERVICE_VERBOSE      2         // Will report the service info
#define SERVICE_NAME             "AutoSrv" // Name of the service
      
#define MAX_DEBUG_STRING_LENGTH  255       // Max length of a string to be dumped on debugger

      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\multimedia\xmo\xmotest\xmotest.cpp ===
#include <xtl.h>
#include <xdbg.h>
#include <macros.h>
#include <waveldr.h>
#include <srcxmo.h>
#include <netxmo.h>

static const DWORD XMO_NULL           = 0x00000000;
static const DWORD XMO_HAWK_MIC       = 0x00000001;
static const DWORD XMO_NET_RECV       = 0x00000002;
static const DWORD XMO_WAVE_FILE      = 0x00000004;
static const DWORD XMO_SRC_16_8       = 0x00000008;
static const DWORD XMO_VOX_ENC        = 0x00000010;
static const DWORD XMO_VOX_DEC        = 0x00000020;
static const DWORD XMO_ADPCM_ENC      = 0x00000040;
static const DWORD XMO_ADPCM_DEC      = 0x00000080;
static const DWORD XMO_SRC_8_16       = 0x00000100;
static const DWORD XMO_HAWK_HEAD      = 0x00000200;
static const DWORD XMO_NET_SEND       = 0x00000400;
static const DWORD XMO_MCPX           = 0x00000800;

static const DWORD FREE_SRC           = 0x00000000;
static const DWORD FREE_DEST          = 0x00000001;
static const DWORD PENDING_SRC        = 0x00000002;
static const DWORD PENDING_DEST       = 0x00000004;

static const WORD SAMPLES_PER_BLOCK   = 0x0800;
static const ULONG PACKET_COUNT       = 3;
static const ULONG PACKET_SIZE        = 1024;
static const ULONG NUM_QUEUES         = 2;
static const ULONG NUM_EVENTS         = NUM_QUEUES * PACKET_COUNT;
static const ULONG TEST_PORT          = 600;
static const DWORD INVALID_PORT       = 0xFFFFFFFF;
static const LPCWSTR FILE_NAME        = L"t:\\media\\audio\\pcm\\1306.wav";
static const LPCSTR TEST_ADDR_LEFT    = "157.56.10.245";
static const LPCSTR TEST_ADDR_RIGHT   = "157.56.11.66";

static LPSTR XMO_NAME_NET_SEND = "XMO_NET_SEND";
static LPSTR XMO_NAME_NET_RECV = "XMO_NET_RECV";
static LPSTR XMO_NAME_HAWK_MIC = "XMO_HAWK_MIC";
static LPSTR XMO_NAME_HAWK_HEAD = "XMO_HAWK_HEAD";

struct List {
	XMediaObject* pXMO;
	char* szName;
	List* pNext;
};

static HANDLE g_hEvent = NULL;

struct ProcessContext {
	List* pXMOList;
	List* pLastXMO;

//	DWORD dwNumDest[PACKET_COUNT];
//	DWORD dwNumQueued;
//	DWORD dwStartQueue;
	DWORD dwBytesPerQueue;
	DWORD dwPacketSize;

	DWORD pdwStatus[NUM_EVENTS];
	DWORD pdwContextStatus[NUM_EVENTS];
	DWORD pdwCompletedSize[NUM_EVENTS];

//	DWORD dwInStatus;
//	DWORD dwOutStatus;
//	DWORD dwInCompletedSize;
//	DWORD dwOutCompletedSize;

	LPBYTE pQueueBuffer;

	HANDLE hEvent;

//	HANDLE pPacketEvents[NUM_EVENTS];
	XMEDIAPACKET pPackets[NUM_EVENTS];
};

union ENCODEDFORMATEX {

	WAVEFORMATEX wfx;
	IMAADPCMWAVEFORMAT wfxAdpcm;
	VOICECODECWAVEFORMAT wfxVox;
};

HRESULT OpenNet( void )
{
	HRESULT hr = S_OK;
	WSADATA wsadata;

	CHECKEXECUTE( XnetInitialize( NULL, TRUE ) );
	CHECKEXECUTE( WSAStartup( WINSOCK_VERSION, &wsadata ) );

	return hr;
}

bool IsLeftMachine( void )
{
	char* szAddress = NULL;

    struct in_addr address;
	XnetGetIpAddress( &address );

	szAddress = inet_ntoa( address );

	return 0 == strcmp( TEST_ADDR_LEFT, szAddress );
}


HRESULT CloseNet( void )
{
	HRESULT hr = S_OK;

	CHECKEXECUTE( WSACleanup() );
	CHECKEXECUTE( XnetCleanup() );

	return hr;
}

void DeleteList( List* pList )
{
	List* pTemp = NULL;

	for ( ; NULL != pList; pList = pList->pNext )
	{
		if ( NULL != pTemp )
			delete pTemp;

		RELEASE( pList->pXMO );
		pTemp = pList;
	}

	delete pTemp;
}

DWORD GetHawkPort( void )
{
	DWORD dwCount = 0;
	DWORD dwInsertions = 0;
    DWORD dwSlot = 0;
    DWORD dwPort = INVALID_PORT;

    while ( dwCount++ < 2 ) {

        dwInsertions = XGetDevices( XDEVICE_TYPE_VOICE_MICROPHONE );

        if( dwInsertions )
        {
            for( DWORD i = 0; i < 32; i++ )
            {
                if( dwInsertions & ( 1 << i ) )
                {
                    if( i < 16 )
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }

                    dwCount = 2;
                    break;
                }   
            }
        }

        Sleep( 1000 );
    }

	return dwPort;
}



HRESULT InsertList( List** ppList, XMediaObject* pXMO, char* szName )
{
	if ( NULL == ppList || NULL == pXMO )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	List* pTemp = NULL;
	List* pLast = *ppList;

	pTemp = new List;
	CHECKALLOC( pTemp );

	if ( SUCCEEDED( hr ) )
	{
		pTemp->pXMO = pXMO;
		pTemp->pNext = NULL;
		pTemp->szName = szName;
	}

	if ( SUCCEEDED( hr ) && NULL == pLast )
	{
		*ppList = pTemp;
	}

	else if ( SUCCEEDED( hr ) )
	{
		for( ; NULL != pLast->pNext; pLast = pLast->pNext )
		{
			// NO CODE HERE
		}

		pLast->pNext = pTemp;
	}

	return hr;
}

HRESULT InitWaveFormat( LPWAVEFORMATEX* ppFormat )
{
	if ( NULL == ppFormat )
		return E_INVALIDARG;

	LPWAVEFORMATEX pFormat = new WAVEFORMATEX;
	
	if ( NULL == pFormat )
		return E_OUTOFMEMORY;

    pFormat->wFormatTag          = WAVE_FORMAT_PCM;
    pFormat->nSamplesPerSec      = 16000;
    pFormat->nChannels           = 1;
    pFormat->wBitsPerSample      = (WORD) 16;
    pFormat->nBlockAlign         = (16 * pFormat->nChannels / 8);
    pFormat->nAvgBytesPerSec     = pFormat->nSamplesPerSec * pFormat->nBlockAlign;
    pFormat->cbSize              = 0;

	*ppFormat = pFormat;

	return S_OK;
}

HRESULT InitEncodedFormat( ENCODEDFORMATEX* pFormat, DWORD dwFlags )
{
	if ( NULL == pFormat )
		return E_INVALIDARG;

	if ( dwFlags & XMO_ADPCM_ENC || dwFlags & XMO_ADPCM_DEC )
	{
		IMAADPCMWAVEFORMAT* pwfx = &pFormat->wfxAdpcm;

		pwfx->wfx.wFormatTag = WAVE_FORMAT_IMA_ADPCM;
		pwfx->wfx.nChannels = 1;
		pwfx->wfx.nSamplesPerSec = 16000;
		pwfx->wfx.wBitsPerSample = 4;
		pwfx->wfx.nBlockAlign = (((SAMPLES_PER_BLOCK * 4) + 7) >> 3) + 4;
		pwfx->wfx.nAvgBytesPerSec = pwfx->wfx.nSamplesPerSec * pwfx->wfx.nBlockAlign / SAMPLES_PER_BLOCK;
		pwfx->wfx.cbSize = sizeof(*pwfx) - sizeof(pwfx->wfx);
		pwfx->wSamplesPerBlock = SAMPLES_PER_BLOCK;
	}

	// add code for vox

	return S_OK;
}



HRESULT InitStream( LPDSSTREAMDESC pDesc, LPCWAVEFORMATEX pFormat )
{
	if ( NULL == pDesc || NULL == pFormat )
		return E_INVALIDARG;

    pDesc->dwSize = sizeof( *pDesc );
    pDesc->dwFlags = 0;
    pDesc->dwMaxAttachedPackets = PACKET_COUNT;
    pDesc->lpwfxFormat = (LPWAVEFORMATEX) pFormat;

	return S_OK;
}

HRESULT CreateNetXMO( XMediaObject** pXMO )
{
	if ( NULL == pXMO )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	static XMediaObject* pNetXMO = NULL;

	if ( pNetXMO )
	{
		pNetXMO->AddRef();
	}

	else
	{
		CHECKEXECUTE( XnetCreateMediaObject( &pNetXMO, INVALID_SOCKET, IsLeftMachine() ? TEST_ADDR_RIGHT : TEST_ADDR_LEFT, TEST_PORT, PACKET_SIZE, 0 ) );
	}

	if ( SUCCEEDED( hr ) )
	{
		*pXMO = pNetXMO;
	}

	return hr;
}

HANDLE GetEvent( void )
{
	if ( NULL == g_hEvent )
	{
		g_hEvent = CreateEvent( NULL, FALSE, TRUE, NULL );
	}

	return g_hEvent;
}

void DestroyEvent( void )
{
	if ( NULL != g_hEvent )
	{
		CloseHandle( g_hEvent );
		g_hEvent = NULL;
	}
}

HRESULT CreateList( List** ppList, DWORD dwFlags )
{
	if ( NULL != *ppList )
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	XMediaObject* pXMO = NULL;
	DWORD dwIndex = 0x00000001;

	LPCWAVEFORMATEX pwfxRaw = NULL;
	ENCODEDFORMATEX wfxEncoded;
	DSSTREAMDESC dsDesc;

	char * szName = NULL;

	ZeroMemory( &wfxEncoded, sizeof( ENCODEDFORMATEX ) );
	ZeroMemory( &dsDesc, sizeof( DSSTREAMDESC ) );

	CHECKEXECUTE( InitEncodedFormat( &wfxEncoded, dwFlags ) );

	while ( SUCCEEDED( hr ) && XMO_NULL != dwIndex )
	{
		switch ( dwFlags & dwIndex )
		{
			case XMO_HAWK_HEAD:
				szName = XMO_NAME_HAWK_HEAD;
				CHECKEXECUTE( XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_HEADPHONE, GetHawkPort(), PACKET_COUNT, (LPWAVEFORMATEX) pwfxRaw, &pXMO ) );
				break;

			case XMO_MCPX:
				CHECKEXECUTE( InitStream( &dsDesc, pwfxRaw ) );
				CHECKEXECUTE( DirectSoundCreateStream( DSDEVID_MCPX, &dsDesc, (LPDIRECTSOUNDSTREAM*) &pXMO, NULL ) );
				break;

			case XMO_HAWK_MIC:
				szName = XMO_NAME_HAWK_MIC;
				CHECKEXECUTE( InitWaveFormat( (LPWAVEFORMATEX*) &pwfxRaw ) );
				CHECKEXECUTE( XVoiceCreateMediaObject( XDEVICE_TYPE_VOICE_MICROPHONE, GetHawkPort(), PACKET_COUNT, (LPWAVEFORMATEX) pwfxRaw, &pXMO ) );
				break;

			case XMO_NET_SEND:
				szName = XMO_NAME_NET_SEND;
			case XMO_NET_RECV:
				szName = NULL == szName ? XMO_NAME_NET_RECV : szName;
				CHECKEXECUTE( InitWaveFormat( (LPWAVEFORMATEX*) &pwfxRaw ) );
				CHECKEXECUTE( CreateNetXMO( &pXMO ) );
				break;

			case XMO_WAVE_FILE:
				CHECKEXECUTE( XWaveFileCreateMediaObject( FILE_NAME, &pwfxRaw, (XFileMediaObject**) &pXMO ) );
				break;

			case XMO_SRC_16_8:
			case XMO_SRC_8_16:
			//	CHECKEXECUTE( XSrcCreateMediaObject( &pXMO, pwfxRaw ) );
				break;

			case XMO_VOX_ENC:
				break;

			case XMO_VOX_DEC:
				break;

			case XMO_ADPCM_ENC:
				CHECKEXECUTE( AdpcmCreateEncoder( (LPWAVEFORMATEX) pwfxRaw, SAMPLES_PER_BLOCK, &wfxEncoded.wfxAdpcm, &pXMO ) );
				break;

			case XMO_ADPCM_DEC:
				CHECKEXECUTE( AdpcmCreateDecoder( &wfxEncoded.wfxAdpcm, (LPWAVEFORMATEX) pwfxRaw, &pXMO ) );
				break;

			default:
				pXMO = NULL;
				szName = NULL;
				break;
		}

		if ( SUCCEEDED( hr ) && NULL != pXMO )
		{
			CHECKEXECUTE( InsertList( ppList, pXMO, szName ) );
		}	

		dwIndex <<= 1;
	}

	return hr;
}

DWORD CountList( List* pList )
{
	DWORD dwCount = 0;

	for ( ; NULL != pList; pList = pList->pNext )
	{
		dwCount++;
	}

	return dwCount;
}

HRESULT ConnectXMOs( List* pXMOList, LPDWORD pdwPacketSize )
{
	if ( NULL == pXMOList )
		return S_OK;

	if ( NULL == pdwPacketSize )
	{
		return E_INVALIDARG;
	}

	HRESULT hr = S_OK;

	XMEDIAINFO xMediaInfo;
	ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

	DWORD dwNumXMOs = CountList( pXMOList );
	DWORD dwMask = 1UL << (dwNumXMOs - 1);
	DWORD dwDone = 0x00000000;
	DWORD dwOldInputSize = 0;
	DWORD dwOldOutputSize = 0;
	DWORD dwCompleted = 0xFFFFFFFF << dwNumXMOs;

	*pdwPacketSize = PACKET_SIZE;

	while ( 0xFFFFFFFF != ( dwDone | dwCompleted ) ) 
	{
		for ( List* pList = pXMOList ; SUCCEEDED( hr ) && NULL != pList; pList = pList->pNext )
		{
			xMediaInfo.dwInputSize = xMediaInfo.dwOutputSize;
			xMediaInfo.dwOutputSize = pList == pXMOList ? *pdwPacketSize : 0;

			dwOldInputSize = xMediaInfo.dwInputSize;
			dwOldOutputSize = xMediaInfo.dwOutputSize;

			CHECKEXECUTE( pList->pXMO->GetInfo( &xMediaInfo ) );

			if ( ( pList == pXMOList && xMediaInfo.dwOutputSize == dwOldOutputSize ) || 
				 ( NULL == pList->pNext && xMediaInfo.dwInputSize == dwOldInputSize ) || 
				 ( xMediaInfo.dwInputSize == dwOldInputSize /*&& xMediaInfo.dwOutputSize == dwOldOutputSize*/ ) )
			{
				dwDone |= dwMask;
			}

			*pdwPacketSize = max( xMediaInfo.dwInputSize, max( xMediaInfo.dwOutputSize, *pdwPacketSize ) );

			dwMask >>= 1UL;
		}

		dwMask = 1UL << (dwNumXMOs - 1);
	}
	
	DbgPrint( "Agreed size: %u\n", *pdwPacketSize );

	return hr;
}

HRESULT InitPacket( LPXMEDIAPACKET pPacket, DWORD dwPacketSize, LPVOID pBuffer, LPDWORD dwStatus, LPDWORD dwCompletedSize, HANDLE hEvent )
{
	if ( NULL == pPacket )
		return E_INVALIDARG;

	ZeroMemory( pPacket, sizeof ( XMEDIAPACKET ) );

	pPacket->dwMaxSize = dwPacketSize;
	pPacket->pvBuffer = pBuffer;

	pPacket->pdwStatus = dwStatus;
	pPacket->pdwCompletedSize = dwCompletedSize;

	pPacket->hCompletionEvent = hEvent;

	return S_OK;
}

HRESULT InitProcessContext( List* pXMOList, DWORD dwPacketSize, ProcessContext** ppContext )
{
	if ( NULL == ppContext )
		return E_INVALIDARG;

	if ( NULL == pXMOList )
	{
		*ppContext = NULL;
		return S_OK;
	}

	HRESULT hr = S_OK;
	DWORD i = 0;

	ProcessContext* pContext = new ProcessContext;
	CHECKALLOC( pContext );

	if ( SUCCEEDED( hr ) )
	{
		ZeroMemory( pContext, sizeof( ProcessContext ) );
		pContext->pXMOList = pXMOList;

		for ( pContext->pLastXMO = pXMOList; NULL != pContext->pLastXMO->pNext; pContext->pLastXMO = pContext->pLastXMO->pNext ); 

		pContext->dwPacketSize = dwPacketSize;
		pContext->dwBytesPerQueue = pContext->dwPacketSize * PACKET_COUNT;

//		pContext->dwInStatus = XMEDIAPACKET_STATUS_PENDING;
//		pContext->dwOutStatus = XMEDIAPACKET_STATUS_PENDING;

//		pContext->dwInCompletedSize = 0;
//		pContext->dwOutCompletedSize = 0;

//		pContext->dwNumQueued = 0;
//		pContext->dwStartQueue = 0;

//		for ( i = 0; i < PACKET_COUNT; i++ )
//		{
//			pContext->dwNumDest[i] = 0;
//		}

/*		for ( i = 0; SUCCEEDED( hr ) && i < NUM_EVENTS; i++ )
		{
			pContext->pPacketEvents[i] = CreateEvent( NULL, FALSE, FALSE, NULL );
			CHECKALLOC( pContext->pPacketEvents[i] );
		}
*/
		pContext->hEvent = GetEvent();
		CHECKALLOC( pContext->hEvent );
	}

	if ( SUCCEEDED( hr ) )
	{
		pContext->pQueueBuffer = new BYTE[pContext->dwBytesPerQueue * NUM_QUEUES];
		CHECKALLOC( pContext->pQueueBuffer );
	}

	if ( SUCCEEDED( hr ) )
	{
		ZeroMemory( pContext->pQueueBuffer, pContext->dwBytesPerQueue * NUM_QUEUES );
	}

	for ( i = 0; SUCCEEDED( hr ) && i < NUM_EVENTS; i++ )
	{
		pContext->pdwStatus[i] = 0;
		pContext->pdwContextStatus[i] = FREE_SRC;
		pContext->pdwCompletedSize[i] = 0;

		CHECKEXECUTE( InitPacket( &pContext->pPackets[i], 
			                      pContext->dwPacketSize, 
								  pContext->pQueueBuffer + i * pContext->dwPacketSize, 
								  &pContext->pdwStatus[i], 
								  &pContext->pdwCompletedSize[i], 
								  pContext->hEvent ) );	
	}
		
	if ( SUCCEEDED( hr ) )
	{
		*ppContext = pContext;
	}

	return hr;
}

void DestroyProcessContext( ProcessContext* pContext )
{
	if ( NULL == pContext )
		return;

	delete [] pContext->pQueueBuffer;

	delete pContext;
}
/*
HRESULT PrimeContext( ProcessContext* pContext )
{
	if ( NULL == pContext )
		return S_OK;

	HRESULT hr = S_OK;

	for ( DWORD i = 0; SUCCEEDED( hr ) && i < PACKET_COUNT; i++ )
	{
		pContext->dwNumDest[i] = i + PACKET_COUNT;
		*pContext->pPackets[i + PACKET_COUNT].pdwCompletedSize = 0;
		CHECKEXECUTE( pContext->pXMOList->pXMO->Process( NULL, &pContext->pPackets[i + PACKET_COUNT] ) );
	}

	pContext->dwNumQueued = PACKET_COUNT;
	pContext->dwStartQueue = 0;

	return hr;
}
*/
/*HRESULT Process( ProcessContext* pContext )
{
	if ( NULL == pContext )
		return S_OK;

	HRESULT hr = S_OK;

	List* pCurrent = pContext->pXMOList;

	DWORD dwWait = WaitForMultipleObjects( NUM_EVENTS, pContext->pPacketEvents, FALSE, INFINITE );
	dwWait -= WAIT_OBJECT_0;

	if ( PACKET_COUNT <= dwWait )
	{
		if ( 0 != pContext->dwNumQueued && dwWait == pContext->dwNumDest[pContext->dwStartQueue] )
		{
			pContext->dwNumQueued--;
			pContext->dwStartQueue = ( pContext->dwStartQueue + 1 ) % PACKET_COUNT;

			pCurrent = pCurrent->pNext;

			for ( ; SUCCEEDED( hr ) && NULL != pCurrent; pCurrent = pCurrent->pNext )
			{
				*pContext->pPackets[dwWait - PACKET_COUNT].pdwCompletedSize = 0;
				//memcpy( pContext->pPackets[dwWait - PACKET_COUNT].pvBuffer, pContext->pPackets[dwWait].pvBuffer, pContext->dwPacketSize );
				pContext->pPackets[dwWait - PACKET_COUNT].pvBuffer = pContext->pQueueBuffer + dwWait * pContext->dwPacketSize;
				CHECKEXECUTE( pCurrent->pXMO->Process( &pContext->pPackets[dwWait - PACKET_COUNT], NULL == pCurrent->pNext ? NULL : &pContext->pPackets[dwWait] ) );
			}

		}
		else
		{
			SetEvent( pContext->pPacketEvents[dwWait] );
		}
	}
	else
	{
		if ( PACKET_COUNT != pContext->dwNumQueued )
		{
			pContext->dwNumDest[pContext->dwStartQueue] = dwWait + PACKET_COUNT;
			pContext->dwNumQueued++;
			pContext->dwStartQueue = 0 == pContext->dwStartQueue ? PACKET_COUNT - 1 : pContext->dwStartQueue - 1;

			*pContext->pPackets[dwWait + PACKET_COUNT].pdwCompletedSize = 0;
			CHECKEXECUTE( pCurrent->pXMO->Process( NULL, &pContext->pPackets[dwWait + PACKET_COUNT] ) );
		}
		else
		{
			SetEvent( pContext->pPacketEvents[dwWait] );
		}
	}

	return hr;
}
*/



HRESULT Process( ProcessContext* pContext )
{
	if ( NULL == pContext )
		return S_OK;

	HRESULT hr = S_OK;
	DWORD i = 0;
	DWORD dwStatusSrc = 0;
	DWORD dwStatusDest = 0;
	
	static DWORD c = 0;

	for ( i = 0; i < NUM_EVENTS && SUCCEEDED( hr ); i++ )
	{
		if ( PENDING_SRC == pContext->pdwContextStatus[i] && XMEDIAPACKET_STATUS_SUCCESS == pContext->pdwStatus[i] )
		{
			pContext->pdwContextStatus[i] = FREE_DEST;
		}

		if ( PENDING_DEST == pContext->pdwContextStatus[i] && XMEDIAPACKET_STATUS_SUCCESS == pContext->pdwStatus[i] )
		{
			pContext->pdwContextStatus[i] = FREE_SRC;
		}
	}

	for ( i = 0; i < NUM_EVENTS && SUCCEEDED( hr ); i++ )
	{
		CHECKEXECUTE( pContext->pXMOList->pXMO->GetStatus( &dwStatusSrc ) );
		CHECKEXECUTE( pContext->pLastXMO->pXMO->GetStatus( &dwStatusDest ) );

		if ( SUCCEEDED( hr ) && FREE_SRC == pContext->pdwContextStatus[i] && XMO_STATUSF_ACCEPT_OUTPUT_DATA & dwStatusSrc )
		{
			pContext->pPackets[i].dwMaxSize = pContext->dwPacketSize;
			*pContext->pPackets[i].pdwCompletedSize = 0;
			pContext->pdwContextStatus[i] = PENDING_SRC;
			/*CHECKEXECUTE(*/ hr = pContext->pXMOList->pXMO->Process( NULL, &pContext->pPackets[i] /*)*/ );

			if ( ( SUCCEEDED( hr ) && 
				   XMEDIAPACKET_STATUS_SUCCESS == pContext->pdwStatus[i] && 
				   0 == *pContext->pPackets[i].pdwCompletedSize ) || FAILED( hr ) )
			{
				__asm int 3;
				DbgPrint( "Warning case source\n" );
			//	hr = S_OK;
				break;
			}

		}

		if ( SUCCEEDED( hr ) && FREE_DEST == pContext->pdwContextStatus[i] && XMO_STATUSF_ACCEPT_INPUT_DATA & dwStatusDest )
		{
		//	if ( c++ % 100 == 0 )
		//	DbgPrint( "******************** %u PENDING_DEST %s\n", i, pContext->pLastXMO->szName );

			pContext->pPackets[i].dwMaxSize = *pContext->pPackets[i].pdwCompletedSize;
			*pContext->pPackets[i].pdwCompletedSize = 0;
			pContext->pdwContextStatus[i] = PENDING_DEST;
			/*CHECKEXECUTE(*/ hr = pContext->pLastXMO->pXMO->Process( &pContext->pPackets[i], NULL /*)*/ );

			if ( ( SUCCEEDED( hr ) && XMEDIAPACKET_STATUS_SUCCESS == pContext->pdwStatus[i] && 0 == *pContext->pPackets[i].pdwCompletedSize ) || FAILED( hr ) )
			{
				DbgPrint( "waring case dest\n" );
				__asm int 3;
			//	hr = S_OK;
				break;
			}

		}
	}

	return hr;
}

HRESULT ProcessXMOs( List* pSendXMOs, DWORD dwSendPacketSize, List* pRecvXMOs, DWORD dwRecvPacketSize )
{
	HRESULT hr = S_OK;

	ProcessContext* pSendContext = NULL;
	ProcessContext* pRecvContext = NULL;

	CHECKEXECUTE( InitProcessContext( pSendXMOs, dwSendPacketSize, &pSendContext ) );
	CHECKEXECUTE( InitProcessContext( pRecvXMOs, dwRecvPacketSize, &pRecvContext ) );

//	CHECKEXECUTE( PrimeContext( pSendContext ) );
//	CHECKEXECUTE( PrimeContext( pRecvContext ) );

	while ( SUCCEEDED( hr ) )
	{
		WaitForSingleObject( g_hEvent, INFINITE );

		CHECKEXECUTE( Process( pSendContext ) );
		CHECKEXECUTE( Process( pRecvContext ) );
	}
	
	DestroyProcessContext( pSendContext );
	DestroyProcessContext( pRecvContext );

	return hr;
}

void RunTest( void )
{
	HRESULT hr = S_OK;

	List* pSendXMOs = NULL;
	List* pRecvXMOs = NULL;

	DWORD dwSendPacketSize = 0;
	DWORD dwRecvPacketSize = 0;

	CHECKEXECUTE( OpenNet() );

	CHECKEXECUTE( CreateList( &pSendXMOs, XMO_HAWK_MIC | XMO_NET_SEND ) );
	CHECKEXECUTE( CreateList( &pRecvXMOs, XMO_NET_RECV | XMO_HAWK_HEAD ) );

	CHECKEXECUTE( ConnectXMOs( pSendXMOs, &dwSendPacketSize ) );
	CHECKEXECUTE( ConnectXMOs( pRecvXMOs, &dwRecvPacketSize ) );

	CHECKEXECUTE( ProcessXMOs( pSendXMOs, dwSendPacketSize, pRecvXMOs, dwRecvPacketSize ) );

	DeleteList( pSendXMOs );
    DeleteList( pRecvXMOs );

	CHECKEXECUTE( CloseNet() );

}

EXTERN_C DWORD WINAPI VoiceThreadProc( LPVOID lpParameter )
{
	RunTest();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\sendping\inc\controller.h ===
/*
 * File : Controller.h
 * Author : Sandeep Prabhu
 * Revision History
 *      27/4/2000       sandeep           Created
 *
 * The Controller object is teh client side of AutoSrv and exposes the APIs provided by
 * AutoSrv to the upper level clients - COM objects, C++ programs. It is totally transparent
 * to the underlying driver. The clients need to provide it Send and Receive callback funtions
 * along with an I/O context
 */
 
#ifndef __CONTROLLER__H
#define __CONTROLLER__H

#include <winsock2.h>
#include <iphlpapi.h>
#include "CommandStructs.h"
                  
typedef DWORD (*SEND_HANDLER) (PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength);

typedef DWORD (*RECEIVE_HANDLER) (PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength,                                                   
                                  PULONG pulBytesRead, DWORD dwTimeout);   

//
// Winsock send and receive handlers
//
DWORD WinsockSendHandler(PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength);
DWORD WinsockRecvHandler(PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength,                             
                         PULONG pulBytesRead, DWORD dwTimeout);

class CController {
private:
    LONG m_lTID;
    SEND_HANDLER m_pfnSendHandler;
    RECEIVE_HANDLER m_pfnReceiveHandler;
    PVOID m_pvContextHandle;
    INT m_iRexmitCount;
    DWORD m_dwInitRexmitTimeout;
    DWORD m_dwRexmitTimeoutDelta;
    BOOL m_fWinsock;


    DWORD GetUniqueResponseId();
    PVOID SendAndReceive(tGenericStruct *pCommandStruct, DWORD dwLength,                                  
                         PDWORD pdwCommandStatus, PDWORD pdwStatus);
    DWORD Cleanup();

public:
    CController(PVOID pvContextHandle, SEND_HANDLER pfnSendHandler, 
                RECEIVE_HANDLER pfnReceiveHandler);
    
    //
    // Will create a controller which uses Winsock to talk with autosrv
    //
    CController(PCHAR pszSrcIP, PCHAR pszDstIP, USHORT usSrcPort, USHORT usDstPort,                         
                PDWORD pdwStatus);
    ~CController();

    /*********************************************************************
     * Functions exposed by AutoSrv
     *********************************************************************/

    //
    // Miscellaneous commands
    //
    DWORD Reboot();
    DWORD Ping();


    //
    // IPHlpAPI functions
    //
    PMIB_IPNETTABLE GetArpCache(PDWORD pdwStatus);
    DWORD FlushArpCache(DWORD dwAdapterIndex);
    DWORD DeleteArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                              PTCHAR pszMacAddress, DWORD dwType);
    DWORD AddArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                           PTCHAR pszMacAddress, DWORD dwType);
    DWORD CheckArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                             PTCHAR pszMacAddress, PBOOL pfPresent);
    PMIB_IPFORWARDTABLE GetRouteTable(PDWORD pdwStatus);
    DWORD DeleteRouteTableEntry(DWORD dwAdapterIndex, PTCHAR pszTargetIP, PTCHAR pszGWIP, 
                                PTCHAR pszMask, DWORD dwMetric, DWORD dwType);
    DWORD AddRouteTableEntry(DWORD dwAdapterIndex, PTCHAR pszTargetIP, PTCHAR pszGWIP, 
                             PTCHAR pszMask, DWORD dwMetric, DWORD dwType);
    DWORD GetNumInterfaces(PDWORD pdwCount);
    DWORD GetInterfaceIndex(PTCHAR pszFriendlyName, PDWORD pdwIndex);
    DWORD DeleteIP(ULONG ulNTEContext);
    DWORD AddIP(DWORD dwAdapterIndex, PTCHAR pszIPAddress, PTCHAR pszMask, 
                PULONG pulNTEContext);
    PMACADDR SendArp(PTCHAR pszDestIP, PTCHAR pszSrcIP, PDWORD pdwStatus);

    //
    // Registry commands
    //
    DWORD CreateRegistryKey(HKEY hMainKey, PTCHAR pszSubKey, DWORD dwOptions, REGSAM Sam);
    DWORD DeleteRegistryKey(HKEY hMainKey, PTCHAR pszSubKey);
    DWORD SetRegistryKeyValue(HKEY hMainKey, PTCHAR pszSubKey, PTCHAR pszValueName, DWORD dwType,
                              PBYTE pbValue, DWORD dwLength);
    tResponse_GetRegistryKeyValue* GetRegistryKeyValue(HKEY hMainKey, PTCHAR pszSubKey, 
                                                       PTCHAR pszValueName, PDWORD pdwStatus);

    //
    // Session commands
    //
    DWORD Socket(INT iType, PDWORD pdwSessionId);
    DWORD BindEx(DWORD dwSessionId, PTCHAR pszSrcIP, USHORT usSrcPort);
    DWORD Bind(INT iType, PTCHAR pszSrcIP, USHORT usSrcPort, PDWORD pdwSessionId);
    DWORD SetSocketOption(DWORD dwSessionId, INT iOption, PCHAR pchValue, INT iSize);
    DWORD Connect(INT iType, PTCHAR pszSrcIP, USHORT usSrcPort, 
                  PTCHAR pszDestIP, USHORT usDestPort, PDWORD pdwSessionId);
    DWORD ConnectEx(DWORD dwSessionId, PTCHAR pszDestIP, USHORT usDestPort);
    DWORD AsyncConnectEx(PDWORD pdwTID, DWORD dwSessionId, PTCHAR pszDestIP, USHORT usDestPort);
    DWORD Accept(INT iType, PTCHAR pszSrcIP, USHORT usSrcPort, INT iListenQ, 
                 PDWORD pdwSessionId);
    DWORD AcceptEx(DWORD dwSessionId, INT iListenQ);
    DWORD AsyncAcceptEx(PDWORD pdwTID, DWORD dwSessionId, INT iListenQ);
    DWORD Receive(DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay, INT iBufferSize);
    DWORD AsyncReceive(PDWORD pdwTID, DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay, 
                       INT iBufferSize);
    DWORD Send(DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay, INT iBufferSize, 
               PCHAR pchBuffer=NULL);
    DWORD AsyncSend(PDWORD pdwTID, DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay, 
                    INT iBufferSize, PCHAR pchBuffer=NULL);
    DWORD GetSessionStats(DWORD dwSessionId, PDWORD pdwBytesSent, PDWORD pdwBytesRcvd);
    DWORD GetAsyncCompletionStatus(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD GetAsyncStatus(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD Stop(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD Shutdown(DWORD dwSessionId);
    DWORD Close(DWORD dwSessionId);
    DWORD Reset(DWORD dwSessionId);
    DWORD AsyncShutdown(PDWORD pdwTID, DWORD dwSessionId);
    DWORD AsyncClose(PDWORD pdwTID, DWORD dwSessionId);
    DWORD AsyncReset(PDWORD pdwTID, DWORD dwSessionId);
};
          
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\lib\xbttcp.c ===
/*
 * File             :       SendPing.cpp
 * Author           :       Jim Y
 * Revision History
 *      Aug/02/2000   JimY        Created    
 *
 * This file contains code for sending a Ping
 */


#include "precomp.h"

#include <xbttcp.h>
#include <xtl.h>
#include <stdlib.h>
#include <xlog.h>

#define RCVTIMEOUT  3
#define PINGBUFSIZE 2048
#define BuffLen 200
#define UNICAST 0
#define MULTICAST 1
#define IPADDRESSLENGTH 16
#define PASS 0
#define FAIL 1

//
// Functions exported by XNET.DLL
//

INT WSAAPI XnetInitialize(const XnetInitParams*, BOOL);
INT WSAAPI XnetCleanup(VOID);

//
// Functions local to this module
//
INT Ping(HANDLE, INT, CHAR *);
VOID SendIcmpMessage(SOCKET, struct sockaddr_in*, IcmpMessage*, INT);
BOOL RecvIcmpMessage(SOCKET, struct sockaddr_in*);



CHAR TESTADDR[IPADDRESSLENGTH];
CHAR UCASTTESTADDR[IPADDRESSLENGTH];   


INT err, result;
CHAR databuf[PINGBUFSIZE];
INT rcvlen;
WORD id, seqno;
//CHAR pingdata[] = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
CHAR pingdata[] = "XBOXPING";

char szBuffer[BuffLen];
char iniBuffer[BuffLen];

SOCKET sock;
struct sockaddr_in sockname;
IcmpMessage* icmpmsg;
struct in_addr mcastif;
//struct in_addr ucastreq;  //unicast
struct ip_mreq mcastreq;  //multicast



#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())


__inline _bind(SOCKET s, struct sockaddr_in* addr) {
    return bind(s, (struct sockaddr*) addr, sizeof(*addr));
}

__inline INT _sendto(SOCKET s, CHAR* buf, DWORD buflen, struct sockaddr_in* to) {
    WSABUF wsabuf = { buflen, buf };
    return WSASendTo(s, &wsabuf, 1, &buflen, 0, (struct sockaddr*) to, sizeof(*to), 0, 0);
}

__inline INT _recvfrom(SOCKET s, CHAR* buf, DWORD* buflen, struct sockaddr_in* from) {
    WSABUF wsabuf = { *buflen, buf };
    INT fromlen = sizeof(*from);
    DWORD flags = 0;
    return WSARecvFrom(s, &wsabuf, 1, buflen, &flags, (struct sockaddr*) from, &fromlen, 0, 0);
}


VOID
SendIcmpMessage(
    SOCKET s,
    struct sockaddr_in* toaddr,
    IcmpMessage* icmpmsg,
    INT msglen
    )
{
    icmpmsg->checksum = 0;
    icmpmsg->checksum = (WORD) ~tcpipxsum(0, icmpmsg, msglen);

    err = _sendto(s, (CHAR*) icmpmsg, msglen, toaddr);
    if (err != NO_ERROR) {
        WARNFAIL(sendto);
    }
}


BOOL
RecvIcmpMessage(
    SOCKET s,
    struct sockaddr_in* fromaddr
    )
{
    TIMEVAL timeout;
    fd_set readfds;
    DWORD len;

    // Wait until there is data to be read

    timeout.tv_sec = RCVTIMEOUT;
    timeout.tv_usec = 0;

    FD_ZERO(&readfds);
    FD_SET(s, &readfds);

    err = select(1, &readfds, NULL, NULL, &timeout);
    if (err == SOCKET_ERROR) {
        WARNFAIL(select); return FALSE;
    }

    if (err == 0) return FALSE;

    len = PINGBUFSIZE;
    err = _recvfrom(s, databuf, &len, fromaddr);
    if (err != NO_ERROR) {
        WARNFAIL(recvfrom); return FALSE;
    }

    rcvlen = len;
    return TRUE;
}




INT
Ping(HANDLE hLog, INT AddressType, CHAR * TESTADDR)
{
    SOCKET sock;
    struct sockaddr_in sockname;
    IcmpMessage* icmpmsg;
    struct in_addr mcastif;
//    struct in_addr ucastreq;  //unicast
    struct ip_mreq mcastreq;  //multicast
    INT result = FAIL;

    CHAR ActualIP[IPADDRESSLENGTH];
    CHAR ExpectedIP[IPADDRESSLENGTH];   




    DbgPrint("SendPing: Inside Ping()...\n");

    ZeroMem(&ActualIP, IPADDRESSLENGTH);
    ZeroMem(&ExpectedIP, IPADDRESSLENGTH);

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); return result;
    }

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }


    //
    // If a Multicast ping
    //

    if (AddressType == MULTICAST)  {

        mcastif.s_addr = INADDR_ANY;
        err = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, (char*) &mcastif, sizeof(mcastif));
        if (err != NO_ERROR) {
            WARNFAIL(setmcastif); goto exit;
        }


        mcastreq.imr_multiaddr.s_addr = inet_addr(TESTADDR);
        mcastreq.imr_interface.s_addr = INADDR_ANY;
        err = setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
        if (err != NO_ERROR) {
            WARNFAIL(addmember); goto exit;
        }
     }



            icmpmsg = (IcmpMessage*) databuf;
            icmpmsg->type = ICMPTYPE_ECHO_REQUEST;
            icmpmsg->code = 0;
            icmpmsg->id = id++;
            icmpmsg->seqno = seqno++;
            CopyMem(icmpmsg->origdata, pingdata, sizeof(pingdata));
            sockname.sin_addr.s_addr = inet_addr(TESTADDR);

            DbgPrint("Sending out ICMP echo request...\n");
            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);

            SendIcmpMessage(
                sock,
                &sockname,
                icmpmsg,
                ICMPHDRLEN + sizeof(pingdata));


        if (RecvIcmpMessage(sock, &sockname)) {
            IpHeader* iphdr = (IpHeader*) databuf;
            INT iphdrlen, iplen;

            DbgPrint("Received ICMP message from %s:\n", inet_ntoa(sockname.sin_addr));

            if (rcvlen < IPHDRLEN ||
                (iphdrlen = GETIPHDRLEN(iphdr)) == 0 ||
                iphdrlen > rcvlen ||
                (iplen = GETIPLEN(iphdr)) > rcvlen ||
                iphdrlen > iplen) {
                DbgPrint("  Bad IP header!\n");
            }

            rcvlen = iplen - iphdrlen;
            icmpmsg = (IcmpMessage*) &databuf[iphdrlen];
            
            if (rcvlen < ICMPHDRLEN ||
                tcpipxsum(0, icmpmsg, rcvlen) != 0xffff) {
                DbgPrint("  Bad ICMP header!\n");
            }
            
//            DbgPrint("  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
//            DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
//            DbgPrint("  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);

            //
            // These conditions must be met for the PING to be declared PASS 
            //
            if (AddressType == MULTICAST)  {
            // gethostname()
            // strcpy(ExpectedIP, gethostbyname());
            }
            if (AddressType == UNICAST)  {
                strcpy(ExpectedIP, TESTADDR);
            }

            strcpy(ActualIP, inet_ntoa(sockname.sin_addr));
            strcpy(ExpectedIP, TESTADDR);
            DbgPrint("  ActualIP = [%s]\n", ActualIP);
            DbgPrint("  ExpectedIP = [%s]\n", ExpectedIP);
            DbgPrint("  strstr = %d\n", strstr(ActualIP, ExpectedIP) );
            if (strstr(ActualIP, ExpectedIP))  {
                xLog(hLog, XLL_INFO, "ActualIP matches ExpectedIP");
                DbgPrint("SendPing: ActualIP matches ExpectedIP\n");

                if ((icmpmsg->seqno == seqno) && (icmpmsg->type = ICMPTYPE_ECHO_REPLY))  {
                    result = PASS;
                }
                else  {
                    xLog(hLog, XLL_INFO, "SequenceNumber or MessageType is not what's expected");                 
                    DbgPrint("  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
                    DbgPrint("  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
                    DbgPrint("  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);
                }
            }
            else {
                xLog(hLog, XLL_INFO, "ActualIP does NOT match ExpectedIP");
                DbgPrint("SendPing: ActualIP does NOT match ExpectedIP\n");
            }


            if (icmpmsg->type == ICMPTYPE_ECHO_REQUEST) {
                DbgPrint("Sending out ICMP echo reply...\n");
                icmpmsg->type = ICMPTYPE_ECHO_REPLY;
                SendIcmpMessage(sock, &sockname, icmpmsg, rcvlen);
            }

        }


    //
    // If a Multicast ping
    //
    if (AddressType == MULTICAST)  {
        err = setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
        if (err != NO_ERROR) {
            WARNFAIL(dropmember); goto exit;
        }
    }



exit:
    closesocket(sock);
    return result; 
}



INT xbtUCastPing(CHAR *TESTADDR, UINT *Offset, CHAR *mydatabuf, UINT datalength, CHAR *ResponseIP,  CHAR *mypingmessage, UINT mypingmessagelength)
{

    INT iphdrlen, iplen;
    INT result = FAIL;


    DbgPrint("xbttcp: In xbtUCastPing...\n");
    DbgPrint("xbttcp: mypingmessge = [%s]\n", mypingmessage);
    *Offset = 0;

    // 
    // Create the Socket
    //

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); goto exit;
    }


    //
    // Set some values in the socket struct
    // 

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

 
    //
    // Bind the socket
    // 

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }


    // 
    // Fill in ICMP values to be sent out
    //

    icmpmsg = (IcmpMessage*) databuf;
    icmpmsg->type = ICMPTYPE_ECHO_REQUEST;
    icmpmsg->code = 0;
    icmpmsg->id = (WORD) (GetTickCount() >> 16);
//    icmpmsg->id = id++;
    icmpmsg->seqno = (WORD) (GetTickCount() & 0xffff);
//    icmpmsg->seqno = seqno++;
//    CopyMem(icmpmsg->origdata, pingdata, sizeof(pingdata));
    CopyMem(icmpmsg->origdata, mypingmessage, strlen(mypingmessage));
    sockname.sin_addr.s_addr = inet_addr(TESTADDR);


    //
    // Send a PING request (ECHO_REQUEST)
    // 
    DbgPrint("xbttcp: Sending out ICMP echo request...\n");
    DbgPrint("xbttcp:   id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);

    SendIcmpMessage(sock, &sockname, icmpmsg, ICMPHDRLEN + strlen(mypingmessage));
//    SendIcmpMessage(sock, &sockname, icmpmsg, ICMPHDRLEN + sizeof(pingdata));


    //
    // Receive any ICMP message (response)
    //

    if (RecvIcmpMessage(sock, &sockname)) 
    {

        IpHeader* iphdr = (IpHeader*) databuf;

        ZeroMem(ResponseIP, IPADDRESSLENGTH);
        strcpy(ResponseIP, inet_ntoa(sockname.sin_addr));
        DbgPrint("xbttcp: Received ICMP message from %s:\n", ResponseIP);

        if (rcvlen < IPHDRLEN || (iphdrlen = GETIPHDRLEN(iphdr)) == 0 || iphdrlen > rcvlen || (iplen = GETIPLEN(iphdr)) > rcvlen || iphdrlen > iplen) 
        {
            DbgPrint("xbttcp:  Bad IP header!\n");
        }

        rcvlen = iplen - iphdrlen;
        icmpmsg = (IcmpMessage*) &databuf[iphdrlen];
            
        if (rcvlen < ICMPHDRLEN || tcpipxsum(0, icmpmsg, rcvlen) != 0xffff) 
        {
            DbgPrint("xbttcp:  Bad ICMP header!\n");
        }

        *Offset = iphdrlen;
        CopyMem(mydatabuf, databuf, datalength);
            
        DbgPrint("xbttcp:  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
        DbgPrint("xbttcp:  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
        DbgPrint("xbttcp:  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);
        DbgPrint("xbttcp:  Offset = %d\n", *Offset);

        result = PASS;

   }
   //
   // If we don't receive a ICMP response (IP address is not in use)    
   //
   else
   {
        DbgPrint("xbttcp: Did not receive an ICMP reply from %s:\n", *TESTADDR);
        ZeroMem(ResponseIP, IPADDRESSLENGTH);
        strcpy(ResponseIP, "0.0.0.0");
        DbgPrint("xbttcp: Setting status to FAIL and IP to %s:\n", ResponseIP);

        result = FAIL;

   }


exit:
    closesocket(sock);
    return result;

}



//
//
//
INT xbtMCastPing(CHAR *TESTADDR, UINT *Offset, CHAR *mydatabuf, UINT datalength, CHAR *ResponseIP,  CHAR *mypingmessage, UINT mypingmessagelength)
{

    INT iphdrlen, iplen;
    INT result = FAIL;

    DbgPrint("xbttcp: In xbtMCastPing...\n");

    DbgPrint("xbttcp: mypingmessge = [%s]\n", mypingmessage);
    *Offset = 0;

    // 
    // Create the Socket
    //

    sock = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (sock == INVALID_SOCKET) {
        WARNFAIL(socket); goto exit;
    }


    //
    // Set some values in the socket struct
    // 

    ZeroMem(&sockname, sizeof(sockname));
    sockname.sin_family = AF_INET;
    sockname.sin_port = 0;
    sockname.sin_addr.s_addr = INADDR_ANY;

 
    //
    // Bind the socket
    // 

    err = _bind(sock, &sockname);
    if (err != NO_ERROR) {
        WARNFAIL(bind); goto exit;
    }


    //
    // Set Multicast option
    //
    mcastif.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_MULTICAST_IF, (char*) &mcastif, sizeof(mcastif));
    if (err != NO_ERROR) {
        WARNFAIL(setmcastif); goto exit;
    }

    //
    // Set Multicast option
    //
    mcastreq.imr_multiaddr.s_addr = inet_addr(TESTADDR);
    mcastreq.imr_interface.s_addr = INADDR_ANY;
    err = setsockopt(sock, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(addmember); goto exit;
    }



    // 
    // Fill in ICMP values to be sent out
    //

    icmpmsg = (IcmpMessage*) databuf;
    icmpmsg->type = ICMPTYPE_ECHO_REQUEST;
    icmpmsg->code = 0;
    icmpmsg->id = (WORD) (GetTickCount() >> 16);
    icmpmsg->seqno = (WORD) (GetTickCount() & 0xffff);
    CopyMem(icmpmsg->origdata, mypingmessage, strlen(mypingmessage));
    sockname.sin_addr.s_addr = inet_addr(TESTADDR);


    //
    // Send a PING request (ECHO_REQUEST)
    // 
    DbgPrint("xbttcp: Sending out ICMP echo request...\n");
    DbgPrint("xbttcp:   id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);

    SendIcmpMessage(sock, &sockname, icmpmsg, ICMPHDRLEN + strlen(mypingmessage));


    //
    // Receive any ICMP message (response)
    //

    if (RecvIcmpMessage(sock, &sockname)) 
    {

        IpHeader* iphdr = (IpHeader*) databuf;

        ZeroMem(ResponseIP, IPADDRESSLENGTH);
        strcpy(ResponseIP, inet_ntoa(sockname.sin_addr));
        DbgPrint("xbttcp: Received ICMP message from %s:\n", ResponseIP);

        if (rcvlen < IPHDRLEN || (iphdrlen = GETIPHDRLEN(iphdr)) == 0 || iphdrlen > rcvlen || (iplen = GETIPLEN(iphdr)) > rcvlen || iphdrlen > iplen) 
        {
            DbgPrint("xbttcp:  Bad IP header!\n");
        }

        rcvlen = iplen - iphdrlen;
        icmpmsg = (IcmpMessage*) &databuf[iphdrlen];
            
        if (rcvlen < ICMPHDRLEN || tcpipxsum(0, icmpmsg, rcvlen) != 0xffff) 
        {
            DbgPrint("xbttcp:  Bad ICMP header!\n");
        }

        *Offset = iphdrlen;
        CopyMem(mydatabuf, databuf, datalength);
            
        DbgPrint("xbttcp:  type = %d, code = %d\n", icmpmsg->type, icmpmsg->code);
        DbgPrint("xbttcp:  id = %d, seqno = %d\n", icmpmsg->id, icmpmsg->seqno);
        DbgPrint("xbttcp:  %d bytes of data: %s\n", rcvlen - ICMPHDRLEN, icmpmsg->origdata);
        DbgPrint("xbttcp:  Offset = %d\n", *Offset);

        result = PASS;

    }


    //
    // If a Multicast ping
    //
    err = setsockopt(sock, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char*) &mcastreq, sizeof(mcastreq));
    if (err != NO_ERROR) {
        WARNFAIL(dropmember); goto exit;
    }


exit:
    closesocket(sock);
    return result;




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\lib\sources.inc ===
!IF 0

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sources

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Steven Kehrli (steveke) 13-Mar-2000

Environment:

    XBox

Revision History:

  24-Apr-2000  steveke

      Build for xbox and nt.

  04-Apr-2000  steveke

      Removed xtestlib dependency.

!ENDIF



TARGETTYPE=DYNLINK
TARGETPATH=$(BASEDIR)\private\test\lib

DLLENTRY=DllMain

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

INCLUDES=\
    $(INCLUDES); \
    $(BASEDIR)\private\test\inc; \
    $(BASEDIR)\private\ntos\inc; \
    $(BASEDIR)\private\ntos\ke;  \
    $(BASEDIR)\private\ntos\ex;  \
    ..\;                         \

SOURCES=\
    ..\xlogging.rc \
    ..\dllmain.c   \
    ..\util.c      \
    ..\xlogging.c  \
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\HackAttack.cpp ===
// HackAttack.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "HackAttack.h"
#include "HackAttackDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHackAttackApp

BEGIN_MESSAGE_MAP(CHackAttackApp, CWinApp)
	//{{AFX_MSG_MAP(CHackAttackApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHackAttackApp construction

CHackAttackApp::CHackAttackApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CHackAttackApp object

CHackAttackApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CHackAttackApp initialization

BOOL CHackAttackApp::InitInstance()
{
	if (!AfxSocketInit())
	{
		AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
		return FALSE;
	}

	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CHackAttackDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\lib\xbttcp.h ===
//
// Global variables
//


//
// Export functions in the LIB file
//
INT xbtUCastPing(
    CHAR *TESTADDR,
    UINT *Offset,
    CHAR *mydatabuf,
    UINT datalength,
    CHAR *ResponseIP,
    CHAR *mypingmessage, 
    UINT mypingmessagelength
    );

INT xbtMCastPing(
    CHAR *TESTADDR, 
    UINT *Offset, 
    CHAR *mydatabuf, 
    UINT datalength, 
    CHAR *ResponseIP,  
    CHAR *mypingmessage, 
    UINT mypingmessagelength
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\espattacks.cpp ===
// ESPAttacks.cpp : Contains the Sparta code for various ESP-UDP layer attacks
//

#include "stdafx.h"
#include "AttackConstants.h"

#pragma pack(push, 1) // one byte packing for all wire structures

typedef struct {
    BYTE        bSizeOfStruct;                  // sizeof(XNADDR)
    BYTE        bFlags;                         // XNET_XNADDR_* flags below
    BYTE        abEnet[6];                      // Ethernet MAC address of the host
    IN_ADDR     ina;                            // IP address of the host
} XNADDR;

typedef struct {
    BYTE        ab[8];                          // key identifier
} XNKID;

typedef struct CKeyExMsg
{
    DWORD           _dwSpiZero;         // Must be zero
    DWORD           _dwSpiInit;         // SPI of the initiator
    DWORD           _dwSpiResp;         // SPI of the responder
    BYTE            _abNonceInit[8];    // Nonce of the initiator
    BYTE            _abNonceResp[8];    // Nonce of the responder
    BYTE            _abDhGX[CBDHLEN];   // diffie-hellman g^X (or g^Y)
    XNKID           _xnkid;             // key identifier
    XNADDR          _xnaddr;            // XNADDR of the sender of this message
    LARGE_INTEGER   _liTime;            // increasing time-value of the sender
    BYTE            _abHash[12];        // HMAC-SHA-1-96 digest of CKeyExMsg
} XLKX_KEYEXMSG, *PXLKX_KEYEXMSG;

typedef struct CEspHead
{
	DWORD			dwSpi;
	DWORD			dwSeqNum;
} XESP_HEAD, *PXESP_HEAD;

typedef struct CEspTail
{
	BYTE			bPadLen;
	BYTE			bNextHeader;
	BYTE			abAuthData[12];
} XESP_TAIL, *PXESP_TAIL;

typedef struct CUdpHead
{
	WORD			wSourcePort;
	WORD			wDestPort;
	WORD			wLength;
	WORD			wChecksum;
} UDP_HEAD, *PUDP_HEAD;

#pragma pack(pop)

//==================================================================================
// SendEncryptedESPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends an encrypted ESP-UDP packet with the specified parameters
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendEncryptedESPPacket(CInterface *pInterface, CHAR *szDestMac, DWORD dwSpi, DWORD dwSeqNum, DWORD dwEncapsulatedLen)
{
	CUDPPacket *pUDPPacket = NULL;
	CHAR szFormattedDestMac[18];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	if(!szDestMac || (strlen(szDestMac) < 12))
		return FALSE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Ethernet fields
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);

		// IP fields
		pUDPPacket->IPHeader.SetVersion(4);
		pUDPPacket->IPHeader.SetTOS(0);
		pUDPPacket->IPHeader.SetID(1);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(64);
		pUDPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
	
		// UDP fields
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);

		if(dwEncapsulatedLen)
		{
			PXESP_HEAD pEspHeader = NULL;

			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, dwEncapsulatedLen);
			pEspHeader = (PXESP_HEAD) pBuffer;

			// If the supplied buffer is large enough for the ESP header
			if(dwEncapsulatedLen >= sizeof(XESP_HEAD))
			{
				pEspHeader->dwSpi = dwSpi;
				pEspHeader->dwSeqNum = dwSeqNum;

				memset(pBuffer + sizeof(XESP_HEAD), 'x', dwEncapsulatedLen - sizeof(XESP_HEAD));
			}			

			// Associate that buffer with the packet
			pUDPPacket->SetUserBuffer(pBuffer, dwEncapsulatedLen, TRUE);
		}
		
		pInterface->Send(pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	delete pUDPPacket;

	// Release the payload buffer
	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// SendAuthenticatedESPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends an authenticated ESP-UDP packet with the specified parameters
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendAuthenticatedESPPacket(CInterface *pInterface, CHAR *szDestMac, DWORD dwSpi, DWORD dwSeqNum, BYTE bPadLen, BYTE bNextHeader, DWORD dwEncapsulatedLen)
{
	CUDPPacket *pUDPPacket = NULL;
	CHAR szFormattedDestMac[18];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	if(!szDestMac || (strlen(szDestMac) < 12))
		return FALSE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Ethernet fields
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);

		// IP fields
		pUDPPacket->IPHeader.SetVersion(4);
		pUDPPacket->IPHeader.SetTOS(0);
		pUDPPacket->IPHeader.SetID(1);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(64);
		pUDPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
	
		// UDP fields
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);

		if(dwEncapsulatedLen)
		{
			PXESP_HEAD pEspHeader = NULL;
			PXESP_TAIL pEspTail = NULL;

			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, dwEncapsulatedLen);
			pEspHeader = (PXESP_HEAD) pBuffer;


			if(dwEncapsulatedLen < sizeof(XESP_HEAD))
			{
				memset(pBuffer + sizeof(XESP_HEAD), 'x', dwEncapsulatedLen);
			}
			else
			{
				// If the supplied buffer is large enough for the ESP header
				pEspHeader->dwSpi = dwSpi;
				pEspHeader->dwSeqNum = dwSeqNum;

				if(dwEncapsulatedLen < (sizeof(XESP_HEAD) + sizeof(XESP_TAIL)))
				{
					memset(pBuffer + sizeof(XESP_HEAD), 'x', dwEncapsulatedLen - sizeof(XESP_HEAD));
				}
				else
				{
					pEspTail = (PXESP_TAIL) (pBuffer + dwEncapsulatedLen - sizeof(XESP_TAIL));
					pEspTail->bPadLen = bPadLen;
					pEspTail->bNextHeader = bNextHeader;
					memset(pEspTail->abAuthData, 'z', sizeof(pEspTail->abAuthData));
					memset(pBuffer + sizeof(XESP_HEAD), 'x', dwEncapsulatedLen - sizeof(XESP_HEAD) - sizeof(XESP_TAIL));
				}

			}

			// Associate that buffer with the packet
			pUDPPacket->SetUserBuffer(pBuffer, dwEncapsulatedLen, TRUE);
		}
		
		pInterface->Send(pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	delete pUDPPacket;

	// Release the payload buffer
	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// ESPMaxTitleEncryptAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and maximum size to the Xbox via a broadcast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMaxTitleEncryptAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, "FFFFFFFFFFFF", 0xFFFFFFFF, 0xFFFFFFFF, 1500 - IPHEADER_SIZE - UDPHEADER_SIZE);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMinTitleEncryptAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and minimum size to the Xbox via a broadcast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMinTitleEncryptAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, "FFFFFFFFFFFF", 0xFFFFFFFF, 0xFFFFFFFF, sizeof(XESP_HEAD));
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMaxTitleEncryptUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and maximum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMaxTitleEncryptUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0xFFFFFFFF, 0xFFFFFFFF, 1500 - IPHEADER_SIZE - UDPHEADER_SIZE);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMinTitleEncryptUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and minimum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMinTitleEncryptUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0xFFFFFFFF, 0xFFFFFFFF, sizeof(XESP_HEAD));
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPOneAboveTitleEncryptBroadcastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and a size that is one larger than normal to the Xbox via a broadcast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPOneAboveTitleEncryptBroadcastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, "FFFFFFFFFFFF", 0xFFFFFFFF, 0xFFFFFFFF, TITLEENCRYPT_SIZE + 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPOneBelowTitleEncryptBroadcastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI/SeqNum of 0xFFFFFFFF
//   and a size that is one smaller than normal to the Xbox via a broadcast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPOneBelowTitleEncryptBroadcastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, "FFFFFFFFFFFF", 0xFFFFFFFF, 0xFFFFFFFF, TITLEENCRYPT_SIZE - 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMaxLanExchangeUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI of 0x00000000
//   and maximum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMaxLanExchangeUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0x00000000, 0x00112200, 1500 - IPHEADER_SIZE - UDPHEADER_SIZE);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMinLanExchangeUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI of 0x00000000
//   and minimum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMinLanExchangeUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0x00000000, 0x00112200, sizeof(XESP_HEAD));
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPOneAboveLanExchangeUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI of 0x00000000
//   and a size that is one larger than normal to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPOneAboveLanExchangeUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0x00000000, 0x00112200, LANEXCHANGE_SIZE + 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPOneBelowLanExchangeUnicastAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with SPI of 0x00000000
//   and a size that is one smaller than normal to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPOneBelowLanExchangeUnicastAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0x00000000, 0x00112200, LANEXCHANGE_SIZE - 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPLargePadLenAuthAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with an authenticated SPI
//   and a maximum pad length
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPLargePadLenAuthAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendAuthenticatedESPPacket(pInterface, szDestMac, 0x00112200, 0x00112200, 255, UDP_PROTOCOL_VALUE,
			sizeof(XESP_HEAD) + sizeof(XESP_TAIL) + 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPUnknownProtocolAuthAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with an authenticated SPI
//   and a next header field containing an unknown protocol
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPUnknownProtocolAuthAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendAuthenticatedESPPacket(pInterface, szDestMac, 0x00112200, 0x00112200, 0, UNKNOWN_PROTOCOL_VALUE,
			sizeof(XESP_HEAD) + sizeof(XESP_TAIL) + 1);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMaxAuthAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with an authenticated SPI
//   and maximum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMaxAuthAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendAuthenticatedESPPacket(pInterface, szDestMac, 0x00112200, 0x00112200, 0, UDP_PROTOCOL_VALUE,
			1500 - IPHEADER_SIZE - UDPHEADER_SIZE);
		if(!fRet)
			break;
	}

	return fRet;
}

//==================================================================================
// ESPMaxEncryptAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends an ESP-UDP packet with an encrypted SPI
//   and maximum size to the Xbox via a unicast
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ESPMaxEncryptAttack (CInterface *pInterface, CHAR *szDestMac)
{
	BOOL fRet = FALSE;

	for(INT i = 0; i < ESP_ITERATIONS; ++i)
	{
		fRet = SendEncryptedESPPacket(pInterface, szDestMac, 0x00112201, 0x00112200, 1500 - IPHEADER_SIZE - UDPHEADER_SIZE);
		if(!fRet)
			break;
	}

	return fRet;
}


PATTACK_FUNCTION g_ESPAttackFunctions[ESPATTACK_MAXTEST] = 
{
	ESPMaxTitleEncryptAttack,
	ESPMinTitleEncryptAttack,
	ESPMaxTitleEncryptUnicastAttack,
	ESPMinTitleEncryptUnicastAttack,
	ESPOneAboveTitleEncryptBroadcastAttack,
	ESPOneBelowTitleEncryptBroadcastAttack,
	ESPMaxLanExchangeUnicastAttack,
	ESPMinLanExchangeUnicastAttack,
	ESPOneAboveLanExchangeUnicastAttack,
	ESPOneBelowLanExchangeUnicastAttack,
	ESPLargePadLenAuthAttack,
	ESPUnknownProtocolAuthAttack,
	ESPMaxAuthAttack,
	ESPMaxEncryptAttack
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\AttackConstants.h ===
// AttackConstants.h : header file containing constants for SPARTA net attack cases
//

#ifndef _ATTACKCONSTANTS_H_
#define _ATTACKCONSTANTS_H_

typedef BOOL (*PATTACK_FUNCTION) (CInterface *pInterface, CHAR *szDestMac);

// ----------------------------------------
// ESP attack constants
// ----------------------------------------
#define ESPATTACK_MAXTEST 14

#define LANEXCHANGE_SIZE 164
#define TITLEENCRYPT_SIZE 740
#define TCP_PROTOCOL_VALUE 6
#define UDP_PROTOCOL_VALUE 17
#define UNKNOWN_PROTOCOL_VALUE 255
#define CBDHLEN 96
#define ESP_ITERATIONS 100

// ----------------------------------------
// TCP attack constants
// ----------------------------------------
#define TCPATTACK_MAXTEST 4

#define MSS_DEFAULT 1418
#define TCPHEADER_SIZE 20
#define TCPPORT_DEST 3074
#define TCPPORT_SOURCE 3074

// ----------------------------------------
// UDP attack constants
// ----------------------------------------
#define UDPATTACK_MAXTEST 14

#define PROTOCOL_UDP 17
#define UDPHEADER_SIZE 8
#define UDPPORT_DEST 3074
#define UDPPORT_SOURCE 3074

// ----------------------------------------
// IP attack constants
// ----------------------------------------
#define IPATTACK_MAXTEST 55

#define IPADDR_DEST "0.0.0.1"
#define IPADDR_SOURCE "0.0.0.1"
#define IPADDR_LOOPBACK "127.0.0.1"
#define	IPHEADER_SIZE		20
#define IPVERSION_SIX 6
#define IPVERSION_BAD 15
#define IPVERSION_DEFAULT 4
#define IPHEADER_DEFAULT 20
#define IPHEADER_BELOWMIN 4
#define IPHEADER_MAX 60
#define IPTOS_NORMAL 0
#define IPTOS_NETCONTROL 224
#define IPTOS_LOWDELAY 16
#define IPTOS_HIGHTHRUPUT 8
#define IPTOS_HIGHRELI 4
#define IPTOS_RESERVED 1
#define IPTOS_DEFAULT IPTOS_NORMAL
#define IPLENGTH_DEFAULT UDPHEADER_SIZE + 1
#define IPLENGTH_BELOWMIN 10
#define IPLENGTH_ATMIN 20
#define IPLENGTH_MAX 1500
#define IPID_MIN 0
#define IPID_MAX MAXWORD
#define IPID_DEFAULT 100
#define IPFLAG_RESERVED 4
#define IPFLAG_DONTFRAG 2
#define IPFLAG_MOREFRAGS 1
#define IPTTL_MIN 0
#define IPTTL_MAX 255
#define IPTTL_DEFAULT 64
#define IPPROTOCOL_UNSUPPORTED 255
#define IPPROTOCOL_ICMP 1
#define IPPROTOCOL_IGMP 2
#define IPPROTOCOL_TCP 6
#define IPPROTOCOL_UDP 17
#define OVERSIZED_FRAG_COUNT 99
#define DEFAULT_FRAG_COUNT 4
#define TEARDROP_SIZE 28
#define TEARDROP_XVALUE 3
#define NEWTEAR_SIZE 20
#define NEWTEAR_XVALUE 3
#define SYNDROP_SIZE 20
#define SYNDROP_XVALUE 3
#define BONK_SIZE 20
#define BONK_XVALUE 3
#define SIM_REASM_MAX 4
#define MAX_SIMUL_PORT_OFFSET 5
#define ABOVE_MAX_SIMUL_PORT_OFFSET 5

#endif // _ATTACKCONSTANTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\HackAttackDlg.h ===
// HackAttackDlg.h : header file
//

#if !defined(AFX_HACKATTACKDLG_H__920B2895_8B2D_4520_BA76_956AF5AC17E0__INCLUDED_)
#define AFX_HACKATTACKDLG_H__920B2895_8B2D_4520_BA76_956AF5AC17E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000




/////////////////////////////////////////////////////////////////////////////
// CHackAttackDlg dialog

class CHackAttackDlg : public CDialog
{
friend DWORD WINAPI SpartaThread(LPVOID lpParameter);

// Construction
public:
	CHackAttackDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CHackAttackDlg)
	enum { IDD = IDD_HACKATTACK_DIALOG };
	CButton	m_checkESP;
	CButton	m_checkUDP;
	CButton	m_checkTCP;
	CButton	m_checkIP;
	CButton	m_buttonStart;
	BOOL	m_fTCP;
	BOOL	m_fIP;
	BOOL	m_fUDP;
	CString	m_stringResults;
	CString	m_stringMacAddress;
	BOOL	m_fESP;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHackAttackDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	TCHAR m_szMacAddress[13];
	BOOL m_fAttackRunning;
	CInterface * m_pInterface;
	CInterfaceList * m_pInterfaceList;
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CHackAttackDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnClose();
	afx_msg void OnStart();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HACKATTACKDLG_H__920B2895_8B2D_4520_BA76_956AF5AC17E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\HackAttack.h ===
// HackAttack.h : main header file for the HACKATTACK application
//

#if !defined(AFX_HACKATTACK_H__1A56E991_69C7_406A_89F0_6B71257424E2__INCLUDED_)
#define AFX_HACKATTACK_H__1A56E991_69C7_406A_89F0_6B71257424E2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CHackAttackApp:
// See HackAttack.cpp for the implementation of this class
//

class CHackAttackApp : public CWinApp
{
public:
	CHackAttackApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHackAttackApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CHackAttackApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_HACKATTACK_H__1A56E991_69C7_406A_89F0_6B71257424E2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\HackAttackDlg.cpp ===
// HackAttackDlg.cpp : implementation file
//

#include "stdafx.h"
#include "HackAttack.h"
#include "HackAttackDlg.h"
#include "AttackConstants.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern PATTACK_FUNCTION g_IPAttackFunctions[];
extern PATTACK_FUNCTION g_TCPAttackFunctions[];
extern PATTACK_FUNCTION g_UDPAttackFunctions[];
extern PATTACK_FUNCTION g_ESPAttackFunctions[];

#define MAX_MAC_LEN 12

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHackAttackDlg dialog

CHackAttackDlg::CHackAttackDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHackAttackDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CHackAttackDlg)
	m_fTCP = FALSE;
	m_fIP = FALSE;
	m_fUDP = FALSE;
	m_stringResults = _T("");
	m_stringMacAddress = _T("");
	m_fESP = FALSE;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CHackAttackDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHackAttackDlg)
	DDX_Control(pDX, IDC_ESP, m_checkESP);
	DDX_Control(pDX, IDC_CHECKUDP, m_checkUDP);
	DDX_Control(pDX, IDC_CHECKTCP, m_checkTCP);
	DDX_Control(pDX, IDC_CHECKIP, m_checkIP);
	DDX_Control(pDX, IDC_START, m_buttonStart);
	DDX_Check(pDX, IDC_CHECKTCP, m_fTCP);
	DDX_Check(pDX, IDC_CHECKIP, m_fIP);
	DDX_Check(pDX, IDC_CHECKUDP, m_fUDP);
	DDX_Text(pDX, IDC_RESULTS, m_stringResults);
	DDX_Text(pDX, IDC_MACADDRESS, m_stringMacAddress);
	DDV_MaxChars(pDX, m_stringMacAddress, 12);
	DDX_Check(pDX, IDC_ESP, m_fESP);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CHackAttackDlg, CDialog)
	//{{AFX_MSG_MAP(CHackAttackDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_START, OnStart)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHackAttackDlg message handlers

BOOL CHackAttackDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	m_pInterfaceList = NULL;
	m_pInterfaceList = new CInterfaceList;
	if(!m_pInterfaceList)
	{
		MessageBox("Couldn't create interface list!", "SPARTA Error", MB_ICONERROR | MB_OK);
		return TRUE;
	}

	m_pInterface = NULL;
	m_pInterface = new CInterface(m_pInterfaceList->GetNameAt(0));
	if(!m_pInterface)
	{
		MessageBox("Couldn't create interface!", "SPARTA Error", MB_ICONERROR | MB_OK);
		return TRUE;
	}

	m_fAttackRunning = FALSE;

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CHackAttackDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CHackAttackDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CHackAttackDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CHackAttackDlg::OnClose() 
{
	m_pInterfaceList ? delete m_pInterfaceList : 0;
	m_pInterface ? delete m_pInterface : 0;
	
	m_pInterfaceList = NULL;
	m_pInterface = NULL;

	CDialog::OnClose();
}

void CHackAttackDlg::OnStart() 
{
	UpdateData(TRUE);

	if(!m_fAttackRunning)
	{
		m_buttonStart.EnableWindow(FALSE);
		m_checkTCP.EnableWindow(FALSE);
		m_checkIP.EnableWindow(FALSE);
		m_checkUDP.EnableWindow(FALSE);
		m_checkESP.EnableWindow(FALSE);

		CreateThread(NULL, 0, SpartaThread, this, 0, NULL);

		m_fAttackRunning = TRUE;
	}	
}


DWORD WINAPI SpartaThread(LPVOID lpParameter)
{
	CHackAttackDlg *pMainDialog = (CHackAttackDlg *) lpParameter;
	CHAR szMacAddress[MAX_MAC_LEN + 1];
	DWORD dwAttackCounter = 0;
	DWORD nMacAddressLen = 0;

	szMacAddress[0] = 0;
	
#ifdef UNICODE
	LPWSTR szTempMacAddress = NULL;
	
	nMacAddressLen = wcslen(szTempMacAddress = pMainDialog->m_stringMacAddress.GetBuffer(0));
	if(nMacAddressLen == MAX_MAC_LEN)
		wcstombs(szMacAddress, szTempMacAddress, MAX_MAC_LEN);
	else
		goto Exit;
#else
	LPSTR szTempMacAddress = NULL;
	
	nMacAddressLen = strlen(szTempMacAddress = pMainDialog->m_stringMacAddress.GetBuffer(0));
	if(nMacAddressLen == MAX_MAC_LEN)
		strncpy(szMacAddress, szTempMacAddress, MAX_MAC_LEN);
	else
		goto Exit;
#endif

	szMacAddress[MAX_MAC_LEN] = 0;

	if(pMainDialog->m_fTCP)
	{
		for(dwAttackCounter = 0; dwAttackCounter < TCPATTACK_MAXTEST; ++dwAttackCounter)
		{
			g_TCPAttackFunctions[dwAttackCounter](pMainDialog->m_pInterface, szMacAddress);
		}
	}
	
	if(pMainDialog->m_fUDP)
	{
		for(dwAttackCounter = 0; dwAttackCounter < UDPATTACK_MAXTEST; ++dwAttackCounter)
		{
			g_UDPAttackFunctions[dwAttackCounter](pMainDialog->m_pInterface, szMacAddress);
		}
	}
	
	if(pMainDialog->m_fIP)
	{
		for(dwAttackCounter = 0; dwAttackCounter < IPATTACK_MAXTEST; ++dwAttackCounter)
		{
			g_IPAttackFunctions[dwAttackCounter](pMainDialog->m_pInterface, szMacAddress);
		}
	}

	if(pMainDialog->m_fESP)
	{
		for(dwAttackCounter = 0; dwAttackCounter < ESPATTACK_MAXTEST; ++dwAttackCounter)
		{
			g_ESPAttackFunctions[dwAttackCounter](pMainDialog->m_pInterface, szMacAddress);
		}
	}

Exit:

	pMainDialog->m_fAttackRunning = FALSE;

	pMainDialog->m_buttonStart.EnableWindow(TRUE);
	pMainDialog->m_checkTCP.EnableWindow(TRUE);
	pMainDialog->m_checkIP.EnableWindow(TRUE);
	pMainDialog->m_checkUDP.EnableWindow(TRUE);
	pMainDialog->m_checkESP.EnableWindow(TRUE);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\IPAttacks.cpp ===
// IPAttacks.cpp : Contains the Sparta code for various IP layer attacks
//

#include "stdafx.h"
#include "AttackConstants.h"

//==================================================================================
// SendIPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends an IP packet with the specified parameters
//
// Arguments:
//	
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendIPPacket(CInterface *pInterface, CHAR *szDestMac, CHAR *szDestIP, CHAR *szSourceIP, BYTE bVersion, BYTE bHeaderLength, BYTE bTypeOfService, WORD bTotalLength, WORD bID, BYTE bFlags, WORD wFragOffset, BYTE bTimeToLive, BYTE bProtocol, DWORD dwPayloadSize, BOOL fCalcChecksum, BOOL fPadHdr)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		((bProtocol == PROTOCOL_UDP) && (dwPayloadSize >= UDPHEADER_SIZE)) ? pIPPacket = new CUDPPacket(MediaType) : pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(bVersion);
		pIPPacket->IPHeader.SetTOS(bTypeOfService);
		pIPPacket->IPHeader.SetID(bID);
		pIPPacket->IPHeader.SetFlag(bFlags);
		pIPPacket->IPHeader.SetFragOffset(wFragOffset);
		pIPPacket->IPHeader.SetTTL(bTimeToLive);
		pIPPacket->IPHeader.SetProtocolType(bProtocol);
		pIPPacket->IPHeader.SetDestAddr(szDestIP);
		pIPPacket->IPHeader.SetSrcAddr(szSourceIP);
		
		// Set up the total length field
		if(bTotalLength)
		{
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(bTotalLength);
		}
		else
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
		
		// Set up the header length field
		if(bHeaderLength)
		{
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
			pIPPacket->IPHeader.SetHdrLength(bHeaderLength);

			// If the header is bigger than the default, fill it with no-ops
			if((bHeaderLength > IPHEADER_SIZE) && fPadHdr)
			{
				// For each additional double-word in the header beyond the default, add 4 no-opts (1 byte each)
				for(INT DoubleWordIndex = 0; DoubleWordIndex < bHeaderLength - IPHEADER_SIZE ;  DoubleWordIndex++)
				{
					pIPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
				}
			}
		}
		else
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		
		// Set up the IP header checksum
		if(fCalcChecksum)
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		else
		{
			pIPPacket->IPHeader.SetAutoCalcChecksum(OFF);
			pIPPacket->IPHeader.SetChecksum(0xFFFF);	// Not guaranteed to fail, but close enough
		}
		
		// Set up the UDP fields if necessary
		if((bProtocol == PROTOCOL_UDP)  && (dwPayloadSize >= UDPHEADER_SIZE))
		{
			WORD HeaderSize = bHeaderLength ? bHeaderLength * 4 : IPHEADER_SIZE;

			CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
			
			pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
			pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);

			// Hard to explain this one...  Basically, for tests where we are overriding the total length
			// field of the IP datagram, and that overridden value is less than the actual amount of data in
			// the packet (including its payload)...  Then we also want to override the length field in the
			// UDP header so that the generated UDP packet is still valid
			if((bTotalLength >= UDPHEADER_SIZE + IPHEADER_SIZE) && (bTotalLength < dwPayloadSize + IPHEADER_SIZE))
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(bTotalLength - IPHEADER_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);
			}
			
			// If we are to send data beyond the header, set up the data buffer
			if(dwPayloadSize > UDPHEADER_SIZE)
			{
				// Create the buffer for the remaining packet data
				pBuffer = (CHAR *) LocalAlloc(LPTR, dwPayloadSize - UDPHEADER_SIZE);
				memset(pBuffer, (int) 'x', dwPayloadSize - UDPHEADER_SIZE);
				
				// Associate that buffer with the packet
				pUDPPacket->SetUserBuffer(pBuffer, dwPayloadSize - UDPHEADER_SIZE, TRUE);				
			}
		}
		else if(dwPayloadSize > 0)
		{
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, dwPayloadSize);
			memset(pBuffer, (int) 'x', dwPayloadSize);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, dwPayloadSize, TRUE);								
		}
		
		pInterface->Send(*pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pIPPacket ? delete pIPPacket : 0;
	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// IPVersionSixAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating version 6
//
// Arguments:
//	DWORD		FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionSixAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_SIX, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPVersionBadAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating an unknown version (16)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionBadAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_BAD, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPHeaderLenBelowMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length below the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenBelowMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, IPHEADER_BELOWMIN, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPHeaderLenMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a maximum header length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenMaxAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, IPHEADER_MAX, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPHeaderLenAboveTotalLenAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length larger than the total length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveTotalLenAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, IPHEADER_MAX, IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPHeaderLenAboveAvailAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length larger than the bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveAvailAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, IPHEADER_MAX, IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, FALSE);
}

//==================================================================================
// IPTosNormalAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a normal type-of-Attackice
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNormalAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTosNetControlAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a net-control type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNetControlAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_NETCONTROL, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTosLowDelayAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a low-delay type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosLowDelayAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_LOWDELAY, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTosHighThroughputAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a high-throughput type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighThroughputAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_HIGHTHRUPUT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTosHighReliabilityAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a high-reliability type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighReliabilityAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_HIGHRELI, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTosReservedAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a reserved type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosReservedAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_RESERVED, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPLengthBelowMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a total length below the minimum possible
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		IPLENGTH_BELOWMIN, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, 0, 0, TRUE, TRUE);
}

//==================================================================================
// IPLengthAtMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a minimum valid total length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAtMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		IPLENGTH_ATMIN, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, 0, 0, TRUE, TRUE);
}

//==================================================================================
// IPLengthAboveMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length above the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPLengthAboveTotalAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length greater than the number of bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveTotalAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 2, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPLengthBelowTotalAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length less than the number of bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowTotalAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 2, TRUE, TRUE);
}

//==================================================================================
// IPLengthMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the maximum single datagram size
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthMaxAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		IPLENGTH_MAX, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, IPLENGTH_MAX - IPHEADER_SIZE, TRUE, TRUE);
}

//==================================================================================
// IPIDMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the minimum datagram ID
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_MIN, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPIDMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the maximum datagram ID
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMaxAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_MAX, 0, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPFlagReservedSetAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the reserved bit of the flags field set
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagReservedSetAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, IPFLAG_RESERVED, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPFlagDontFragAndMoreFragsAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram both  don't-frag and more-frags flag set
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagDontFragAndMoreFragsAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, IPFLAG_DONTFRAG | IPFLAG_MOREFRAGS, 0, IPTTL_DEFAULT, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTtlMinAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with minimum time-to-live
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_MIN, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPTtlMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with maximum time-to-live
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMaxAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_MAX, PROTOCOL_UDP, UDPHEADER_SIZE + 1, TRUE, TRUE);
}

//==================================================================================
// IPProtocolUnsupportedAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram of an unsupported protocol
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_UNSUPPORTED, 1, TRUE, TRUE);
}

//==================================================================================
// IPProtocolICMPTooSmallAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends ICMP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolICMPTooSmallAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_ICMP, 0, TRUE, TRUE);
}

//==================================================================================
// IPProtocolIGMPTooSmallAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends IGMP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolIGMPTooSmallAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_IGMP, 0, TRUE, TRUE);
}

//==================================================================================
// IPProtocolTCPTooSmallAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends TCP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolTCPTooSmallAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_TCP, 0, TRUE, TRUE);
}

//==================================================================================
// IPProtocolUDPTooSmallAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends UDP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUDPTooSmallAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_UDP, 0, TRUE, TRUE);
}

//==================================================================================
// IPProtocolUnsupportedTooSmallAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram of unsupported protocol with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedTooSmallAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_UNSUPPORTED, 0, TRUE, TRUE);
}

//==================================================================================
// IPChecksumBadAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a bad checksum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPChecksumBadAttack(CInterface *pInterface, CHAR *szDestMac)
{
	return SendIPPacket(pInterface, szDestMac, IPADDR_DEST, IPADDR_SOURCE, IPVERSION_DEFAULT, 0, IPTOS_DEFAULT, 
		0, IPID_DEFAULT, 0, 0, IPTTL_DEFAULT, IPPROTOCOL_UDP, UDPHEADER_SIZE + 1, FALSE, TRUE);
}

//==================================================================================
// IPOptionsAboveAvailAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with an option that is cutoff by the end of the datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsAboveAvailAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CIPOption *pIPOption = NULL;
	CHAR szFormattedDestMac[18];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pIPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pIPPacket->IPHeader.SetID(IPID_DEFAULT);
		pIPPacket->IPHeader.SetFlag(0);
		pIPPacket->IPHeader.SetFragOffset(0);
		pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pIPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		
		pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pIPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 4);

		pIPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pIPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 4);

		pIPOption = pIPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(sizeof(DWORD));
		pIPOption->SetOptionLength(11);
		pIPOption->SetOptionOffset(8);

		pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pInterface->Send(*pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pIPPacket ? delete pIPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsExactSizeAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a variable-length option reaching the exact end of the header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsExactSizeAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	CHAR szFormattedDestMac[18], PayloadData[1];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, IPADDR_SOURCE);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);

		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsEndOfOpsLastAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a variable-length option followed by an end-of-options
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsLastAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	CHAR szFormattedDestMac[18], PayloadData[1];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, IPADDR_SOURCE);
		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_END_OF_OPTIONLIST);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);
		
		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsEndOfOpsFirstAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with an end-of-options followed by a variable-length option
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsFirstAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	CHAR szFormattedDestMac[18], PayloadData[1];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_END_OF_OPTIONLIST);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, IPADDR_SOURCE);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);
		
		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPFragFullReverseAttack
//----------------------------------------------------------