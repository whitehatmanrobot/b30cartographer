  /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMText __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMText __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *splitText )( 
            IXMLDOMText __RPC_FAR * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMTextVtbl;

    interface IXMLDOMText
    {
        CONST_VTBL struct IXMLDOMTextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMText_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMText_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMText_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMText_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMText_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMText_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMText_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMText_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMText_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMText_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMText_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMText_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMText_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMText_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMText_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMText_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMText_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMText_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMText_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMText_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMText_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMText_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMText_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMText_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMText_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMText_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMText_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMText_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMText_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMText_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMText_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMText_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMText_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMText_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMText_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMText_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMText_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMText_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMText_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMText_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMText_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMText_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMText_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMText_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMText_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMText_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMText_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMText_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMText_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMText_splitText_Proxy( 
    IXMLDOMText __RPC_FAR * This,
    /* [in] */ long offset,
    /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);


void __RPC_STUB IXMLDOMText_splitText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMText_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMComment_INTERFACE_DEFINED__
#define __IXMLDOMComment_INTERFACE_DEFINED__

/* interface IXMLDOMComment */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMComment;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF88-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMComment : public IXMLDOMCharacterData
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCommentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMComment __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMComment __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMComment __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        END_INTERFACE
    } IXMLDOMCommentVtbl;

    interface IXMLDOMComment
    {
        CONST_VTBL struct IXMLDOMCommentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMComment_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMComment_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMComment_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMComment_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMComment_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMComment_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMComment_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMComment_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMComment_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMComment_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMComment_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMComment_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMComment_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMComment_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMComment_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMComment_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMComment_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMComment_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMComment_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMComment_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMComment_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMComment_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMComment_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMComment_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMComment_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMComment_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMComment_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMComment_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMComment_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMComment_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMComment_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMComment_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMComment_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMComment_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMComment_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMComment_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMComment_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMComment_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMComment_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMComment_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMComment_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMComment_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMComment_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMComment_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMComment_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMComment_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMComment_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMComment_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMComment_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMComment_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMComment_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__
#define __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__

/* interface IXMLDOMProcessingInstruction */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMProcessingInstruction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF89-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMProcessingInstruction : public IXMLDOMNode
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_target( 
            /* [retval][out] */ BSTR __RPC_FAR *name) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_data( 
            /* [retval][out] */ BSTR __RPC_FAR *value) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_data( 
            /* [in] */ BSTR value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMProcessingInstructionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_target )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMProcessingInstruction __RPC_FAR * This,
            /* [in] */ BSTR value);
        
        END_INTERFACE
    } IXMLDOMProcessingInstructionVtbl;

    interface IXMLDOMProcessingInstruction
    {
        CONST_VTBL struct IXMLDOMProcessingInstructionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMProcessingInstruction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMProcessingInstruction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMProcessingInstruction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMProcessingInstruction_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMProcessingInstruction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMProcessingInstruction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMProcessingInstruction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMProcessingInstruction_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMProcessingInstruction_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMProcessingInstruction_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMProcessingInstruction_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMProcessingInstruction_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMProcessingInstruction_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMProcessingInstruction_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMProcessingInstruction_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMProcessingInstruction_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMProcessingInstruction_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMProcessingInstruction_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMProcessingInstruction_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMProcessingInstruction_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMProcessingInstruction_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMProcessingInstruction_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMProcessingInstruction_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMProcessingInstruction_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMProcessingInstruction_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMProcessingInstruction_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMProcessingInstruction_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMProcessingInstruction_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMProcessingInstruction_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMProcessingInstruction_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMProcessingInstruction_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMProcessingInstruction_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMProcessingInstruction_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMProcessingInstruction_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMProcessingInstruction_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMProcessingInstruction_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMProcessingInstruction_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMProcessingInstruction_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMProcessingInstruction_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMProcessingInstruction_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMProcessingInstruction_get_target(This,name)	\
    (This)->lpVtbl -> get_target(This,name)

#define IXMLDOMProcessingInstruction_get_data(This,value)	\
    (This)->lpVtbl -> get_data(This,value)

#define IXMLDOMProcessingInstruction_put_data(This,value)	\
    (This)->lpVtbl -> put_data(This,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_target_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *name);


void __RPC_STUB IXMLDOMProcessingInstruction_get_target_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_get_data_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *value);


void __RPC_STUB IXMLDOMProcessingInstruction_get_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMProcessingInstruction_put_data_Proxy( 
    IXMLDOMProcessingInstruction __RPC_FAR * This,
    /* [in] */ BSTR value);


void __RPC_STUB IXMLDOMProcessingInstruction_put_data_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMProcessingInstruction_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMCDATASection_INTERFACE_DEFINED__
#define __IXMLDOMCDATASection_INTERFACE_DEFINED__

/* interface IXMLDOMCDATASection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMCDATASection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8A-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMCDATASection : public IXMLDOMText
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMCDATASectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMCDATASection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMCDATASection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_data )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_data )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *dataLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *substringData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [retval][out] */ BSTR __RPC_FAR *data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *deleteData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceData )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [in] */ long count,
            /* [in] */ BSTR data);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *splitText )( 
            IXMLDOMCDATASection __RPC_FAR * This,
            /* [in] */ long offset,
            /* [retval][out] */ IXMLDOMText __RPC_FAR *__RPC_FAR *rightHandTextNode);
        
        END_INTERFACE
    } IXMLDOMCDATASectionVtbl;

    interface IXMLDOMCDATASection
    {
        CONST_VTBL struct IXMLDOMCDATASectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMCDATASection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMCDATASection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMCDATASection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMCDATASection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMCDATASection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMCDATASection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMCDATASection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMCDATASection_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMCDATASection_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMCDATASection_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMCDATASection_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMCDATASection_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMCDATASection_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMCDATASection_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMCDATASection_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMCDATASection_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMCDATASection_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMCDATASection_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMCDATASection_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMCDATASection_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMCDATASection_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMCDATASection_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMCDATASection_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMCDATASection_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMCDATASection_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMCDATASection_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMCDATASection_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMCDATASection_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMCDATASection_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMCDATASection_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMCDATASection_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMCDATASection_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMCDATASection_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMCDATASection_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMCDATASection_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMCDATASection_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMCDATASection_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMCDATASection_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMCDATASection_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMCDATASection_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMCDATASection_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMCDATASection_get_data(This,data)	\
    (This)->lpVtbl -> get_data(This,data)

#define IXMLDOMCDATASection_put_data(This,data)	\
    (This)->lpVtbl -> put_data(This,data)

#define IXMLDOMCDATASection_get_length(This,dataLength)	\
    (This)->lpVtbl -> get_length(This,dataLength)

#define IXMLDOMCDATASection_substringData(This,offset,count,data)	\
    (This)->lpVtbl -> substringData(This,offset,count,data)

#define IXMLDOMCDATASection_appendData(This,data)	\
    (This)->lpVtbl -> appendData(This,data)

#define IXMLDOMCDATASection_insertData(This,offset,data)	\
    (This)->lpVtbl -> insertData(This,offset,data)

#define IXMLDOMCDATASection_deleteData(This,offset,count)	\
    (This)->lpVtbl -> deleteData(This,offset,count)

#define IXMLDOMCDATASection_replaceData(This,offset,count,data)	\
    (This)->lpVtbl -> replaceData(This,offset,count,data)


#define IXMLDOMCDATASection_splitText(This,offset,rightHandTextNode)	\
    (This)->lpVtbl -> splitText(This,offset,rightHandTextNode)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMCDATASection_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMDocumentType_INTERFACE_DEFINED__
#define __IXMLDOMDocumentType_INTERFACE_DEFINED__

/* interface IXMLDOMDocumentType */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMDocumentType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8B-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMDocumentType : public IXMLDOMNode
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [retval][out] */ BSTR __RPC_FAR *rootName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_entities( 
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_notations( 
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMDocumentTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMDocumentType __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMDocumentType __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *rootName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_entities )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_notations )( 
            IXMLDOMDocumentType __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap);
        
        END_INTERFACE
    } IXMLDOMDocumentTypeVtbl;

    interface IXMLDOMDocumentType
    {
        CONST_VTBL struct IXMLDOMDocumentTypeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMDocumentType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMDocumentType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMDocumentType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMDocumentType_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMDocumentType_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMDocumentType_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMDocumentType_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMDocumentType_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMDocumentType_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMDocumentType_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMDocumentType_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMDocumentType_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMDocumentType_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMDocumentType_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMDocumentType_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMDocumentType_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMDocumentType_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMDocumentType_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMDocumentType_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMDocumentType_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMDocumentType_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMDocumentType_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMDocumentType_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMDocumentType_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMDocumentType_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMDocumentType_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMDocumentType_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMDocumentType_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMDocumentType_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMDocumentType_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMDocumentType_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMDocumentType_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMDocumentType_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMDocumentType_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMDocumentType_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMDocumentType_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMDocumentType_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMDocumentType_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMDocumentType_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMDocumentType_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMDocumentType_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMDocumentType_get_name(This,rootName)	\
    (This)->lpVtbl -> get_name(This,rootName)

#define IXMLDOMDocumentType_get_entities(This,entityMap)	\
    (This)->lpVtbl -> get_entities(This,entityMap)

#define IXMLDOMDocumentType_get_notations(This,notationMap)	\
    (This)->lpVtbl -> get_notations(This,notationMap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_name_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *rootName);


void __RPC_STUB IXMLDOMDocumentType_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_entities_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *entityMap);


void __RPC_STUB IXMLDOMDocumentType_get_entities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMDocumentType_get_notations_Proxy( 
    IXMLDOMDocumentType __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *notationMap);


void __RPC_STUB IXMLDOMDocumentType_get_notations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMDocumentType_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMNotation_INTERFACE_DEFINED__
#define __IXMLDOMNotation_INTERFACE_DEFINED__

/* interface IXMLDOMNotation */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMNotation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8C-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMNotation : public IXMLDOMNode
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT __RPC_FAR *publicID) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT __RPC_FAR *systemID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMNotationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMNotation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMNotation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_publicId )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *publicID);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemId )( 
            IXMLDOMNotation __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *systemID);
        
        END_INTERFACE
    } IXMLDOMNotationVtbl;

    interface IXMLDOMNotation
    {
        CONST_VTBL struct IXMLDOMNotationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMNotation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMNotation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMNotation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMNotation_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMNotation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMNotation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMNotation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMNotation_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMNotation_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMNotation_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMNotation_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMNotation_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMNotation_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMNotation_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMNotation_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMNotation_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMNotation_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMNotation_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMNotation_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMNotation_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMNotation_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMNotation_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMNotation_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMNotation_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMNotation_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMNotation_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMNotation_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMNotation_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMNotation_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMNotation_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMNotation_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMNotation_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMNotation_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMNotation_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMNotation_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMNotation_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMNotation_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMNotation_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMNotation_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMNotation_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMNotation_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMNotation_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMNotation_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMNotation_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_publicId_Proxy( 
    IXMLDOMNotation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *publicID);


void __RPC_STUB IXMLDOMNotation_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMNotation_get_systemId_Proxy( 
    IXMLDOMNotation __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *systemID);


void __RPC_STUB IXMLDOMNotation_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMNotation_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntity_INTERFACE_DEFINED__
#define __IXMLDOMEntity_INTERFACE_DEFINED__

/* interface IXMLDOMEntity */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8D-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntity : public IXMLDOMNode
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ VARIANT __RPC_FAR *publicID) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ VARIANT __RPC_FAR *systemID) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_notationName( 
            /* [retval][out] */ BSTR __RPC_FAR *name) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMEntity __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMEntity __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_publicId )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *publicID);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemId )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *systemID);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_notationName )( 
            IXMLDOMEntity __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        END_INTERFACE
    } IXMLDOMEntityVtbl;

    interface IXMLDOMEntity
    {
        CONST_VTBL struct IXMLDOMEntityVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntity_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntity_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntity_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntity_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntity_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntity_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntity_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntity_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntity_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntity_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntity_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntity_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntity_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntity_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntity_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntity_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntity_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntity_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntity_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntity_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntity_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntity_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntity_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntity_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntity_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntity_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntity_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntity_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntity_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntity_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntity_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntity_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntity_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntity_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntity_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntity_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntity_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntity_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntity_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXMLDOMEntity_get_publicId(This,publicID)	\
    (This)->lpVtbl -> get_publicId(This,publicID)

#define IXMLDOMEntity_get_systemId(This,systemID)	\
    (This)->lpVtbl -> get_systemId(This,systemID)

#define IXMLDOMEntity_get_notationName(This,name)	\
    (This)->lpVtbl -> get_notationName(This,name)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_publicId_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *publicID);


void __RPC_STUB IXMLDOMEntity_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_systemId_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *systemID);


void __RPC_STUB IXMLDOMEntity_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMEntity_get_notationName_Proxy( 
    IXMLDOMEntity __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *name);


void __RPC_STUB IXMLDOMEntity_get_notationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMEntity_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMEntityReference_INTERFACE_DEFINED__
#define __IXMLDOMEntityReference_INTERFACE_DEFINED__

/* interface IXMLDOMEntityReference */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMEntityReference;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF8E-7B36-11d2-B20E-00C04F983E60")
    IXMLDOMEntityReference : public IXMLDOMNode
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMEntityReferenceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMEntityReference __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMEntityReference __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXMLDOMEntityReference __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        END_INTERFACE
    } IXMLDOMEntityReferenceVtbl;

    interface IXMLDOMEntityReference
    {
        CONST_VTBL struct IXMLDOMEntityReferenceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMEntityReference_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMEntityReference_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMEntityReference_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMEntityReference_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMEntityReference_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMEntityReference_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMEntityReference_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMEntityReference_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXMLDOMEntityReference_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXMLDOMEntityReference_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXMLDOMEntityReference_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXMLDOMEntityReference_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXMLDOMEntityReference_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXMLDOMEntityReference_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXMLDOMEntityReference_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXMLDOMEntityReference_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXMLDOMEntityReference_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXMLDOMEntityReference_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXMLDOMEntityReference_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXMLDOMEntityReference_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXMLDOMEntityReference_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXMLDOMEntityReference_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXMLDOMEntityReference_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXMLDOMEntityReference_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXMLDOMEntityReference_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXMLDOMEntityReference_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXMLDOMEntityReference_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXMLDOMEntityReference_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXMLDOMEntityReference_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXMLDOMEntityReference_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXMLDOMEntityReference_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXMLDOMEntityReference_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXMLDOMEntityReference_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXMLDOMEntityReference_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXMLDOMEntityReference_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXMLDOMEntityReference_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXMLDOMEntityReference_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXMLDOMEntityReference_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXMLDOMEntityReference_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXMLDOMEntityReference_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXMLDOMEntityReference_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IXMLDOMEntityReference_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMParseError_INTERFACE_DEFINED__
#define __IXMLDOMParseError_INTERFACE_DEFINED__

/* interface IXMLDOMParseError */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMParseError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa426-272f-11d2-836f-0000f87a7782")
    IXMLDOMParseError : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_errorCode( 
            /* [out][retval] */ long __RPC_FAR *errorCode) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_url( 
            /* [out][retval] */ BSTR __RPC_FAR *urlString) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_reason( 
            /* [out][retval] */ BSTR __RPC_FAR *reasonString) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_srcText( 
            /* [out][retval] */ BSTR __RPC_FAR *sourceString) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_line( 
            /* [out][retval] */ long __RPC_FAR *lineNumber) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_linepos( 
            /* [out][retval] */ long __RPC_FAR *linePosition) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_filepos( 
            /* [out][retval] */ long __RPC_FAR *filePosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMParseErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMParseError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMParseError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorCode )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *errorCode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_url )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *urlString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_reason )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *reasonString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_srcText )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *sourceString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_line )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *lineNumber);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_linepos )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *linePosition);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_filepos )( 
            IXMLDOMParseError __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *filePosition);
        
        END_INTERFACE
    } IXMLDOMParseErrorVtbl;

    interface IXMLDOMParseError
    {
        CONST_VTBL struct IXMLDOMParseErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMParseError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMParseError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMParseError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMParseError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMParseError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMParseError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMParseError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMParseError_get_errorCode(This,errorCode)	\
    (This)->lpVtbl -> get_errorCode(This,errorCode)

#define IXMLDOMParseError_get_url(This,urlString)	\
    (This)->lpVtbl -> get_url(This,urlString)

#define IXMLDOMParseError_get_reason(This,reasonString)	\
    (This)->lpVtbl -> get_reason(This,reasonString)

#define IXMLDOMParseError_get_srcText(This,sourceString)	\
    (This)->lpVtbl -> get_srcText(This,sourceString)

#define IXMLDOMParseError_get_line(This,lineNumber)	\
    (This)->lpVtbl -> get_line(This,lineNumber)

#define IXMLDOMParseError_get_linepos(This,linePosition)	\
    (This)->lpVtbl -> get_linepos(This,linePosition)

#define IXMLDOMParseError_get_filepos(This,filePosition)	\
    (This)->lpVtbl -> get_filepos(This,filePosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_errorCode_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *errorCode);


void __RPC_STUB IXMLDOMParseError_get_errorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_url_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *urlString);


void __RPC_STUB IXMLDOMParseError_get_url_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_reason_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *reasonString);


void __RPC_STUB IXMLDOMParseError_get_reason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_srcText_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *sourceString);


void __RPC_STUB IXMLDOMParseError_get_srcText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_line_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *lineNumber);


void __RPC_STUB IXMLDOMParseError_get_line_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_linepos_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *linePosition);


void __RPC_STUB IXMLDOMParseError_get_linepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMParseError_get_filepos_Proxy( 
    IXMLDOMParseError __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *filePosition);


void __RPC_STUB IXMLDOMParseError_get_filepos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMParseError_INTERFACE_DEFINED__ */


#ifndef __IXTLRuntime_INTERFACE_DEFINED__
#define __IXTLRuntime_INTERFACE_DEFINED__

/* interface IXTLRuntime */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXTLRuntime;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3efaa425-272f-11d2-836f-0000f87a7782")
    IXTLRuntime : public IXMLDOMNode
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE uniqueID( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pID) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE depth( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pDepth) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE childNumber( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ancestorChildNumber( 
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE absoluteChildNumber( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE formatIndex( 
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE formatNumber( 
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE formatDate( 
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE formatTime( 
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXTLRuntimeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXTLRuntime __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXTLRuntime __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeName )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *name);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT value);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ DOMNodeType __RPC_FAR *type);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parentNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *parent);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_childNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *childList);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_firstChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *firstChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lastChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *lastChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_previousSibling )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *previousSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nextSibling )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextSibling);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNamedNodeMap __RPC_FAR *__RPC_FAR *attributeMap);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *insertBefore )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ VARIANT refChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *replaceChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [in] */ IXMLDOMNode __RPC_FAR *oldChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outOldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *childNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *oldChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *appendChild )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *newChild,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *outNewChild);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *hasChildNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *hasChild);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerDocument )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *DOMDocument);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *cloneNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL deep,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *cloneRoot);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypeString )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nodeType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *text);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR text);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_specified )( 
            IXTLRuntime __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSpecified);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_definition )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *definitionNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_nodeTypedValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *typedValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_nodeTypedValue )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT typedValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dataType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT __RPC_FAR *dataTypeName);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_dataType )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR dataTypeName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_xml )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [out][retval] */ BSTR __RPC_FAR *xmlString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectNodes )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNodeList __RPC_FAR *__RPC_FAR *resultList);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *selectSingleNode )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR queryString,
            /* [out][retval] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *resultNode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parsed )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *isParsed);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_namespaceURI )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_prefix )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *prefixString);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseName )( 
            IXTLRuntime __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *nameString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transformNodeToObject )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet,
            /* [in] */ VARIANT outputObject);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *uniqueID )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pID);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *depth )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pDepth);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *childNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ancestorChildNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ BSTR bstrNodeName,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *absoluteChildNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ long __RPC_FAR *pNumber);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatIndex )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ long lIndex,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatNumber )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ double dblNumber,
            /* [in] */ BSTR bstrFormat,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatDate )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT varDate,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *formatTime )( 
            IXTLRuntime __RPC_FAR * This,
            /* [in] */ VARIANT varTime,
            /* [in] */ BSTR bstrFormat,
            /* [optional][in] */ VARIANT varDestLocale,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);
        
        END_INTERFACE
    } IXTLRuntimeVtbl;

    interface IXTLRuntime
    {
        CONST_VTBL struct IXTLRuntimeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXTLRuntime_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXTLRuntime_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXTLRuntime_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXTLRuntime_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXTLRuntime_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXTLRuntime_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXTLRuntime_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXTLRuntime_get_nodeName(This,name)	\
    (This)->lpVtbl -> get_nodeName(This,name)

#define IXTLRuntime_get_nodeValue(This,value)	\
    (This)->lpVtbl -> get_nodeValue(This,value)

#define IXTLRuntime_put_nodeValue(This,value)	\
    (This)->lpVtbl -> put_nodeValue(This,value)

#define IXTLRuntime_get_nodeType(This,type)	\
    (This)->lpVtbl -> get_nodeType(This,type)

#define IXTLRuntime_get_parentNode(This,parent)	\
    (This)->lpVtbl -> get_parentNode(This,parent)

#define IXTLRuntime_get_childNodes(This,childList)	\
    (This)->lpVtbl -> get_childNodes(This,childList)

#define IXTLRuntime_get_firstChild(This,firstChild)	\
    (This)->lpVtbl -> get_firstChild(This,firstChild)

#define IXTLRuntime_get_lastChild(This,lastChild)	\
    (This)->lpVtbl -> get_lastChild(This,lastChild)

#define IXTLRuntime_get_previousSibling(This,previousSibling)	\
    (This)->lpVtbl -> get_previousSibling(This,previousSibling)

#define IXTLRuntime_get_nextSibling(This,nextSibling)	\
    (This)->lpVtbl -> get_nextSibling(This,nextSibling)

#define IXTLRuntime_get_attributes(This,attributeMap)	\
    (This)->lpVtbl -> get_attributes(This,attributeMap)

#define IXTLRuntime_insertBefore(This,newChild,refChild,outNewChild)	\
    (This)->lpVtbl -> insertBefore(This,newChild,refChild,outNewChild)

#define IXTLRuntime_replaceChild(This,newChild,oldChild,outOldChild)	\
    (This)->lpVtbl -> replaceChild(This,newChild,oldChild,outOldChild)

#define IXTLRuntime_removeChild(This,childNode,oldChild)	\
    (This)->lpVtbl -> removeChild(This,childNode,oldChild)

#define IXTLRuntime_appendChild(This,newChild,outNewChild)	\
    (This)->lpVtbl -> appendChild(This,newChild,outNewChild)

#define IXTLRuntime_hasChildNodes(This,hasChild)	\
    (This)->lpVtbl -> hasChildNodes(This,hasChild)

#define IXTLRuntime_get_ownerDocument(This,DOMDocument)	\
    (This)->lpVtbl -> get_ownerDocument(This,DOMDocument)

#define IXTLRuntime_cloneNode(This,deep,cloneRoot)	\
    (This)->lpVtbl -> cloneNode(This,deep,cloneRoot)

#define IXTLRuntime_get_nodeTypeString(This,nodeType)	\
    (This)->lpVtbl -> get_nodeTypeString(This,nodeType)

#define IXTLRuntime_get_text(This,text)	\
    (This)->lpVtbl -> get_text(This,text)

#define IXTLRuntime_put_text(This,text)	\
    (This)->lpVtbl -> put_text(This,text)

#define IXTLRuntime_get_specified(This,isSpecified)	\
    (This)->lpVtbl -> get_specified(This,isSpecified)

#define IXTLRuntime_get_definition(This,definitionNode)	\
    (This)->lpVtbl -> get_definition(This,definitionNode)

#define IXTLRuntime_get_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> get_nodeTypedValue(This,typedValue)

#define IXTLRuntime_put_nodeTypedValue(This,typedValue)	\
    (This)->lpVtbl -> put_nodeTypedValue(This,typedValue)

#define IXTLRuntime_get_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> get_dataType(This,dataTypeName)

#define IXTLRuntime_put_dataType(This,dataTypeName)	\
    (This)->lpVtbl -> put_dataType(This,dataTypeName)

#define IXTLRuntime_get_xml(This,xmlString)	\
    (This)->lpVtbl -> get_xml(This,xmlString)

#define IXTLRuntime_transformNode(This,stylesheet,xmlString)	\
    (This)->lpVtbl -> transformNode(This,stylesheet,xmlString)

#define IXTLRuntime_selectNodes(This,queryString,resultList)	\
    (This)->lpVtbl -> selectNodes(This,queryString,resultList)

#define IXTLRuntime_selectSingleNode(This,queryString,resultNode)	\
    (This)->lpVtbl -> selectSingleNode(This,queryString,resultNode)

#define IXTLRuntime_get_parsed(This,isParsed)	\
    (This)->lpVtbl -> get_parsed(This,isParsed)

#define IXTLRuntime_get_namespaceURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_namespaceURI(This,namespaceURI)

#define IXTLRuntime_get_prefix(This,prefixString)	\
    (This)->lpVtbl -> get_prefix(This,prefixString)

#define IXTLRuntime_get_baseName(This,nameString)	\
    (This)->lpVtbl -> get_baseName(This,nameString)

#define IXTLRuntime_transformNodeToObject(This,stylesheet,outputObject)	\
    (This)->lpVtbl -> transformNodeToObject(This,stylesheet,outputObject)


#define IXTLRuntime_uniqueID(This,pNode,pID)	\
    (This)->lpVtbl -> uniqueID(This,pNode,pID)

#define IXTLRuntime_depth(This,pNode,pDepth)	\
    (This)->lpVtbl -> depth(This,pNode,pDepth)

#define IXTLRuntime_childNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> childNumber(This,pNode,pNumber)

#define IXTLRuntime_ancestorChildNumber(This,bstrNodeName,pNode,pNumber)	\
    (This)->lpVtbl -> ancestorChildNumber(This,bstrNodeName,pNode,pNumber)

#define IXTLRuntime_absoluteChildNumber(This,pNode,pNumber)	\
    (This)->lpVtbl -> absoluteChildNumber(This,pNode,pNumber)

#define IXTLRuntime_formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatIndex(This,lIndex,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)	\
    (This)->lpVtbl -> formatNumber(This,dblNumber,bstrFormat,pbstrFormattedString)

#define IXTLRuntime_formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatDate(This,varDate,bstrFormat,varDestLocale,pbstrFormattedString)

#define IXTLRuntime_formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)	\
    (This)->lpVtbl -> formatTime(This,varTime,bstrFormat,varDestLocale,pbstrFormattedString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_uniqueID_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pID);


void __RPC_STUB IXTLRuntime_uniqueID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_depth_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pDepth);


void __RPC_STUB IXTLRuntime_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_childNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_childNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_ancestorChildNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ BSTR bstrNodeName,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_ancestorChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_absoluteChildNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ long __RPC_FAR *pNumber);


void __RPC_STUB IXTLRuntime_absoluteChildNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatIndex_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ long lIndex,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatNumber_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ double dblNumber,
    /* [in] */ BSTR bstrFormat,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatDate_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ VARIANT varDate,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXTLRuntime_formatTime_Proxy( 
    IXTLRuntime __RPC_FAR * This,
    /* [in] */ VARIANT varTime,
    /* [in] */ BSTR bstrFormat,
    /* [optional][in] */ VARIANT varDestLocale,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFormattedString);


void __RPC_STUB IXTLRuntime_formatTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXTLRuntime_INTERFACE_DEFINED__ */


#ifndef __IXSLTemplate_INTERFACE_DEFINED__
#define __IXSLTemplate_INTERFACE_DEFINED__

/* interface IXSLTemplate */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLTemplate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF93-7B36-11d2-B20E-00C04F983E60")
    IXSLTemplate : public IDispatch
    {
    public:
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_stylesheet( 
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createProcessor( 
            /* [retval][out] */ IXSLProcessor __RPC_FAR *__RPC_FAR *ppProcessor) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLTemplateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXSLTemplate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXSLTemplate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXSLTemplate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXSLTemplate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXSLTemplate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXSLTemplate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXSLTemplate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_stylesheet )( 
            IXSLTemplate __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stylesheet )( 
            IXSLTemplate __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createProcessor )( 
            IXSLTemplate __RPC_FAR * This,
            /* [retval][out] */ IXSLProcessor __RPC_FAR *__RPC_FAR *ppProcessor);
        
        END_INTERFACE
    } IXSLTemplateVtbl;

    interface IXSLTemplate
    {
        CONST_VTBL struct IXSLTemplateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLTemplate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLTemplate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLTemplate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLTemplate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLTemplate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLTemplate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLTemplate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLTemplate_putref_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> putref_stylesheet(This,stylesheet)

#define IXSLTemplate_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#define IXSLTemplate_createProcessor(This,ppProcessor)	\
    (This)->lpVtbl -> createProcessor(This,ppProcessor)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_putref_stylesheet_Proxy( 
    IXSLTemplate __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *stylesheet);


void __RPC_STUB IXSLTemplate_putref_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_get_stylesheet_Proxy( 
    IXSLTemplate __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet);


void __RPC_STUB IXSLTemplate_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLTemplate_createProcessor_Proxy( 
    IXSLTemplate __RPC_FAR * This,
    /* [retval][out] */ IXSLProcessor __RPC_FAR *__RPC_FAR *ppProcessor);


void __RPC_STUB IXSLTemplate_createProcessor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLTemplate_INTERFACE_DEFINED__ */


#ifndef __IXSLProcessor_INTERFACE_DEFINED__
#define __IXSLProcessor_INTERFACE_DEFINED__

/* interface IXSLProcessor */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXSLProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2933BF92-7B36-11d2-B20E-00C04F983E60")
    IXSLProcessor : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_input( 
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_input( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVar) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ownerTemplate( 
            /* [retval][out] */ IXSLTemplate __RPC_FAR *__RPC_FAR *ppTemplate) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setStartMode( 
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_startMode( 
            /* [retval][out] */ BSTR __RPC_FAR *mode) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_startModeURI( 
            /* [retval][out] */ BSTR __RPC_FAR *namespaceURI) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT output) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT __RPC_FAR *pOutput) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE transform( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pDone) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE reset( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long __RPC_FAR *pReadyState) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addParameter( 
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI = L"") = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addObject( 
            /* [in] */ IDispatch __RPC_FAR *obj,
            /* [in] */ BSTR namespaceURI) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stylesheet( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXSLProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXSLProcessor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXSLProcessor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXSLProcessor __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_input )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ VARIANT var);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_input )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVar);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ownerTemplate )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ IXSLTemplate __RPC_FAR *__RPC_FAR *ppTemplate);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setStartMode )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ BSTR mode,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_startMode )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *mode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_startModeURI )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *namespaceURI);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_output )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ VARIANT output);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_output )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pOutput);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *transform )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pDone);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IXSLProcessor __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pReadyState);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addParameter )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ BSTR baseName,
            /* [in] */ VARIANT parameter,
            /* [defaultvalue][in] */ BSTR namespaceURI);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addObject )( 
            IXSLProcessor __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *obj,
            /* [in] */ BSTR namespaceURI);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stylesheet )( 
            IXSLProcessor __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet);
        
        END_INTERFACE
    } IXSLProcessorVtbl;

    interface IXSLProcessor
    {
        CONST_VTBL struct IXSLProcessorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXSLProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXSLProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXSLProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXSLProcessor_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXSLProcessor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXSLProcessor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXSLProcessor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXSLProcessor_put_input(This,var)	\
    (This)->lpVtbl -> put_input(This,var)

#define IXSLProcessor_get_input(This,pVar)	\
    (This)->lpVtbl -> get_input(This,pVar)

#define IXSLProcessor_get_ownerTemplate(This,ppTemplate)	\
    (This)->lpVtbl -> get_ownerTemplate(This,ppTemplate)

#define IXSLProcessor_setStartMode(This,mode,namespaceURI)	\
    (This)->lpVtbl -> setStartMode(This,mode,namespaceURI)

#define IXSLProcessor_get_startMode(This,mode)	\
    (This)->lpVtbl -> get_startMode(This,mode)

#define IXSLProcessor_get_startModeURI(This,namespaceURI)	\
    (This)->lpVtbl -> get_startModeURI(This,namespaceURI)

#define IXSLProcessor_put_output(This,output)	\
    (This)->lpVtbl -> put_output(This,output)

#define IXSLProcessor_get_output(This,pOutput)	\
    (This)->lpVtbl -> get_output(This,pOutput)

#define IXSLProcessor_transform(This,pDone)	\
    (This)->lpVtbl -> transform(This,pDone)

#define IXSLProcessor_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXSLProcessor_get_readyState(This,pReadyState)	\
    (This)->lpVtbl -> get_readyState(This,pReadyState)

#define IXSLProcessor_addParameter(This,baseName,parameter,namespaceURI)	\
    (This)->lpVtbl -> addParameter(This,baseName,parameter,namespaceURI)

#define IXSLProcessor_addObject(This,obj,namespaceURI)	\
    (This)->lpVtbl -> addObject(This,obj,namespaceURI)

#define IXSLProcessor_get_stylesheet(This,stylesheet)	\
    (This)->lpVtbl -> get_stylesheet(This,stylesheet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_input_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [in] */ VARIANT var);


void __RPC_STUB IXSLProcessor_put_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_input_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB IXSLProcessor_get_input_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_ownerTemplate_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ IXSLTemplate __RPC_FAR *__RPC_FAR *ppTemplate);


void __RPC_STUB IXSLProcessor_get_ownerTemplate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_setStartMode_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [in] */ BSTR mode,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_setStartMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startMode_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *mode);


void __RPC_STUB IXSLProcessor_get_startMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_startModeURI_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *namespaceURI);


void __RPC_STUB IXSLProcessor_get_startModeURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_put_output_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [in] */ VARIANT output);


void __RPC_STUB IXSLProcessor_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_output_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pOutput);


void __RPC_STUB IXSLProcessor_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_transform_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pDone);


void __RPC_STUB IXSLProcessor_transform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_reset_Proxy( 
    IXSLProcessor __RPC_FAR * This);


void __RPC_STUB IXSLProcessor_reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_readyState_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pReadyState);


void __RPC_STUB IXSLProcessor_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addParameter_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [in] */ BSTR baseName,
    /* [in] */ VARIANT parameter,
    /* [defaultvalue][in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_addObject_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *obj,
    /* [in] */ BSTR namespaceURI);


void __RPC_STUB IXSLProcessor_addObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXSLProcessor_get_stylesheet_Proxy( 
    IXSLProcessor __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *stylesheet);


void __RPC_STUB IXSLProcessor_get_stylesheet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXSLProcessor_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLReader_INTERFACE_DEFINED__
#define __ISAXXMLReader_INTERFACE_DEFINED__

/* interface ISAXXMLReader */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a4f96ed0-f829-476e-81c0-cdc7bd2a0802")
    ISAXXMLReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT_BOOL vfValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getEntityResolver( 
            /* [retval][out] */ ISAXEntityResolver __RPC_FAR *__RPC_FAR *ppResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putEntityResolver( 
            /* [in] */ ISAXEntityResolver __RPC_FAR *pResolver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getContentHandler( 
            /* [retval][out] */ ISAXContentHandler __RPC_FAR *__RPC_FAR *ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putContentHandler( 
            /* [in] */ ISAXContentHandler __RPC_FAR *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getDTDHandler( 
            /* [retval][out] */ ISAXDTDHandler __RPC_FAR *__RPC_FAR *ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putDTDHandler( 
            /* [in] */ ISAXDTDHandler __RPC_FAR *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getErrorHandler( 
            /* [retval][out] */ ISAXErrorHandler __RPC_FAR *__RPC_FAR *ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putErrorHandler( 
            /* [in] */ ISAXErrorHandler __RPC_FAR *pHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getBaseURL( 
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putBaseURL( 
            /* [in] */ const wchar_t __RPC_FAR *pwchBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSecureBaseURL( 
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putSecureBaseURL( 
            /* [in] */ const wchar_t __RPC_FAR *pwchSecureBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ const wchar_t __RPC_FAR *pwchUrl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXXMLReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXXMLReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFeature )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putFeature )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProperty )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putProperty )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getEntityResolver )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ ISAXEntityResolver __RPC_FAR *__RPC_FAR *ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putEntityResolver )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ ISAXEntityResolver __RPC_FAR *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getContentHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ ISAXContentHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putContentHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ ISAXContentHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getDTDHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ ISAXDTDHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putDTDHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ ISAXDTDHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ ISAXErrorHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putErrorHandler )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ ISAXErrorHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getBaseURL )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putBaseURL )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSecureBaseURL )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putSecureBaseURL )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parse )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parseURL )( 
            ISAXXMLReader __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchUrl);
        
        END_INTERFACE
    } ISAXXMLReaderVtbl;

    interface ISAXXMLReader
    {
        CONST_VTBL struct ISAXXMLReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLReader_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLReader_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLReader_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLReader_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLReader_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLReader_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLReader_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLReader_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLReader_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLReader_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLReader_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLReader_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLReader_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLReader_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLReader_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLReader_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLReader_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLReader_getFeature_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvfValue);


void __RPC_STUB ISAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putFeature_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ VARIANT_BOOL vfValue);


void __RPC_STUB ISAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getProperty_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarValue);


void __RPC_STUB ISAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putProperty_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB ISAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getEntityResolver_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ ISAXEntityResolver __RPC_FAR *__RPC_FAR *ppResolver);


void __RPC_STUB ISAXXMLReader_getEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putEntityResolver_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ ISAXEntityResolver __RPC_FAR *pResolver);


void __RPC_STUB ISAXXMLReader_putEntityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getContentHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ ISAXContentHandler __RPC_FAR *__RPC_FAR *ppHandler);


void __RPC_STUB ISAXXMLReader_getContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putContentHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ ISAXContentHandler __RPC_FAR *pHandler);


void __RPC_STUB ISAXXMLReader_putContentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getDTDHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ ISAXDTDHandler __RPC_FAR *__RPC_FAR *ppHandler);


void __RPC_STUB ISAXXMLReader_getDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putDTDHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ ISAXDTDHandler __RPC_FAR *pHandler);


void __RPC_STUB ISAXXMLReader_putDTDHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getErrorHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ ISAXErrorHandler __RPC_FAR *__RPC_FAR *ppHandler);


void __RPC_STUB ISAXXMLReader_getErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putErrorHandler_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ ISAXErrorHandler __RPC_FAR *pHandler);


void __RPC_STUB ISAXXMLReader_putErrorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getBaseURL_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchBaseUrl);


void __RPC_STUB ISAXXMLReader_getBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putBaseURL_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchBaseUrl);


void __RPC_STUB ISAXXMLReader_putBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_getSecureBaseURL_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_getSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_putSecureBaseURL_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchSecureBaseUrl);


void __RPC_STUB ISAXXMLReader_putSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parse_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB ISAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLReader_parseURL_Proxy( 
    ISAXXMLReader __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchUrl);


void __RPC_STUB ISAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __ISAXXMLFilter_INTERFACE_DEFINED__
#define __ISAXXMLFilter_INTERFACE_DEFINED__

/* interface ISAXXMLFilter */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70409222-ca09-4475-acb8-40312fe8d145")
    ISAXXMLFilter : public ISAXXMLReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getParent( 
            /* [retval][out] */ ISAXXMLReader __RPC_FAR *__RPC_FAR *ppReader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE putParent( 
            /* [in] */ ISAXXMLReader __RPC_FAR *pReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXXMLFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXXMLFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFeature )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pvfValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putFeature )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT_BOOL vfValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProperty )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putProperty )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ VARIANT varValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getEntityResolver )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ ISAXEntityResolver __RPC_FAR *__RPC_FAR *ppResolver);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putEntityResolver )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ ISAXEntityResolver __RPC_FAR *pResolver);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getContentHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ ISAXContentHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putContentHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ ISAXContentHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getDTDHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ ISAXDTDHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putDTDHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ ISAXDTDHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getErrorHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ ISAXErrorHandler __RPC_FAR *__RPC_FAR *ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putErrorHandler )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ ISAXErrorHandler __RPC_FAR *pHandler);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getBaseURL )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putBaseURL )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSecureBaseURL )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putSecureBaseURL )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchSecureBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parse )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parseURL )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getParent )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ ISAXXMLReader __RPC_FAR *__RPC_FAR *ppReader);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putParent )( 
            ISAXXMLFilter __RPC_FAR * This,
            /* [in] */ ISAXXMLReader __RPC_FAR *pReader);
        
        END_INTERFACE
    } ISAXXMLFilterVtbl;

    interface ISAXXMLFilter
    {
        CONST_VTBL struct ISAXXMLFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXXMLFilter_getFeature(This,pwchName,pvfValue)	\
    (This)->lpVtbl -> getFeature(This,pwchName,pvfValue)

#define ISAXXMLFilter_putFeature(This,pwchName,vfValue)	\
    (This)->lpVtbl -> putFeature(This,pwchName,vfValue)

#define ISAXXMLFilter_getProperty(This,pwchName,pvarValue)	\
    (This)->lpVtbl -> getProperty(This,pwchName,pvarValue)

#define ISAXXMLFilter_putProperty(This,pwchName,varValue)	\
    (This)->lpVtbl -> putProperty(This,pwchName,varValue)

#define ISAXXMLFilter_getEntityResolver(This,ppResolver)	\
    (This)->lpVtbl -> getEntityResolver(This,ppResolver)

#define ISAXXMLFilter_putEntityResolver(This,pResolver)	\
    (This)->lpVtbl -> putEntityResolver(This,pResolver)

#define ISAXXMLFilter_getContentHandler(This,ppHandler)	\
    (This)->lpVtbl -> getContentHandler(This,ppHandler)

#define ISAXXMLFilter_putContentHandler(This,pHandler)	\
    (This)->lpVtbl -> putContentHandler(This,pHandler)

#define ISAXXMLFilter_getDTDHandler(This,ppHandler)	\
    (This)->lpVtbl -> getDTDHandler(This,ppHandler)

#define ISAXXMLFilter_putDTDHandler(This,pHandler)	\
    (This)->lpVtbl -> putDTDHandler(This,pHandler)

#define ISAXXMLFilter_getErrorHandler(This,ppHandler)	\
    (This)->lpVtbl -> getErrorHandler(This,ppHandler)

#define ISAXXMLFilter_putErrorHandler(This,pHandler)	\
    (This)->lpVtbl -> putErrorHandler(This,pHandler)

#define ISAXXMLFilter_getBaseURL(This,ppwchBaseUrl)	\
    (This)->lpVtbl -> getBaseURL(This,ppwchBaseUrl)

#define ISAXXMLFilter_putBaseURL(This,pwchBaseUrl)	\
    (This)->lpVtbl -> putBaseURL(This,pwchBaseUrl)

#define ISAXXMLFilter_getSecureBaseURL(This,ppwchSecureBaseUrl)	\
    (This)->lpVtbl -> getSecureBaseURL(This,ppwchSecureBaseUrl)

#define ISAXXMLFilter_putSecureBaseURL(This,pwchSecureBaseUrl)	\
    (This)->lpVtbl -> putSecureBaseURL(This,pwchSecureBaseUrl)

#define ISAXXMLFilter_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define ISAXXMLFilter_parseURL(This,pwchUrl)	\
    (This)->lpVtbl -> parseURL(This,pwchUrl)


#define ISAXXMLFilter_getParent(This,ppReader)	\
    (This)->lpVtbl -> getParent(This,ppReader)

#define ISAXXMLFilter_putParent(This,pReader)	\
    (This)->lpVtbl -> putParent(This,pReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXXMLFilter_getParent_Proxy( 
    ISAXXMLFilter __RPC_FAR * This,
    /* [retval][out] */ ISAXXMLReader __RPC_FAR *__RPC_FAR *ppReader);


void __RPC_STUB ISAXXMLFilter_getParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXXMLFilter_putParent_Proxy( 
    ISAXXMLFilter __RPC_FAR * This,
    /* [in] */ ISAXXMLReader __RPC_FAR *pReader);


void __RPC_STUB ISAXXMLFilter_putParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __ISAXLocator_INTERFACE_DEFINED__
#define __ISAXLocator_INTERFACE_DEFINED__

/* interface ISAXLocator */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9b7e472a-0de4-4640-bff3-84d38a051c31")
    ISAXLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getColumnNumber( 
            /* [retval][out] */ int __RPC_FAR *pnColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLineNumber( 
            /* [retval][out] */ int __RPC_FAR *pnLine) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getPublicId( 
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchPublicId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getSystemId( 
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getColumnNumber )( 
            ISAXLocator __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnColumn);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getLineNumber )( 
            ISAXLocator __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnLine);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getPublicId )( 
            ISAXLocator __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchPublicId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getSystemId )( 
            ISAXLocator __RPC_FAR * This,
            /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSystemId);
        
        END_INTERFACE
    } ISAXLocatorVtbl;

    interface ISAXLocator
    {
        CONST_VTBL struct ISAXLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLocator_getColumnNumber(This,pnColumn)	\
    (This)->lpVtbl -> getColumnNumber(This,pnColumn)

#define ISAXLocator_getLineNumber(This,pnLine)	\
    (This)->lpVtbl -> getLineNumber(This,pnLine)

#define ISAXLocator_getPublicId(This,ppwchPublicId)	\
    (This)->lpVtbl -> getPublicId(This,ppwchPublicId)

#define ISAXLocator_getSystemId(This,ppwchSystemId)	\
    (This)->lpVtbl -> getSystemId(This,ppwchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLocator_getColumnNumber_Proxy( 
    ISAXLocator __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnColumn);


void __RPC_STUB ISAXLocator_getColumnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getLineNumber_Proxy( 
    ISAXLocator __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnLine);


void __RPC_STUB ISAXLocator_getLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getPublicId_Proxy( 
    ISAXLocator __RPC_FAR * This,
    /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchPublicId);


void __RPC_STUB ISAXLocator_getPublicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLocator_getSystemId_Proxy( 
    ISAXLocator __RPC_FAR * This,
    /* [retval][out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchSystemId);


void __RPC_STUB ISAXLocator_getSystemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLocator_INTERFACE_DEFINED__ */


#ifndef __ISAXEntityResolver_INTERFACE_DEFINED__
#define __ISAXEntityResolver_INTERFACE_DEFINED__

/* interface ISAXEntityResolver */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99bca7bd-e8c4-4d5f-a0cf-6d907901ff07")
    ISAXEntityResolver : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXEntityResolver __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXEntityResolver __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXEntityResolver __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resolveEntity )( 
            ISAXEntityResolver __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarInput);
        
        END_INTERFACE
    } ISAXEntityResolverVtbl;

    interface ISAXEntityResolver
    {
        CONST_VTBL struct ISAXEntityResolverVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXEntityResolver_resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)	\
    (This)->lpVtbl -> resolveEntity(This,pwchPublicId,pwchSystemId,pvarInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXEntityResolver_resolveEntity_Proxy( 
    ISAXEntityResolver __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
    /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarInput);


void __RPC_STUB ISAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __ISAXContentHandler_INTERFACE_DEFINED__
#define __ISAXContentHandler_INTERFACE_DEFINED__

/* interface ISAXContentHandler */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1545cdfa-9e4e-4497-a8a4-2bf7d0112c44")
    ISAXContentHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXContentHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXContentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putDocumentLocator )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ ISAXLocator __RPC_FAR *pLocator);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDocument )( 
            ISAXContentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endDocument )( 
            ISAXContentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startPrefixMapping )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endPrefixMapping )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startElement )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endElement )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *characters )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ignorableWhitespace )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *processingInstruction )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *skippedEntity )( 
            ISAXContentHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);
        
        END_INTERFACE
    } ISAXContentHandlerVtbl;

    interface ISAXContentHandler
    {
        CONST_VTBL struct ISAXContentHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXContentHandler_putDocumentLocator(This,pLocator)	\
    (This)->lpVtbl -> putDocumentLocator(This,pLocator)

#define ISAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define ISAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define ISAXContentHandler_startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)	\
    (This)->lpVtbl -> startPrefixMapping(This,pwchPrefix,cchPrefix,pwchUri,cchUri)

#define ISAXContentHandler_endPrefixMapping(This,pwchPrefix,cchPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,pwchPrefix,cchPrefix)

#define ISAXContentHandler_startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)	\
    (This)->lpVtbl -> startElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName,pAttributes)

#define ISAXContentHandler_endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)	\
    (This)->lpVtbl -> endElement(This,pwchNamespaceUri,cchNamespaceUri,pwchLocalName,cchLocalName,pwchQName,cchQName)

#define ISAXContentHandler_characters(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> characters(This,pwchChars,cchChars)

#define ISAXContentHandler_ignorableWhitespace(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,pwchChars,cchChars)

#define ISAXContentHandler_processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)	\
    (This)->lpVtbl -> processingInstruction(This,pwchTarget,cchTarget,pwchData,cchData)

#define ISAXContentHandler_skippedEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> skippedEntity(This,pwchName,cchName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXContentHandler_putDocumentLocator_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ ISAXLocator __RPC_FAR *pLocator);


void __RPC_STUB ISAXContentHandler_putDocumentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startDocument_Proxy( 
    ISAXContentHandler __RPC_FAR * This);


void __RPC_STUB ISAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endDocument_Proxy( 
    ISAXContentHandler __RPC_FAR * This);


void __RPC_STUB ISAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startPrefixMapping_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
    /* [in] */ int cchPrefix,
    /* [in] */ const wchar_t __RPC_FAR *pwchUri,
    /* [in] */ int cchUri);


void __RPC_STUB ISAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endPrefixMapping_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
    /* [in] */ int cchPrefix);


void __RPC_STUB ISAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_startElement_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t __RPC_FAR *pwchQName,
    /* [in] */ int cchQName,
    /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);


void __RPC_STUB ISAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_endElement_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
    /* [in] */ int cchNamespaceUri,
    /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [in] */ const wchar_t __RPC_FAR *pwchQName,
    /* [in] */ int cchQName);


void __RPC_STUB ISAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_characters_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_ignorableWhitespace_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_processingInstruction_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
    /* [in] */ int cchTarget,
    /* [in] */ const wchar_t __RPC_FAR *pwchData,
    /* [in] */ int cchData);


void __RPC_STUB ISAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXContentHandler_skippedEntity_Proxy( 
    ISAXContentHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDTDHandler_INTERFACE_DEFINED__
#define __ISAXDTDHandler_INTERFACE_DEFINED__

/* interface ISAXDTDHandler */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e15c1baf-afb3-4d60-8c36-19a8c45defed")
    ISAXDTDHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t __RPC_FAR *pwchNotationName,
            /* [in] */ int cchNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXDTDHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXDTDHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXDTDHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *notationDecl )( 
            ISAXDTDHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *unparsedEntityDecl )( 
            ISAXDTDHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId,
            /* [in] */ const wchar_t __RPC_FAR *pwchNotationName,
            /* [in] */ int cchNotationName);
        
        END_INTERFACE
    } ISAXDTDHandlerVtbl;

    interface ISAXDTDHandler
    {
        CONST_VTBL struct ISAXDTDHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDTDHandler_notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> notationDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXDTDHandler_unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId,pwchNotationName,cchNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDTDHandler_notationDecl_Proxy( 
    ISAXDTDHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDTDHandler_unparsedEntityDecl_Proxy( 
    ISAXDTDHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
    /* [in] */ int cchSystemId,
    /* [in] */ const wchar_t __RPC_FAR *pwchNotationName,
    /* [in] */ int cchNotationName);


void __RPC_STUB ISAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXErrorHandler_INTERFACE_DEFINED__
#define __ISAXErrorHandler_INTERFACE_DEFINED__

/* interface ISAXErrorHandler */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a60511c4-ccf5-479e-98a3-dc8dc545b7d0")
    ISAXErrorHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXErrorHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXErrorHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXErrorHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *error )( 
            ISAXErrorHandler __RPC_FAR * This,
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fatalError )( 
            ISAXErrorHandler __RPC_FAR * This,
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ignorableWarning )( 
            ISAXErrorHandler __RPC_FAR * This,
            /* [in] */ ISAXLocator __RPC_FAR *pLocator,
            /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
            /* [in] */ HRESULT hrErrorCode);
        
        END_INTERFACE
    } ISAXErrorHandlerVtbl;

    interface ISAXErrorHandler
    {
        CONST_VTBL struct ISAXErrorHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXErrorHandler_error(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> error(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> fatalError(This,pLocator,pwchErrorMessage,hrErrorCode)

#define ISAXErrorHandler_ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,pLocator,pwchErrorMessage,hrErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXErrorHandler_error_Proxy( 
    ISAXErrorHandler __RPC_FAR * This,
    /* [in] */ ISAXLocator __RPC_FAR *pLocator,
    /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_fatalError_Proxy( 
    ISAXErrorHandler __RPC_FAR * This,
    /* [in] */ ISAXLocator __RPC_FAR *pLocator,
    /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXErrorHandler_ignorableWarning_Proxy( 
    ISAXErrorHandler __RPC_FAR * This,
    /* [in] */ ISAXLocator __RPC_FAR *pLocator,
    /* [in] */ const wchar_t __RPC_FAR *pwchErrorMessage,
    /* [in] */ HRESULT hrErrorCode);


void __RPC_STUB ISAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXLexicalHandler_INTERFACE_DEFINED__
#define __ISAXLexicalHandler_INTERFACE_DEFINED__

/* interface ISAXLexicalHandler */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7f85d5f5-47a8-4497-bda5-84ba04819ea6")
    ISAXLexicalHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE startDTD( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE comment( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXLexicalHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXLexicalHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXLexicalHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDTD )( 
            ISAXLexicalHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endDTD )( 
            ISAXLexicalHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startEntity )( 
            ISAXLexicalHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endEntity )( 
            ISAXLexicalHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startCDATA )( 
            ISAXLexicalHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endCDATA )( 
            ISAXLexicalHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *comment )( 
            ISAXLexicalHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        END_INTERFACE
    } ISAXLexicalHandlerVtbl;

    interface ISAXLexicalHandler
    {
        CONST_VTBL struct ISAXLexicalHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXLexicalHandler_startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> startDTD(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#define ISAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define ISAXLexicalHandler_startEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> startEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_endEntity(This,pwchName,cchName)	\
    (This)->lpVtbl -> endEntity(This,pwchName,cchName)

#define ISAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define ISAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define ISAXLexicalHandler_comment(This,pwchChars,cchChars)	\
    (This)->lpVtbl -> comment(This,pwchChars,cchChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startDTD_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endDTD_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB ISAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startEntity_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endEntity_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName);


void __RPC_STUB ISAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_startCDATA_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB ISAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_endCDATA_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB ISAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXLexicalHandler_comment_Proxy( 
    ISAXLexicalHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchChars,
    /* [in] */ int cchChars);


void __RPC_STUB ISAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXDeclHandler_INTERFACE_DEFINED__
#define __ISAXDeclHandler_INTERFACE_DEFINED__

/* interface ISAXDeclHandler */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("862629ac-771a-47b2-8337-4e6843c1be90")
    ISAXDeclHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchModel,
            /* [in] */ int cchModel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t __RPC_FAR *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t __RPC_FAR *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t __RPC_FAR *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t __RPC_FAR *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchValue,
            /* [in] */ int cchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXDeclHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXDeclHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXDeclHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *elementDecl )( 
            ISAXDeclHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchModel,
            /* [in] */ int cchModel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *attributeDecl )( 
            ISAXDeclHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchElementName,
            /* [in] */ int cchElementName,
            /* [in] */ const wchar_t __RPC_FAR *pwchAttributeName,
            /* [in] */ int cchAttributeName,
            /* [in] */ const wchar_t __RPC_FAR *pwchType,
            /* [in] */ int cchType,
            /* [in] */ const wchar_t __RPC_FAR *pwchValueDefault,
            /* [in] */ int cchValueDefault,
            /* [in] */ const wchar_t __RPC_FAR *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *internalEntityDecl )( 
            ISAXDeclHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchValue,
            /* [in] */ int cchValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *externalEntityDecl )( 
            ISAXDeclHandler __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName,
            /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
            /* [in] */ int cchPublicId,
            /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
            /* [in] */ int cchSystemId);
        
        END_INTERFACE
    } ISAXDeclHandlerVtbl;

    interface ISAXDeclHandler
    {
        CONST_VTBL struct ISAXDeclHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXDeclHandler_elementDecl(This,pwchName,cchName,pwchModel,cchModel)	\
    (This)->lpVtbl -> elementDecl(This,pwchName,cchName,pwchModel,cchModel)

#define ISAXDeclHandler_attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)	\
    (This)->lpVtbl -> attributeDecl(This,pwchElementName,cchElementName,pwchAttributeName,cchAttributeName,pwchType,cchType,pwchValueDefault,cchValueDefault,pwchValue,cchValue)

#define ISAXDeclHandler_internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,pwchName,cchName,pwchValue,cchValue)

#define ISAXDeclHandler_externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,pwchName,cchName,pwchPublicId,cchPublicId,pwchSystemId,cchSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXDeclHandler_elementDecl_Proxy( 
    ISAXDeclHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchModel,
    /* [in] */ int cchModel);


void __RPC_STUB ISAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_attributeDecl_Proxy( 
    ISAXDeclHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchElementName,
    /* [in] */ int cchElementName,
    /* [in] */ const wchar_t __RPC_FAR *pwchAttributeName,
    /* [in] */ int cchAttributeName,
    /* [in] */ const wchar_t __RPC_FAR *pwchType,
    /* [in] */ int cchType,
    /* [in] */ const wchar_t __RPC_FAR *pwchValueDefault,
    /* [in] */ int cchValueDefault,
    /* [in] */ const wchar_t __RPC_FAR *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_internalEntityDecl_Proxy( 
    ISAXDeclHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchValue,
    /* [in] */ int cchValue);


void __RPC_STUB ISAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXDeclHandler_externalEntityDecl_Proxy( 
    ISAXDeclHandler __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchName,
    /* [in] */ int cchName,
    /* [in] */ const wchar_t __RPC_FAR *pwchPublicId,
    /* [in] */ int cchPublicId,
    /* [in] */ const wchar_t __RPC_FAR *pwchSystemId,
    /* [in] */ int cchSystemId);


void __RPC_STUB ISAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __ISAXAttributes_INTERFACE_DEFINED__
#define __ISAXAttributes_INTERFACE_DEFINED__

/* interface ISAXAttributes */
/* [unique][uuid][local][object][hidden] */ 


EXTERN_C const IID IID_ISAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f078abe1-45d2-4832-91ea-4466ce2f25c9")
    ISAXAttributes : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE getLength( 
            /* [retval][out] */ int __RPC_FAR *pnLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
            /* [out] */ int __RPC_FAR *pcchUri) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
            /* [out] */ int __RPC_FAR *pcchLocalName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
            /* [out] */ int __RPC_FAR *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getName( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
            /* [out] */ int __RPC_FAR *pcchUri,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
            /* [out] */ int __RPC_FAR *pcchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
            /* [out] */ int __RPC_FAR *pcchQName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int __RPC_FAR *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int __RPC_FAR *pnIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISAXAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISAXAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getLength )( 
            ISAXAttributes __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pnLength);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getURI )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
            /* [out] */ int __RPC_FAR *pcchUri);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getLocalName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
            /* [out] */ int __RPC_FAR *pcchLocalName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getQName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
            /* [out] */ int __RPC_FAR *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
            /* [out] */ int __RPC_FAR *pcchUri,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
            /* [out] */ int __RPC_FAR *pcchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
            /* [out] */ int __RPC_FAR *pcchQName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getIndexFromName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [retval][out] */ int __RPC_FAR *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getIndexFromQName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [retval][out] */ int __RPC_FAR *pnIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getType )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getTypeFromName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getTypeFromQName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
            /* [out] */ int __RPC_FAR *pcchType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValue )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValueFromName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValueFromQName )( 
            ISAXAttributes __RPC_FAR * This,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName,
            /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
            /* [out] */ int __RPC_FAR *pcchValue);
        
        END_INTERFACE
    } ISAXAttributesVtbl;

    interface ISAXAttributes
    {
        CONST_VTBL struct ISAXAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISAXAttributes_getLength(This,pnLength)	\
    (This)->lpVtbl -> getLength(This,pnLength)

#define ISAXAttributes_getURI(This,nIndex,ppwchUri,pcchUri)	\
    (This)->lpVtbl -> getURI(This,nIndex,ppwchUri,pcchUri)

#define ISAXAttributes_getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,ppwchLocalName,pcchLocalName)

#define ISAXAttributes_getQName(This,nIndex,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,ppwchQName,pcchQName)

#define ISAXAttributes_getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)	\
    (This)->lpVtbl -> getName(This,nIndex,ppwchUri,pcchUri,ppwchLocalName,pcchLocalName,ppwchQName,pcchQName)

#define ISAXAttributes_getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,pnIndex)

#define ISAXAttributes_getIndexFromQName(This,pwchQName,cchQName,pnIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,pwchQName,cchQName,pnIndex)

#define ISAXAttributes_getType(This,nIndex,ppwchType,pcchType)	\
    (This)->lpVtbl -> getType(This,nIndex,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchType,pcchType)

#define ISAXAttributes_getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)	\
    (This)->lpVtbl -> getTypeFromQName(This,pwchQName,cchQName,ppwchType,pcchType)

#define ISAXAttributes_getValue(This,nIndex,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromName(This,pwchUri,cchUri,pwchLocalName,cchLocalName,ppwchValue,pcchValue)

#define ISAXAttributes_getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)	\
    (This)->lpVtbl -> getValueFromQName(This,pwchQName,cchQName,ppwchValue,pcchValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISAXAttributes_getLength_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pnLength);


void __RPC_STUB ISAXAttributes_getLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getURI_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
    /* [out] */ int __RPC_FAR *pcchUri);


void __RPC_STUB ISAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getLocalName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
    /* [out] */ int __RPC_FAR *pcchLocalName);


void __RPC_STUB ISAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getQName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
    /* [out] */ int __RPC_FAR *pcchQName);


void __RPC_STUB ISAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchUri,
    /* [out] */ int __RPC_FAR *pcchUri,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchLocalName,
    /* [out] */ int __RPC_FAR *pcchLocalName,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchQName,
    /* [out] */ int __RPC_FAR *pcchQName);


void __RPC_STUB ISAXAttributes_getName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [retval][out] */ int __RPC_FAR *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getIndexFromQName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchQName,
    /* [in] */ int cchQName,
    /* [retval][out] */ int __RPC_FAR *pnIndex);


void __RPC_STUB ISAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getType_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
    /* [out] */ int __RPC_FAR *pcchType);


void __RPC_STUB ISAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
    /* [out] */ int __RPC_FAR *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getTypeFromQName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchType,
    /* [out] */ int __RPC_FAR *pcchType);


void __RPC_STUB ISAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValue_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
    /* [out] */ int __RPC_FAR *pcchValue);


void __RPC_STUB ISAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchUri,
    /* [in] */ int cchUri,
    /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
    /* [in] */ int cchLocalName,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
    /* [out] */ int __RPC_FAR *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISAXAttributes_getValueFromQName_Proxy( 
    ISAXAttributes __RPC_FAR * This,
    /* [in] */ const wchar_t __RPC_FAR *pwchQName,
    /* [in] */ int cchQName,
    /* [out] */ const wchar_t __RPC_FAR *__RPC_FAR *ppwchValue,
    /* [out] */ int __RPC_FAR *pcchValue);


void __RPC_STUB ISAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLReader_INTERFACE_DEFINED__
#define __IVBSAXXMLReader_INTERFACE_DEFINED__

/* interface IVBSAXXMLReader */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c033caa-6cd6-4f73-b728-4531af74945f")
    IVBSAXXMLReader : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getFeature( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE putFeature( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT __RPC_FAR *varValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE putProperty( 
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_entityResolver( 
            /* [retval][out] */ IVBSAXEntityResolver __RPC_FAR *__RPC_FAR *oResolver) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_entityResolver( 
            /* [in] */ IVBSAXEntityResolver __RPC_FAR *oResolver) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_contentHandler( 
            /* [retval][out] */ IVBSAXContentHandler __RPC_FAR *__RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_contentHandler( 
            /* [in] */ IVBSAXContentHandler __RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_dtdHandler( 
            /* [retval][out] */ IVBSAXDTDHandler __RPC_FAR *__RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_dtdHandler( 
            /* [in] */ IVBSAXDTDHandler __RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_errorHandler( 
            /* [retval][out] */ IVBSAXErrorHandler __RPC_FAR *__RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_errorHandler( 
            /* [in] */ IVBSAXErrorHandler __RPC_FAR *oHandler) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_baseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *strBaseURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_baseURL( 
            /* [in] */ BSTR strBaseURL) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_secureBaseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *strSecureBaseURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_secureBaseURL( 
            /* [in] */ BSTR strSecureBaseURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parse( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE parseURL( 
            /* [in] */ BSTR strURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXXMLReader __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXXMLReader __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getFeature )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putFeature )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProperty )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [retval][out] */ VARIANT __RPC_FAR *varValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putProperty )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strName,
            /* [in] */ VARIANT varValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_entityResolver )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ IVBSAXEntityResolver __RPC_FAR *__RPC_FAR *oResolver);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_entityResolver )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ IVBSAXEntityResolver __RPC_FAR *oResolver);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_contentHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ IVBSAXContentHandler __RPC_FAR *__RPC_FAR *oHandler);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_contentHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ IVBSAXContentHandler __RPC_FAR *oHandler);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ IVBSAXDTDHandler __RPC_FAR *__RPC_FAR *oHandler);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_dtdHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ IVBSAXDTDHandler __RPC_FAR *oHandler);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_errorHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ IVBSAXErrorHandler __RPC_FAR *__RPC_FAR *oHandler);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_errorHandler )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ IVBSAXErrorHandler __RPC_FAR *oHandler);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_baseURL )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strBaseURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_baseURL )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strBaseURL);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_secureBaseURL )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strSecureBaseURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_secureBaseURL )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strSecureBaseURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parse )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *parseURL )( 
            IVBSAXXMLReader __RPC_FAR * This,
            /* [in] */ BSTR strURL);
        
        END_INTERFACE
    } IVBSAXXMLReaderVtbl;

    interface IVBSAXXMLReader
    {
        CONST_VTBL struct IVBSAXXMLReaderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLReader_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLReader_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLReader_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLReader_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLReader_getFeature(This,strName,fValue)	\
    (This)->lpVtbl -> getFeature(This,strName,fValue)

#define IVBSAXXMLReader_putFeature(This,strName,fValue)	\
    (This)->lpVtbl -> putFeature(This,strName,fValue)

#define IVBSAXXMLReader_getProperty(This,strName,varValue)	\
    (This)->lpVtbl -> getProperty(This,strName,varValue)

#define IVBSAXXMLReader_putProperty(This,strName,varValue)	\
    (This)->lpVtbl -> putProperty(This,strName,varValue)

#define IVBSAXXMLReader_get_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> get_entityResolver(This,oResolver)

#define IVBSAXXMLReader_putref_entityResolver(This,oResolver)	\
    (This)->lpVtbl -> putref_entityResolver(This,oResolver)

#define IVBSAXXMLReader_get_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> get_contentHandler(This,oHandler)

#define IVBSAXXMLReader_putref_contentHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_contentHandler(This,oHandler)

#define IVBSAXXMLReader_get_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> get_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_putref_dtdHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_dtdHandler(This,oHandler)

#define IVBSAXXMLReader_get_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> get_errorHandler(This,oHandler)

#define IVBSAXXMLReader_putref_errorHandler(This,oHandler)	\
    (This)->lpVtbl -> putref_errorHandler(This,oHandler)

#define IVBSAXXMLReader_get_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> get_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_put_baseURL(This,strBaseURL)	\
    (This)->lpVtbl -> put_baseURL(This,strBaseURL)

#define IVBSAXXMLReader_get_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> get_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_put_secureBaseURL(This,strSecureBaseURL)	\
    (This)->lpVtbl -> put_secureBaseURL(This,strSecureBaseURL)

#define IVBSAXXMLReader_parse(This,varInput)	\
    (This)->lpVtbl -> parse(This,varInput)

#define IVBSAXXMLReader_parseURL(This,strURL)	\
    (This)->lpVtbl -> parseURL(This,strURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getFeature_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);


void __RPC_STUB IVBSAXXMLReader_getFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putFeature_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IVBSAXXMLReader_putFeature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_getProperty_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [retval][out] */ VARIANT __RPC_FAR *varValue);


void __RPC_STUB IVBSAXXMLReader_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putProperty_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strName,
    /* [in] */ VARIANT varValue);


void __RPC_STUB IVBSAXXMLReader_putProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_entityResolver_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ IVBSAXEntityResolver __RPC_FAR *__RPC_FAR *oResolver);


void __RPC_STUB IVBSAXXMLReader_get_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_entityResolver_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ IVBSAXEntityResolver __RPC_FAR *oResolver);


void __RPC_STUB IVBSAXXMLReader_putref_entityResolver_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_contentHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ IVBSAXContentHandler __RPC_FAR *__RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_get_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_contentHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ IVBSAXContentHandler __RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_contentHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_dtdHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ IVBSAXDTDHandler __RPC_FAR *__RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_get_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_dtdHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ IVBSAXDTDHandler __RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_dtdHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_errorHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ IVBSAXErrorHandler __RPC_FAR *__RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_get_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_putref_errorHandler_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ IVBSAXErrorHandler __RPC_FAR *oHandler);


void __RPC_STUB IVBSAXXMLReader_putref_errorHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_baseURL_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_baseURL_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_baseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_get_secureBaseURL_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_get_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_put_secureBaseURL_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strSecureBaseURL);


void __RPC_STUB IVBSAXXMLReader_put_secureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parse_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IVBSAXXMLReader_parse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLReader_parseURL_Proxy( 
    IVBSAXXMLReader __RPC_FAR * This,
    /* [in] */ BSTR strURL);


void __RPC_STUB IVBSAXXMLReader_parseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLReader_INTERFACE_DEFINED__ */


#ifndef __IVBSAXXMLFilter_INTERFACE_DEFINED__
#define __IVBSAXXMLFilter_INTERFACE_DEFINED__

/* interface IVBSAXXMLFilter */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXXMLFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1299eb1b-5b88-433e-82de-82ca75ad4e04")
    IVBSAXXMLFilter : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [retval][out] */ IVBSAXXMLReader __RPC_FAR *__RPC_FAR *oReader) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_parent( 
            /* [in] */ IVBSAXXMLReader __RPC_FAR *oReader) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXXMLFilterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXXMLFilter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXXMLFilter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [retval][out] */ IVBSAXXMLReader __RPC_FAR *__RPC_FAR *oReader);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_parent )( 
            IVBSAXXMLFilter __RPC_FAR * This,
            /* [in] */ IVBSAXXMLReader __RPC_FAR *oReader);
        
        END_INTERFACE
    } IVBSAXXMLFilterVtbl;

    interface IVBSAXXMLFilter
    {
        CONST_VTBL struct IVBSAXXMLFilterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXXMLFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXXMLFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXXMLFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXXMLFilter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXXMLFilter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXXMLFilter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXXMLFilter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXXMLFilter_get_parent(This,oReader)	\
    (This)->lpVtbl -> get_parent(This,oReader)

#define IVBSAXXMLFilter_putref_parent(This,oReader)	\
    (This)->lpVtbl -> putref_parent(This,oReader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_get_parent_Proxy( 
    IVBSAXXMLFilter __RPC_FAR * This,
    /* [retval][out] */ IVBSAXXMLReader __RPC_FAR *__RPC_FAR *oReader);


void __RPC_STUB IVBSAXXMLFilter_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXXMLFilter_putref_parent_Proxy( 
    IVBSAXXMLFilter __RPC_FAR * This,
    /* [in] */ IVBSAXXMLReader __RPC_FAR *oReader);


void __RPC_STUB IVBSAXXMLFilter_putref_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXXMLFilter_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLocator_INTERFACE_DEFINED__
#define __IVBSAXLocator_INTERFACE_DEFINED__

/* interface IVBSAXLocator */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("796e7ac5-5aa2-4eff-acad-3faaf01a3288")
    IVBSAXLocator : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_columnNumber( 
            /* [retval][out] */ int __RPC_FAR *nColumn) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_lineNumber( 
            /* [retval][out] */ int __RPC_FAR *nLine) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_publicId( 
            /* [retval][out] */ BSTR __RPC_FAR *strPublicId) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_systemId( 
            /* [retval][out] */ BSTR __RPC_FAR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXLocator __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXLocator __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_columnNumber )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *nColumn);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_lineNumber )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *nLine);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_publicId )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strPublicId);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_systemId )( 
            IVBSAXLocator __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strSystemId);
        
        END_INTERFACE
    } IVBSAXLocatorVtbl;

    interface IVBSAXLocator
    {
        CONST_VTBL struct IVBSAXLocatorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLocator_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLocator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLocator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLocator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLocator_get_columnNumber(This,nColumn)	\
    (This)->lpVtbl -> get_columnNumber(This,nColumn)

#define IVBSAXLocator_get_lineNumber(This,nLine)	\
    (This)->lpVtbl -> get_lineNumber(This,nLine)

#define IVBSAXLocator_get_publicId(This,strPublicId)	\
    (This)->lpVtbl -> get_publicId(This,strPublicId)

#define IVBSAXLocator_get_systemId(This,strSystemId)	\
    (This)->lpVtbl -> get_systemId(This,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_columnNumber_Proxy( 
    IVBSAXLocator __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *nColumn);


void __RPC_STUB IVBSAXLocator_get_columnNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_lineNumber_Proxy( 
    IVBSAXLocator __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *nLine);


void __RPC_STUB IVBSAXLocator_get_lineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_publicId_Proxy( 
    IVBSAXLocator __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strPublicId);


void __RPC_STUB IVBSAXLocator_get_publicId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXLocator_get_systemId_Proxy( 
    IVBSAXLocator __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strSystemId);


void __RPC_STUB IVBSAXLocator_get_systemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLocator_INTERFACE_DEFINED__ */


#ifndef __IVBSAXEntityResolver_INTERFACE_DEFINED__
#define __IVBSAXEntityResolver_INTERFACE_DEFINED__

/* interface IVBSAXEntityResolver */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXEntityResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0c05d096-f45b-4aca-ad1a-aa0bc25518dc")
    IVBSAXEntityResolver : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resolveEntity( 
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId,
            /* [retval][out] */ VARIANT __RPC_FAR *varInput) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXEntityResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXEntityResolver __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXEntityResolver __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resolveEntity )( 
            IVBSAXEntityResolver __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId,
            /* [retval][out] */ VARIANT __RPC_FAR *varInput);
        
        END_INTERFACE
    } IVBSAXEntityResolverVtbl;

    interface IVBSAXEntityResolver
    {
        CONST_VTBL struct IVBSAXEntityResolverVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXEntityResolver_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXEntityResolver_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXEntityResolver_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXEntityResolver_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXEntityResolver_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXEntityResolver_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXEntityResolver_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXEntityResolver_resolveEntity(This,strPublicId,strSystemId,varInput)	\
    (This)->lpVtbl -> resolveEntity(This,strPublicId,strSystemId,varInput)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXEntityResolver_resolveEntity_Proxy( 
    IVBSAXEntityResolver __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strPublicId,
    /* [out][in] */ BSTR __RPC_FAR *strSystemId,
    /* [retval][out] */ VARIANT __RPC_FAR *varInput);


void __RPC_STUB IVBSAXEntityResolver_resolveEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXEntityResolver_INTERFACE_DEFINED__ */


#ifndef __IVBSAXContentHandler_INTERFACE_DEFINED__
#define __IVBSAXContentHandler_INTERFACE_DEFINED__

/* interface IVBSAXContentHandler */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXContentHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2ed7290a-4dd5-4b46-bb26-4e4155e77faa")
    IVBSAXContentHandler : public IDispatch
    {
    public:
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_documentLocator( 
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startDocument( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endDocument( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startPrefixMapping( 
            /* [out][in] */ BSTR __RPC_FAR *strPrefix,
            /* [out][in] */ BSTR __RPC_FAR *strURI) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endPrefixMapping( 
            /* [out][in] */ BSTR __RPC_FAR *strPrefix) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startElement( 
            /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
            /* [out][in] */ BSTR __RPC_FAR *strLocalName,
            /* [out][in] */ BSTR __RPC_FAR *strQName,
            /* [in] */ IVBSAXAttributes __RPC_FAR *oAttributes) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endElement( 
            /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
            /* [out][in] */ BSTR __RPC_FAR *strLocalName,
            /* [out][in] */ BSTR __RPC_FAR *strQName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE characters( 
            /* [out][in] */ BSTR __RPC_FAR *strChars) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [out][in] */ BSTR __RPC_FAR *strChars) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [out][in] */ BSTR __RPC_FAR *strTarget,
            /* [out][in] */ BSTR __RPC_FAR *strData) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [out][in] */ BSTR __RPC_FAR *strName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXContentHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXContentHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXContentHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_documentLocator )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDocument )( 
            IVBSAXContentHandler __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endDocument )( 
            IVBSAXContentHandler __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startPrefixMapping )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strPrefix,
            /* [out][in] */ BSTR __RPC_FAR *strURI);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endPrefixMapping )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strPrefix);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startElement )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
            /* [out][in] */ BSTR __RPC_FAR *strLocalName,
            /* [out][in] */ BSTR __RPC_FAR *strQName,
            /* [in] */ IVBSAXAttributes __RPC_FAR *oAttributes);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endElement )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
            /* [out][in] */ BSTR __RPC_FAR *strLocalName,
            /* [out][in] */ BSTR __RPC_FAR *strQName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *characters )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strChars);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ignorableWhitespace )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strChars);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *processingInstruction )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strTarget,
            /* [out][in] */ BSTR __RPC_FAR *strData);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *skippedEntity )( 
            IVBSAXContentHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName);
        
        END_INTERFACE
    } IVBSAXContentHandlerVtbl;

    interface IVBSAXContentHandler
    {
        CONST_VTBL struct IVBSAXContentHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXContentHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXContentHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXContentHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXContentHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXContentHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXContentHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXContentHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXContentHandler_putref_documentLocator(This,oLocator)	\
    (This)->lpVtbl -> putref_documentLocator(This,oLocator)

#define IVBSAXContentHandler_startDocument(This)	\
    (This)->lpVtbl -> startDocument(This)

#define IVBSAXContentHandler_endDocument(This)	\
    (This)->lpVtbl -> endDocument(This)

#define IVBSAXContentHandler_startPrefixMapping(This,strPrefix,strURI)	\
    (This)->lpVtbl -> startPrefixMapping(This,strPrefix,strURI)

#define IVBSAXContentHandler_endPrefixMapping(This,strPrefix)	\
    (This)->lpVtbl -> endPrefixMapping(This,strPrefix)

#define IVBSAXContentHandler_startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)	\
    (This)->lpVtbl -> startElement(This,strNamespaceURI,strLocalName,strQName,oAttributes)

#define IVBSAXContentHandler_endElement(This,strNamespaceURI,strLocalName,strQName)	\
    (This)->lpVtbl -> endElement(This,strNamespaceURI,strLocalName,strQName)

#define IVBSAXContentHandler_characters(This,strChars)	\
    (This)->lpVtbl -> characters(This,strChars)

#define IVBSAXContentHandler_ignorableWhitespace(This,strChars)	\
    (This)->lpVtbl -> ignorableWhitespace(This,strChars)

#define IVBSAXContentHandler_processingInstruction(This,strTarget,strData)	\
    (This)->lpVtbl -> processingInstruction(This,strTarget,strData)

#define IVBSAXContentHandler_skippedEntity(This,strName)	\
    (This)->lpVtbl -> skippedEntity(This,strName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_putref_documentLocator_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [in] */ IVBSAXLocator __RPC_FAR *oLocator);


void __RPC_STUB IVBSAXContentHandler_putref_documentLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startDocument_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This);


void __RPC_STUB IVBSAXContentHandler_startDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endDocument_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This);


void __RPC_STUB IVBSAXContentHandler_endDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startPrefixMapping_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strPrefix,
    /* [out][in] */ BSTR __RPC_FAR *strURI);


void __RPC_STUB IVBSAXContentHandler_startPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endPrefixMapping_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strPrefix);


void __RPC_STUB IVBSAXContentHandler_endPrefixMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_startElement_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
    /* [out][in] */ BSTR __RPC_FAR *strLocalName,
    /* [out][in] */ BSTR __RPC_FAR *strQName,
    /* [in] */ IVBSAXAttributes __RPC_FAR *oAttributes);


void __RPC_STUB IVBSAXContentHandler_startElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_endElement_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strNamespaceURI,
    /* [out][in] */ BSTR __RPC_FAR *strLocalName,
    /* [out][in] */ BSTR __RPC_FAR *strQName);


void __RPC_STUB IVBSAXContentHandler_endElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_characters_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strChars);


void __RPC_STUB IVBSAXContentHandler_characters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_ignorableWhitespace_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strChars);


void __RPC_STUB IVBSAXContentHandler_ignorableWhitespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_processingInstruction_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strTarget,
    /* [out][in] */ BSTR __RPC_FAR *strData);


void __RPC_STUB IVBSAXContentHandler_processingInstruction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXContentHandler_skippedEntity_Proxy( 
    IVBSAXContentHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName);


void __RPC_STUB IVBSAXContentHandler_skippedEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXContentHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDTDHandler_INTERFACE_DEFINED__
#define __IVBSAXDTDHandler_INTERFACE_DEFINED__

/* interface IVBSAXDTDHandler */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDTDHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("24fb3297-302d-4620-ba39-3a732d850558")
    IVBSAXDTDHandler : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE notationDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE unparsedEntityDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId,
            /* [out][in] */ BSTR __RPC_FAR *strNotationName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDTDHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXDTDHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXDTDHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *notationDecl )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *unparsedEntityDecl )( 
            IVBSAXDTDHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId,
            /* [out][in] */ BSTR __RPC_FAR *strNotationName);
        
        END_INTERFACE
    } IVBSAXDTDHandlerVtbl;

    interface IVBSAXDTDHandler
    {
        CONST_VTBL struct IVBSAXDTDHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDTDHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDTDHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDTDHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDTDHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDTDHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDTDHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDTDHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDTDHandler_notationDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> notationDecl(This,strName,strPublicId,strSystemId)

#define IVBSAXDTDHandler_unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)	\
    (This)->lpVtbl -> unparsedEntityDecl(This,strName,strPublicId,strSystemId,strNotationName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_notationDecl_Proxy( 
    IVBSAXDTDHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strPublicId,
    /* [out][in] */ BSTR __RPC_FAR *strSystemId);


void __RPC_STUB IVBSAXDTDHandler_notationDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDTDHandler_unparsedEntityDecl_Proxy( 
    IVBSAXDTDHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strPublicId,
    /* [out][in] */ BSTR __RPC_FAR *strSystemId,
    /* [out][in] */ BSTR __RPC_FAR *strNotationName);


void __RPC_STUB IVBSAXDTDHandler_unparsedEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDTDHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXErrorHandler_INTERFACE_DEFINED__
#define __IVBSAXErrorHandler_INTERFACE_DEFINED__

/* interface IVBSAXErrorHandler */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXErrorHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d963d3fe-173c-4862-9095-b92f66995f52")
    IVBSAXErrorHandler : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE error( 
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE fatalError( 
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ignorableWarning( 
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXErrorHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXErrorHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXErrorHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *error )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *fatalError )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ignorableWarning )( 
            IVBSAXErrorHandler __RPC_FAR * This,
            /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
            /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
            /* [in] */ long nErrorCode);
        
        END_INTERFACE
    } IVBSAXErrorHandlerVtbl;

    interface IVBSAXErrorHandler
    {
        CONST_VTBL struct IVBSAXErrorHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXErrorHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXErrorHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXErrorHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXErrorHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXErrorHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXErrorHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXErrorHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXErrorHandler_error(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> error(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_fatalError(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> fatalError(This,oLocator,strErrorMessage,nErrorCode)

#define IVBSAXErrorHandler_ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)	\
    (This)->lpVtbl -> ignorableWarning(This,oLocator,strErrorMessage,nErrorCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_error_Proxy( 
    IVBSAXErrorHandler __RPC_FAR * This,
    /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
    /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_fatalError_Proxy( 
    IVBSAXErrorHandler __RPC_FAR * This,
    /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
    /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_fatalError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXErrorHandler_ignorableWarning_Proxy( 
    IVBSAXErrorHandler __RPC_FAR * This,
    /* [in] */ IVBSAXLocator __RPC_FAR *oLocator,
    /* [out][in] */ BSTR __RPC_FAR *strErrorMessage,
    /* [in] */ long nErrorCode);


void __RPC_STUB IVBSAXErrorHandler_ignorableWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXErrorHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXLexicalHandler_INTERFACE_DEFINED__
#define __IVBSAXLexicalHandler_INTERFACE_DEFINED__

/* interface IVBSAXLexicalHandler */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXLexicalHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("032aac35-8c0e-4d9d-979f-e3b702935576")
    IVBSAXLexicalHandler : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startDTD( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endDTD( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startEntity( 
            /* [out][in] */ BSTR __RPC_FAR *strName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endEntity( 
            /* [out][in] */ BSTR __RPC_FAR *strName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE startCDATA( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE endCDATA( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE comment( 
            /* [out][in] */ BSTR __RPC_FAR *strChars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXLexicalHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXLexicalHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXLexicalHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startDTD )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endDTD )( 
            IVBSAXLexicalHandler __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startEntity )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endEntity )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *startCDATA )( 
            IVBSAXLexicalHandler __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *endCDATA )( 
            IVBSAXLexicalHandler __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *comment )( 
            IVBSAXLexicalHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strChars);
        
        END_INTERFACE
    } IVBSAXLexicalHandlerVtbl;

    interface IVBSAXLexicalHandler
    {
        CONST_VTBL struct IVBSAXLexicalHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXLexicalHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXLexicalHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXLexicalHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXLexicalHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXLexicalHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXLexicalHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXLexicalHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXLexicalHandler_startDTD(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> startDTD(This,strName,strPublicId,strSystemId)

#define IVBSAXLexicalHandler_endDTD(This)	\
    (This)->lpVtbl -> endDTD(This)

#define IVBSAXLexicalHandler_startEntity(This,strName)	\
    (This)->lpVtbl -> startEntity(This,strName)

#define IVBSAXLexicalHandler_endEntity(This,strName)	\
    (This)->lpVtbl -> endEntity(This,strName)

#define IVBSAXLexicalHandler_startCDATA(This)	\
    (This)->lpVtbl -> startCDATA(This)

#define IVBSAXLexicalHandler_endCDATA(This)	\
    (This)->lpVtbl -> endCDATA(This)

#define IVBSAXLexicalHandler_comment(This,strChars)	\
    (This)->lpVtbl -> comment(This,strChars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startDTD_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strPublicId,
    /* [out][in] */ BSTR __RPC_FAR *strSystemId);


void __RPC_STUB IVBSAXLexicalHandler_startDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endDTD_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB IVBSAXLexicalHandler_endDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startEntity_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName);


void __RPC_STUB IVBSAXLexicalHandler_startEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endEntity_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName);


void __RPC_STUB IVBSAXLexicalHandler_endEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_startCDATA_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB IVBSAXLexicalHandler_startCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_endCDATA_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This);


void __RPC_STUB IVBSAXLexicalHandler_endCDATA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXLexicalHandler_comment_Proxy( 
    IVBSAXLexicalHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strChars);


void __RPC_STUB IVBSAXLexicalHandler_comment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXLexicalHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXDeclHandler_INTERFACE_DEFINED__
#define __IVBSAXDeclHandler_INTERFACE_DEFINED__

/* interface IVBSAXDeclHandler */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXDeclHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e8917260-7579-4be1-b5dd-7afbfa6f077b")
    IVBSAXDeclHandler : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE elementDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strModel) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE attributeDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strElementName,
            /* [out][in] */ BSTR __RPC_FAR *strAttributeName,
            /* [out][in] */ BSTR __RPC_FAR *strType,
            /* [out][in] */ BSTR __RPC_FAR *strValueDefault,
            /* [out][in] */ BSTR __RPC_FAR *strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE internalEntityDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE externalEntityDecl( 
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXDeclHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXDeclHandler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXDeclHandler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *elementDecl )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strModel);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *attributeDecl )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strElementName,
            /* [out][in] */ BSTR __RPC_FAR *strAttributeName,
            /* [out][in] */ BSTR __RPC_FAR *strType,
            /* [out][in] */ BSTR __RPC_FAR *strValueDefault,
            /* [out][in] */ BSTR __RPC_FAR *strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *internalEntityDecl )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *externalEntityDecl )( 
            IVBSAXDeclHandler __RPC_FAR * This,
            /* [out][in] */ BSTR __RPC_FAR *strName,
            /* [out][in] */ BSTR __RPC_FAR *strPublicId,
            /* [out][in] */ BSTR __RPC_FAR *strSystemId);
        
        END_INTERFACE
    } IVBSAXDeclHandlerVtbl;

    interface IVBSAXDeclHandler
    {
        CONST_VTBL struct IVBSAXDeclHandlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXDeclHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXDeclHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXDeclHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXDeclHandler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXDeclHandler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXDeclHandler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXDeclHandler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXDeclHandler_elementDecl(This,strName,strModel)	\
    (This)->lpVtbl -> elementDecl(This,strName,strModel)

#define IVBSAXDeclHandler_attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)	\
    (This)->lpVtbl -> attributeDecl(This,strElementName,strAttributeName,strType,strValueDefault,strValue)

#define IVBSAXDeclHandler_internalEntityDecl(This,strName,strValue)	\
    (This)->lpVtbl -> internalEntityDecl(This,strName,strValue)

#define IVBSAXDeclHandler_externalEntityDecl(This,strName,strPublicId,strSystemId)	\
    (This)->lpVtbl -> externalEntityDecl(This,strName,strPublicId,strSystemId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_elementDecl_Proxy( 
    IVBSAXDeclHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strModel);


void __RPC_STUB IVBSAXDeclHandler_elementDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_attributeDecl_Proxy( 
    IVBSAXDeclHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strElementName,
    /* [out][in] */ BSTR __RPC_FAR *strAttributeName,
    /* [out][in] */ BSTR __RPC_FAR *strType,
    /* [out][in] */ BSTR __RPC_FAR *strValueDefault,
    /* [out][in] */ BSTR __RPC_FAR *strValue);


void __RPC_STUB IVBSAXDeclHandler_attributeDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_internalEntityDecl_Proxy( 
    IVBSAXDeclHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strValue);


void __RPC_STUB IVBSAXDeclHandler_internalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXDeclHandler_externalEntityDecl_Proxy( 
    IVBSAXDeclHandler __RPC_FAR * This,
    /* [out][in] */ BSTR __RPC_FAR *strName,
    /* [out][in] */ BSTR __RPC_FAR *strPublicId,
    /* [out][in] */ BSTR __RPC_FAR *strSystemId);


void __RPC_STUB IVBSAXDeclHandler_externalEntityDecl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXDeclHandler_INTERFACE_DEFINED__ */


#ifndef __IVBSAXAttributes_INTERFACE_DEFINED__
#define __IVBSAXAttributes_INTERFACE_DEFINED__

/* interface IVBSAXAttributes */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IVBSAXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10dc0586-132b-4cac-8bb3-db00ac8b7ee0")
    IVBSAXAttributes : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ int __RPC_FAR *nLength) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getURI( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strURI) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getLocalName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strLocalName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getQName( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strQName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getIndexFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int __RPC_FAR *nIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getIndexFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int __RPC_FAR *nIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getType( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getTypeFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR __RPC_FAR *strType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getTypeFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR __RPC_FAR *strType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getValue( 
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getValueFromName( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR __RPC_FAR *strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getValueFromQName( 
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR __RPC_FAR *strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVBSAXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVBSAXAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVBSAXAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *nLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getURI )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strURI);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getLocalName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strLocalName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getQName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strQName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getIndexFromName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ int __RPC_FAR *nIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getIndexFromQName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ int __RPC_FAR *nIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getType )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getTypeFromName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR __RPC_FAR *strType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getTypeFromQName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR __RPC_FAR *strType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValue )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [retval][out] */ BSTR __RPC_FAR *strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValueFromName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [retval][out] */ BSTR __RPC_FAR *strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getValueFromQName )( 
            IVBSAXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strQName,
            /* [retval][out] */ BSTR __RPC_FAR *strValue);
        
        END_INTERFACE
    } IVBSAXAttributesVtbl;

    interface IVBSAXAttributes
    {
        CONST_VTBL struct IVBSAXAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVBSAXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVBSAXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVBSAXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVBSAXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVBSAXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVBSAXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVBSAXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVBSAXAttributes_get_length(This,nLength)	\
    (This)->lpVtbl -> get_length(This,nLength)

#define IVBSAXAttributes_getURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> getURI(This,nIndex,strURI)

#define IVBSAXAttributes_getLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> getLocalName(This,nIndex,strLocalName)

#define IVBSAXAttributes_getQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> getQName(This,nIndex,strQName)

#define IVBSAXAttributes_getIndexFromName(This,strURI,strLocalName,nIndex)	\
    (This)->lpVtbl -> getIndexFromName(This,strURI,strLocalName,nIndex)

#define IVBSAXAttributes_getIndexFromQName(This,strQName,nIndex)	\
    (This)->lpVtbl -> getIndexFromQName(This,strQName,nIndex)

#define IVBSAXAttributes_getType(This,nIndex,strType)	\
    (This)->lpVtbl -> getType(This,nIndex,strType)

#define IVBSAXAttributes_getTypeFromName(This,strURI,strLocalName,strType)	\
    (This)->lpVtbl -> getTypeFromName(This,strURI,strLocalName,strType)

#define IVBSAXAttributes_getTypeFromQName(This,strQName,strType)	\
    (This)->lpVtbl -> getTypeFromQName(This,strQName,strType)

#define IVBSAXAttributes_getValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> getValue(This,nIndex,strValue)

#define IVBSAXAttributes_getValueFromName(This,strURI,strLocalName,strValue)	\
    (This)->lpVtbl -> getValueFromName(This,strURI,strLocalName,strValue)

#define IVBSAXAttributes_getValueFromQName(This,strQName,strValue)	\
    (This)->lpVtbl -> getValueFromQName(This,strQName,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_get_length_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *nLength);


void __RPC_STUB IVBSAXAttributes_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getURI_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strURI);


void __RPC_STUB IVBSAXAttributes_getURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getLocalName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strLocalName);


void __RPC_STUB IVBSAXAttributes_getLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getQName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strQName);


void __RPC_STUB IVBSAXAttributes_getQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ int __RPC_FAR *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getIndexFromQName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ int __RPC_FAR *nIndex);


void __RPC_STUB IVBSAXAttributes_getIndexFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getType_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strType);


void __RPC_STUB IVBSAXAttributes_getType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR __RPC_FAR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getTypeFromQName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR __RPC_FAR *strType);


void __RPC_STUB IVBSAXAttributes_getTypeFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValue_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [retval][out] */ BSTR __RPC_FAR *strValue);


void __RPC_STUB IVBSAXAttributes_getValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [retval][out] */ BSTR __RPC_FAR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IVBSAXAttributes_getValueFromQName_Proxy( 
    IVBSAXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strQName,
    /* [retval][out] */ BSTR __RPC_FAR *strValue);


void __RPC_STUB IVBSAXAttributes_getValueFromQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVBSAXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXWriter_INTERFACE_DEFINED__
#define __IMXWriter_INTERFACE_DEFINED__

/* interface IMXWriter */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4d7ff4ba-1565-4ea8-94e1-6e724a46f98d")
    IMXWriter : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_output( 
            /* [in] */ VARIANT varDestination) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_output( 
            /* [retval][out] */ VARIANT __RPC_FAR *varDestination) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_encoding( 
            /* [in] */ BSTR strEncoding) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_encoding( 
            /* [retval][out] */ BSTR __RPC_FAR *strEncoding) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_byteOrderMark( 
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_byteOrderMark( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fWriteByteOrderMark) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_indent( 
            /* [in] */ VARIANT_BOOL fIndentMode) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_indent( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIndentMode) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_standalone( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_standalone( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_omitXMLDeclaration( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_omitXMLDeclaration( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_version( 
            /* [in] */ BSTR strVersion) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [retval][out] */ BSTR __RPC_FAR *strVersion) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_disableOutputEscaping( 
            /* [in] */ VARIANT_BOOL fValue) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_disableOutputEscaping( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMXWriter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMXWriter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMXWriter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_output )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT varDestination);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_output )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *varDestination);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_encoding )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ BSTR strEncoding);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_encoding )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strEncoding);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_byteOrderMark )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fWriteByteOrderMark);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_byteOrderMark )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fWriteByteOrderMark);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_indent )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIndentMode);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_indent )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIndentMode);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_standalone )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_standalone )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_omitXMLDeclaration )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_omitXMLDeclaration )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_version )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ BSTR strVersion);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *strVersion);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_disableOutputEscaping )( 
            IMXWriter __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fValue);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_disableOutputEscaping )( 
            IMXWriter __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *flush )( 
            IMXWriter __RPC_FAR * This);
        
        END_INTERFACE
    } IMXWriterVtbl;

    interface IMXWriter
    {
        CONST_VTBL struct IMXWriterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXWriter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXWriter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXWriter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXWriter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXWriter_put_output(This,varDestination)	\
    (This)->lpVtbl -> put_output(This,varDestination)

#define IMXWriter_get_output(This,varDestination)	\
    (This)->lpVtbl -> get_output(This,varDestination)

#define IMXWriter_put_encoding(This,strEncoding)	\
    (This)->lpVtbl -> put_encoding(This,strEncoding)

#define IMXWriter_get_encoding(This,strEncoding)	\
    (This)->lpVtbl -> get_encoding(This,strEncoding)

#define IMXWriter_put_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> put_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_get_byteOrderMark(This,fWriteByteOrderMark)	\
    (This)->lpVtbl -> get_byteOrderMark(This,fWriteByteOrderMark)

#define IMXWriter_put_indent(This,fIndentMode)	\
    (This)->lpVtbl -> put_indent(This,fIndentMode)

#define IMXWriter_get_indent(This,fIndentMode)	\
    (This)->lpVtbl -> get_indent(This,fIndentMode)

#define IMXWriter_put_standalone(This,fValue)	\
    (This)->lpVtbl -> put_standalone(This,fValue)

#define IMXWriter_get_standalone(This,fValue)	\
    (This)->lpVtbl -> get_standalone(This,fValue)

#define IMXWriter_put_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> put_omitXMLDeclaration(This,fValue)

#define IMXWriter_get_omitXMLDeclaration(This,fValue)	\
    (This)->lpVtbl -> get_omitXMLDeclaration(This,fValue)

#define IMXWriter_put_version(This,strVersion)	\
    (This)->lpVtbl -> put_version(This,strVersion)

#define IMXWriter_get_version(This,strVersion)	\
    (This)->lpVtbl -> get_version(This,strVersion)

#define IMXWriter_put_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> put_disableOutputEscaping(This,fValue)

#define IMXWriter_get_disableOutputEscaping(This,fValue)	\
    (This)->lpVtbl -> get_disableOutputEscaping(This,fValue)

#define IMXWriter_flush(This)	\
    (This)->lpVtbl -> flush(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_output_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT varDestination);


void __RPC_STUB IMXWriter_put_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_output_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *varDestination);


void __RPC_STUB IMXWriter_get_output_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_encoding_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ BSTR strEncoding);


void __RPC_STUB IMXWriter_put_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_encoding_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strEncoding);


void __RPC_STUB IMXWriter_get_encoding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_byteOrderMark_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fWriteByteOrderMark);


void __RPC_STUB IMXWriter_put_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_byteOrderMark_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fWriteByteOrderMark);


void __RPC_STUB IMXWriter_get_byteOrderMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_indent_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIndentMode);


void __RPC_STUB IMXWriter_put_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_indent_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIndentMode);


void __RPC_STUB IMXWriter_get_indent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_standalone_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_standalone_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);


void __RPC_STUB IMXWriter_get_standalone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_omitXMLDeclaration_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_omitXMLDeclaration_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);


void __RPC_STUB IMXWriter_get_omitXMLDeclaration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_version_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ BSTR strVersion);


void __RPC_STUB IMXWriter_put_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_version_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *strVersion);


void __RPC_STUB IMXWriter_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IMXWriter_put_disableOutputEscaping_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fValue);


void __RPC_STUB IMXWriter_put_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IMXWriter_get_disableOutputEscaping_Proxy( 
    IMXWriter __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fValue);


void __RPC_STUB IMXWriter_get_disableOutputEscaping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXWriter_flush_Proxy( 
    IMXWriter __RPC_FAR * This);


void __RPC_STUB IMXWriter_flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXWriter_INTERFACE_DEFINED__ */


#ifndef __IMXAttributes_INTERFACE_DEFINED__
#define __IMXAttributes_INTERFACE_DEFINED__

/* interface IMXAttributes */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXAttributes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f10d27cc-3ec0-415c-8ed8-77ab1c5e7262")
    IMXAttributes : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addAttribute( 
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addAttributeFromIndex( 
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clear( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ int nIndex) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttributes( 
            /* [in] */ VARIANT varAtts) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setLocalName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setQName( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setType( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setURI( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setValue( 
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXAttributesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMXAttributes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMXAttributes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMXAttributes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addAttribute )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addAttributeFromIndex )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ VARIANT varAtts,
            /* [in] */ int nIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clear )( 
            IMXAttributes __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI,
            /* [in] */ BSTR strLocalName,
            /* [in] */ BSTR strQName,
            /* [in] */ BSTR strType,
            /* [in] */ BSTR strValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttributes )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ VARIANT varAtts);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setLocalName )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strLocalName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setQName )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strQName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setType )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setURI )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strURI);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setValue )( 
            IMXAttributes __RPC_FAR * This,
            /* [in] */ int nIndex,
            /* [in] */ BSTR strValue);
        
        END_INTERFACE
    } IMXAttributesVtbl;

    interface IMXAttributes
    {
        CONST_VTBL struct IMXAttributesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXAttributes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXAttributes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXAttributes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXAttributes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXAttributes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXAttributes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXAttributes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXAttributes_addAttribute(This,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> addAttribute(This,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_addAttributeFromIndex(This,varAtts,nIndex)	\
    (This)->lpVtbl -> addAttributeFromIndex(This,varAtts,nIndex)

#define IMXAttributes_clear(This)	\
    (This)->lpVtbl -> clear(This)

#define IMXAttributes_removeAttribute(This,nIndex)	\
    (This)->lpVtbl -> removeAttribute(This,nIndex)

#define IMXAttributes_setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)	\
    (This)->lpVtbl -> setAttribute(This,nIndex,strURI,strLocalName,strQName,strType,strValue)

#define IMXAttributes_setAttributes(This,varAtts)	\
    (This)->lpVtbl -> setAttributes(This,varAtts)

#define IMXAttributes_setLocalName(This,nIndex,strLocalName)	\
    (This)->lpVtbl -> setLocalName(This,nIndex,strLocalName)

#define IMXAttributes_setQName(This,nIndex,strQName)	\
    (This)->lpVtbl -> setQName(This,nIndex,strQName)

#define IMXAttributes_setType(This,nIndex,strType)	\
    (This)->lpVtbl -> setType(This,nIndex,strType)

#define IMXAttributes_setURI(This,nIndex,strURI)	\
    (This)->lpVtbl -> setURI(This,nIndex,strURI)

#define IMXAttributes_setValue(This,nIndex,strValue)	\
    (This)->lpVtbl -> setValue(This,nIndex,strValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttribute_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_addAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_addAttributeFromIndex_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ VARIANT varAtts,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_addAttributeFromIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_clear_Proxy( 
    IMXAttributes __RPC_FAR * This);


void __RPC_STUB IMXAttributes_clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_removeAttribute_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex);


void __RPC_STUB IMXAttributes_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttribute_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI,
    /* [in] */ BSTR strLocalName,
    /* [in] */ BSTR strQName,
    /* [in] */ BSTR strType,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setAttributes_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ VARIANT varAtts);


void __RPC_STUB IMXAttributes_setAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setLocalName_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strLocalName);


void __RPC_STUB IMXAttributes_setLocalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setQName_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strQName);


void __RPC_STUB IMXAttributes_setQName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setType_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strType);


void __RPC_STUB IMXAttributes_setType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setURI_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strURI);


void __RPC_STUB IMXAttributes_setURI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXAttributes_setValue_Proxy( 
    IMXAttributes __RPC_FAR * This,
    /* [in] */ int nIndex,
    /* [in] */ BSTR strValue);


void __RPC_STUB IMXAttributes_setValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXAttributes_INTERFACE_DEFINED__ */


#ifndef __IMXReaderControl_INTERFACE_DEFINED__
#define __IMXReaderControl_INTERFACE_DEFINED__

/* interface IMXReaderControl */
/* [unique][uuid][nonextensible][oleautomation][dual][local][object] */ 


EXTERN_C const IID IID_IMXReaderControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("808f4e35-8d5a-4fbe-8466-33a41279ed30")
    IMXReaderControl : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE resume( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE suspend( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMXReaderControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMXReaderControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMXReaderControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMXReaderControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMXReaderControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMXReaderControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMXReaderControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMXReaderControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *abort )( 
            IMXReaderControl __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *resume )( 
            IMXReaderControl __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *suspend )( 
            IMXReaderControl __RPC_FAR * This);
        
        END_INTERFACE
    } IMXReaderControlVtbl;

    interface IMXReaderControl
    {
        CONST_VTBL struct IMXReaderControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMXReaderControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMXReaderControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMXReaderControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMXReaderControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMXReaderControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMXReaderControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMXReaderControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMXReaderControl_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IMXReaderControl_resume(This)	\
    (This)->lpVtbl -> resume(This)

#define IMXReaderControl_suspend(This)	\
    (This)->lpVtbl -> suspend(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_abort_Proxy( 
    IMXReaderControl __RPC_FAR * This);


void __RPC_STUB IMXReaderControl_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_resume_Proxy( 
    IMXReaderControl __RPC_FAR * This);


void __RPC_STUB IMXReaderControl_resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IMXReaderControl_suspend_Proxy( 
    IMXReaderControl __RPC_FAR * This);


void __RPC_STUB IMXReaderControl_suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMXReaderControl_INTERFACE_DEFINED__ */


#ifndef __IXMLElementCollection_INTERFACE_DEFINED__
#define __IXMLElementCollection_INTERFACE_DEFINED__

/* interface IXMLElementCollection */
/* [hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElementCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65725580-9B5D-11d0-9BFE-00C04FC99C8E")
    IXMLElementCollection : public IDispatch
    {
    public:
        virtual /* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE put_length( 
            /* [in] */ long v) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [out][retval] */ long __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__newEnum( 
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElementCollection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElementCollection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][hidden][restricted][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in] */ long v);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *item )( 
            IXMLElementCollection __RPC_FAR * This,
            /* [in][optional] */ VARIANT var1,
            /* [in][optional] */ VARIANT var2,
            /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);
        
        END_INTERFACE
    } IXMLElementCollectionVtbl;

    interface IXMLElementCollection
    {
        CONST_VTBL struct IXMLElementCollectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElementCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElementCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElementCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElementCollection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElementCollection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElementCollection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElementCollection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElementCollection_put_length(This,v)	\
    (This)->lpVtbl -> put_length(This,v)

#define IXMLElementCollection_get_length(This,p)	\
    (This)->lpVtbl -> get_length(This,p)

#define IXMLElementCollection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)

#define IXMLElementCollection_item(This,var1,var2,ppDisp)	\
    (This)->lpVtbl -> item(This,var1,var2,ppDisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][hidden][restricted][propput] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_put_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in] */ long v);


void __RPC_STUB IXMLElementCollection_put_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get_length_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *p);


void __RPC_STUB IXMLElementCollection_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_get__newEnum_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);


void __RPC_STUB IXMLElementCollection_get__newEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElementCollection_item_Proxy( 
    IXMLElementCollection __RPC_FAR * This,
    /* [in][optional] */ VARIANT var1,
    /* [in][optional] */ VARIANT var2,
    /* [out][retval] */ IDispatch __RPC_FAR *__RPC_FAR *ppDisp);


void __RPC_STUB IXMLElementCollection_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElementCollection_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument_INTERFACE_DEFINED__
#define __IXMLDocument_INTERFACE_DEFINED__

/* interface IXMLDocument */
/* [hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F52E2B61-18A1-11d1-B105-00805F49916B")
    IXMLDocument : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDocument __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDocument __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_root )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileSize )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileModifiedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileUpdatedDate )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mimeType )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_charset )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdURL )( 
            IXMLDocument __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDocument __RPC_FAR * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);
        
        END_INTERFACE
    } IXMLDocumentVtbl;

    interface IXMLDocument
    {
        CONST_VTBL struct IXMLDocumentVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_root_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileSize_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileModifiedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_fileUpdatedDate_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_URL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_mimeType_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_readyState_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pl);


void __RPC_STUB IXMLDocument_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument_put_charset_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_version_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_doctype_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument_get_dtdURL_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDocument_createElement_Proxy( 
    IXMLDocument __RPC_FAR * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB IXMLDocument_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument_INTERFACE_DEFINED__ */


#ifndef __IXMLDocument2_INTERFACE_DEFINED__
#define __IXMLDocument2_INTERFACE_DEFINED__

/* interface IXMLDocument2 */
/* [hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLDocument2 : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_root( 
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileSize( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileModifiedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_fileUpdatedDate( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_URL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_mimeType( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [out][retval] */ long __RPC_FAR *pl) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_charset( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_charset( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_version( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_doctype( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE get_dtdURL( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE createElement( 
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_async( 
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_async( 
            /* [in] */ VARIANT_BOOL f) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDocument2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDocument2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDocument2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_root )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileSize )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileModifiedDate )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_fileUpdatedDate )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_URL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_mimeType )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *pl);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_charset )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_charset )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_version )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_doctype )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_dtdURL )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *createElement )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT vType,
            /* [in][optional] */ VARIANT var1,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_async )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_async )( 
            IXMLDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL f);
        
        END_INTERFACE
    } IXMLDocument2Vtbl;

    interface IXMLDocument2
    {
        CONST_VTBL struct IXMLDocument2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDocument2_get_root(This,p)	\
    (This)->lpVtbl -> get_root(This,p)

#define IXMLDocument2_get_fileSize(This,p)	\
    (This)->lpVtbl -> get_fileSize(This,p)

#define IXMLDocument2_get_fileModifiedDate(This,p)	\
    (This)->lpVtbl -> get_fileModifiedDate(This,p)

#define IXMLDocument2_get_fileUpdatedDate(This,p)	\
    (This)->lpVtbl -> get_fileUpdatedDate(This,p)

#define IXMLDocument2_get_URL(This,p)	\
    (This)->lpVtbl -> get_URL(This,p)

#define IXMLDocument2_put_URL(This,p)	\
    (This)->lpVtbl -> put_URL(This,p)

#define IXMLDocument2_get_mimeType(This,p)	\
    (This)->lpVtbl -> get_mimeType(This,p)

#define IXMLDocument2_get_readyState(This,pl)	\
    (This)->lpVtbl -> get_readyState(This,pl)

#define IXMLDocument2_get_charset(This,p)	\
    (This)->lpVtbl -> get_charset(This,p)

#define IXMLDocument2_put_charset(This,p)	\
    (This)->lpVtbl -> put_charset(This,p)

#define IXMLDocument2_get_version(This,p)	\
    (This)->lpVtbl -> get_version(This,p)

#define IXMLDocument2_get_doctype(This,p)	\
    (This)->lpVtbl -> get_doctype(This,p)

#define IXMLDocument2_get_dtdURL(This,p)	\
    (This)->lpVtbl -> get_dtdURL(This,p)

#define IXMLDocument2_createElement(This,vType,var1,ppElem)	\
    (This)->lpVtbl -> createElement(This,vType,var1,ppElem)

#define IXMLDocument2_get_async(This,pf)	\
    (This)->lpVtbl -> get_async(This,pf)

#define IXMLDocument2_put_async(This,f)	\
    (This)->lpVtbl -> put_async(This,f)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_root_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_root_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileSize_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileModifiedDate_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileModifiedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_fileUpdatedDate_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_fileUpdatedDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_URL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_URL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_mimeType_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_mimeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_readyState_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *pl);


void __RPC_STUB IXMLDocument2_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_charset_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_charset_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLDocument2_put_charset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_version_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_doctype_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_doctype_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][hidden][restricted][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_dtdURL_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLDocument2_get_dtdURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_createElement_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ VARIANT vType,
    /* [in][optional] */ VARIANT var1,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppElem);


void __RPC_STUB IXMLDocument2_createElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_get_async_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [out][retval] */ VARIANT_BOOL __RPC_FAR *pf);


void __RPC_STUB IXMLDocument2_get_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDocument2_put_async_Proxy( 
    IXMLDocument2 __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL f);


void __RPC_STUB IXMLDocument2_put_async_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDocument2_INTERFACE_DEFINED__ */


#ifndef __IXMLElement_INTERFACE_DEFINED__
#define __IXMLElement_INTERFACE_DEFINED__

/* interface IXMLElement */
/* [hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")
    IXMLElement : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long __RPC_FAR *plType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement __RPC_FAR *pChildElem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElement __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElement __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElement __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tagName )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_children )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *plType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLElement __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLElement __RPC_FAR * This,
            /* [in] */ IXMLElement __RPC_FAR *pChildElem);
        
        END_INTERFACE
    } IXMLElementVtbl;

    interface IXMLElement
    {
        CONST_VTBL struct IXMLElementVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_tagName_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_parent_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElement __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IXMLElement_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_setAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_getAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);


void __RPC_STUB IXMLElement_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeAttribute_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_children_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_type_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *plType);


void __RPC_STUB IXMLElement_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement_get_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement_put_text_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_addChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement_removeChild_Proxy( 
    IXMLElement __RPC_FAR * This,
    /* [in] */ IXMLElement __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElement_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement_INTERFACE_DEFINED__ */


#ifndef __IXMLElement2_INTERFACE_DEFINED__
#define __IXMLElement2_INTERFACE_DEFINED__

/* interface IXMLElement2 */
/* [hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLElement2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")
    IXMLElement2 : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_tagName( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_tagName( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_parent( 
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAttribute( 
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAttribute( 
            /* [in] */ BSTR strPropertyName) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_children( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_type( 
            /* [out][retval] */ long __RPC_FAR *plType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_text( 
            /* [out][retval] */ BSTR __RPC_FAR *p) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_text( 
            /* [in] */ BSTR p) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE addChild( 
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeChild( 
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_attributes( 
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLElement2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLElement2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLElement2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_tagName )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_tagName )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_parent )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ VARIANT PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName,
            /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAttribute )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR strPropertyName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_children )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_type )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ long __RPC_FAR *plType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_text )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *p);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_text )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ BSTR p);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *addChild )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
            long lIndex,
            long lReserved);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeChild )( 
            IXMLElement2 __RPC_FAR * This,
            /* [in] */ IXMLElement2 __RPC_FAR *pChildElem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_attributes )( 
            IXMLElement2 __RPC_FAR * This,
            /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);
        
        END_INTERFACE
    } IXMLElement2Vtbl;

    interface IXMLElement2
    {
        CONST_VTBL struct IXMLElement2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLElement2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLElement2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLElement2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLElement2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLElement2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLElement2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLElement2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLElement2_get_tagName(This,p)	\
    (This)->lpVtbl -> get_tagName(This,p)

#define IXMLElement2_put_tagName(This,p)	\
    (This)->lpVtbl -> put_tagName(This,p)

#define IXMLElement2_get_parent(This,ppParent)	\
    (This)->lpVtbl -> get_parent(This,ppParent)

#define IXMLElement2_setAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> setAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_getAttribute(This,strPropertyName,PropertyValue)	\
    (This)->lpVtbl -> getAttribute(This,strPropertyName,PropertyValue)

#define IXMLElement2_removeAttribute(This,strPropertyName)	\
    (This)->lpVtbl -> removeAttribute(This,strPropertyName)

#define IXMLElement2_get_children(This,pp)	\
    (This)->lpVtbl -> get_children(This,pp)

#define IXMLElement2_get_type(This,plType)	\
    (This)->lpVtbl -> get_type(This,plType)

#define IXMLElement2_get_text(This,p)	\
    (This)->lpVtbl -> get_text(This,p)

#define IXMLElement2_put_text(This,p)	\
    (This)->lpVtbl -> put_text(This,p)

#define IXMLElement2_addChild(This,pChildElem,lIndex,lReserved)	\
    (This)->lpVtbl -> addChild(This,pChildElem,lIndex,lReserved)

#define IXMLElement2_removeChild(This,pChildElem)	\
    (This)->lpVtbl -> removeChild(This,pChildElem)

#define IXMLElement2_get_attributes(This,pp)	\
    (This)->lpVtbl -> get_attributes(This,pp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_tagName_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement2_get_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_tagName_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_tagName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_parent_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElement2 __RPC_FAR *__RPC_FAR *ppParent);


void __RPC_STUB IXMLElement2_get_parent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_setAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [in] */ VARIANT PropertyValue);


void __RPC_STUB IXMLElement2_setAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_getAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName,
    /* [out][retval] */ VARIANT __RPC_FAR *PropertyValue);


void __RPC_STUB IXMLElement2_getAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeAttribute_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR strPropertyName);


void __RPC_STUB IXMLElement2_removeAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_children_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement2_get_children_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_type_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ long __RPC_FAR *plType);


void __RPC_STUB IXMLElement2_get_type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_text_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *p);


void __RPC_STUB IXMLElement2_get_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLElement2_put_text_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ BSTR p);


void __RPC_STUB IXMLElement2_put_text_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_addChild_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ IXMLElement2 __RPC_FAR *pChildElem,
    long lIndex,
    long lReserved);


void __RPC_STUB IXMLElement2_addChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLElement2_removeChild_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [in] */ IXMLElement2 __RPC_FAR *pChildElem);


void __RPC_STUB IXMLElement2_removeChild_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLElement2_get_attributes_Proxy( 
    IXMLElement2 __RPC_FAR * This,
    /* [out][retval] */ IXMLElementCollection __RPC_FAR *__RPC_FAR *pp);


void __RPC_STUB IXMLElement2_get_attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLElement2_INTERFACE_DEFINED__ */


#ifndef __IXMLAttribute_INTERFACE_DEFINED__
#define __IXMLAttribute_INTERFACE_DEFINED__

/* interface IXMLAttribute */
/* [hidden][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLAttribute;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")
    IXMLAttribute : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_name( 
            /* [out][retval] */ BSTR __RPC_FAR *n) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_value( 
            /* [out][retval] */ BSTR __RPC_FAR *v) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLAttributeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLAttribute __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLAttribute __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLAttribute __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_name )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *n);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_value )( 
            IXMLAttribute __RPC_FAR * This,
            /* [out][retval] */ BSTR __RPC_FAR *v);
        
        END_INTERFACE
    } IXMLAttributeVtbl;

    interface IXMLAttribute
    {
        CONST_VTBL struct IXMLAttributeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLAttribute_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLAttribute_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLAttribute_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLAttribute_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLAttribute_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLAttribute_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLAttribute_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLAttribute_get_name(This,n)	\
    (This)->lpVtbl -> get_name(This,n)

#define IXMLAttribute_get_value(This,v)	\
    (This)->lpVtbl -> get_value(This,v)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_name_Proxy( 
    IXMLAttribute __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *n);


void __RPC_STUB IXMLAttribute_get_name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLAttribute_get_value_Proxy( 
    IXMLAttribute __RPC_FAR * This,
    /* [out][retval] */ BSTR __RPC_FAR *v);


void __RPC_STUB IXMLAttribute_get_value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLAttribute_INTERFACE_DEFINED__ */


#ifndef __IXMLError_INTERFACE_DEFINED__
#define __IXMLError_INTERFACE_DEFINED__

/* interface IXMLError */
/* [hidden][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLError;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")
    IXMLError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            XML_ERROR __RPC_FAR *pErrorReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLError __RPC_FAR * This,
            XML_ERROR __RPC_FAR *pErrorReturn);
        
        END_INTERFACE
    } IXMLErrorVtbl;

    interface IXMLError
    {
        CONST_VTBL struct IXMLErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLError_GetErrorInfo(This,pErrorReturn)	\
    (This)->lpVtbl -> GetErrorInfo(This,pErrorReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLError_GetErrorInfo_Proxy( 
    IXMLError __RPC_FAR * This,
    XML_ERROR __RPC_FAR *pErrorReturn);


void __RPC_STUB IXMLError_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLError_INTERFACE_DEFINED__ */


#ifndef __IXMLDOMSelection_INTERFACE_DEFINED__
#define __IXMLDOMSelection_INTERFACE_DEFINED__

/* interface IXMLDOMSelection */
/* [unique][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IXMLDOMSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA634FC7-5888-44a7-A257-3A47150D3A0E")
    IXMLDOMSelection : public IXMLDOMNodeList
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_expr( 
            /* [retval][out] */ BSTR __RPC_FAR *expression) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_expr( 
            /* [in] */ BSTR expression) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_context( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode) = 0;
        
        virtual /* [id][propputref] */ HRESULT STDMETHODCALLTYPE putref_context( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE peekNode( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE matches( 
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeNext( 
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE removeAll( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE clone( 
            /* [retval][out] */ IXMLDOMSelection __RPC_FAR *__RPC_FAR *ppNode) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getProperty( 
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setProperty( 
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLDOMSelectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLDOMSelection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLDOMSelection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_item )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ long index,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *listItem);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_length )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *listLength);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *nextNode )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *nextItem);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *reset )( 
            IXMLDOMSelection __RPC_FAR * This);
        
        /* [id][hidden][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__newEnum )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [out][retval] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_expr )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *expression);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_expr )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ BSTR expression);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_context )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);
        
        /* [id][propputref] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_context )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *peekNode )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *matches )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeNext )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *removeAll )( 
            IXMLDOMSelection __RPC_FAR * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *clone )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMSelection __RPC_FAR *__RPC_FAR *ppNode);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getProperty )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setProperty )( 
            IXMLDOMSelection __RPC_FAR * This,
            /* [in] */ BSTR name,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IXMLDOMSelectionVtbl;

    interface IXMLDOMSelection
    {
        CONST_VTBL struct IXMLDOMSelectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLDOMSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLDOMSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLDOMSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLDOMSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLDOMSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLDOMSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLDOMSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLDOMSelection_get_item(This,index,listItem)	\
    (This)->lpVtbl -> get_item(This,index,listItem)

#define IXMLDOMSelection_get_length(This,listLength)	\
    (This)->lpVtbl -> get_length(This,listLength)

#define IXMLDOMSelection_nextNode(This,nextItem)	\
    (This)->lpVtbl -> nextNode(This,nextItem)

#define IXMLDOMSelection_reset(This)	\
    (This)->lpVtbl -> reset(This)

#define IXMLDOMSelection_get__newEnum(This,ppUnk)	\
    (This)->lpVtbl -> get__newEnum(This,ppUnk)


#define IXMLDOMSelection_get_expr(This,expression)	\
    (This)->lpVtbl -> get_expr(This,expression)

#define IXMLDOMSelection_put_expr(This,expression)	\
    (This)->lpVtbl -> put_expr(This,expression)

#define IXMLDOMSelection_get_context(This,ppNode)	\
    (This)->lpVtbl -> get_context(This,ppNode)

#define IXMLDOMSelection_putref_context(This,pNode)	\
    (This)->lpVtbl -> putref_context(This,pNode)

#define IXMLDOMSelection_peekNode(This,ppNode)	\
    (This)->lpVtbl -> peekNode(This,ppNode)

#define IXMLDOMSelection_matches(This,pNode,ppNode)	\
    (This)->lpVtbl -> matches(This,pNode,ppNode)

#define IXMLDOMSelection_removeNext(This,ppNode)	\
    (This)->lpVtbl -> removeNext(This,ppNode)

#define IXMLDOMSelection_removeAll(This)	\
    (This)->lpVtbl -> removeAll(This)

#define IXMLDOMSelection_clone(This,ppNode)	\
    (This)->lpVtbl -> clone(This,ppNode)

#define IXMLDOMSelection_getProperty(This,name,value)	\
    (This)->lpVtbl -> getProperty(This,name,value)

#define IXMLDOMSelection_setProperty(This,name,value)	\
    (This)->lpVtbl -> setProperty(This,name,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_expr_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *expression);


void __RPC_STUB IXMLDOMSelection_get_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_put_expr_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [in] */ BSTR expression);


void __RPC_STUB IXMLDOMSelection_put_expr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_get_context_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);


void __RPC_STUB IXMLDOMSelection_get_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propputref] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_putref_context_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode);


void __RPC_STUB IXMLDOMSelection_putref_context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_peekNode_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);


void __RPC_STUB IXMLDOMSelection_peekNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_matches_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [in] */ IXMLDOMNode __RPC_FAR *pNode,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);


void __RPC_STUB IXMLDOMSelection_matches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeNext_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMNode __RPC_FAR *__RPC_FAR *ppNode);


void __RPC_STUB IXMLDOMSelection_removeNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_removeAll_Proxy( 
    IXMLDOMSelection __RPC_FAR * This);


void __RPC_STUB IXMLDOMSelection_removeAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_clone_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMSelection __RPC_FAR *__RPC_FAR *ppNode);


void __RPC_STUB IXMLDOMSelection_clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_getProperty_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [retval][out] */ VARIANT __RPC_FAR *value);


void __RPC_STUB IXMLDOMSelection_getProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLDOMSelection_setProperty_Proxy( 
    IXMLDOMSelection __RPC_FAR * This,
    /* [in] */ BSTR name,
    /* [in] */ VARIANT value);


void __RPC_STUB IXMLDOMSelection_setProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLDOMSelection_INTERFACE_DEFINED__ */


#ifndef __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__
#define __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__

/* dispinterface XMLDOMDocumentEvents */
/* [uuid][hidden] */ 


EXTERN_C const IID DIID_XMLDOMDocumentEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("3efaa427-272f-11d2-836f-0000f87a7782")
    XMLDOMDocumentEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct XMLDOMDocumentEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            XMLDOMDocumentEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            XMLDOMDocumentEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            XMLDOMDocumentEvents __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } XMLDOMDocumentEventsVtbl;

    interface XMLDOMDocumentEvents
    {
        CONST_VTBL struct XMLDOMDocumentEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define XMLDOMDocumentEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define XMLDOMDocumentEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define XMLDOMDocumentEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define XMLDOMDocumentEvents_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define XMLDOMDocumentEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define XMLDOMDocumentEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define XMLDOMDocumentEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __XMLDOMDocumentEvents_DISPINTERFACE_DEFINED__ */


#ifndef __IDSOControl_INTERFACE_DEFINED__
#define __IDSOControl_INTERFACE_DEFINED__

/* interface IDSOControl */
/* [unique][hidden][nonextensible][oleautomation][dual][uuid][object][local] */ 


EXTERN_C const IID IID_IDSOControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("310afa62-0575-11d2-9ca9-0060b0ec3d39")
    IDSOControl : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMLDocument( 
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMLDocument( 
            /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_JavaDSOCompatible( 
            /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_JavaDSOCompatible( 
            /* [in] */ BOOL fJavaDSOCompatible) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long __RPC_FAR *state) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSOControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDSOControl __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDSOControl __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDSOControl __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMLDocument )( 
            IDSOControl __RPC_FAR * This,
            /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMLDocument )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_JavaDSOCompatible )( 
            IDSOControl __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_JavaDSOCompatible )( 
            IDSOControl __RPC_FAR * This,
            /* [in] */ BOOL fJavaDSOCompatible);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IDSOControl __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *state);
        
        END_INTERFACE
    } IDSOControlVtbl;

    interface IDSOControl
    {
        CONST_VTBL struct IDSOControlVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSOControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDSOControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDSOControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDSOControl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDSOControl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDSOControl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDSOControl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDSOControl_get_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> get_XMLDocument(This,ppDoc)

#define IDSOControl_put_XMLDocument(This,ppDoc)	\
    (This)->lpVtbl -> put_XMLDocument(This,ppDoc)

#define IDSOControl_get_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> get_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_put_JavaDSOCompatible(This,fJavaDSOCompatible)	\
    (This)->lpVtbl -> put_JavaDSOCompatible(This,fJavaDSOCompatible)

#define IDSOControl_get_readyState(This,state)	\
    (This)->lpVtbl -> get_readyState(This,state)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_XMLDocument_Proxy( 
    IDSOControl __RPC_FAR * This,
    /* [retval][out] */ IXMLDOMDocument __RPC_FAR *__RPC_FAR *ppDoc);


void __RPC_STUB IDSOControl_get_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_XMLDocument_Proxy( 
    IDSOControl __RPC_FAR * This,
    /* [in] */ IXMLDOMDocument __RPC_FAR *ppDoc);


void __RPC_STUB IDSOControl_put_XMLDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_JavaDSOCompatible_Proxy( 
    IDSOControl __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *fJavaDSOCompatible);


void __RPC_STUB IDSOControl_get_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDSOControl_put_JavaDSOCompatible_Proxy( 
    IDSOControl __RPC_FAR * This,
    /* [in] */ BOOL fJavaDSOCompatible);


void __RPC_STUB IDSOControl_put_JavaDSOCompatible_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDSOControl_get_readyState_Proxy( 
    IDSOControl __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *state);


void __RPC_STUB IDSOControl_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDSOControl_INTERFACE_DEFINED__ */


#ifndef __IXMLHTTPRequest_INTERFACE_DEFINED__
#define __IXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IXMLHTTPRequest */
/* [unique][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED8C108D-4349-11D2-91A4-00C04F7969E8")
    IXMLHTTPRequest : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE open( 
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setRequestHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getResponseHeader( 
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getAllResponseHeaders( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE send( 
            /* [optional][in] */ VARIANT varBody) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE abort( void) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_status( 
            /* [retval][out] */ long __RPC_FAR *plStatus) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_statusText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_responseXML( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_responseText( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBody) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_responseBody( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_responseStream( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_readyState( 
            /* [retval][out] */ long __RPC_FAR *plState) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_onreadystatechange( 
            /* [in] */ IDispatch __RPC_FAR *pReadyStateSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLHTTPRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLHTTPRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *open )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setRequestHeader )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getResponseHeader )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAllResponseHeaders )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *send )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *abort )( 
            IXMLHTTPRequest __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plStatus);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_statusText )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseXML )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseText )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseBody )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseStream )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plState);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onreadystatechange )( 
            IXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pReadyStateSink);
        
        END_INTERFACE
    } IXMLHTTPRequestVtbl;

    interface IXMLHTTPRequest
    {
        CONST_VTBL struct IXMLHTTPRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_open_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrMethod,
    /* [in] */ BSTR bstrUrl,
    /* [optional][in] */ VARIANT varAsync,
    /* [optional][in] */ VARIANT bstrUser,
    /* [optional][in] */ VARIANT bstrPassword);


void __RPC_STUB IXMLHTTPRequest_open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_setRequestHeader_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrHeader,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IXMLHTTPRequest_setRequestHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getResponseHeader_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrHeader,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);


void __RPC_STUB IXMLHTTPRequest_getResponseHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_getAllResponseHeaders_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders);


void __RPC_STUB IXMLHTTPRequest_getAllResponseHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_send_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [optional][in] */ VARIANT varBody);


void __RPC_STUB IXMLHTTPRequest_send_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_abort_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This);


void __RPC_STUB IXMLHTTPRequest_abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_status_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plStatus);


void __RPC_STUB IXMLHTTPRequest_get_status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_statusText_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);


void __RPC_STUB IXMLHTTPRequest_get_statusText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseXML_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody);


void __RPC_STUB IXMLHTTPRequest_get_responseXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseText_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrBody);


void __RPC_STUB IXMLHTTPRequest_get_responseText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseBody_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_responseStream_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);


void __RPC_STUB IXMLHTTPRequest_get_responseStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_get_readyState_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plState);


void __RPC_STUB IXMLHTTPRequest_get_readyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IXMLHTTPRequest_put_onreadystatechange_Proxy( 
    IXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ IDispatch __RPC_FAR *pReadyStateSink);


void __RPC_STUB IXMLHTTPRequest_put_onreadystatechange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLHTTPRequest_INTERFACE_DEFINED__ */


#ifndef __IServerXMLHTTPRequest_INTERFACE_DEFINED__
#define __IServerXMLHTTPRequest_INTERFACE_DEFINED__

/* interface IServerXMLHTTPRequest */
/* [unique][oleautomation][dual][uuid][object] */ 


EXTERN_C const IID IID_IServerXMLHTTPRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2e9196bf-13ba-4dd4-91ca-6c571f281495")
    IServerXMLHTTPRequest : public IXMLHTTPRequest
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setTimeouts( 
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE waitForResponse( 
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE getOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT __RPC_FAR *value) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE setOption( 
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerXMLHTTPRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServerXMLHTTPRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServerXMLHTTPRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *open )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrMethod,
            /* [in] */ BSTR bstrUrl,
            /* [optional][in] */ VARIANT varAsync,
            /* [optional][in] */ VARIANT bstrUser,
            /* [optional][in] */ VARIANT bstrPassword);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setRequestHeader )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [in] */ BSTR bstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getResponseHeader )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrHeader,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrValue);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getAllResponseHeaders )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrHeaders);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *send )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [optional][in] */ VARIANT varBody);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *abort )( 
            IServerXMLHTTPRequest __RPC_FAR * This);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_status )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plStatus);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_statusText )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatus);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseXML )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseText )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseBody )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_responseStream )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarBody);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_readyState )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plState);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_onreadystatechange )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ IDispatch __RPC_FAR *pReadyStateSink);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setTimeouts )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ long resolveTimeout,
            /* [in] */ long connectTimeout,
            /* [in] */ long sendTimeout,
            /* [in] */ long receiveTimeout);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *waitForResponse )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [optional][in] */ VARIANT timeoutInSeconds,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *getOption )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [retval][out] */ VARIANT __RPC_FAR *value);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *setOption )( 
            IServerXMLHTTPRequest __RPC_FAR * This,
            /* [in] */ SERVERXMLHTTP_OPTION option,
            /* [in] */ VARIANT value);
        
        END_INTERFACE
    } IServerXMLHTTPRequestVtbl;

    interface IServerXMLHTTPRequest
    {
        CONST_VTBL struct IServerXMLHTTPRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServerXMLHTTPRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServerXMLHTTPRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServerXMLHTTPRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServerXMLHTTPRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServerXMLHTTPRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServerXMLHTTPRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServerXMLHTTPRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServerXMLHTTPRequest_open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)	\
    (This)->lpVtbl -> open(This,bstrMethod,bstrUrl,varAsync,bstrUser,bstrPassword)

#define IServerXMLHTTPRequest_setRequestHeader(This,bstrHeader,bstrValue)	\
    (This)->lpVtbl -> setRequestHeader(This,bstrHeader,bstrValue)

#define IServerXMLHTTPRequest_getResponseHeader(This,bstrHeader,pbstrValue)	\
    (This)->lpVtbl -> getResponseHeader(This,bstrHeader,pbstrValue)

#define IServerXMLHTTPRequest_getAllResponseHeaders(This,pbstrHeaders)	\
    (This)->lpVtbl -> getAllResponseHeaders(This,pbstrHeaders)

#define IServerXMLHTTPRequest_send(This,varBody)	\
    (This)->lpVtbl -> send(This,varBody)

#define IServerXMLHTTPRequest_abort(This)	\
    (This)->lpVtbl -> abort(This)

#define IServerXMLHTTPRequest_get_status(This,plStatus)	\
    (This)->lpVtbl -> get_status(This,plStatus)

#define IServerXMLHTTPRequest_get_statusText(This,pbstrStatus)	\
    (This)->lpVtbl -> get_statusText(This,pbstrStatus)

#define IServerXMLHTTPRequest_get_responseXML(This,ppBody)	\
    (This)->lpVtbl -> get_responseXML(This,ppBody)

#define IServerXMLHTTPRequest_get_responseText(This,pbstrBody)	\
    (This)->lpVtbl -> get_responseText(This,pbstrBody)

#define IServerXMLHTTPRequest_get_responseBody(This,pvarBody)	\
    (This)->lpVtbl -> get_responseBody(This,pvarBody)

#define IServerXMLHTTPRequest_get_responseStream(This,pvarBody)	\
    (This)->lpVtbl -> get_responseStream(This,pvarBody)

#define IServerXMLHTTPRequest_get_readyState(This,plState)	\
    (This)->lpVtbl -> get_readyState(This,plState)

#define IServerXMLHTTPRequest_put_onreadystatechange(This,pReadyStateSink)	\
    (This)->lpVtbl -> put_onreadystatechange(This,pReadyStateSink)


#define IServerXMLHTTPRequest_setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)	\
    (This)->lpVtbl -> setTimeouts(This,resolveTimeout,connectTimeout,sendTimeout,receiveTimeout)

#define IServerXMLHTTPRequest_waitForResponse(This,timeoutInSeconds,isSuccessful)	\
    (This)->lpVtbl -> waitForResponse(This,timeoutInSeconds,isSuccessful)

#define IServerXMLHTTPRequest_getOption(This,option,value)	\
    (This)->lpVtbl -> getOption(This,option,value)

#define IServerXMLHTTPRequest_setOption(This,option,value)	\
    (This)->lpVtbl -> setOption(This,option,value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setTimeouts_Proxy( 
    IServerXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ long resolveTimeout,
    /* [in] */ long connectTimeout,
    /* [in] */ long sendTimeout,
    /* [in] */ long receiveTimeout);


void __RPC_STUB IServerXMLHTTPRequest_setTimeouts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_waitForResponse_Proxy( 
    IServerXMLHTTPRequest __RPC_FAR * This,
    /* [optional][in] */ VARIANT timeoutInSeconds,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *isSuccessful);


void __RPC_STUB IServerXMLHTTPRequest_waitForResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_getOption_Proxy( 
    IServerXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [retval][out] */ VARIANT __RPC_FAR *value);


void __RPC_STUB IServerXMLHTTPRequest_getOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE IServerXMLHTTPRequest_setOption_Proxy( 
    IServerXMLHTTPRequest __RPC_FAR * This,
    /* [in] */ SERVERXMLHTTP_OPTION option,
    /* [in] */ VARIANT value);


void __RPC_STUB IServerXMLHTTPRequest_setOption_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServerXMLHTTPRequest_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_DOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF90-7B36-11d2-B20E-00C04F983E60")
DOMDocument;
#endif

EXTERN_C const CLSID CLSID_DOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1b-c551-11d3-89b9-0000f81fe221")
DOMDocument26;
#endif

EXTERN_C const CLSID CLSID_DOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f32-c551-11d3-89b9-0000f81fe221")
DOMDocument30;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F12-9C73-11D3-B32E-00C04F990BB4")
FreeThreadedDOMDocument;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1c-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument26;
#endif

EXTERN_C const CLSID CLSID_FreeThreadedDOMDocument30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f33-c551-11d3-89b9-0000f81fe221")
FreeThreadedDOMDocument30;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache;

#ifdef __cplusplus

class DECLSPEC_UUID("373984c9-b845-449b-91e7-45ac83036ade")
XMLSchemaCache;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1d-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache26;
#endif

EXTERN_C const CLSID CLSID_XMLSchemaCache30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f34-c551-11d3-89b9-0000f81fe221")
XMLSchemaCache30;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate;

#ifdef __cplusplus

class DECLSPEC_UUID("2933BF94-7B36-11d2-B20E-00C04F983E60")
XSLTemplate;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f21-c551-11d3-89b9-0000f81fe221")
XSLTemplate26;
#endif

EXTERN_C const CLSID CLSID_XSLTemplate30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f36-c551-11d3-89b9-0000f81fe221")
XSLTemplate30;
#endif

EXTERN_C const CLSID CLSID_DSOControl;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F14-9C73-11D3-B32E-00C04F990BB4")
DSOControl;
#endif

EXTERN_C const CLSID CLSID_DSOControl26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1f-c551-11d3-89b9-0000f81fe221")
DSOControl26;
#endif

EXTERN_C const CLSID CLSID_DSOControl30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f39-c551-11d3-89b9-0000f81fe221")
DSOControl30;
#endif

EXTERN_C const CLSID CLSID_XMLHTTPRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("ED8C108E-4349-11D2-91A4-00C04F7969E8")
XMLHTTPRequest;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("F6D90F16-9C73-11D3-B32E-00C04F990BB4")
XMLHTTP;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP26;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f1e-c551-11d3-89b9-0000f81fe221")
XMLHTTP26;
#endif

EXTERN_C const CLSID CLSID_XMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("f5078f35-c551-11d3-89b9-0000f81fe221")
XMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP;

#ifdef __cplusplus

class DECLSPEC_UUID("afba6b42-5692-48ea-8141-dc517dcf0ef1")
ServerXMLHTTP;
#endif

EXTERN_C const CLSID CLSID_ServerXMLHTTP30;

#ifdef __cplusplus

class DECLSPEC_UUID("afb40ffd-b609-40a3-9828-f88bbe11e4e3")
ServerXMLHTTP30;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader;

#ifdef __cplusplus

class DECLSPEC_UUID("079aa557-4a18-424a-8eee-e39f0a8d41b9")
SAXXMLReader;
#endif

EXTERN_C const CLSID CLSID_SAXXMLReader30;

#ifdef __cplusplus

class DECLSPEC_UUID("3124c396-fb13-4836-a6ad-1317f1713688")
SAXXMLReader30;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter;

#ifdef __cplusplus

class DECLSPEC_UUID("fc220ad8-a72a-4ee8-926e-0b7ad152a020")
MXXMLWriter;
#endif

EXTERN_C const CLSID CLSID_MXXMLWriter30;

#ifdef __cplusplus

class DECLSPEC_UUID("3d813dfe-6c91-4a4e-8f41-04346a841d9c")
MXXMLWriter30;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes;

#ifdef __cplusplus

class DECLSPEC_UUID("4dd441ad-526d-4a77-9f1b-9841ed802fb0")
SAXAttributes;
#endif

EXTERN_C const CLSID CLSID_SAXAttributes30;

#ifdef __cplusplus

class DECLSPEC_UUID("3e784a01-f3ae-4dc0-9354-9526b9370eba")
SAXAttributes30;
#endif

EXTERN_C const CLSID CLSID_XMLDocument;

#ifdef __cplusplus

class DECLSPEC_UUID("CFC399AF-D876-11d0-9C10-00C04FC99C8E")
XMLDocument;
#endif
#endif /* __MSXML2_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_msxml2_0141 */
/* [local] */ 

//----------------------------
// MSXML SPECIFIC ERROR CODES 
//----------------------------
#define E_XML_NOTWF 0xC00CE223L  // Validate failed because the document is not well formed.
#define E_XML_NODTD 0xC00CE224L  // Validate failed because a DTD/Schema was not specified in the document.
#define E_XML_INVALID 0xC00CE225L  // Validate failed because of a DTD/Schema violation.
#ifdef __USE_MSXML2_NAMESPACE__
}
#endif


extern RPC_IF_HANDLE __MIDL_itf_msxml2_0141_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msxml2_0141_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\mtype.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

#ifndef __MTYPE__
#define __MTYPE__

/* Helper class that derived pin objects can use to compare media
   types etc. Has same data members as the struct AM_MEDIA_TYPE defined
   in the streams IDL file, but also has (non-virtual) functions */

class CMediaType : public _AMMediaType {

public:

    ~CMediaType();
    CMediaType();
    CMediaType(const GUID * majortype);
    CMediaType(const AM_MEDIA_TYPE&);
    CMediaType(const CMediaType&);

    CMediaType& operator=(const CMediaType&);
    CMediaType& operator=(const AM_MEDIA_TYPE&);

    BOOL operator == (const CMediaType&) const;
    BOOL operator != (const CMediaType&) const;

    BOOL IsValid() const;

    const GUID *Type() const { return &majortype;} ;
    void SetType(const GUID *);
    const GUID *Subtype() const { return &subtype;} ;
    void SetSubtype(const GUID *);

    BOOL IsFixedSize() const {return bFixedSizeSamples; };
    BOOL IsTemporalCompressed() const {return bTemporalCompression; };
    ULONG GetSampleSize() const;

    void SetSampleSize(ULONG sz);
    void SetVariableSize();
    void SetTemporalCompression(BOOL bCompressed);

    // read/write pointer to format - can't change length without
    // calling SetFormat, AllocFormatBuffer or ReallocFormatBuffer

    BYTE*   Format() const {return pbFormat; };
    ULONG   FormatLength() const { return cbFormat; };

    void SetFormatType(const GUID *);
    const GUID *FormatType() const {return &formattype; };
    BOOL SetFormat(BYTE *pFormat, ULONG length);
    void ResetFormatBuffer();
    BYTE* AllocFormatBuffer(ULONG length);
    BYTE* ReallocFormatBuffer(ULONG length);

    void InitMediaType();

    BOOL MatchesPartial(const CMediaType* ppartial) const;
    BOOL IsPartiallySpecified(void) const;
};

/* General purpose functions to copy and delete a task allocated AM_MEDIA_TYPE
   structure which is useful when using the IEnumMediaFormats interface as
   the implementation allocates the structures which you must later delete */

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat);


/*
 * Helper functions to get VIDEOINFO/VIDEOINFOHEADER2/BITMAPINFOHEADER & other components from
 * CMediaTypes
 */
BITMAPINFOHEADER * WINAPI GetBitmapInfoHeader (const CMediaType *pMediaType);
RGBQUAD * WINAPI GetBmiColors (const CMediaType *pMediaType);
const DWORD * WINAPI GetBitMasks (const CMediaType *pMediaType);
VIDEOINFOHEADER * WINAPI GetVideoInfoHeader (const CMediaType *pMediaType);
VIDEOINFOHEADER2 * WINAPI GetVideoInfoHeader2 (const CMediaType *pMediaType);

/*
 * Helper functions to get VIDEOINFO/VIDEOINFOHEADER2/BITMAPINFOHEADER & other components from
 * AM_MEDIA_TYPEs
 */
BITMAPINFOHEADER * WINAPI GetBitmapInfoHeader (const AM_MEDIA_TYPE *pMediaType);

#endif /* __MTYPE__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\netdma.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2005-2006  Microsoft Corporation

Module Name:

    netdma.h

Abstract:

    This module contains function prototypes and definitons for memory to memory DMA
    providers

Author:

    
Revision history:
    Nov 2006: Added support for a subset of IOAT V2 features (page break and descriptor ring)
    Feb 2005: Original version
    
Environment:

    kernel mode only

--*/

#ifdef UNDER_CE
#pragma once
#endif  //  UNDER_CE

#ifndef _NET_DMA_H
#define _NET_DMA_H

#undef NET_DMA_EXPORT
#if defined(NET_DMA)
#define NET_DMA_EXPORT
#else
#define NET_DMA_EXPORT DECLSPEC_IMPORT
#endif

//
// flags used in NET_DMA_DESCRIPTOR->ControlFlags
//
#define NET_DMA_INTERRUPT_ON_COMPLETION     0x00000001
#define NET_DMA_SOURCE_NO_SNOOP             0x00000002
#define NET_DMA_DESTINATION_NO_SNOOP        0x00000004
#define NET_DMA_STATUS_UPDATE_ON_COMPLETION 0x00000008
#define NET_DMA_SERIALIZE_TRANSFER          0x00000010      // fence bit
#define NET_DMA_NULL_TRANSFER               0x00000020

//
// new flags supported in NETDMA V2
//

#define NET_DMA_SOURCE_PAGE_BREAK           0x00000040
#define NET_DMA_DESTINATION_PAGE_BREAK      0x00000080
#define NET_DMA_DESTINATION_DCA_ENABLE      0x00000200

//
// flags used in NET_DMA_DESCRIPTOR->ControlFlags with NET_DMA_OP_TYPE_CONTEXT_CHANGE
//
#define NET_DMA_DCA_CONTEXT_CHANGE          0x00000001


#define NET_DMA_OP_TYPE_STANDARD_DMA        0x00000000
#define NET_DMA_OP_TYPE_CONTEXT_CHANGE      0xFF000000


//
// The low 3 bits in "Completed Descriptor Address" are used
// to indicate the status of a DMA transfer. The physical and virtual address of 
// "Completed Descriptor Address" of a DMA channel are specified 
// by CompletionVirtualAddress and CompletionPhysicalAddress fields of 
// NET_DMA_CHANNEL_PARAMETERS at the time of allocating a DMA channel
//
#define NET_DMA_TRANSFER_STATUS_MASK        0x00000007

typedef enum _NET_DMA_TRANSFER_STATUS
{
    NetDmaTransferStatusActive = 0,     // 000 = Active, transfer completed successfully. This was -not- the last pending descriptor
    NetDmaTransferStatusIdle = 1,       // 001 = Idle, transfer completed successfully. This was the last pending descriptor
    NetDmaTransferStatusSuspend = 2,    // 010 = Suspend completed (no hard error). DMA channel is in Halt state
    NetDmaTransferStatusHalted = 3,     // 011 = Halted, operation aborted
    NetDmaTransferStatusArmed = 4       // 100 = Armed, first descriptor has not yet completed and Completed Descriptor Address is not valid
} NET_DMA_TRANSFER_STATUS, *PNET_DMA_TRANSFER_STATUS;
        
  
//
// NET_DMA_DESCRIPTOR data structure is used to submit a dma transfer to DMA engine
// DMA descriptors can be chained together. Descriptor structure is modeled after
// CB DMA descriptors. DMA descriptors are aligned on 64 bit boundary
//
typedef struct _NET_DMA_DESCRIPTOR
{
    union
    {
        ULONG               TransferSize;       // DMA Transfer size
        // DCA context = the APIC ID of the target CPU
        struct 
        {
            ULONG           DCAContext:32;
        }DCAContext32;
        struct
        {   
            ULONG           DCAContext:16;
            ULONG           Reserved:16;
        }DCAContext16;
        struct
        {
            ULONG           DCAContext:8;
            ULONG           Reserved:24;
        }DCAContext8;
    };
    
    ULONG               ControlFlags;           // see NET_DMA_xxx flags
    PHYSICAL_ADDRESS    SourceAddress;          // Source physical address
    PHYSICAL_ADDRESS    DestinationAddress;     // Destination physical address
    PHYSICAL_ADDRESS    NextDescriptor;         // Physical address of the next descriptor in the chain
    union
    {
        ULONG64             Reserved1;              // reserved for use by DMA engine (Provider)
        PHYSICAL_ADDRESS    NextSourceAddress;
    };
    union
    {
        ULONG64             Reserved2;              // reserved for use by DMA engine (Provider)
        PHYSICAL_ADDRESS    NextDestinationAddress;
    };
    ULONG64             UserContext1;           // Used by netdma driver and/or DMA client
    ULONG64             UserContext2;           // Used by netdma driver and/or DMA client
} NET_DMA_DESCRIPTOR, *PNET_DMA_DESCRIPTOR;


//
// DMA Provider entry points
//

typedef struct _NET_DMA_CHANNEL_CPU_AFFINITY
{
    ULONG   DmaChannel;
    ULONG   CpuNumber;
}NET_DMA_CHANNEL_CPU_AFFINITY,*PNET_DMA_CHANNEL_CPU_AFFINITY;

//
// DMA channel CPU affinity handler. NETDMA calls this entry point to set the affinity
// policy of DMA channels
//
typedef
NTSTATUS
(*DMA_CHANNELS_CPU_AFFINITY_HANDLER)(
    IN  PVOID   ProviderContext,                        // the Provider context passed to NetDmaRegisterProvider
    IN  PNET_DMA_CHANNEL_CPU_AFFINITY CpuAffinityArray, // see NET_DMA_CHANNEL_CPU_AFFINITY
    IN  ULONG   CpuAffinityArraySize                    // size of CpuAffinityArray
    );


//
// NET_DMA_CHANNEL_PARAMETERS is used to set up a DMA channel
// at the time of allocating the channel
//

#define NET_DMA_CHANNEL_REVISION_1  1

typedef struct _NET_DMA_CHANNEL_PARAMETERS
{
    USHORT              Revision;                   // Structure revision
    USHORT              Size;                       // size of this structure
    ULONG               Flags;                      // TBD
    PVOID               CompletionVirtualAddress;   // the virtual address where the engine will write the completion status
    PHYSICAL_ADDRESS    CompletionPhysicalAddress;  // the physical address where the engine will write the completion status
    ULONG               ProcessorAffinityMask;      // bitmap of CPUs that this channel could be associated with
    ULONG               ChannelPriority;            // per CB spec
    ULONG               CpuNumber;                  // provider will fill this with the CPU this channel is associated with
} NET_DMA_CHANNEL_PARAMETERS, *PNET_DMA_CHANNEL_PARAMETERS;

//
// DMA channel Allocate handler. NETDMA calls this entry point to allocate a DMA channel
//
typedef
NTSTATUS
(*DMA_CHANNEL_ALLOCATE_HANDLER)(
    IN  PVOID   ProviderContext,                        // the Provider context passed to NetDmaRegisterProvider
    IN  PNET_DMA_CHANNEL_PARAMETERS ChannelParameters,  // see NET_DMA_CHANNEL_PARAMETERS
    IN  PVOID   NetDmaChannelHandle,                    // NETDMA handle for this channel. used by all calls from Provider to NETDMA regarding this channel
    OUT PVOID * pProviderChannelContext                 // on return holds Provider context for this channel. used in all calls from NETDMA to provider regarding this channel
    );

//
// NETDMA calls this entry point to free a DMA channel. When NETDMA calls this
// entry points, there are no outstanding DMA operations on this channel. Once
// NETDMA makes this call, it can not call the provider for any operation on the
// channel
// 

typedef
VOID
(*DMA_CHANNEL_FREE_HANDLER)(
    IN  PVOID   ProviderChannelContext               // Provider context for this channel (retuned from DMA_CHANNEL_ALLOCATE_HANDLER in pProviderChannelContext)
    );

//
// NETDMA calls this entry point to start a DMA transfer
//
typedef
NTSTATUS
(*DMA_START_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    IN  PNET_DMA_DESCRIPTOR     DescriptorVirtualAddress,   // pointer to the virtual address of the first descriptor
    IN  PHYSICAL_ADDRESS        DescriptorPhysicalAddress,  // pointer to the physical address of the first descriptor
    IN  ULONG                   DescriptorCount             // number of descriptors
    );

//
// NETDMA calls this entry point to suspend the DMA transfers
// currently in progress. The provider will return the
// physical address of the last DMA descriptor that it processed
//
typedef
NTSTATUS
(*DMA_SUSPEND_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    OUT PPHYSICAL_ADDRESS*      pLastDescriptor             // the physical address of the last processed descriptor
    );

//
// NETDMA calls this entry point to resume DMA operations on 
// a suspended DMA channel
//
typedef
NTSTATUS
(*DMA_RESUME_HANDLER)(
    IN  PVOID   ProviderChannelContext                      // Provider context for this channel
    );

//
// NETDMA calls this entry point to abort all DMA transfers
// that have been scheduled on a DMA channel
//
typedef
NTSTATUS
(*DMA_ABORT_HANDLER)(
    IN  PVOID   ProviderChannelContext                      // Provider context for this channel
    );

//
// NETDMA calls this entry point to append a chain of DMA descriptors
// to the last descriptor on a DMA channel
//
typedef
NTSTATUS
(*DMA_APPEND_HANDLER)(
    IN  PVOID                   ProviderChannelContext,     // Provider context for this channel
    IN  PNET_DMA_DESCRIPTOR     DescriptorVirtualAddress,   // pointer to the virtual address of the first descriptor to append
    IN  PHYSICAL_ADDRESS        DescriptorPhysicalAddress,  // pointer to the physical address of the first descriptor to append
    IN  ULONG                   DescriptorCount             // number of descriptors
    );

//
// TBD:
//
typedef
NTSTATUS
(*DMA_RESET_HANDLER)(
    IN  PVOID   ProviderChannelContext
    );


//
// DMA providers use NET_DMA_PROVIDER_CHARACTERISTICS structure in the call to 
// NetDmaRegisterProvider
//
#define NET_DMA_PROVIDER_REVISION_1  1
#define NET_DMA_PROVIDER_REVISION_2  2

typedef struct _NET_DMA_PROVIDER_CHARACTERISTICS
{
    UCHAR                           MajorVersion;               // Major version of the DMA provider
    UCHAR                           MinorVersion;               // Minor version of the DMA provider
    USHORT                          Size;                       // the size of this structure
    ULONG                           Flags;                      // TBD
    PDEVICE_OBJECT                  PhysicalDeviceObject;       // The physical device object PnP associates with this device
    ULONG                           MaxDmaChannelCount;         // Maximum number of DMA channels
    DMA_CHANNELS_CPU_AFFINITY_HANDLER SetDmaChannelCpuAffinity; // Set channel CPU affinity handler
    DMA_CHANNEL_ALLOCATE_HANDLER    AllocateDmaChannel;         // Allocate DMA channel handler
    DMA_CHANNEL_FREE_HANDLER        FreeDmaChannel;             // Free DMA channel handler
    DMA_START_HANDLER               StartDma;                   // Start DMA handler
    DMA_SUSPEND_HANDLER             SuspendDma;                 // Suspend DMA handler
    DMA_RESUME_HANDLER              ResumeDma;                  // Resume DMA handler
    DMA_ABORT_HANDLER               AbortDma;                   // Abort DMA handler
    DMA_APPEND_HANDLER              AppendDma;                  // Append DMA handler
    DMA_RESET_HANDLER               ResetChannel;               // Reset channel handler
    UNICODE_STRING                  FriendlyName;               // Provider's friendly name
} NET_DMA_PROVIDER_CHARACTERISTICS, *PNET_DMA_PROVIDER_CHARACTERISTICS;


//
// DMA providers call NetDmaRegisterProvider to register an instance of a 
// DMA provider. An instance of a DMA provider is associated with a device
// (DMA engine). Providers usually make this call in their AddDevice entry point.
// Note: the reason that the call has to be made during AddDevice and not
// START IRP is because allocating MSI-X resources has to be done in
// FILTER_RESOURCE_REQUIREMENTS that is sent to the device drivers before
// the START IRP
//
NET_DMA_EXPORT
NTSTATUS
NetDmaRegisterProvider(
    IN  PVOID                           ProviderContext,                // Provider context for this device
    IN  PVOID *                         pNetDmaProviderHandle,          // upon return, this will hold NETDMA handle for this device
    IN  PNET_DMA_PROVIDER_CHARACTERISTICS ProviderCharacteristics       // provider's characteristics
    );

//
// DMA providers call NetDmaDeregisterProvider to deregister a provider
// that was previously registered by a call to NetDmaRegisterProvider
// the call is usually made while handling REMOVE IRP. 
//
NET_DMA_EXPORT
VOID
NetDmaDeregisterProvider(
    IN PVOID                        NetDmaProviderHandle                // Handle obtained by the call to NetDmaRegisterProvider
    );

#define NET_DMA_PROVIDER_ATTRIBUTES_DCA_SUPPORTED   0x00000001

//
// DMA providers use this structure in the call to NetDmaProviderStart
//

typedef struct _NET_DMA_PROVIDER_ATTRIBUTES
{
    UCHAR                           MajorHwVersion;             // Major version of the DMA provider
    UCHAR                           MinorHwVersion;             // Minor version of the DMA provider
    USHORT                          Size;                       // the size of this structure
    ULONG                           Flags;                      // TBD
    ULONG                           VendorId;                   // vendor ID
    ULONG                           DmaChannelCount;            // number of DMA channels
    ULONG                           MaximumTransferSize;        // Maximum DMA transfer size (minimum of 4K)
    PHYSICAL_ADDRESS                MaximumAddressSpace;        // Maximum physical adddress that can be addressed by this device
} NET_DMA_PROVIDER_ATTRIBUTES, *PNET_DMA_PROVIDER_ATTRIBUTES;

//
// DMA providers call NetDmaProviderStart to notify NETDMA that all the DMA channels
// on a provider are initialized  and ready to be used. DMA providers call this API in the
// context of handling START IRP.
//
NET_DMA_EXPORT
VOID
NetDmaProviderStart(
    IN PVOID                        NetDmaProviderHandle,      // Handle obtained by the call to NetDmaRegisterProvider
    IN PNET_DMA_PROVIDER_ATTRIBUTES ProviderAttributes         // the provider's device attributes    
    );

//
// DMA providers call NetDmaProviderStop to notify NETDMA that a previously started
// DMA engine is no longer available.
// DMA providers call this API in the context of handling REMOVE or STOP IRP. NETDMA will wait 
// for outstanding DMA operations to complete and frees all the DMA channels
// before returning back from this API
//
NET_DMA_EXPORT
VOID
NetDmaProviderStop(
    IN PVOID                NetDmaProviderHandle        // Handle obtained by the call to NetDmaRegisterProvider                
    );

//
// DMA providers call NetDmaIsr in their ISR handler
//
NET_DMA_EXPORT
VOID
NetDmaIsr(
    IN  PVOID               NetDmaChannelHandle,
    IN  PHYSICAL_ADDRESS    DmaDescriptor,
    OUT PULONG              pCpuNumber
    );

//
// DMA providers call NetDmaInterruptDpc in their interrupt DPC handler
//
NET_DMA_EXPORT
VOID
NetDmaInterruptDpc(
    IN  PVOID               NetDmaChannelHandle,    // DMA channel
    IN  PHYSICAL_ADDRESS    DmaDescriptor OPTIONAL  // optional if this is called for reasons other DMA completion
    );


NET_DMA_EXPORT
UINT
NetDmaGetVersion(
    VOID
    );


typedef enum _NET_DMA_PNP_NOTIFICATION_CODE
{
    NetDmaNotificationProviderRegistered = 1,   // a provider has registered. not used by providers
    NetDmaNotificationProviderArrival,          // a provider is ready for use. not used by providers
    NetDmaNotificationProviderRemoval,          // a provider is about to be removed. not used by providers
    NetDmaNotificationChannelArrival,           // a DMA channel has become available. not used by providers
    NetDmaNotificationProviderPowerDown,        // the DMA provider is going to D3. 
    NetDmaNotificationProviderPowerUp,          // the DMA provider is back to D0
    NetDmaNotificationMax
}NET_DMA_PNP_NOTIFICATION_CODE, *PNET_DMA_PNP_NOTIFICATION_CODE;

#define NET_DMA_PNP_NOTIFICATION_REVISION_1 1

typedef struct _NET_DMA_PNP_NOTIFICATION
{
    ULONG                           StructureRevision;
    ULONG                           StructureSize;
    NET_DMA_PNP_NOTIFICATION_CODE   NotificationCode;
    PVOID                           Buffer;
    ULONG                           BufferLength;
}NET_DMA_PNP_NOTIFICATION, *PNET_DMA_PNP_NOTIFICATION;

//
// this API is available to Providers version 1.1 and above
//
NET_DMA_EXPORT
VOID
NetDmaPnPEventNotify(
    IN  PVOID                       NetDmaProviderHandle,   // Provider handle
    IN  PNET_DMA_PNP_NOTIFICATION   PnPEvent                // PnP and Power Management event
    );

#endif //_NET_DMA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\netevent.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Module Name:

    netevent.h

Abstract:

    Definitions for network events.

Author:

    Portable Systems Group 6-May-1992

Notes:

    This file is generated by the MC tool from the netevent.mc file.

--*/

#ifndef _NETEVENT_
#define _NETEVENT_


/////////////////////////////////////////////////////////////////////////
//
// Lanman Server Events (2000 - 2999)
//     2000-2499 are generated by the server driver (kernel mode)
//     2500-2999 are generated by the server service (user mode)
//
/////////////////////////////////////////////////////////////////////////


// Server driver events, issued from kernel mode.  Don't use %1 for
// server-supplied insertion strings -- the I/O system provides the
// first string.

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_SRV_SERVICE_FAILED
//
// MessageText:
//
// The server's call to a system service failed unexpectedly.
//
#define EVENT_SRV_SERVICE_FAILED         0xC00007D0L

//
// MessageId: EVENT_SRV_RESOURCE_SHORTAGE
//
// MessageText:
//
// The server was unable to perform an operation due to a shortage of available resources.
//
#define EVENT_SRV_RESOURCE_SHORTAGE      0xC00007D1L

//
// MessageId: EVENT_SRV_CANT_CREATE_DEVICE
//
// MessageText:
//
// The server could not create its device.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_DEVICE     0xC00007D2L

//
// MessageId: EVENT_SRV_CANT_CREATE_PROCESS
//
// MessageText:
//
// The server could not create a process.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_PROCESS    0xC00007D3L

//
// MessageId: EVENT_SRV_CANT_CREATE_THREAD
//
// MessageText:
//
// The server could not create a startup thread.  The server could not be started.
//
#define EVENT_SRV_CANT_CREATE_THREAD     0xC00007D4L

//
// MessageId: EVENT_SRV_UNEXPECTED_DISC
//
// MessageText:
//
// The server received an unexpected disconnection from a client.
//
#define EVENT_SRV_UNEXPECTED_DISC        0xC00007D5L

//
// MessageId: EVENT_SRV_INVALID_REQUEST
//
// MessageText:
//
// The server received an incorrectly formatted request from %2.
//
#define EVENT_SRV_INVALID_REQUEST        0xC00007D6L

//
// MessageId: EVENT_SRV_CANT_OPEN_NPFS
//
// MessageText:
//
// The server could not open the named pipe file system.  Remote named pipes are disabled.
//
#define EVENT_SRV_CANT_OPEN_NPFS         0xC00007D7L

//
// MessageId: EVENT_SRV_CANT_GROW_TABLE
//
// MessageText:
//
// The server could not expand a table because the table reached the maximum size.
//
#define EVENT_SRV_CANT_GROW_TABLE        0x800007D9L

//
// MessageId: EVENT_SRV_CANT_START_SCAVENGER
//
// MessageText:
//
// The server could not start the scavenger thread.  The server could not be started.
//
#define EVENT_SRV_CANT_START_SCAVENGER   0xC00007DAL

//
// MessageId: EVENT_SRV_IRP_STACK_SIZE
//
// MessageText:
//
// The server's configuration parameter "irpstacksize" is too small for the server to use a local device.  Please increase the value of this parameter.
//
#define EVENT_SRV_IRP_STACK_SIZE         0xC00007DBL

//
// MessageId: EVENT_SRV_NETWORK_ERROR
//
// MessageText:
//
// While transmitting or receiving data, the server encountered a network error.
// Occassional errors are expected, but large amounts of these indicate a possible
// error in your network configuration.  The error status code is contained within
// the returned data (formatted as Words) and may point you towards the problem.
//
#define EVENT_SRV_NETWORK_ERROR          0x800007DCL

//
// MessageId: EVENT_SRV_DISK_FULL
//
// MessageText:
//
// The %2 disk is at or near capacity.  You may need to delete some files.
//
#define EVENT_SRV_DISK_FULL              0x800007DDL

//
// MessageId: EVENT_SRV_NO_VIRTUAL_MEMORY
//
// MessageText:
//
// The server was unable to allocate virtual memory.
//
#define EVENT_SRV_NO_VIRTUAL_MEMORY      0xC00007E0L

//
// MessageId: EVENT_SRV_NONPAGED_POOL_LIMIT
//
// MessageText:
//
// The server was unable to allocate from the system nonpaged pool because the server reached the configured limit for nonpaged pool allocations.
//
#define EVENT_SRV_NONPAGED_POOL_LIMIT    0xC00007E1L

//
// MessageId: EVENT_SRV_PAGED_POOL_LIMIT
//
// MessageText:
//
// The server was unable to allocate from the system paged pool because the server reached the configured limit for paged pool allocations.
//
#define EVENT_SRV_PAGED_POOL_LIMIT       0xC00007E2L

//
// MessageId: EVENT_SRV_NO_NONPAGED_POOL
//
// MessageText:
//
// The server was unable to allocate from the system nonpaged pool because the pool was empty.
//
#define EVENT_SRV_NO_NONPAGED_POOL       0xC00007E3L

//
// MessageId: EVENT_SRV_NO_PAGED_POOL
//
// MessageText:
//
// The server was unable to allocate from the system paged pool because the pool was empty.
//
#define EVENT_SRV_NO_PAGED_POOL          0xC00007E4L

//
// MessageId: EVENT_SRV_NO_WORK_ITEM
//
// MessageText:
//
// The server was unable to allocate a work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_WORK_ITEM           0x800007E5L

//
// MessageId: EVENT_SRV_NO_FREE_CONNECTIONS
//
// MessageText:
//
#ifdef UNDER_CE
// The server was unable to find a free connection %2 times in the last %3 seconds.
#else  //  UNDER_CE
// The server was unable to find a free connection %2 times in the last %3 seconds.  This indicates a spike in
// network traffic.  If this is happening frequently, you should consider increasing the minimum number of free
// connections to add headroom.  To do that, modify the MinFreeConnections and MaxFreeConnections for the LanmanServer
// in the registry.
#endif  //  UNDER_CE
//
#define EVENT_SRV_NO_FREE_CONNECTIONS    0x800007E6L

//
// MessageId: EVENT_SRV_NO_FREE_RAW_WORK_ITEM
//
// MessageText:
//
// The server was unable to find a free raw work item %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_FREE_RAW_WORK_ITEM  0x800007E7L

//
// MessageId: EVENT_SRV_NO_BLOCKING_IO
//
// MessageText:
//
// The server was unable to allocate resources for blocking I/O %2 times in the last %3 seconds.
//
#define EVENT_SRV_NO_BLOCKING_IO         0x800007E8L

//
// MessageId: EVENT_SRV_DOS_ATTACK_DETECTED
//
// MessageText:
//
// The server has detected an attempted Denial-Of-Service attack from client %2, and has disconnected the connection.
//
#define EVENT_SRV_DOS_ATTACK_DETECTED    0x800007E9L

//
// MessageId: EVENT_SRV_TOO_MANY_DOS
//
// MessageText:
//
// The server has detected too many Denial-Of-Service attacks and will stop logging
// events for any more of them.  Be advised it is likely someone is actively attacking
// your machine.
//
#define EVENT_SRV_TOO_MANY_DOS           0x800007EAL

//
// MessageId: EVENT_SRV_OUT_OF_WORK_ITEM_DOS
//
// MessageText:
//
// The server has detected a potential Denial-of-Service attack caused by consuming all the work-items.  Some connections
// were disconnected to protect against this.  If this is not the case, please raise the MaxWorkItems for the server or
// disable DoS detection.  This event will not be logged again for 24 hours.
//
#define EVENT_SRV_OUT_OF_WORK_ITEM_DOS   0x800007EBL


// Server service events, issued from user mode.  %1 is the first
// service-supplied insertion string.

//
// MessageId: EVENT_SRV_KEY_NOT_FOUND
//
// MessageText:
//
// The server's Registry key %1 was not present.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_FOUND          0xC00009C5L

//
// MessageId: EVENT_SRV_KEY_NOT_CREATED
//
// MessageText:
//
// The server's Registry key %1 was not present and could not be created.  The server could not start.
//
#define EVENT_SRV_KEY_NOT_CREATED        0xC00009C6L

//
// MessageId: EVENT_SRV_NO_TRANSPORTS_BOUND
//
// MessageText:
//
// The server did not bind to any transports.  The server could not start.
//
#define EVENT_SRV_NO_TRANSPORTS_BOUND    0xC00009C7L

//
// MessageId: EVENT_SRV_CANT_BIND_TO_TRANSPORT
//
// MessageText:
//
// The server could not bind to the transport %1.
//
#define EVENT_SRV_CANT_BIND_TO_TRANSPORT 0x800009C8L

//
// MessageId: EVENT_SRV_CANT_BIND_DUP_NAME
//
// MessageText:
//
// The server could not bind to the transport %1 because another computer on the network has the same name.  The server could not start.
//
#define EVENT_SRV_CANT_BIND_DUP_NAME     0xC00009C9L

//
// MessageId: EVENT_SRV_INVALID_REGISTRY_VALUE
//
// MessageText:
//
#ifdef UNDER_CE
//  The value named %1 in the server's Registry key %2 was invalid.  The value was ignored, and processing continued.  Please change the value to one
//  that is the correct type and is within the acceptable bounds, or delete the value to use the default.  If you did not specify this value, it was 
//  probably setup by an old application that did not know the correct boundaries.
#else  //  UNDER_CE
// The value named %1 in the server's registry key %2 was not valid, and was ignored.
// If you want to change the value, change it to one that is the correct type and is
// within the acceptable range, or delete the value to use the default. This value
// might have been set up by an older program that did not use the correct boundaries.
#endif  //  UNDER_CE
//
#define EVENT_SRV_INVALID_REGISTRY_VALUE 0x800009CAL

//
// MessageId: EVENT_SRV_INVALID_SD
//
// MessageText:
//
// The security descriptor stored in the Registry for the share %1 was invalid.  The share was not automatically recreated.
//
#define EVENT_SRV_INVALID_SD             0x800009CBL

//
// MessageId: EVENT_SRV_CANT_LOAD_DRIVER
//
// MessageText:
//
// The server service was unable to load the server driver.
//
#define EVENT_SRV_CANT_LOAD_DRIVER       0x800009CCL

//
// MessageId: EVENT_SRV_CANT_UNLOAD_DRIVER
//
// MessageText:
//
// The server service was unable to unload the server driver.
//
#define EVENT_SRV_CANT_UNLOAD_DRIVER     0x800009CDL

//
// MessageId: EVENT_SRV_CANT_MAP_ERROR
//
// MessageText:
//
// The server service was unable to map error code %1.
//
#define EVENT_SRV_CANT_MAP_ERROR         0x800009CEL

//
// MessageId: EVENT_SRV_CANT_RECREATE_SHARE
//
// MessageText:
//
// The server service was unable to recreate the share %1 because the directory %2 no longer exists.  Please run "net share %1 /delete" to delete the share, or recreate the directory %2.
//
#define EVENT_SRV_CANT_RECREATE_SHARE    0x800009CFL

//
// MessageId: EVENT_SRV_CANT_CHANGE_DOMAIN_NAME
//
// MessageText:
//
// The server service was unable to change the domain name from %1 to %2.
//
#define EVENT_SRV_CANT_CHANGE_DOMAIN_NAME 0x800009D0L

//
// MessageId: EVENT_SRV_TXF_INIT_FAILED
//
// MessageText:
//
// The server service was unable to register to the transaction resource manager. Remote transactions will be unavailable.
//
#define EVENT_SRV_TXF_INIT_FAILED        0x800009D1L


/////////////////////////////////////////////////////////////////////////
//
// Lanman Redirector Events
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RDR_RESOURCE_SHORTAGE
//
// MessageText:
//
// The redirector was unable to allocate memory.
//
#define EVENT_RDR_RESOURCE_SHORTAGE      0x80000BB9L

//
// MessageId: EVENT_RDR_CANT_CREATE_DEVICE
//
// MessageText:
//
// The redirector could not create its device.  The redirector could not be started.
//
#define EVENT_RDR_CANT_CREATE_DEVICE     0x80000BBAL

//
// MessageId: EVENT_RDR_CANT_CREATE_THREAD
//
// MessageText:
//
// The redirector could not create a system thread.
//
#define EVENT_RDR_CANT_CREATE_THREAD     0x80000BBBL

//
// MessageId: EVENT_RDR_CANT_SET_THREAD
//
// MessageText:
//
// The redirector could not set the priority for a system thread.
//
#define EVENT_RDR_CANT_SET_THREAD        0x80000BBCL

//
// MessageId: EVENT_RDR_INVALID_REPLY
//
// MessageText:
//
// The redirector received an incorrectly formatted response from %2.
//
#define EVENT_RDR_INVALID_REPLY          0x80000BBDL

//
// MessageId: EVENT_RDR_INVALID_SMB
//
// MessageText:
//
// The redirector received an SMB that was too short.
//
#define EVENT_RDR_INVALID_SMB            0x80000BBEL

//
// MessageId: EVENT_RDR_INVALID_LOCK_REPLY
//
// MessageText:
//
// The redirector received an incorrect response from %2 to a lock request.
//
#define EVENT_RDR_INVALID_LOCK_REPLY     0x80000BBFL

//
// MessageId: EVENT_RDR_FAILED_UNLOCK
//
// MessageText:
//
// The redirector failed to unlock part of a file on server %2.
//
#define EVENT_RDR_FAILED_UNLOCK          0x80000BC1L

//
// MessageId: EVENT_RDR_CLOSE_BEHIND
//
// MessageText:
//
// The redirector failed to write data to server %2 after the file was closed.
//
#define EVENT_RDR_CLOSE_BEHIND           0x80000BC3L

//
// MessageId: EVENT_RDR_UNEXPECTED_ERROR
//
// MessageText:
//
// An unexpected network error has occurred on the virtual circuit to %2.
//
#define EVENT_RDR_UNEXPECTED_ERROR       0x80000BC4L

//
// MessageId: EVENT_RDR_TIMEOUT
//
// MessageText:
//
// The redirector has timed out a request to %2.
//
#define EVENT_RDR_TIMEOUT                0x80000BC5L

//
// MessageId: EVENT_RDR_INVALID_OPLOCK
//
// MessageText:
//
// The redirector received an invalid oplock level from %2.
//
#define EVENT_RDR_INVALID_OPLOCK         0x80000BC6L

//
// MessageId: EVENT_RDR_CONNECTION_REFERENCE
//
// MessageText:
//
// The redirector dereferenced a connection through zero.
//
#define EVENT_RDR_CONNECTION_REFERENCE   0x80000BC7L

//
// MessageId: EVENT_RDR_SERVER_REFERENCE
//
// MessageText:
//
// The redirector dereferenced a server through zero.
//
#define EVENT_RDR_SERVER_REFERENCE       0x80000BC8L

//
// MessageId: EVENT_RDR_SMB_REFERENCE
//
// MessageText:
//
// The redirector dereferenced the allocated SMB count through zero.
//
#define EVENT_RDR_SMB_REFERENCE          0x80000BC9L

//
// MessageId: EVENT_RDR_ENCRYPT
//
// MessageText:
//
// The redirector accessed a share-level server that indicates it encrypts passwords.
// This combination is not supported.
//
#define EVENT_RDR_ENCRYPT                0x80000BCAL

//
// MessageId: EVENT_RDR_CONNECTION
//
// MessageText:
//
// The redirector failed to determine the connection type.
//
#define EVENT_RDR_CONNECTION             0x80000BCBL

//
// MessageId: EVENT_RDR_MAXCMDS
//
// MessageText:
//
// The redirector failed to allocate a multiplex table entry.  This indicates that
// the MAXCMDS parameter to the redirector is insufficient for the users needs.
//
#define EVENT_RDR_MAXCMDS                0x80000BCDL

//
// MessageId: EVENT_RDR_OPLOCK_SMB
//
// MessageText:
//
// The redirector failed to allocate a buffer for an oplock break.
//
#define EVENT_RDR_OPLOCK_SMB             0x80000BCEL

//
// MessageId: EVENT_RDR_DISPOSITION
//
// MessageText:
//
// The redirector failed to map the requested file disposition (for NtCreateFile).
//
#define EVENT_RDR_DISPOSITION            0x80000BCFL

//
// MessageId: EVENT_RDR_CONTEXTS
//
// MessageText:
//
// The redirector is allocating additional resources for input/output request packet contexts.  This is
// probably caused by a resource leak in the redirector.
//
#define EVENT_RDR_CONTEXTS               0x80000BD0L

//
// MessageId: EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED
//
// MessageText:
//
// A write-behind operation has failed to the remote server %2.  The data contains the amount requested to write and the amount actually written.
//
#define EVENT_RDR_WRITE_BEHIND_FLUSH_FAILED 0x80000BD1L

//
// MessageId: EVENT_RDR_AT_THREAD_MAX
//
// MessageText:
//
// The redirector was unable to create a worker thread because it has already created the maximum number of configured work threads.
//
#define EVENT_RDR_AT_THREAD_MAX          0x80000BD2L

//
// MessageId: EVENT_RDR_CANT_READ_REGISTRY
//
// MessageText:
//
// The redirector was unable to initialize variables from the Registry.
//
#define EVENT_RDR_CANT_READ_REGISTRY     0x80000BD3L

//
// MessageId: EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE
//
// MessageText:
//
// The time zone bias calculated between %2 and the current workstation is too
// large.  The data specifies the number of 100ns units between the workstation
// and server.  Make sure that the time of day on the workstation and server are
// correct.
//
#define EVENT_RDR_TIMEZONE_BIAS_TOO_LARGE 0x80000BD4L

//
// MessageId: EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
// The redirector has failed to connect to the server %2 on the primary transport.  The data contains the error.
//
#define EVENT_RDR_PRIMARY_TRANSPORT_CONNECT_FAILED 0x80000BD5L

//
// MessageId: EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED
//
// MessageText:
//
// The redirector was unable to update the file attributes on a file located on server %2.
// The data contains the name of the file.
//
#define EVENT_RDR_DELAYED_SET_ATTRIBUTES_FAILED 0x80000BD6L

//
// MessageId: EVENT_RDR_DELETEONCLOSE_FAILED
//
// MessageText:
//
// The redirector was unable to delete the file specified on server %2 when it was closed by the application.
// The data contains the name of the file.
//
#define EVENT_RDR_DELETEONCLOSE_FAILED   0x80000BD7L

//
// MessageId: EVENT_RDR_CANT_BIND_TRANSPORT
//
// MessageText:
//
// The redirector was unable to register the domain %2 on to transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_BIND_TRANSPORT    0x80000BD8L

//
// MessageId: EVENT_RDR_CANT_REGISTER_ADDRESS
//
// MessageText:
//
// The redirector was unable to register the address for transport %3 for the following reason: %4. Transport has been taken offline.
//
#define EVENT_RDR_CANT_REGISTER_ADDRESS  0x80000BD9L

//
// MessageId: EVENT_RDR_CANT_GET_SECURITY_CONTEXT
//
// MessageText:
//
// The redirector was unable to initialize security context or query context attributes.
//
#define EVENT_RDR_CANT_GET_SECURITY_CONTEXT 0x80000BDAL

//
// MessageId: EVENT_RDR_CANT_BUILD_SMB_HEADER
//
// MessageText:
//
// The redirector was unable to build SMB header.
//
#define EVENT_RDR_CANT_BUILD_SMB_HEADER  0x80000BDBL

//
// MessageId: EVENT_RDR_SECURITY_SIGNATURE_MISMATCH
//
// MessageText:
//
// The redirector detected a security signature mismatch. The connection has been disconnected.
//
#define EVENT_RDR_SECURITY_SIGNATURE_MISMATCH 0x80000BDCL



/////////////////////////////////////////////////////////////////////////
//
// IPv6 Events
//
// Codes 3100 - 3199
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TCPIP6_STARTED
//
// MessageText:
//
// The Microsoft TCP/IP version 6 driver was started.
//
#define EVENT_TCPIP6_STARTED             0x40000C1CL



/////////////////////////////////////////////////////////////////////////
//
// STREAMS Environment Events
//
// Codes 4000 - 4099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_STREAMS_STRLOG
//
// MessageText:
//
// %2
//
#define EVENT_STREAMS_STRLOG             0xC0000FA0L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE
//
// MessageText:
//
// Unable to allocate a %2 byte message.
//
#define EVENT_STREAMS_ALLOCB_FAILURE     0x80000FA1L

//
// MessageId: EVENT_STREAMS_ALLOCB_FAILURE_CNT
//
// MessageText:
//
// %2 message allocations have failed since initialization.
//
#define EVENT_STREAMS_ALLOCB_FAILURE_CNT 0x80000FA2L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE
//
// MessageText:
//
// Unable to allocate a %2 byte external message.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE   0x80000FA3L

//
// MessageId: EVENT_STREAMS_ESBALLOC_FAILURE_CNT
//
// MessageText:
//
// %2 external message allocations have failed since initialization.
//
#define EVENT_STREAMS_ESBALLOC_FAILURE_CNT 0x80000FA4L



/////////////////////////////////////////////////////////////////////////
//
// TCP/IP Events
//
// Codes 4100 - 4299
//
/////////////////////////////////////////////////////////////////////////


//
// Common TCP/IP messages
//
// Codes 4100 - 4149
//
//

//
// MessageId: EVENT_TCPIP_CREATE_DEVICE_FAILED
//
// MessageText:
//
// Unable to create device object %2. Initialization failed.
//
#define EVENT_TCPIP_CREATE_DEVICE_FAILED 0xC0001004L

//
// MessageId: EVENT_TCPIP_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
// Unable to allocate required resources. Initialization failed.
//
#define EVENT_TCPIP_NO_RESOURCES_FOR_INIT 0xC0001005L


//
// ARP messages
//
// Codes 4150-4174


//
// IP Loopback messages
//
// Codes 4175-4184
//


//
// IP/ICMP messages
//
// Codes 4185 - 4224

//
// MessageId: EVENT_TCPIP_TOO_MANY_NETS
//
// MessageText:
//
// IP has been bound to more than the maximum number of supported interfaces.
// Some interfaces on network adapter %2 will not be initialized.
//
#define EVENT_TCPIP_TOO_MANY_NETS        0xC0001059L

//
// MessageId: EVENT_TCPIP_NO_MASK
//
// MessageText:
//
// No subnet mask was specified for interface %2. This interface and all
// subsequent interfaces on network adapter %3 cannot be initialized.
//
#define EVENT_TCPIP_NO_MASK              0xC000105AL

//
// MessageId: EVENT_TCPIP_INVALID_ADDRESS
//
// MessageText:
//
// An invalid address %2 was specified for network adapter %3. This interface
// cannot be initialized.
//
#define EVENT_TCPIP_INVALID_ADDRESS      0xC000105BL

//
// MessageId: EVENT_TCPIP_INVALID_MASK
//
// MessageText:
//
// An invalid subnet mask %2 was specified for address %3 on network adapter %4.
// This interface cannot be initialized.
//
#define EVENT_TCPIP_INVALID_MASK         0xC000105CL

//
// MessageId: EVENT_TCPIP_NO_ADAPTER_RESOURCES
//
// MessageText:
//
// IP could not allocate some resources required to configure network adapter %2.
// Some interfaces on this network adapter will not be initialized.
//
#define EVENT_TCPIP_NO_ADAPTER_RESOURCES 0xC000105DL

//
// MessageId: EVENT_TCPIP_DHCP_INIT_FAILED
//
// MessageText:
//
// IP was unable to initialize network adapter %2 for configuration by DHCP.
// If DHCP is enabled on this network adapter, the primary interface may not be
// configured properly. Interfaces on this network adapter not configured by
// DHCP will be unaffected.
//
#define EVENT_TCPIP_DHCP_INIT_FAILED     0x8000105EL

//
// MessageId: EVENT_TCPIP_ADAPTER_REG_FAILURE
//
// MessageText:
//
// IP could not open the registry key for network adapter %2.
// Interfaces on this network adapter will not be initialized.
//
#define EVENT_TCPIP_ADAPTER_REG_FAILURE  0xC000105FL

//
// MessageId: EVENT_TCPIP_INVALID_DEFAULT_GATEWAY
//
// MessageText:
//
// Invalid default gateway address %2 was specified for network adapter %3.
// Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_INVALID_DEFAULT_GATEWAY 0x80001060L

//
// MessageId: EVENT_TCPIP_NO_ADDRESS_LIST
//
// MessageText:
//
// Unable to read the configured IP addresses for network adapter %2.
// IP interfaces will not be initialized on this network adapter.
//
#define EVENT_TCPIP_NO_ADDRESS_LIST      0xC0001061L

//
// MessageId: EVENT_TCPIP_NO_MASK_LIST
//
// MessageText:
//
// Unable to read the configured subnet masks for network adapter %2.
// IP interfaces will not be initialized on this network adapter.
//
#define EVENT_TCPIP_NO_MASK_LIST         0xC0001062L

//
// MessageId: EVENT_TCPIP_NO_BINDINGS
//
// MessageText:
//
// IP was unable to read its bindings from the registry. No network interfaces
// were configured.
//
#define EVENT_TCPIP_NO_BINDINGS          0xC0001063L

//
// MessageId: EVENT_TCPIP_IP_INIT_FAILED
//
// MessageText:
//
// Initialization of IP failed.
//
#define EVENT_TCPIP_IP_INIT_FAILED       0xC0001064L

//
// MessageId: EVENT_TCPIP_TOO_MANY_GATEWAYS
//
// MessageText:
//
// More than the maximum number of default gateways were specified for
// network adapter %2. Some remote networks may not be reachable as a result.
//
#define EVENT_TCPIP_TOO_MANY_GATEWAYS    0x80001065L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT1
//
// MessageText:
//
// The system detected an address conflict for IP address %2 with the system
// having network hardware address %3. The local interface has been disabled.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT1    0xC0001066L

//
// MessageId: EVENT_TCPIP_ADDRESS_CONFLICT2
//
// MessageText:
//
// The system detected an address conflict for IP address %2 with the system
// having network hardware address %3. Network operations on this system may
// be disrupted as a result.
//
#define EVENT_TCPIP_ADDRESS_CONFLICT2    0xC0001067L

//
// MessageId: EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE
//
// MessageText:
//
// Unable to read or write the NTE Context list for network adapter %2.
// IP interfaces on this network adapter may not be initialized completely.
//
#define EVENT_TCPIP_NTE_CONTEXT_LIST_FAILURE 0xC0001068L

//
// MessageId: EVENT_TCPIP_MEDIA_CONNECT
//
// MessageText:
//
// The system detected that network adapter %2 was connected to the network,
// and has initiated normal operation.
//
#define EVENT_TCPIP_MEDIA_CONNECT        0x40001069L

//
// MessageId: EVENT_TCPIP_MEDIA_DISCONNECT
//
// MessageText:
//
// The system detected that network adapter %2 was disconnected from the network
// and its network configuration has been released. If the network adapter was
// not disconnected, this may indicate that it has malfunctioned.
// Try updating the driver for the network adapter.
//
#define EVENT_TCPIP_MEDIA_DISCONNECT     0x4000106AL

//
// MessageId: EVENT_TCPIP_IPV4_UNINSTALLED
//
// MessageText:
//
// The system detected that IPv4 is not installed.  This may cause some
// networking services to fail to start, or to malfunction.  To install IPv4, use
// "netsh interface ipv4 install".
//
#define EVENT_TCPIP_IPV4_UNINSTALLED     0x4000106BL


//
// TCP messages
//
// Codes 4225 - 4264
//

//
// MessageId: EVENT_TCPIP_TCP_INIT_FAILED
//
// MessageText:
//
// Initialization of TCP/UDP failed.
//
#define EVENT_TCPIP_TCP_INIT_FAILED      0xC0001081L

//
// MessageId: EVENT_TCPIP_TCP_CONNECT_LIMIT_REACHED
//
// MessageText:
//
// TCP/IP has reached the security limit imposed on the number of concurrent TCP connect attempts.
//
#define EVENT_TCPIP_TCP_CONNECT_LIMIT_REACHED 0x80001082L

//
// MessageId: EVENT_TCPIP_TCP_TIME_WAIT_COLLISION
//
// MessageText:
//
// TCP/IP failed to establish an outgoing connection because the selected local endpoint
// was recently used to connect to the same remote endpoint. This error typically occurs
// when outgoing connections are opened and closed at a high rate, causing all available
// local ports to be used and forcing TCP/IP to reuse a local port for an outgoing connection.
// To minimize the risk of data corruption, the TCP/IP standard requires a minimum time period
// to elapse between successive connections from a given local endpoint to a given remote endpoint.
//
#define EVENT_TCPIP_TCP_TIME_WAIT_COLLISION 0x80001083L

//
// MessageId: EVENT_TCPIP_TCP_WSD_WS_RESTRICTED
//
// MessageText:
//
// TCP/IP has chosen to restrict the scale factor due to a network condition. 
// This could be related to a problem in a network device and will cause 
// degraded throughput.
//
#define EVENT_TCPIP_TCP_WSD_WS_RESTRICTED 0x80001084L

//
// UDP messages
//
// Codes 4265 - 4280
//

//
// MessageId: EVENT_TCPIP_UDP_LIMIT_REACHED
//
// MessageText:
//
// Backlog of pending datagram sends reached. Please increase the value of Tcpip\Parameters\DGMaxSendFree in the registry.
//
#define EVENT_TCPIP_UDP_LIMIT_REACHED    0x800010A9L



/////////////////////////////////////////////////////////////////////////
//
// NBT Events
//
// Codes 4300 - 4399
//
/////////////////////////////////////////////////////////////////////////



// Don't use %1 for driver supplied insertion strings.  The IO subsystem
// supplies the first string!!

//
// MessageId: EVENT_NBT_CREATE_DRIVER
//
// MessageText:
//
// The driver could not be created.
//
#define EVENT_NBT_CREATE_DRIVER          0xC00010CCL

//
// MessageId: EVENT_NBT_OPEN_REG_PARAMS
//
// MessageText:
//
// Unable to open the Registry Parameters to read configuration information.
//
#define EVENT_NBT_OPEN_REG_PARAMS        0xC00010CDL

//
// MessageId: EVENT_NBT_NO_BACKUP_WINS
//
// MessageText:
//
// The backup WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_BACKUP_WINS         0x800010CEL

//
// MessageId: EVENT_NBT_NO_WINS
//
// MessageText:
//
// The primary WINS server address is not configured in the registry.
//
#define EVENT_NBT_NO_WINS                0x800010CFL

//
// MessageId: EVENT_NBT_BAD_BACKUP_WINS_ADDR
//
// MessageText:
//
// The backup WINS server address is not formated correctly in the registry.
//
#define EVENT_NBT_BAD_BACKUP_WINS_ADDR   0x800010D0L

//
// MessageId: EVENT_NBT_BAD_PRIMARY_WINS_ADDR
//
// MessageText:
//
// The primary WINS server address is not formatted correctly in the registry.
//
#define EVENT_NBT_BAD_PRIMARY_WINS_ADDR  0x800010D1L

//
// MessageId: EVENT_NBT_NAME_SERVER_ADDRS
//
// MessageText:
//
// Unable to configure the addresses of the WINS servers.
//
#define EVENT_NBT_NAME_SERVER_ADDRS      0xC00010D2L

//
// MessageId: EVENT_NBT_CREATE_ADDRESS
//
// MessageText:
//
// Initialization failed because the transport refused to open initial addresses.
//
#define EVENT_NBT_CREATE_ADDRESS         0xC00010D3L

//
// MessageId: EVENT_NBT_CREATE_CONNECTION
//
// MessageText:
//
// Initialization failed because the transport refused to open initial connections.
//
#define EVENT_NBT_CREATE_CONNECTION      0xC00010D4L

//
// MessageId: EVENT_NBT_NON_OS_INIT
//
// MessageText:
//
// Data structure initialization failed.
//
#define EVENT_NBT_NON_OS_INIT            0xC00010D5L

//
// MessageId: EVENT_NBT_TIMERS
//
// MessageText:
//
// Initialization failed because the timers could not be started.
//
#define EVENT_NBT_TIMERS                 0xC00010D6L

//
// MessageId: EVENT_NBT_CREATE_DEVICE
//
// MessageText:
//
// Initialization failed because the driver device could not be created.
// Use the string "%2" to identify the interface for which initialization
// failed. It represents the MAC address of the failed interface or the 
// Globally Unique Interface Identifier (GUID) if NetBT was unable to 
// map from GUID to MAC address. If neither the MAC address nor the GUID were 
// available, the string represents a cluster device name.
// 
//
#define EVENT_NBT_CREATE_DEVICE          0xC00010D7L

//
// MessageId: EVENT_NBT_NO_DEVICES
//
// MessageText:
//
// There are no network adapters configured for this protocol stack.
//
#define EVENT_NBT_NO_DEVICES             0x800010D8L

//
// MessageId: EVENT_NBT_OPEN_REG_LINKAGE
//
// MessageText:
//
// Unable to open the Registry Linkage to read configuration information.
//
#define EVENT_NBT_OPEN_REG_LINKAGE       0xC00010D9L

//
// MessageId: EVENT_NBT_READ_BIND
//
// MessageText:
//
// Unable to read the driver's bindings to the transport from the registry.
//
#define EVENT_NBT_READ_BIND              0xC00010DAL

//
// MessageId: EVENT_NBT_READ_EXPORT
//
// MessageText:
//
// Unable to read the driver's exported linkage configuration information.
//
#define EVENT_NBT_READ_EXPORT            0xC00010DBL

//
// MessageId: EVENT_NBT_OPEN_REG_NAMESERVER
//
// MessageText:
//
// Unable to open the registry to read the WINS server addresses.
//
#define EVENT_NBT_OPEN_REG_NAMESERVER    0x800010DCL

//
// MessageId: EVENT_SCOPE_LABEL_TOO_LONG
//
// MessageText:
//
// The Netbios Name Scope has a component longer than 63 characters. Each label
// in the Scope cannot be longer than 63 bytes.
//
#define EVENT_SCOPE_LABEL_TOO_LONG       0x800010DDL

//
// MessageId: EVENT_SCOPE_TOO_LONG
//
// MessageText:
//
// The Netbios Name Scope is too long. The scope cannot be longer than
// 255 bytes.
//
#define EVENT_SCOPE_TOO_LONG             0x800010DEL

//
// MessageId: EVENT_NBT_DUPLICATE_NAME
//
// MessageText:
//
// A duplicate name has been detected on the TCP network.  The IP address of
// the computer that sent the message is in the data. Use nbtstat -n in a
// command window to see which name is in the Conflict state.
//
#define EVENT_NBT_DUPLICATE_NAME         0xC00010DFL

//
// MessageId: EVENT_NBT_NAME_RELEASE
//
// MessageText:
//
// Another computer has sent a name release message to this computer, probably
// because a duplicate name has been detected on the TCP network.  The IP address
// of the node that sent the message is in the data. Use nbtstat -n in a
// command window to see which name is in the Conflict state.
//
#define EVENT_NBT_NAME_RELEASE           0xC00010E0L

//
// MessageId: EVENT_NBT_DUPLICATE_NAME_ERROR
//
// MessageText:
//
// The name "%2" could not be registered on the interface with IP address %3.
// The computer with the IP address %4 did not allow the name to be claimed by
// this computer.
//
#define EVENT_NBT_DUPLICATE_NAME_ERROR   0xC00010E1L

//
// MessageId: EVENT_NBT_NO_RESOURCES
//
// MessageText:
//
// NetBT failed to process a request because it encountered OutOfResources
// exception(s) in the last 1 hour.
//
#define EVENT_NBT_NO_RESOURCES           0xC00010E2L


/////////////////////////////////////////////////////////////////////////
//
// NDIS Environment Events
//
// Codes 5000 - 5099
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// %2 : Has encountered a conflict in resources and could not load.
//
#define EVENT_NDIS_RESOURCE_CONFLICT     0xC0001388L

//
// MessageId: EVENT_NDIS_OUT_OF_RESOURCE
//
// MessageText:
//
// %2 : Could not allocate the resources necessary for operation.
//
#define EVENT_NDIS_OUT_OF_RESOURCE       0xC0001389L

//
// MessageId: EVENT_NDIS_HARDWARE_FAILURE
//
// MessageText:
//
// %2 : Has determined that the network adapter is not functioning properly.
//
#define EVENT_NDIS_HARDWARE_FAILURE      0xC000138AL

//
// MessageId: EVENT_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// %2 : Could not find a network adapter.
//
#define EVENT_NDIS_ADAPTER_NOT_FOUND     0xC000138BL

//
// MessageId: EVENT_NDIS_INTERRUPT_CONNECT
//
// MessageText:
//
// %2 : Could not connect to the interrupt number supplied.
//
#define EVENT_NDIS_INTERRUPT_CONNECT     0xC000138CL

//
// MessageId: EVENT_NDIS_DRIVER_FAILURE
//
// MessageText:
//
// %2 : Has encountered an internal error and has failed.
//
#define EVENT_NDIS_DRIVER_FAILURE        0xC000138DL

//
// MessageId: EVENT_NDIS_BAD_VERSION
//
// MessageText:
//
// %2 : The version number is incorrect for this driver.
//
#define EVENT_NDIS_BAD_VERSION           0xC000138EL

//
// MessageId: EVENT_NDIS_TIMEOUT
//
// MessageText:
//
// %2 : Timed out during an operation.
//
#define EVENT_NDIS_TIMEOUT               0x8000138FL

//
// MessageId: EVENT_NDIS_NETWORK_ADDRESS
//
// MessageText:
//
// %2 : Has encountered an invalid network address.
//
#define EVENT_NDIS_NETWORK_ADDRESS       0xC0001390L

//
// MessageId: EVENT_NDIS_UNSUPPORTED_CONFIGURATION
//
// MessageText:
//
// %2 : Does not support the configuration supplied.
//
#define EVENT_NDIS_UNSUPPORTED_CONFIGURATION 0xC0001391L

//
// MessageId: EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
//
// MessageText:
//
// %2 : The network adapter has returned an invalid value to the driver.
//
#define EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER 0xC0001392L

//
// MessageId: EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
//
// MessageText:
//
// %2 : A required parameter is missing from the registry.
//
#define EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER 0xC0001393L

//
// MessageId: EVENT_NDIS_BAD_IO_BASE_ADDRESS
//
// MessageText:
//
// %2 : The I/O base address supplied does not match the jumpers on the adapter.
//
#define EVENT_NDIS_BAD_IO_BASE_ADDRESS   0xC0001394L

//
// MessageId: EVENT_NDIS_RECEIVE_SPACE_SMALL
//
// MessageText:
//
// %2 : The adapter is configured such that the receive space is smaller than
// the maximum packet size.  Some packets may be lost.
//
#define EVENT_NDIS_RECEIVE_SPACE_SMALL   0x40001395L

//
// MessageId: EVENT_NDIS_ADAPTER_DISABLED
//
// MessageText:
//
// %2 : The driver cannot function because the network adapter is disabled.
//
#define EVENT_NDIS_ADAPTER_DISABLED      0x80001396L

//
// MessageId: EVENT_NDIS_IO_PORT_CONFLICT
//
// MessageText:
//
// %2 : There is an I/O port conflict.
//
#define EVENT_NDIS_IO_PORT_CONFLICT      0x80001397L

//
// MessageId: EVENT_NDIS_PORT_OR_DMA_CONFLICT
//
// MessageText:
//
// %2 : There is an I/O port or DMA channel conflict.
//
#define EVENT_NDIS_PORT_OR_DMA_CONFLICT  0x80001398L

//
// MessageId: EVENT_NDIS_MEMORY_CONFLICT
//
// MessageText:
//
// %2 : There is a memory conflict at address 0x%3.
//
#define EVENT_NDIS_MEMORY_CONFLICT       0x80001399L

//
// MessageId: EVENT_NDIS_INTERRUPT_CONFLICT
//
// MessageText:
//
// %2 : There is a interrupt conflict at Interrupt %3.
//
#define EVENT_NDIS_INTERRUPT_CONFLICT    0x8000139AL

//
// MessageId: EVENT_NDIS_DMA_CONFLICT
//
// MessageText:
//
// %2 : There is a resource conflict at DMA channel %3.
//
#define EVENT_NDIS_DMA_CONFLICT          0x8000139BL

//
// MessageId: EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR
//
// MessageText:
//
// %2 : The download file is invalid.  The driver is unable to load.
//
#define EVENT_NDIS_INVALID_DOWNLOAD_FILE_ERROR 0xC000139CL

//
// MessageId: EVENT_NDIS_MAXRECEIVES_ERROR
//
// MessageText:
//
// %2 : The specified registry entry MaxReceives is out of range. Using 
// default value.
//
#define EVENT_NDIS_MAXRECEIVES_ERROR     0x8000139DL

//
// MessageId: EVENT_NDIS_MAXTRANSMITS_ERROR
//
// MessageText:
//
// %2 : The specified registry entry MaxTransmits is out of range. Using 
// default value
//
#define EVENT_NDIS_MAXTRANSMITS_ERROR    0x8000139EL

//
// MessageId: EVENT_NDIS_MAXFRAMESIZE_ERROR
//
// MessageText:
//
// %2 : The specified registry entry MaxFrameSize is out of range. Using 
// default value.
//
#define EVENT_NDIS_MAXFRAMESIZE_ERROR    0x8000139FL

//
// MessageId: EVENT_NDIS_MAXINTERNALBUFS_ERROR
//
// MessageText:
//
// %2 : The specified registry entry MaxInternalBufs is out of range. Using 
// default value.
//
#define EVENT_NDIS_MAXINTERNALBUFS_ERROR 0x800013A0L

//
// MessageId: EVENT_NDIS_MAXMULTICAST_ERROR
//
// MessageText:
//
// %2 : The specified registry entry MaxMulticast is out of range. Using 
// default value.
//
#define EVENT_NDIS_MAXMULTICAST_ERROR    0x800013A1L

//
// MessageId: EVENT_NDIS_PRODUCTID_ERROR
//
// MessageText:
//
// %2 : The specified registry entry ProductId is out of range. Using 
// default value.
//
#define EVENT_NDIS_PRODUCTID_ERROR       0x800013A2L

//
// MessageId: EVENT_NDIS_LOBE_FAILUE_ERROR
//
// MessageText:
//
// %2 : A Token Ring Lobe Wire Fault has occurred. Verify cable connections. 
// The network adapter will continue to try to reinsert into the ring.
//
#define EVENT_NDIS_LOBE_FAILUE_ERROR     0x800013A3L

//
// MessageId: EVENT_NDIS_SIGNAL_LOSS_ERROR
//
// MessageText:
//
// %2 : The adapter had detected a loss of signal on the ring.  The adapter
// will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_SIGNAL_LOSS_ERROR     0x800013A4L

//
// MessageId: EVENT_NDIS_REMOVE_RECEIVED_ERROR
//
// MessageText:
//
// %2 : The adapter has received a request to deinsert from the
// ring.  The adapter will continue to try to reinsert back into the ring.
//
#define EVENT_NDIS_REMOVE_RECEIVED_ERROR 0x800013A5L

//
// MessageId: EVENT_NDIS_TOKEN_RING_CORRECTION
//
// MessageText:
//
// %2 : The network adapter has successfully reinserted into the ring.
//
#define EVENT_NDIS_TOKEN_RING_CORRECTION 0x400013A6L

//
// MessageId: EVENT_NDIS_ADAPTER_CHECK_ERROR
//
// MessageText:
//
// %2 : The network adapter has detected an Adapter Check as a result of 
// an unrecoverable hardware or software error.
//
#define EVENT_NDIS_ADAPTER_CHECK_ERROR   0xC00013A7L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_ERROR
//
// MessageText:
//
// %2 : The network adapter failed to reset within a specified time, which could 
// be caused by a hardware failure. The network adapter will continue to try to reset.
//
#define EVENT_NDIS_RESET_FAILURE_ERROR   0x800013A8L

//
// MessageId: EVENT_NDIS_CABLE_DISCONNECTED_ERROR
//
// MessageText:
//
// %2 : The network adapter has detected that the token ring cable is disconnected 
// from the network adapter. Please reconnect the cable.
//
#define EVENT_NDIS_CABLE_DISCONNECTED_ERROR 0x800013A9L

//
// MessageId: EVENT_NDIS_RESET_FAILURE_CORRECTION
//
// MessageText:
//
// %2 : The network adapter has successfully completed a previously failed reset.
//
#define EVENT_NDIS_RESET_FAILURE_CORRECTION 0x800013AAL


/////////////////////////////////////////////////////////////////////////
//
// General NT System Events
//
/////////////////////////////////////////////////////////////////////////

//
// Eventlog Events 6000 - 6099
//
//
// MessageId: EVENT_EventlogStarted
//
// MessageText:
//
// The Event log service was started.
//
#define EVENT_EventlogStarted            0x80001775L

//
// MessageId: EVENT_EventlogStopped
//
// MessageText:
//
// The Event log service was stopped.
//
#define EVENT_EventlogStopped            0x80001776L

//
// MessageId: EVENT_EventlogAbnormalShutdown
//
// MessageText:
//
// The previous system shutdown at %1 on %2 was unexpected.
//
#define EVENT_EventlogAbnormalShutdown   0x80001778L

//
// MessageId: EVENT_EventLogProductInfo
//
// MessageText:
//
#ifdef UNDER_CE
//  Microsoft (R) Windows 2000 (R) %1 %2 %3 %4.
#else  //  UNDER_CE
// Microsoft (R) Windows (R) %1 %2 %3 %4.
#endif  //  UNDER_CE
//
#define EVENT_EventLogProductInfo        0x80001779L

//
// MessageId: EVENT_ComputerNameChange
//
// MessageText:
//
// The NetBIOS name and DNS host name of this machine have been changed from %1 to %2.
//
#define EVENT_ComputerNameChange         0x8000177BL

//
// MessageId: EVENT_DNSDomainNameChange
//
// MessageText:
//
// The DNS domain assigned to this computer has been changed from %1 to %2.
//
#define EVENT_DNSDomainNameChange        0x8000177CL

//
// MessageId: EVENT_EventlogUptime
//
// MessageText:
//
// The system uptime is %5 seconds.
//
#define EVENT_EventlogUptime             0x8000177DL

//
// System Events 6100 - 6199
//
//
// MessageId: EVENT_UP_DRIVER_ON_MP
//
// MessageText:
//
// A uniprocessor-specific driver was loaded on a multiprocessor system.  The driver could not load.
//
#define EVENT_UP_DRIVER_ON_MP            0xC00017D4L

//
// Service Controller Events 7000 - 7899
//
// IMPORTANT NOTE: Do not add any new Vista+ SCM events in netevent.mc, please add those to base\screg\sc\manifests\services.man which contains
// Crimson-friendly event definitions. The SCM events defined here are not used by the eventvwr MMC snapin but continue to remain here due to
// few components depending on the definition (test code, tools code, etc.)
//
//
// MessageId: EVENT_SERVICE_START_FAILED
//
// MessageText:
//
// The %1 service failed to start due to the following error: %n%2
//
#define EVENT_SERVICE_START_FAILED       0xC0001B58L

//
// MessageId: EVENT_SERVICE_START_FAILED_II
//
// MessageText:
//
// The %1 service depends on the %2 service which failed to start because of the following error: %n%3
//
#define EVENT_SERVICE_START_FAILED_II    0xC0001B59L

//
// MessageId: EVENT_SERVICE_START_FAILED_GROUP
//
// MessageText:
//
// The %1 service depends on the %2 group and no member of this group started.
//
#define EVENT_SERVICE_START_FAILED_GROUP 0xC0001B5AL

//
// MessageId: EVENT_SERVICE_START_FAILED_NONE
//
// MessageText:
//
// The %1 service depends on the following nonexistent service: %2
//
#define EVENT_SERVICE_START_FAILED_NONE  0xC0001B5BL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED
//
// MessageText:
//
// The %1 call failed with the following error: %n%2
//
#define EVENT_CALL_TO_FUNCTION_FAILED    0xC0001B5DL

//
// MessageId: EVENT_CALL_TO_FUNCTION_FAILED_II
//
// MessageText:
//
// The %1 call failed for %2 with the following error: %n%3
//
#define EVENT_CALL_TO_FUNCTION_FAILED_II 0xC0001B5EL

//
// MessageId: EVENT_REVERTED_TO_LASTKNOWNGOOD
//
// MessageText:
//
// The system reverted to its last known good configuration.  The system is restarting....
//
#define EVENT_REVERTED_TO_LASTKNOWNGOOD  0xC0001B5FL

//
// MessageId: EVENT_BAD_ACCOUNT_NAME
//
// MessageText:
//
// No backslash is in the account name.
//
#define EVENT_BAD_ACCOUNT_NAME           0xC0001B60L

//
// MessageId: EVENT_CONNECTION_TIMEOUT
//
// MessageText:
//
// Timeout (%1 milliseconds) waiting for the %2 service to connect.
//
#define EVENT_CONNECTION_TIMEOUT         0xC0001B61L

//
// MessageId: EVENT_READFILE_TIMEOUT
//
// MessageText:
//
// Timeout (%1 milliseconds) waiting for ReadFile.
//
#define EVENT_READFILE_TIMEOUT           0xC0001B62L

//
// MessageId: EVENT_TRANSACT_TIMEOUT
//
// MessageText:
//
// Timeout (%1 milliseconds) waiting for a transaction response from the %2 service.
//
#define EVENT_TRANSACT_TIMEOUT           0xC0001B63L

//
// MessageId: EVENT_TRANSACT_INVALID
//
// MessageText:
//
// Message returned in transaction has incorrect size.
//
#define EVENT_TRANSACT_INVALID           0xC0001B64L

//
// MessageId: EVENT_FIRST_LOGON_FAILED
//
// MessageText:
//
// Logon attempt with current password failed with the following error: %n%1
//
#define EVENT_FIRST_LOGON_FAILED         0xC0001B65L

//
// MessageId: EVENT_SECOND_LOGON_FAILED
//
// MessageText:
//
// Second logon attempt with old password also failed with the following error: %n%1
//
#define EVENT_SECOND_LOGON_FAILED        0xC0001B66L

//
// MessageId: EVENT_INVALID_DRIVER_DEPENDENCY
//
// MessageText:
//
// Boot-start or system-start driver (%1) must not depend on a service.
//
#define EVENT_INVALID_DRIVER_DEPENDENCY  0xC0001B67L

//
// MessageId: EVENT_BAD_SERVICE_STATE
//
// MessageText:
//
// The %1 service has reported an invalid current state %2.
//
#define EVENT_BAD_SERVICE_STATE          0xC0001B68L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_DEMAND
//
// MessageText:
//
// Detected circular dependencies demand starting %1.
//
#define EVENT_CIRCULAR_DEPENDENCY_DEMAND 0xC0001B69L

//
// MessageId: EVENT_CIRCULAR_DEPENDENCY_AUTO
//
// MessageText:
//
// Detected circular dependencies auto-starting services.
//
#define EVENT_CIRCULAR_DEPENDENCY_AUTO   0xC0001B6AL

//
// MessageId: EVENT_DEPEND_ON_LATER_SERVICE
//
// MessageText:
//
// Circular dependency: The %1 service depends on a service in a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_SERVICE    0xC0001B6BL

//
// MessageId: EVENT_DEPEND_ON_LATER_GROUP
//
// MessageText:
//
// Circular dependency: The %1 service depends on a group which starts later.
//
#define EVENT_DEPEND_ON_LATER_GROUP      0xC0001B6CL

//
// MessageId: EVENT_SEVERE_SERVICE_FAILED
//
// MessageText:
//
// About to revert to the last known good configuration because the %1 service failed to start.
//
#define EVENT_SEVERE_SERVICE_FAILED      0xC0001B6DL

//
// MessageId: EVENT_SERVICE_START_HUNG
//
// MessageText:
//
// The %1 service hung on starting.
//
#define EVENT_SERVICE_START_HUNG         0xC0001B6EL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED
//
// MessageText:
//
// The %1 service terminated with the following error: %n%2
//
#define EVENT_SERVICE_EXIT_FAILED        0xC0001B6FL

//
// MessageId: EVENT_SERVICE_EXIT_FAILED_SPECIFIC
//
// MessageText:
//
// The %1 service terminated with service-specific error %2.
//
#define EVENT_SERVICE_EXIT_FAILED_SPECIFIC 0xC0001B70L

//
// MessageId: EVENT_SERVICE_START_AT_BOOT_FAILED
//
// MessageText:
//
// At least one service or driver failed during system startup.  Use Event Viewer to examine the event log for details.
//
#define EVENT_SERVICE_START_AT_BOOT_FAILED 0xC0001B71L

//
// MessageId: EVENT_BOOT_SYSTEM_DRIVERS_FAILED
//
// MessageText:
//
// The following boot-start or system-start driver(s) failed to load: %1
//
#define EVENT_BOOT_SYSTEM_DRIVERS_FAILED 0xC0001B72L

//
// MessageId: EVENT_RUNNING_LASTKNOWNGOOD
//
// MessageText:
//
// Windows could not be started as configured.  A previous working configuration was used instead.
//
#define EVENT_RUNNING_LASTKNOWNGOOD      0xC0001B73L

//
// MessageId: EVENT_TAKE_OWNERSHIP
//
// MessageText:
//
// The %1 Registry key denied access to SYSTEM account programs so the Service Control Manager took ownership of the Registry key.
//
#define EVENT_TAKE_OWNERSHIP             0xC0001B74L

//
// This Text is used as a title for the message box used to display
// MessageId 7027.  It is not an event or error message.
//
//
// MessageId: TITLE_SC_MESSAGE_BOX
//
// MessageText:
//
// Service Control Manager %0
//
#define TITLE_SC_MESSAGE_BOX             0xC0001B75L

//
// MessageId: EVENT_SERVICE_NOT_INTERACTIVE
//
// MessageText:
//
// The %1 service is marked as an interactive service.  However, the system is configured to not allow interactive services.  This service may not function properly.
//
#define EVENT_SERVICE_NOT_INTERACTIVE    0xC0001B76L

//
// Parameter %4 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %5.
//
//
// MessageId: EVENT_SERVICE_CRASH
//
// MessageText:
//
// The %1 service terminated unexpectedly.  It has done this %2 time(s).  The following corrective action will be taken in %3 milliseconds: %5.
//
#define EVENT_SERVICE_CRASH              0xC0001B77L

//
// Parameter %1 is the value, in decimal, of the SC_ACTION_ constant for
// the action described in parameter %2.
//
//
// MessageId: EVENT_SERVICE_RECOVERY_FAILED
//
// MessageText:
//
// The Service Control Manager tried to take a corrective action (%2) after the unexpected termination of the %3 service, but this action failed with the following error: %n%4
//
#define EVENT_SERVICE_RECOVERY_FAILED    0xC0001B78L

//
// MessageId: EVENT_SERVICE_SCESRV_FAILED
//
// MessageText:
//
// The Service Control Manager did not initialize successfully. The security
// configuration server (scesrv.dll) failed to initialize with error %1.  The
// system is restarting...
//
#define EVENT_SERVICE_SCESRV_FAILED      0xC0001B79L

//
// MessageId: EVENT_SERVICE_CRASH_NO_ACTION
//
// MessageText:
//
// The %1 service terminated unexpectedly.  It has done this %2 time(s).
//
#define EVENT_SERVICE_CRASH_NO_ACTION    0xC0001B7AL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_CONTROL_SUCCESS
//
// MessageText:
//
#ifdef UNDER_CE
//  The %1 service was successfully %2.
#else  //  UNDER_CE
// The %1 service was successfully sent a %2 control.
#endif  //  UNDER_CE
//
#define EVENT_SERVICE_CONTROL_SUCCESS    0x40001B7BL

//
// Parameter %2 is the string name of the control
//
//
// MessageId: EVENT_SERVICE_STATUS_SUCCESS
//
// MessageText:
//
// The %1 service entered the %2 state.
//
#define EVENT_SERVICE_STATUS_SUCCESS     0x40001B7CL

//
// MessageId: EVENT_SERVICE_CONFIG_BACKOUT_FAILED
//
// MessageText:
//
// The Service Control Manager encountered an error undoing a configuration change
// to the %1 service.  The service's %2 is currently in an unpredictable state.
// 
// If you do not correct this configuration, you may not be able to restart the %1
// service or may encounter other errors.  To ensure that the service is configured
// properly, use the Services snap-in in Microsoft Management Console (MMC).
//
#define EVENT_SERVICE_CONFIG_BACKOUT_FAILED 0xC0001B7DL

//
// MessageId: EVENT_FIRST_LOGON_FAILED_II
//
// MessageText:
//
// The %1 service was unable to log on as %2 with the currently configured
// password due to the following error: %n%3%n%nTo ensure that the service is
// configured properly, use the Services snap-in in Microsoft Management
// Console (MMC).
//
#define EVENT_FIRST_LOGON_FAILED_II      0xC0001B7EL

//
// MessageId: EVENT_SERVICE_DIFFERENT_PID_CONNECTED
//
// MessageText:
//
// A service process other than the one launched by the Service Control Manager
// connected when starting the %1 service.  The Service Control Manager launched
// process %2 and process %3 connected instead.%n%n
// 
// Note that if this service is configured to start under a debugger, this behavior
// is expected.
//
#define EVENT_SERVICE_DIFFERENT_PID_CONNECTED 0x80001B7FL

//
// MessageId: EVENT_SERVICE_START_TYPE_CHANGED
//
// MessageText:
//
// The start type of the %1 service was changed from %2 to %3.
//
#define EVENT_SERVICE_START_TYPE_CHANGED 0x40001B80L

//
// MessageId: EVENT_SERVICE_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
// The %1 service was unable to log on as %2 with the currently configured
// password due to the following error:
// %nLogon failure: the user has not been granted the requested logon type at this
// computer.%n
// %nService: %1
// %nDomain and account: %2%n
// %nThis service account does not have the necessary user right "Log on as a service."%n
// %nUser Action%n
// %nAssign "Log on as a service" to the service account on this computer. You can
// use Local Security Settings (Secpol.msc) to do this. If this computer is a
// node in a cluster, check that this user right is assigned to the Cluster
// service account on all nodes in the cluster.%n
// %nIf you have already assigned this user right to the service account, and the
// user right appears to be removed, a Group Policy object associated with this
// node might be removing the right. Check with your domain administrator to find
// out if this is happening.
//
#define EVENT_SERVICE_LOGON_TYPE_NOT_GRANTED 0xC0001B81L

//
// MessageId: EVENT_SERVICE_STOP_SUCCESS_WITH_REASON
//
// MessageText:
//
// The %1 service was successfully sent a %2 control.%n%n
// The reason specified was: %3 [%4]%n%n
// Comment: %5
//
#define EVENT_SERVICE_STOP_SUCCESS_WITH_REASON 0x40001B82L

//
// MessageId: EVENT_SERVICE_SHUTDOWN_FAILED
//
// MessageText:
//
// The %1 service did not shutdown properly after receiving a preshutdown control.
//
#define EVENT_SERVICE_SHUTDOWN_FAILED    0xC0001B83L

//
// IMPORTANT NOTE: Do not add any new Vista+ SCM events in netevent.mc, please add those to base\screg\sc\manifests\services.man which contains
// Crimson-friendly event definitions. The SCM events defined here are not used by the eventvwr MMC snapin but continue to remain here due to
// few components depending on the definition (test code, tools code, etc.)
//
//
// Schedule (AT command) Service Events 7900 - 7999
//
//
// MessageId: EVENT_COMMAND_NOT_INTERACTIVE
//
// MessageText:
//
// The %1 command is marked as an interactive command.  However, the system is
// configured to not allow interactive command execution.  This command may not
// function properly.
//
#define EVENT_COMMAND_NOT_INTERACTIVE    0xC0001EDCL

//
// MessageId: EVENT_COMMAND_START_FAILED
//
// MessageText:
//
// The %1 command failed to start due to the following error: %n%2
//
#define EVENT_COMMAND_START_FAILED       0xC0001EDDL


/////////////////////////////////////////////////////////////////////////
//
// Lanman Bowser/Browser Events (8000-8499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_BOWSER_OTHER_MASTER_ON_NET
//
// MessageText:
//
// The master browser has received a server announcement from the computer %2
// that believes that it is the master browser for the domain on transport %3.
// The master browser is stopping or an election is being forced.
//
#define EVENT_BOWSER_OTHER_MASTER_ON_NET 0xC0001F43L

//
// MessageId: EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER
//
// MessageText:
//
// A request has been submitted to promote the computer to backup when it is already a
// master browser.
//
#define EVENT_BOWSER_PROMOTED_WHILE_ALREADY_MASTER 0x80001F44L

//
// MessageId: EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE
//
// MessageText:
//
// The browser has received a server announcement indicating that the computer %2
// is a master browser, but this computer is not a master browser.
//
#define EVENT_BOWSER_NON_MASTER_MASTER_ANNOUNCE 0x80001F45L

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM
//
// MessageText:
//
// The browser has received an illegal datagram from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM    0x80001F46L

//
// MessageId: EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED
//
// MessageText:
//
// The browser was unable to update the service status bits.  The data is the error.
//
#define EVENT_BROWSER_STATUS_BITS_UPDATE_FAILED 0xC0001F47L

//
// MessageId: EVENT_BROWSER_ROLE_CHANGE_FAILED
//
// MessageText:
//
// The browser was unable to update its role.  The data is the error.
//
#define EVENT_BROWSER_ROLE_CHANGE_FAILED 0xC0001F48L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED
//
// MessageText:
//
// The browser was unable to promote itself to master browser.  The computer that currently
// believes it is the master browser is %1.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED 0xC0001F49L

//
// MessageId: EVENT_BOWSER_NAME_CONVERSION_FAILED
//
// MessageText:
//
// The browser driver was unable to convert a character string to a unicode string.
//
#define EVENT_BOWSER_NAME_CONVERSION_FAILED 0xC0001F4AL

//
// MessageId: EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED
//
// MessageText:
//
// The browser was unable to add the configuration parameter %1.
//
#define EVENT_BROWSER_OTHERDOMAIN_ADD_FAILED 0xC0001F4BL

//
// MessageId: EVENT_BOWSER_ELECTION_RECEIVED
//
// MessageText:
//
// The browser driver has received an election packet from computer %2 on network %3.  The data is the packet received.
//
#define EVENT_BOWSER_ELECTION_RECEIVED   0x00001F4CL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED
//
// MessageText:
//
// The browser driver has forced an election on network %2 because it was unable to find a master browser to retrieve a backup list on that network.
//
#define EVENT_BOWSER_ELECTION_SENT_GETBLIST_FAILED 0x40001F4DL

//
// MessageId: EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED
//
// MessageText:
//
// The browser driver has forced an election on network %2 because it was unable to find a master browser for that network.
//
#define EVENT_BOWSER_ELECTION_SENT_FIND_MASTER_FAILED 0x40001F4EL

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED
//
// MessageText:
//
// The browser has forced an election on network %1 because a Windows Server (or domain master) browser is started.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STARTED 0x40001F4FL

//
// MessageId: EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD
//
// MessageText:
//
// The browser driver has received too many illegal datagrams from the remote computer %2 to name %3 on transport %4.  The data is the datagram.
// No more events will be generated until the reset frequency has expired.
//
#define EVENT_BOWSER_ILLEGAL_DATAGRAM_THRESHOLD 0xC0001F50L

//
// MessageId: EVENT_BROWSER_DEPENDANT_SERVICE_FAILED
//
// MessageText:
//
// The browser has failed to start because the dependent service %1 had invalid service status %2.
// Status             Meaning
//   1              Service Stopped%n
//   2              Start Pending%n
//   3              Stop Pending%n
//   4              Running%n
//   5              Continue Pending%n
//   6              Pause Pending%n
//   7              Paused%n
//
#define EVENT_BROWSER_DEPENDANT_SERVICE_FAILED 0xC0001F51L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING
//
// MessageText:
//
// The browser was unable to promote itself to master browser.  The browser will continue
// to attempt to promote itself to the master browser, but will no longer log any events in the event log in Event Viewer.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_STOPPING 0xC0001F53L

//
// MessageId: EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER
//
// MessageText:
//
// The browser was unable to promote itself to master browser.  The computer that currently
// believes it is the master browser is unknown.
//
#define EVENT_BROWSER_MASTER_PROMOTION_FAILED_NO_MASTER 0xC0001F54L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_FAILED
//
// MessageText:
//
// The browser service was unable to retrieve a list of servers from the browser master %1 on the network %2.%n
// %n
// Browser master: %1%n
// Network: %2%n
// %n
// This event may be caused by a temporary loss of network connectivity. If this message appears again, verify that the server is still connected to the network. The return code is in the Data text box.
//
#define EVENT_BROWSER_SERVER_LIST_FAILED 0x80001F55L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_FAILED
//
// MessageText:
//
// The browser service was unable to retrieve a list of domains from the browser master %1 on the network %2.%n
// %n
// Browser master: %1%n
// Network: %2%n
// %n
// This event may be caused by a temporary loss of network connectivity. If this message appears again, verify that the server is still connected to the network. The return code is in the Data text box.
//
#define EVENT_BROWSER_DOMAIN_LIST_FAILED 0x80001F56L

//
// MessageId: EVENT_BROWSER_ILLEGAL_CONFIG
//
// MessageText:
//
// The value for the parameter %1 to the browser service was illegal.
//
#define EVENT_BROWSER_ILLEGAL_CONFIG     0x80001F57L

//
// MessageId: EVENT_BOWSER_OLD_BACKUP_FOUND
//
// MessageText:
//
// The backup browser server %2 is out-of-date.  Consider upgrading this computer.
//
#define EVENT_BOWSER_OLD_BACKUP_FOUND    0x40001F58L

//
// MessageId: EVENT_BROWSER_SERVER_LIST_RETRIEVED
//
// MessageText:
//
// The browser has retrieved a list of servers from remote computer %1 on transport %2.%n
// There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_SERVER_LIST_RETRIEVED 0x00001F59L

//
// MessageId: EVENT_BROWSER_DOMAIN_LIST_RETRIEVED
//
// MessageText:
//
// The browser has retrieved a list of domains from remote computer %1 on transport %2.%n
// There were %3 entries read, and %4 total entries.
//
#define EVENT_BROWSER_DOMAIN_LIST_RETRIEVED 0x00001F5AL

//
// MessageId: EVENT_BOWSER_PDC_LOST_ELECTION
//
// MessageText:
//
// The browser running on the Domain Controller has lost an election.  The computer that won the election is %2, on the transport %3.%n
// The data contains the election version, election criteria, and remote computer time up, and the same information for
// the current computer.
//
#define EVENT_BOWSER_PDC_LOST_ELECTION   0x40001F5BL

//
// MessageId: EVENT_BOWSER_NON_PDC_WON_ELECTION
//
// MessageText:
//
// The browser running on this computer has won a browser election on network %2.
// This computer is a member of a domain, so the Domain Controller should become the master
// browser.
//
#define EVENT_BOWSER_NON_PDC_WON_ELECTION 0x40001F5CL

//
// MessageId: EVENT_BOWSER_CANT_READ_REGISTRY
//
// MessageText:
//
// The browser driver was unable to initialize variables from the Registry.
//
#define EVENT_BOWSER_CANT_READ_REGISTRY  0x40001F5DL

//
// MessageId: EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED
//
// MessageText:
//
// The browser driver has discarded too many mailslot messages.
//
#define EVENT_BOWSER_MAILSLOT_DATAGRAM_THRESHOLD_EXCEEDED 0x40001F5EL

//
// MessageId: EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED
//
// MessageText:
//
// The browser driver has discarded too many GetBrowserServerList requests.
//
#define EVENT_BOWSER_GETBROWSERLIST_THRESHOLD_EXCEEDED 0x40001F5FL

//
// MessageId: EVENT_BROWSER_BACKUP_STOPPED
//
// MessageText:
//
// The browser service has failed to retrieve the backup list too many times on transport %1.
// The backup browser is stopping.
//
#define EVENT_BROWSER_BACKUP_STOPPED     0xC0001F60L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED
//
// MessageText:
//
// The browser has forced an election on network %1 because a master browser was stopped.
//
#define EVENT_BROWSER_ELECTION_SENT_LANMAN_NT_STOPPED 0x40001F61L

//
// MessageId: EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER
//
// MessageText:
//
// The browser has received a GetBrowserServerList request when it is not the master browser.
//
#define EVENT_BROWSER_GETBLIST_RECEIVED_NOT_MASTER 0xC0001F62L

//
// MessageId: EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED
//
// MessageText:
//
// The browser has forced an election on network %1 because the Domain Controller (or Server) has changed its role.
//
#define EVENT_BROWSER_ELECTION_SENT_ROLE_CHANGED 0x40001F63L

//
// MessageId: EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH
//
// MessageText:
//
// The browser has failed to start because of an error in the DirectHostBinding parameter to the browser.
//
#define EVENT_BROWSER_NOT_STARTED_IPX_CONFIG_MISMATCH 0xC0001F64L


/////////////////////////////////////////////////////////////////////////
//
// Sap Agent Events (8500-8999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: NWSAP_EVENT_KEY_NOT_FOUND
//
// MessageText:
//
// The Registry Key %1 was not present.  The Sap Agent could not start.
//
#define NWSAP_EVENT_KEY_NOT_FOUND        0xC0002134L

//
// MessageId: NWSAP_EVENT_WSASTARTUP_FAILED
//
// MessageText:
//
// Winsock startup routine failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WSASTARTUP_FAILED    0xC0002135L

//
// MessageId: NWSAP_EVENT_SOCKET_FAILED
//
// MessageText:
//
// Socket create call failed for main socket. The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SOCKET_FAILED        0xC0002136L

//
// MessageId: NWSAP_EVENT_SETOPTBCAST_FAILED
//
// MessageText:
//
// Setting broadcast option on socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SETOPTBCAST_FAILED   0xC0002137L

//
// MessageId: NWSAP_EVENT_BIND_FAILED
//
// MessageText:
//
// Binding to SAP Socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BIND_FAILED          0xC0002138L

//
// MessageId: NWSAP_EVENT_GETSOCKNAME_FAILED
//
// MessageText:
//
// Getting bound address of socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_GETSOCKNAME_FAILED   0xC0002139L

//
// MessageId: NWSAP_EVENT_OPTEXTENDEDADDR_FAILED
//
// MessageText:
//
// Setting option EXTENDED_ADDRESS failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTEXTENDEDADDR_FAILED 0xC000213AL

//
// MessageId: NWSAP_EVENT_OPTBCASTINADDR_FAILED
//
// MessageText:
//
// Setting NWLink option BCASTINTADDR failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTBCASTINADDR_FAILED 0xC000213BL

//
// MessageId: NWSAP_EVENT_CARDMALLOC_FAILED
//
// MessageText:
//
// Error allocating memory to hold a card structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDMALLOC_FAILED    0xC000213CL

//
// MessageId: NWSAP_EVENT_NOCARDS
//
// MessageText:
//
// Enumeration of cards returned 0 cards.
//
#define NWSAP_EVENT_NOCARDS              0xC000213DL

//
// MessageId: NWSAP_EVENT_THREADEVENT_FAIL
//
// MessageText:
//
// Error creating thread counting event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_THREADEVENT_FAIL     0xC000213EL

//
// MessageId: NWSAP_EVENT_RECVSEM_FAIL
//
// MessageText:
//
// Error creating receive semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_RECVSEM_FAIL         0xC000213FL

//
// MessageId: NWSAP_EVENT_SENDEVENT_FAIL
//
// MessageText:
//
// Error creating send event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SENDEVENT_FAIL       0xC0002140L

//
// MessageId: NWSAP_EVENT_STARTRECEIVE_ERROR
//
// MessageText:
//
// Error starting receive thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTRECEIVE_ERROR   0xC0002141L

//
// MessageId: NWSAP_EVENT_STARTWORKER_ERROR
//
// MessageText:
//
// Error starting worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWORKER_ERROR    0xC0002142L

//
// MessageId: NWSAP_EVENT_TABLE_MALLOC_FAILED
//
// MessageText:
//
// Error allocating database array.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_TABLE_MALLOC_FAILED  0xC0002143L

//
// MessageId: NWSAP_EVENT_HASHTABLE_MALLOC_FAILED
//
// MessageText:
//
// Error allocating hash table.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_HASHTABLE_MALLOC_FAILED 0xC0002144L

//
// MessageId: NWSAP_EVENT_STARTLPCWORKER_ERROR
//
// MessageText:
//
// Error starting LPC worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTLPCWORKER_ERROR 0xC0002145L

//
// MessageId: NWSAP_EVENT_CREATELPCPORT_ERROR
//
// MessageText:
//
// Error creating the LPC port.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCPORT_ERROR  0xC0002146L

//
// MessageId: NWSAP_EVENT_CREATELPCEVENT_ERROR
//
// MessageText:
//
// Error creating the LPC thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CREATELPCEVENT_ERROR 0xC0002147L

//
// MessageId: NWSAP_EVENT_LPCLISTENMEMORY_ERROR
//
// MessageText:
//
// Error allocating memory for an LPC Client structure.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCLISTENMEMORY_ERROR 0xC0002148L

//
// MessageId: NWSAP_EVENT_LPCHANDLEMEMORY_ERROR
//
// MessageText:
//
// Error allocating buffer to hold LPC worker thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_LPCHANDLEMEMORY_ERROR 0xC0002149L

//
// MessageId: NWSAP_EVENT_BADWANFILTER_VALUE
//
// MessageText:
//
// The value for WANFilter in the registry must be 0-2.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_BADWANFILTER_VALUE   0xC000214AL

//
// MessageId: NWSAP_EVENT_CARDLISTEVENT_FAIL
//
// MessageText:
//
// Error creating event for card list access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_CARDLISTEVENT_FAIL   0xC000214BL

//
// MessageId: NWSAP_EVENT_SDMDEVENT_FAIL
//
// MessageText:
//
// Error creating event for database access synchronization.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_SDMDEVENT_FAIL       0xC000214CL

//
// MessageId: NWSAP_EVENT_INVALID_FILTERNAME
//
// MessageText:
//
// Name too long in key %1: Name = %s.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_INVALID_FILTERNAME   0x8000214DL

//
// MessageId: NWSAP_EVENT_WANSEM_FAIL
//
// MessageText:
//
// Error creating WAN control semaphore.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSEM_FAIL          0xC000214EL

//
// MessageId: NWSAP_EVENT_WANSOCKET_FAILED
//
// MessageText:
//
// Socket create call failed for WAN socket.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANSOCKET_FAILED     0xC000214FL

//
// MessageId: NWSAP_EVENT_WANBIND_FAILED
//
// MessageText:
//
// Binding to WAN socket failed.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANBIND_FAILED       0xC0002150L

//
// MessageId: NWSAP_EVENT_STARTWANWORKER_ERROR
//
// MessageText:
//
// Error starting WAN worker thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANWORKER_ERROR 0xC0002151L

//
// MessageId: NWSAP_EVENT_STARTWANCHECK_ERROR
//
// MessageText:
//
// Error starting WAN check thread.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_STARTWANCHECK_ERROR  0xC0002152L

//
// MessageId: NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR
//
// MessageText:
//
// Error on getsockopt IPX_MAX_ADAPTER_NUM.  Data is the error code.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_OPTMAXADAPTERNUM_ERROR 0xC0002153L

//
// MessageId: NWSAP_EVENT_WANHANDLEMEMORY_ERROR
//
// MessageText:
//
// Error allocating buffer to hold WAN notify thread handles.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANHANDLEMEMORY_ERROR 0xC0002154L

//
// MessageId: NWSAP_EVENT_WANEVENT_ERROR
//
// MessageText:
//
// Error creating the WAN thread event.  The Sap Agent cannot continue.
//
#define NWSAP_EVENT_WANEVENT_ERROR       0xC0002155L


/////////////////////////////////////////////////////////////////////////
//
// Transport Events (9000-9499)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_TRANSPORT_RESOURCE_POOL
//
// MessageText:
//
// %2 could not allocate a resource of type %3 due to system resource problems.
//
#define EVENT_TRANSPORT_RESOURCE_POOL    0x80002329L

//
// MessageId: EVENT_TRANSPORT_RESOURCE_LIMIT
//
// MessageText:
//
// %2 could not allocate a resource of type %3 due to its configured size of %4.
//
#define EVENT_TRANSPORT_RESOURCE_LIMIT   0x8000232AL

//
// MessageId: EVENT_TRANSPORT_RESOURCE_SPECIFIC
//
// MessageText:
//
// %2 could not allocate a resource of type %3 due to a specifically configured limit of %4.
//
#define EVENT_TRANSPORT_RESOURCE_SPECIFIC 0x8000232BL

//
// MessageId: EVENT_TRANSPORT_REGISTER_FAILED
//
// MessageText:
//
// %2 failed to register itself with the NDIS wrapper.
//
#define EVENT_TRANSPORT_REGISTER_FAILED  0xC000232CL

//
// MessageId: EVENT_TRANSPORT_BINDING_FAILED
//
// MessageText:
//
// %2 failed to bind to network adapter %3.
//
#define EVENT_TRANSPORT_BINDING_FAILED   0xC000232DL

//
// MessageId: EVENT_TRANSPORT_ADAPTER_NOT_FOUND
//
// MessageText:
//
// %2 could not find network adapter %3.
//
#define EVENT_TRANSPORT_ADAPTER_NOT_FOUND 0xC000232EL

//
// MessageId: EVENT_TRANSPORT_SET_OID_FAILED
//
// MessageText:
//
// %2 failed while setting object identifier %3 on network adapter %4.
//
#define EVENT_TRANSPORT_SET_OID_FAILED   0xC000232FL

//
// MessageId: EVENT_TRANSPORT_QUERY_OID_FAILED
//
// MessageText:
//
// %2 failed while querying object identifier %3 on network adapter %4.
//
#define EVENT_TRANSPORT_QUERY_OID_FAILED 0xC0002330L

//
// MessageId: EVENT_TRANSPORT_TRANSFER_DATA
//
// MessageText:
//
// %2 could not transfer a packet from the network adapter.  The packet was dropped.
//
#define EVENT_TRANSPORT_TRANSFER_DATA    0x40002331L

//
// MessageId: EVENT_TRANSPORT_TOO_MANY_LINKS
//
// MessageText:
//
// %2 could not create a link to a remote computer.  Your computer has exceeded the number of connections it can make to that remote computer.
//
#define EVENT_TRANSPORT_TOO_MANY_LINKS   0x40002332L

//
// MessageId: EVENT_TRANSPORT_BAD_PROTOCOL
//
// MessageText:
//
// %2 received an unexpected %3 packet from a remote computer.
//
#define EVENT_TRANSPORT_BAD_PROTOCOL     0x40002333L


/////////////////////////////////////////////////////////////////////////
//
// IPX/SPX Events (9500-9999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_IPX_NEW_DEFAULT_TYPE
//
// MessageText:
//
// The default frame type for auto-detection on %2 was changed to %3.
// This type is now the default if no frame type can be detected.
//
#define EVENT_IPX_NEW_DEFAULT_TYPE       0x4000251DL

//
// MessageId: EVENT_IPX_SAP_ANNOUNCE
//
// MessageText:
//
// A SAP announcement was sent over %2 which is configured for multiple
// networks, but no internal network is configured. This may prevent
// machines on some networks from locating the advertised service.
//
#define EVENT_IPX_SAP_ANNOUNCE           0x8000251EL

//
// MessageId: EVENT_IPX_ILLEGAL_CONFIG
//
// MessageText:
//
// The value for the %2 parameter %3 was illegal.
//
#define EVENT_IPX_ILLEGAL_CONFIG         0x8000251FL

//
// MessageId: EVENT_IPX_INTERNAL_NET_INVALID
//
// MessageText:
//
// %2 was configured with an internal network number of %3. This network
// number conflicts with one of the attached networks. The configured
// internal network number will be ignored.
//
#define EVENT_IPX_INTERNAL_NET_INVALID   0xC0002520L

//
// MessageId: EVENT_IPX_NO_FRAME_TYPES
//
// MessageText:
//
// %2 had no frame types configured for the binding to adapter %3.
//
#define EVENT_IPX_NO_FRAME_TYPES         0xC0002521L

//
// MessageId: EVENT_IPX_CREATE_DEVICE
//
// MessageText:
//
// %2 failed to initialize because the driver device could not be created.
//
#define EVENT_IPX_CREATE_DEVICE          0xC0002522L

//
// MessageId: EVENT_IPX_NO_ADAPTERS
//
// MessageText:
//
// %2 could not bind to any adapters. The transport could not start.
//
#define EVENT_IPX_NO_ADAPTERS            0xC0002523L


/////////////////////////////////////////////////////////////////////////
//
// DCOM Events (10000-10999)
//
//
/////////////////////////////////////////////////////////////////////////


//
// MessageId: EVENT_RPCSS_CREATEPROCESS_FAILURE
//
// MessageText:
//
// Unable to start a DCOM Server: %3.
// The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_CREATEPROCESS_FAILURE 0xC0002710L

//
// MessageId: EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
// Unable to start a DCOM Server: %3 as %4/%5.
// The error:%n"%%%2"%nHappened while starting this command:%n%1
//
#define EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE 0xC0002711L

//
// MessageId: EVENT_RPCSS_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
// Access denied attempting to launch a DCOM Server.
// The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_LAUNCH_ACCESS_DENIED 0xC0002712L

//
// MessageId: EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED
//
// MessageText:
//
// Access denied attempting to launch a DCOM Server using DefaultLaunchPermssion.
// The server is:%n%1%nThe user is %2/%3, SID=%4.
//
#define EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED 0xC0002713L

//
// MessageId: EVENT_RPCSS_RUNAS_CANT_LOGIN
//
// MessageText:
//
// DCOM got error "%%%1" and was unable to logon %2\%3
// in order to run the server:%n%4
//
#define EVENT_RPCSS_RUNAS_CANT_LOGIN     0xC0002714L

//
// MessageId: EVENT_RPCSS_START_SERVICE_FAILURE
//
// MessageText:
//
// DCOM got error "%%%1" attempting to start the service %2 with arguments "%3"
// in order to run the server:%n%4
//
#define EVENT_RPCSS_START_SERVICE_FAILURE 0xC0002715L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR
//
// MessageText:
//
// DCOM got error "%%%1" from the computer %2 when attempting to
// activate the server:%n%3
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR    0xC0002716L

//
// MessageId: EVENT_RPCSS_ACTIVATION_ERROR
//
// MessageText:
//
// DCOM got error "%%%1" when attempting to
// activate the server:%n%2
//
#define EVENT_RPCSS_ACTIVATION_ERROR     0xC0002717L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE
//
// MessageText:
//
// DCOM got error "%%%1" from the computer %2 when attempting to
// the server:%n%3 with file %4.
//
#define EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE 0xC0002718L

//
// MessageId: EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE
//
// MessageText:
//
// DCOM was unable to communicate with the computer %1 using any of the configured
// protocols.
//
#define EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE 0xC0002719L

//
// MessageId: EVENT_RPCSS_SERVER_START_TIMEOUT
//
// MessageText:
//
// The server %1 did not register with DCOM within the required timeout.
//
#define EVENT_RPCSS_SERVER_START_TIMEOUT 0xC000271AL

//
// MessageId: EVENT_RPCSS_SERVER_NOT_RESPONDING
//
// MessageText:
//
// The server %1 could not be contacted to establish the connection to the client
//
#define EVENT_RPCSS_SERVER_NOT_RESPONDING 0xC000271BL

//
// MessageId: EVENT_DCOM_ASSERTION_FAILURE
//
// MessageText:
//
// There is an assertion failure in DCOM.  Context follows:
// %1
// %2
// %3
//
#define EVENT_DCOM_ASSERTION_FAILURE     0xC000271CL

//
// MessageId: EVENT_DCOM_INVALID_ENDPOINT_DATA
//
// MessageText:
//
// DCOM server attempted to listen on an invalid endpoint.
// Protseq:  %1
// Endpoint: %2
// Flags:    %3
//
#define EVENT_DCOM_INVALID_ENDPOINT_DATA 0xC000271DL

//
// MessageId: EVENT_DCOM_COMPLUS_DISABLED
//
// MessageText:
//
// The activation for CLSID %1 failed because remote activations for COM+ are disabled.
// To enable this functionality use the Configure Your Server wizard and select the Web
// Application Server role.
//
#define EVENT_DCOM_COMPLUS_DISABLED      0xC000271EL


/////////////////////////////////////////////////////////////////////////
//
// DNS Caching Resolvers Service and DNS API Events (11000-11999)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DLL
//
// MessageText:
//
// Unable to start DNS Client Service.
// Failed to load DLL %2, Error: %1.
// Please reinstall this DLL from installation CD.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DLL 0xC0002AF8L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY
//
// MessageText:
//
// Unable to start DNS Client service. Can not find entry %3 in DLL %2.
// Please reinstall this DLL from installation CD. For specific error
// code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_ENTRY 0xC0002AF9L

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL
//
// MessageText:
//
// Unable to start the DNS Client service. The system could not register a
// service control handler and could be out of resources. Close any
// applications not in use or reboot the computer. For specific error
// code, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_CONTROL 0xC0002AFAL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT
//
// MessageText:
//
// Unable to start DNS Client service. The system could
// not create a termination event for this service and
// could be out of resources. Close any applications not
// in use or reboot the computer. For specific error code,
// see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_DONE_EVENT 0xC0002AFBL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_RPC
//
// MessageText:
//
// Unable to start DNS Client service. Could not start the
// Remote Procedure Call (RPC) interface for this service.
// To correct the problem, you may restart the RPC and DNS
// Client services. To do so, use the following commands at a command
// prompt: (1) type "net start rpc" to start the RPC service, and (2)
// type "net start dnscache" to start the DNS Client service. For
// specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_RPC 0xC0002AFCL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY
//
// MessageText:
//
// Unable to start DNS Client service. The system could not register
// shutdown notification for this service and could be out of resources.
// Try closing any applications not in use or reboot the computer.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_SHUTDOWN_NOTIFY 0xC0002AFDL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE
//
// MessageText:
//
// Unable to start DNS Client service. Could not update status with
// Service Control Manager. To correct the problem, you may restart
// the RPC and DNS Client services. To do so, use the following commands
// at a command prompt: (1) type "net start rpc" to start the RPC service,
// and (2) type "net start dnscache" to start the DNS Client service. For
// specific error code information, see the record data displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_NO_UPDATE 0xC0002AFEL

//
// MessageId: EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY
//
// MessageText:
//
// Unable to start DNS Client service because the system failed to allocate
// memory and may be out of available memory. Try closing any applications not
// in use or reboot the computer. For specific error code, see the record data
// displayed below.
//
#define EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY 0xC0002AFFL


//
// Warnings
//

//
// MessageId: EVENT_DNS_CACHE_NETWORK_PERF_WARNING
//
// MessageText:
//
// The DNS Client service could not contact any DNS servers for
// a repeated number of attempts. For the next %3 seconds the
// DNS Client service will not use the network to avoid further
// network performance problems. It will resume its normal behavior
// after that. If this problem persists, verify your TCP/IP
// configuration, specifically check that you have a preferred
// (and possibly an alternate) DNS server configured. If the problem
// continues, verify network conditions to these DNS servers or contact
// your network administrator.
//
#define EVENT_DNS_CACHE_NETWORK_PERF_WARNING 0x80002B2AL

//
// MessageId: EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING
//
// MessageText:
//
// The DNS Client service failed to reach DNS server at address %1. It will
// not use this DNS server for %2 seconds.
//
#define EVENT_DNS_CACHE_UNABLE_TO_REACH_SERVER_WARNING 0x80002B2BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS Server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The cause of this DNS registration failure was because the DNS update
// request timed out after being sent to the specified DNS Server. This is
// probably because the authoritative DNS server for the name being updated
// is not running.%n%n You can manually retry registration of the network
// adapter and its settings by typing "ipconfig /registerdns" at the command
// prompt. If problems still  persist, contact your network systems
// administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT 0x80002B8EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The cause of this DNS registration failure was because of DNS server failure.
// This may be due to a zone transfer that has locked the DNS server for the
// applicable zone that your computer needs to register itself with.%n%n
// (The applicable zone should typically correspond to the Adapter-specific
// Domain Suffix that was indicated above.) You can manually retry registration
// of the network adapter and its settings by typing "ipconfig /registerdns"
// at the command prompt. If problems still persist, contact your network
// systems administrator to verify network conditions.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL 0x80002B8FL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason it could not register was because either: (a) the DNS server
// does not support the DNS dynamic update protocol, or (b) the primary zone
// authoritative for the registering names does not currently accept dynamic
// updates.%n%n To add or register a DNS host (A or AAAA) resource record using 
// the specific DNS name for this adapter, contact your DNS server or network
// systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP 0x80002B90L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason it could not register was because the DNS server refused the
// dynamic update request. This could happen for the following reasons:
// (a) current DNS update policies do not allow this computer to update
// the DNS domain name configured for this adapter, or (b) the authoritative
// DNS server for this DNS domain name does not support the DNS dynamic update
// protocol.%n%n
// To register a DNS host (A or AAAA) resource record using the specific DNS 
// domain name for this adapter, contact your DNS server or network systems
// administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED 0x80002B91L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The system could not register the DNS update request because of a
// security related problem. This could happen for the following reasons:
// (a) the DNS domain name that your computer is trying to register could
// not be updated because your computer does not have the right permissions,
// or (b) there might have been a problem negotiating valid credentials
// with the DNS server to update.%n%n
// You can manually retry DNS registration of the network adapter and its
// settings by typing "ipconfig /registerdns" at the command prompt. If
// problems still persist, contact your DNS server or network systems
// administrator. For specific error code information, see the record data
// displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY 0x80002B92L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
// The system failed to register network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the DNS update request could not be completed was because
// of a system problem. You can manually retry DNS registration of the
// network adapter and its settings by typing "ipconfig /registerdns"
// at the command prompt. If problems still persist, contact your DNS
// server or network systems administrator. For specific error code
// information, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER 0x80002B93L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The reason that the system could not register these RRs was because the
// update request that was sent to the specified DNS server timed out. This
// is probably because the authoritative DNS server for the name being
// registered is not running.%n%n You can manually retry DNS registration
// of the network adapter and its settings by typing "ipconfig /registerdns"
// at the command prompt. If problems still persist, contact your DNS
// server or network systems administrator. For specific error code
// information, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_TIMEOUT 0x80002B94L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The cause was DNS server failure. This may because the reverse lookup
// zone is busy or missing on the DNS server that your computer needs to
// update. In most cases, this is a minor problem because it does not
// affect normal (forward) name resolution.%n%n If reverse (address-to-name)
// resolution is required for your computer, you can manually retry DNS
// registration of the network adapter and its settings by typing 
// "ipconfig /registerdns" at the command prompt. If problems still 
// persist, contact your DNS server or network systems administrator. 
// For specific error code information, see the record data below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SERVERFAIL 0x80002B95L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The reason that the system could not register these RRs was because
// (a) either the DNS server does not support the DNS dynamic update
// protocol, or (b) the authoritative zone where these records are to
// be registered does not allow dynamic updates.%n%n
// To register DNS pointer (PTR) resource records using the specific
// DNS domain name and IP addresses for this adapter, contact your
// DNS server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_NOTSUPP 0x80002B96L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The reason that the system could not register these RRs was because
// the DNS server refused the update request. The cause of this could
// be (a) your computer is not allowed to update the adapter-specified DNS
// domain name, or (b) because the DNS server authoritative for the specified
// name does not support the DNS dynamic update protocol.%n%n
// To register the DNS pointer (PTR) resource records using the specific
// DNS domain name and IP addresses for this adapter, contact your DNS
// server or network systems administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_REFUSED 0x80002B97L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The reason that the system could not register these RRs was because
// of a security related problem. The cause of this could be (a) your
// computer does not have permissions to register and update the specific
// DNS domain name set for this adapter, or (b) there might have been a
// problem negotiating valid credentials with the DNS server during the
// processing of the update request.%n%n
// You can manually retry DNS registration of the network adapter and
// its settings by typing "ipconfig /registerdns" at the command prompt.
// If problems still persist, contact your DNS server or network systems
// administrator.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_SECURITY 0x80002B98L

//
// MessageId: EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER
//
// MessageText:
//
// The system failed to register pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The reason the system could not register these RRs during the
// update request was because of a system problem. You can manually
// retry DNS registration of the network adapter and its settings by
// typing "ipconfig /registerdns" at the command prompt. If problems
// still persist, contact your DNS server or network systems
// administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_REGISTRATION_FAILED_OTHER 0x80002B99L

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not register these RRs was because the
// update request it sent to the DNS server timed out. The most likely
// cause of this is that the DNS server authoritative for the name it
// was attempting to register or update is not running at this time.%n%n
// You can manually retry DNS registration of the network adapter and
// its settings by typing "ipconfig /registerdns" at the command prompt.
// If problems still persist, contact your DNS server or network systems
// administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002B9AL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not register these RRs was because the
// DNS server failed the update request. The most likely cause of this
// is that the authoritative DNS server required to process this update
// request has a lock in place on the zone, probably because a zone
// transfer is in progress.%n%n
// You can manually retry DNS registration of the network adapter and
// its settings by typing "ipconfig /registerdns" at the command prompt.
// If problems still persist, contact your DNS server or network systems
// administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002B9BL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records for 
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// Either the DNS server does not support the DNS dynamic update protocol 
// or the authoritative zone for the specified DNS domain name does not 
// accept dynamic updates.%n%n
// To register the DNS host (A or AAAA) resource records using the specific
// DNS domain name and IP addresses for this adapter, contact your DNS 
// server or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002B9CL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not register these RRs was because the
// DNS server contacted refused the update request. The reasons for this
// might be (a) you are not allowed to update the specified DNS domain name,
// or (b) because the DNS server authoritative for this name does not support
// the DNS dynamic update protocol.%n%n
// To register the DNS host (A or AAAA) resource records using the specific DNS
// domain name and IP addresses for this adapter, contact your DNS server
// or network systems administrator.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002B9DL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not register these RRs was because of a
// security related problem. The cause of this could be (a) your computer
// does not have permissions to register and update the specific DNS domain
// name set for this adapter, or (b) there might have been a problem negotiating
// valid credentials with the DNS server during the processing of the update
// request.%n%n
// You can manually retry DNS registration of the network adapter and
// its settings by typing "ipconfig /registerdns" at the command prompt.
// If problems still persist, contact your DNS server or network systems
// administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002B9EL

//
// MessageId: EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
// The system failed to register host (A or AAAA) resource records (RRs) for
// network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not register these RRs during the
// update request was because of a system problem. You can manually
// retry DNS registration of the network adapter and its settings by
// typing "ipconfig /registerdns" at the command prompt. If problems
// still persist, contact your DNS server or network systems
// administrator. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_REGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002B9FL


//
// Deregistration update errors
//

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
// The system failed to update and remove registration for the
// network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason for this failure is because the DNS server it sent the update
// request to timed out. The most likely cause of this failure is that the
// DNS server authoritative for the zone where the registration was originally
// made is either not running or unreachable through the network at this time.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT 0x80002BACL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
// The system failed to update and remove registration for the
// network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason for this failure is because the DNS server it sent the update
// to failed the update request. A possible cause of this failure is that
// the DNS server required to process this update request has a lock in place
// on the zone, probably because a zone transfer is in progress.%n%n
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BADL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
// The system failed to update and remove registration for the network
// adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason for this failure is because the DNS server sent the update
// either (a) does not support the DNS dynamic update protocol, or (b) the
// authoritative zone for the specified DNS domain name does not currently
// accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP 0x80002BAEL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
// The system failed to update and remove registration for the network
// adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not perform the update request was the
// DNS server contacted refused update request. The cause of this is
// (a) this computer is not allowed to update the specified DNS domain
// name, or (b) because the DNS server authoritative for the zone that
// requires updating does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED 0x80002BAFL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
// The system failed to update and remove registration for the network
// adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the system could not perform the update request was because
// of a security related problem. The cause of this could be (a) your computer
// does not have permissions to register and update the specific DNS domain
// name set for this adapter, or (b) there might have been a problem negotiating
// valid credentials with the DNS server during the processing of the update
// request.%n%n
// For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY 0x80002BB0L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
// The system failed to update and remove the DNS registration for the
// network adapter with settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The system could not update to remove this DNS registration because of
// a system problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER 0x80002BB1L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because the update request
// timed out while awaiting a response from the DNS server. This is probably
// because the DNS server authoritative for the zone that requires update
// is not running.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_TIMEOUT 0x80002BB2L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because the DNS server failed the
// update request. A possible cause is that a zone transfer is in progress,
// causing a lock for the zone at the DNS server authorized to perform the
// updates for these RRs.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SERVERFAIL 0x80002BB3L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because either the DNS server
// does not support the DNS dynamic update protocol or the authoritative zone
// that contains these RRs does not accept dynamic updates.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_NOTSUPP 0x80002BB4L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because the DNS server refused the
// update request. The cause of this might be (a) this computer is not allowed
// to update the specified DNS domain name specified by these settings, or
// (b) because the DNS server authorized to perform updates for the zone that
// contains these RRs does not support the DNS dynamic update protocol.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_REFUSED 0x80002BB5L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because of a security related
// problem. The cause of this could be that (a) your computer does not have
// permissions to remove and update the specific DNS domain name or IP addresses
// configured for this adapter, or (b) there might have been a problem negotiating
// valid credentials with the DNS server during the processing of the update
// request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_SECURITY 0x80002BB6L

//
// MessageId: EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER
//
// MessageText:
//
// The system failed to update and remove pointer (PTR) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address : %6%n%n
// The system could not remove these PTR RRs because because of a system
// problem. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_PTR_DEREGISTRATION_FAILED_OTHER 0x80002BB7L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The system could not remove these host (A or AAAA) RRs because the update request 
// timed out while awaiting a response from the DNS server. This is probably because
// the DNS server authoritative for the zone where these RRs need to be updated
// is either not currently running or reachable on the network.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_TIMEOUT_PRIMARY_DN 0x80002BB8L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The system could not remove these host (A or AAAA) RRs because the DNS server
// failed the update request. A possible cause is that a zone transfer is in progress,
// causing a lock for the zone at the DNS server authorized to perform the
// updates for these RRs.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SERVERFAIL_PRIMARY_DN 0x80002BB9L

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason for this failure is because the DNS server sent the update
// either (a) does not support the DNS dynamic update protocol, or (b) the
// authoritative zone for the DNS domain name specified in these host (A or AAAA)
// RRs does not currently accept DNS dynamic updates.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_NOTSUPP_PRIMARY_DN 0x80002BBAL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The request to remove these records failed because the DNS server refused
// the update request. The cause of this might be that either (a) this
// computer is not allowed to update the DNS domain name specified by these
// settings, or (b) because the DNS server authorized to perform updates for
// the zone that contains these RRs does not support the DNS dynamic update
// protocol.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_REFUSED_PRIMARY_DN 0x80002BBBL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason for this failure was because of a security related problem.
// The cause of this could be that (a) your computer does not have permissions
// to remove and update the specific DNS domain name or IP addresses
// configured for this adapter, or (b) there might have been a problem
// negotiating valid credentials with the DNS server during the processing of
// the update request. For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_SECURITY_PRIMARY_DN 0x80002BBCL

//
// MessageId: EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN
//
// MessageText:
//
// The system failed to update and remove host (A or AAAA) resource records (RRs)
// for network adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6%n%n
// The reason the update request failed was because of a system problem.
// For specific error code, see the record data displayed below.
//
#define EVENT_DNSAPI_DEREGISTRATION_FAILED_OTHER_PRIMARY_DN 0x80002BBDL


//
// Information
//

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER
//
// MessageText:
//
// The system registered network adapter with settings :%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER  0x40002BC0L

//
// MessageId: EVENT_DNSAPI_REGISTERED_PTR
//
// MessageText:
//
// The system registered pointer (PTR) resource records (RRs) for network
// adapter%nwith settings:%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Adapter-specific Domain Suffix : %3%n
//   Primary Domain Suffix : %4%n
//   DNS server list :%n
//     %5%n
//   Sent update to server : %6%n
//   IP Address : %7
//
#define EVENT_DNSAPI_REGISTERED_PTR      0x40002BC1L

//
// MessageId: EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN
//
// MessageText:
//
// The system registered host (A or AAAA) resource records (RRs) for network
// adapter%nwith settings :%n%n
//   Adapter Name : %1%n
//   Host Name : %2%n
//   Primary Domain Suffix : %3%n
//   DNS server list :%n
//     %4%n
//   Sent update to server : %5%n
//   IP Address(es) :%n
//     %6
//
#define EVENT_DNSAPI_REGISTERED_ADAPTER_PRIMARY_DN 0x40002BC2L


/////////////////////////////////////////////////////////////////////////
//
// WMI Service Events (12000-12499)
//
/////////////////////////////////////////////////////////////////////////

//
// Errors
//

//
// MessageId: EVENT_WMI_CANT_OPEN_DEVICE
//
// MessageText:
//
// The WMI service was unable to open the WMI service device. The status code is in the additional data.
//
#define EVENT_WMI_CANT_OPEN_DEVICE       0xC0002EE0L


//
// Warnings
//

//
// MessageId: EVENT_WMI_INVALID_MOF
//
// MessageText:
//
// The binary MOF in the resource named %1 in the image file %2 is not valid.
//
#define EVENT_WMI_INVALID_MOF            0x80002F44L

//
// MessageId: EVENT_WMI_MOF_LOAD_FAILURE
//
// MessageText:
//
// The binary MOF in the resource named %1 in the image file %2 could not be loaded.
//
#define EVENT_WMI_MOF_LOAD_FAILURE       0x80002F45L

//
// MessageId: EVENT_WMI_INVALID_REGINFO
//
// MessageText:
//
// The registration information for the image file %1 is not valid.
//
#define EVENT_WMI_INVALID_REGINFO        0x80002F46L

//
// MessageId: EVENT_WMI_INVALID_REGPATH
//
// MessageText:
//
// The registry path (%1) passed by a kernel mode driver is invalid. The driver device object is in the additional data.
//
#define EVENT_WMI_INVALID_REGPATH        0x80002F47L

//
// MessageId: EVENT_WMI_CANT_RESOLVE_INSTANCE
//
// MessageText:
//
// An event was fired specifying a static instance name that could not be resolved.
//
#define EVENT_WMI_CANT_RESOLVE_INSTANCE  0x80002F48L

//
// MessageId: EVENT_WMI_CANT_GET_EVENT_DATA
//
// MessageText:
//
// An error occured while attempting to query for the event data referenced by a fired event.
//
#define EVENT_WMI_CANT_GET_EVENT_DATA    0x80002F49L


/////////////////////////////////////////////////////////////////////////
//
// Trk Services Events (12500-12999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_TRK_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occured in Distributed Link Tracking.  The error code was %1.
//
#define EVENT_TRK_INTERNAL_ERROR         0xC00030D4L

//
// MessageId: EVENT_TRK_SERVICE_START_SUCCESS
//
// MessageText:
//
// Service started successfully
//
#define EVENT_TRK_SERVICE_START_SUCCESS  0x400030D5L

//
// MessageId: EVENT_TRK_SERVICE_START_FAILURE
//
// MessageText:
//
// Service failed to start.  Error = %1
//
#define EVENT_TRK_SERVICE_START_FAILURE  0xC00030D6L

//
// MessageId: EVENT_TRK_SERVICE_CORRUPT_LOG
//
// MessageText:
//
// The Distributed Link Tracking log was corrupt on volume %1: and has been re-created.  This log is used to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_CORRUPT_LOG    0xC00030D7L

//
// MessageId: EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED
//
// MessageText:
//
// The Distributed Link Tracking volume ID quota on this machine has been exceeded.  As a result, it is not possible to create new volume IDs.  Distributed Link Tracking normally uses these volume IDs to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOL_QUOTA_EXCEEDED 0x800030D8L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CREATE
//
// MessageText:
//
// A new volume ID has been assigned for %1:%n%2%n%n
// This ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  If there previously were links to files on this volume that are broken, they might not be automatically repairable.
//
#define EVENT_TRK_SERVICE_VOLUME_CREATE  0x400030D9L

//
// MessageId: EVENT_TRK_SERVICE_VOLUME_CLAIM
//
// MessageText:
//
// Ownership of the volume ID for %1: has been successfully claimed.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_VOLUME_CLAIM   0x400030DAL

//
// MessageId: EVENT_TRK_SERVICE_DUPLICATE_VOLIDS
//
// MessageText:
//
// The volume ID for %1: has been reset, since it was a duplicate of that on %2:.  This volume ID is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.
//
#define EVENT_TRK_SERVICE_DUPLICATE_VOLIDS 0x400030DBL

//
// MessageId: EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED
//
// MessageText:
//
// The move table quota for Distributed Link Tracking in this domain has been exceeded.  This table is used by Distributed Link Tracking to automatically repair file links, such as Shell Shortcuts and OLE links, when for some reason those links become broken.  While this quota is exceeded, it may not be possible to automatically repair some such broken links.
//
#define EVENT_TRK_SERVICE_MOVE_QUOTA_EXCEEDED 0x800030DCL


/////////////////////////////////////////////////////////////////////////
//
// ATM Protocol Events (13000-13499)
//
/////////////////////////////////////////////////////////////////////////

// ATM is removed from the OS so all strings that related to ATM are removed.

/////////////////////////////////////////////////////////////////////////
//
// File Replication Service (NtFrs) Events (13500-13999)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_FRS_ERROR
//
// MessageText:
//
// File Replication Service
//
#define EVENT_FRS_ERROR                  0xC00034BCL

//
// MessageId: EVENT_FRS_STARTING
//
// MessageText:
//
// The File Replication Service is starting.
//
#define EVENT_FRS_STARTING               0x400034BDL

//
// MessageId: EVENT_FRS_STOPPING
//
// MessageText:
//
// The File Replication Service is stopping.
//
#define EVENT_FRS_STOPPING               0x400034BEL

//
// MessageId: EVENT_FRS_STOPPED
//
// MessageText:
//
// The File Replication Service has stopped.
//
#define EVENT_FRS_STOPPED                0x400034BFL

//
// MessageId: EVENT_FRS_STOPPED_FORCE
//
// MessageText:
//
// The File Replication Service stopped without cleaning up.
//
#define EVENT_FRS_STOPPED_FORCE          0xC00034C0L

//
// MessageId: EVENT_FRS_STOPPED_ASSERT
//
// MessageText:
//
// The File Replication Service has stopped after taking an assertion failure.
//
#define EVENT_FRS_STOPPED_ASSERT         0xC00034C1L

//
// MessageId: EVENT_FRS_ASSERT
//
// MessageText:
//
// The File Replication Service failed a consistency check
// %n  (%3)
// %nin "%1" at line %2.
// %n
// %nThe File Replication Service will restart automatically at a later time.
// If this problem persists a subsequent entry in this event log describes the
// recovery procedure.
// %n
// For more information about the automatic restart right click on
// My Computer and then click on Manage, System Tools, Services,
// File Replication Service, and Recovery.
//
#define EVENT_FRS_ASSERT                 0xC00034C2L

//
// MessageId: EVENT_FRS_VOLUME_NOT_SUPPORTED
//
// MessageText:
//
// The File Replication Service cannot start replica set %1 on computer %2
// for directory %3 because the type of volume %4 is not NTFS 5.0 or later.
// %n
// %nThe volume's type can be found by typing "chkdsk %4".
// %n
// %nThe volume can be upgraded to NTFS 5.0 or later by typing "chkntfs /E %4".
//
#define EVENT_FRS_VOLUME_NOT_SUPPORTED   0xC00034C3L

//
// MessageId: EVENT_FRS_LONG_JOIN
//
// MessageText:
//
// The File Replication Service is having trouble enabling replication
// from %1 to %2 for %3 using the DNS name %4. FRS will keep retrying.
// %n Following are some of the reasons you would see this warning.
// %n
// %n [1] FRS can not correctly resolve the DNS name %4 from this computer.
// %n [2] FRS is not running on %4.
// %n [3] The topology information in the Active Directory for this replica has not
// yet replicated to all the Domain Controllers.
// %n
// %n This event log message will appear once per connection, After the problem
// is fixed you will see another event log message indicating that the connection
// has been established.
//
#define EVENT_FRS_LONG_JOIN              0x800034C4L

//
// MessageId: EVENT_FRS_LONG_JOIN_DONE
//
// MessageText:
//
// The File Replication Service has enabled replication from %1 to %2 for %3
// after repeated retries.
//
#define EVENT_FRS_LONG_JOIN_DONE         0x800034C5L

//
// MessageId: EVENT_FRS_CANNOT_COMMUNICATE
//
// MessageText:
//
// The File Replication Service on the computer %1 cannot communicate with
// the File Replication Service on the computer %2.
// %n
// %nVerify that the computer %2 is up and running.
// %n
// %nVerify that the File Replication Service is running on %2 by
// typing "net start ntfrs" on %2.
// %n
// %nVerify that the network is functioning between %1 and %2 by
// typing "ping %1" on %2 and "ping %2" on %1.
// If the pings succeed then retry the failed operation.
// If the pings fail then there may be problems with the DNS server.
// %n
// %nThe DNS server is responsible for mapping computer names to IP addresses.
// The commands "ipconfig" and "nslookup" help diagnose problems with the
// DNS server.
// %n
// %nTyping "ipconfig /all" will list the computer's IP address and the IP
// address of the computer's DNS servers. Type "ping <DNS server's IP address>"
// to verify that a DNS server is available. The DNS mapping for %2 or %1
// can be verified by typing "nslookup" and then typing "%2" and then "%1"
// on %1 and %2. Be sure to check out the DNS server on both %1 and %2;
// a DNS problem on either computer will prevent proper communication.
// %n
// %nSome network problems between %1 and %2 can be cleared up by flushing
// the DNS Resolver Cache. Type "ipconfig /flushdns".
// %n
// %nSome network problems between %1 and %2 can be cleared up by renewing
// the IP address. Type "ipconfig /release" followed by "ipconfig /renew".
// %n
// %nSome network problems between %1 and %2 can be cleared up by resetting
// the computer's DNS entry. Type "net stop NetLogon" followed by
// "net start NetLogon".
// %n
// %nSome problems between %1 and %2 can be cleared up by restarting
// the File Replication Service. Type "net stop ntfrs" followed by
// "net start ntfrs".
// %n
// %nSome problems between %1 and %2 can be cleared up by restarting
// the computers %1 and %2 AFTER CLOSING RUNNING APPLIATIONS,
// especially dcpromo. Click on Start, Shutdown, select Restart, and
// click on OK.
// %n
// %nOther network and computer problems are beyond the scope of
// this event log message.
//
#define EVENT_FRS_CANNOT_COMMUNICATE     0xC00034C6L

//
// MessageId: EVENT_FRS_DATABASE_SPACE
//
// MessageText:
//
// The File Replication Service is stopping on computer %1 because there is no free
// space on the volume containing %2.
// %n
// %nThe available space on the volume can be found by typing
// "dir %2".
// %n
// %nOnce free space is made available on the volume containing %2,
// the File Replication Service can be restarted immediately by typing
// "net start ntfrs". Otherwise, the File Replication Service will
// restart automatically at a later time.
// %n
// %nFor more information about the automatic restart right click on
// My Computer and then click on Manage, System Tools, Services, File
// Replication Service, and Recovery.
// %n
// %nFor more information about managing space on a volume type "copy /?",
// "rename /?", "del /?", "rmdir /?", and "dir /?".
//
#define EVENT_FRS_DATABASE_SPACE         0xC00034C7L

//
// MessageId: EVENT_FRS_DISK_WRITE_CACHE_ENABLED
//
// MessageText:
//
// The File Replication Service has detected an enabled disk write cache
// on the drive containing the directory %2 on the computer %1.
// The File Replication Service might not recover when power to the
// drive is interrupted and critical updates are lost.
//
#define EVENT_FRS_DISK_WRITE_CACHE_ENABLED 0x800034C8L

//
// MessageId: EVENT_FRS_JET_1414
//
// MessageText:
//
// The File Replication Service on computer %1 is stopping because the
// database %2 is corrupted.
// %n
// %nThe database can be recovered by typing "esentutl /d %2 /l%3 /s%4".
// %n
// %nOnce the database has been successfully recovered the
// File Replication Service can be restarted by typing "net start ntfrs".
//
#define EVENT_FRS_JET_1414               0xC00034C9L

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY
//
// MessageText:
//
// The File Replication Service may be preventing the computer %1 from becoming a
// domain controller while the system volume is being initialized with data
// from another domain controller and then shared as SYSVOL.
// %n
// %nType "net share" to check for the SYSVOL share. The File Replication
// Service has stopped preventing the computer from becoming a domain
// controller once the SYSVOL share appears.
// %n
// %nThe initialization of the system volume can take some time.
// The time is dependent on the amount of data in the system volume,
// the availability of other domain controllers, and the replication
// interval between domain controllers.
//
#define EVENT_FRS_SYSVOL_NOT_READY       0x800034CAL

//
// MessageId: EVENT_FRS_SYSVOL_NOT_READY_PRIMARY
//
// MessageText:
//
// The File Replication Service may be preventing the computer %1 from becoming a
// domain controller while the system volume is being initialized and then
// shared as SYSVOL.
// %n
// %nType "net share" to check for the SYSVOL share. The File Replication
// Service has stopped preventing the computer from becoming a domain
// controller once the SYSVOL share appears.
// %n
// %nThe initialization of the system volume can take some time.
// The time is dependent on the amount of data in the system volume.
// %n
// %nThe initialization of the system volume can be bypassed by first typing
// regedt32 and setting the value of SysvolReady to 1 and then restarting
// the Netlogon service.
// %n
// %nWARNING - BYPASSING THE SYSTEM VOLUME INITIALIZATION IS NOT RECOMMENDED.
// Applications may fail in unexpected ways.
// %n
// %nThe value SysvolReady is located by clicking on HKEY_LOCAL_MACHINE
// and then clicking on System, CurrentControlSet, Services, Netlogon,
// and Parameters.
// %n
// %nThe Netlogon service can be restarted by typing "net stop netlogon"
// followed by "net start netlogon".
//
#define EVENT_FRS_SYSVOL_NOT_READY_PRIMARY 0x800034CBL

//
// MessageId: EVENT_FRS_SYSVOL_READY
//
// MessageText:
//
// The File Replication Service is no longer preventing the computer %1 from
// becoming a domain controller. The system volume has been successfully
// initialized and the Netlogon service has been notified that the system
// volume is now ready to be shared as SYSVOL.
// %n
// %nType "net share" to check for the SYSVOL share.
//
#define EVENT_FRS_SYSVOL_READY           0x400034CCL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_DISABLED
//
// MessageText:
//
// The File Replication Service will not check access to the API "%1".
// %n
// %nAccess checks can be enabled for "%1" by running regedt32.
// %n
// %nClick on Start, Run, and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
// Change the string to Enabled.
// %n
// %nPermissions can be changed by highlighting "%1" and then clicking on the
// toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_DISABLED 0x800034CDL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_USER
//
// MessageText:
//
// The File Replication Service did not grant the user "%3" access to the
// API "%1".
// %n
// %nPermissions for "%1" can be changed by running regedt32.
// %n
// %nClick on Start, Run, and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, Access Checks, and highlight "%1".
// Click on the toolbar option Security and then Permissions...
// %n
// %nAccess checks can be disabled for "%1". Double click on "%2" and
// change the string to Disabled.
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_USER 0x800034CEL

//
// MessageId: EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN
//
// MessageText:
//
// The File Replication Service could not grant an unknown user access to the
// API "%1".
// %n
// %nAccess checks can be disabled for "%1" by running regedt32.
// %n
// %nClick on Start, Run, and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, Access Checks, "%1", and "%2".
// Change the string to Disabled.
// %n
// %nPermissions can be changed by highlighting "%1" and then clicking on the
// toolbar option Security and then Permissions...
//
#define EVENT_FRS_ACCESS_CHECKS_FAILED_UNKNOWN 0xC00034CFL

//
// MessageId: EVENT_FRS_MOVED_PREEXISTING
//
// MessageText:
//
// The File Replication Service moved the preexisting files in %1 to %2.
// %n
// %nThe File Replication Service may delete the files in %2 at any time.
// Files can be saved from deletion by copying them out of %2. Copying
// the files into %1 may lead to name conflicts if the files already exist
// on some other replicating partner.
// %n
// %nIn some cases, the File Replication Service may copy a file
// from %2 into %1 instead of replicating the file from some other
// replicating partner.
// %n
// %nSpace can be recovered at any time by deleting the files in %2.
//
#define EVENT_FRS_MOVED_PREEXISTING      0x800034D0L

//
// MessageId: EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS
//
// MessageText:
//
// The File Replication Service cannot enable replication on the comptuer %1
// until a backup/restore application completes.
// %n
// %nA backup/restore application has set a registry key that
// prevents the File Replication Service from starting until the registry
// key is deleted or the system is rebooted.
// %n
// %nThe backup/restore application may still be running. Check with your
// local administrator before proceeding further.
// %n
// %nThe computer can be rebooted by clicking on Start, Shutdown, and
// selecting Restart.
// %n
// %nWARNING - DELETING THE REGISTRY KEY IS NOT RECOMMENDED!
// Applications may fail in unexpected ways.
// %n
// %nThe registry key can be deleted by running regedt32.
// %n
// %nClick on Start, Run, and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, Backup/Restore,
// "Stop NtFrs from Starting". On the toolbar, click on Edit and select
// Delete. Be careful! Deleting a key other than "Stop NtFrs From Starting"
// can have unexpected sideeffects.
//
#define EVENT_FRS_CANNOT_START_BACKUP_RESTORE_IN_PROGRESS 0xC00034D1L

//
// MessageId: EVENT_FRS_STAGING_AREA_FULL
//
// MessageText:
//
// The File Replication Service paused because the staging area is full.
// Replication will resume if staging space becomes available or if the
// staging space limit is increased.
// %n
// %nThe current value of the staging space limit is %1 KB.
// %n
// %nTo change the staging space limit, run regedt32.
// %n
// %nClick on Start, Run and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, and the value
// "Staging Space Limit in KB".
//
#define EVENT_FRS_STAGING_AREA_FULL      0x800034D2L

//
// MessageId: EVENT_FRS_HUGE_FILE
//
// MessageText:
//
// The File Replication Service paused because the size of a file exceeds the
// staging space limit. Replication will resume only if the staging space limit
// is increased.
// %n
// %nThe staging space limit is %1 KB and the file size is %2 KB.
// %n
// %nTo change the staging space limit, run regedt32.
// %n
// %nClick on Start, Run and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE. Double click on SYSTEM,
// CurrentControlSet, Services, NtFrs, Parameters, and the value
// "Staging Space Limit in KB".
//
#define EVENT_FRS_HUGE_FILE              0x800034D3L

//
// MessageId: EVENT_FRS_CANNOT_CREATE_UUID
//
// MessageText:
//
// The File Replication Service is stopping on the computer %1 because
// a universally unique ID (UUID) cannot be created.
// %n
// %nThe SDK function UuidCreate() returned the error "%2".
// %n
// %nThe problem may be the lack of an Ethernet address,
// token ring address, or network address. The lack of a network
// address implies an unsupported netcard.
// %n
// %nThe File Replication Service will restart automatically at a later time.
// For more information about the automatic restart right click on
// My Computer and then click on Manage, System Tools, Services,
// File Replication Service, and Recovery.
//
#define EVENT_FRS_CANNOT_CREATE_UUID     0xC00034D4L

//
// MessageId: EVENT_FRS_NO_DNS_ATTRIBUTE
//
// MessageText:
//
// The File Replication Service cannot find the DNS name for the computer %1
// because the "%2" attribute could not be read from the distinguished
// name "%3".
// %n
// %nThe File Replication Service will try using the name "%1" until the
// computer's DNS name appears.
//
#define EVENT_FRS_NO_DNS_ATTRIBUTE       0x800034D5L

//
// MessageId: EVENT_FRS_NO_SID
//
// MessageText:
//
// The File Replication Service cannot replicate %1 with the computer
// %2 because the computer's SID cannot be determined from the distinguished
// name "%3".
// %n
// %nThe File Replication Service will retry later.
//
#define EVENT_FRS_NO_SID                 0xC00034D6L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET
//
// MessageText:
//
// The RPC binding failed in the Open function of the FileReplicaSet Object. The
// counter data for this object will not be available. The FileReplicaSet object
// contains the performance counters of the Replica sets whose files are being
// replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_SET 0xC00034D7L

//
// MessageId: NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
// The RPC binding failed in the Open function of the FileReplicaConn Object. The
// counter data for this object will not be available. The FileReplicaConn object
// contains the performance counters of the connections over which files are being
// replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_BINDING_ERROR_CONN 0xC00034D8L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_SET
//
// MessageText:
//
// The RPC call failed in the Open function of the FileReplicaSet Object. The
// counter data for this object will not be available. The FileReplicaSet object
// contains the performance counters of the Replica sets whose files are being
// replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_SET 0xC00034D9L

//
// MessageId: NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN
//
// MessageText:
//
// The RPC call failed in the Open function of the FileReplicaConn Object. The
// counter data for this object will not be available. The FileReplicaConn object
// contains the performance counters of the connections over which files are being
// replicated by the File Replication Service.
//
#define NTFRSPRF_OPEN_RPC_CALL_ERROR_CONN 0xC00034DAL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET
//
// MessageText:
//
// The RPC binding failed in the Collect function of the FileReplicaSet Object. The
// counter data for this object will not be available till the binding succeeds.
// The FileReplicaSet object contains the performance counters of the Replica sets
// whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_SET 0xC00034DBL

//
// MessageId: NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN
//
// MessageText:
//
// The RPC binding failed in the Collect function of the FileReplicaConn Object.
// The counter data for this object will not be available till the binding
// succeeds. The FileReplicaConn object contains the performance counters of the
// connections over which files are being replicated by the File Replication
// Service.
//
#define NTFRSPRF_COLLECT_RPC_BINDING_ERROR_CONN 0xC00034DCL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET
//
// MessageText:
//
// The RPC call failed in the Collect function of the FileReplicaSet Object. The
// counter data for this object will not be available till the call succeeds. The
// FileReplicaSet object contains the performance counters of the Replica sets
// whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_SET 0xC00034DDL

//
// MessageId: NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN
//
// MessageText:
//
// The RPC call failed in the Collect function of the FileReplicaConn Object. The
// counter data for this object will not be available till the call succeeds. The
// FileReplicaConn object contains the performance counters of the connections over
// which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_COLLECT_RPC_CALL_ERROR_CONN 0xC00034DEL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_SET
//
// MessageText:
//
// The call to VirtualAlloc failed in the Open function of the FileReplicaSet
// Object. The counter data for this object will not be available. The
// FileReplicaSet object contains the performance counters of the Replica sets
// whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_SET  0xC00034DFL

//
// MessageId: NTFRSPRF_VIRTUALALLOC_ERROR_CONN
//
// MessageText:
//
// The call to VirtualAlloc failed in the Open function of the FileReplicaConn
// Object. The counter data for this object will not be available. The
// FileReplicaConn object contains the performance counters of the connections over
// which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_VIRTUALALLOC_ERROR_CONN 0xC00034E0L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_SET
//
// MessageText:
//
// The call to the Registry failed in the Open function of the FileReplicaSet
// Object. The counter data for this object will not be available. The
// FileReplicaSet object contains the performance counters of the Replica sets
// whose files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_SET      0xC00034E1L

//
// MessageId: NTFRSPRF_REGISTRY_ERROR_CONN
//
// MessageText:
//
// The call to the Registry failed in the Open function of the FileReplicaConn
// Object. The counter data for this object will not be available. The
// FileReplicaConn object contains the performance counters of the connections over
// which files are being replicated by the File Replication Service.
//
#define NTFRSPRF_REGISTRY_ERROR_CONN     0xC00034E2L

//
// MessageId: EVENT_FRS_ROOT_NOT_VALID
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because the
// pathname of the replicated directory is not the fully qualified
// pathname of an existing, accessible local directory.
//
#define EVENT_FRS_ROOT_NOT_VALID         0xC00034E3L

//
// MessageId: EVENT_FRS_STAGE_NOT_VALID
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because the pathname
// of the customer designated staging directory:
// %n    %2
// %n is not the fully qualified pathname of an existing, accessible local directory.
//
#define EVENT_FRS_STAGE_NOT_VALID        0xC00034E4L

//
// MessageId: EVENT_FRS_OVERLAPS_LOGGING
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because it overlaps
// the File Replication Service's logging pathname %2.
//
#define EVENT_FRS_OVERLAPS_LOGGING       0xC00034E5L

//
// MessageId: EVENT_FRS_OVERLAPS_WORKING
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because it overlaps
// the File Replication Service's working directory %2.
//
#define EVENT_FRS_OVERLAPS_WORKING       0xC00034E6L

//
// MessageId: EVENT_FRS_OVERLAPS_STAGE
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because it overlaps
// the staging directory %2.
//
#define EVENT_FRS_OVERLAPS_STAGE         0xC00034E7L

//
// MessageId: EVENT_FRS_OVERLAPS_ROOT
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because it overlaps
// the replicating directory %2.
//
#define EVENT_FRS_OVERLAPS_ROOT          0xC00034E8L

//
// MessageId: EVENT_FRS_OVERLAPS_OTHER_STAGE
//
// MessageText:
//
// The File Replication Service cannot replicate %1 because it overlaps
// the staging directory %2 of the replicating directory %3.
//
#define EVENT_FRS_OVERLAPS_OTHER_STAGE   0xC00034E9L

//
// MessageId: EVENT_FRS_PREPARE_ROOT_FAILED
//
// MessageText:
//
// The File Replication Service could not prepare the root directory
// %1 for replication.  This is likely due to a problem creating the
// root directory or a problem removing preexisting files in the root
// directory.
// %n
// %nCheck that the path leading up to the root directory exists and is
// accessible.
//
#define EVENT_FRS_PREPARE_ROOT_FAILED    0xC00034EAL

//
// MessageId: EVENT_FRS_BAD_REG_DATA
//
// MessageText:
//
// The File Replication Service detected an invalid parameter value in the
// registry.  %1.
// %n
// %nThe expected registry key name is "%2".
// %nThe expected value name is "%3".
// %nThe expected registry data type is %4.
// %nThe allowed range for this parameter is %5
// %nThe data units for this parameter value are %6.
// %nThe File Replication Service is using a default value of "%7".
// %n
// %nTo change this parameter, run regedt32.
// %n
// %nClick on Start, Run and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE.
// %nClick down the key path: "%8"
// %nDouble click on the value name -
// %n    "%9"
// %nand update the value.
// %nIf the value name is not present you may add it with the Add Value function
// under the Edit Menu item. Type the value name exactly as shown above using the
// above registry data type.  Make sure you observe the data units and allowed range
// when entering the value.
//
#define EVENT_FRS_BAD_REG_DATA           0x800034EBL

//
// MessageId: EVENT_FRS_JOIN_FAIL_TIME_SKEW
//
// MessageText:
//
// The File Replication Service is unable to replicate with its partner computer
// because the difference in clock times is outside the range of plus or minus
// %1 minutes.
// %n
// %nThe connection to the partner computer is:
// %n  "%2"
// %nThe detected time difference is:  %3 minutes.
// %n
// %nNote: If this time difference is close to a multiple of 60 minutes then it
// is likely that either this computer or its partner computer was set to the
// incorrect time zone when the computer time was initially set.  Check that
// the time zone and the system time are correctly set on both computers.
// %n
// %nIf necessary, the default value used to test for computer time consistency
// may be changed in the registry on this computer.  (Note: This is not recommended.)
// %n
// %nTo change this parameter, run regedt32.
// %n
// %nClick on Start, Run and type regedt32.
// %n
// %nClick on the window entitled HKEY_LOCAL_MACHINE.
// %nClick down the key path:
// %n   "System\CurrentControlSet\Services\NtFrs\Parameters"
// %nDouble click on the value name
// %n   "Partner Clock Skew In Minutes"
// %nand update the value.
// %n
// %nIf the value name is not present you may add it with the Add Value function
// under the Edit Menu item. Type the value name exactly as shown above using the
// the registry data type REG_DWORD.
//
#define EVENT_FRS_JOIN_FAIL_TIME_SKEW    0xC00034ECL

//
// MessageId: EVENT_FRS_RMTCO_TIME_SKEW
//
// MessageText:
//
// The File Replication Service is unable to replicate from a partner computer
// because the event time associated with the file to be replicated is too far
// into the future.  It is %1 minutes greater than the current time.  This can
// happen if the system time on the partner computer was set incorrectly when
// the file was created or updated.  To preserve the integrity of the replica
// set this file update will not be performed or propagated further.
// %n
// %nThe file name is: "%2"
// %nThe connection to the partner computer is:
// %n  "%3"
// %n
// %nNote: If this time difference is close to a multiple of 60 minutes then it
// is likely that this file may have been created or updated on the partner
// computer while the computer was set to the incorrect time zone when its
// computer time was initially set.  Check that the timezone and time are
// correctly set on the partner computer.
//
#define EVENT_FRS_RMTCO_TIME_SKEW        0xC00034EDL

//
// MessageId: EVENT_FRS_CANT_OPEN_STAGE
//
// MessageText:
//
// The File Replication Service is unable to open the customer designated
// staging directory for replica set %1.  The path used for the staging
// directory is,
// %n    "%2"
// %nThe customer designated root path for this replica set is:
// %n    "%3"
// %n
// The service is unable to start replication on this replica set.  Among the
// possible errors to check are:
// %n  --  an invalid staging path,
// %n  --  a missing directory,
// %n  --  a missing disk volume,
// %n  --  a file system on the volume that does not support ACLs,
// %n  --  a sharing conflict on the staging directory with some other application.
// %n
// %nCorrect the problem and the service will attempt to restart replication
// automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_STAGE        0xC00034EEL

//
// MessageId: EVENT_FRS_CANT_OPEN_PREINSTALL
//
// MessageText:
//
// The File Replication Service is unable to open (or create) the pre-install
// directory under the customer designated replica tree directory for
// replica set %1.  The path used for the pre-install
// directory is,
// %n    "%2"
// %nThe customer designated root path for this replica set is:
// %n    "%3"
// %n
// The service is unable to start replication on this replica set.  Among the
// possible errors to check are:
// %n  --  an invalid root path,
// %n  --  a missing directory,
// %n  --  a missing disk volume,
// %n  --  a file system on the volume that does not support NTFS 5.0
// %n  --  a sharing conflict on the pre-install directory with some other application.
// %n
// %nCorrect the problem and the service will attempt to restart replication
// automatically at a later time.
//
#define EVENT_FRS_CANT_OPEN_PREINSTALL   0xC00034EFL

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_FAIL
//
// MessageText:
//
// The File Replication Service is unable to add this computer to the following
// replica set:
// %n    "%1"
// %n
// %nThis could be caused by a number of problems such as:
// %n  --  an invalid root path,
// %n  --  a missing directory,
// %n  --  a missing disk volume,
// %n  --  a file system on the volume that does not support NTFS 5.0
// %n
// %nThe information below may help to resolve the problem:
// %nComputer DNS name is "%2"
// %nReplica set member name is "%3"
// %nReplica set root path is "%4"
// %nReplica staging directory path is "%5"
// %nReplica working directory path is "%6"
// %nWindows error status code is %7
// %nFRS error status code is %8
// %n
// %nOther event log messages may also help determine the problem.  Correct the
// problem and the service will attempt to restart replication automatically at
// a later time.
//
#define EVENT_FRS_REPLICA_SET_CREATE_FAIL 0xC00034F0L

//
// MessageId: EVENT_FRS_REPLICA_SET_CREATE_OK
//
// MessageText:
//
// The File Replication Service successfully added this computer to the following
// replica set:
// %n    "%1"
// %n
// %nInformation related to this event is shown below:
// %nComputer DNS name is "%2"
// %nReplica set member name is "%3"
// %nReplica set root path is "%4"
// %nReplica staging directory path is "%5"
// %nReplica working directory path is "%6"
//
#define EVENT_FRS_REPLICA_SET_CREATE_OK  0x400034F1L

//
// MessageId: EVENT_FRS_REPLICA_SET_CXTIONS
//
// MessageText:
//
// The File Replication Service successfully added the connections shown below
// to the replica set:
// %n    "%1"
// %n
// %n    %2
// %n    %3
// %n    %4
// %n    %5
// %n    %6
// %n    %7
// %n    %8
// %n    %9
// %n
// %nMore information may appear in subsequent event log messages.
//
#define EVENT_FRS_REPLICA_SET_CXTIONS    0x400034F2L

//
// MessageId: EVENT_FRS_IN_ERROR_STATE
//
// MessageText:
//
// The File Replication Service is in an error state. Files will not replicate
// to or from one or all of the replica sets on his computer until the
// following recovery steps are performed:
// %n
// %n Recovery Steps:
// %n
// %n [1] The error state may clear itself if you stop and restart the FRS service.
// This can be done by performing the following in a command window:
// %n
// %n    net stop ntfrs
// %n    net start ntfrs
// %n
// %nIf this fails to clear up the problem then proceed as follows.
// %n
// %n [2] For Active Directory Domain Controllers that DO NOT host any DFS
// alternates or other replica sets with replication enabled:
// %n
// %nIf there is at least one other Domain Controller in this domain then
// restore the "system state" of this DC from backup (using ntbackup or other
// backup-restore utility) and make it non-authoritative.
// %n
// %nIf there are NO other Domain Controllers in this domain then restore
// the "system state" of this DC from backup (using ntbackup or other
// backup-restore utility) and choose the Advanced option which marks
// the sysvols as primary.
// %n
// %nIf there are other Domain Controllers in this domain but ALL of
// them have this event log message then restore one of them as primary
// (data files from primary will replicate everywhere) and the others as
// non-authoritative.
// %n
// %n
// %n [3] For Active Directory Domain Controllers that host DFS alternates
// or other replica sets with replication enabled:
// %n
// %n (3-a) If the Dfs alternates on this DC do not have any other replication
// partners then copy the data under that Dfs share to a safe location.
// %n (3-b) If this server is the only Active Directory Domain Controller for this
// domain then, before going to (3-c),  make sure this server does not have any
// inbound or outbound connections to other servers that were formerly Domain
// Controllers for this domain but are now off the net (and will never be
// coming back online) or have been fresh installed without being demoted.
// To delete connections use the Sites and Services snapin and look for
// %nSites->NAME_OF_SITE->Servers->NAME_OF_SERVER->NTDS Settings->CONNECTIONS.
// %n (3-c) Restore the "system state" of this DC from backup (using ntbackup
// or other backup-restore utility) and make it non-authoritative.
// %n (3-d) Copy the data from step (3-a) above to the original location
// after the sysvol share is published.
// %n
// %n
// %n [4] For other Windows 2000 servers:
// %n
// %n (4-a)  If any of the DFS alternates or other replica sets hosted by
// this server do not have any other replication partners then copy the
// data under its share or replica tree root to a safe location.
// %n (4-b)  net stop ntfrs
// %n (4-c)  rd /s /q  %1
// %n (4-d)  net start ntfrs
// %n (4-e)  Copy the data from step (4-a) above to the original location after
// the service has initialized (5 minutes is a safe waiting time).
// %n
// %nNote: If this error message is in the eventlog of all the members of a
// particular replica set then perform steps (4-a) and (4-e) above on only
// one of the members.
//
#define EVENT_FRS_IN_ERROR_STATE         0xC00034F3L

//
// MessageId: EVENT_FRS_REPLICA_NO_ROOT_CHANGE
//
// MessageText:
//
// The File Replication Service has detected what appears to be an attempt
// to change the root path for the following replica set:
// %n    "%1"
// %n
// %nThis is not allowed.  To perform this operation you must remove this member
// from the replica set and add the member back with the new root path.
// %n
// %nIt is possible that this is a transient error due to Active Directory
// replication delays associated with updating FRS configuration objects.  If
// file replication does not take place after an appropriate waiting time,
// which could be several hours if cross site Active Directory replication
// is required, you must delete and re-add this member to the replica set.
// %n
// %nInformation related to this event is shown below:
// %nComputer DNS name is "%2"
// %nReplica set member name is "%3"
// %nThe current Replica set root path is "%4"
// %nThe desired new Replica set root path is "%5"
// %nReplica staging directory path is "%6"
//
#define EVENT_FRS_REPLICA_NO_ROOT_CHANGE 0xC00034F4L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL
//
// MessageText:
//
// The File Replication Service has detected a duplicate connection object between
// this computer "%6" and a computer named "%1".
// %nThis was detected for the following replica set:
// %n    "%2"
// %n
// %nThis is not allowed and replication will not occur between these two
// computers until the duplicate connection objects are removed.
// %n
// %nIt is possible that this is a transient error due to Active Directory
// replication delays associated with updating FRS configuration objects.  If
// file replication does not take place after an appropriate waiting time,
// which could be several hours if cross site Active Directory replication
// is required, you must manually delete the duplicate connection objects by
// following the steps below:
// %n
// %n [1] Start the Active Directory Sites and Services Snapin.
// %n [2] Click on "%3, %4, %5, %6, %7".
// %n [3] Look for duplicate connections from "%1" in site "%8".
// %n [4] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION_SYSVOL 0xC00034F5L

//
// MessageId: EVENT_FRS_DUPLICATE_IN_CXTION
//
// MessageText:
//
// The File Replication Service has detected a duplicate connection object between
// this computer "%7" and a computer named "%1".
// %nThis was detected for the following replica set:
// %n    "%2"
// %n
// %nThis is not allowed and replication will not occur between these two
// computers until the duplicate connection objects are removed.
// %n
// %nIt is possible that this is a transient error due to Active Directory
// replication delays associated with updating FRS configuration objects.  If
// file replication does not take place after an appropriate waiting time,
// which could be several hours if cross site Active Directory replication
// is required, you must manually delete the duplicate connection objects by
// following the steps below:
// %n
// %n [1] Start the Active Directory Users and Computers Snapin.
// %n [2] Click the view button and advanced features to display the system node.
// %n [3] Click on "%3, %4, %5".
// %n [4] Under "%5" you will see one or more DFS related replica set objects.
// Look for the FRS member object "%6" under the subtree for replica set "%2".
// %n [5] Under "%6" look for duplicate connections from "%1".
// %n [6] Delete all but one of the connections.
//
#define EVENT_FRS_DUPLICATE_IN_CXTION    0xC00034F6L

//
// MessageId: EVENT_FRS_ROOT_HAS_MOVED
//
// MessageText:
//
// The File Replication Service has detected that the replica root path has changed
// from "%2" to "%3". If this is an intentional move then a file with the name
// NTFRS_CMD_FILE_MOVE_ROOT needs to be created under the new root path.
// %nThis was detected for the following replica set:
// %n    "%1"
// %n
// %nChanging the replica root path is a two step process which is triggered by
// the creation of the NTFRS_CMD_FILE_MOVE_ROOT file.
// %n
// %n [1] At the first poll which will occur in %4 minutes this computer will be
// deleted from the replica set.
// %n [2] At the poll following the deletion this computer will be re-added to the
// replica set with the new root path. This re-addition will trigger a full tree
// sync for the replica set. At the end of the sync all the files will be at the new
// location. The files may or may not be deleted from the old location depending on whether
// they are needed or not.
//
#define EVENT_FRS_ROOT_HAS_MOVED         0xC00034F7L

//
// MessageId: EVENT_FRS_ERROR_REPLICA_SET_DELETED
//
// MessageText:
//
// The File Replication Service is deleting this computer from the replica set "%1" as an attempt to
// recover from the error state,
// %n Error status = %2
// %n At the next poll, which will occur in %3 minutes, this computer will be re-added to the
// replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_ERROR_REPLICA_SET_DELETED 0x800034F8L

//
// MessageId: EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR
//
// MessageText:
//
// The File Replication Service has detected that the replica set "%1" is in JRNL_WRAP_ERROR.
// %n
// %n Replica set name is    : "%1"
// %n Replica root path is   : "%2"
// %n Replica root volume is : "%3"
// %n
// 
// A Replica set hits JRNL_WRAP_ERROR when the record that it is trying to read from the NTFS USN journal is not found.
// This can occur because of one of the following reasons.
// %n
// %n [1] Volume "%3" has been formatted.
// %n [2] The NTFS USN journal on volume "%3" has been deleted.
// %n [3] The NTFS USN journal on volume "%3" has been truncated. Chkdsk can truncate
// the journal if it finds corrupt entries at the end of the journal.
// %n [4] File Replication Service was not running on this computer for a long time.
// %n [5] File Replication Service could not keep up with the rate of Disk IO activity on "%3".
// %n
// %n Following recovery steps will be taken to automatically recover from this error state.
// %n [1] At the first poll which will occur in %4 minutes this computer will be
// deleted from the replica set.
// %n [2] At the poll following the deletion this computer will be re-added to the
// replica set. The re-addition will trigger a full tree sync for the replica set.
//
#define EVENT_FRS_REPLICA_IN_JRNL_WRAP_ERROR 0xC00034F9L

//
// MessageId: EVENT_FRS_DS_POLL_ERROR_SUMMARY
//
// MessageText:
//
// Following is the summary of warnings and errors encountered by File Replication Service
// while polling the Domain Controller %1 for FRS replica set configuration information.
// %n
// %n %2
// %n
//
#define EVENT_FRS_DS_POLL_ERROR_SUMMARY  0x800034FAL

/////////////////////////////////////////////////////////////////////////
//
// PSCHED Events
//
// Codes 14000 - 14299
//
/////////////////////////////////////////////////////////////////////////
//
// Driver wide events (14000 - 14099)
//
//
// MessageId: EVENT_PS_GPC_REGISTER_FAILED
//
// MessageText:
//
// QoS: The Packet Scheduler failed to register with the Generic Packet Classifier (msgpc.sys).
//
#define EVENT_PS_GPC_REGISTER_FAILED     0xC00036B0L

//
// MessageId: EVENT_PS_NO_RESOURCES_FOR_INIT
//
// MessageText:
//
// QoS: The Packet Scheduler was unable to allocate required resources for initialization.
//
#define EVENT_PS_NO_RESOURCES_FOR_INIT   0xC00036B1L

//
// MessageId: EVENT_PS_REGISTER_PROTOCOL_FAILED
//
// MessageText:
//
// QoS: The Packet Scheduler failed to register as a protocol with NDIS.
//
#define EVENT_PS_REGISTER_PROTOCOL_FAILED 0xC00036B2L

//
// MessageId: EVENT_PS_REGISTER_MINIPORT_FAILED
//
// MessageText:
//
// QoS: The Packet Scheduler failed to register as a miniport with NDIS.
//
#define EVENT_PS_REGISTER_MINIPORT_FAILED 0xC00036B3L

//
// Adapter events (14100 - 14199)
//
//
// MessageId: EVENT_PS_BAD_BESTEFFORT_LIMIT
//
// MessageText:
//
// QoS [Adapter %2]:%nThe BestEffortLimit value set in the registry exceeds the LinkSpeed. Defaulting to Unlimited BestEffort.
//
#define EVENT_PS_BAD_BESTEFFORT_LIMIT    0x80003714L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE
//
// MessageText:
//
// QoS [Adapter %2]:%nThe network adapter driver failed the query for OID_GEN_MAXIMUM_FRAME_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_FRAME_SIZE 0xC0003715L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE
//
// MessageText:
//
// QoS [Adapter %2]:%nThe network adapter driver failed the query for OID_GEN_MAXIMUM_TOTAL_SIZE.
//
#define EVENT_PS_QUERY_OID_GEN_MAXIMUM_TOTAL_SIZE 0xC0003716L

//
// MessageId: EVENT_PS_QUERY_OID_GEN_LINK_SPEED
//
// MessageText:
//
// QoS [Adapter %2]:%nThe network adapter driver failed the query for OID_GEN_LINK_SPEED.
//
#define EVENT_PS_QUERY_OID_GEN_LINK_SPEED 0xC0003717L

//
// MessageId: EVENT_PS_BINDING_FAILED
//
// MessageText:
//
// QoS [Adapter %2]:%nThe Packet Scheduler failed to bind to the network adapter's miniport driver.
//
#define EVENT_PS_BINDING_FAILED          0xC0003718L

//
// MessageId: EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA
//
// MessageText:
//
// QoS [Adapter %2]:%nThe UpperBindings key is missing from the registry.
//
#define EVENT_PS_MISSING_ADAPTER_REGISTRY_DATA 0xC0003719L

//
// MessageId: EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED
//
// MessageText:
//
// QoS [Adapter %2]:%nThe Packet Scheduler was unable to register with the NDISWAN Call Manager.
//
#define EVENT_PS_REGISTER_ADDRESS_FAMILY_FAILED 0xC000371AL

//
// MessageId: EVENT_PS_INIT_DEVICE_FAILED
//
// MessageText:
//
// QoS [Adapter %2]:%nThe Packet Scheduler could not initialize the virtual miniport with NDIS.
//
#define EVENT_PS_INIT_DEVICE_FAILED      0xC000371BL

//
// MessageId: EVENT_PS_WMI_INSTANCE_NAME_FAILED
//
// MessageText:
//
// QoS [Adapter %2]:%nThe Packet Scheduler could not obtain the network adapter's friendly name from NDIS.
//
#define EVENT_PS_WMI_INSTANCE_NAME_FAILED 0xC000371CL

//
// MessageId: EVENT_PS_WAN_LIMITED_BESTEFFORT
//
// MessageText:
//
// QoS [Adapter %2]:%nThe registry entry for BestEffortLimit is not supported over WAN links. Defaulting to Unlimited BestEffort mode.
//
#define EVENT_PS_WAN_LIMITED_BESTEFFORT  0x8000371DL

//
// MessageId: EVENT_PS_RESOURCE_POOL
//
// MessageText:
//
// QoS [Adapter %2]:%nCould not initialize due to insufficient nonpaged pool memory.
//
#define EVENT_PS_RESOURCE_POOL           0xC000371EL

//
// MessageId: EVENT_PS_ADMISSIONCONTROL_OVERFLOW
//
// MessageText:
//
// QoS [Adapter %2]:%nTotal bandwidth allocated to flows exceeds the NonBestEffortLimit. This is because of a reduction in the LinkSpeed or because of a change to the NonBestEffortLimit registry key.
//
#define EVENT_PS_ADMISSIONCONTROL_OVERFLOW 0x8000371FL

//
// MessageId: EVENT_PS_NETWORK_ADDRESS_FAIL
//
// MessageText:
//
// QoS [Adapter %2]:%nCould not allocate non-paged pool memory for storing network addresses.
//
#define EVENT_PS_NETWORK_ADDRESS_FAIL    0xC0003720L


/////////////////////////////////////////////////////////////////////////
//
// Distributed File System (Dfs) Events (14300-14599)
//
/////////////////////////////////////////////////////////////////////////

//
// Server-side (dfs.sys) errors (14300-14399)
//
// NOTE: events 14300-14317 are UNUSED as of WS03. They need to remain so that
//       downlevel eventlogs can be parsed by uplevel systems.
//
//
// MessageId: EXTRA_EXIT_POINT
//
// MessageText:
//
// An extra ExitPoint %2 was found at server %3
//
#define EXTRA_EXIT_POINT                 0xC00037DCL

//
// MessageId: MISSING_EXIT_POINT
//
// MessageText:
//
// The ExitPoint %2 was missing at server %3
//
#define MISSING_EXIT_POINT               0xC00037DDL

//
// MessageId: MISSING_VOLUME
//
// MessageText:
//
// The Volume %2 was missing at server %3
//
#define MISSING_VOLUME                   0xC00037DEL

//
// MessageId: EXTRA_VOLUME
//
// MessageText:
//
// The extra Volume %2 was found at server %3
//
#define EXTRA_VOLUME                     0xC00037DFL

//
// MessageId: EXTRA_EXIT_POINT_DELETED
//
// MessageText:
//
// The extra ExitPoint %2 was deleted successfully from the server %3
//
#define EXTRA_EXIT_POINT_DELETED         0xC00037E0L

//
// MessageId: EXTRA_EXIT_POINT_NOT_DELETED
//
// MessageText:
//
// Unable to delete the extra ExitPoint %2 at the server %3
//
#define EXTRA_EXIT_POINT_NOT_DELETED     0xC00037E1L

//
// MessageId: MISSING_EXIT_POINT_CREATED
//
// MessageText:
//
// The missing ExitPoint %2 was created at the server %3 successfully
//
#define MISSING_EXIT_POINT_CREATED       0xC00037E2L

//
// MessageId: MISSING_EXIT_POINT_NOT_CREATED
//
// MessageText:
//
// Unable to create the missing Exit Point %2 at the server %3
//
#define MISSING_EXIT_POINT_NOT_CREATED   0xC00037E3L

//
// MessageId: MISSING_VOLUME_CREATED
//
// MessageText:
//
// Successfully created the missing volume %2 knowledge at the server %3
//
#define MISSING_VOLUME_CREATED           0xC00037E4L

//
// MessageId: MISSING_VOLUME_NOT_CREATED
//
// MessageText:
//
// Unable to create the missing Volume %2 info at server %3
//
#define MISSING_VOLUME_NOT_CREATED       0xC00037E5L

//
// MessageId: EXTRA_VOLUME_DELETED
//
// MessageText:
//
// The extra Volume %2 info was deleted at server %3
//
#define EXTRA_VOLUME_DELETED             0xC00037E6L

//
// MessageId: EXTRA_VOLUME_NOT_DELETED
//
// MessageText:
//
// The extra Volume %2 info was not deleted at server %3
//
#define EXTRA_VOLUME_NOT_DELETED         0xC00037E7L

//
// MessageId: COULD_NOT_VERIFY_VOLUMES
//
// MessageText:
//
// Since the DC %2 was unavailable could not verify volumes knowledge.
//
#define COULD_NOT_VERIFY_VOLUMES         0xC00037E8L

//
// MessageId: KNOWLEDGE_INCONSISTENCY_DETECTED
//
// MessageText:
//
// Detected Knowledge inconsistency with the volume %2 at server %3
//
#define KNOWLEDGE_INCONSISTENCY_DETECTED 0xC00037E9L

//
// MessageId: PREFIX_MISMATCH
//
// MessageText:
//
// The local Prefix %2 was represented as %3 at remote server %4
//
#define PREFIX_MISMATCH                  0xC00037EAL

//
// MessageId: PREFIX_MISMATCH_FIXED
//
// MessageText:
//
// The remote Prefix %3 was corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_FIXED            0xC00037EBL

//
// MessageId: PREFIX_MISMATCH_NOT_FIXED
//
// MessageText:
//
// The remote Prefix %3 was NOT corrected to %2 at remote server %4
//
#define PREFIX_MISMATCH_NOT_FIXED        0xC00037ECL

//
// MessageId: MACHINE_UNJOINED
//
// MessageText:
//
// The machine %2 has become unlinked from the domain. Re-join the machine the machine to this domain.
//
#define MACHINE_UNJOINED                 0xC00037EDL

//
// MessageId: DFS_REFERRAL_REQUEST
//
// MessageText:
//
// Dfs received a referral request for "%2".  The return code is in the data.
//
#define DFS_REFERRAL_REQUEST             0x400037EEL

//
// Client-side Dfs (mup.sys) errors (14400-14499)
//
// NOTE: events 14400-14407 are UNUSED as of Vista. They need to remain so that
//       downlevel eventlogs can be parsed by uplevel systems.
//
//
// MessageId: NOT_A_DFS_PATH
//
// MessageText:
//
// The path "%2" is not a dfs path
//
#define NOT_A_DFS_PATH                   0x40003840L

//
// MessageId: LM_REDIR_FAILURE
//
// MessageText:
//
// Dfs was unable to open the Lan Redir
//
#define LM_REDIR_FAILURE                 0x40003841L

//
// MessageId: DFS_CONNECTION_FAILURE
//
// MessageText:
//
// Dfs was unable to open a connection to server %2.  The error returned is in the record data.
//
#define DFS_CONNECTION_FAILURE           0x40003842L

//
// MessageId: DFS_REFERRAL_FAILURE
//
// MessageText:
//
// Dfs was unable to obtain a referral for "%2" from %3.  The error returned is in the record data.
//
#define DFS_REFERRAL_FAILURE             0x40003843L

//
// MessageId: DFS_REFERRAL_SUCCESS
//
// MessageText:
//
// Dfs obtained a referral for "%2" from %3
//
#define DFS_REFERRAL_SUCCESS             0x40003844L

//
// MessageId: DFS_MAX_DNR_ATTEMPTS
//
// MessageText:
//
// Dfs reached its limit of attempts of resolution of "%2".
//
#define DFS_MAX_DNR_ATTEMPTS             0x40003845L

//
// MessageId: DFS_SPECIAL_REFERRAL_FAILURE
//
// MessageText:
//
// Dfs was unable to obtain the special referral table from %2.  The error returned is in the record data.
//
#define DFS_SPECIAL_REFERRAL_FAILURE     0x40003846L

//
// MessageId: DFS_OPEN_FAILURE
//
// MessageText:
//
// Dfs failed on open of %2 directed to %3.  The error returned is in the record data.
//
#define DFS_OPEN_FAILURE                 0x40003847L

//
// Dfs service (dfssvc) errors (14500-14599)
//
// NOTE: events 14500-14501 are UNUSED as of WS03.
//       events 14502, 14506-07, 14525, 14527-28 were defined in WS03 development
//             but never issued in retail, and have been removed.
//
//
// MessageId: NET_DFS_ENUM
//
// MessageText:
//
// NetrDfsEnum received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUM                     0x400038A4L

//
// MessageId: NET_DFS_ENUMEX
//
// MessageText:
//
// NetrDfsEnumEx received an enumeration.  The return code is in the record data.
//
#define NET_DFS_ENUMEX                   0x400038A5L

#ifndef UNDER_CE
//
// MessageId: DFS_ERROR_CREATE_REPARSEPOINT_FAILURE
//
// MessageText:
//
// Dfs could not create reparse point for directory %1 under directory %2. The return code is in the record data.
//
#define DFS_ERROR_CREATE_REPARSEPOINT_FAILURE 0xC00038A7L

//
// MessageId: DFS_ERROR_UNSUPPORTED_FILESYSTEM
//
// MessageText:
//
// Share %1 mapped to %2 does not support reparse points. Upgrade Filesystem and retry.
//
#define DFS_ERROR_UNSUPPORTED_FILESYSTEM 0xC00038A8L

//
// MessageId: DFS_ERROR_OVERLAPPING_DIRECTORIES
//
// MessageText:
//
// Share %1 mapped to %2 directory overlaps an existing root. The DFS Root will not be created.
//
#define DFS_ERROR_OVERLAPPING_DIRECTORIES 0xC00038A9L
#endif  //  UNDER_CE

//
// MessageId: DFS_INFO_ACTIVEDIRECTORY_ONLINE
//
// MessageText:
//
// DFS re-established a connection to the PDC to initiate Domain DFS operations.
//
#define DFS_INFO_ACTIVEDIRECTORY_ONLINE  0x400038ACL

#ifndef UNDER_CE
//
// MessageId: DFS_ERROR_TOO_MANY_ERRORS
//
// MessageText:
//
// Root %1 has too many errors. No further eventlogs will be logged on this root.
//
#define DFS_ERROR_TOO_MANY_ERRORS        0xC00038ADL

//
// MessageId: DFS_ERROR_WINSOCKINIT_FAILED
//
// MessageText:
//
// DFS could not initialize winsock library. The return code is in the record data.
//
#define DFS_ERROR_WINSOCKINIT_FAILED     0xC00038AEL

//
// MessageId: DFS_ERROR_SECURITYINIT_FAILED
//
// MessageText:
//
// DFS could not initialize security library. The return code is in the record data.
//
#define DFS_ERROR_SECURITYINIT_FAILED    0xC00038AFL

//
// MessageId: DFS_ERROR_THREADINIT_FAILED
//
// MessageText:
//
// DFS could not create DFS support thread. The return code is in the record data.
//
#define DFS_ERROR_THREADINIT_FAILED      0xC00038B0L

//
// MessageId: DFS_ERROR_SITECACHEINIT_FAILED
//
// MessageText:
//
// DFS could not initialize IP site cache. The return code is in the record data.
//
#define DFS_ERROR_SITECACHEINIT_FAILED   0xC00038B1L

//
// MessageId: DFS_ERROR_ROOTSYNCINIT_FAILED
//
// MessageText:
//
// DFS could not synchronize all DFS roots. The return code is in the record data.
//
#define DFS_ERROR_ROOTSYNCINIT_FAILED    0xC00038B2L

//
// MessageId: DFS_ERROR_CREATEEVENT_FAILED
//
// MessageText:
//
// DFS could not create event handle. The return code is in the record data.
//
#define DFS_ERROR_CREATEEVENT_FAILED     0xC00038B3L

//
// MessageId: DFS_ERROR_COMPUTERINFO_FAILED
//
// MessageText:
//
// DFS could not get required computer information. The return code is in the record data.
//
#define DFS_ERROR_COMPUTERINFO_FAILED    0xC00038B4L

//
// MessageId: DFS_ERROR_CLUSTERINFO_FAILED
//
// MessageText:
//
// DFS could not get required cluster information. The return code is in the record data.
//
#define DFS_ERROR_CLUSTERINFO_FAILED     0xC00038B5L

//
// MessageId: DFS_ERROR_DCINFO_FAILED
//
// MessageText:
//
// DFS could not get required DC information. The return code is in the record data.
//
#define DFS_ERROR_DCINFO_FAILED          0xC00038B6L

//
// MessageId: DFS_ERROR_PREFIXTABLE_FAILED
//
// MessageText:
//
// DFS could not initialize prefix table. The return code is in the record data.
//
#define DFS_ERROR_PREFIXTABLE_FAILED     0xC00038B7L

//
// MessageId: DFS_ERROR_HANDLENAMESPACE_FAILED
//
// MessageText:
//
// DFS could not initialize DFS namespace.The return code is in the record data.
//
#define DFS_ERROR_HANDLENAMESPACE_FAILED 0xC00038B8L

//
// MessageId: DFS_ERROR_REGISTERSTORE_FAILED
//
// MessageText:
//
// DFS could not Register DFS Namespaces. The return code is in the record data.
//
#define DFS_ERROR_REGISTERSTORE_FAILED   0xC00038B9L

//
// MessageId: DFS_ERROR_REFLECTIONENGINE_FAILED
//
// MessageText:
//
// DFS could not initialize User/kernel communication package. The return code is in the record data.
//
#define DFS_ERROR_REFLECTIONENGINE_FAILED 0xC00038BAL

//
// MessageId: DFS_ERROR_ACTIVEDIRECTORY_OFFLINE
//
// MessageText:
//
// DFS could not contact any DC for Domain DFS operations. This operation will be retried periodically.
//
#define DFS_ERROR_ACTIVEDIRECTORY_OFFLINE 0xC00038BBL

//
// MessageId: DFS_ERROR_SITESUPPOR_FAILED
//
// MessageText:
//
// DFS could not initialize site support table. The return code is in the record data.
//
#define DFS_ERROR_SITESUPPOR_FAILED      0xC00038BCL

//
// MessageId: DFS_ERROR_DSCONNECT_FAILED
//
// MessageText:
//
// DFS could not contact the %1 Active Directory. DFS will be using cached data. The return code is in the record data.
//
#define DFS_ERROR_DSCONNECT_FAILED       0x800038BEL
#endif  //  UNDER_CE

//
// MessageId: DFS_INFO_DS_RECONNECTED
//
// MessageText:
//
// DFS has connected to the %1 Active Directory.
//
#define DFS_INFO_DS_RECONNECTED          0x400038C1L

#ifndef UNDER_CE
//
// MessageId: DFS_ERROR_NO_DFS_DATA
//
// MessageText:
//
// DFS could not access its private data from the Active Directory. Please manually check
// network connectivity, security access, and/or consistency of DFS information
// in the Active Directory. This error occurred on root %1.
//
#define DFS_ERROR_NO_DFS_DATA            0xC00038C2L
#endif  //  UNDER_CE

//
// MessageId: DFS_INFO_FINISH_INIT
//
// MessageText:
//
// DFS server has finished initializing.
//
#define DFS_INFO_FINISH_INIT             0x400038C3L

//
// MessageId: DFS_INFO_RECONNECT_DATA
//
// MessageText:
//
// DFS has recovered from an error and is able to read its private data from
// the Active Directory. Root %1 is now able to read information from the Active Directory.
//
#define DFS_INFO_RECONNECT_DATA          0x400038C4L

//
// MessageId: DFS_INFO_FINISH_BUILDING_NAMESPACE
//
// MessageText:
//
// DFS has finished building all namespaces.
//
#define DFS_INFO_FINISH_BUILDING_NAMESPACE 0x400038C5L

#ifndef UNDER_CE
//
// MessageId: DFS_ERROR_ON_ROOT
//
// MessageText:
//
// DFS Root %1 failed during initialization. The root will not be available.
//
#define DFS_ERROR_ON_ROOT                0x800038C6L

//
// MessageId: DFS_ERROR_MUTLIPLE_ROOTS_NOT_SUPPORTED
//
// MessageText:
//
// DFS does not support multiple roots on Standard server SKU. Please cleanup the roots or upgrade.
//
#define DFS_ERROR_MUTLIPLE_ROOTS_NOT_SUPPORTED 0xC00038C7L
#endif  //  UNDER_CE

//
// MessageId: DFS_WARN_DOMAIN_REFERRAL_OVERFLOW
//
// MessageText:
//
// DFS is unable to return the entire list of trusted domains to the client. There are too many trusted domains.
//
#define DFS_WARN_DOMAIN_REFERRAL_OVERFLOW 0x800038C8L

//
// MessageId: DFS_INFO_DOMAIN_REFERRAL_MIN_OVERFLOW
//
// MessageText:
//
// DFS is requesting the client for a larger buffer for trusted domain information. Some Win98 clients may not be able to access DFS namespaces.
//
#define DFS_INFO_DOMAIN_REFERRAL_MIN_OVERFLOW 0x400038C9L

//
// MessageId: DFS_WARN_INCOMPLETE_MOVE
//
// MessageText:
//
// DFS was unable to move all matching links of root: %1 for path %2 to new path %3
//
#define DFS_WARN_INCOMPLETE_MOVE         0x800038CAL

#ifndef UNDER_CE
//
// MessageId: DFS_ERROR_RESYNCHRONIZE_FAILED
//
// MessageText:
//
// DFS was unable to resynchronize this root target for root: %1. This may lead to inaccessability of portions of the DFS namespace. 
// Please verify the share %1 has all the link directories created for the DFS links. This error may occur if there are directories 
// on this share that may be preventing creation of links.
//
#define DFS_ERROR_RESYNCHRONIZE_FAILED   0xC00038CBL

//
// MessageId: DFS_ERROR_REMOVE_LINK_FAILED
//
// MessageText:
//
// DFS was unable to delete link: %2  for root: %1 during a link move operation. 
//
#define DFS_ERROR_REMOVE_LINK_FAILED     0xC00038CCL
#endif  //  UNDER_CE

//
// MessageId: DFS_WARN_METADATA_LINK_TYPE_INCORRECT
//
// MessageText:
//
// DFS link %1 was marked incorrectly as a DFS root. The DFS namespace is operational on this server. If this namespace is hosted on servers running Windows Server 2003 prior to Service Pack 2 (SP2), or if the server is running Windows 2000 Server, the namespace might not be fully functional on those servers.
// 
// Please consult the Microsoft Knowledge Base for more information on correcting this issue.
//
#define DFS_WARN_METADATA_LINK_TYPE_INCORRECT 0x800038CDL

//
// MessageId: DFS_WARN_METADATA_LINK_INFO_INVALID
//
// MessageText:
//
// DFS metadata object %1 is empty in the metadata for DFS root %2. The DFS namespace is operational on this server. If this namespace is hosted on servers running Windows Server 2003 prior to Service Pack 2 (SP2), or if the server is running Windows 2000 Server, the namespace might not be fully functional on those servers.
// 
// Please consult the Microsoft Knowledge Base for more information on correcting this issue.
//
#define DFS_WARN_METADATA_LINK_INFO_INVALID 0x800038CEL

/////////////////////////////////////////////////////////////////////////
//
// BRIDGE Events
//
// Codes 14600 - 14899
//
/////////////////////////////////////////////////////////////////////////
//
// Driver-wide events (14600 - 14699)
//
//
// MessageId: EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED
//
// MessageText:
//
// Bridge: The bridge could not be initialized because the bridge failed to register as a protocol with NDIS.
//
#define EVENT_BRIDGE_PROTOCOL_REGISTER_FAILED 0xC0003908L

//
// MessageId: EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING
//
// MessageText:
//
// Bridge: The bridge could not be initialized because the bridge's miniport device name is missing from the registry.
//
#define EVENT_BRIDGE_MINIPROT_DEVNAME_MISSING 0xC0003909L

//
// MessageId: EVENT_BRIDGE_MINIPORT_REGISTER_FAILED
//
// MessageText:
//
// Bridge: The bridge could not be initialized because the bridge failed to register as a miniport with NDIS.
//
#define EVENT_BRIDGE_MINIPORT_REGISTER_FAILED 0xC000390AL

//
// MessageId: EVENT_BRIDGE_DEVICE_CREATION_FAILED
//
// MessageText:
//
// Bridge: The bridge could not be initialized because the bridge failed to create a device object.
//
#define EVENT_BRIDGE_DEVICE_CREATION_FAILED 0xC000390BL

//
// MessageId: EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR
//
// MessageText:
//
// Bridge: The bridge could not be initialized because the bridge failed to determine a MAC address for itself.
//
#define EVENT_BRIDGE_NO_BRIDGE_MAC_ADDR  0xC000390CL

//
// MessageId: EVENT_BRIDGE_MINIPORT_INIT_FAILED
//
// MessageText:
//
// Bridge: The bridge failed to create its virtual miniport.
//
#define EVENT_BRIDGE_MINIPORT_INIT_FAILED 0xC000390DL

//
// MessageId: EVENT_BRIDGE_ETHERNET_NOT_OFFERED
//
// MessageText:
//
// Bridge: The bridge could not initialize its miniport because Ethernet was not offered as a supported medium.
//
#define EVENT_BRIDGE_ETHERNET_NOT_OFFERED 0xC000390EL

//
// MessageId: EVENT_BRIDGE_THREAD_CREATION_FAILED
//
// MessageText:
//
// Bridge: The bridge could not initialize because it failed to create a system thread.
//
#define EVENT_BRIDGE_THREAD_CREATION_FAILED 0xC000390FL

//
// MessageId: EVENT_BRIDGE_THREAD_REF_FAILED
//
// MessageText:
//
// Bridge: The bridge could not initialize because it failed to reference its system thread.
//
#define EVENT_BRIDGE_THREAD_REF_FAILED   0xC0003910L

//
// MessageId: EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED
//
// MessageText:
//
// Bridge: The bridge could not initialize because it failed to create a packet pool.
//
#define EVENT_BRIDGE_PACKET_POOL_CREATION_FAILED 0xC0003911L

//
// MessageId: EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED
//
// MessageText:
//
// Bridge: The bridge could not initialize because it failed to create a buffer pool.
//
#define EVENT_BRIDGE_BUFFER_POOL_CREATION_FAILED 0xC0003912L

//
// MessageId: EVENT_BRIDGE_INIT_MALLOC_FAILED
//
// MessageText:
//
// Bridge: The bridge could not initialize because it failed to allocate memory.
//
#define EVENT_BRIDGE_INIT_MALLOC_FAILED  0xC0003913L

//
// Adapter-specific events (14700 - 14799)
//
//
// MessageId: EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED
//
// MessageText:
//
// Bridge [Adapter %2]:%nThe bridge could not determine the network adapter's link speed. The network adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_LINK_SPEED_QUERY_FAILED 0xC000396CL

//
// MessageId: EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED
//
// MessageText:
//
// Bridge [Adapter %2]:%nThe bridge could not determine the network adapter's MAC address. The network adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_MAC_ADDR_QUERY_FAILED 0xC000396DL

#ifdef UNDER_CE
//
// MessageId: EVENT_BRIDGE_ADAPTER_PROMISCUOUS_FAILED
//
// MessageText:
//
//  Bridge [Adapter %2]:%nThe bridge could not put the adapter into or out of promiscuous receive mode. The adapter will not function correctly.
//
#define EVENT_BRIDGE_ADAPTER_PROMISCUOUS_FAILED 0xC000396EL
#else  //  UNDER_CE
//
// MessageId: EVENT_BRIDGE_ADAPTER_FILTER_FAILED
//
// MessageText:
//
// Bridge [Adapter %2]:%nThe bridge could not modify the network adapter's packet filter. The network adapter will not function correctly.
//
#define EVENT_BRIDGE_ADAPTER_FILTER_FAILED 0xC000396EL
#endif  //  UNDER_CE

//
// MessageId: EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED
//
// MessageText:
//
// Bridge [Adapter %2]:%nThe bridge could not retrieve the network adapter's description string. The network adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_NAME_QUERY_FAILED 0xC000396FL

//
// MessageId: EVENT_BRIDGE_ADAPTER_BIND_FAILED
//
// MessageText:
//
// Bridge [Adapter %2]:%nThe bridge failed to bind to the network adapter. The network adapter will not be used.
//
#define EVENT_BRIDGE_ADAPTER_BIND_FAILED 0xC0003970L

#ifndef UNDER_CE
//
// DAV Redir Events (14800 - 14899)
//
//
// MessageId: EVENT_DAV_REDIR_DELAYED_WRITE_FAILED
//
// MessageText:
//
// Windows was unable to save data for file %2. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define EVENT_DAV_REDIR_DELAYED_WRITE_FAILED 0x800039D0L

//
// WebClient Service Events (14900 - 14999)
//
//
// MessageId: EVENT_WEBCLIENT_CLOSE_PUT_FAILED
//
// MessageText:
//
// PUT failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PUT_FAILED 0x80003A35L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_DELETE_FAILED
//
// MessageText:
//
// DELETE failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_DELETE_FAILED 0x80003A36L

//
// MessageId: EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED
//
// MessageText:
//
// PROPPATCH failed for file %1 on Close. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_CLOSE_PROPPATCH_FAILED 0x80003A37L

//
// MessageId: EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED
//
// MessageText:
//
// PROPPATCH failed for file %1 on SetFileInfo. ErrorStatus: %2.
//
#define EVENT_WEBCLIENT_SETINFO_PROPPATCH_FAILED 0x80003A38L
#endif  //  UNDER_CE


/////////////////////////////////////////////////////////////////////////
//
// Winsock/WSK Events (16000-16199)
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: EVENT_WSK_OWNINGTHREAD_PARAMETER_IGNORED
//
// MessageText:
//
// WSK provider has ignored the OwningThread parameter passed to a WSK socket creation request. This happens when the socket needs to be created over a TDI transport provider either because a TDI filter driver is installed or because a client-specified TDI mapping exists that matches the AddressFamily, socketType, and Protocol specified in the socket creation request.
//
#define EVENT_WSK_OWNINGTHREAD_PARAMETER_IGNORED 0xC0003E80L


/////////////////////////////////////////////////////////////////////////
//
// eQoS Events (16500 -16999)
//
/////////////////////////////////////////////////////////////////////////


//
// Informational
//

//
// MessageId: EVENT_EQOS_INFO_MACHINE_POLICY_REFRESH_NO_CHANGE
//
// MessageText:
//
// Computer QoS policies successfully refreshed. No changes detected.
//
#define EVENT_EQOS_INFO_MACHINE_POLICY_REFRESH_NO_CHANGE 0x40004074L

//
// MessageId: EVENT_EQOS_INFO_MACHINE_POLICY_REFRESH_WITH_CHANGE
//
// MessageText:
//
// Computer QoS policies successfully refreshed. Policy changes detected.
//
#define EVENT_EQOS_INFO_MACHINE_POLICY_REFRESH_WITH_CHANGE 0x40004075L

//
// MessageId: EVENT_EQOS_INFO_USER_POLICY_REFRESH_NO_CHANGE
//
// MessageText:
//
// User QoS policies successfully refreshed. No changes detected.
//
#define EVENT_EQOS_INFO_USER_POLICY_REFRESH_NO_CHANGE 0x40004076L

//
// MessageId: EVENT_EQOS_INFO_USER_POLICY_REFRESH_WITH_CHANGE
//
// MessageText:
//
// User QoS policies successfully refreshed. Policy changes detected.
//
#define EVENT_EQOS_INFO_USER_POLICY_REFRESH_WITH_CHANGE 0x40004077L

//
// MessageId: EVENT_EQOS_INFO_TCP_AUTOTUNING_NOT_CONFIGURED
//
// MessageText:
//
// The Advanced QoS Setting for inbound TCP throughput level successfully refreshed. 
// Setting value is not specified by any QoS policy. Local computer default will be applied.
//
#define EVENT_EQOS_INFO_TCP_AUTOTUNING_NOT_CONFIGURED 0x40004078L

//
// MessageId: EVENT_EQOS_INFO_TCP_AUTOTUNING_OFF
//
// MessageText:
//
// The Advanced QoS Setting for inbound TCP throughput level successfully refreshed. 
// Setting value is Level 0 (minimum throughput).
//
#define EVENT_EQOS_INFO_TCP_AUTOTUNING_OFF 0x40004079L

//
// MessageId: EVENT_EQOS_INFO_TCP_AUTOTUNING_HIGHLY_RESTRICTED
//
// MessageText:
//
// The Advanced QoS Setting for inbound TCP throughput level successfully refreshed. 
// Setting value is Level 1.
//
#define EVENT_EQOS_INFO_TCP_AUTOTUNING_HIGHLY_RESTRICTED 0x4000407AL

//
// MessageId: EVENT_EQOS_INFO_TCP_AUTOTUNING_RESTRICTED
//
// MessageText:
//
// The Advanced QoS Setting for inbound TCP throughput level successfully refreshed. 
// Setting value is Level 2.
//
#define EVENT_EQOS_INFO_TCP_AUTOTUNING_RESTRICTED 0x4000407BL

//
// MessageId: EVENT_EQOS_INFO_TCP_AUTOTUNING_NORMAL
//
// MessageText:
//
// The Advanced QoS Setting for inbound TCP throughput level successfully refreshed. 
// Setting value is Level 3 (maximum throughput).
//
#define EVENT_EQOS_INFO_TCP_AUTOTUNING_NORMAL 0x4000407CL

//
// MessageId: EVENT_EQOS_INFO_APP_MARKING_NOT_CONFIGURED
//
// MessageText:
//
// The Advanced QoS Setting for DSCP marking overrides successfully refreshed. 
// Setting value is not specified by any QoS policy. Local computer default will be applied. By default, applications can set DSCP values independently of QoS policies.
//
#define EVENT_EQOS_INFO_APP_MARKING_NOT_CONFIGURED 0x4000407DL

//
// MessageId: EVENT_EQOS_INFO_APP_MARKING_IGNORED
//
// MessageText:
//
// The Advanced QoS Setting for DSCP marking overrides successfully refreshed. 
// Application DSCP marking requests will be ignored. Only QoS policies can set DSCP values.
//
#define EVENT_EQOS_INFO_APP_MARKING_IGNORED 0x4000407EL

//
// MessageId: EVENT_EQOS_INFO_APP_MARKING_ALLOWED
//
// MessageText:
//
// The Advanced QoS Setting for DSCP marking overrides successfully refreshed. 
// Applications can set DSCP values independently of QoS policies.
//
#define EVENT_EQOS_INFO_APP_MARKING_ALLOWED 0x4000407FL

//
// MessageId: EVENT_EQOS_INFO_LOCAL_SETTING_DONT_USE_NLA
//
// MessageText:
//
// Selective application of QoS policies based on domain or non-domain network category has been disabled on this machine.
// QoS policies will be applied to all network interfaces.    
//
#define EVENT_EQOS_INFO_LOCAL_SETTING_DONT_USE_NLA 0x40004080L


//
// Warnings
//

//
// MessageId: EVENT_EQOS_WARNING_TEST_1
//
// MessageText:
//
// EQOS: ***Testing***, with one string %2.
//
#define EVENT_EQOS_WARNING_TEST_1        0x800040D8L

//
// MessageId: EVENT_EQOS_WARNING_TEST_2
//
// MessageText:
//
// EQOS: ***Testing***, with two strings, string1 is %2, string2 is %3.
//
#define EVENT_EQOS_WARNING_TEST_2        0x800040D9L

//
// MessageId: EVENT_EQOS_WARNING_MACHINE_POLICY_VERSION
//
// MessageText:
//
// A computer QoS policy "%2" has an invalid version number. This policy will not be applied.
//
#define EVENT_EQOS_WARNING_MACHINE_POLICY_VERSION 0x800040DAL

//
// MessageId: EVENT_EQOS_WARNING_USER_POLICY_VERSION
//
// MessageText:
//
// A user QoS policy "%2" has an invalid version number. This policy will not be applied.
//
#define EVENT_EQOS_WARNING_USER_POLICY_VERSION 0x800040DBL

//
// MessageId: EVENT_EQOS_WARNING_MACHINE_POLICY_PROFILE_NOT_SPECIFIED
//
// MessageText:
//
// A computer QoS policy "%2" does not specify a DSCP value or throttle rate. This policy will not be applied.
//
#define EVENT_EQOS_WARNING_MACHINE_POLICY_PROFILE_NOT_SPECIFIED 0x800040DCL

//
// MessageId: EVENT_EQOS_WARNING_USER_POLICY_PROFILE_NOT_SPECIFIED
//
// MessageText:
//
// A user QoS policy "%2" does not specify a DSCP value or throttle rate. This policy will not be applied.
//
#define EVENT_EQOS_WARNING_USER_POLICY_PROFILE_NOT_SPECIFIED 0x800040DDL

//
// MessageId: EVENT_EQOS_WARNING_MACHINE_POLICY_QUOTA_EXCEEDED
//
// MessageText:
//
// Exceeded the maximum number of computer QoS policies. 
// The computer QoS policy "%2" and subsequent computer QoS policies will not be applied.
//
#define EVENT_EQOS_WARNING_MACHINE_POLICY_QUOTA_EXCEEDED 0x800040DEL

//
// MessageId: EVENT_EQOS_WARNING_USER_POLICY_QUOTA_EXCEEDED
//
// MessageText:
//
// Exceeded the maximum number of user QoS policies. 
// The user QoS policy "%2" and subsequent user QoS policies will not be applied.
//
#define EVENT_EQOS_WARNING_USER_POLICY_QUOTA_EXCEEDED 0x800040DFL

//
// MessageId: EVENT_EQOS_WARNING_MACHINE_POLICY_CONFLICT
//
// MessageText:
//
// A computer QoS policy "%2" potentially conflicts with other QoS policies. 
// See documentation for rules about which policy will be applied at packet send time.
//
#define EVENT_EQOS_WARNING_MACHINE_POLICY_CONFLICT 0x800040E0L

//
// MessageId: EVENT_EQOS_WARNING_USER_POLICY_CONFLICT
//
// MessageText:
//
// A user QoS policy "%2" potentially conflicts with other QoS policies. 
// See documentation for rules about which policy will be applied at packet send time.
//
#define EVENT_EQOS_WARNING_USER_POLICY_CONFLICT 0x800040E1L

//
// MessageId: EVENT_EQOS_WARNING_MACHINE_POLICY_NO_FULLPATH_APPNAME
//
// MessageText:
//
// A computer QoS policy "%2" was ignored because the application path cannot be processed.  
// The application path may be totally invalid, or has an invalid drive letter, or contains network-mapped drive letter.
//
#define EVENT_EQOS_WARNING_MACHINE_POLICY_NO_FULLPATH_APPNAME 0x800040E2L

//
// MessageId: EVENT_EQOS_WARNING_USER_POLICY_NO_FULLPATH_APPNAME
//
// MessageText:
//
// A user QoS policy "%2" was ignored because the application path cannot be processed.  
// The application path may be totally invalid, or has an invalid drive letter, or contains network-mapped drive letter.
//
#define EVENT_EQOS_WARNING_USER_POLICY_NO_FULLPATH_APPNAME 0x800040E3L


//
// Errors
//

//
// MessageId: EVENT_EQOS_ERROR_MACHINE_POLICY_REFERESH
//
// MessageText:
//
// Computer QoS policies failed to refresh. Error code: %2.
//
#define EVENT_EQOS_ERROR_MACHINE_POLICY_REFERESH 0xC000413CL

//
// MessageId: EVENT_EQOS_ERROR_USER_POLICY_REFERESH
//
// MessageText:
//
// User QoS policies failed to refresh. Error code: %2.
//
#define EVENT_EQOS_ERROR_USER_POLICY_REFERESH 0xC000413DL

//
// MessageId: EVENT_EQOS_ERROR_OPENING_MACHINE_POLICY_ROOT_KEY
//
// MessageText:
//
// QoS failed to open the computer-level root key for QoS policies. Error code: %2.
//
#define EVENT_EQOS_ERROR_OPENING_MACHINE_POLICY_ROOT_KEY 0xC000413EL

//
// MessageId: EVENT_EQOS_ERROR_OPENING_USER_POLICY_ROOT_KEY
//
// MessageText:
//
// QoS failed to open the user-level root key for QoS policies. Error code: %2.
//
#define EVENT_EQOS_ERROR_OPENING_USER_POLICY_ROOT_KEY 0xC000413FL

//
// MessageId: EVENT_EQOS_ERROR_MACHINE_POLICY_KEYNAME_TOO_LONG
//
// MessageText:
//
// A computer QoS policy exceeds the maximum allowed name length. 
// The offending policy is listed under the computer-level QoS policy root key, with index %2. 
//
#define EVENT_EQOS_ERROR_MACHINE_POLICY_KEYNAME_TOO_LONG 0xC0004140L

//
// MessageId: EVENT_EQOS_ERROR_USER_POLICY_KEYNAME_TOO_LONG
//
// MessageText:
//
// A user QoS policy exceeds the maximum allowed name length. 
// The offending policy is listed under the user-level QoS policy root key, with index %2. 
//
#define EVENT_EQOS_ERROR_USER_POLICY_KEYNAME_TOO_LONG 0xC0004141L

//
// MessageId: EVENT_EQOS_ERROR_MACHINE_POLICY_KEYNAME_SIZE_ZERO
//
// MessageText:
//
// A computer QoS policy has a zero length name. 
// The offending policy is listed under the computer-level QoS policy root key, with index %2.
//
#define EVENT_EQOS_ERROR_MACHINE_POLICY_KEYNAME_SIZE_ZERO 0xC0004142L

//
// MessageId: EVENT_EQOS_ERROR_USER_POLICY_KEYNAME_SIZE_ZERO
//
// MessageText:
//
// A user QoS policy has a zero length name. 
// The offending policy is listed under the user-level QoS policy root key, with index %2.
//
#define EVENT_EQOS_ERROR_USER_POLICY_KEYNAME_SIZE_ZERO 0xC0004143L

//
// MessageId: EVENT_EQOS_ERROR_OPENING_MACHINE_POLICY_SUBKEY
//
// MessageText:
//
// QoS failed to open the registry subkey for a computer QoS policy. 
// The policy is listed under the computer-level QoS policy root key, with index %2. 
//
#define EVENT_EQOS_ERROR_OPENING_MACHINE_POLICY_SUBKEY 0xC0004144L

//
// MessageId: EVENT_EQOS_ERROR_OPENING_USER_POLICY_SUBKEY
//
// MessageText:
//
// QoS failed to open the registry subkey for a user QoS policy. 
// The policy is listed under the user-level QoS policy root key, with index %2. 
//
#define EVENT_EQOS_ERROR_OPENING_USER_POLICY_SUBKEY 0xC0004145L

//
// MessageId: EVENT_EQOS_ERROR_PROCESSING_MACHINE_POLICY_FIELD
//
// MessageText:
//
// QoS failed to read or validate the "%2" field for the computer QoS policy "%3".
//
#define EVENT_EQOS_ERROR_PROCESSING_MACHINE_POLICY_FIELD 0xC0004146L

//
// MessageId: EVENT_EQOS_ERROR_PROCESSING_USER_POLICY_FIELD
//
// MessageText:
//
// QoS failed to read or validate the "%2" field for the user QoS policy "%3".
//
#define EVENT_EQOS_ERROR_PROCESSING_USER_POLICY_FIELD 0xC0004147L

//
// MessageId: EVENT_EQOS_ERROR_SETTING_TCP_AUTOTUNING
//
// MessageText:
//
// QoS failed to read or set inbound TCP throughput level, error code: "%2".
//
#define EVENT_EQOS_ERROR_SETTING_TCP_AUTOTUNING 0xC0004148L

//
// MessageId: EVENT_EQOS_ERROR_SETTING_APP_MARKING
//
// MessageText:
//
// QoS failed to read or set the DSCP marking override setting, error code: "%2".
//
#define EVENT_EQOS_ERROR_SETTING_APP_MARKING 0xC0004149L


#endif // _NETEVENT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\new.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/***
*new.h - declarations and definitions for C++ memory allocation functions
*
*
*Purpose:
*       Contains the declarations for C++ memory allocation functions.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_NEW
#define _INC_NEW

#ifdef  __cplusplus

#ifndef _MSC_EXTENSIONS
#include <new>
#endif

#include <crtdefs.h>

/* Protect against #define of new */
#pragma push_macro("new")
#undef  new

/* types and structures */

#ifdef  _MSC_EXTENSIONS

// set_new_handler should be in namespace std
// namespace std {

typedef void (__cdecl * new_handler) ();
_CRTIMP new_handler __cdecl set_new_handler(__in_opt new_handler _NewHandler) throw();

// using std::new_handler;
// using std::set_new_handler;

// }

#endif

#ifndef __NOTHROW_T_DEFINED
#define __NOTHROW_T_DEFINED
namespace std {
        /* placement new tag type to suppress exceptions */
        struct nothrow_t {};

        /* constant for placement new tag */
        extern const nothrow_t nothrow;
};

__bcount_opt(_Size) void *__CRTDECL operator new(size_t _Size, const std::nothrow_t&) throw();
__bcount_opt(_Size) void *__CRTDECL operator new[](size_t _Size, const std::nothrow_t&) throw();
void __CRTDECL operator delete(void *, const std::nothrow_t&) throw();
void __CRTDECL operator delete[](void *, const std::nothrow_t&) throw();
#endif

#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__CRTDECL operator new(size_t, void *_Where)
        {return (_Where); }
#if     _MSC_VER >= 1200
inline void __CRTDECL operator delete(void *, void *)
        {return; }
#endif
#endif


/*
 * new mode flag -- when set, makes malloc() behave like new()
 */

_CRTIMP int __cdecl _query_new_mode( void );
_CRTIMP int __cdecl _set_new_mode( int );

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

_CRTIMP _PNH __cdecl _query_new_handler( void );
_CRTIMP _PNH __cdecl _set_new_handler( __in_opt _PNH _NewHandler);

#pragma pop_macro("new")

#endif  /* __cplusplus */

#endif  /* _INC_NEW */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\nldef.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    nldef.h

Abstract:

    This module contains basic network layer definitions.
    Previously some of these were duplicated in both routprot.h and
    iprtrmib.h.

Author:
@@BEGIN_DDKSPLIT
    Dave Thaler (dthaler) 12-Apr-2001
@@END_DDKSPLIT
Environment:

    user mode or kernel mode

--*/

#ifndef _NLDEF_
#define _NLDEF_
#pragma once

#define NL_MAX_METRIC_COMPONENT ((((ULONG) 1) << 31) - 1)

typedef enum {
    //
    // These values are from iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpPrefixOriginOther = 0,
    IpPrefixOriginManual,
    IpPrefixOriginWellKnown,
    IpPrefixOriginDhcp,
    IpPrefixOriginRouterAdvertisement,
    IpPrefixOriginUnchanged = 1 << 4
} NL_PREFIX_ORIGIN;

//
// TODO: Remove these definitions.
//
#define NlpoOther               IpPrefixOriginOther
#define NlpoManual              IpPrefixOriginManual
#define NlpoWellKnown           IpPrefixOriginWellKnown
#define NlpoDhcp                IpPrefixOriginDhcp
#define NlpoRouterAdvertisement IpPrefixOriginRouterAdvertisement

typedef enum {
    //
    // TODO: Remove the Nlso* definitions.
    //
    NlsoOther = 0,
    NlsoManual,
    NlsoWellKnown,
    NlsoDhcp,
    NlsoLinkLayerAddress,
    NlsoRandom,

    //
    // These values are from in iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual,
    IpSuffixOriginWellKnown,
    IpSuffixOriginDhcp,
    IpSuffixOriginLinkLayerAddress,
    IpSuffixOriginRandom,
    IpSuffixOriginUnchanged = 1 << 4
} NL_SUFFIX_ORIGIN;

typedef enum {
    //
    // TODO: Remove the Nlds* definitions.
    //
    NldsInvalid,
    NldsTentative,
    NldsDuplicate,
    NldsDeprecated,
    NldsPreferred,

    //
    // These values are from in iptypes.h.
    //
    IpDadStateInvalid    = 0,
    IpDadStateTentative,
    IpDadStateDuplicate,
    IpDadStateDeprecated,
    IpDadStatePreferred,
} NL_DAD_STATE;

//
// MIB_IPPROTO_* values were previously in iprtrmib.h.
// PROTO_IP_* values were previously in routprot.h.
//
#define MAKE_ROUTE_PROTOCOL(suffix, value) \
    MIB_IPPROTO_ ## suffix = value, \
    PROTO_IP_ ## suffix    = value

//
// Routing protocol values from RFC.
//
typedef enum {
    //
    // TODO: Remove the RouteProtocol* definitions.
    //
    RouteProtocolOther   = 1,
    RouteProtocolLocal   = 2,
    RouteProtocolNetMgmt = 3,
    RouteProtocolIcmp    = 4,
    RouteProtocolEgp     = 5,
    RouteProtocolGgp     = 6,
    RouteProtocolHello   = 7,
    RouteProtocolRip     = 8,
    RouteProtocolIsIs    = 9,
    RouteProtocolEsIs    = 10,
    RouteProtocolCisco   = 11,
    RouteProtocolBbn     = 12,
    RouteProtocolOspf    = 13,
    RouteProtocolBgp     = 14,

    MAKE_ROUTE_PROTOCOL(OTHER,   1),
    MAKE_ROUTE_PROTOCOL(LOCAL,   2),
    MAKE_ROUTE_PROTOCOL(NETMGMT, 3),
    MAKE_ROUTE_PROTOCOL(ICMP,    4),
    MAKE_ROUTE_PROTOCOL(EGP,     5),
    MAKE_ROUTE_PROTOCOL(GGP,     6),
    MAKE_ROUTE_PROTOCOL(HELLO,   7),
    MAKE_ROUTE_PROTOCOL(RIP,     8),
    MAKE_ROUTE_PROTOCOL(IS_IS,   9),
    MAKE_ROUTE_PROTOCOL(ES_IS,  10),
    MAKE_ROUTE_PROTOCOL(CISCO,  11),
    MAKE_ROUTE_PROTOCOL(BBN,    12),
    MAKE_ROUTE_PROTOCOL(OSPF,   13),
    MAKE_ROUTE_PROTOCOL(BGP,    14),

    //
    // Windows-specific definitions.
    //
    MAKE_ROUTE_PROTOCOL(NT_AUTOSTATIC,     10002),
    MAKE_ROUTE_PROTOCOL(NT_STATIC,         10006),
    MAKE_ROUTE_PROTOCOL(NT_STATIC_NON_DOD, 10007),
} NL_ROUTE_PROTOCOL, *PNL_ROUTE_PROTOCOL;

typedef enum {
    NlatUnspecified,
    NlatUnicast,
    NlatAnycast,
    NlatMulticast,
    NlatBroadcast,
    NlatInvalid
} NL_ADDRESS_TYPE, *PNL_ADDRESS_TYPE;

//
// NL_ROUTE_ORIGIN
//
// Define route origin values.
//

typedef enum _NL_ROUTE_ORIGIN {
    NlroManual,
    NlroWellKnown,
    NlroDHCP,
    NlroRouterAdvertisement,
    Nlro6to4,
} NL_ROUTE_ORIGIN, *PNL_ROUTE_ORIGIN;

//
// NL_NEIGHBOR_STATE
//
// Define network layer neighbor state.  RFC 2461, section 7.3.2 has details.
// Note: Only state names are documented, we chose the values used here.
//

typedef enum _NL_NEIGHBOR_STATE {
    NlnsUnreachable,
    NlnsIncomplete,
    NlnsProbe,
    NlnsDelay,
    NlnsStale,
    NlnsReachable,
    NlnsPermanent,
    NlnsMaximum,
} NL_NEIGHBOR_STATE, *PNL_NEIGHBOR_STATE;

typedef enum _NL_LINK_LOCAL_ADDRESS_BEHAVIOR{
    LinkLocalAlwaysOff = 0,     // Never use link locals.
    LinkLocalDelayed,           // Use link locals only if no other addresses.
                                // (default for IPv4).
                                // Legacy mapping: IPAutoconfigurationEnabled.
    LinkLocalAlwaysOn,          // Always use link locals (default for IPv6).
    LinkLocalUnchanged = -1
} NL_LINK_LOCAL_ADDRESS_BEHAVIOR;

#pragma warning(push)
#pragma warning(disable:4214)

typedef struct _NL_INTERFACE_OFFLOAD_ROD {
    BOOLEAN NlChecksumSupported : 1;
    BOOLEAN NlOptionsSupported : 1;
    BOOLEAN TlDatagramChecksumSupported : 1;
    BOOLEAN TlStreamChecksumSupported : 1;
    BOOLEAN TlStreamOptionsSupported : 1;
    BOOLEAN FastPathCompatible : 1;
    BOOLEAN TlLargeSendOffloadSupported : 1;
    BOOLEAN TlGiantSendOffloadSupported : 1;
} NL_INTERFACE_OFFLOAD_ROD, *PNL_INTERFACE_OFFLOAD_ROD;

#pragma warning(pop)

typedef enum _NL_ROUTER_DISCOVERY_BEHAVIOR {
    RouterDiscoveryDisabled = 0,
    RouterDiscoveryEnabled,
    RouterDiscoveryDhcp,
    RouterDiscoveryUnchanged = -1
} NL_ROUTER_DISCOVERY_BEHAVIOR;

typedef enum _NL_BANDWIDTH_FLAG {
    NlbwDisabled = 0,
    NlbwEnabled,
    NlbwUnchanged = -1
} NL_BANDWIDTH_FLAG, *PNL_BANDWIDTH_FLAG;

typedef struct _NL_PATH_BANDWIDTH_ROD {
    ULONG64 Bandwidth;
    ULONG64 Instability;
    BOOLEAN BandwidthPeaked;
} NL_PATH_BANDWIDTH_ROD, *PNL_PATH_BANDWIDTH_ROD;

#define NET_IF_CURRENT_SESSION ((ULONG)-1)

#endif // _NLDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\netioapi.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

Module Name:

    netioapi.h

Abstract:

    This module contains definitions for version agnostic IP helper APIs.


Environment:

    User mode or kernel mode.

    In user mode this file should be included from iphlpapi.h,
    after including the following headers:

    #include <ws2def.h> 
    #include <ws2ipdef.h>

    In kernel mode the following files should be included.
    
    #include <ntddk.h>

    For all APIs, the caller IRQL should be less than DISPATCH_LEVEL.

Notes:

    Please follow these notes to maintain consistency within this API set,
    as well as across the legacy IP helper API:
    
    1. Express objects and functions in terms of MIB operations if possible.
       E.g. MIB_UNICASTIPADDRESS_ROW structure is associated with the 
       GetUnicastIpAddress() function.

    2. Use the NETIO/RTL coding convention for naming structures and functions.
       When modifying a structure with a legacy IP helper API counterpart,
       try to maintain the same name (without abbreviations).
       The hungarian convention must not be used and, for structure fields,
       the structure name need not prefix the field.

    3. For versioning a new structure or API,
       append a version number to the constructs.

    4. The functions in this file are grouped by the object they operate upon.
       Within the group, they are sorted alphabetically.

--*/

#ifndef _NETIOAPI_H_
#define _NETIOAPI_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// General types.
//

//
// Nameless structure/union.
//
#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214)

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

#ifdef __IPHLPAPI_H__

//
// User Mode.  This file should be included from iphlpapi.h
// User should include ws2ipdef.h to use these APIs.
//

#define NETIO_STATUS DWORD
#define NETIO_SUCCESS(x) ((x) == NO_ERROR)
#define NETIOAPI_API_ WINAPI

#else

//
// Kernel Mode.
//

#include <ws2def.h>
#include <ws2ipdef.h>
#include <ifdef.h>
#include <nldef.h>

#define NETIO_STATUS NTSTATUS
#define NETIO_SUCCESS(x) NT_SUCCESS(x)
#define NETIOAPI_API_ NTAPI

#endif

#define NETIOAPI_API NETIO_STATUS NETIOAPI_API_

typedef enum _MIB_NOTIFICATION_TYPE {
    //
    // ParameterChange.
    //
    MibParameterNotification,
    //
    // Addition.
    //
    MibAddInstance,
    //
    // Deletion.
    //
    MibDeleteInstance,
    //
    // Initial notification.
    // 
    MibInitialNotification,
} MIB_NOTIFICATION_TYPE, *PMIB_NOTIFICATION_TYPE;

//
// Interface management routines.
//

//
// The MIB structure for Interface management routines.
//

#ifdef _WS2IPDEF_ 
#include <ntddndis.h>

typedef struct _MIB_IF_ROW2 {
    //
    // Key structure.  Sorted by preference.
    //
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex; 

    //
    // Read-Only fields.
    //
    GUID InterfaceGuid;
    WCHAR Alias[IF_MAX_STRING_SIZE + 1]; 
    WCHAR Description[IF_MAX_STRING_SIZE + 1];
    ULONG PhysicalAddressLength;
    UCHAR PhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];
    UCHAR PermanentPhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];    

    ULONG Mtu;
    IFTYPE Type;                // Interface Type.
    TUNNEL_TYPE TunnelType;     // Tunnel Type, if Type = IF_TUNNEL.
    NDIS_MEDIUM MediaType; 
    NDIS_PHYSICAL_MEDIUM PhysicalMediumType; 
    NET_IF_ACCESS_TYPE AccessType;
    NET_IF_DIRECTION_TYPE DirectionType;
    struct {
        BOOLEAN HardwareInterface : 1;
        BOOLEAN FilterInterface : 1;
        BOOLEAN ConnectorPresent : 1;
        BOOLEAN NotAuthenticated : 1;
        BOOLEAN NotMediaConnected : 1;
        BOOLEAN Paused : 1;
        BOOLEAN LowPower : 1;
        BOOLEAN EndPointInterface : 1;
    } InterfaceAndOperStatusFlags;
    
    IF_OPER_STATUS OperStatus;  
    NET_IF_ADMIN_STATUS AdminStatus;
    NET_IF_MEDIA_CONNECT_STATE MediaConnectState;
    NET_IF_NETWORK_GUID NetworkGuid;
    NET_IF_CONNECTION_TYPE ConnectionType; 

    //
    // Statistics.
    //
    ULONG64 TransmitLinkSpeed;
    ULONG64 ReceiveLinkSpeed;

    ULONG64 InOctets;
    ULONG64 InUcastPkts;
    ULONG64 InNUcastPkts;
    ULONG64 InDiscards;
    ULONG64 InErrors;
    ULONG64 InUnknownProtos;
    ULONG64 InUcastOctets;      
    ULONG64 InMulticastOctets;  
    ULONG64 InBroadcastOctets; 
    ULONG64 OutOctets;
    ULONG64 OutUcastPkts;
    ULONG64 OutNUcastPkts;
    ULONG64 OutDiscards;
    ULONG64 OutErrors;
    ULONG64 OutUcastOctets;     
    ULONG64 OutMulticastOctets; 
    ULONG64 OutBroadcastOctets;   
    ULONG64 OutQLen; 
} MIB_IF_ROW2, *PMIB_IF_ROW2;

typedef struct _MIB_IF_TABLE2 {
    ULONG NumEntries;
    MIB_IF_ROW2 Table[ANY_SIZE];
} MIB_IF_TABLE2, *PMIB_IF_TABLE2;

NETIOAPI_API
GetIfEntry2(
    IN OUT PMIB_IF_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified interface on the local computer. 

Arguments:

    Row - Supplies a MIB_IF_ROW2 structure with either the Luid or Index
        initialized to that of the interface for which to retrieve 
        information.      
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1.  At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetIfTable2(
    OUT PMIB_IF_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the MIB-II interface table. 

Arguments:

    Table - Returns the table of interfaces in a MIB_IFTABLE2 structure.
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

typedef enum _MIB_IF_TABLE_LEVEL {
    MibIfTableNormal,
    MibIfTableRaw
} MIB_IF_TABLE_LEVEL, *PMIB_IF_TABLE_LEVEL;

NETIOAPI_API
GetIfTable2Ex(
    IN MIB_IF_TABLE_LEVEL Level,
    OUT PMIB_IF_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the MIB-II interface table. 

Arguments:

    Table - Returns the table of interfaces in a MIB_IFTABLE2 structure.
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

//
// IpInterface management routines.
//

//
// The MIB structure for Network layer Interface management routines.
//
typedef struct _MIB_IPINTERFACE_ROW {
    //
    // Key Structure;
    //
    ADDRESS_FAMILY Family;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    //
    // Read-Write fields.
    //

    //
    // Fields currently not exposed.
    //
    ULONG MaxReassemblySize;
    ULONG64 InterfaceIdentifier;
    ULONG MinRouterAdvertisementInterval;
    ULONG MaxRouterAdvertisementInterval;

    //
    // Fileds currently exposed.
    //       
    BOOLEAN AdvertisingEnabled;
    BOOLEAN ForwardingEnabled;
    BOOLEAN WeakHostSend;
    BOOLEAN WeakHostReceive;
    BOOLEAN UseAutomaticMetric;
    BOOLEAN UseNeighborUnreachabilityDetection;   
    BOOLEAN ManagedAddressConfigurationSupported;
    BOOLEAN OtherStatefulConfigurationSupported;
    BOOLEAN AdvertiseDefaultRoute;
    
    NL_ROUTER_DISCOVERY_BEHAVIOR RouterDiscoveryBehavior;
    ULONG DadTransmits;         // DupAddrDetectTransmits in RFC 2462.    
    ULONG BaseReachableTime;
    ULONG RetransmitTime;
    ULONG PathMtuDiscoveryTimeout; // Path MTU discovery timeout (in ms).
    
    NL_LINK_LOCAL_ADDRESS_BEHAVIOR LinkLocalAddressBehavior;
    ULONG LinkLocalAddressTimeout; // In ms.
    ULONG ZoneIndices[ScopeLevelCount]; // Zone part of a SCOPE_ID.
    ULONG SitePrefixLength;
    ULONG Metric;
    ULONG NlMtu;    

    //
    // Read Only fields.
    //
    BOOLEAN Connected;
    BOOLEAN SupportsWakeUpPatterns;   
    BOOLEAN SupportsNeighborDiscovery;
    BOOLEAN SupportsRouterDiscovery;
    
    ULONG ReachableTime;

    NL_INTERFACE_OFFLOAD_ROD TransmitOffload;
    NL_INTERFACE_OFFLOAD_ROD ReceiveOffload; 

    //
    // Disables using default route on the interface. This flag
    // can be used by VPN clients to restrict Split tunnelling.
    //
    BOOLEAN DisableDefaultRoutes;
} MIB_IPINTERFACE_ROW, *PMIB_IPINTERFACE_ROW;

typedef struct _MIB_IPINTERFACE_TABLE {
    ULONG NumEntries;
    MIB_IPINTERFACE_ROW Table[ANY_SIZE];
} MIB_IPINTERFACE_TABLE, *PMIB_IPINTERFACE_TABLE;

typedef struct _MIB_IFSTACK_ROW {
    NET_IFINDEX HigherLayerInterfaceIndex;
    NET_IFINDEX LowerLayerInterfaceIndex;
} MIB_IFSTACK_ROW, *PMIB_IFSTACK_ROW;

typedef struct _MIB_INVERTEDIFSTACK_ROW {
    NET_IFINDEX LowerLayerInterfaceIndex;
    NET_IFINDEX HigherLayerInterfaceIndex;
} MIB_INVERTEDIFSTACK_ROW, *PMIB_INVERTEDIFSTACK_ROW;

typedef struct _MIB_IFSTACK_TABLE {
    ULONG NumEntries;
    MIB_IFSTACK_ROW Table[ANY_SIZE];
} MIB_IFSTACK_TABLE, *PMIB_IFSTACK_TABLE;

typedef struct _MIB_INVERTEDIFSTACK_TABLE {
    ULONG NumEntries;
    MIB_INVERTEDIFSTACK_ROW Table[ANY_SIZE];
} MIB_INVERTEDIFSTACK_TABLE, *PMIB_INVERTEDIFSTACK_TABLE;

typedef
VOID
(*PIPINTERFACE_CHANGE_CALLBACK) (
    IN PVOID CallerContext,
    IN PMIB_IPINTERFACE_ROW Row OPTIONAL,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );

NETIOAPI_API
GetIfStackTable(
    OUT PMIB_IFSTACK_TABLE *Table
    );

NETIOAPI_API
GetInvertedIfStackTable(
    OUT PMIB_INVERTEDIFSTACK_TABLE *Table
    );

NETIOAPI_API
GetIpInterfaceEntry(
    IN OUT PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Retrieves IP information for the specified interface on the local computer.
    
Arguments:

    Row - Supplies a MIB_IPINTERFACE_ROW structure with either the Luid or
        Index initialized to that of the interface for which to retrieve 
        information. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. Family: it must be either AF_INET or AF_INET6
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetIpInterfaceTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPINTERFACE_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the network-layer interface table. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 MIB entries.

        AF_INET6: Only returns IPv6 MIB entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 MIB entries.

    Table - Returns the table of interfaces in a MIB_IPINTERFACE_TABLE
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

VOID
NETIOAPI_API_
InitializeIpInterfaceEntry(
    IN OUT PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Initialize the MIB_IPINTERFACE_ROW entry for use in SetIpInterfaceRow.

Arguments:

    Row - Returns an initialized MIB_IPINTERFACE_ROW structure. 

Return Value:

    None. 

Notes:

    InitializeIpInterfaceEntry must be used to initialize the fields of
    MIB_IPINTERFACE_ROW with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpInterfaceEntry.
        
--*/

NETIOAPI_API
NotifyIpInterfaceChange(
    IN ADDRESS_FAMILY Family,
    IN PIPINTERFACE_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for IP interface changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 change notifications.

        AF_INET6: Only register for IPv6 change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 change notifications.

    Callback - Supplies a callback function.  This function will be invoked
        when an interface notification is received.

    CallerContext - Provides the user specific caller context.  This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

NETIOAPI_API
SetIpInterfaceEntry(
    IN OUT PMIB_IPINTERFACE_ROW Row
    );
/*++

Routine Description:

    Set the properties of an IP interface. 

Arguments:

    Row - Supplies a MIB_IPINTERFACE_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpInterfaceEntry must be used to initialize the fields of
    MIB_IPINTERFACE_ROW with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpInterfaceEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpInterfaceEntry:
    1. Family: To AF_INET or AF_INET6.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/


//
// Unicast address management routines.
//

//
// The structure for unicast IP Address management.
//
typedef struct _MIB_UNICASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    // 
    // Read-Write Fileds.
    //
    NL_PREFIX_ORIGIN PrefixOrigin;
    NL_SUFFIX_ORIGIN SuffixOrigin;    
    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    UINT8 OnLinkPrefixLength;
    BOOLEAN SkipAsSource;

    //
    // Read-Only Fields.
    //
    NL_DAD_STATE DadState;
    SCOPE_ID ScopeId;
    LARGE_INTEGER CreationTimeStamp;    
} MIB_UNICASTIPADDRESS_ROW, *PMIB_UNICASTIPADDRESS_ROW;

typedef struct _MIB_UNICASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_UNICASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_UNICASTIPADDRESS_TABLE, *PMIB_UNICASTIPADDRESS_TABLE;

typedef
VOID
(*PUNICAST_IPADDRESS_CHANGE_CALLBACK) (
    IN PVOID CallerContext,
    IN PMIB_UNICASTIPADDRESS_ROW Row OPTIONAL,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );
    
NETIOAPI_API
CreateUnicastIpAddressEntry(
    IN CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Create a unicast IP address entry on the local computer. 

Arguments:

    Row - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke CreateIpInterfaceEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeUnicastIpAddressEntry:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

NETIOAPI_API
DeleteUnicastIpAddressEntry(
    IN CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Delete a unicast IP address entry on the local computer. 

Arguments:

    Row - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

NETIOAPI_API
GetUnicastIpAddressEntry(
    IN OUT PMIB_UNICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified unicast IP address entry on the 
        local computer. 

Arguments:

    Address - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetUnicastIpAddressTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_UNICASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the unicast IP address table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 unicast addresses.

        AF_INET6: Only returns IPv6 unicast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 unicast addresses.

    Table - Returns the table of unicast IP addresses in a
        MIB_UNICASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

VOID
NETIOAPI_API_
InitializeUnicastIpAddressEntry(
    OUT PMIB_UNICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Initialize the MIB_UNICASTIPADDRESS_ROW entry for use in 
    CreateUnicastIpAddressEntry and SetUnicastIpAddressEntry.

Arguments:

    Address - Returns an initialized MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    None. 

Notes:

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke CreateUnicastIpAddressEntry or
    SetUnicastIpAddressEntry.
        
--*/


NETIOAPI_API
NotifyUnicastIpAddressChange(
    IN ADDRESS_FAMILY Family,
    IN PUNICAST_IPADDRESS_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for unicast IP address changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 change notifications.

        AF_INET6: Only register for IPv6 change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 change notifications.

    Callback - Supplies a callback function.  This function will be invoked
        when an unicast IP address notification is received.

    CallerContext - Provides the user specific caller context.  This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

typedef
VOID
(*PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK) (
    IN PVOID CallerContext,
    IN PMIB_UNICASTIPADDRESS_TABLE AddressTable
    );
    
NETIOAPI_API
NotifyStableUnicastIpAddressTable(
    IN ADDRESS_FAMILY Family,
    IN OUT PMIB_UNICASTIPADDRESS_TABLE* Table,
    IN PSTABLE_UNICAST_IPADDRESS_TABLE_CALLBACK CallerCallback,
    IN PVOID CallerContext,
    IN OUT HANDLE *NotificationHandle
    );

NETIOAPI_API
SetUnicastIpAddressEntry(
    IN CONST MIB_UNICASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Set the properties of an unicast IP address. 

Arguments:

    Address - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeUnicastIpAddressEntry must be used to initialize the fields of
    MIB_UNICASTIPADDRESS_ROW with default values.  The caller can then update
    the fields it wishes to modify and invoke SetUnicastIpAddressEntry.

    On input, the following key fields of Row must be initialized after
    invoking InitializeUnicastIpAddressEntry:    
    1. Address to a valid IPv4 or IPv6 unicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.     

--*/

//
// Anycast address management routines.
//

typedef struct _MIB_ANYCASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;

    //
    // Read-Only Fields.
    //
    SCOPE_ID ScopeId;
} MIB_ANYCASTIPADDRESS_ROW, *PMIB_ANYCASTIPADDRESS_ROW; 

typedef struct _MIB_ANYCASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_ANYCASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_ANYCASTIPADDRESS_TABLE, *PMIB_ANYCASTIPADDRESS_TABLE;
    
NETIOAPI_API
CreateAnycastIpAddressEntry(
    IN CONST MIB_ANYCASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Create an anycast IP address entry on the local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

NETIOAPI_API
DeleteAnycastIpAddressEntry(
    IN CONST MIB_ANYCASTIPADDRESS_ROW *Row
    );
/*++

Routine Description:

    Delete an anycast IP address entry on the local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.   

--*/

NETIOAPI_API
GetAnycastIpAddressEntry(
    IN OUT PMIB_ANYCASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified anycast IP address entry on the 
    local computer. 

Arguments:

    Address - Supplies a MIB_ANYCASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. Address to a valid IPv4 or IPv6 anycast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetAnycastIpAddressTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_ANYCASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the anycast IP address table. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 anycast addresses.

        AF_INET6: Only returns IPv6 anycast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 anycast addresses.

    Table - Returns the table of anycast IP addresses in a
        MIB_ANYCASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/


//
// Multicast address management routines.
//
typedef struct _MIB_MULTICASTIPADDRESS_ROW {
    //
    // Key Structure.
    //
    SOCKADDR_INET Address;
    NET_IFINDEX InterfaceIndex;
    NET_LUID InterfaceLuid;

    //
    // Read-Only Fields.
    //
    SCOPE_ID ScopeId;
} MIB_MULTICASTIPADDRESS_ROW, *PMIB_MULTICASTIPADDRESS_ROW;

typedef struct _MIB_MULTICASTIPADDRESS_TABLE {
    ULONG NumEntries;
    MIB_MULTICASTIPADDRESS_ROW Table[ANY_SIZE];
} MIB_MULTICASTIPADDRESS_TABLE, *PMIB_MULTICASTIPADDRESS_TABLE;    

NETIOAPI_API
GetMulticastIpAddressEntry(
    IN OUT PMIB_MULTICASTIPADDRESS_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified mulitcast IP address entry on the 
    local computer. 

Arguments:

    Row - Supplies a MIB_MULTICASTIPADDRESS_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized.
    1. Address to a valid IPv4 or IPv6 multicast address.
    2. At least one of InterfaceLuid or InterfaceIndex must be specified.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetMulticastIpAddressTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_MULTICASTIPADDRESS_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the multicast IP address table on the local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 multicast addresses.

        AF_INET6: Only returns IPv6 multicast addresses.

        AF_UNSPEC: Returns both IPv4 and IPv6 multicast addresses.

    Table - Returns the table of multicast IP addresses in a 
        MIB_MULTICASTIPADDRESS_TABLE Structure.  Use FreeMibTable to free this 
        buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

//
// Route management routines.
//

typedef struct _IP_ADDRESS_PREFIX {
    SOCKADDR_INET Prefix;
    UINT8 PrefixLength;
} IP_ADDRESS_PREFIX, *PIP_ADDRESS_PREFIX;    

typedef struct _MIB_IPFORWARD_ROW2 {
    //
    // Key Structure.
    //
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;
    IP_ADDRESS_PREFIX DestinationPrefix;
    SOCKADDR_INET NextHop;

    //
    // Read-Write Fields.
    //
    UCHAR SitePrefixLength;
    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG Metric;
    NL_ROUTE_PROTOCOL Protocol;
    
    BOOLEAN Loopback;
    BOOLEAN AutoconfigureAddress;
    BOOLEAN Publish;
    BOOLEAN Immortal;

    //
    // Read-Only Fields.
    //
    ULONG Age;
    NL_ROUTE_ORIGIN Origin;
} MIB_IPFORWARD_ROW2, *PMIB_IPFORWARD_ROW2;  

typedef struct _MIB_IPFORWARD_TABLE2 {
    ULONG NumEntries;
    MIB_IPFORWARD_ROW2 Table[ANY_SIZE];
} MIB_IPFORWARD_TABLE2, *PMIB_IPFORWARD_TABLE2;

typedef
VOID
(*PIPFORWARD_CHANGE_CALLBACK) (
    IN PVOID CallerContext,
    IN PMIB_IPFORWARD_ROW2 Row OPTIONAL,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );

NETIOAPI_API
CreateIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Create a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke CreateIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

NETIOAPI_API
DeleteIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Delete a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

NETIOAPI_API
GetBestRoute2(
    IN NET_LUID *InterfaceLuid OPTIONAL,
    IN NET_IFINDEX InterfaceIndex,
    CONST IN SOCKADDR_INET *SourceAddress,
    CONST IN SOCKADDR_INET *DestinationAddress,
    IN ULONG AddressSortOptions,
    OUT PMIB_IPFORWARD_ROW2 BestRoute,
    OUT SOCKADDR_INET *BestSourceAddress
    );
/*++

Routine Description:

    Retrieve the best route between source and destination address on a local
        computer. 

Arguments:

    InterfaceLuid - Supplies Luid to specify an interface.

    InterfaceIndex - Supplies Index to specify an interface.

    SourceAddress - Supplies source address.

    DestinationAddress - Supplies destination address.

    AddressSortOptions - Supplies AddressSortOptions.

    BestRoute - Returns the MIB structure that holds the best route.
    
    BestSourceAddress - Returns the source address of the best route. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following parameters must be supplied:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. SourceAddress.
    3. DestinationAddress.

--*/

NETIOAPI_API
GetIpForwardEntry2(
    IN OUT PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified route entry on the local computer. 

Arguments:

    Route - Supplies a MIB_IPFORWARD_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. DestinationPrefix and NextHop can be specified.

    On output, the remaining fields of Row are filled in.

    If one or more routes matches the specified criteria,
    this API matches the first entry.
    
--*/

NETIOAPI_API
GetIpForwardTable2(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPFORWARD_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the route table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 route entries.

        AF_INET6: Only returns IPv6 route entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 route entries.

    Table - Returns the table of routes in a MIB_IPFORWARD_TABLE2 Structure. 
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

VOID
NETIOAPI_API_
InitializeIpForwardEntry(
    OUT PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Initialize the MIB_IPFORWARD_ROW2 entry for use in SetIpForwardEntry2.

Arguments:

    Row - Returns an initialized PMIB_IPFORWARD_ROW2 structure. 

Return Value:

    None. 

Notes:

    InitializeIpForwardEntry must be used to initialize the fields of 
        MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
        fields it wishes to modify and invoke SetIpForwardEntry2.

--*/

NETIOAPI_API
NotifyRouteChange2(
    IN ADDRESS_FAMILY AddressFamily,
    IN PIPFORWARD_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for route changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 route change notifications.

        AF_INET6: Only register for IPv6 route change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 route change notifications.

    Callback - Supplies a callback function. This function will be invoked when
        an unicast IP address notification is received.

    CallerContext - Provides the user specific caller context. This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

NETIOAPI_API
SetIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Route
    );
/*++

Routine Description:

    Set the properties of a route entry. 

Arguments:

    Route - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.  
    2. DestinationPrefix.
    3. NextHop.

--*/

//
// Path management routines.
//

typedef struct _MIB_IPPATH_ROW {
    //
    // Key.
    //
    
    SOCKADDR_INET Source;    
    SOCKADDR_INET Destination;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;  

    //
    // RO.
    //
    //
    // The current next hop.  This can change over the lifetime of a path. 
    //
    SOCKADDR_INET CurrentNextHop;

    //
    // MTU of path to destination. Includes the IP header length.
    //
    ULONG PathMtu;

    //
    // Estimated mean RTT.
    //
    ULONG RttMean;

    //
    // Mean deviation of RTT.
    //
    ULONG RttDeviation;
    union {
        ULONG LastReachable;    // Milliseconds.
        ULONG LastUnreachable;  // Milliseconds.
    };
    BOOLEAN IsReachable;

    //
    // Estimated speed.
    //
    ULONG64 LinkTransmitSpeed;
    ULONG64 LinkReceiveSpeed;

} MIB_IPPATH_ROW, *PMIB_IPPATH_ROW;

typedef struct _MIB_IPPATH_TABLE {
    ULONG NumEntries;
    MIB_IPPATH_ROW Table[ANY_SIZE];
} MIB_IPPATH_TABLE, *PMIB_IPPATH_TABLE;


NETIOAPI_API
FlushIpPathTable(
    IN ADDRESS_FAMILY Family
    );
/*++

Routine Description:

    Flush the IP Path table on the local computer.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 path table.

        AF_INET6: Only flush the IPv6 path table.

        AF_UNSPEC: Flush both IPv4 and IPv6 path table.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
NETIOAPI_API
GetIpPathEntry(
    IN OUT PMIB_IPPATH_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified path entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPPATH_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Source.
    3. Destination.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetIpPathTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPPATH_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the path table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 paths.

        AF_INET6: Only returns IPv6 paths.

        AF_UNSPEC: Returns both IPv4 and IPv6 paths.

    Table - Returns the table of paths in a MIB_IPPATH_TABLE
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

//
// ARP and IPv6 Neighbor management routines.
//

typedef struct _MIB_IPNET_ROW2 {
    //
    // Key Struture.
    //
    SOCKADDR_INET Address;
    NET_IFINDEX InterfaceIndex;
    NET_LUID InterfaceLuid;

    //
    // Read-Write.
    //
    UCHAR PhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];

    //
    // Read-Only.
    //
    ULONG PhysicalAddressLength;
    NL_NEIGHBOR_STATE State;

    union {
        struct {
            BOOLEAN IsRouter : 1;
            BOOLEAN IsUnreachable : 1;
        };
        UCHAR Flags;
    };

    union {
        ULONG LastReachable;
        ULONG LastUnreachable;
    } ReachabilityTime;
} MIB_IPNET_ROW2, *PMIB_IPNET_ROW2;

typedef struct _MIB_IPNET_TABLE2 {
    ULONG NumEntries;
    MIB_IPNET_ROW2 Table[ANY_SIZE];
} MIB_IPNET_TABLE2, *PMIB_IPNET_TABLE2;

NETIOAPI_API
CreateIpNetEntry2(
    IN CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Create a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.
    3. PhysicalAddress.

--*/

NETIOAPI_API
DeleteIpNetEntry2(
    IN CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Delete a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.

--*/


NETIOAPI_API
FlushIpNetTable2(
    IN ADDRESS_FAMILY Family,
    IN NET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Flush the neighbor entry table on the local computer. 

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 neighbor table.

        AF_INET6: Only flush the IPv6 neighbor table.

        AF_UNSPEC: Flush both IPv4 and IPv6 neighbor table.

    InterfaceIndex - Supplies the Interface index.  If the index is specified,
        flush the neighbor entries on a specific interface, otherwise flush the
        neighbor entries on all the interfaces.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/


NETIOAPI_API
GetIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified neighbor entry on the local
    computer.

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/
    
NETIOAPI_API
GetIpNetTable2(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPNET_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the neighbor table on the local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 neighbor entries.

        AF_INET6: Only returns IPv6 neighbor entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 neighbor entries.

    Table - Returns the table of neighbor entries in a MIB_IPNET_TABLE2
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.
    
--*/    

NETIOAPI_API
ResolveIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row,
    IN CONST SOCKADDR_INET *SourceAddress OPTIONAL
    );
/*++

Routine Description:

    Resolve the physical address of a specific neighbor. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure.

    SourceAddress - Supplies the source address.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    This API flushes any existing neighbor entry and resolves the MAC address
    by sending ARP requests (IPv4) or Neighbor Solicitation (IPv6).
    If source address is not provided, the API will automatically select the
    best interface to send the request on.

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
SetIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Set the physical address of a neighbor entry. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.
    3. PhysicalAddress.     

--*/ 

//
// Teredo APIs.
//
#define MIB_INVALID_TEREDO_PORT_NUMBER 0

typedef
VOID
(*PTEREDO_PORT_CHANGE_CALLBACK) (
    IN PVOID CallerContext,
    IN USHORT Port,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );

NETIOAPI_API
NotifyTeredoPortChange(
    IN PTEREDO_PORT_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );

NETIOAPI_API
GetTeredoPort(
    OUT USHORT *Port
    );
/*++

Routine Description:

    Get the Teredo client port. 

Arguments:

    Port - returns the Teredo port. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure.      

--*/ 


//
// Generic (not IP-specific) interface definitions.
//

NETIOAPI_API
CancelMibChangeNotify2(
    IN HANDLE NotificationHandle
    );
/*++

Routine Description:

    Deregister for change notifications.

Arguments:

    NotificationHandle - Supplies the handle returned from a notification 
        registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    Blocks until all callback have returned.
    
--*/

VOID
NETIOAPI_API_
FreeMibTable(
    IN PVOID Memory
    ); 
/*++

Routine Description:

    Free the buffer allocated by Get*Table APIs.

Arguments:

    Memory - Supplies the buffer to free.

Return Value:

    None.

--*/


NETIOAPI_API
CreateSortedAddressPairs(
    IN const PSOCKADDR_IN6 SourceAddressList OPTIONAL,
    IN ULONG SourceAddressCount,
    IN const PSOCKADDR_IN6 DestinationAddressList,
    IN ULONG DestinationAddressCount,
    IN ULONG AddressSortOptions,
    OUT PSOCKADDR_IN6_PAIR *SortedAddressPairList,
    OUT ULONG *SortedAddressPairCount
    );
/*++

Routine Description:

    Given a list of source and destination addresses, returns a list of
    pairs of addresses in sorted order.  The list is sorted by which address
    pair is best suited for communication between two peers.

    The list of source addresses is optional, in which case the function
    automatically uses all the host machine's local addresses.

Arguments:

    SourceAddressList - Supplies list of potential source addresses.
        If NULL the routine automatically uses all local addresses.
        IPv4 addresses can be specified in IPv4-mapped format.
        Reserved for future use.  Must be NULL.
    
    SourceAddressCount - Supplies the number of addresses in the 
        SourceAddressList.
        Reserved for future use.  Must be 0.        

    DestinationAddressList - Supplies list of potential destination addresses.
        IPv4 addresses can be specified in IPv4-mapped format.

    DestinationAddressCount -  Supplies the number of addresses in the 
        DestinationAddressList.

    AddressSortOptions - Reserved for future use.  Must be 0.

    SortedAddressPairList - Returns a sorted list of pairs of addresses
        in prefered order of communication.  The list must be freed with a
        single call to NetioFreeMemory.

    SortedAddressPairCount - Returns the number of address pairs in
        SortedAddressPairList.

Return Value:

    ERROR_SUCCESS on success.  WIN32 error code on error.

--*/

#endif //_WS2IPDEF_

NETIOAPI_API
ConvertInterfaceNameToLuidA(
    IN CONST CHAR *InterfaceName,
    OUT NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceNameToLuidW(
    IN CONST WCHAR *InterfaceName,
    OUT NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToNameA(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Lenght - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToNameW(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Length - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToIndex(
    IN CONST NET_LUID *InterfaceLuid,
    OUT PNET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Convert an Interface Luid to Index.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface Index.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceIndexToLuid(
    IN NET_IFINDEX InterfaceIndex,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Index to Luid.

Arguments:

    InterfaceName - Supplies the interface Index to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToAlias(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceAlias,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Alias.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceAlias - Returns the interface Alias.

    Length - Supplies the length of InterfaceAlias buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceAliasToLuid(
    IN CONST WCHAR *InterfaceAlias,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Alias to Luid.

Arguments:

    InterfaceAlias - Supplies the null terminated interface Alias.

    InterfaceLuid - Returns the interface Luid. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/


#ifdef UNDER_CE
NETIOAPI_API
ConvertInterfaceDescrToLuid(
    IN CONST WCHAR *InterfaceDescr,
    OUT PNET_LUID InterfaceLuid
    );
#endif


NETIOAPI_API
ConvertInterfaceLuidToGuid(
    IN CONST NET_LUID *InterfaceLuid,
    OUT GUID *InterfaceGuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceGuid - Returns the interface Guid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceGuidToLuid(
    IN CONST GUID *InterfaceGuid,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceGuid - Supplies the interface Guid to be converted.

    InterfaceGuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#define IF_NAMESIZE NDIS_IF_MAX_STRING_SIZE

NET_IFINDEX
NETIOAPI_API_
if_nametoindex(
    __in PCSTR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface name to Index.

Arguments:

    InterfaceName - Supplies the null terminated interface name to convert.

Return Value:

    Interface index on success, 0 otherwise.

--*/
    
PCHAR
NETIOAPI_API_
if_indextoname(
    __in NET_IFINDEX InterfaceIndex,
    __out_ecount(IF_NAMESIZE) PCHAR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface index to Name.

Arguments:

    InterfaceIndex - Supplies the Interface index to convert.

    InterfaceName - Returns the null terminated interface name.

Return Value:

    Interface name on success, NULL otherwise.

Notes:

    The length of InterfaceName buffer must be equal to or greater than 
        IF_NAMESIZE.

--*/

NET_IF_COMPARTMENT_ID
NETIOAPI_API_
GetCurrentThreadCompartmentId(
    VOID
    );
/*++

Routine Description:

    Get the compartment ID of current thread.

Arguments:

    None.

Return Value:

    The compartment ID of current thread.

--*/

NETIOAPI_API
SetCurrentThreadCompartmentId(
    IN NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of current thread.

Arguments:

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 


--*/

NET_IF_COMPARTMENT_ID
NETIOAPI_API_
GetSessionCompartmentId(
    IN ULONG SessionId
    );
/*++

Routine Description:

    Get the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

Return Value:

    The compartment ID of the session.

--*/


NETIOAPI_API
SetSessionCompartmentId(
    IN ULONG SessionId,
    IN NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
GetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __out PNET_IF_COMPARTMENT_ID CompartmentId,
    __out PULONG SiteId,
    __out_ecount(Length) PWCHAR NetworkName,
    __in ULONG Length
    );
/*++

Routine Description:

    Get the network information.

Arguments:

    NetworkGuid - Supplies the Network GUID.

    CompartmentId - Returns the compartment ID.

    SiteId - Returns Site ID.

    NetowrkName - Returns the network name.

    Length - Supplies the length of NetworkName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
NETIOAPI_API
SetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __in NET_IF_COMPARTMENT_ID CompartmentId,
    __in CONST WCHAR *NetworkName
    );
/*++

Routine Description:

    Set the Network Information.

Arguments:

    NetworkGuid - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

    NetworkName - Supplies the Network name to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#pragma warning(pop) 

NETIOAPI_API
ConvertLengthToIpv4Mask(
    IN ULONG MaskLength,
    OUT PULONG Mask
    );
/*++

Routine Description:

    Converts a prefixLength to a subnet mask.

Arguments:

    MaskLength - Prefix Length.

    Mask - Mask generated.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

NETIOAPI_API
ConvertIpv4MaskToLength(
    IN ULONG Mask,
    OUT PUINT8 MaskLength
    );
/*++

Routine Description:

    Converts a subnet mask to a prefix length.

Arguments:

    Mask - Subnet mask to use.

    MaskLength - Prefix length computed.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

//
//4201.
//
#ifdef __cplusplus
}
#endif

#endif // _NETIOAPI_H_.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\netwdm.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//


#pragma once

#include <ntcompat.h>

#define LOOKASIDE_ALIGN

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))



//
// Define types that are not exported.
//

typedef struct _ACCESS_STATE *PACCESS_STATE;
typedef struct _CALLBACK_OBJECT *PCALLBACK_OBJECT;
#if defined(_NTHAL_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _ETHREAD *PETHREAD;
#elif defined(_NTIFS_INCLUDED_)
typedef struct _KPROCESS *PEPROCESS;
typedef struct _KTHREAD *PETHREAD;
#else
typedef struct _EPROCESS *PEPROCESS;
//typedef struct _ETHREAD *PETHREAD;
#endif
typedef struct _IO_TIMER *PIO_TIMER;
//typedef struct _KINTERRUPT *PKINTERRUPT;
typedef struct _KTHREAD *PKTHREAD, *PRKTHREAD;
typedef struct _OBJECT_TYPE *POBJECT_TYPE;
typedef struct _SECURITY_QUALITY_OF_SERVICE *PSECURITY_QUALITY_OF_SERVICE;


//
// Declare empty structure definitions so that they may be referenced by
// routines before they are defined
//
typedef struct _CONTEXT *PCONTEXT;
typedef struct _IO_STACK_LOCATION *PIO_STACK_LOCATION;
typedef struct _VPB *PVPB;
typedef struct _FILE_GET_QUOTA_INFORMATION *PFILE_GET_QUOTA_INFORMATION;


//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

// line 4615
//
// ClientId
//
/* lpc.h already defines this!

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID;
typedef CLIENT_ID *PCLIENT_ID;
*/
typedef enum _POOL_TYPE POOL_TYPE;

typedef
PVOID
(*PALLOCATE_FUNCTION) (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    __in PVOID Buffer
    );

typedef struct _LOOKASIDE_LIST_EX *PLOOKASIDE_LIST_EX;

typedef
PVOID
(*PALLOCATE_FUNCTION_EX) (
    __in POOL_TYPE PoolType,
    __in SIZE_T NumberOfBytes,
    __in ULONG Tag,
    __inout PLOOKASIDE_LIST_EX Lookaside
    );

typedef
VOID
(*PFREE_FUNCTION_EX) (
    __in PVOID Buffer,
    __inout PLOOKASIDE_LIST_EX Lookaside
    );


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_


#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY


typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;


#endif // _SLIST_HEADER_



//
// The goal here is to end up with two structure types that are identical except
// for the fact that one (GENERAL_LOOKASIDE) is cache aligned, and the other
// (GENERAL_LOOKASIDE_POOL) is merely naturally aligned.
//
// An anonymous structure element would do the trick except that C++ can't handle
// such complex syntax, so we're stuck with this macro technique.
// 

#define GENERAL_LOOKASIDE_LAYOUT                \
    union {                                     \
        SLIST_HEADER ListHead;                  \
        SINGLE_LIST_ENTRY SingleListHead;       \
    };                                          \
    USHORT Depth;                               \
    USHORT MaximumDepth;                        \
    ULONG TotalAllocates;                       \
    union {                                     \
        ULONG AllocateMisses;                   \
        ULONG AllocateHits;                     \
    };                                          \
                                                \
    ULONG TotalFrees;                           \
    union {                                     \
        ULONG FreeMisses;                       \
        ULONG FreeHits;                         \
    };                                          \
                                                \
    POOL_TYPE Type;                             \
    ULONG Tag;                                  \
    ULONG Size;                                 \
    union {                                     \
        PALLOCATE_FUNCTION_EX AllocateEx;       \
        PALLOCATE_FUNCTION Allocate;            \
    };                                          \
                                                \
    union {                                     \
        PFREE_FUNCTION_EX FreeEx;               \
        PFREE_FUNCTION Free;                    \
    };                                          \
                                                \
    LIST_ENTRY ListEntry;                       \
    ULONG LastTotalAllocates;                   \
    union {                                     \
        ULONG LastAllocateMisses;               \
        ULONG LastAllocateHits;                 \
    };                                          \
    ULONG Future[2];

//
// GENERAL_LOOKASIDE is a cache aligned type, typically shared between
// multiple processors
// 
/*
#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4324) // structure was padded due to __declspec(align())
#endif
*/

typedef struct LOOKASIDE_ALIGN _GENERAL_LOOKASIDE {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;


//
// GENERAL_LOOKASIDE_POOL is the same layout as GENERAL_LOOKASIDE but is
// not cacheblock aligned, for use in cases where access is limited to a
// single processor
// 

typedef struct _GENERAL_LOOKASIDE_POOL {
    GENERAL_LOOKASIDE_LAYOUT
} GENERAL_LOOKASIDE_POOL, *PGENERAL_LOOKASIDE_POOL;


typedef struct _LOOKASIDE_LIST_EX {
    GENERAL_LOOKASIDE_POOL L;
} LOOKASIDE_LIST_EX, *PLOOKASIDE_LIST_EX;


PVOID
FORCEINLINE
ExAllocateFromLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{
    return NULL;
    
}

VOID
FORCEINLINE
ExFreeToLookasideListEx (
    __inout PLOOKASIDE_LIST_EX Lookaside,
    __in PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a LOOKASIDE_LIST_EX structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{
    return;
}


//
// _EX_POOL_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPoolPriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPoolPriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//
// SpecialPool can be specified to bound the allocation at a page end (or
// beginning).  This should only be done on systems being debugged as the
// memory cost is expensive.
//
// N.B.  These values are very carefully chosen so that the pool allocation
//       code can quickly crack the priority request.
//

typedef enum _EX_POOL_PRIORITY {
    LowPoolPriority,
    LowPoolPrioritySpecialPoolOverrun = 8,
    LowPoolPrioritySpecialPoolUnderrun = 9,
    NormalPoolPriority = 16,
    NormalPoolPrioritySpecialPoolOverrun = 24,
    NormalPoolPrioritySpecialPoolUnderrun = 25,
    HighPoolPriority = 32,
    HighPoolPrioritySpecialPoolOverrun = 40,
    HighPoolPrioritySpecialPoolUnderrun = 41

    } EX_POOL_PRIORITY;


//
// Interrupt modes.
//
/*
typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
} KINTERRUPT_MODE;
*/

//  wdm.h
typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;

typedef enum _KINTERRUPT_POLARITY {
    InterruptPolarityUnknown,
    InterruptActiveHigh,
    InterruptActiveLow
} KINTERRUPT_POLARITY, *PKINTERRUPT_POLARITY;



//
// Interrupt message information table entry definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO_ENTRY {

    //
    // Message address - indicates the address the device should use to
    // generate this message signaled interrupt.
    //

    PHYSICAL_ADDRESS MessageAddress;

    //
    // Target processor set - indicates the set of processors that this
    // message in allowed to interrupt.
    //

    KAFFINITY TargetProcessorSet;

    //
    // Interrupt object - holds a pointer to the interrupt object associated
    // with this interrupt message.  This structure is opaque to drivers.
    //

    PKINTERRUPT InterruptObject;

    //
    // Message data - supplies the value that the device should write to the
    // message address in order to generate this interrupt message.
    //

    ULONG MessageData;

    //
    // The remaining fields indicate the system interrupt vector, IRQL,
    // trigger mode, and interrupt polarity associated with this interrupt
    // message.  These first three values are suitable for use in a fully
    // specified connection parameter structure in a call to
    // IoConnectInterruptEx.
    //

    ULONG Vector;
    KIRQL Irql;
    KINTERRUPT_MODE Mode;
    KINTERRUPT_POLARITY Polarity;

} IO_INTERRUPT_MESSAGE_INFO_ENTRY, *PIO_INTERRUPT_MESSAGE_INFO_ENTRY;

//
// Interrupt message information table definition
//

typedef struct _IO_INTERRUPT_MESSAGE_INFO {

    //
    // Unified IRQL - indicates the IRQL that will be used when calling a
    // message service routine associated with any of the interrupt messages
    // in this table.  Such a unified IRQL will only exist in cases where 1) a
    // driver provides a spinlock to IoConnectInterruptEx with the intent of
    // serializing delivery of all of the messages listed in this table or 2)
    // the driver provides a synchronization IRQL, and no spinlock, with the
    // intent of blocking any message service routine associated with this
    // table from directly preempting another one.  If neither of these cases
    // applies, then the different messages in this table are allowed to be
    // delivered in parallel and at different IRQLs.  In this case this field
    // will be set to zero.
    //

    KIRQL UnifiedIrql;

    //
    // Message count - indicates the number of entries contained in this
    // message information table.
    //

    ULONG MessageCount;

    //
    // Message info - lies at the start of a variable size array of
    // information table entries, with the size of the array dictated by the
    // message count associated with this table.  Each entry describes a
    // different interrupt message that has been allocated to this device.
    //

    IO_INTERRUPT_MESSAGE_INFO_ENTRY MessageInfo[1];

} IO_INTERRUPT_MESSAGE_INFO, *PIO_INTERRUPT_MESSAGE_INFO;

typedef enum _WORK_QUEUE_TYPE {
    CriticalWorkQueue,
    DelayedWorkQueue,
    HyperCriticalWorkQueue,
    MaximumWorkQueue
} WORK_QUEUE_TYPE;

NTKERNELAPI
SIZE_T
MmSizeOfMdl (
    __in_bcount_opt (Length) PVOID Base,
    __in SIZE_T Length
    );

#include <io.h>


LARGE_INTEGER
KeQueryPerformanceCounter (
   __out_opt PLARGE_INTEGER PerformanceFrequency
   );


//
// Since the following function will be compiled inline for user code, the
// initialization changes for IA64 will only take effect if the user code
// is recompiled with this new header. For those binaries that are recompiled
// with this new code, it will not have to go through an extra step of header
// initialization on its first push or pop operation. Note that the SLIST code
// will still work perfectly even without the changes in this initialization
// function.
//

__inline
VOID
InitializeSListHead (
    __out PSLIST_HEADER SListHead
    )

{

    //
    // Slist headers must be 16 byte aligned.
    //

    RtlZeroMemory(SListHead, sizeof(SLIST_HEADER));

    return;
}

#define ExInitializeSListHead InitializeSListHead

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    __inout PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    __inout PSLIST_HEADER ListHead,
    __inout PSLIST_ENTRY ListEntry
    );

typedef enum _MEMORY_CACHING_TYPE_ORIG {
    MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG;

typedef enum _MEMORY_CACHING_TYPE {
    MmNonCached = FALSE,
    MmCached = TRUE,
    MmWriteCombined = MmFrameBufferCached,
    MmHardwareCoherentCached,
    MmNonCachedUnordered,       // IA64
    MmUSWCCached,
    MmMaximumCacheType
} MEMORY_CACHING_TYPE;

#define MM_DONT_ZERO_ALLOCATION             0x00000001
#define MM_ALLOCATE_FROM_LOCAL_NODE_ONLY    0x00000002

typedef __inexpressible_readableTo(polymorphism) MDL *PMDLX;


#if 0
NTKERNELAPI
PVOID
MmMapLockedPagesWithReservedMapping (
    __in PVOID MappingAddress,
    __in ULONG PoolTag,
    __in PMDLX MemoryDescriptorList,
    __in MEMORY_CACHING_TYPE CacheType
    );
#endif


NTKERNELAPI
PMDL
MmAllocatePagesForMdlEx (
    __in PHYSICAL_ADDRESS LowAddress,
    __in PHYSICAL_ADDRESS HighAddress,
    __in PHYSICAL_ADDRESS SkipBytes,
    __in SIZE_T TotalBytes,
    __in MEMORY_CACHING_TYPE CacheType,
    __in ULONG Flags
    );

NTKERNELAPI
VOID
MmFreePagesFromMdl (
    __in PMDLX MemoryDescriptorList
    );

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;


//++
// PPFN_NUMBER
// MmGetMdlPfnArray (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlPfnArray routine returns the virtual address of the
//     first element of the array of physical page numbers associated with
//     the MDL.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the virtual address of the first element of the array of
//     physical page numbers associated with the MDL.
//
//--

#define MmGetMdlPfnArray(Mdl) ((PPFN_NUMBER)(Mdl + 1))


//
// Kernel dispatcher object functions
//


typedef KDPC *PRKDPC;

VOID
KeInitializeDpc (
    __out PRKDPC Dpc,
    __in PKDEFERRED_ROUTINE DeferredRoutine,
    __in_opt PVOID DeferredContext
    );


// from ntdef.h
typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;


NTKERNELAPI
VOID
KeInitializeTimerEx (
    __out PKTIMER Timer,
    __in TIMER_TYPE Type
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    ULONG Revision
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl (
    PACL Acl,
    ULONG AclLength,
    ULONG AclRevision
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx (
    PACL Acl,
    ULONG AceRevision,
    ULONG AceFlags,
    ACCESS_MASK AccessMask,
    PSID Sid
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlSetDaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    BOOLEAN DaclPresent,
    PACL Dacl,
    BOOLEAN DaclDefaulted
    );

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    } POOL_TYPE;

//
// GENERAL_LOOKASIDE is a cache aligned type, typically shared between
// multiple processors
// 

typedef struct _NPAGED_LOOKASIDE_LIST 
{
    GENERAL_LOOKASIDE L;
#ifdef UNDER_CE
    CRITICAL_SECTION    Lock;
#else  //  UNDER_CE
    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;
#endif  //  UNDER_CE
} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;



#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    __out PNPAGED_LOOKASIDE_LIST Lookaside,
    __in_opt PALLOCATE_FUNCTION Allocate,
    __in_opt PFREE_FUNCTION Free,
    __in ULONG Flags,
    __in SIZE_T Size,
    __in ULONG Tag,
    __in USHORT Depth
    );
#endif

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    __inout PNPAGED_LOOKASIDE_LIST Lookaside
    );
#endif

__inline
PVOID
ExAllocateFromNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead, (PSLIST_ENTRY)Entry);

#endif

    }

    return;
}

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

#define ERROR_LOG_LIMIT_SIZE (256-16)

//
// This limit, exclusive of IO_ERROR_LOG_MESSAGE_HEADER_LENGTH, also applies
// to IO_ERROR_LOG_MESSAGE_LENGTH
//

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) -    \
                                            sizeof(IO_ERROR_LOG_PACKET) +     \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                          \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

//
// IO_ERROR_LOG_MESSAGE_LENGTH is
// min(PORT_MAXIMUM_MESSAGE_LENGTH, ERROR_LOG_MESSAGE_LIMIT_SIZE)
//

#define IO_ERROR_LOG_MESSAGE_LENGTH                                           \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?           \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                        \
        PORT_MAXIMUM_MESSAGE_LENGTH)
//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -                 \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

#define PORT_MAXIMUM_MESSAGE_LENGTH 256

//
// Key query structures
//

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef struct _KEY_NODE_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable length string
//          Class[1];           // Variable length string not declared
} KEY_NODE_INFORMATION, *PKEY_NODE_INFORMATION;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];           // Variable length
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    MaxKeyInfoClass   // MaxKeyInfoClass shoudl always be teh last enum
} KEY_INFORMATION_CLASS;

//
// Value entry query structures
//

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
//          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

#define ObReferenceObject(Object) ObfReferenceObject(Object)

NTKERNELAPI
LONG_PTR
FASTCALL
ObfReferenceObject(
    __in PVOID Object
    );

FORCEINLINE
VOID
RtlInitEmptyUnicodeString(
    __out PUNICODE_STRING UnicodeString,
    __in_bcount_opt(BufferSize) PWSTR Buffer,
    __in USHORT BufferSize
    )
{
    UnicodeString->Length = 0;
    UnicodeString->MaximumLength = BufferSize;
    UnicodeString->Buffer = Buffer;
}

FORCEINLINE
VOID
RtlInitEmptyAnsiString(
    __inout PANSI_STRING AnsiString,
    __out_ecount(BufferSize) PCHAR Buffer,
    __in USHORT BufferSize
    )
{
    AnsiString->Length = 0;
    AnsiString->MaximumLength = BufferSize;
    AnsiString->Buffer = Buffer;
}

typedef struct _SECURITY_SUBJECT_CONTEXT {
    PACCESS_TOKEN ClientToken;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    PACCESS_TOKEN PrimaryToken;
    PVOID ProcessAuditId;
} SECURITY_SUBJECT_CONTEXT, *PSECURITY_SUBJECT_CONTEXT;


#define ReadTimeStampCounter() __rdtsc()


BOOLEAN
InterlockedBitTestAndSet (
    IN LONG volatile *Base,
    IN LONG Bit
    );


BOOLEAN
InterlockedBitTestAndReset (
    IN LONG volatile *Base,
    IN LONG Bit
    );


LONGLONG
__cdecl
InterlockedExchangeAdd64(
    IN OUT LONGLONG volatile *Addend,
    IN LONGLONG Value);

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;


NTKERNELAPI
BOOLEAN
KeInsertQueueDpc (
    __inout PRKDPC Dpc,
    __in_opt PVOID SystemArgument1,
    __in_opt PVOID SystemArgument2
    );


#define InterlockedIncrementSizeT(a) InterlockedIncrement((LONG *)a)



//
// These must be converted to LUIDs before use.
//

#define SE_MIN_WELL_KNOWN_PRIVILEGE         (2L)
#define SE_CREATE_TOKEN_PRIVILEGE           (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE     (3L)
#define SE_LOCK_MEMORY_PRIVILEGE            (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE         (5L)

#define SE_MACHINE_ACCOUNT_PRIVILEGE        (6L)
#define SE_TCB_PRIVILEGE                    (7L)
#define SE_SECURITY_PRIVILEGE               (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE         (9L)
#define SE_LOAD_DRIVER_PRIVILEGE            (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE         (11L)
#define SE_SYSTEMTIME_PRIVILEGE             (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE    (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE      (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE        (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE       (16L)
#define SE_BACKUP_PRIVILEGE                 (17L)
#define SE_RESTORE_PRIVILEGE                (18L)
#define SE_SHUTDOWN_PRIVILEGE               (19L)
#define SE_DEBUG_PRIVILEGE                  (20L)
#define SE_AUDIT_PRIVILEGE                  (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE     (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE          (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE        (24L)
#define SE_UNDOCK_PRIVILEGE                 (25L)
#define SE_SYNC_AGENT_PRIVILEGE             (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE      (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE          (28L)
#define SE_IMPERSONATE_PRIVILEGE            (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE          (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE                (32L)
#define SE_INC_WORKING_SET_PRIVILEGE        (33L)
#define SE_TIME_ZONE_PRIVILEGE              (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE   (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE         (SE_CREATE_SYMBOLIC_LINK_PRIVILEGE)

#define LOOKASIDE_MINIMUM_BLOCK_SIZE  (RTL_SIZEOF_THROUGH_FIELD (SLIST_ENTRY, Next))


//++
//
// PVOID
// MmGetMdlStartVa (
//     __in PMDL Mdl
//     )
//
// Routine Description:
//
//     The MmGetMdlBaseVa returns the virtual address of the buffer
//     described by the Mdl rounded down to the nearest page.
//
// Arguments:
//
//     Mdl - Pointer to an MDL.
//
// Return Value:
//
//     Returns the returns the starting virtual address of the MDL.
//
//
//--


typedef enum _MM_SYSTEM_SIZE {
    MmSmallSystem,
    MmMediumSystem,
    MmLargeSystem
} MM_SYSTEMSIZE;

#if (NTDDI_VERSION >= NTDDI_WIN2K)
NTKERNELAPI
MM_SYSTEMSIZE
MmQuerySystemSize (
    VOID
    );
#endif


#if (NTDDI_VERSION >= NTDDI_WINXP)
NTKERNELAPI
NTSTATUS
MmIsVerifierEnabled (
    __out PULONG VerifierFlags
    );
#endif


typedef
NTSTATUS
(*PPCI_MSIX_SET_ENTRY) (
    __in PVOID Context,
    __in ULONG TableEntry,  
    __in ULONG MessageNumber
    );

typedef
NTSTATUS
(*PPCI_MSIX_MASKUNMASK_ENTRY) (
    __in PVOID Context,
    __in ULONG TableEntry
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\notify.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:Notify.h

Purpose:Public Header for User Notifications

--*/

#ifndef _NOTIFY_H_
#define _NOTIFY_H_

// @doc NOTIFY

/*
 * Parameters to the CeRunAppAtEvent() API.
 */

#define NOTIFICATION_EVENT_NONE                     0
#define NOTIFICATION_EVENT_TIME_CHANGE              1
#define NOTIFICATION_EVENT_SYNC_END                 2
#define NOTIFICATION_EVENT_ON_AC_POWER              3
#define NOTIFICATION_EVENT_OFF_AC_POWER             4
#define NOTIFICATION_EVENT_NET_CONNECT              5
#define NOTIFICATION_EVENT_NET_DISCONNECT           6
#define NOTIFICATION_EVENT_DEVICE_CHANGE            7
#define NOTIFICATION_EVENT_IR_DISCOVERED            8
#define NOTIFICATION_EVENT_RS232_DETECTED           9
#define NOTIFICATION_EVENT_RESTORE_END             10
#define NOTIFICATION_EVENT_WAKEUP                  11
#define NOTIFICATION_EVENT_TZ_CHANGE               12
#define NOTIFICATION_EVENT_MACHINE_NAME_CHANGE     13
#define NOTIFICATION_EVENT_RNDIS_FN_DETECTED       14
#define NOTIFICATION_EVENT_INTERNET_PROXY_CHANGE   15
#define NOTIFICATION_EVENT_LOW_STORAGE             16
#define NOTIFICATION_EVENT_LOW_MEMORY              17
#define NOTIFICATION_EVENT_LAST                    NOTIFICATION_EVENT_LOW_MEMORY

/*
 * String passed on the command line when an app is run as the result
 * of a call to CeRunAppAtTime().
 */

#define APP_RUN_AT_TIME                      TEXT("AppRunAtTime")

/*
 * Prefix of the command line when the user requests to run the application
 * that "owns" a notification.  It is followed by a space, and the
 * stringized version of the notification handle.
 */

#define APP_RUN_TO_HANDLE_NOTIFICATION  TEXT("AppRunToHandleNotification")

/*
 * Strings passed on the command line when an event occurs that the
 * app has requested via CeRunAppAtEvent.  Note that some of these
 * strings will be used as the command line *prefix*, since the rest
 * of the command line will be used as a parameter.
 */

#define APP_RUN_AFTER_TIME_CHANGE           TEXT("AppRunAfterTimeChange")
#define APP_RUN_AFTER_SYNC                  TEXT("AppRunAfterSync")
#define APP_RUN_AT_AC_POWER_ON              TEXT("AppRunAtAcPowerOn")
#define APP_RUN_AT_AC_POWER_OFF             TEXT("AppRunAtAcPowerOff")
#define APP_RUN_AT_NET_CONNECT              TEXT("AppRunAtNetConnect")
#define APP_RUN_AT_NET_DISCONNECT           TEXT("AppRunAtNetDisconnect")
#define APP_RUN_AT_DEVICE_CHANGE            TEXT("AppRunDeviceChange")
#define APP_RUN_AT_IR_DISCOVERY             TEXT("AppRunAtIrDiscovery")
#define APP_RUN_AT_RS232_DETECT             TEXT("AppRunAtRs232Detect")
#define APP_RUN_AFTER_RESTORE               TEXT("AppRunAfterRestore")
#define APP_RUN_AFTER_WAKEUP                TEXT("AppRunAfterWakeup")
#define APP_RUN_AFTER_TZ_CHANGE             TEXT("AppRunAfterTzChange")
#define APP_RUN_AFTER_MACHINE_NAME_CHANGE   TEXT("AppRunAfterMachineNameChange")
#define APP_RUN_AFTER_EXTENDED_EVENT        TEXT("AppRunAfterExtendedEvent")
#define APP_RUN_AFTER_RNDIS_FN_DETECTED     TEXT("AppRunAfterRndisFnDetected")
#define APP_RUN_AFTER_INTERNET_PROXY_CHANGE TEXT("AppRunAfterInternetProxyChange")
#define APP_RUN_AT_LOW_STORAGE              TEXT("AppRunAtLowStorage")
#define APP_RUN_AFTER_LOW_MEMORY            TEXT("AppRunAfterLowMemory")

/*
 * Strings passed on the end of the command line for the event,
 * NOTIFICATION_EVENT_DEVICE_CHANGE.  The general form will be
 * "/op devicename" for instance "/ADD COM2:"
 */
#define NOTIFY_DEVICE_ADD                   TEXT("/ADD")
#define NOTIFY_DEVICE_REMOVE                TEXT("/REMOVE")

/*
 * @struct CE_USER_NOTIFICATION | User Notification Structure
 *
 * @comm  This structure is passed in to <f CeGetUserNotificationPreferences>.
 * Initial settings are used to populate the dialog.  If the function
 * returns TRUE, the returned settings should be saved, and considered when
 * calling <f CeSetUserNotification>.  Settings for hardware not on the
 * current device will be ignored.
 *
 * It is also used when calling <f CeSetUserNotification>, to describe
 * what should happen when the notification time is reached.  
 */

typedef struct UserNotificationType {
    DWORD ActionFlags;      //@field Action Flags.  Any combination of the
                            // PUN_* flags.  Flags not valid on a given
                            // hardware platform will be ignored.
#define PUN_LED     1       //@flag PUN_LED | LED flag.  Set if the LED should be 
                            // flashed when the notification occurs.
#define PUN_VIBRATE 2       //@flag PUN_VIBRATE | Vibrate flag.  Set if the device should
                            // be vibrated.
#define PUN_DIALOG  4       //@flag PUN_DIALOG | Dialog flag.  Set if a dialog should be
                            // displayed (the app must provide title and text
                            // when calling <f CeSetUserNotification>).
#define PUN_SOUND   8       //@flag PUN_SOUND | Sound flag.  Set if the sound specified
                            // in pwszSound should be played.
#define PUN_REPEAT  16      //@flag PUN_REPEAT | Sound repeat flag.  Set if the sound
                            // specified in pwszSound should be repeated progressively.
#define PUN_PRIVATE 32      //@flag PUN_PRIVATE | Dialog box z-order flag.  Set if the
                            // notification dialog box should come up behind the password.
    TCHAR *pwszDialogTitle; //@field Dialog Title.  Required if PUN_DIALOG is set, ignored
                            // otherwise. Ignored by CeGetUserNotificationPreferences().
    TCHAR *pwszDialogText;  //@field Dialog Text.  Required if PUN_DIALOG is set, ignored
                            // otherwise. Ignored by CeGetUserNotificationPreferences().
    TCHAR *pwszSound;       //@field Sound string as supplied to sndPlaySound.
                            // CeSetUserNotification() ignores it if PUN_SOUND is not set.
    DWORD nMaxSound;        //@field Max Sound string length.  Specifies the
                            // maximum length of the string that can be copied
                            // into the pwszSound buffer by
                            // CeGetUserNotificationPreferences().
                                                        // Should be at least MAX_PATH * sizeof(TCHAR).
                            // Ignored by CeSetUserNotification().
        union {
        DWORD dwReserved;   //@field Reserved.  Must be NULL or a pointer to
                            // platform-defined expansion structure.
                            // The first dword of the structure
                            // indicates the size of the structure.
            void *pExpansion;
        };
} CE_USER_NOTIFICATION, *PCE_USER_NOTIFICATION;

typedef struct UserNotificationTrigger {
        DWORD           dwSize;
        DWORD           dwType;                         //@field dwType Notification type
#define CNT_EVENT               1                       //@flag CNT_EVENT  | System event notification
#define CNT_TIME                2                       //@flag CNT_TIME   | Time-based notification
#define CNT_PERIOD              3                       //@flag CNT_PERIOD | Time-based notification is active for
                                                                        // time period between stStart and stEnd
#define CNT_CLASSICTIME 4                       //@flag CNT_CLASSICTIME | equivalent to using (obsolete)
                                                                        // CeSetUserNotification function - standard command line is
                                                                        // supplied. lpszArguments must be NULL
#define CNT_SYSTEMTIME 8                                //@flag CNT_SYSTEMTIME | Passed time structs are interpreted
                                                        // as system times, instead of local times.
        DWORD           dwEvent;                        //@field dwEvent - type of event if dwType == CNT_EVENT
        TCHAR           *lpszApplication;       //@field lpszApplication - name of application to execute
        TCHAR           *lpszArguments;         //@field lpszArguments   - command line (sans app name)
        SYSTEMTIME      stStartTime;            //@field stStartTime - begin of notification period
        SYSTEMTIME      stEndTime;                      //@field stEndTime   - end of notification period
} CE_NOTIFICATION_TRIGGER, *PCE_NOTIFICATION_TRIGGER;

#define VALID_CENT_TYPE (CNT_EVENT | CNT_TIME | CNT_PERIOD | CNT_CLASSICTIME | CNT_SYSTEMTIME)
#define NOTIFY_TYPE_MASK 0x00000007
#define NOTIFY_GET_TYPE(dwType) \
    ((DWORD)(dwType) & NOTIFY_TYPE_MASK)

//
//      Application name can be prefixed with the following strings to specify different
//      named objects rather than an application. The action varies depending on the prefix.
//  In case of named event, the event gets signaled.
//
#define NAMED_EVENT_PREFIX_TEXT TEXT("\\\\.\\Notifications\\NamedEvents\\")
#define NAMED_EVENT_PREFIX_LEN (sizeof(NAMED_EVENT_PREFIX_TEXT)/sizeof(TCHAR) - 1)

typedef struct UserNotificationInfoHeader {
        HANDLE                                  hNotification;
#define CNS_SIGNALLED   1

        DWORD                                   dwStatus;
        CE_NOTIFICATION_TRIGGER *pcent;
        CE_USER_NOTIFICATION    *pceun;
} CE_NOTIFICATION_INFO_HEADER, *PCE_NOTIFICATION_INFO_HEADER;

/* Declarations of User Notification APIs. */

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

BOOL   CeGetUserNotificationPreferences (HWND hWndParent, PCE_USER_NOTIFICATION lpNotification);

HANDLE CeSetUserNotificationEx          (HANDLE hNotification, CE_NOTIFICATION_TRIGGER *pcnt, CE_USER_NOTIFICATION *pceun);
BOOL   CeClearUserNotification          (HANDLE hNotification);
BOOL   CeGetUserNotification            (HANDLE hNotification, DWORD cBufferSize, LPDWORD pcBytesNeeded, LPBYTE pBuffer);
BOOL   CeGetUserNotificationHandles (HANDLE *rghNotifications, DWORD cHandles, LPDWORD pcHandlesNeeded);

//
//      Obsolete; provided to maintain compatibility only
//
HANDLE CeSetUserNotification (HANDLE hNotification, TCHAR *pwszAppName, SYSTEMTIME *lpTime, PCE_USER_NOTIFICATION lpUserNotification);
BOOL   CeRunAppAtTime (TCHAR *pwszAppName, SYSTEMTIME *lpTime);
BOOL   CeRunAppAtEvent(TCHAR *pwszAppName, LONG lWhichEvent);
BOOL   CeHandleAppNotifications (TCHAR *pwszAppName);

//
//      API set ready event - wait for it before using notifications
//
#define NOTIFICATION_EVENTNAME_API_SET_READY    L"system/events/notify/APIReady"

#ifdef __cplusplus
}
#endif  //__cplusplus

#ifdef WINCEOEM
#include <pnotify.h>
#endif

#endif /* _NOTIFY_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\notftn.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 22 12:15:10 2007
 */
/* Compiler settings for ..\notftn.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __notftn_h__
#define __notftn_h__

/* Forward Declarations */ 

#ifndef __INotificationRunning_FWD_DEFINED__
#define __INotificationRunning_FWD_DEFINED__
typedef interface INotificationRunning INotificationRunning;
#endif 	/* __INotificationRunning_FWD_DEFINED__ */


#ifndef __INotificationProcessMgr0_FWD_DEFINED__
#define __INotificationProcessMgr0_FWD_DEFINED__
typedef interface INotificationProcessMgr0 INotificationProcessMgr0;
#endif 	/* __INotificationProcessMgr0_FWD_DEFINED__ */


/* header files for imported files */
#include "msnotify.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_notftn_0000 */
/* [local] */ 

#include <msnotify.h>             
#ifndef _LPNOTIFICATIONRUNNING_DEFINED
#define _LPNOTIFICATIONRUNNING_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_notftn_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_notftn_0000_v0_0_s_ifspec;

#ifndef __INotificationRunning_INTERFACE_DEFINED__
#define __INotificationRunning_INTERFACE_DEFINED__

/* interface INotificationRunning */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ INotificationRunning __RPC_FAR *LPNOTIFICATIONRUNNING;


EXTERN_C const IID IID_INotificationRunning;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c733e4ad-576e-11d0-b28c-00c04fd7cd22")
    INotificationRunning : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct INotificationRunningVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INotificationRunning __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INotificationRunning __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INotificationRunning __RPC_FAR * This);
        
        END_INTERFACE
    } INotificationRunningVtbl;

    interface INotificationRunning
    {
        CONST_VTBL struct INotificationRunningVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotificationRunning_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotificationRunning_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotificationRunning_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INotificationRunning_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_notftn_0167 */
/* [local] */ 

#endif
#ifndef _LPNOTIFICATIONPROCESSMGR0_DEFINED
#define _LPNOTIFICATIONPROCESSMGR0_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_notftn_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_notftn_0167_v0_0_s_ifspec;

#ifndef __INotificationProcessMgr0_INTERFACE_DEFINED__
#define __INotificationProcessMgr0_INTERFACE_DEFINED__

/* interface INotificationProcessMgr0 */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ INotificationProcessMgr0 __RPC_FAR *LPNOTIFICATIONPROCESSMGR0;

typedef 
enum _tagNOTIFICATIONMGRMODE
    {	NM_DEFAULT_PROCESS	= 0x1,
	NM_DEFAULT_THREAD	= 0x2
    }	_NOTIFICATIONMGRMODE;

typedef DWORD NOTIFICATIONMGRMODE;

typedef 
enum _tagTHROTTLE_ITEMS_FLAGS
    {	TF_DONT_DELIVER_SCHEDULED_ITEMS	= 0x1,
	TF_APPLY_EXCLUDE_RANGE	= 0x2,
	TF_APPLY_UPDATEINTERVAL	= 0x4
    }	_THROTTLE_ITEMS_FLAGS;

typedef DWORD THROTTLE_ITEMS_FLAGS;

typedef struct THROTTLEITEM
    {
    NOTIFICATIONTYPE NotificationType;
    LONG nParallel;
    DWORD dwFlags;
    SYSTEMTIME stBegin;
    SYSTEMTIME stEnd;
    DWORD dwMinItemUpdateInterval;
    }	THROTTLEITEM;

typedef struct THROTTLEITEM __RPC_FAR *PTHROTTLEITEM;


EXTERN_C const IID IID_INotificationProcessMgr0;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c733e4ae-576e-11d0-b28c-00c04fd7cd22")
    INotificationProcessMgr0 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMode( 
            /* [in] */ REFCLSID rClsID,
            /* [in] */ NOTIFICATIONMGRMODE NotificationMgrMode,
            /* [out] */ LPCLSID __RPC_FAR *pClsIDPre,
            /* [in] */ DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterThrottleNotificationType( 
            /* [in] */ ULONG cItems,
            /* [size_is][in] */ PTHROTTLEITEM pThrottleItems,
            /* [out] */ ULONG __RPC_FAR *pcItemsOut,
            /* [out] */ PTHROTTLEITEM __RPC_FAR *ppThrottleItemsOut,
            /* [in] */ DWORD dwMode,
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INotificationProcessMgr0Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            INotificationProcessMgr0 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            INotificationProcessMgr0 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            INotificationProcessMgr0 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMode )( 
            INotificationProcessMgr0 __RPC_FAR * This,
            /* [in] */ REFCLSID rClsID,
            /* [in] */ NOTIFICATIONMGRMODE NotificationMgrMode,
            /* [out] */ LPCLSID __RPC_FAR *pClsIDPre,
            /* [in] */ DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterThrottleNotificationType )( 
            INotificationProcessMgr0 __RPC_FAR * This,
            /* [in] */ ULONG cItems,
            /* [size_is][in] */ PTHROTTLEITEM pThrottleItems,
            /* [out] */ ULONG __RPC_FAR *pcItemsOut,
            /* [out] */ PTHROTTLEITEM __RPC_FAR *ppThrottleItemsOut,
            /* [in] */ DWORD dwMode,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } INotificationProcessMgr0Vtbl;

    interface INotificationProcessMgr0
    {
        CONST_VTBL struct INotificationProcessMgr0Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotificationProcessMgr0_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotificationProcessMgr0_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotificationProcessMgr0_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotificationProcessMgr0_SetMode(This,rClsID,NotificationMgrMode,pClsIDPre,dwReserved)	\
    (This)->lpVtbl -> SetMode(This,rClsID,NotificationMgrMode,pClsIDPre,dwReserved)

#define INotificationProcessMgr0_RegisterThrottleNotificationType(This,cItems,pThrottleItems,pcItemsOut,ppThrottleItemsOut,dwMode,dwReserved)	\
    (This)->lpVtbl -> RegisterThrottleNotificationType(This,cItems,pThrottleItems,pcItemsOut,ppThrottleItemsOut,dwMode,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INotificationProcessMgr0_SetMode_Proxy( 
    INotificationProcessMgr0 __RPC_FAR * This,
    /* [in] */ REFCLSID rClsID,
    /* [in] */ NOTIFICATIONMGRMODE NotificationMgrMode,
    /* [out] */ LPCLSID __RPC_FAR *pClsIDPre,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB INotificationProcessMgr0_SetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INotificationProcessMgr0_RegisterThrottleNotificationType_Proxy( 
    INotificationProcessMgr0 __RPC_FAR * This,
    /* [in] */ ULONG cItems,
    /* [size_is][in] */ PTHROTTLEITEM pThrottleItems,
    /* [out] */ ULONG __RPC_FAR *pcItemsOut,
    /* [out] */ PTHROTTLEITEM __RPC_FAR *ppThrottleItemsOut,
    /* [in] */ DWORD dwMode,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB INotificationProcessMgr0_RegisterThrottleNotificationType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INotificationProcessMgr0_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_notftn_0168 */
/* [local] */ 

#endif
#define DM_SYNCHRONOUS              0x00000010       
#define DM_ONLY_IF_NOT_PENDING      0x00001000       


extern RPC_IF_HANDLE __MIDL_itf_notftn_0168_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_notftn_0168_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\nsplay.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for nsplay.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __nsplay_h__
#define __nsplay_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INSOPlay_FWD_DEFINED__
#define __INSOPlay_FWD_DEFINED__
typedef interface INSOPlay INSOPlay;
#endif 	/* __INSOPlay_FWD_DEFINED__ */


#ifndef __INSPlay_FWD_DEFINED__
#define __INSPlay_FWD_DEFINED__
typedef interface INSPlay INSPlay;
#endif 	/* __INSPlay_FWD_DEFINED__ */


#ifndef __INSPlay1_FWD_DEFINED__
#define __INSPlay1_FWD_DEFINED__
typedef interface INSPlay1 INSPlay1;
#endif 	/* __INSPlay1_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_nsplay_0000_0000 */
/* [local] */ 

typedef /* [public] */ 
enum NSOStateConstants
    {	nsoStopped	= 0,
	nsoPaused	= ( nsoStopped + 1 ) ,
	nsoRunning	= ( nsoPaused + 1 ) 
    } 	NSOStateConstants;

typedef /* [public] */ 
enum NSOControlConstants
    {	nsoNone	= 0,
	nsoSimple	= ( nsoNone + 1 ) ,
	nsoFull	= ( nsoSimple + 1 ) 
    } 	NSOControlConstants;

typedef /* [public] */ 
enum NSODisplayConstants
    {	nsoDefaultSize	= 0,
	nsoHalfSize	= ( nsoDefaultSize + 1 ) ,
	nsoDoubleSize	= ( nsoHalfSize + 1 ) 
    } 	NSODisplayConstants;

typedef /* [public] */ 
enum NSPlayStateConstants
    {	nsStopped	= 0,
	nsPaused	= ( nsStopped + 1 ) ,
	nsPlaying	= ( nsPaused + 1 ) ,
	nsWaiting	= ( nsPlaying + 1 ) 
    } 	NSPlayStateConstants;

typedef /* [public] */ 
enum NSControlConstants
    {	nsNone	= 0,
	nsSimple	= ( nsNone + 1 ) ,
	nsFull	= ( nsSimple + 1 ) 
    } 	NSControlConstants;

typedef /* [public] */ 
enum NSDisplayConstants
    {	nsDefaultSize	= 0,
	nsHalfSize	= ( nsDefaultSize + 1 ) ,
	nsDoubleSize	= ( nsHalfSize + 1 ) 
    } 	NSDisplayConstants;

typedef /* [public] */ 
enum NSProtocolConstants
    {	nsMulticast	= 1,
	nsMulticastPlus	= ( nsMulticast + 1 ) ,
	nsUDP	= ( nsMulticastPlus + 1 ) ,
	nsTCP	= ( nsUDP + 1 ) ,
	nsDistribution	= ( nsTCP + 1 ) ,
	nsHTTP	= ( nsDistribution + 1 ) ,
	nsFile	= ( nsHTTP + 1 ) 
    } 	NSProtocolConstants;

typedef /* [public] */ 
enum NSOpenStateConstants
    {	nsClosed	= 0,
	nsLoadingASX	= ( nsClosed + 1 ) ,
	nsLoadingNSC	= ( nsLoadingASX + 1 ) ,
	nsLocating	= ( nsLoadingNSC + 1 ) ,
	nsConnecting	= ( nsLocating + 1 ) ,
	nsOpening	= ( nsConnecting + 1 ) ,
	nsOpen	= ( nsOpening + 1 ) 
    } 	NSOpenStateConstants;

typedef /* [public] */ 
enum NSWarningTypeConstants
    {	nsNoAudioDevice	= 0,
	nsUnknownStreamFormat	= ( nsNoAudioDevice + 1 ) ,
	nsPlaylistItemFailure	= ( nsUnknownStreamFormat + 1 ) ,
	nsVideoNotRendered	= ( nsPlaylistItemFailure + 1 ) ,
	nsAudioNotRendered	= ( nsVideoNotRendered + 1 ) ,
	nsMissingCodec	= ( nsAudioNotRendered + 1 ) 
    } 	NSWarningTypeConstants;



extern RPC_IF_HANDLE __MIDL_itf_nsplay_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_nsplay_0000_0000_v0_0_s_ifspec;

#ifndef __INSOPlay_INTERFACE_DEFINED__
#define __INSOPlay_INTERFACE_DEFINED__

/* interface INSOPlay */
/* [hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_INSOPlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2179C5D1-EBFF-11cf-B6FD-00AA00B4E220")
    INSOPlay : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceWidth( 
            /* [retval][out] */ long *pWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceHeight( 
            /* [retval][out] */ long *pHeight) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ double *pDuration) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Author( 
            /* [retval][out] */ BSTR *pbstrAuthor) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR *pbstrCopyright) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR *pbstrDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rating( 
            /* [retval][out] */ BSTR *pbstrRating) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Title( 
            /* [retval][out] */ BSTR *pbstrTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceLink( 
            /* [retval][out] */ BSTR *pbstrSourceLink) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MarkerCount( 
            /* [retval][out] */ long *pMarkerCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanScan( 
            /* [retval][out] */ VARIANT_BOOL *pCanScan) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeek( 
            /* [retval][out] */ VARIANT_BOOL *pCanSeek) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeekToMarkers( 
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE *pCreationDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ long *pBandwidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCorrection( 
            /* [retval][out] */ BSTR *pbstrErrorCorrection) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoStart( 
            /* [retval][out] */ VARIANT_BOOL *pAutoStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoStart( 
            /* [in] */ VARIANT_BOOL AutoStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoRewind( 
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoRewind( 
            /* [in] */ VARIANT_BOOL AutoRewind) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_InvokeURLs( 
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InvokeURLs( 
            /* [in] */ VARIANT_BOOL InvokeURLs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableContextMenu( 
            /* [in] */ VARIANT_BOOL EnableContextMenu) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_TransparentAtStart( 
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TransparentAtStart( 
            /* [in] */ VARIANT_BOOL TransparentAtStart) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ClickToPlay( 
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ClickToPlay( 
            /* [in] */ VARIANT_BOOL ClickToPlay) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ double *pCurrentPosition) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ double CurrentPosition) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double *pRate) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double Rate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentMarker( 
            /* [retval][out] */ long *pCurrentMarker) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentMarker( 
            /* [in] */ long CurrentMarker) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayCount( 
            /* [retval][out] */ long *pPlayCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PlayCount( 
            /* [in] */ long PlayCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentState( 
            /* [retval][out] */ long *pCurrentState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplaySize( 
            /* [retval][out] */ long *pDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplaySize( 
            /* [in] */ long DisplaySize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MainWindow( 
            /* [retval][out] */ long *pMainWindow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowScan( 
            /* [retval][out] */ VARIANT_BOOL *pAllowScan) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowScan( 
            /* [in] */ VARIANT_BOOL AllowScan) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendKeyboardEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendKeyboardEvents( 
            /* [in] */ VARIANT_BOOL SendKeyboardEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseClickEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseClickEvents( 
            /* [in] */ VARIANT_BOOL SendMouseClickEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseMoveEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseMoveEvents( 
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendStateChangeEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceivedPackets( 
            /* [retval][out] */ long *pReceivedPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RecoveredPackets( 
            /* [retval][out] */ long *pRecoveredPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LostPackets( 
            /* [retval][out] */ long *pLostPackets) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceptionQuality( 
            /* [retval][out] */ long *pReceptionQuality) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingCount( 
            /* [retval][out] */ long *pBufferingCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ long *pCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ long CursorType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AnimationAtStart( 
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AnimationAtStart( 
            /* [in] */ VARIANT_BOOL AnimationAtStart) = 0;
        
        virtual /* [hidden][propget][id] */ HRESULT STDMETHODCALLTYPE get_AnimationOnStop( 
            /* [retval][out] */ VARIANT_BOOL *pAnimationOnStop) = 0;
        
        virtual /* [hidden][propput][id] */ HRESULT STDMETHODCALLTYPE put_AnimationOnStop( 
            /* [in] */ VARIANT_BOOL AnimationOnStop) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSOPlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSOPlay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSOPlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSOPlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INSOPlay * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INSOPlay * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INSOPlay * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INSOPlay * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            INSOPlay * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            INSOPlay * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            INSOPlay * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            INSOPlay * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanScan )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeek )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeek);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeekToMarkers )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            INSOPlay * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            INSOPlay * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InvokeURLs )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InvokeURLs )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TransparentAtStart )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TransparentAtStart )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClickToPlay )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClickToPlay )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            INSOPlay * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            INSOPlay * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            INSOPlay * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            INSOPlay * This,
            /* [in] */ double CurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            INSOPlay * This,
            /* [retval][out] */ double *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            INSOPlay * This,
            /* [in] */ double Rate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            INSOPlay * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentMarker )( 
            INSOPlay * This,
            /* [in] */ long CurrentMarker);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            INSOPlay * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            INSOPlay * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            INSOPlay * This,
            /* [retval][out] */ long *pCurrentState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplaySize )( 
            INSOPlay * This,
            /* [retval][out] */ long *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplaySize )( 
            INSOPlay * This,
            /* [in] */ long DisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MainWindow )( 
            INSOPlay * This,
            /* [retval][out] */ long *pMainWindow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowScan )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowScan )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendKeyboardEvents )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendKeyboardEvents )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseClickEvents )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseClickEvents )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseMoveEvents )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseMoveEvents )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendStateChangeEvents )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendStateChangeEvents )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL SendStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            INSOPlay * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            INSOPlay * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            INSOPlay * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            INSOPlay * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            INSOPlay * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CursorType )( 
            INSOPlay * This,
            /* [retval][out] */ long *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CursorType )( 
            INSOPlay * This,
            /* [in] */ long CursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationAtStart )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationAtStart )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationOnStop )( 
            INSOPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationOnStop);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationOnStop )( 
            INSOPlay * This,
            /* [in] */ VARIANT_BOOL AnimationOnStop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            INSOPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            INSOPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            INSOPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            INSOPlay * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            INSOPlay * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        END_INTERFACE
    } INSOPlayVtbl;

    interface INSOPlay
    {
        CONST_VTBL struct INSOPlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSOPlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INSOPlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INSOPlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INSOPlay_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INSOPlay_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INSOPlay_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INSOPlay_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INSOPlay_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define INSOPlay_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define INSOPlay_get_Duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,pDuration) ) 

#define INSOPlay_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define INSOPlay_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define INSOPlay_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define INSOPlay_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define INSOPlay_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define INSOPlay_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#define INSOPlay_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define INSOPlay_get_CanScan(This,pCanScan)	\
    ( (This)->lpVtbl -> get_CanScan(This,pCanScan) ) 

#define INSOPlay_get_CanSeek(This,pCanSeek)	\
    ( (This)->lpVtbl -> get_CanSeek(This,pCanSeek) ) 

#define INSOPlay_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    ( (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers) ) 

#define INSOPlay_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define INSOPlay_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define INSOPlay_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define INSOPlay_get_AutoStart(This,pAutoStart)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pAutoStart) ) 

#define INSOPlay_put_AutoStart(This,AutoStart)	\
    ( (This)->lpVtbl -> put_AutoStart(This,AutoStart) ) 

#define INSOPlay_get_AutoRewind(This,pAutoRewind)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind) ) 

#define INSOPlay_put_AutoRewind(This,AutoRewind)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,AutoRewind) ) 

#define INSOPlay_get_InvokeURLs(This,pInvokeURLs)	\
    ( (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs) ) 

#define INSOPlay_put_InvokeURLs(This,InvokeURLs)	\
    ( (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs) ) 

#define INSOPlay_get_EnableContextMenu(This,pEnableContextMenu)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu) ) 

#define INSOPlay_put_EnableContextMenu(This,EnableContextMenu)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu) ) 

#define INSOPlay_get_TransparentAtStart(This,pTransparentAtStart)	\
    ( (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart) ) 

#define INSOPlay_put_TransparentAtStart(This,TransparentAtStart)	\
    ( (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart) ) 

#define INSOPlay_get_ClickToPlay(This,pClickToPlay)	\
    ( (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay) ) 

#define INSOPlay_put_ClickToPlay(This,ClickToPlay)	\
    ( (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay) ) 

#define INSOPlay_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define INSOPlay_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define INSOPlay_get_CurrentPosition(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition) ) 

#define INSOPlay_put_CurrentPosition(This,CurrentPosition)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition) ) 

#define INSOPlay_get_Rate(This,pRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pRate) ) 

#define INSOPlay_put_Rate(This,Rate)	\
    ( (This)->lpVtbl -> put_Rate(This,Rate) ) 

#define INSOPlay_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define INSOPlay_put_CurrentMarker(This,CurrentMarker)	\
    ( (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker) ) 

#define INSOPlay_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define INSOPlay_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define INSOPlay_get_CurrentState(This,pCurrentState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pCurrentState) ) 

#define INSOPlay_get_DisplaySize(This,pDisplaySize)	\
    ( (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize) ) 

#define INSOPlay_put_DisplaySize(This,DisplaySize)	\
    ( (This)->lpVtbl -> put_DisplaySize(This,DisplaySize) ) 

#define INSOPlay_get_MainWindow(This,pMainWindow)	\
    ( (This)->lpVtbl -> get_MainWindow(This,pMainWindow) ) 

#define INSOPlay_get_AllowScan(This,pAllowScan)	\
    ( (This)->lpVtbl -> get_AllowScan(This,pAllowScan) ) 

#define INSOPlay_put_AllowScan(This,AllowScan)	\
    ( (This)->lpVtbl -> put_AllowScan(This,AllowScan) ) 

#define INSOPlay_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    ( (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents) ) 

#define INSOPlay_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    ( (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents) ) 

#define INSOPlay_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    ( (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents) ) 

#define INSOPlay_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    ( (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents) ) 

#define INSOPlay_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    ( (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents) ) 

#define INSOPlay_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    ( (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents) ) 

#define INSOPlay_get_SendStateChangeEvents(This,pSendStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendStateChangeEvents(This,pSendStateChangeEvents) ) 

#define INSOPlay_put_SendStateChangeEvents(This,SendStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendStateChangeEvents(This,SendStateChangeEvents) ) 

#define INSOPlay_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define INSOPlay_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define INSOPlay_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define INSOPlay_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define INSOPlay_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define INSOPlay_get_CursorType(This,pCursorType)	\
    ( (This)->lpVtbl -> get_CursorType(This,pCursorType) ) 

#define INSOPlay_put_CursorType(This,CursorType)	\
    ( (This)->lpVtbl -> put_CursorType(This,CursorType) ) 

#define INSOPlay_get_AnimationAtStart(This,pAnimationAtStart)	\
    ( (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart) ) 

#define INSOPlay_put_AnimationAtStart(This,AnimationAtStart)	\
    ( (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart) ) 

#define INSOPlay_get_AnimationOnStop(This,pAnimationOnStop)	\
    ( (This)->lpVtbl -> get_AnimationOnStop(This,pAnimationOnStop) ) 

#define INSOPlay_put_AnimationOnStop(This,AnimationOnStop)	\
    ( (This)->lpVtbl -> put_AnimationOnStop(This,AnimationOnStop) ) 

#define INSOPlay_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define INSOPlay_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define INSOPlay_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define INSOPlay_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define INSOPlay_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INSOPlay_INTERFACE_DEFINED__ */


#ifndef __INSPlay_INTERFACE_DEFINED__
#define __INSPlay_INTERFACE_DEFINED__

/* interface INSPlay */
/* [hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_INSPlay;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E7C4BE80-7960-11d0-B727-00AA00B4E220")
    INSPlay : public INSOPlay
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR *pbstrChannelName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelDescription( 
            /* [retval][out] */ BSTR *pbstrChannelDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelURL( 
            /* [retval][out] */ BSTR *pbstrChannelURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactAddress( 
            /* [retval][out] */ BSTR *pbstrContactAddress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactPhone( 
            /* [retval][out] */ BSTR *pbstrContactPhone) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactEmail( 
            /* [retval][out] */ BSTR *pbstrContactEmail) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowChangeDisplaySize( 
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowChangeDisplaySize( 
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CodecCount( 
            /* [retval][out] */ long *pCodecCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBroadcast( 
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDurationValid( 
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceProtocol( 
            /* [retval][out] */ long *pSourceProtocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_OpenState( 
            /* [retval][out] */ long *pOpenState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendOpenStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendOpenStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendWarningEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendWarningEvents( 
            /* [in] */ VARIANT_BOOL SendWarningEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendErrorEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendErrorEvents( 
            /* [in] */ VARIANT_BOOL SendErrorEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HasError( 
            /* [retval][out] */ VARIANT_BOOL *pHasError) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR *pbstrErrorDescription) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long *pErrorCode) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayState( 
            /* [retval][out] */ long *pPlayState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SendPlayStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendPlayStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingTime( 
            /* [retval][out] */ double *pBufferingTime) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BufferingTime( 
            /* [in] */ double BufferingTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UseFixedUDPPort( 
            /* [retval][out] */ VARIANT_BOOL *pUseFixedUDPPort) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UseFixedUDPPort( 
            /* [in] */ VARIANT_BOOL UseFixedUDPPort) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FixedUDPPort( 
            /* [retval][out] */ long *pFixedUDPPort) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FixedUDPPort( 
            /* [in] */ long FixedUDPPort) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UseHTTPProxy( 
            /* [retval][out] */ VARIANT_BOOL *pUseHTTPProxy) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UseHTTPProxy( 
            /* [in] */ VARIANT_BOOL UseHTTPProxy) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableAutoProxy( 
            /* [retval][out] */ VARIANT_BOOL *pEnableAutoProxy) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableAutoProxy( 
            /* [in] */ VARIANT_BOOL EnableAutoProxy) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HTTPProxyHost( 
            /* [retval][out] */ BSTR *pbstrHTTPProxyHost) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_HTTPProxyHost( 
            /* [in] */ BSTR bstrHTTPProxyHost) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_HTTPProxyPort( 
            /* [retval][out] */ long *pHTTPProxyPort) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_HTTPProxyPort( 
            /* [in] */ long HTTPProxyPort) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableMulticast( 
            /* [retval][out] */ VARIANT_BOOL *pEnableMulticast) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableMulticast( 
            /* [in] */ VARIANT_BOOL EnableMulticast) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableUDP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableUDP) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableUDP( 
            /* [in] */ VARIANT_BOOL EnableUDP) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableTCP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableTCP) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableTCP( 
            /* [in] */ VARIANT_BOOL EnableTCP) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableHTTP( 
            /* [retval][out] */ VARIANT_BOOL *pEnableHTTP) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableHTTP( 
            /* [in] */ VARIANT_BOOL EnableHTTP) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingProgress( 
            /* [retval][out] */ long *pBufferingProgress) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR *pbstrBaseURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultFrame( 
            /* [retval][out] */ BSTR *pbstrDefaultFrame) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecInstalled( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecDescription( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetCodecURL( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR bstrFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSPlayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSPlay * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSPlay * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSPlay * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INSPlay * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INSPlay * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INSPlay * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INSPlay * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            INSPlay * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            INSPlay * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            INSPlay * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            INSPlay * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanScan )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeek )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeek);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeekToMarkers )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            INSPlay * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            INSPlay * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InvokeURLs )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InvokeURLs )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TransparentAtStart )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TransparentAtStart )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClickToPlay )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClickToPlay )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            INSPlay * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            INSPlay * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            INSPlay * This,
            /* [in] */ double CurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            INSPlay * This,
            /* [retval][out] */ double *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            INSPlay * This,
            /* [in] */ double Rate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            INSPlay * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentMarker )( 
            INSPlay * This,
            /* [in] */ long CurrentMarker);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            INSPlay * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            INSPlay * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            INSPlay * This,
            /* [retval][out] */ long *pCurrentState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplaySize )( 
            INSPlay * This,
            /* [retval][out] */ long *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplaySize )( 
            INSPlay * This,
            /* [in] */ long DisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MainWindow )( 
            INSPlay * This,
            /* [retval][out] */ long *pMainWindow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowScan )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowScan )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendKeyboardEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendKeyboardEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseClickEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseClickEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseMoveEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseMoveEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendStateChangeEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendStateChangeEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            INSPlay * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            INSPlay * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            INSPlay * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            INSPlay * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            INSPlay * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CursorType )( 
            INSPlay * This,
            /* [retval][out] */ long *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CursorType )( 
            INSPlay * This,
            /* [in] */ long CursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationAtStart )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationAtStart )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationOnStop )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationOnStop);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationOnStop )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AnimationOnStop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            INSPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            INSPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            INSPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            INSPlay * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            INSPlay * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrChannelName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelDescription )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrChannelDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelURL )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrChannelURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactAddress )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrContactAddress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactPhone )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrContactPhone);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactEmail )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrContactEmail);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplaySize )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplaySize )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CodecCount )( 
            INSPlay * This,
            /* [retval][out] */ long *pCodecCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBroadcast )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDurationValid )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceProtocol )( 
            INSPlay * This,
            /* [retval][out] */ long *pSourceProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OpenState )( 
            INSPlay * This,
            /* [retval][out] */ long *pOpenState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendOpenStateChangeEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendOpenStateChangeEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendWarningEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendWarningEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendErrorEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendErrorEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasError )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pHasError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrErrorDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            INSPlay * This,
            /* [retval][out] */ long *pErrorCode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayState )( 
            INSPlay * This,
            /* [retval][out] */ long *pPlayState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendPlayStateChangeEvents )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendPlayStateChangeEvents )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingTime )( 
            INSPlay * This,
            /* [retval][out] */ double *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BufferingTime )( 
            INSPlay * This,
            /* [in] */ double BufferingTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseFixedUDPPort )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pUseFixedUDPPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseFixedUDPPort )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL UseFixedUDPPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FixedUDPPort )( 
            INSPlay * This,
            /* [retval][out] */ long *pFixedUDPPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FixedUDPPort )( 
            INSPlay * This,
            /* [in] */ long FixedUDPPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseHTTPProxy )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pUseHTTPProxy);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseHTTPProxy )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL UseHTTPProxy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableAutoProxy )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableAutoProxy);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableAutoProxy )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableAutoProxy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyHost )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrHTTPProxyHost);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyHost )( 
            INSPlay * This,
            /* [in] */ BSTR bstrHTTPProxyHost);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyPort )( 
            INSPlay * This,
            /* [retval][out] */ long *pHTTPProxyPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyPort )( 
            INSPlay * This,
            /* [in] */ long HTTPProxyPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableMulticast )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableMulticast);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableMulticast )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableMulticast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableUDP )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableUDP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableUDP )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableUDP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTCP )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableTCP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTCP )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableTCP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableHTTP )( 
            INSPlay * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableHTTP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableHTTP )( 
            INSPlay * This,
            /* [in] */ VARIANT_BOOL EnableHTTP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingProgress )( 
            INSPlay * This,
            /* [retval][out] */ long *pBufferingProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BaseURL )( 
            INSPlay * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFrame )( 
            INSPlay * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultFrame )( 
            INSPlay * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            INSPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            INSPlay * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecInstalled )( 
            INSPlay * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecDescription )( 
            INSPlay * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecURL )( 
            INSPlay * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            INSPlay * This,
            /* [in] */ BSTR bstrFileName);
        
        END_INTERFACE
    } INSPlayVtbl;

    interface INSPlay
    {
        CONST_VTBL struct INSPlayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSPlay_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INSPlay_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INSPlay_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INSPlay_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INSPlay_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INSPlay_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INSPlay_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INSPlay_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define INSPlay_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define INSPlay_get_Duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,pDuration) ) 

#define INSPlay_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define INSPlay_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define INSPlay_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define INSPlay_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define INSPlay_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define INSPlay_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#define INSPlay_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define INSPlay_get_CanScan(This,pCanScan)	\
    ( (This)->lpVtbl -> get_CanScan(This,pCanScan) ) 

#define INSPlay_get_CanSeek(This,pCanSeek)	\
    ( (This)->lpVtbl -> get_CanSeek(This,pCanSeek) ) 

#define INSPlay_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    ( (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers) ) 

#define INSPlay_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define INSPlay_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define INSPlay_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define INSPlay_get_AutoStart(This,pAutoStart)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pAutoStart) ) 

#define INSPlay_put_AutoStart(This,AutoStart)	\
    ( (This)->lpVtbl -> put_AutoStart(This,AutoStart) ) 

#define INSPlay_get_AutoRewind(This,pAutoRewind)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind) ) 

#define INSPlay_put_AutoRewind(This,AutoRewind)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,AutoRewind) ) 

#define INSPlay_get_InvokeURLs(This,pInvokeURLs)	\
    ( (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs) ) 

#define INSPlay_put_InvokeURLs(This,InvokeURLs)	\
    ( (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs) ) 

#define INSPlay_get_EnableContextMenu(This,pEnableContextMenu)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu) ) 

#define INSPlay_put_EnableContextMenu(This,EnableContextMenu)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu) ) 

#define INSPlay_get_TransparentAtStart(This,pTransparentAtStart)	\
    ( (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart) ) 

#define INSPlay_put_TransparentAtStart(This,TransparentAtStart)	\
    ( (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart) ) 

#define INSPlay_get_ClickToPlay(This,pClickToPlay)	\
    ( (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay) ) 

#define INSPlay_put_ClickToPlay(This,ClickToPlay)	\
    ( (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay) ) 

#define INSPlay_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define INSPlay_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define INSPlay_get_CurrentPosition(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition) ) 

#define INSPlay_put_CurrentPosition(This,CurrentPosition)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition) ) 

#define INSPlay_get_Rate(This,pRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pRate) ) 

#define INSPlay_put_Rate(This,Rate)	\
    ( (This)->lpVtbl -> put_Rate(This,Rate) ) 

#define INSPlay_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define INSPlay_put_CurrentMarker(This,CurrentMarker)	\
    ( (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker) ) 

#define INSPlay_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define INSPlay_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define INSPlay_get_CurrentState(This,pCurrentState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pCurrentState) ) 

#define INSPlay_get_DisplaySize(This,pDisplaySize)	\
    ( (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize) ) 

#define INSPlay_put_DisplaySize(This,DisplaySize)	\
    ( (This)->lpVtbl -> put_DisplaySize(This,DisplaySize) ) 

#define INSPlay_get_MainWindow(This,pMainWindow)	\
    ( (This)->lpVtbl -> get_MainWindow(This,pMainWindow) ) 

#define INSPlay_get_AllowScan(This,pAllowScan)	\
    ( (This)->lpVtbl -> get_AllowScan(This,pAllowScan) ) 

#define INSPlay_put_AllowScan(This,AllowScan)	\
    ( (This)->lpVtbl -> put_AllowScan(This,AllowScan) ) 

#define INSPlay_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    ( (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents) ) 

#define INSPlay_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    ( (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents) ) 

#define INSPlay_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    ( (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents) ) 

#define INSPlay_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    ( (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents) ) 

#define INSPlay_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    ( (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents) ) 

#define INSPlay_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    ( (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents) ) 

#define INSPlay_get_SendStateChangeEvents(This,pSendStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendStateChangeEvents(This,pSendStateChangeEvents) ) 

#define INSPlay_put_SendStateChangeEvents(This,SendStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendStateChangeEvents(This,SendStateChangeEvents) ) 

#define INSPlay_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define INSPlay_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define INSPlay_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define INSPlay_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define INSPlay_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define INSPlay_get_CursorType(This,pCursorType)	\
    ( (This)->lpVtbl -> get_CursorType(This,pCursorType) ) 

#define INSPlay_put_CursorType(This,CursorType)	\
    ( (This)->lpVtbl -> put_CursorType(This,CursorType) ) 

#define INSPlay_get_AnimationAtStart(This,pAnimationAtStart)	\
    ( (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart) ) 

#define INSPlay_put_AnimationAtStart(This,AnimationAtStart)	\
    ( (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart) ) 

#define INSPlay_get_AnimationOnStop(This,pAnimationOnStop)	\
    ( (This)->lpVtbl -> get_AnimationOnStop(This,pAnimationOnStop) ) 

#define INSPlay_put_AnimationOnStop(This,AnimationOnStop)	\
    ( (This)->lpVtbl -> put_AnimationOnStop(This,AnimationOnStop) ) 

#define INSPlay_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define INSPlay_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define INSPlay_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define INSPlay_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define INSPlay_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 


#define INSPlay_get_ChannelName(This,pbstrChannelName)	\
    ( (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName) ) 

#define INSPlay_get_ChannelDescription(This,pbstrChannelDescription)	\
    ( (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription) ) 

#define INSPlay_get_ChannelURL(This,pbstrChannelURL)	\
    ( (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL) ) 

#define INSPlay_get_ContactAddress(This,pbstrContactAddress)	\
    ( (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress) ) 

#define INSPlay_get_ContactPhone(This,pbstrContactPhone)	\
    ( (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone) ) 

#define INSPlay_get_ContactEmail(This,pbstrContactEmail)	\
    ( (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail) ) 

#define INSPlay_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize) ) 

#define INSPlay_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize) ) 

#define INSPlay_get_CodecCount(This,pCodecCount)	\
    ( (This)->lpVtbl -> get_CodecCount(This,pCodecCount) ) 

#define INSPlay_get_IsBroadcast(This,pIsBroadcast)	\
    ( (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast) ) 

#define INSPlay_get_IsDurationValid(This,pIsDurationValid)	\
    ( (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid) ) 

#define INSPlay_get_SourceProtocol(This,pSourceProtocol)	\
    ( (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol) ) 

#define INSPlay_get_OpenState(This,pOpenState)	\
    ( (This)->lpVtbl -> get_OpenState(This,pOpenState) ) 

#define INSPlay_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents) ) 

#define INSPlay_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents) ) 

#define INSPlay_get_SendWarningEvents(This,pSendWarningEvents)	\
    ( (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents) ) 

#define INSPlay_put_SendWarningEvents(This,SendWarningEvents)	\
    ( (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents) ) 

#define INSPlay_get_SendErrorEvents(This,pSendErrorEvents)	\
    ( (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents) ) 

#define INSPlay_put_SendErrorEvents(This,SendErrorEvents)	\
    ( (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents) ) 

#define INSPlay_get_HasError(This,pHasError)	\
    ( (This)->lpVtbl -> get_HasError(This,pHasError) ) 

#define INSPlay_get_ErrorDescription(This,pbstrErrorDescription)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription) ) 

#define INSPlay_get_ErrorCode(This,pErrorCode)	\
    ( (This)->lpVtbl -> get_ErrorCode(This,pErrorCode) ) 

#define INSPlay_get_PlayState(This,pPlayState)	\
    ( (This)->lpVtbl -> get_PlayState(This,pPlayState) ) 

#define INSPlay_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents) ) 

#define INSPlay_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents) ) 

#define INSPlay_get_BufferingTime(This,pBufferingTime)	\
    ( (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime) ) 

#define INSPlay_put_BufferingTime(This,BufferingTime)	\
    ( (This)->lpVtbl -> put_BufferingTime(This,BufferingTime) ) 

#define INSPlay_get_UseFixedUDPPort(This,pUseFixedUDPPort)	\
    ( (This)->lpVtbl -> get_UseFixedUDPPort(This,pUseFixedUDPPort) ) 

#define INSPlay_put_UseFixedUDPPort(This,UseFixedUDPPort)	\
    ( (This)->lpVtbl -> put_UseFixedUDPPort(This,UseFixedUDPPort) ) 

#define INSPlay_get_FixedUDPPort(This,pFixedUDPPort)	\
    ( (This)->lpVtbl -> get_FixedUDPPort(This,pFixedUDPPort) ) 

#define INSPlay_put_FixedUDPPort(This,FixedUDPPort)	\
    ( (This)->lpVtbl -> put_FixedUDPPort(This,FixedUDPPort) ) 

#define INSPlay_get_UseHTTPProxy(This,pUseHTTPProxy)	\
    ( (This)->lpVtbl -> get_UseHTTPProxy(This,pUseHTTPProxy) ) 

#define INSPlay_put_UseHTTPProxy(This,UseHTTPProxy)	\
    ( (This)->lpVtbl -> put_UseHTTPProxy(This,UseHTTPProxy) ) 

#define INSPlay_get_EnableAutoProxy(This,pEnableAutoProxy)	\
    ( (This)->lpVtbl -> get_EnableAutoProxy(This,pEnableAutoProxy) ) 

#define INSPlay_put_EnableAutoProxy(This,EnableAutoProxy)	\
    ( (This)->lpVtbl -> put_EnableAutoProxy(This,EnableAutoProxy) ) 

#define INSPlay_get_HTTPProxyHost(This,pbstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> get_HTTPProxyHost(This,pbstrHTTPProxyHost) ) 

#define INSPlay_put_HTTPProxyHost(This,bstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> put_HTTPProxyHost(This,bstrHTTPProxyHost) ) 

#define INSPlay_get_HTTPProxyPort(This,pHTTPProxyPort)	\
    ( (This)->lpVtbl -> get_HTTPProxyPort(This,pHTTPProxyPort) ) 

#define INSPlay_put_HTTPProxyPort(This,HTTPProxyPort)	\
    ( (This)->lpVtbl -> put_HTTPProxyPort(This,HTTPProxyPort) ) 

#define INSPlay_get_EnableMulticast(This,pEnableMulticast)	\
    ( (This)->lpVtbl -> get_EnableMulticast(This,pEnableMulticast) ) 

#define INSPlay_put_EnableMulticast(This,EnableMulticast)	\
    ( (This)->lpVtbl -> put_EnableMulticast(This,EnableMulticast) ) 

#define INSPlay_get_EnableUDP(This,pEnableUDP)	\
    ( (This)->lpVtbl -> get_EnableUDP(This,pEnableUDP) ) 

#define INSPlay_put_EnableUDP(This,EnableUDP)	\
    ( (This)->lpVtbl -> put_EnableUDP(This,EnableUDP) ) 

#define INSPlay_get_EnableTCP(This,pEnableTCP)	\
    ( (This)->lpVtbl -> get_EnableTCP(This,pEnableTCP) ) 

#define INSPlay_put_EnableTCP(This,EnableTCP)	\
    ( (This)->lpVtbl -> put_EnableTCP(This,EnableTCP) ) 

#define INSPlay_get_EnableHTTP(This,pEnableHTTP)	\
    ( (This)->lpVtbl -> get_EnableHTTP(This,pEnableHTTP) ) 

#define INSPlay_put_EnableHTTP(This,EnableHTTP)	\
    ( (This)->lpVtbl -> put_EnableHTTP(This,EnableHTTP) ) 

#define INSPlay_get_BufferingProgress(This,pBufferingProgress)	\
    ( (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress) ) 

#define INSPlay_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define INSPlay_put_BaseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL) ) 

#define INSPlay_get_DefaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame) ) 

#define INSPlay_put_DefaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame) ) 

#define INSPlay_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define INSPlay_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define INSPlay_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    ( (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled) ) 

#define INSPlay_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    ( (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription) ) 

#define INSPlay_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    ( (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL) ) 

#define INSPlay_Open(This,bstrFileName)	\
    ( (This)->lpVtbl -> Open(This,bstrFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id] */ HRESULT STDMETHODCALLTYPE INSPlay_Cancel_Proxy( 
    INSPlay * This);


void __RPC_STUB INSPlay_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE INSPlay_GetCodecInstalled_Proxy( 
    INSPlay * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);


void __RPC_STUB INSPlay_GetCodecInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE INSPlay_GetCodecDescription_Proxy( 
    INSPlay * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR *pbstrCodecDescription);


void __RPC_STUB INSPlay_GetCodecDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE INSPlay_GetCodecURL_Proxy( 
    INSPlay * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR *pbstrCodecURL);


void __RPC_STUB INSPlay_GetCodecURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE INSPlay_Open_Proxy( 
    INSPlay * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB INSPlay_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSPlay_INTERFACE_DEFINED__ */


#ifndef __INSPlay1_INTERFACE_DEFINED__
#define __INSPlay1_INTERFACE_DEFINED__

/* interface INSPlay1 */
/* [hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_INSPlay1;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("265EC141-AE62-11d1-8500-00A0C91F9CA0")
    INSPlay1 : public INSPlay
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaPlayer( 
            /* [retval][out] */ IDispatch **ppdispatch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSPlay1Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSPlay1 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSPlay1 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSPlay1 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INSPlay1 * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INSPlay1 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INSPlay1 * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INSPlay1 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceWidth )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSourceHeight )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pHeight);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Duration )( 
            INSPlay1 * This,
            /* [retval][out] */ double *pDuration);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Author )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrAuthor);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Copyright )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrCopyright);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rating )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrRating);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Title )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceLink )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrSourceLink);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MarkerCount )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pMarkerCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanScan )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeek )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeek);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CanSeekToMarkers )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pCanSeekToMarkers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CreationDate )( 
            INSPlay1 * This,
            /* [retval][out] */ DATE *pCreationDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Bandwidth )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pBandwidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCorrection )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrErrorCorrection);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoStart )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoStart )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AutoRewind )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AutoRewind )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InvokeURLs )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InvokeURLs )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableContextMenu )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableContextMenu )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TransparentAtStart )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TransparentAtStart )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ClickToPlay )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ClickToPlay )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FileName )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FileName )( 
            INSPlay1 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPosition )( 
            INSPlay1 * This,
            /* [retval][out] */ double *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentPosition )( 
            INSPlay1 * This,
            /* [in] */ double CurrentPosition);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rate )( 
            INSPlay1 * This,
            /* [retval][out] */ double *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Rate )( 
            INSPlay1 * This,
            /* [in] */ double Rate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMarker )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CurrentMarker )( 
            INSPlay1 * This,
            /* [in] */ long CurrentMarker);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayCount )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_PlayCount )( 
            INSPlay1 * This,
            /* [in] */ long PlayCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentState )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pCurrentState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplaySize )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplaySize )( 
            INSPlay1 * This,
            /* [in] */ long DisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MainWindow )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pMainWindow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowScan )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowScan )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendKeyboardEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendKeyboardEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseClickEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseClickEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendMouseMoveEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendMouseMoveEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendStateChangeEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendStateChangeEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceivedPackets )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pReceivedPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecoveredPackets )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pRecoveredPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LostPackets )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pLostPackets);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReceptionQuality )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pReceptionQuality);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingCount )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pBufferingCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CursorType )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_CursorType )( 
            INSPlay1 * This,
            /* [in] */ long CursorType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationAtStart )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationAtStart )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [hidden][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AnimationOnStop )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAnimationOnStop);
        
        /* [hidden][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AnimationOnStop )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AnimationOnStop);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Play )( 
            INSPlay1 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Pause )( 
            INSPlay1 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Stop )( 
            INSPlay1 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerTime )( 
            INSPlay1 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double *pMarkerTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetMarkerName )( 
            INSPlay1 * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR *pbstrMarkerName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelName )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrChannelName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelDescription )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrChannelDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChannelURL )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrChannelURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactAddress )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrContactAddress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactPhone )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrContactPhone);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ContactEmail )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrContactEmail);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowChangeDisplaySize )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowChangeDisplaySize )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CodecCount )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pCodecCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsBroadcast )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pIsBroadcast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsDurationValid )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pIsDurationValid);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SourceProtocol )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pSourceProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_OpenState )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pOpenState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendOpenStateChangeEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendOpenStateChangeEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendWarningEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendWarningEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendErrorEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendErrorEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HasError )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pHasError);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorDescription )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrErrorDescription);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorCode )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pErrorCode);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_PlayState )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pPlayState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SendPlayStateChangeEvents )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SendPlayStateChangeEvents )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingTime )( 
            INSPlay1 * This,
            /* [retval][out] */ double *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BufferingTime )( 
            INSPlay1 * This,
            /* [in] */ double BufferingTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseFixedUDPPort )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pUseFixedUDPPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseFixedUDPPort )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL UseFixedUDPPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FixedUDPPort )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pFixedUDPPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FixedUDPPort )( 
            INSPlay1 * This,
            /* [in] */ long FixedUDPPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseHTTPProxy )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pUseHTTPProxy);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseHTTPProxy )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL UseHTTPProxy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableAutoProxy )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableAutoProxy);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableAutoProxy )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableAutoProxy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyHost )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrHTTPProxyHost);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyHost )( 
            INSPlay1 * This,
            /* [in] */ BSTR bstrHTTPProxyHost);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_HTTPProxyPort )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pHTTPProxyPort);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_HTTPProxyPort )( 
            INSPlay1 * This,
            /* [in] */ long HTTPProxyPort);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableMulticast )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableMulticast);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableMulticast )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableMulticast);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableUDP )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableUDP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableUDP )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableUDP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableTCP )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableTCP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableTCP )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableTCP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableHTTP )( 
            INSPlay1 * This,
            /* [retval][out] */ VARIANT_BOOL *pEnableHTTP);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableHTTP )( 
            INSPlay1 * This,
            /* [in] */ VARIANT_BOOL EnableHTTP);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BufferingProgress )( 
            INSPlay1 * This,
            /* [retval][out] */ long *pBufferingProgress);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BaseURL )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BaseURL )( 
            INSPlay1 * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultFrame )( 
            INSPlay1 * This,
            /* [retval][out] */ BSTR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultFrame )( 
            INSPlay1 * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *AboutBox )( 
            INSPlay1 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            INSPlay1 * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecInstalled )( 
            INSPlay1 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL *pCodecInstalled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecDescription )( 
            INSPlay1 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecDescription);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetCodecURL )( 
            INSPlay1 * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR *pbstrCodecURL);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            INSPlay1 * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPlayer )( 
            INSPlay1 * This,
            /* [retval][out] */ IDispatch **ppdispatch);
        
        END_INTERFACE
    } INSPlay1Vtbl;

    interface INSPlay1
    {
        CONST_VTBL struct INSPlay1Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSPlay1_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INSPlay1_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INSPlay1_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INSPlay1_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INSPlay1_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INSPlay1_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INSPlay1_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INSPlay1_get_ImageSourceWidth(This,pWidth)	\
    ( (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth) ) 

#define INSPlay1_get_ImageSourceHeight(This,pHeight)	\
    ( (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight) ) 

#define INSPlay1_get_Duration(This,pDuration)	\
    ( (This)->lpVtbl -> get_Duration(This,pDuration) ) 

#define INSPlay1_get_Author(This,pbstrAuthor)	\
    ( (This)->lpVtbl -> get_Author(This,pbstrAuthor) ) 

#define INSPlay1_get_Copyright(This,pbstrCopyright)	\
    ( (This)->lpVtbl -> get_Copyright(This,pbstrCopyright) ) 

#define INSPlay1_get_Description(This,pbstrDescription)	\
    ( (This)->lpVtbl -> get_Description(This,pbstrDescription) ) 

#define INSPlay1_get_Rating(This,pbstrRating)	\
    ( (This)->lpVtbl -> get_Rating(This,pbstrRating) ) 

#define INSPlay1_get_Title(This,pbstrTitle)	\
    ( (This)->lpVtbl -> get_Title(This,pbstrTitle) ) 

#define INSPlay1_get_SourceLink(This,pbstrSourceLink)	\
    ( (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink) ) 

#define INSPlay1_get_MarkerCount(This,pMarkerCount)	\
    ( (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount) ) 

#define INSPlay1_get_CanScan(This,pCanScan)	\
    ( (This)->lpVtbl -> get_CanScan(This,pCanScan) ) 

#define INSPlay1_get_CanSeek(This,pCanSeek)	\
    ( (This)->lpVtbl -> get_CanSeek(This,pCanSeek) ) 

#define INSPlay1_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    ( (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers) ) 

#define INSPlay1_get_CreationDate(This,pCreationDate)	\
    ( (This)->lpVtbl -> get_CreationDate(This,pCreationDate) ) 

#define INSPlay1_get_Bandwidth(This,pBandwidth)	\
    ( (This)->lpVtbl -> get_Bandwidth(This,pBandwidth) ) 

#define INSPlay1_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    ( (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection) ) 

#define INSPlay1_get_AutoStart(This,pAutoStart)	\
    ( (This)->lpVtbl -> get_AutoStart(This,pAutoStart) ) 

#define INSPlay1_put_AutoStart(This,AutoStart)	\
    ( (This)->lpVtbl -> put_AutoStart(This,AutoStart) ) 

#define INSPlay1_get_AutoRewind(This,pAutoRewind)	\
    ( (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind) ) 

#define INSPlay1_put_AutoRewind(This,AutoRewind)	\
    ( (This)->lpVtbl -> put_AutoRewind(This,AutoRewind) ) 

#define INSPlay1_get_InvokeURLs(This,pInvokeURLs)	\
    ( (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs) ) 

#define INSPlay1_put_InvokeURLs(This,InvokeURLs)	\
    ( (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs) ) 

#define INSPlay1_get_EnableContextMenu(This,pEnableContextMenu)	\
    ( (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu) ) 

#define INSPlay1_put_EnableContextMenu(This,EnableContextMenu)	\
    ( (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu) ) 

#define INSPlay1_get_TransparentAtStart(This,pTransparentAtStart)	\
    ( (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart) ) 

#define INSPlay1_put_TransparentAtStart(This,TransparentAtStart)	\
    ( (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart) ) 

#define INSPlay1_get_ClickToPlay(This,pClickToPlay)	\
    ( (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay) ) 

#define INSPlay1_put_ClickToPlay(This,ClickToPlay)	\
    ( (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay) ) 

#define INSPlay1_get_FileName(This,pbstrFileName)	\
    ( (This)->lpVtbl -> get_FileName(This,pbstrFileName) ) 

#define INSPlay1_put_FileName(This,bstrFileName)	\
    ( (This)->lpVtbl -> put_FileName(This,bstrFileName) ) 

#define INSPlay1_get_CurrentPosition(This,pCurrentPosition)	\
    ( (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition) ) 

#define INSPlay1_put_CurrentPosition(This,CurrentPosition)	\
    ( (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition) ) 

#define INSPlay1_get_Rate(This,pRate)	\
    ( (This)->lpVtbl -> get_Rate(This,pRate) ) 

#define INSPlay1_put_Rate(This,Rate)	\
    ( (This)->lpVtbl -> put_Rate(This,Rate) ) 

#define INSPlay1_get_CurrentMarker(This,pCurrentMarker)	\
    ( (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker) ) 

#define INSPlay1_put_CurrentMarker(This,CurrentMarker)	\
    ( (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker) ) 

#define INSPlay1_get_PlayCount(This,pPlayCount)	\
    ( (This)->lpVtbl -> get_PlayCount(This,pPlayCount) ) 

#define INSPlay1_put_PlayCount(This,PlayCount)	\
    ( (This)->lpVtbl -> put_PlayCount(This,PlayCount) ) 

#define INSPlay1_get_CurrentState(This,pCurrentState)	\
    ( (This)->lpVtbl -> get_CurrentState(This,pCurrentState) ) 

#define INSPlay1_get_DisplaySize(This,pDisplaySize)	\
    ( (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize) ) 

#define INSPlay1_put_DisplaySize(This,DisplaySize)	\
    ( (This)->lpVtbl -> put_DisplaySize(This,DisplaySize) ) 

#define INSPlay1_get_MainWindow(This,pMainWindow)	\
    ( (This)->lpVtbl -> get_MainWindow(This,pMainWindow) ) 

#define INSPlay1_get_AllowScan(This,pAllowScan)	\
    ( (This)->lpVtbl -> get_AllowScan(This,pAllowScan) ) 

#define INSPlay1_put_AllowScan(This,AllowScan)	\
    ( (This)->lpVtbl -> put_AllowScan(This,AllowScan) ) 

#define INSPlay1_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    ( (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents) ) 

#define INSPlay1_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    ( (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents) ) 

#define INSPlay1_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    ( (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents) ) 

#define INSPlay1_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    ( (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents) ) 

#define INSPlay1_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    ( (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents) ) 

#define INSPlay1_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    ( (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents) ) 

#define INSPlay1_get_SendStateChangeEvents(This,pSendStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendStateChangeEvents(This,pSendStateChangeEvents) ) 

#define INSPlay1_put_SendStateChangeEvents(This,SendStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendStateChangeEvents(This,SendStateChangeEvents) ) 

#define INSPlay1_get_ReceivedPackets(This,pReceivedPackets)	\
    ( (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets) ) 

#define INSPlay1_get_RecoveredPackets(This,pRecoveredPackets)	\
    ( (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets) ) 

#define INSPlay1_get_LostPackets(This,pLostPackets)	\
    ( (This)->lpVtbl -> get_LostPackets(This,pLostPackets) ) 

#define INSPlay1_get_ReceptionQuality(This,pReceptionQuality)	\
    ( (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality) ) 

#define INSPlay1_get_BufferingCount(This,pBufferingCount)	\
    ( (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount) ) 

#define INSPlay1_get_CursorType(This,pCursorType)	\
    ( (This)->lpVtbl -> get_CursorType(This,pCursorType) ) 

#define INSPlay1_put_CursorType(This,CursorType)	\
    ( (This)->lpVtbl -> put_CursorType(This,CursorType) ) 

#define INSPlay1_get_AnimationAtStart(This,pAnimationAtStart)	\
    ( (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart) ) 

#define INSPlay1_put_AnimationAtStart(This,AnimationAtStart)	\
    ( (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart) ) 

#define INSPlay1_get_AnimationOnStop(This,pAnimationOnStop)	\
    ( (This)->lpVtbl -> get_AnimationOnStop(This,pAnimationOnStop) ) 

#define INSPlay1_put_AnimationOnStop(This,AnimationOnStop)	\
    ( (This)->lpVtbl -> put_AnimationOnStop(This,AnimationOnStop) ) 

#define INSPlay1_Play(This)	\
    ( (This)->lpVtbl -> Play(This) ) 

#define INSPlay1_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define INSPlay1_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define INSPlay1_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    ( (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime) ) 

#define INSPlay1_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    ( (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName) ) 


#define INSPlay1_get_ChannelName(This,pbstrChannelName)	\
    ( (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName) ) 

#define INSPlay1_get_ChannelDescription(This,pbstrChannelDescription)	\
    ( (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription) ) 

#define INSPlay1_get_ChannelURL(This,pbstrChannelURL)	\
    ( (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL) ) 

#define INSPlay1_get_ContactAddress(This,pbstrContactAddress)	\
    ( (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress) ) 

#define INSPlay1_get_ContactPhone(This,pbstrContactPhone)	\
    ( (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone) ) 

#define INSPlay1_get_ContactEmail(This,pbstrContactEmail)	\
    ( (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail) ) 

#define INSPlay1_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize) ) 

#define INSPlay1_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    ( (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize) ) 

#define INSPlay1_get_CodecCount(This,pCodecCount)	\
    ( (This)->lpVtbl -> get_CodecCount(This,pCodecCount) ) 

#define INSPlay1_get_IsBroadcast(This,pIsBroadcast)	\
    ( (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast) ) 

#define INSPlay1_get_IsDurationValid(This,pIsDurationValid)	\
    ( (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid) ) 

#define INSPlay1_get_SourceProtocol(This,pSourceProtocol)	\
    ( (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol) ) 

#define INSPlay1_get_OpenState(This,pOpenState)	\
    ( (This)->lpVtbl -> get_OpenState(This,pOpenState) ) 

#define INSPlay1_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents) ) 

#define INSPlay1_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents) ) 

#define INSPlay1_get_SendWarningEvents(This,pSendWarningEvents)	\
    ( (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents) ) 

#define INSPlay1_put_SendWarningEvents(This,SendWarningEvents)	\
    ( (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents) ) 

#define INSPlay1_get_SendErrorEvents(This,pSendErrorEvents)	\
    ( (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents) ) 

#define INSPlay1_put_SendErrorEvents(This,SendErrorEvents)	\
    ( (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents) ) 

#define INSPlay1_get_HasError(This,pHasError)	\
    ( (This)->lpVtbl -> get_HasError(This,pHasError) ) 

#define INSPlay1_get_ErrorDescription(This,pbstrErrorDescription)	\
    ( (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription) ) 

#define INSPlay1_get_ErrorCode(This,pErrorCode)	\
    ( (This)->lpVtbl -> get_ErrorCode(This,pErrorCode) ) 

#define INSPlay1_get_PlayState(This,pPlayState)	\
    ( (This)->lpVtbl -> get_PlayState(This,pPlayState) ) 

#define INSPlay1_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents) ) 

#define INSPlay1_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    ( (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents) ) 

#define INSPlay1_get_BufferingTime(This,pBufferingTime)	\
    ( (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime) ) 

#define INSPlay1_put_BufferingTime(This,BufferingTime)	\
    ( (This)->lpVtbl -> put_BufferingTime(This,BufferingTime) ) 

#define INSPlay1_get_UseFixedUDPPort(This,pUseFixedUDPPort)	\
    ( (This)->lpVtbl -> get_UseFixedUDPPort(This,pUseFixedUDPPort) ) 

#define INSPlay1_put_UseFixedUDPPort(This,UseFixedUDPPort)	\
    ( (This)->lpVtbl -> put_UseFixedUDPPort(This,UseFixedUDPPort) ) 

#define INSPlay1_get_FixedUDPPort(This,pFixedUDPPort)	\
    ( (This)->lpVtbl -> get_FixedUDPPort(This,pFixedUDPPort) ) 

#define INSPlay1_put_FixedUDPPort(This,FixedUDPPort)	\
    ( (This)->lpVtbl -> put_FixedUDPPort(This,FixedUDPPort) ) 

#define INSPlay1_get_UseHTTPProxy(This,pUseHTTPProxy)	\
    ( (This)->lpVtbl -> get_UseHTTPProxy(This,pUseHTTPProxy) ) 

#define INSPlay1_put_UseHTTPProxy(This,UseHTTPProxy)	\
    ( (This)->lpVtbl -> put_UseHTTPProxy(This,UseHTTPProxy) ) 

#define INSPlay1_get_EnableAutoProxy(This,pEnableAutoProxy)	\
    ( (This)->lpVtbl -> get_EnableAutoProxy(This,pEnableAutoProxy) ) 

#define INSPlay1_put_EnableAutoProxy(This,EnableAutoProxy)	\
    ( (This)->lpVtbl -> put_EnableAutoProxy(This,EnableAutoProxy) ) 

#define INSPlay1_get_HTTPProxyHost(This,pbstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> get_HTTPProxyHost(This,pbstrHTTPProxyHost) ) 

#define INSPlay1_put_HTTPProxyHost(This,bstrHTTPProxyHost)	\
    ( (This)->lpVtbl -> put_HTTPProxyHost(This,bstrHTTPProxyHost) ) 

#define INSPlay1_get_HTTPProxyPort(This,pHTTPProxyPort)	\
    ( (This)->lpVtbl -> get_HTTPProxyPort(This,pHTTPProxyPort) ) 

#define INSPlay1_put_HTTPProxyPort(This,HTTPProxyPort)	\
    ( (This)->lpVtbl -> put_HTTPProxyPort(This,HTTPProxyPort) ) 

#define INSPlay1_get_EnableMulticast(This,pEnableMulticast)	\
    ( (This)->lpVtbl -> get_EnableMulticast(This,pEnableMulticast) ) 

#define INSPlay1_put_EnableMulticast(This,EnableMulticast)	\
    ( (This)->lpVtbl -> put_EnableMulticast(This,EnableMulticast) ) 

#define INSPlay1_get_EnableUDP(This,pEnableUDP)	\
    ( (This)->lpVtbl -> get_EnableUDP(This,pEnableUDP) ) 

#define INSPlay1_put_EnableUDP(This,EnableUDP)	\
    ( (This)->lpVtbl -> put_EnableUDP(This,EnableUDP) ) 

#define INSPlay1_get_EnableTCP(This,pEnableTCP)	\
    ( (This)->lpVtbl -> get_EnableTCP(This,pEnableTCP) ) 

#define INSPlay1_put_EnableTCP(This,EnableTCP)	\
    ( (This)->lpVtbl -> put_EnableTCP(This,EnableTCP) ) 

#define INSPlay1_get_EnableHTTP(This,pEnableHTTP)	\
    ( (This)->lpVtbl -> get_EnableHTTP(This,pEnableHTTP) ) 

#define INSPlay1_put_EnableHTTP(This,EnableHTTP)	\
    ( (This)->lpVtbl -> put_EnableHTTP(This,EnableHTTP) ) 

#define INSPlay1_get_BufferingProgress(This,pBufferingProgress)	\
    ( (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress) ) 

#define INSPlay1_get_BaseURL(This,pbstrBaseURL)	\
    ( (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL) ) 

#define INSPlay1_put_BaseURL(This,bstrBaseURL)	\
    ( (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL) ) 

#define INSPlay1_get_DefaultFrame(This,pbstrDefaultFrame)	\
    ( (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame) ) 

#define INSPlay1_put_DefaultFrame(This,bstrDefaultFrame)	\
    ( (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame) ) 

#define INSPlay1_AboutBox(This)	\
    ( (This)->lpVtbl -> AboutBox(This) ) 

#define INSPlay1_Cancel(This)	\
    ( (This)->lpVtbl -> Cancel(This) ) 

#define INSPlay1_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    ( (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled) ) 

#define INSPlay1_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    ( (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription) ) 

#define INSPlay1_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    ( (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL) ) 

#define INSPlay1_Open(This,bstrFileName)	\
    ( (This)->lpVtbl -> Open(This,bstrFileName) ) 


#define INSPlay1_get_MediaPlayer(This,ppdispatch)	\
    ( (This)->lpVtbl -> get_MediaPlayer(This,ppdispatch) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE INSPlay1_get_MediaPlayer_Proxy( 
    INSPlay1 * This,
    /* [retval][out] */ IDispatch **ppdispatch);


void __RPC_STUB INSPlay1_get_MediaPlayer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSPlay1_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\nserror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft
// premium shared source license agreement under which you licensed
// this source code. If you did not accept the terms of the license
// agreement, you are not authorized to use this source code.
// For the terms of the license, please see the license agreement
// signed by you and Microsoft.
// THE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation, 1999 - 2001.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for NetShow events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events - NOT NECESSARY ON WINDOWS CE

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors - NOT NECESSARY ON WINDOWS CE


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup - NOT NECESSARY ON WINDOWS CE

 12000 - 12999 = Windows Media Networking

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
// The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 0x000D0000L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
// There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                0xC00D0005L

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               0xC00D0006L

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
// Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          0xC00D0007L

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
// Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           0xC00D0008L

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
// Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           0xC00D0009L

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
// Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            0xC00D000AL

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
// There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          0xC00D000BL

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
// There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    0xC00D000CL

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
// Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                0xC00D000DL

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.%0
//
#define NS_E_NETWORK_BUSY                0xC00D000EL

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
// The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               0xC00D000FL

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
// The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           0xC00D0010L

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
// Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               0xC00D0011L

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
// There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           0xC00D0012L

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
// The server, a computer setup to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define NS_E_TIMEOUT                     0xC00D0013L

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
// Error writing to the network.%0
//
#define NS_E_NET_WRITE                   0xC00D0014L

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
// Error reading from the network.%0
//
#define NS_E_NET_READ                    0xC00D0015L

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
// Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  0xC00D0016L

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
// Error reading from a disk.%0
//
#define NS_E_DISK_READ                   0xC00D0017L

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
// Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  0xC00D0018L

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
// Error reading from a file.%0
//
#define NS_E_FILE_READ                   0xC00D0019L

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              0xC00D001AL

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
// The file already exists.%0
//
#define NS_E_FILE_EXISTS                 0xC00D001BL

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
// The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                0xC00D001CL

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
// Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            0xC00D001DL

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
// Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      0xC00D001EL

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
// Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            0xC00D001FL

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
// Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            0xC00D0020L

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
// Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         0xC00D0021L

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
// An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     0xC00D0022L

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
// Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 0xC00D0023L

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
// An unknown error occurred.%0
//
#define NS_E_INTERNAL                    0xC00D0024L

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
// The requested resource is in use.%0
//
#define NS_E_BUSY                        0xC00D0025L

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
// The specified stream type is not recognized.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    0xC00D0026L

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
// The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     0xC00D0027L

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    0xC00D0028L

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
// The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          0xC00D0029L

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
// The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    0xC00D002AL

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
// The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             0xC00D002BL

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
// There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      0xC00D002CL

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
// The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              0xC00D002DL

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
// An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              0xC00D002EL

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
// Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                0xC00D002FL

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
// The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        0xC00D0030L

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
// The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             0xC00D0031L

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
// The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            0xC00D0032L

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
// There is no stream available.%0
//
#define NS_E_NO_STREAM                   0xC00D0033L

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
// There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  0xC00D0034L

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
// The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            0xC00D0035L

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
// The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              0xC00D0036L

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
// The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           0xC00D0037L

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
// The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       0xC00D0038L

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
// The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         0xC00D0039L

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
// The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           0xC00D003AL

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
// The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             0xC00D003BL

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
// The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              0xC00D003CL

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
// The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             0xC00D003DL

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
// The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    0xC00D003EL

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
// The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              0xC00D003FL

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
// The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   0xC00D0040L

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
// The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         0xC00D0041L

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
// The specified key is not valid.
//
#define NS_E_INVALID_KEY                 0xC00D0042L

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
// The specified port is not valid.
//
#define NS_E_INVALID_PORT                0xC00D0043L

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
// The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 0xC00D0044L

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
// The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              0xC00D0045L

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
// The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  0xC00D0050L


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               0xC00D07F1L

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
// Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                0xC00D07F2L


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
// Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              0xC00D00C8L

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
// Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             0xC00D00C9L

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
// Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           0xC00D00CAL

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
// %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      0xC00D00CBL

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
// The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            0xC00D00CCL

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
// The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                0xC00D00CDL

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
// Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           0xC00D00CEL

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
// Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             0xC00D00CFL

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
// Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         0xC00D00D0L

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
// UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                0xC00D00D1L

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
// TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                0xC00D00D2L

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
// HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               0xC00D00D3L

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
// The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             0xC00D00D4L


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            0xC00D0BBEL

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
// The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           0xC00D0BC0L

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
// You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    0xC00D0BC1L

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
// The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                0xC00D0BCAL


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     0xC00D2711L

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     0xC00D2712L

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
// Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      0xC00D2713L

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR 0xC00D2714L

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR 0xC00D2715L

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         0xC00D2716L

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  0xC00D2717L

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
// The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         0xC00D2718L

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
// Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         0xC00D2719L

//
// MessageId: NS_E_DRM_LICENSE_EVAL_FAILED
//
// MessageText:
//
// The license is corrupted or invalid. Acquire a new license or reinstall the application.%0
//
#define NS_E_DRM_LICENSE_EVAL_FAILED     0xC00D271AL

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     0xC00D271BL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST 0xC00D271CL

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    0xC00D271DL

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
// The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE 0xC00D271EL

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED 0xC00D271FL

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
// The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               0xC00D2720L

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_KEY_ERROR               0xC00D2721L

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           0xC00D2722L

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           0xC00D2723L

//
// MessageId: NS_E_DRM_LICENSE_PREVENTS_STORING
//
// MessageText:
//
// You cannot save this file.%0
//
#define NS_E_DRM_LICENSE_PREVENTS_STORING 0xC00D2724L

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     0xC00D2725L

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
// Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        0x000D2726L

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
// Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          0x000D2727L

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION 0xC00D2728L

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_FAILED
//
// MessageText:
//
// The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_FAILED 0xC00D2729L

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
// The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      0xC00D272AL

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
// You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       0xC00D272BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
// You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         0xC00D272CL

//
// MessageId: NS_E_DRM_ENCRYPTING
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_ENCRYPTING              0xC00D272DL

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   0xC00D272FL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
// A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT 0xC00D2730L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT 0xC00D2731L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT 0xC00D2732L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT 0xC00D2733L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT 0xC00D2734L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT 0xC00D2735L

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
// The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     0xC00D2736L

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      0xC00D2737L

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     0xC00D2738L

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       0xC00D2739L

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             0xC00D273AL

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            0xC00D273BL

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR 0xC00D273CL

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR 0xC00D273DL

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           0xC00D273EL

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
// The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER 0xC00D273FL

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         0xC00D2740L

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION 0xC00D2741L

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
// Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           0xC00D2742L

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
// One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          0xC00D2743L

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
// You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      0xC00D2744L

//
// MessageId: NS_E_DRM_GET_ATTRIBUTE_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_GET_ATTRIBUTE_ERROR     0xC00D2745L

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
// Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       0x000D2746L

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
// Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       0x000D2747L

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
// The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        0xC00D2748L

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
// A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        0xC00D2749L

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  0xC00D274AL

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
// A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    0xC00D274BL

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
// A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE 0xC00D274CL

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
// Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     0xC00D274DL

//
// MessageId: NS_E_DRM_NEED_UPGRADE
//
// MessageText:
//
// A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE            0xC00D274EL

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
// Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          0xC00D274FL

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
// Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  0xC00D2750L

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD 0xC00D2751L

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         0xC00D2752L

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
// You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           0xC00D2753L

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
// The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   0xC00D2754L

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
// To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            0xC00D2755L

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
// You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       0xC00D2756L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT 0xC00D2757L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT 0xC00D2758L

// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
// Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     0xC00D2759L

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT 0xC00D275AL

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT 0xC00D275BL

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied is not sufficient.%0
//
#define NS_E_DRM_BUFFER_TOO_SMALL        0xC00D275CL

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The property requested is not supported.%0
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    0xC00D275DL

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.%0
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      0xC00D275EL

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
// Some of the licenses could not be stored.%0
//
#define NS_E_DRM_STORE_NOTALLSTORED      0xC00D275FL

// License Reasons Section
// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
// The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         0xC00D27D8L

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
// The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      0xC00D27D9L

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       0xC00D27DAL

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
// The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0
//
#define NS_E_DRM_STORE_NEEDINDI          0xC00D27DBL

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
// Your machine does not meet the requirements for storing the license.%0
//
#define NS_E_DRM_STORE_NOTALLOWED        0xC00D27DCL

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           0xC00D27DDL

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           0xC00D27DEL

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
// The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           0xC00D27DFL

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  0xC00D27E0L

//
// MessageId: NS_E_DRM_TOO_MANY_INSTANCES
//
// MessageText:
//
// The Digital Rights Management (DRM) sub-system can only be used by one process at a time.  Please close any other applications which may be using DRM, or navigate your browser away from any DRM-related activities, and then try again.%0
//
#define NS_E_DRM_TOO_MANY_INSTANCES      0xC00D27E1L

//
// MessageId: NS_E_DRM_ACQUIRE_LICENSE_VIA_BROWSER
//
// MessageText:
//
// The license for this file could not be acquired silently.  Your browser is being used to try and acquire the license.  Please reopen this file again after you have completed license acquisition.%0
//
#define NS_E_DRM_ACQUIRE_LICENSE_VIA_BROWSER 0xC00D27E2L


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
// The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            0xC00D2EE0L

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
// The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           0xC00D2EE1L

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
// The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       0xC00D2EE2L

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
// The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 0xC00D2EE3L

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
// The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            0xC00D2EE4L

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
// The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               0xC00D2EE5L

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
// The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          0xC00D2EE6L

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
// The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           0xC00D2EE7L

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
// The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         0xC00D2EE8L

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
// The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          0xC00D2EE9L

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
// The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            0xC00D2EEAL

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
// The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      0xC00D2EEBL

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
// The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    0xC00D2EECL

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
// The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             0xC00D2EEDL

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
// Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     0xC00D2EEEL

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          0xC00D2EEFL

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           0xC00D2EF0L

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
// Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           0xC00D2EF1L

//
// MessageId: NS_E_DRM_NO_SERVER_AVAILABLE
//
// MessageText:
//
// The server name or address could not be resolved.%0
//
#define NS_E_DRM_NO_SERVER_AVAILABLE     0xC00D2EF2L


#endif _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ntintsafe.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/******************************************************************
*                                                                 *
*  ntintsafe.h -- This module defines helper functions to prevent *
*                 integer overflow bugs for drivers. A similar    *
*                 file, intsafe.h, is available for applications. *
*                                                                 *
*                                                                 *
******************************************************************/
#ifndef _NTINTSAFE_H_INCLUDED_
#define _NTINTSAFE_H_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

#include <specstrings.h>    // for __in, etc.


#if defined(_AMD64_) && !defined(UnsignedMultiply128)
#ifdef __cplusplus
extern "C" {
#endif
#define UnsignedMultiply128 _umul128
ULONG64
UnsignedMultiply128 (
    IN  ULONG64  Multiplier,
    IN  ULONG64  Multiplicand,
    OUT ULONG64 *HighProduct
    );
#pragma intrinsic(_umul128)
#ifdef __cplusplus
}
#endif
#endif // _AMD64_ && !UnsignedMultiply128

#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    size_t;
#else
typedef __w64 unsigned int  size_t;
#endif  // !_WIN64
#define _SIZE_T_DEFINED
#endif  // !_SIZE_T_DEFINED

#if !defined(_WCHAR_T_DEFINED) && !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


#ifndef LOWORD
#define LOWORD(_l)      ((unsigned short)((unsigned long)(_l) & 0xffff))
#endif // !LOWORD

#ifndef HIWORD
#define HIWORD(_l)      ((unsigned short)((unsigned long)(_l) >> 16))
#endif // !HIWORD

#ifndef HIDWORD
#define HIDWORD(_qw)    (unsigned long)((_qw)>>32)
#endif // !HIDWORD

#ifndef LODWORD
#define LODWORD(_qw)    (unsigned long)(_qw)
#endif // !LODWORD

#ifndef UInt32x32To64
#define UInt32x32To64(a, b) ((unsigned __int64)((unsigned long)(a)) * (unsigned __int64)((unsigned long)(b)))
#endif // !UInt32x32To64

#ifndef INT_MAX
#define INT_MAX         2147483647
#endif // !INT_MAX

//
// It is common for -1 to be used as an error value for various types
//
#define USHORT_ERROR    (0xffff)
#define INT_ERROR       (2147483647)
#define UINT_ERROR      (0xffffffff)
#define ULONG_ERROR     (0xffffffff)
#define SIZET_ERROR     ((size_t)-1)
#define ULONGLONG_ERROR (0xffffffffffffffff)

//
// We make some assumptions about the sizes of various types. Let's be
// explicit about those assumptions and check them.
//
C_ASSERT(sizeof(unsigned short) == 2);
C_ASSERT(sizeof(unsigned int) == 4);
C_ASSERT(sizeof(unsigned long) == 4);


//
// INT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
#define RtlIntToChar(iOperand, pch)        RtlIntToUChar(iOperand, pch)
#else
__inline
NTSTATUS
RtlIntToChar(
    __in int iOperand,
    __out char* pch)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pch = '\0';

    if ((iOperand >= -128) && (iOperand <= 127))
    {
        *pch = (char)iOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}
#endif // _CHAR_UNSIGNED

//
// INT -> UCHAR conversion
//
__inline
NTSTATUS
RtlIntToUChar(
    __in int iOperand,
    __out unsigned char* pch)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pch = '\0';

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (unsigned char)iOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}

//
// INT -> BYTE conversion
//
#define RtlIntToByte(uOperand, pResult)    RtlIntToUChar(uOperand, pResult)

//
// UINT -> CHAR conversion
//
#ifdef _CHAR_UNSIGNED
#define RtlUIntToChar(uOperand, pch)       RtlUIntToUChar(uOperand, pch)
#else
__inline
NTSTATUS
RtlUIntToChar(
    __in unsigned int uOperand,
    __out char* pch)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pch = '\0';

    if (uOperand <= 127)
    {
        *pch = (char)uOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}
#endif // _CHAR_UNSIGNED

//
// UINT -> UCHAR conversion
//
__inline
NTSTATUS
RtlUIntToUChar(
    __in unsigned int uOperand,
    __out unsigned char* pch)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pch = '\0';

    if (uOperand <= 255)
    {
        *pch = (unsigned char)uOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}

//
// UINT -> BYTE conversion
//
#define RtlUIntToByte(uOperand, pResult)   RtlUIntToUChar(uOperand, pResult)

//
// INT -> UINT conversion
//
__inline
NTSTATUS
RtlIntToUInt(
    __in int iOperand,
    __out unsigned int* puResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *puResult = UINT_ERROR;

    if (iOperand >= 0)
    {
        *puResult = (unsigned int)iOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}

//
// UINT -> INT conversion
//
__inline
NTSTATUS
RtlUIntToInt(
    __in unsigned int uOperand,
    __out int* piResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *piResult = INT_ERROR;

    if (uOperand <= INT_MAX)
    {
        *piResult = (int)uOperand;
        status = STATUS_SUCCESS;
    }

    return status;
}

//
// UINT -> USHORT conversion
//
__inline
NTSTATUS
RtlUIntToUShort(
    __in unsigned int uOperand,
    __out unsigned short* pusResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (HIWORD(uOperand) == 0)
    {
        *pusResult = LOWORD(uOperand);
        status = STATUS_SUCCESS;
    }

    return status;
}

//
// UINT -> WORD conversion
//
#define RtlUIntToWord(uOperand, pwResult)      RtlUIntToUShort(uOperand, pwResult)

//
// ULONGLONG -> ULONG conversion
//
__inline
NTSTATUS
RtlULongLongToULong(
    __in unsigned __int64 ullOperand,
    __out unsigned long* pulResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pulResult = ULONG_ERROR;
    
    if (HIDWORD(ullOperand) == 0)
    {
        *pulResult = LODWORD(ullOperand);
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// ULONGLONG -> UINT conversion
//
__inline
NTSTATUS
RtlULongLongToUInt(
    __in unsigned __int64 ullOperand,
    __out unsigned int* puResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *puResult = UINT_ERROR;
    
    if (HIDWORD(ullOperand) == 0)
    {
        *puResult = LODWORD(ullOperand);
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// USHORT addition
//
__inline
NTSTATUS
RtlUShortAdd(
    __in unsigned short usAugend,
    __in unsigned short usAddend,
    __out unsigned short* pusResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if ((unsigned short)(usAugend + usAddend) >= usAugend)
    {
        *pusResult = usAugend + usAddend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// WORD addtition
//
#define RtlWordAdd(wAugend, wAddend, pwResult)         RtlUShortAdd(wAugend, wAddend, pwResult)

//
// UINT addition
//
__inline
NTSTATUS
RtlUIntAdd(
    __in unsigned int uAugend,
    __in unsigned int uAddend,
    __out unsigned int* puResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *puResult = UINT_ERROR;

    if ((unsigned int)(uAugend + uAddend) >= uAugend)
    {
        *puResult = uAugend + uAddend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// UINT_PTR addition
//
#ifdef _WIN64
#define RtlUIntPtrAdd(uAugend, uAddend, puResult)      RtlULongLongAdd(uAugend, uAddend, puResult)
#else
#define RtlUIntPtrAdd(uAugend, uAddend, puResult)      RtlUIntAdd(uAugend, uAddend, puResult)
#endif // _WIN64

//
// ULONG addition
//
__inline
NTSTATUS
RtlULongAdd(
    __in unsigned long ulAugend,
    __in unsigned long ulAddend,
    __out unsigned long* pulResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if ((unsigned long)(ulAugend + ulAddend) >= ulAugend)
    {
        *pulResult = ulAugend + ulAddend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// ULONG_PTR addition
//
#ifdef _WIN64
#define RtlULongPtrAdd(ulAugend, ulAddend, pulResult)  RtlULongLongAdd(ulAugend, ulAddend, pulResult)
#else
#define RtlULongPtrAdd(ulAugend, ulAddend, pulResult)  RtlULongAdd(ulAugend, ulAddend, pulResult)
#endif // _WIN64

//
// DWORD addition
//
#define RtlDWordAdd(dwAugend, dwAddend, pdwResult)     RtlULongAdd(dwAugend, dwAddend, pdwResult)

//
// DWORD_PTR addition
//
#ifdef _WIN64
#define RtlDWordPtrAdd(dwAugend, dwAddend, pdwResult)  RtlULongLongAdd(dwAugend, dwAddend, pdwResult)
#else
#define RtlDWordPtrAdd(dwAugend, dwAddend, pdwResult)  RtlULongAdd(dwAugend, dwAddend, pdwResult)
#endif // _WIN64

//
// size_t addition
//
__inline
NTSTATUS
RtlSizeTAdd(
    __in size_t Augend,
    __in size_t Addend,
    __out size_t* pResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pResult = SIZET_ERROR;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = Augend + Addend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// SIZE_T addition
//
#ifdef _WIN64
#define RtlSIZETAdd(Augend, Addend, pResult)       RtlULongLongAdd(Augend, Addend, pResult)
#else
#define RtlSIZETAdd(Augend, Addend, pResult)       RtlULongAdd(Augend, Addend, pResult)
#endif // _WIN64

//
// ULONGLONG addition
//
__inline
NTSTATUS
RtlULongLongAdd(
    __in unsigned __int64 ullAugend,
    __in unsigned __int64 ullAddend,
    __out unsigned __int64* pullResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;

    if ((unsigned __int64)(ullAugend + ullAddend) >= ullAugend)
    {
        *pullResult = ullAugend + ullAddend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// USHORT subtraction
//
__inline
NTSTATUS
RtlUShortSub(
    __in unsigned short usMinuend,
    __in unsigned short usSubtrahend,
    __out unsigned short* pusResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pusResult = USHORT_ERROR;

    if (usMinuend >= usSubtrahend)
    {
        *pusResult = usMinuend - usSubtrahend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// WORD subtraction
//
#define RtlWordSub(wMinuend, wSubtrahend, pwResult)    RtlUShortSub(wMinuend, wSubtrahend, pwResult)


//
// UINT subtraction
//
__inline
NTSTATUS
RtlUIntSub(
    __in unsigned int uMinuend,
    __in unsigned int uSubtrahend,
    __out unsigned int* puResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *puResult = UINT_ERROR;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = uMinuend - uSubtrahend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// UINT_PTR subtraction
//
#ifdef _WIN64
#define RtlUIntPtrSub(uMinuend, uSubtrahend, puResult)     RtlULongLongSub(uMinuend, uSubtrahend, puResult)
#else
#define RtlUIntPtrSub(uMinuend, uSubtrahend, puResult)     RtlUIntSub(uMinuend, uSubtrahend, puResult)
#endif // _WIN64

//
// ULONG subtraction
//
__inline
NTSTATUS
RtlULongSub(
    __in unsigned long ulMinuend,
    __in unsigned long ulSubtrahend,
    __out unsigned long* pulResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pulResult = ULONG_ERROR;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = ulMinuend - ulSubtrahend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// ULONG_PTR subtraction
//
#ifdef _WIN64
#define RtlULongPtrSub(ulMinuend, ulSubtrahend, pulResult)     RtlULongLongSub(ulMinuend, ulSubtrahend, pulResult)
#else
#define RtlULongPtrSub(ulMinuend, ulSubtrahend, pulResult)     RtlULongSub(ulMinuend, ulSubtrahend, pulResult)
#endif // _WIN64


//
// DWORD subtraction
//
#define RtlDWordSub(dwMinuend, dwSubtrahend, pdwResult)        RtlULongSub(dwMinuend, dwSubtrahend, pdwResult)

//
// DWORD_PTR subtraction
//
#ifdef _WIN64
#define RtlDWordPtrSub(dwMinuend, dwSubtrahend, pdwResult)     RtlULongLongSub(dwMinuend, dwSubtrahend, pdwResult)
#else
#define RtlDWordPtrSub(dwMinuend, dwSubtrahend, pdwResult)     RtlULongSub(dwMinuend, dwSubtrahend, pdwResult)
#endif // _WIN64

//
// size_t subtraction
//
__inline
NTSTATUS
RtlSizeTSub(
    __in size_t Minuend,
    __in size_t Subtrahend,
    __out size_t* pResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pResult = SIZET_ERROR;

    if (Minuend >= Subtrahend)
    {
        *pResult = Minuend - Subtrahend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// SIZE_T subtraction
//
#ifdef _WIN64
#define RtlSIZETSub(Minuend, Subtrahend, pResult)       RtlULongLongSub(Minuend, Subtrahend, pResult)
#else
#define RtlSIZETSub(Minuend, Subtrahend, pResult)       RtlULongSub(Minuend, Subtrahend, pResult)
#endif // _WIN64

//
// ULONGLONG subtraction
//
__inline
NTSTATUS
RtlULongLongSub(
    __in unsigned __int64 ullMinuend,
    __in unsigned __int64 ullSubtrahend,
    __out unsigned __int64* pullResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
    *pullResult = ULONGLONG_ERROR;

    if (ullMinuend >= ullSubtrahend)
    {
        *pullResult = ullMinuend - ullSubtrahend;
        status = STATUS_SUCCESS;
    }
    
    return status;
}

//
// USHORT multiplication
//
__inline
NTSTATUS
RtlUShortMult(
    __in unsigned short usMultiplicand,
    __in unsigned short usMultiplier,
    __out unsigned short* pusResult)
{
    unsigned long ulResult = (unsigned long)usMultiplicand * usMultiplier;
    
    return RtlUIntToUShort(ulResult, pusResult);
}

//
// WORD multiplication
//
#define RtlWordMult(wMultiplicand, wMultiplier, pwResult)      RtlUShortMult(wMultiplicand, wMultiplier, pwResult)

//
// UINT multiplication
//
__inline
NTSTATUS
RtlUIntMult(
    __in unsigned int uMultiplicand,
    __in unsigned int uMultiplier,
    __out unsigned int* puResult)
{
    unsigned __int64 ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return RtlULongLongToUInt(ull64Result, puResult);
}

//
// UINT_PTR multiplication
//
#ifdef _WIN64
#define RtlUIntPtrMult(uMultiplicand, uMultiplier, puResult)       RtlULongLongMult(uMultiplicand, uMultiplier, puResult)
#else
#define RtlUIntPtrMult(uMultiplicand, uMultiplier, puResult)       RtlUIntMult(uMultiplicand, uMultiplier, puResult)
#endif // _WIN64

//
// ULONG multiplication
//
__inline
NTSTATUS
RtlULongMult(
    __in unsigned long ulMultiplicand,
    __in unsigned long ulMultiplier,
    __out unsigned long* pulResult)
{
    unsigned __int64 ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return RtlULongLongToULong(ull64Result, pulResult);
}

//
// ULONG_PTR multiplication
//
#ifdef _WIN64
#define RtlULongPtrMult(ulMultiplicand, ulMultiplier, pulResult)   RtlULongLongMult(ulMultiplicand, ulMultiplier, pulResult)
#else
#define RtlULongPtrMult(ulMultiplicand, ulMultiplier, pulResult)   RtlULongMult(ulMultiplicand, ulMultiplier, pulResult)
#endif // _WIN64


//
// DWORD multiplication
//
#define RtlDWordMult(dwMultiplicand, dwMultiplier, pdwResult)      RtlULongMult(dwMultiplicand, dwMultiplier, pdwResult)

//
// DWORD_PTR multiplication
//
#ifdef _WIN64
#define RtlDWordPtrMult(dwMultiplicand, dwMultiplier, pdwResult)   RtlULongLongMult(dwMultiplicand, dwMultiplier, pdwResult)
#else
#define RtlDWordPtrMult(dwMultiplicand, dwMultiplier, pdwResult)   RtlULongMult(dwMultiplicand, dwMultiplier, pdwResult)
#endif // _WIN64

//
// size_t multiplication
//

#ifdef _WIN64
#define RtlSizeTMult(Multiplicand, Multiplier, pResult)        RtlULongLongMult(Multiplicand, Multiplier, pResult)
#else
#define RtlSizeTMult(Multiplicand, Multiplier, pResult)        RtlUIntMult(Multiplicand, Multiplier, pResult)
#endif // _WIN64

//
// SIZE_T multiplication
//
#ifdef _WIN64
#define RtlSIZETMult(Multiplicand, Multiplier, pResult)        RtlULongLongMult(Multiplicand, Multiplier, pResult)
#else
#define RtlSIZETMult(Multiplicand, Multiplier, pResult)        RtlULongMult(Multiplicand, Multiplier, pResult)
#endif // _WIN64

//
// ULONGLONG multiplication
//
__inline
NTSTATUS
RtlULongLongMult(
    __in unsigned __int64 ullMultiplicand,
    __in unsigned __int64 ullMultiplier,
    __out unsigned __int64* pullResult)
{
    NTSTATUS status = STATUS_INTEGER_OVERFLOW;
#ifdef _AMD64_
    unsigned __int64 u64ResultHigh;
    unsigned __int64 u64ResultLow;
    
    *pullResult = ULONGLONG_ERROR;
    
    u64ResultLow = UnsignedMultiply128(ullMultiplicand, ullMultiplier, &u64ResultHigh);
    if (u64ResultHigh == 0)
    {
        *pullResult = u64ResultLow;
        status = STATUS_SUCCESS;
    }
#else
    // 64x64 into 128 is like 32.32 x 32.32.
    //
    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
    // A*C + A*d + b*C + b*d
    // So there are four components to add together.
    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
    //
    // a * c must be 0 or there would be bits in the high 64-bits
    // a * d must be less than 2^32 or there would be bits in the high 64-bits
    // b * c must be less than 2^32 or there would be bits in the high 64-bits
    // then there must be no overflow of the resulting values summed up.
    
    unsigned long dw_a;
    unsigned long dw_b;
    unsigned long dw_c;
    unsigned long dw_d;
    unsigned __int64 ac = 0;
    unsigned __int64 ad = 0;
    unsigned __int64 bc = 0;
    unsigned __int64 bd = 0;
    unsigned __int64 ullResult = 0;
    
    *pullResult = ULONGLONG_ERROR;

    dw_a = HIDWORD(ullMultiplicand);
    dw_c = HIDWORD(ullMultiplier);

    // common case -- if high dwords are both zero, no chance for overflow
    if ((dw_a == 0) && (dw_c == 0))
    {
        dw_b = LODWORD(ullMultiplicand);
        dw_d = LODWORD(ullMultiplier);

        *pullResult = (unsigned __int64)dw_b * (unsigned __int64)dw_d;
        status = STATUS_SUCCESS;
    }
    else
    {
        // a * c must be 0 or there would be bits set in the high 64-bits
        if ((dw_a == 0) ||
            (dw_c == 0) ||
            (((ac = (unsigned __int64)dw_a * (unsigned __int64)dw_c)) == 0))
        {
            dw_d = LODWORD(ullMultiplier);

            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
            ad = (unsigned __int64)dw_a * (unsigned __int64)dw_d;
            if (ad <= 4294967295)
            {
                dw_b = LODWORD(ullMultiplicand);

                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
                bc = (unsigned __int64)dw_b * (unsigned __int64)dw_c;
                if (bc <= 4294967295)
                {
                    // now sum them all up checking for overflow.
                    // shifting is safe because we already checked for overflow above
#ifdef _WIN64 
                    if (NT_SUCCESS(RtlULongLongAdd(bc << 32, ad << 32, &ullResult)))                        
#else
                    // << 32 not supported on 32-bit compilers
                    if (NT_SUCCESS(RtlULongLongAdd(bc * 4294967295, ad * 4294967295, &ullResult)))
#endif                                      
                    {
                        // b * d
                        bd = (unsigned __int64)dw_b * (unsigned __int64)dw_d;
                    
                        if (NT_SUCCESS(RtlULongLongAdd(ullResult, bd, &ullResult)))
                        {
                            *pullResult = ullResult;
                            status = STATUS_SUCCESS;
                        }
                    }
                }
            }
        }
    }
#endif // _AMD64_  
    
    return status;
}

#ifdef UNDER_CE
// Extra helper functions specific to CE

__inline
NTSTATUS
CeRtlULongAdd3(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(NT_SUCCESS(RtlULongAdd(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlULongAdd(*pResult,arg3,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

__inline
NTSTATUS
CeRtlULongAdd4(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__in unsigned long arg4,
	__out unsigned long* pResult)
{
	if(NT_SUCCESS(RtlULongAdd(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlULongAdd(*pResult,arg3,pResult)) &&
		NT_SUCCESS(RtlULongAdd(*pResult,arg4,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

// (arg1*arg2) + arg3
__inline
NTSTATUS
CeRtlULongMult2Add(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(NT_SUCCESS(RtlULongMult(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlULongAdd(*pResult,arg3,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

// (arg1+arg2) * arg3
__inline
NTSTATUS
CeRtlULongAdd2Mult(
	__in unsigned long arg1,
	__in unsigned long arg2,
	__in unsigned long arg3,
	__out unsigned long* pResult)
{
	if(NT_SUCCESS(RtlULongAdd(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlULongMult(*pResult,arg3,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

#define CeRtlDWordAdd3(arg1,arg2,arg3,pResult) CeRtlULongAdd3(arg1,arg2,arg3,pResult)

#define CeRtlDWordAdd4(arg1,arg2,arg3,arg4,pResult) CeRtlULongAdd4(arg1,arg2,arg3,arg4,pResult)

#define CeRtlDWordMult2Add(arg1,arg2,arg3,pResult) CeRtlULongMult2Add(arg1,arg2,arg3,pResult)

#define CeRtlDWordAdd2Mult(arg1,arg2,arg3,pResult) CeRtlULongAdd2Mult(arg1,arg2,arg3,pResult)

__inline
NTSTATUS
CeRtlUIntAdd3(
	__in unsigned int arg1,
	__in unsigned int arg2,
	__in unsigned int arg3,
	__out unsigned int* pResult)
{
	if(NT_SUCCESS(RtlUIntAdd(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlUIntAdd(*pResult,arg3,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

__inline
NTSTATUS
CeRtlUIntAdd4(
	__in unsigned int arg1,
	__in unsigned int arg2,
	__in unsigned int arg3,
	__in unsigned int arg4,
	__out unsigned int* pResult)
{
	if(NT_SUCCESS(RtlUIntAdd(arg1,arg2,pResult)) &&
		NT_SUCCESS(RtlUIntAdd(*pResult,arg3,pResult)) &&
		NT_SUCCESS(RtlUIntAdd(*pResult,arg4,pResult))){
		return STATUS_SUCCESS;
	}

	return STATUS_INTEGER_OVERFLOW;
}

#endif

#endif // _NTINTSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ntcompat.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:

ntcompat.h

Abstract:

Compatiblity defines for CE NDIS drivers

Notes:


--*/

#pragma once

#ifndef _NTCOMPAT_H_
#define _NTCOMPAT_H_

#include <windows.h>

#include <wdm.h>
#include <resmgr.h>
//
//  Determine if the active thread owns the critical section
//
#define OWN_CRITSEC(CS) ((CS)->OwnerThread == (HANDLE)GetCurrentThreadId())

#ifdef __cplusplus
extern "C" {
#endif

typedef CONST char *PCSZ;

typedef char CCHAR, *PCCHAR;
typedef short CSHORT, *PCSHORT;
typedef ULONG CLONG, *PCLONG;

typedef STRING ANSI_STRING, *PANSI_STRING;
typedef STRING OEM_STRING, *POEM_STRING;
typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


/* resources */
/* bit masks for Flags when type is CmResourceTypeInterrupt */
#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE   0
#define CM_RESOURCE_INTERRUPT_LATCHED           1

/* bit masks for Flags when type is CmResourceTypeMemory */
#define CM_RESOURCE_MEMORY_READ_WRITE           0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY            0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY           0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE         0x0004
#define CM_RESOURCE_MEMORY_COMBINEDWRITE        0x0008
#define CM_RESOURCE_MEMORY_24                   0x0010

/* bit masks for Flags when type is CmResourceTypePort */
#define CM_RESOURCE_PORT_MEMORY                 0
#define CM_RESOURCE_PORT_IO                     1

/* bit masks for Flags when type is CmResourceTypeDma */
#define CM_RESOURCE_DMA_8                       0x0000
#define CM_RESOURCE_DMA_16                      0x0001
#define CM_RESOURCE_DMA_32                      0x0002

/* resource options */
#define IO_RESOURCE_PREFERRED                   0x01
#define IO_RESOURCE_DEFAULT                     0x02
#define IO_RESOURCE_ALTERNATIVE                 0x08

typedef enum _CM_RESOURCE_TYPE {
          CmResourceTypeNull = 0,
          CmResourceTypePort,
          CmResourceTypeInterrupt,
          CmResourceTypeMemory,
          CmResourceTypeDma,
          CmResourceTypeDeviceSpecific,
          CmResourceTypeMaximum
        } CM_RESOURCE_TYPE;

typedef enum _CM_SHARE_DISPOSITION {
          CmResourceShareUndetermined = 0,
          CmResourceShareDeviceExclusive,
          CmResourceShareDriverExclusive,
          CmResourceShareShared
        } CM_SHARE_DISPOSITION;

typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
          UCHAR Type;
          UCHAR ShareDisposition;
          USHORT Flags;
          union {
            struct {
              PHYSICAL_ADDRESS  Start;
              ULONG             Length;
            } Port;

            struct {
              ULONG             Level;
              ULONG             Vector;
              ULONG             Affinity;
            } Interrupt;

            struct {
              PHYSICAL_ADDRESS  Start;
              ULONG             Length;
            } Memory;

            struct {
              ULONG             Channel;
              ULONG             Port;
              ULONG             Reserved1;
            } Dma;

            struct {
              ULONG             DataSize;
              ULONG             Reserved1;
              ULONG             Reserved2;
            } DeviceSpecificData;
          } u;
        } CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;

typedef struct _CM_PARTIAL_RESOURCE_LIST {
          USHORT                Version;
          USHORT                Revision;
          ULONG                 Count;
          CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
        } CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
          INTERFACE_TYPE        InterfaceType;
          ULONG                 BusNumber;
          CM_PARTIAL_RESOURCE_LIST PartialResourceList;
        } CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

typedef struct _CM_RESOURCE_LIST {
          ULONG                 Count;
          CM_FULL_RESOURCE_DESCRIPTOR List[1];
        } CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;

typedef struct _IO_RESOURCE_DESCRIPTOR {
          UCHAR                 Option;
          UCHAR                 Type;
          UCHAR                 ShareDisposition;
          UCHAR                 Spare1;
          USHORT                Flags;
          USHORT                Spare2;

          union {
            struct {
              ULONG             Length;
              ULONG             Alignment;
              PHYSICAL_ADDRESS  MinimumAddress;
              PHYSICAL_ADDRESS  MaximumAddress;
            } Port;

            struct {
              ULONG             Length;
              ULONG             Alignment;
              PHYSICAL_ADDRESS  MinimumAddress;
              PHYSICAL_ADDRESS  MaximumAddress;
            } Memory;

            struct {
              ULONG             MinimumVector;
              ULONG             MaximumVector;
            } Interrupt;

            struct {
              ULONG             MinimumChannel;
              ULONG             MaximumChannel;
            } Dma;

        } u;
      } IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;

typedef struct _IO_RESOURCE_LIST {
          USHORT                Version;
          USHORT                Revision;
          ULONG                 Count;
          IO_RESOURCE_DESCRIPTOR Descriptors[1];
        } IO_RESOURCE_LIST, *PIO_RESOURCE_LIST;

typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
          ULONG                 ListSize;
          INTERFACE_TYPE        InterfaceType;
          ULONG                 BusNumber;
          ULONG                 SlotNumber;
          ULONG                 Reserved[3];
          ULONG                 AlternativeLists;
          IO_RESOURCE_LIST      List[1];
        } IO_RESOURCE_REQUIREMENTS_LIST, *PIO_RESOURCE_REQUIREMENTS_LIST;



#ifndef _WDMDDK_
typedef struct _DRIVER_OBJECT {
          HANDLE                ObjectHandle;
          UNICODE_STRING        DriverName;
          UNICODE_STRING        RegistryPath;
          UNICODE_STRING        ImagePath;
        } DRIVER_OBJECT, *PDRIVER_OBJECT;

typedef struct _DEVICE_OBJECT {
          CSHORT                Type;
          USHORT                Size;
          LONG                  ReferenceCount;
          PDRIVER_OBJECT        DriverObject;
          struct _DEVICE_OBJECT *NextDevice;
          struct _DEVICE_OBJECT *AttachedDevice;
        } DEVICE_OBJECT, *PDEVICE_OBJECT;
#endif


#define UNICODE_NULL ((WCHAR)0)

#if defined(BINARY_COMPATIBLE) && !defined(PopEntryList)
/* singly-linked list manipulation routines */
/*++
PSINGLE_LIST_ENTRY
PopEntryList(
  PSINGLE_LIST_ENTRY ListHead
)
--*/
#define PopEntryList(_ListHead) \
          (_ListHead)->Next; \
          { \
            PSINGLE_LIST_ENTRY _FirstEntry = (_ListHead)->Next; \
            if (_FirstEntry != NULL) \
              (_ListHead)->Next = _FirstEntry->Next; \
          }

/*++
VOID
PushEntryList(
  PSINGLE_LIST_ENTRY ListHead,
  PSINGLE_LIST_ENTRY Entry
)
--*/
#define PushEntryList(_ListHead, _Entry) \
        { \
          (_Entry)->Next = (_ListHead)->Next; \
          (_ListHead)->Next = _Entry; \
        }
#endif

#if defined(BINARY_COMPATIBLE) && !defined(InitializeListHead)
/* doubly-linked list manipulation routines */
/*++
VOID
InitializeListHead(
  PLIST_ENTRY ListHead
)
--*/
#define InitializeListHead(_ListHead) \
          ((_ListHead)->Flink = (_ListHead)->Blink = _ListHead)

/*++
BOOLEAN
IsListEmpty(
  PLIST_ENTRY ListHead
)
--*/
#define IsListEmpty(_ListHead)   ((_ListHead)->Flink == _ListHead)

/*++
PLIST_ENTRY
RemoveHeadList(
  PLIST_ENTRY ListHead
)
--*/
#define RemoveHeadList(_ListHead) \
          (_ListHead)->Flink; \
          RemoveEntryList((_ListHead)->Flink)

/*++
PLIST_ENTRY
RemoveTailList(
  PLIST_ENTRY ListHead
)
--*/
#define RemoveTailList(_ListHead) \
          (_ListHead)->Blink; \
          RemoveEntryList((_ListHead)->Blink)

/*++
VOID
RemoveEntryList(
  PLIST_ENTRY Entry
)
--*/
#define RemoveEntryList(_Entry) \
        { \
          PLIST_ENTRY _EX_Flink = (_Entry)->Flink; \
          PLIST_ENTRY _EX_Blink = (_Entry)->Blink; \
          _EX_Blink->Flink = _EX_Flink; \
          _EX_Flink->Blink = _EX_Blink; \
        }

/*++
VOID
InsertTailList(
  PLIST_ENTRY ListHead,
  PLIST_ENTRY Entry
)
--*/
#define InsertTailList(_ListHead, _Entry) \
        { \
          PLIST_ENTRY _EX_ListHead = _ListHead; \
          PLIST_ENTRY _EX_Blink = _EX_ListHead->Blink; \
          (_Entry)->Flink = _EX_ListHead; \
          (_Entry)->Blink = _EX_Blink; \
          _EX_Blink->Flink = _Entry; \
          _EX_ListHead->Blink = _Entry; \
        }

/*++
VOID
InsertHeadList(
  PLIST_ENTRY ListHead,
  PLIST_ENTRY Entry
)
--*/
#define InsertHeadList(_ListHead, _Entry) \
        { \
          PLIST_ENTRY _EX_ListHead = _ListHead; \
          PLIST_ENTRY _EX_Flink = _EX_ListHead->Flink; \
          (_Entry)->Flink = _EX_Flink; \
          (_Entry)->Blink = _EX_ListHead; \
          _EX_Flink->Blink = _Entry; \
          _EX_ListHead->Flink = _Entry; \
        }
#endif

///// cedriver.c

//
// Define driver unload routine type.
//

typedef
VOID
(*PCEDRIVER_UNLOAD) (
    IN struct _CEDRIVER_OBJECT *DriverObject
    );

//
// Structure used to track miniport driver objects
//
typedef struct _CEDRIVER_OBJECT
{
    struct _CEDRIVER_OBJECT *Next;
    HANDLE                  DllHandle;
    UNICODE_STRING          DriverName;
    UNICODE_STRING          RegistryPath;
    PVOID                   DriverObjectExtension; // Only support one of these
    DWORD                   cbDriverObjectExtension;
    int                     refCnt;
    PCEDRIVER_UNLOAD        DriverUnload;
    PVOID                   extensionID;
} CEDRIVER_OBJECT, *PCEDRIVER_OBJECT;

typedef
  DWORD
  (__stdcall *PFN_DRIVER_ENTRY)(
     IN PVOID Argument1,
     IN PVOID Argument2
  );


#define CEDRIVER_MAX_REGISTRY_PATH_CHARS    64
#define CEDRIVER_MAX_IMAGE_PATH_CHARS       128

PCEDRIVER_OBJECT
CeDriverLoad(
    IN PWSTR wszRegistryKey,
    IN PWSTR wszDriverName,
    IN PWSTR wszGroupName
    );

DWORD
CeDriverObjectExtensionAllocate(
    IN  PCEDRIVER_OBJECT    pCeDriverObject,
    IN  PVOID               extensionID,
    IN  size_t              extensionSize,
    OUT PVOID               pExtension
    );

PVOID
CeDriverObjectExtensionGet(
    IN  PCEDRIVER_OBJECT    pCeDriverObject,
    IN  PVOID               extensionID
    );

PCEDRIVER_OBJECT
CeDriverFindObjectByName(
    IN  LPWSTR  wszDriverName
    );

NTSTATUS
CeDriverAddRef(
    IN  PCEDRIVER_OBJECT    pCeDriverObject);

NTSTATUS
CeDriverDelRef(
    IN  PCEDRIVER_OBJECT    pCeDriverObject);

VOID
CeDriverInitializeModule();

VOID
CeDriverDeinitializeModule();

///// cedevice.c

/////////////////////////////
//  Device Object Management
/////////////////////////////

//
// Structure used to track device objects
//
typedef struct _CEDEVICE_OBJECT
{
    struct _CEDEVICE_OBJECT *Next;
    PWSTR                   DeviceName;
    PCEDRIVER_OBJECT        DriverObject;
    int                     BusType;
    int                     BusNumber;
    PVOID                   DeviceExtension; // Only support one of these
    LONG                    cbDeviceExtension;
    HANDLE                  hBusAccessHandle;   //  for using bus APIs like
                                                //  GetBusNamePrefix(), SetDeviceConfigurationData()...

} CEDEVICE_OBJECT, *PCEDEVICE_OBJECT;

NTSTATUS
CeDeviceCreate(
    IN  PCEDRIVER_OBJECT     DriverObject,
    IN  LONG                 DeviceExtensionSize,
    IN  PUNICODE_STRING      DeviceName OPTIONAL,
    OUT PCEDEVICE_OBJECT    *DeviceObject
    );


NTSTATUS
CeDeviceDelete(
    IN  PCEDEVICE_OBJECT     DeviceObject
    );

typedef NTSTATUS
  (*PDEVICE_ADD_ROUTINE)(
        IN  PCEDRIVER_OBJECT     DriverObject,
        IN  PUNICODE_STRING      DeviceName OPTIONAL,
        IN  PCEDEVICE_OBJECT     PhysicalDeviceObject,
        IN  ULONG                Characteristics,
        IN  HANDLE               hBusAccessHandle
  );

NTSTATUS
CeDeviceCreateDeviceForLoadedDriver(
    IN  PCEDRIVER_OBJECT        DriverObject,
    IN  PWSTR                   DeviceName,         // e.g. "NE20001"
    IN  DWORD                   BusType,            // e.g  PCMCIABus
    IN  DWORD                   BusNumber,
    IN  PDEVICE_ADD_ROUTINE     pfnAddDevice,
    OUT PCEDEVICE_OBJECT       *pPhysicalDeviceObject,
    IN  HANDLE                  hBusAccessHandle);

NTSTATUS
CeDeviceLoadDriverAndCreateDevice(
    IN  PWSTR                   wszRegistryKey,     // e.g. "Comm"
    IN  PWSTR                   DriverName,         // e.g. "NE2000"
    IN  PWSTR                   GroupName,          // e.g. "NDIS"
    IN  PWSTR                   DeviceName,         // e.g. "NE20001"
    IN  DWORD                   BusType,            // e.g  PCMCIABus
    IN  DWORD                   BusNumber,
    IN  PDEVICE_ADD_ROUTINE     pfnAddDevice,
    OUT PCEDEVICE_OBJECT       *pPhysicalDeviceObject,
    IN  HANDLE                  hBusAccessHandle);

NTSTATUS
CeDeviceLoadDriverAndCreateNonPnPDevice(
    IN  PWSTR                   wszRegistryKey,     // e.g. "\Comm"
    IN  PWSTR                   DriverName,
    IN  PWSTR                   GroupName,
    IN  PWSTR                   DeviceName,
    IN  PDEVICE_ADD_ROUTINE     pfnAddDevice);

VOID
CeDeviceEnumerateFromRegistry(
    IN  PWSTR                   wszRegistryKey,     // e.g. "\Comm"
    IN  PWSTR                   wszGroup,           // e.g. "NDIS"
    IN  PDEVICE_ADD_ROUTINE     pfnAddDevice
    );

VOID
CeDeviceInitializeModule();

VOID
CeDeviceDeinitializeModule();

///// ceinterrupt.c

//
// Interrupt modes.
//

typedef enum _CEKINTERRUPT_MODE
{
    LevelSensitive,
    Latched
} CEKINTERRUPT_MODE;


typedef BOOLEAN (*PCEKSERVICE_ROUTINE)(struct _CEKINTERRUPT *, PVOID);

typedef void (*PSISTSERVICE_ROUTINE)(DWORD);

typedef struct _CEKINTERRUPT
{
    ULONG               InterruptId;
    HANDLE              hEvent;
    PCEKSERVICE_ROUTINE ServiceRoutine;
    PVOID               ServiceContext;
    HANDLE              hServiceThread;
    BOOLEAN             bOpen;
    UINT                InterruptVector;
    BOOLEAN             bResourceRequested;
    HANDLE              hIsr;
} CEKINTERRUPT, *PCEKINTERRUPT;

NTSTATUS
CeConnectInterrupt(
    OUT         PCEKINTERRUPT       *pInterruptObject,
    IN          PCEKSERVICE_ROUTINE ServiceRoutine,
    IN          PVOID               ServiceContext,
    IN          UINT                InterruptVector,
    IN          UINT                InterruptId,
    IN          CEKINTERRUPT_MODE   InterruptMode,
    IN          BOOLEAN             ShareVector,
    IN          DWORD               BusType,
    IN          UINT                InterruptThreadPriority,
    IN          PWSTR                wszRegKey,
    IN          UINT                 SuperISTThreadPriority,
    IN          PSISTSERVICE_ROUTINE SuperISTServiceRoutine
    );


NTSTATUS
CeDisconnectInterrupt(
    IN  PCEKINTERRUPT   InterruptObject
    );

///// ceke.c

////////////////////////////////////
//      KeXxx emulation
////////////////////////////////////


#define KEVENT                              HANDLE
#define PKEVENT                             PHANDLE

typedef struct _KQUEUE
{
    CRITICAL_SECTION    lock;
    HANDLE              hEvent;
    LIST_ENTRY          list;

} KQUEUE, *PKQUEUE;

VOID
CeKeInitializeQueue (
    IN PKQUEUE Queue,
    IN ULONG Count OPTIONAL
    );
VOID
CeKeFreeQueue (
    IN PKQUEUE Queue
    );
LONG
CeKeInsertQueueHandler(
    IN  PKQUEUE pQueue,
    IN  PLIST_ENTRY pEntry,
    PKDPC   pKDpc,
   __in_opt PVOID SystemArgument1,
   __in_opt PVOID SystemArgument2
    );
LONG
CeKeInsertQueue(
    IN  PKQUEUE pQueue,
    IN  PLIST_ENTRY pEntry
    );
PLIST_ENTRY
CeKeRemoveQueue (
    IN PKQUEUE         pQueue,
    IN PLARGE_INTEGER  Timeout OPTIONAL
    );

VOID
CeKeFlushQueuedDpcs(
    IN  PKQUEUE     pDpcQueue
    );

#define KeInitializeQueue(pQ, count)     CeKeInitializeQueue(pQ, count)
#define KeInsertQueue(pQ, pNode)         CeKeInsertQueue(pQ, pNode)
#define KeRemoveQueue(pQ, mode, timeout) CeKeRemoveQueue(pQ, timeout)

/////////////////////////
//  DPC management
/////////////////////////
VOID
CeKeInitializeDpc(
    PKDPC               pKDpc,
    PKDEFERRED_ROUTINE  DeferredRoutine,
    PVOID               DeferredContext);

VOID
CeKeFreeDpc(
    PKDPC               pKDpc);

LONG
CeKeInsertQueueDpc(
    PKQUEUE pKQueue,
    PKDPC   pKDpc,
   __in_opt PVOID SystemArgument1,
   __in_opt PVOID SystemArgument2
   );

HANDLE
CeKeDpcInitializeModule(
    OUT PKQUEUE pDpcQueue,
    IN  UINT    DpcThreadPriority
    );

VOID
CeKeDpcCleanupModule(
    IN  PKQUEUE pDpcQueue,
    IN  HANDLE  hDpcThread
    );

/////////////////////////
//  Timer management
/////////////////////////

typedef PKDPC   PCEKDPC;

//
// Timer object
//
typedef struct _CEKTIMER {
    LIST_ENTRY          TimerListEntry;
    PCEKDPC             Dpc;

    ULONG               Reserved[2];

    //
    //  The MsRemaining field is the delta from the fire time of
    //  the previous timer in the timer queue for this timer
    //  to fire.
    //

    ULONG               MsRemaining;
    ULONG               Period;
    ULONG               Reserved2;
} CEKTIMER, *PCEKTIMER;

VOID
CeKeInitializeTimer(
    IN OUT PCEKTIMER Timer
    );
void
CeKeSetTimer(
    IN  OUT PCEKTIMER   Timer,
    IN  UINT            DelayMilliseconds,
    IN      PCEKDPC     Dpc
    );
BOOLEAN
CeKeSetPeriodicTimer(
    IN  OUT PCEKTIMER   Timer,
    IN  UINT            PeriodMilliseconds,
    IN      PCEKDPC     Dpc
    );
BOOLEAN
CeKeCancelTimer(
    IN OUT PCEKTIMER Timer
    );
DWORD
CeKeInitializeTimerModule(
    PKQUEUE pDpcQueue,
    DWORD   threadPriority
    );
VOID
CeKeShutdownTimerModule();

//
//  CeKePowerUp() should only be used by NDS_PowerUp() function.
//

typedef
void (*PFUNC_POWER_UP)(void);

void
CeKePowerUp (PFUNC_POWER_UP pFunc);

#define KTIMER  CEKTIMER
#define PKTIMER PCEKTIMER

#define KeInitializeTimer   CeKeInitializeTimer
#define KeSetTimer          CeKeSetTimer
#define KeSetTimerEx(_Timer_, _DueTime_, _PeriodicTime_, _Dpc_) CeKeSetPeriodicTimer(_Timer_, _PeriodicTime_, _Dpc_)
#define KeCancelTimer       CeKeCancelTimer


#define KeGetCurrentProcessorNumber()           0
#define KeNumberProcessors                      1

#define KeBugCheckEx(bugcode, miniport, length, a, b) DebugBreak()

extern void CeKeQuerySystemTime(PLARGE_INTEGER  pCurrentTime);

#define KeQuerySystemTime                       CeKeQuerySystemTime


////////////////////////////////////
//      ExXxx emulation
////////////////////////////////////

#define PETHREAD                                        HANDLE

#define ExAcquireSpinLock(pSpinLock, _pIrql)            EnterCriticalSection(pSpinLock)
#define ExReleaseSpinLock(pSpinLock, _pIrql)            LeaveCriticalSection(pSpinLock)
#define ExAcquireSpinLockAtDpcLevel(pSpinLock)          EnterCriticalSection(pSpinLock)
#define ExReleaseSpinLockFromDpcLevel(pSpinLock)        LeaveCriticalSection(pSpinLock)

typedef
  VOID
  (*PWORKER_THREAD_ROUTINE)(
    IN PVOID Parameter
  );

typedef struct _WORK_QUEUE_ITEM {
          LIST_ENTRY    List;
          PWORKER_THREAD_ROUTINE WorkerRoutine;
          PVOID         Parameter;
        } WORK_QUEUE_ITEM, *PWORK_QUEUE_ITEM;

#define ExInitializeWorkItem(_W, _R, _C)    \
        (_W)->WorkerRoutine = _R;   \
        (_W)->Parameter = _C

#define ExInterlockedAddUlong(pAddend, Increment, pSpinLock)    \
        {   \
            ExAcquireSpinLockAtDpcLevel(pSpinLock); \
            *pAddend += Increment;                  \
            ExReleaseSpinLockFromDpcLevel(pSpinLock);   \
        }

LARGE_INTEGER
ExInterlockedAddLargeInteger(
    IN  PLARGE_INTEGER First,
    IN  LARGE_INTEGER Second,
    IN  PKSPIN_LOCK    SpinLock
    );

PLIST_ENTRY
ExInterlockedInsertHeadList(
    IN  PLIST_ENTRY         ListHead,
    IN  PLIST_ENTRY         ListEntry,
    IN  PKSPIN_LOCK         SpinLock
    );

PLIST_ENTRY
ExInterlockedInsertTailList(
    IN  PLIST_ENTRY         ListHead,
    IN  PLIST_ENTRY         ListEntry,
    IN  PKSPIN_LOCK         SpinLock
    );

PLIST_ENTRY
ExInterlockedRemoveHeadList(
    IN PLIST_ENTRY  ListHead,
    IN PKSPIN_LOCK  SpinLock
    );

PLIST_ENTRY
ExInterlockedRemoveTailList(
    IN PLIST_ENTRY  ListHead,
    IN PKSPIN_LOCK  SpinLock
    );

PSINGLE_LIST_ENTRY
ExInterlockedPushEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PSINGLE_LIST_ENTRY      ListEntry,
    IN  PKSPIN_LOCK             SpinLock
    );

PSINGLE_LIST_ENTRY
ExInterlockedPopEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PKSPIN_LOCK             SpinLock
    );

// approximate cpu usage as 50%
#define ExGetCurrentProcessorCpuUsage(pulUsage)         (*pulUsage) = 50

#define ExGetCurrentProcessorCounts(pIdleCount, pKernelAndUser, pIndex) \
    *pIdleCount = 0;            \
    *pKernelAndUser = 0;        \
    *pIndex = 0

////////////////////////////////////
//      IoXxx emulation
////////////////////////////////////
extern PMDL     CeIoAllocateMdl(PVOID pVa, UINT Length);
extern VOID     CeIoFreeMdl(PMDL pMdl);
extern VOID
CeIoBuildPartialMdl(
    IN PMDL SourceMdl,
    IN OUT PMDL TargetMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length);

#define IoAllocateMdl(pVa, Length, x, y, Irp)           CeIoAllocateMdl(pVa, Length)
#define IoFreeMdl                                       CeIoFreeMdl
#define IoBuildPartialMdl                               CeIoBuildPartialMdl

#define IoSetDeviceInterfaceState(name, flag)           STATUS_SUCCESS

#define IoWMIRegistrationControl(DeviceObject, action)  STATUS_SUCCESS

#define IoCreateSymbolicLink(SymbolicName, DeviceName)  STATUS_SUCCESS
#define IoDeleteSymbolicLink(SymbolicName)              STATUS_SUCCESS

#define DRIVER_OBJECT   CEDRIVER_OBJECT
#define PDRIVER_OBJECT  PCEDRIVER_OBJECT

#define IoAllocateDriverObjectExtension     CeDriverObjectExtensionAllocate
#define IoGetDriverObjectExtension          CeDriverObjectExtensionGet

typedef
VOID
(*PCEDRIVER_UNLOAD) (
    IN PCEDRIVER_OBJECT DriverObject
    );

#define PDRIVER_UNLOAD PCEDRIVER_UNLOAD


#define  DEVICE_OBJECT CEDEVICE_OBJECT
#define  PDEVICE_OBJECT PCEDEVICE_OBJECT
#define _DEVICE_OBJECT _CEDEVICE_OBJECT

#define IoCreateDevice(DriverObject, ExtensionSize, Name, Type, Char, Excl, DeviceObject) \
            CeDeviceCreate(DriverObject, ExtensionSize, Name, DeviceObject)
#define IoDeleteDevice(DeviceObject) \
            CeDeviceDelete(DeviceObject)

#define IoAttachDeviceToDeviceStack(NewDeviceObject, PrevDeviceObject)  PrevDeviceObject
#define IoDetachDevice(NextDeviceObject) (void)0

#define KINTERRUPT          CEKINTERRUPT
#define PKINTERRUPT         PCEKINTERRUPT
#define PKSERVICE_ROUTINE   PCEKSERVICE_ROUTINE
#define KINTERRUPT_MODE     CEKINTERRUPT_MODE

////////////////////////////////////
//      MmXxx emulation
////////////////////////////////////

#ifdef MmInitializeMdl
#undef MmInitializeMdl
#endif

#define MmInitializeMdl(Mdl, BaseVa, Length) { \
    (Mdl)->Next = (PMDL) NULL; \
    (Mdl)->MdlFlags = 0; \
    (Mdl)->StartVa = (PVOID) (BaseVa); \
    (Mdl)->ByteOffset = 0; \
    (Mdl)->ByteCount = (Length); \
    }

#ifdef MmGetSystemAddressForMdl
#undef MmGetSystemAddressForMdl
#endif

#ifdef MmGetMdlVirtualAddress
#undef MmGetMdlVirtualAddress
#endif

#if ( defined(NDIS_WRAPPER) || defined(NDIS60_MINIPORT) || defined(NDIS60) || defined(NDIS_SUPPORT_NDIS6) )
#define MmGetMdlVirtualAddress(pMdl)                            \
            ((pMdl == NULL) ? (NULL) : ((PVOID)((LPBYTE)((pMdl)->StartVa) + (pMdl)->ByteOffset)))
#else  //  ( defined(NDIS_WRAPPER) || defined(NDIS60_MINIPORT) || defined(NDIS60) || defined(NDIS_SUPPORT_NDIS6) )
#define MmGetMdlVirtualAddress(pMdl)                            \
            ((pMdl == NULL) ? (NULL) : ((pMdl)->StartVa))
#endif  //  ( defined(NDIS_WRAPPER) || defined(NDIS60_MINIPORT) || defined(NDIS60) || defined(NDIS_SUPPORT_NDIS6) )

#define MmGetSystemAddressForMdl(pMdl)                  MmGetMdlVirtualAddress(pMdl)
#define MmGetSystemAddressForMdlSafe(pMdl, pPriority)   MmGetMdlVirtualAddress(pMdl)

#ifdef MmGetMdlByteCount
#undef MmGetMdlByteCount
#endif

#define MmGetMdlByteCount(pMdl)                                 \
            ((pMdl == NULL) ? (0x00) : ((pMdl)->ByteCount))


#ifdef MmGetMdlByteOffset
#undef MmGetMdlByteOffset
#endif

#define MmGetMdlByteOffset(pMdl)                                \
            ((pMdl == NULL) ? (0x00) : ((pMdl)->ByteOffset))

#define MmBuildMdlForNonPagedPool(pMdl)                 (void)0

#define MmAllocateNonCachedMemory(Length)               VirtualAlloc(NULL, Length, MEM_COMMIT, PAGE_READWRITE | PAGE_NOCACHE)
#define MmAllocateContiguousMemory(Length, HighAddr)    NULL // don't support contig in CE yet
#define MmFreeNonCachedMemory(VirtualAddress, Length)   VirtualFree(VirtualAddress, 0, MEM_RELEASE)
#define MmFreeContiguousMemory(VirtualAddress)          (void)0



////////////////////////////////////
//      PsXxx emulation
////////////////////////////////////

DWORD
CePsCreateSystemThread(
    OUT PHANDLE  pThreadHandle,
    IN  PVOID    startFunction,
    IN  PVOID    startParameter
    );

#define PsGetCurrentThread()        (PVOID)GetCurrentThreadId()
#define PsCreateSystemThread(pThreadHandle, dwAccessFlags, unused1, processHandle, unused2, startFunction, startParameter) \
    CePsCreateSystemThread(pThreadHandle, startFunction, startParameter)


#ifndef NOTHING
#define NOTHING (void)0
#endif

#define KeFlushIoBuffers(_Mdl, _ReadOperation, _DmaOperation) CacheSync(CACHE_SYNC_DISCARD)

/* debug.c */
VOID DbgBreakPoint(VOID);

/* this is a standard NT DDK function
   and should not be defined anywhere else */
#if defined(BINARY_COMPATIBLE) && defined(DbgPrint)
#undef DbgPrint
#endif

#if !defined(DbgPrint)
ULONG
DbgPrint(
  IN PCHAR DebugMessage,
  ...
);
#endif

///// registry.c

BOOL
GetRegistryValue(
    IN  HKEY     hKey,
    IN  TCHAR   *tszSubKeyName, OPTIONAL
    IN  TCHAR   *tszValueName,
    __out_bcount(cbValue) OUT   LPBYTE   pValue,
    IN  DWORD    cbValue,
    IN  DWORD    dwRequiredType
    );


BOOL
GetRegistryStringValue(
    IN  HKEY     hKey,
    IN  TCHAR   *tszSubKeyName, OPTIONAL
    IN  TCHAR   *tszValueName,
    __out_bcount(cbValue) OUT   TCHAR   *tszValue,
    IN  DWORD    cbValue);

BOOL
GetRegistryMultiSzValue(
    IN  HKEY     hKey,
    IN  TCHAR   *tszSubKeyName, OPTIONAL
    IN  TCHAR   *tszValueName,
    __out_bcount(cbValue) OUT   TCHAR   *tszValue,
    IN  DWORD    cbValue);

BOOL
GetRegistryDwordValue(
    IN  HKEY     hKey,
    IN  TCHAR   *tszSubKeyName, OPTIONAL
    IN  TCHAR   *tszValueName,
    OUT DWORD   *pdwValue);

BOOL
SetRegistryDwordValue(
    IN  HKEY     hKey,
    IN  TCHAR   *tszSubKeyName, OPTIONAL
    IN  TCHAR   *tszValueName,
    IN  DWORD    dwValue);


// from ntrtl.h
typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;


typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS, *PTIME_FIELDS;


VOID
RtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    );

BOOLEAN
RtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    );

VOID
RtlInitString(
  OUT PSTRING DestinationString,
  IN PCSZ SourceString OPTIONAL
);


VOID
RtlFreeAnsiString(
    PANSI_STRING AnsiString
    );

VOID
RtlInitAnsiString(
  OUT PANSI_STRING DestinationString,
  IN PCSZ SourceString OPTIONAL
);


VOID
RtlInitUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PCWSTR SourceString OPTIONAL
);

BOOLEAN
RtlCreateUnicodeString(
  OUT   PUNICODE_STRING DestinationString,
  IN    PCWSTR          SourceString
  );

VOID
RtlFreeUnicodeString(
  IN PUNICODE_STRING UnicodeString
);


NTSTATUS
RtlAnsiStringToUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PANSI_STRING SourceString,
  IN BOOLEAN AllocateDestinationString
);

NTSTATUS
RtlUnicodeStringToAnsiString(
  IN OUT PANSI_STRING DestinationString,
  IN PUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString
);


NTSTATUS
RtlUpcaseUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PUNICODE_STRING SourceString,
  IN BOOLEAN AllocateDestinationString
);

NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    );

BOOLEAN
RtlEqualUnicodeString(
  IN PUNICODE_STRING String1,
  IN PUNICODE_STRING String2,
  IN BOOLEAN CaseInSensitive
);

VOID
RtlCopyUnicodeString(
  OUT PUNICODE_STRING DestinationString,
  IN PUNICODE_STRING SourceString OPTIONAL
);


NTSTATUS
RtlAppendUnicodeToString(
  IN PUNICODE_STRING Destination,
  IN PWSTR Source OPTIONAL
);

NTSTATUS
RtlUnicodeStringToInteger(
  IN PUNICODE_STRING String,
  IN ULONG           Base,
  OUT PINT           pInteger
);

NTSTATUS
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PUNICODE_STRING Source
    );

BOOLEAN
RtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSTR SourceString
    );

NTSTATUS
RtlCharToInteger(
  IN    PCHAR           String,
  IN    ULONG           Base,
  OUT   PINT            pInteger
);

LONG
RtlCompareUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

BOOLEAN
RtlEqualDomainName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    );

NTSTATUS
RtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

VOID
RtlRunEncodeUnicodeString(
    PUCHAR          Seed        OPTIONAL,
    PUNICODE_STRING String
    );

VOID
RtlRunDecodeUnicodeString(
    UCHAR           Seed,
    PUNICODE_STRING String
    );

VOID
RtlAssert(
  IN PVOID FailedAssertion,
  IN PVOID FileName,
  IN ULONG LineNumber,
  IN PCHAR Message OPTIONAL
);

#if defined(x86)
#define HalGetDmaAlignmentRequirement() ((ULONG)1)
#else
#define HalGetDmaAlignmentRequirement() ((ULONG)sizeof(ULONGLONG))
#endif /* x86 */

//
// _MM_PAGE_PRIORITY_ provides a method for the system to handle requests
// intelligently in low resource conditions.
//
// LowPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is low on resources.  An example of
// this could be for a non-critical network connection where the driver can
// handle the failure case when system resources are close to being depleted.
//
// NormalPagePriority should be used when it is acceptable to the driver for the
// mapping request to fail if the system is very low on resources.  An example
// of this could be for a non-critical local filesystem request.
//
// HighPagePriority should be used when it is unacceptable to the driver for the
// mapping request to fail unless the system is completely out of resources.
// An example of this would be the paging file path in a driver.
//

// begin_ntndis

typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;


//SID And ACL functions
BOOL
ConvertStringSidToSidW(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid
    );


PVOID
RtlFreeSid(
    IN PSID Sid
    );

NTSTATUS
RtlAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority0,
    IN ULONG SubAuthority1,
    IN ULONG SubAuthority2,
    IN ULONG SubAuthority3,
    IN ULONG SubAuthority4,
    IN ULONG SubAuthority5,
    IN ULONG SubAuthority6,
    IN ULONG SubAuthority7,
    OUT PSID *Sid
    );

PULONG                                              // ntifs
RtlSubAuthoritySid (                                // ntifs
    PSID Sid,                                       // ntifs
    ULONG SubAuthority                              // ntifs
    );                                              // ntifs

PUCHAR
RtlSubAuthorityCountSid (
    PSID Sid
    );

// begin_ntifs
ULONG
RtlLengthSid (
    PSID Sid
    );

NTSTATUS
RtlCopySid (
    ULONG DestinationSidLength,
    PSID DestinationSid,
    PSID SourceSid
    );

ULONG
RtlLengthRequiredSid (
    ULONG SubAuthorityCount
    );

// added from ntrtl_x.h

//
// This enumerated type is used as the function return value of the function
// that is used to search the tree for a key. FoundNode indicates that the
// function found the key. Insert as left indicates that the key was not found
// and the node should be inserted as the left child of the parent. Insert as
// right indicates that the key was not found and the node should be inserted
//  as the right child of the parent.
//
typedef enum _TABLE_SEARCH_RESULT{
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

//
//  The results of a compare can be less than, equal, or greater than.
//
/*
typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;
*/

//
//  Define the Avl version of the generic table package.  Note a generic table
//  should really be an opaque type.  We provide routines to manipulate the structure.
//
//  A generic table is package for inserting, deleting, and looking up elements
//  in a table (e.g., in a symbol table).  To use this package the user
//  defines the structure of the elements stored in the table, provides a
//  comparison function, a memory allocation function, and a memory
//  deallocation function.
//
//  Note: the user compare function must impose a complete ordering among
//  all of the elements, and the table does not allow for duplicate entries.
//

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

struct _RTL_AVL_TABLE;

//
//  The comparison function takes as input pointers to elements containing
//  user defined structures and returns the results of comparing the two
//  elements.
//

typedef
RTL_GENERIC_COMPARE_RESULTS
(NTAPI *PRTL_AVL_COMPARE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    );

//
//  The allocation function is called by the generic table package whenever
//  it needs to allocate memory for the table.
//

typedef
PVOID
(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    CLONG ByteSize
    );

//
//  The deallocation function is called by the generic table package whenever
//  it needs to deallocate memory from the table that was allocated by calling
//  the user supplied allocation function.
//

typedef
VOID
(NTAPI *PRTL_AVL_FREE_ROUTINE) (
    struct _RTL_AVL_TABLE *Table,
    PVOID Buffer
    );

//
//  The match function takes as input the user data to be matched and a pointer
//  to some match data, which was passed along with the function pointer.  It
//  returns TRUE for a match and FALSE for no match.
//
//  RTL_AVL_MATCH_FUNCTION returns
//      STATUS_SUCCESS if the IndexRow matches
//      STATUS_NO_MATCH if the IndexRow does not match, but the enumeration should
//          continue
//      STATUS_NO_MORE_MATCHES if the IndexRow does not match, and the enumeration
//          should terminate
//


typedef
NTSTATUS
(NTAPI *PRTL_AVL_MATCH_FUNCTION) (
    struct _RTL_AVL_TABLE *Table,
    PVOID UserData,
    PVOID MatchData
    );

//
//  Define the balanced tree links and Balance field.  (No Rank field
//  defined at this time.)
//
//  Callers should treat this structure as opaque!
//
//  The root of a balanced binary tree is not a real node in the tree
//  but rather points to a real node which is the root.  It is always
//  in the table below, and its fields are used as follows:
//
//      Parent      Pointer to self, to allow for detection of the root.
//      LeftChild   NULL
//      RightChild  Pointer to real root
//      Balance     Undefined, however it is set to a convenient value
//                  (depending on the algorithm) prior to rebalancing
//                  in insert and delete routines.
//

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS;
typedef RTL_BALANCED_LINKS *PRTL_BALANCED_LINKS;

//
//  To use the generic table package the user declares a variable of type
//  GENERIC_TABLE and then uses the routines described below to initialize
//  the table and to manipulate the table.  Note that the generic table
//  should really be an opaque type.
//

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE;
typedef RTL_AVL_TABLE *PRTL_AVL_TABLE;


NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl (
    PRTL_AVL_TABLE Table
    );

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory (
    IN PRTL_AVL_TABLE Table,
    IN PRTL_AVL_MATCH_FUNCTION MatchFunction,
    IN PVOID MatchData,
    IN ULONG NextFlag,
    IN OUT PVOID *RestartKey,
    IN OUT PULONG DeleteCount,
    IN OUT PVOID Buffer
    );

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl (
    PRTL_AVL_TABLE Table,
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_AVL_FREE_ROUTINE FreeRoutine,
    PVOID TableContext
    );

#ifdef __cplusplus
}
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\nuiouser.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name:

    nuiouser.h

Abstract:

    Constants and types to access the NDISUIO driver.
    Users must also include ntddndis.h

Environment:

    User/Kernel mode.

Revision History:

    
    4/12/2000    Created
    03/15/2001   CE port.

--*/

#pragma once

#ifndef __NUIOUSER__H
#define __NUIOUSER__H

#ifdef UNDER_CE
#define NDISUIO_DEVICE_NAME          TEXT("UIO1:")
#endif

#include <winioctl.h>

#define FSCTL_NDISUIO_BASE      FILE_DEVICE_NETWORK

#define _NDISUIO_CTL_CODE(_Function, _Method, _Access)  \
            CTL_CODE(FSCTL_NDISUIO_BASE, _Function, _Method, _Access)

#define IOCTL_NDISUIO_OPEN_DEVICE       \
            _NDISUIO_CTL_CODE(0x200, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_QUERY_OID_VALUE   \
            _NDISUIO_CTL_CODE(0x201, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_SET_OID_VALUE     \
            _NDISUIO_CTL_CODE(0x205, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_SET_ETHER_TYPE    \
            _NDISUIO_CTL_CODE(0x202, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_QUERY_BINDING     \
            _NDISUIO_CTL_CODE(0x203, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_BIND_WAIT         \
            _NDISUIO_CTL_CODE(0x204, METHOD_BUFFERED, FILE_ANY_ACCESS)


#ifdef UNDER_CE

#define IOCTL_NDISUIO_OPEN_WRITE_DEVICE     \
            _NDISUIO_CTL_CODE(0x206, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_REQUEST_NOTIFICATION  \
            _NDISUIO_CTL_CODE(0x207, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_CANCEL_NOTIFICATION   \
            _NDISUIO_CTL_CODE(0x208, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_NDISUIO_NIC_STATISTICS        \
            _NDISUIO_CTL_CODE(0x209, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CANCEL_READ                   \
            _NDISUIO_CTL_CODE(0x20a, METHOD_BUFFERED, FILE_ANY_ACCESS)

#ifdef NATIVEWIFI
#define IOCTL_NDISUIO_NATIVEWIFI_STATISTICS                 \
            _NDISUIO_CTL_CODE(0x20b, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif

#define IOCTL_NDISUIO_OPEN_DEVICE_EX    \
            _NDISUIO_CTL_CODE(0x20c, METHOD_BUFFERED, FILE_ANY_ACCESS)
            
#endif


//
// Structures and Macros for IOCTL_NDISUIO_OPEN_DEVICE_EX
// New versions can be extended from the following definitions
//
#define NDISUIO_FILE_OPEN_VERSION_0  0
#define NDISUIO_FILE_OPEN_VERSION_1  1

typedef struct _NDISUIO_FILE_OPEN_PARA_V1 
{
    ULONG DeviceNameLength;
#ifdef UNDER_CE
    DWORD dwNotificationTypes;  // bit wise OR of NDISUIO_NOTIFICATION_XXX
#endif
    UCHAR DeviceName[sizeof(ULONG)];
} NDISUIO_FILE_OPEN_PARA_V1, * PNDISUIO_FILE_OPEN_PARA_V1;

typedef struct _NDISUIO_FILE_OPEN 
{
    ULONG Version;
    union
    {
        NDISUIO_FILE_OPEN_PARA_V1 FileOpenParaV1;  
    };
} NDISUIO_FILE_OPEN, * PNDISUIO_FILE_OPEN;

//
// Packet types
//
typedef enum _NDISUIO_QUEUED_PACKET_TYPE
{
    NDISUIO_DATA_PACKET = 0,
    NDISUIO_MEDIA_CONNECTED,
    NDISUIO_MEDIA_DISCONNECTED,

#ifdef UNDER_CE
    NDISUIO_RESET_START,
    NDISUIO_RESET_END,
    NDISUIO_MEDIA_SPECIFIC_NOTIFICATION,    
    NDISUIO_WW_ASYNC_RESPONSE,    
    NDISUIO_WW_INDICATION,
    NDISUIO_DEVICE_POWER_UP,
    NDISUIO_DEVICE_POWER_DOWN,
    NDISUIO_DEVICE_MAXIMUM
#endif    
} NDISUIO_QUEUED_PACKET_TYPE, * PNDISUIO_QUEUED_PACKET_TYPE;

//
// Read buffer for NDISUIO_FILE_OPEN_VERSION_1 and above
//
typedef struct _NDISUIO_IRP_READ_BUFFER 
{
    NDISUIO_QUEUED_PACKET_TYPE BufferType;
    UCHAR PacketContent [sizeof(ULONG)];
} NDISUIO_IRP_READ_BUFFER, * PNDISUIO_IRP_READ_BUFFER;


//
//  Structure to go with IOCTL_NDISUIO_QUERY_OID_VALUE.
//  The Data part is of variable length, determined by
//  the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISUIO_QUERY_OID
{
    NDIS_OID        Oid;

#ifdef UNDER_CE
    //
    //  In CE land app is allowed to query without having to do
    //  IOCTL_NDISUIO_OPEN_DEVICE
    //  Hence the device name to query argument needed..
    //  For app that does IOCTL_NDISUIO_OPEN_DEVICE this argument
    //  is then not necessary..
    //

    PTCHAR          ptcDeviceName;  
#endif

    UCHAR           Data[sizeof(ULONG)];

} NDISUIO_QUERY_OID, *PNDISUIO_QUERY_OID;

//
//  Structure to go with IOCTL_NDISUIO_SET_OID_VALUE.
//  The Data part is of variable length, determined
//  by the input buffer length passed to DeviceIoControl.
//
typedef struct _NDISUIO_SET_OID
{
    NDIS_OID        Oid;

#ifdef UNDER_CE
    //
    //  In CE land app is allowed to set without having to do
    //  IOCTL_NDISUIO_OPEN_DEVICE
    //  Hence the device name to query argument needed..
    //  For app that does IOCTL_NDISUIO_OPEN_DEVICE this argument
    //  is then not necessary..
    //

    PTCHAR          ptcDeviceName;  
#endif

    UCHAR           Data[sizeof(ULONG)];

} NDISUIO_SET_OID, *PNDISUIO_SET_OID;


//
//  Structure to go with IOCTL_NDISUIO_QUERY_BINDING.
//  The input parameter is BindingIndex, which is the
//  index into the list of bindings active at the driver.
//  On successful completion, we get back a device name
//  and a device descriptor (friendly name).
//
typedef struct _NDISUIO_QUERY_BINDING
{
    ULONG           BindingIndex;       // 0-based binding number
    ULONG           DeviceNameOffset;   // from start of this struct
    ULONG           DeviceNameLength;   // in bytes
    ULONG           DeviceDescrOffset;  // from start of this struct
    ULONG           DeviceDescrLength;  // in bytes

} NDISUIO_QUERY_BINDING, *PNDISUIO_QUERY_BINDING;



#ifdef UNDER_CE

//
//  These are from \nt\public\internal\net\inc\ndispnp.h
//  Since CE does not support NdisQueryStatistics(), so NDISUIO 
//  will do the job via IOCTL_NDISUIO_NIC_STATISTICS ioctl call.
//

#define MEDIA_STATE_CONNECTED       0
#define MEDIA_STATE_DISCONNECTED    1
#define MEDIA_STATE_UNKNOWN         -1

#define DEVICE_STATE_CONNECTED      1
#define DEVICE_STATE_DISCONNECTED   0

typedef struct
{
    ULONG               Size;               //  Of this structure.
    PTCHAR              ptcDeviceName;      //  The device name to be queried..
    ULONG               DeviceState;        //  DEVICE_STATE_XXX above
    ULONG               MediaType;          //  NdisMediumXXX
    ULONG               MediaState;         //  MEDIA_STATE_XXX above
    ULONG               PhysicalMediaType;
    ULONG               LinkSpeed;          //  In 100bits/s. 10Mb/s = 100000
    ULONGLONG           PacketsSent;
    ULONGLONG           PacketsReceived;
    ULONG               InitTime;           //  In milliseconds
    ULONG               ConnectTime;        //  In seconds
    ULONGLONG           BytesSent;          //  0 - Unknown (or not supported)
    ULONGLONG           BytesReceived;      //  0 - Unknown (or not supported)
    ULONGLONG           DirectedBytesReceived;
    ULONGLONG           DirectedPacketsReceived;
    ULONG               PacketsReceiveErrors;
    ULONG               PacketsSendErrors;
    ULONG               ResetCount;
    ULONG               MediaSenseConnectCount;
    ULONG               MediaSenseDisconnectCount;

} NIC_STATISTICS, *PNIC_STATISTICS;


#ifdef UNDER_CE
typedef struct
{
    ULONG               Size;               //  Of this structure.
    PTCHAR              ptcDeviceName;      //  The device name to be queried..
    ULONG               PhysicalMediaType;  
    BOOL                bStationMode;       //  if PhysicalMediaType == NdisPhysicalMediumNativeWifi
                                            //  then bStationMode indicates is is currently operating
                                            //  as Station mode.
    ULONG               ulRSSI;             //  If NWIFI and STA mode then ulRSSI is queried.

    ULONG               Reserved[32];       //  For future...

} NATIVEWIFI_STATISTICS, *PNATIVEWIFI_STATISTICS;
#endif


//
//  This is for device notification (Media State, bind/unbind etc).
//  Because CE does not have WMI..
//

#define NDISUIO_NOTIFICATION_RESET_START                    0x00000001
#define NDISUIO_NOTIFICATION_RESET_END                      0x00000002
#define NDISUIO_NOTIFICATION_MEDIA_CONNECT                  0x00000004
#define NDISUIO_NOTIFICATION_MEDIA_DISCONNECT               0x00000008
#define NDISUIO_NOTIFICATION_BIND                           0x00000010
#define NDISUIO_NOTIFICATION_UNBIND                         0x00000020
#define NDISUIO_NOTIFICATION_MEDIA_SPECIFIC_NOTIFICATION    0x00000040
#define NDISUIO_NOTIFICATION_WW_ASYNC_RESPONSE              0x00000080
#define NDISUIO_NOTIFICATION_WW_INDICATION                  0x00000100
#define NDISUIO_NOTIFICATION_DEVICE_POWER_UP                0x00000200
#define NDISUIO_NOTIFICATION_DEVICE_POWER_DOWN              0x00000400


typedef struct
{
    DWORD   dwNotificationType;
    TCHAR   ptcDeviceName[MAX_PATH];
    UINT    uiOffsetToStatusBuffer;     //  For notifications that come with status.
    UINT    uiStatusBufferSize;         //  Offset from the beginning of the struct.                                        
                                        //  e.g. NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
    
}   NDISUIO_DEVICE_NOTIFICATION, *PNDISUIO_DEVICE_NOTIFICATION;


typedef struct
{
    HANDLE  hMsgQueue;
    DWORD   dwNotificationTypes;

}   NDISUIO_REQUEST_NOTIFICATION, *PNDISUIO_REQUEST_NOTIFICATION;


#endif
 
#endif // __NUIOUSER__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\oaidl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Mar 05 10:21:02 2007
 */
/* Compiler settings for ..\oaidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __oaidl_h__
#define __oaidl_h__

/* Forward Declarations */ 

#ifndef __ICreateTypeInfo_FWD_DEFINED__
#define __ICreateTypeInfo_FWD_DEFINED__
typedef interface ICreateTypeInfo ICreateTypeInfo;
#endif 	/* __ICreateTypeInfo_FWD_DEFINED__ */


#ifndef __ICreateTypeInfo2_FWD_DEFINED__
#define __ICreateTypeInfo2_FWD_DEFINED__
typedef interface ICreateTypeInfo2 ICreateTypeInfo2;
#endif 	/* __ICreateTypeInfo2_FWD_DEFINED__ */


#ifndef __ICreateTypeLib_FWD_DEFINED__
#define __ICreateTypeLib_FWD_DEFINED__
typedef interface ICreateTypeLib ICreateTypeLib;
#endif 	/* __ICreateTypeLib_FWD_DEFINED__ */


#ifndef __ICreateTypeLib2_FWD_DEFINED__
#define __ICreateTypeLib2_FWD_DEFINED__
typedef interface ICreateTypeLib2 ICreateTypeLib2;
#endif 	/* __ICreateTypeLib2_FWD_DEFINED__ */


#ifndef __IDispatch_FWD_DEFINED__
#define __IDispatch_FWD_DEFINED__
typedef interface IDispatch IDispatch;
#endif 	/* __IDispatch_FWD_DEFINED__ */


#ifndef __IEnumVARIANT_FWD_DEFINED__
#define __IEnumVARIANT_FWD_DEFINED__
typedef interface IEnumVARIANT IEnumVARIANT;
#endif 	/* __IEnumVARIANT_FWD_DEFINED__ */


#ifndef __ITypeComp_FWD_DEFINED__
#define __ITypeComp_FWD_DEFINED__
typedef interface ITypeComp ITypeComp;
#endif 	/* __ITypeComp_FWD_DEFINED__ */


#ifndef __ITypeInfo_FWD_DEFINED__
#define __ITypeInfo_FWD_DEFINED__
typedef interface ITypeInfo ITypeInfo;
#endif 	/* __ITypeInfo_FWD_DEFINED__ */


#ifndef __ITypeInfo2_FWD_DEFINED__
#define __ITypeInfo2_FWD_DEFINED__
typedef interface ITypeInfo2 ITypeInfo2;
#endif 	/* __ITypeInfo2_FWD_DEFINED__ */


#ifndef __ITypeLib_FWD_DEFINED__
#define __ITypeLib_FWD_DEFINED__
typedef interface ITypeLib ITypeLib;
#endif 	/* __ITypeLib_FWD_DEFINED__ */


#ifndef __ITypeLib2_FWD_DEFINED__
#define __ITypeLib2_FWD_DEFINED__
typedef interface ITypeLib2 ITypeLib2;
#endif 	/* __ITypeLib2_FWD_DEFINED__ */


#ifndef __ITypeChangeEvents_FWD_DEFINED__
#define __ITypeChangeEvents_FWD_DEFINED__
typedef interface ITypeChangeEvents ITypeChangeEvents;
#endif 	/* __ITypeChangeEvents_FWD_DEFINED__ */


#ifndef __IErrorInfo_FWD_DEFINED__
#define __IErrorInfo_FWD_DEFINED__
typedef interface IErrorInfo IErrorInfo;
#endif 	/* __IErrorInfo_FWD_DEFINED__ */


#ifndef __ICreateErrorInfo_FWD_DEFINED__
#define __ICreateErrorInfo_FWD_DEFINED__
typedef interface ICreateErrorInfo ICreateErrorInfo;
#endif 	/* __ICreateErrorInfo_FWD_DEFINED__ */


#ifndef __ISupportErrorInfo_FWD_DEFINED__
#define __ISupportErrorInfo_FWD_DEFINED__
typedef interface ISupportErrorInfo ISupportErrorInfo;
#endif 	/* __ISupportErrorInfo_FWD_DEFINED__ */


#ifndef __ITypeFactory_FWD_DEFINED__
#define __ITypeFactory_FWD_DEFINED__
typedef interface ITypeFactory ITypeFactory;
#endif 	/* __ITypeFactory_FWD_DEFINED__ */


#ifndef __ITypeMarshal_FWD_DEFINED__
#define __ITypeMarshal_FWD_DEFINED__
typedef interface ITypeMarshal ITypeMarshal;
#endif 	/* __ITypeMarshal_FWD_DEFINED__ */


#ifndef __IRecordInfo_FWD_DEFINED__
#define __IRecordInfo_FWD_DEFINED__
typedef interface IRecordInfo IRecordInfo;
#endif 	/* __IRecordInfo_FWD_DEFINED__ */


#ifndef __IPropertyStorage_FWD_DEFINED__
#define __IPropertyStorage_FWD_DEFINED__
typedef interface IPropertyStorage IPropertyStorage;
#endif 	/* __IPropertyStorage_FWD_DEFINED__ */


#ifndef __IPropertySetStorage_FWD_DEFINED__
#define __IPropertySetStorage_FWD_DEFINED__
typedef interface IPropertySetStorage IPropertySetStorage;
#endif 	/* __IPropertySetStorage_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_FWD_DEFINED__
#define __IEnumSTATPROPSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSTG IEnumSTATPROPSTG;
#endif 	/* __IEnumSTATPROPSTG_FWD_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_FWD_DEFINED__
#define __IEnumSTATPROPSETSTG_FWD_DEFINED__
typedef interface IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;
#endif 	/* __IEnumSTATPROPSETSTG_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_oaidl_0000 */
/* [local] */ 

//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//
#if ( _MSC_VER >= 800 ) && (! defined (UNDER_CE))
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif




















extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_v0_0_s_ifspec;

#ifndef __IOleAutomationTypes_INTERFACE_DEFINED__
#define __IOleAutomationTypes_INTERFACE_DEFINED__

/* interface IOleAutomationTypes */
/* [auto_handle][unique][version] */ 

typedef CY CURRENCY;

typedef struct tagSAFEARRAYBOUND
    {
    ULONG cElements;
    LONG lLbound;
    }	SAFEARRAYBOUND;

typedef struct tagSAFEARRAYBOUND __RPC_FAR *LPSAFEARRAYBOUND;

/* the following is what MIDL knows how to remote */
typedef /* [unique] */ struct _wireVARIANT __RPC_FAR *wireVARIANT;

typedef /* [unique] */ struct _wireBRECORD __RPC_FAR *wireBRECORD;

typedef struct _wireSAFEARR_BSTR
    {
    ULONG Size;
    /* [ref][size_is] */ wireBSTR __RPC_FAR *aBstr;
    }	SAFEARR_BSTR;

typedef struct _wireSAFEARR_UNKNOWN
    {
    ULONG Size;
    /* [ref][size_is] */ IUnknown __RPC_FAR *__RPC_FAR *apUnknown;
    }	SAFEARR_UNKNOWN;

typedef struct _wireSAFEARR_DISPATCH
    {
    ULONG Size;
    /* [ref][size_is] */ IDispatch __RPC_FAR *__RPC_FAR *apDispatch;
    }	SAFEARR_DISPATCH;

typedef struct _wireSAFEARR_VARIANT
    {
    ULONG Size;
    /* [ref][size_is] */ wireVARIANT __RPC_FAR *aVariant;
    }	SAFEARR_VARIANT;

typedef struct _wireSAFEARR_BRECORD
    {
    ULONG Size;
    /* [ref][size_is] */ wireBRECORD __RPC_FAR *aRecord;
    }	SAFEARR_BRECORD;

typedef struct _wireSAFEARR_HAVEIID
    {
    ULONG Size;
    /* [ref][size_is] */ IUnknown __RPC_FAR *__RPC_FAR *apUnknown;
    IID iid;
    }	SAFEARR_HAVEIID;

typedef /* [v1_enum] */ 
enum tagSF_TYPE
    {	SF_ERROR	= VT_ERROR,
	SF_I1	= VT_I1,
	SF_I2	= VT_I2,
	SF_I4	= VT_I4,
	SF_I8	= VT_I8,
	SF_BSTR	= VT_BSTR,
	SF_UNKNOWN	= VT_UNKNOWN,
	SF_DISPATCH	= VT_DISPATCH,
	SF_VARIANT	= VT_VARIANT,
	SF_RECORD	= VT_RECORD,
	SF_HAVEIID	= VT_UNKNOWN | VT_RESERVED
    }	SF_TYPE;

typedef struct _wireSAFEARRAY_UNION
    {
    ULONG sfType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL_IOleAutomationTypes_0001
        {
        /* [case()] */ SAFEARR_BSTR BstrStr;
        /* [case()] */ SAFEARR_UNKNOWN UnknownStr;
        /* [case()] */ SAFEARR_DISPATCH DispatchStr;
        /* [case()] */ SAFEARR_VARIANT VariantStr;
        /* [case()] */ SAFEARR_BRECORD RecordStr;
        /* [case()] */ SAFEARR_HAVEIID HaveIidStr;
        /* [case()] */ BYTE_SIZEDARR ByteStr;
        /* [case()] */ WORD_SIZEDARR WordStr;
        /* [case()] */ DWORD_SIZEDARR LongStr;
        /* [case()] */ HYPER_SIZEDARR HyperStr;
        }	u;
    }	SAFEARRAYUNION;

typedef /* [unique] */ struct _wireSAFEARRAY
    {
    USHORT cDims;
    USHORT fFeatures;
    ULONG cbElements;
    ULONG cLocks;
    SAFEARRAYUNION uArrayStructs;
    /* [size_is] */ SAFEARRAYBOUND rgsabound[ 1 ];
    }	__RPC_FAR *wireSAFEARRAY;

typedef /* [unique] */ wireSAFEARRAY __RPC_FAR *wirePSAFEARRAY;

typedef struct tagSAFEARRAY
    {
    USHORT cDims;
    USHORT fFeatures;
    ULONG cbElements;
    ULONG cLocks;
    PVOID pvData;
    SAFEARRAYBOUND rgsabound[ 1 ];
    }	SAFEARRAY;

typedef /* [wire_marshal] */ SAFEARRAY __RPC_FAR *LPSAFEARRAY;

#define	FADF_AUTO	( 0x1 )

#define	FADF_STATIC	( 0x2 )

#define	FADF_EMBEDDED	( 0x4 )

#define	FADF_FIXEDSIZE	( 0x10 )

#define	FADF_RECORD	( 0x20 )

#define	FADF_HAVEIID	( 0x40 )

#define	FADF_HAVEVARTYPE	( 0x80 )

#define	FADF_BSTR	( 0x100 )

#define	FADF_UNKNOWN	( 0x200 )

#define	FADF_DISPATCH	( 0x400 )

#define	FADF_VARIANT	( 0x800 )

#define	FADF_RESERVED	( 0xf008 )

/* VARIANT STRUCTURE
 *
 *  VARTYPE vt;
 *  WORD wReserved1;
 *  WORD wReserved2;
 *  WORD wReserved3;
 *  union {
 *    LONGLONG       VT_I8
 *    LONG           VT_I4
 *    BYTE           VT_UI1
 *    SHORT          VT_I2
 *    FLOAT          VT_R4
 *    DOUBLE         VT_R8
 *    VARIANT_BOOL   VT_BOOL
 *    SCODE          VT_ERROR
 *    CY             VT_CY
 *    DATE           VT_DATE
 *    BSTR           VT_BSTR
 *    IUnknown *     VT_UNKNOWN
 *    IDispatch *    VT_DISPATCH
 *    SAFEARRAY *    VT_ARRAY
 *    BYTE *         VT_BYREF|VT_UI1
 *    SHORT *        VT_BYREF|VT_I2
 *    LONG *         VT_BYREF|VT_I4
 *    LONGLONG *     VT_BYREF|VT_I8
 *    FLOAT *        VT_BYREF|VT_R4
 *    DOUBLE *       VT_BYREF|VT_R8
 *    VARIANT_BOOL * VT_BYREF|VT_BOOL
 *    SCODE *        VT_BYREF|VT_ERROR
 *    CY *           VT_BYREF|VT_CY
 *    DATE *         VT_BYREF|VT_DATE
 *    BSTR *         VT_BYREF|VT_BSTR
 *    IUnknown **    VT_BYREF|VT_UNKNOWN
 *    IDispatch **   VT_BYREF|VT_DISPATCH
 *    SAFEARRAY **   VT_BYREF|VT_ARRAY
 *    VARIANT *      VT_BYREF|VT_VARIANT
 *    PVOID          VT_BYREF (Generic ByRef)
 *    CHAR           VT_I1
 *    USHORT         VT_UI2
 *    ULONG          VT_UI4
 *    ULONGLONG      VT_UI8
 *    INT            VT_INT
 *    UINT           VT_UINT
 *    DECIMAL *      VT_BYREF|VT_DECIMAL
 *    CHAR *         VT_BYREF|VT_I1
 *    USHORT *       VT_BYREF|VT_UI2
 *    ULONG *        VT_BYREF|VT_UI4
 *    ULONGLONG *    VT_BYREF|VT_UI8
 *    INT *          VT_BYREF|VT_INT
 *    UINT *         VT_BYREF|VT_UINT
 *  }
 */
#if (__STDC__ && !defined(_FORCENAMELESSUNION)) || defined(NONAMELESSUNION)
#define __VARIANT_NAME_1 n1
#define __VARIANT_NAME_2 n2
#define __VARIANT_NAME_3 n3
#define __VARIANT_NAME_4 brecVal
#else
#define __tagVARIANT
#define __VARIANT_NAME_1
#define __VARIANT_NAME_2
#define __VARIANT_NAME_3
#define __tagBRECORD
#define __VARIANT_NAME_4
#endif
typedef /* [wire_marshal] */ struct tagVARIANT VARIANT;

struct tagVARIANT
    {
    union 
        {
        struct __tagVARIANT
            {
            VARTYPE vt;
            WORD wReserved1;
            WORD wReserved2;
            WORD wReserved3;
            union 
                {
                LONGLONG llVal;
                LONG lVal;
                BYTE bVal;
                SHORT iVal;
                FLOAT fltVal;
                DOUBLE dblVal;
                VARIANT_BOOL boolVal;
                _VARIANT_BOOL bool;
                SCODE scode;
                CY cyVal;
                DATE date;
                BSTR bstrVal;
                IUnknown __RPC_FAR *punkVal;
                IDispatch __RPC_FAR *pdispVal;
                SAFEARRAY __RPC_FAR *parray;
                BYTE __RPC_FAR *pbVal;
                SHORT __RPC_FAR *piVal;
                LONG __RPC_FAR *plVal;
                LONGLONG __RPC_FAR *pllVal;
                FLOAT __RPC_FAR *pfltVal;
                DOUBLE __RPC_FAR *pdblVal;
                VARIANT_BOOL __RPC_FAR *pboolVal;
                _VARIANT_BOOL __RPC_FAR *pbool;
                SCODE __RPC_FAR *pscode;
                CY __RPC_FAR *pcyVal;
                DATE __RPC_FAR *pdate;
                BSTR __RPC_FAR *pbstrVal;
                IUnknown __RPC_FAR *__RPC_FAR *ppunkVal;
                IDispatch __RPC_FAR *__RPC_FAR *ppdispVal;
                SAFEARRAY __RPC_FAR *__RPC_FAR *pparray;
                VARIANT __RPC_FAR *pvarVal;
                PVOID byref;
                CHAR cVal;
                USHORT uiVal;
                ULONG ulVal;
                ULONGLONG ullVal;
                INT intVal;
                UINT uintVal;
                DECIMAL __RPC_FAR *pdecVal;
                CHAR __RPC_FAR *pcVal;
                USHORT __RPC_FAR *puiVal;
                ULONG __RPC_FAR *pulVal;
                ULONGLONG __RPC_FAR *pullVal;
                INT __RPC_FAR *pintVal;
                UINT __RPC_FAR *puintVal;
                struct __tagBRECORD
                    {
                    PVOID pvRecord;
                    IRecordInfo __RPC_FAR *pRecInfo;
                    }	__VARIANT_NAME_4;
                }	__VARIANT_NAME_3;
            }	__VARIANT_NAME_2;
        DECIMAL decVal;
        }	__VARIANT_NAME_1;
    };
typedef VARIANT __RPC_FAR *LPVARIANT;

typedef VARIANT VARIANTARG;

typedef VARIANT __RPC_FAR *LPVARIANTARG;

#ifdef MIDL_PASS
typedef const VARIANT __RPC_FAR *REFVARIANT;

#else

#ifndef _REFVARIANT_DEFINED
#define _REFVARIANT_DEFINED
#ifdef __cplusplus
#define REFVARIANT const VARIANT &
#else
#define REFVARIANT const VARIANT * __MIDL_CONST
#endif
#endif

#endif // MIDL_PASS

/* the following is what MIDL knows how to remote */
struct _wireBRECORD
    {
    ULONG fFlags;
    ULONG clSize;
    IRecordInfo __RPC_FAR *pRecInfo;
    /* [size_is] */ byte __RPC_FAR *pRecord;
    };
struct _wireVARIANT
    {
    DWORD clSize;
    DWORD rpcReserved;
    USHORT vt;
    USHORT wReserved1;
    USHORT wReserved2;
    USHORT wReserved3;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ LONGLONG llVal;
        /* [case()] */ LONG lVal;
        /* [case()] */ BYTE bVal;
        /* [case()] */ SHORT iVal;
        /* [case()] */ FLOAT fltVal;
        /* [case()] */ DOUBLE dblVal;
        /* [case()] */ VARIANT_BOOL boolVal;
        /* [case()] */ SCODE scode;
        /* [case()] */ CY cyVal;
        /* [case()] */ DATE date;
        /* [case()] */ wireBSTR bstrVal;
        /* [case()] */ IUnknown __RPC_FAR *punkVal;
        /* [case()] */ IDispatch __RPC_FAR *pdispVal;
        /* [case()] */ wireSAFEARRAY parray;
        /* [case()] */ wireBRECORD brecVal;
        /* [case()] */ BYTE __RPC_FAR *pbVal;
        /* [case()] */ SHORT __RPC_FAR *piVal;
        /* [case()] */ LONG __RPC_FAR *plVal;
        /* [case()] */ LONGLONG __RPC_FAR *pllVal;
        /* [case()] */ FLOAT __RPC_FAR *pfltVal;
        /* [case()] */ DOUBLE __RPC_FAR *pdblVal;
        /* [case()] */ VARIANT_BOOL __RPC_FAR *pboolVal;
        /* [case()] */ SCODE __RPC_FAR *pscode;
        /* [case()] */ CY __RPC_FAR *pcyVal;
        /* [case()] */ DATE __RPC_FAR *pdate;
        /* [case()] */ wireBSTR __RPC_FAR *pbstrVal;
        /* [case()] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkVal;
        /* [case()] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispVal;
        /* [case()] */ wireSAFEARRAY __RPC_FAR *pparray;
        /* [case()] */ wireVARIANT __RPC_FAR *pvarVal;
        /* [case()] */ CHAR cVal;
        /* [case()] */ USHORT uiVal;
        /* [case()] */ ULONG ulVal;
        /* [case()] */ ULONGLONG ullVal;
        /* [case()] */ INT intVal;
        /* [case()] */ UINT uintVal;
        /* [case()] */ DECIMAL decVal;
        /* [case()] */ DECIMAL __RPC_FAR *pdecVal;
        /* [case()] */ CHAR __RPC_FAR *pcVal;
        /* [case()] */ USHORT __RPC_FAR *puiVal;
        /* [case()] */ ULONG __RPC_FAR *pulVal;
        /* [case()] */ ULONGLONG __RPC_FAR *pullVal;
        /* [case()] */ INT __RPC_FAR *pintVal;
        /* [case()] */ UINT __RPC_FAR *puintVal;
        /* [case()] */  /* Empty union arm */ 
        /* [case()] */  /* Empty union arm */ 
        }	;
    };
typedef LONG DISPID;

typedef DISPID MEMBERID;

typedef DWORD HREFTYPE;

typedef /* [v1_enum] */ 
enum tagTYPEKIND
    {	TKIND_ENUM	= 0,
	TKIND_RECORD	= TKIND_ENUM + 1,
	TKIND_MODULE	= TKIND_RECORD + 1,
	TKIND_INTERFACE	= TKIND_MODULE + 1,
	TKIND_DISPATCH	= TKIND_INTERFACE + 1,
	TKIND_COCLASS	= TKIND_DISPATCH + 1,
	TKIND_ALIAS	= TKIND_COCLASS + 1,
	TKIND_UNION	= TKIND_ALIAS + 1,
	TKIND_MAX	= TKIND_UNION + 1
    }	TYPEKIND;

typedef struct tagTYPEDESC
    {
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ struct tagTYPEDESC __RPC_FAR *lptdesc;
        /* [case()] */ struct tagARRAYDESC __RPC_FAR *lpadesc;
        /* [case()] */ HREFTYPE hreftype;
        /* [default] */  /* Empty union arm */ 
        }	;
    VARTYPE vt;
    }	TYPEDESC;

typedef struct tagARRAYDESC
    {
    TYPEDESC tdescElem;
    USHORT cDims;
    /* [size_is] */ SAFEARRAYBOUND rgbounds[ 1 ];
    }	ARRAYDESC;

typedef struct tagPARAMDESCEX
    {
    ULONG cBytes;
    VARIANTARG varDefaultValue;
    }	PARAMDESCEX;

typedef struct tagPARAMDESCEX __RPC_FAR *LPPARAMDESCEX;

typedef struct tagPARAMDESC
    {
    LPPARAMDESCEX pparamdescex;
    USHORT wParamFlags;
    }	PARAMDESC;

typedef struct tagPARAMDESC __RPC_FAR *LPPARAMDESC;

#define	PARAMFLAG_NONE	( 0 )

#define	PARAMFLAG_FIN	( 0x1 )

#define	PARAMFLAG_FOUT	( 0x2 )

#define	PARAMFLAG_FLCID	( 0x4 )

#define	PARAMFLAG_FRETVAL	( 0x8 )

#define	PARAMFLAG_FOPT	( 0x10 )

#define	PARAMFLAG_FHASDEFAULT	( 0x20 )

#define	PARAMFLAG_FHASCUSTDATA	( 0x40 )

typedef struct tagIDLDESC
    {
    ULONG dwReserved;
    USHORT wIDLFlags;
    }	IDLDESC;

typedef struct tagIDLDESC __RPC_FAR *LPIDLDESC;

#define	IDLFLAG_NONE	( PARAMFLAG_NONE )

#define	IDLFLAG_FIN	( PARAMFLAG_FIN )

#define	IDLFLAG_FOUT	( PARAMFLAG_FOUT )

#define	IDLFLAG_FLCID	( PARAMFLAG_FLCID )

#define	IDLFLAG_FRETVAL	( PARAMFLAG_FRETVAL )

//;begin_internal
#if 0
/* the following is what MIDL knows how to remote */
typedef struct tagELEMDESC
    {
    TYPEDESC tdesc;
    PARAMDESC paramdesc;
    }	ELEMDESC;

#else /* 0 */
//;end_internal
typedef struct tagELEMDESC {
    TYPEDESC tdesc;             /* the type of the element */
    union {
        IDLDESC idldesc;        /* info for remoting the element */
        PARAMDESC paramdesc;    /* info about the parameter */
    };
} ELEMDESC, * LPELEMDESC;
//;begin_internal
#endif /* 0 */
//;end_internal
typedef struct tagTYPEATTR
    {
    GUID guid;
    LCID lcid;
    DWORD dwReserved;
    MEMBERID memidConstructor;
    MEMBERID memidDestructor;
    LPOLESTR lpstrSchema;
    ULONG cbSizeInstance;
    TYPEKIND typekind;
    WORD cFuncs;
    WORD cVars;
    WORD cImplTypes;
    WORD cbSizeVft;
    WORD cbAlignment;
    WORD wTypeFlags;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    TYPEDESC tdescAlias;
    IDLDESC idldescType;
    }	TYPEATTR;

typedef struct tagTYPEATTR __RPC_FAR *LPTYPEATTR;

typedef struct tagDISPPARAMS
    {
    /* [size_is] */ VARIANTARG __RPC_FAR *rgvarg;
    /* [size_is] */ DISPID __RPC_FAR *rgdispidNamedArgs;
    UINT cArgs;
    UINT cNamedArgs;
    }	DISPPARAMS;

//;begin_internal
#if 0
/* the following is what MIDL knows how to remote */
typedef struct tagEXCEPINFO
    {
    WORD wCode;
    WORD wReserved;
    BSTR bstrSource;
    BSTR bstrDescription;
    BSTR bstrHelpFile;
    DWORD dwHelpContext;
    ULONG pvReserved;
    ULONG pfnDeferredFillIn;
    SCODE scode;
    }	EXCEPINFO;

#else /* 0 */
//;end_internal
typedef struct tagEXCEPINFO {
    WORD  wCode;
    WORD  wReserved;
    BSTR  bstrSource;
    BSTR  bstrDescription;
    BSTR  bstrHelpFile;
    DWORD dwHelpContext;
    PVOID pvReserved;
    HRESULT (__stdcall *pfnDeferredFillIn)(struct tagEXCEPINFO *);
    SCODE scode;
} EXCEPINFO, * LPEXCEPINFO;
//;begin_internal
#endif /* 0 */
//;end_internal
typedef /* [v1_enum] */ 
enum tagCALLCONV
    {	CC_FASTCALL	= 0,
	CC_CDECL	= 1,
	CC_MSCPASCAL	= CC_CDECL + 1,
	CC_PASCAL	= CC_MSCPASCAL,
	CC_MACPASCAL	= CC_PASCAL + 1,
	CC_STDCALL	= CC_MACPASCAL + 1,
	CC_FPFASTCALL	= CC_STDCALL + 1,
	CC_SYSCALL	= CC_FPFASTCALL + 1,
	CC_MPWCDECL	= CC_SYSCALL + 1,
	CC_MPWPASCAL	= CC_MPWCDECL + 1,
	CC_MAX	= CC_MPWPASCAL + 1
    }	CALLCONV;

typedef /* [v1_enum] */ 
enum tagFUNCKIND
    {	FUNC_VIRTUAL	= 0,
	FUNC_PUREVIRTUAL	= FUNC_VIRTUAL + 1,
	FUNC_NONVIRTUAL	= FUNC_PUREVIRTUAL + 1,
	FUNC_STATIC	= FUNC_NONVIRTUAL + 1,
	FUNC_DISPATCH	= FUNC_STATIC + 1
    }	FUNCKIND;

typedef /* [v1_enum] */ 
enum tagINVOKEKIND
    {	INVOKE_FUNC	= 1,
	INVOKE_PROPERTYGET	= 2,
	INVOKE_PROPERTYPUT	= 4,
	INVOKE_PROPERTYPUTREF	= 8
    }	INVOKEKIND;

typedef struct tagFUNCDESC
    {
    MEMBERID memid;
    /* [size_is] */ SCODE __RPC_FAR *lprgscode;
    /* [size_is] */ ELEMDESC __RPC_FAR *lprgelemdescParam;
    FUNCKIND funckind;
    INVOKEKIND invkind;
    CALLCONV callconv;
    SHORT cParams;
    SHORT cParamsOpt;
    SHORT oVft;
    SHORT cScodes;
    ELEMDESC elemdescFunc;
    WORD wFuncFlags;
    }	FUNCDESC;

typedef struct tagFUNCDESC __RPC_FAR *LPFUNCDESC;

typedef /* [v1_enum] */ 
enum tagVARKIND
    {	VAR_PERINSTANCE	= 0,
	VAR_STATIC	= VAR_PERINSTANCE + 1,
	VAR_CONST	= VAR_STATIC + 1,
	VAR_DISPATCH	= VAR_CONST + 1
    }	VARKIND;

#define	IMPLTYPEFLAG_FDEFAULT	( 0x1 )

#define	IMPLTYPEFLAG_FSOURCE	( 0x2 )

#define	IMPLTYPEFLAG_FRESTRICTED	( 0x4 )

#define	IMPLTYPEFLAG_FDEFAULTVTABLE	( 0x8 )

typedef struct tagVARDESC
    {
    MEMBERID memid;
    LPOLESTR lpstrSchema;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ ULONG oInst;
        /* [case()] */ VARIANT __RPC_FAR *lpvarValue;
        }	;
    ELEMDESC elemdescVar;
    WORD wVarFlags;
    VARKIND varkind;
    }	VARDESC;

typedef struct tagVARDESC __RPC_FAR *LPVARDESC;

typedef 
enum tagTYPEFLAGS
    {	TYPEFLAG_FAPPOBJECT	= 0x1,
	TYPEFLAG_FCANCREATE	= 0x2,
	TYPEFLAG_FLICENSED	= 0x4,
	TYPEFLAG_FPREDECLID	= 0x8,
	TYPEFLAG_FHIDDEN	= 0x10,
	TYPEFLAG_FCONTROL	= 0x20,
	TYPEFLAG_FDUAL	= 0x40,
	TYPEFLAG_FNONEXTENSIBLE	= 0x80,
	TYPEFLAG_FOLEAUTOMATION	= 0x100,
	TYPEFLAG_FRESTRICTED	= 0x200,
	TYPEFLAG_FAGGREGATABLE	= 0x400,
	TYPEFLAG_FREPLACEABLE	= 0x800,
	TYPEFLAG_FDISPATCHABLE	= 0x1000,
	TYPEFLAG_FREVERSEBIND	= 0x2000
    }	TYPEFLAGS;

typedef 
enum tagFUNCFLAGS
    {	FUNCFLAG_FRESTRICTED	= 0x1,
	FUNCFLAG_FSOURCE	= 0x2,
	FUNCFLAG_FBINDABLE	= 0x4,
	FUNCFLAG_FREQUESTEDIT	= 0x8,
	FUNCFLAG_FDISPLAYBIND	= 0x10,
	FUNCFLAG_FDEFAULTBIND	= 0x20,
	FUNCFLAG_FHIDDEN	= 0x40,
	FUNCFLAG_FUSESGETLASTERROR	= 0x80,
	FUNCFLAG_FDEFAULTCOLLELEM	= 0x100,
	FUNCFLAG_FUIDEFAULT	= 0x200,
	FUNCFLAG_FNONBROWSABLE	= 0x400,
	FUNCFLAG_FREPLACEABLE	= 0x800,
	FUNCFLAG_FIMMEDIATEBIND	= 0x1000
    }	FUNCFLAGS;

typedef 
enum tagVARFLAGS
    {	VARFLAG_FREADONLY	= 0x1,
	VARFLAG_FSOURCE	= 0x2,
	VARFLAG_FBINDABLE	= 0x4,
	VARFLAG_FREQUESTEDIT	= 0x8,
	VARFLAG_FDISPLAYBIND	= 0x10,
	VARFLAG_FDEFAULTBIND	= 0x20,
	VARFLAG_FHIDDEN	= 0x40,
	VARFLAG_FRESTRICTED	= 0x80,
	VARFLAG_FDEFAULTCOLLELEM	= 0x100,
	VARFLAG_FUIDEFAULT	= 0x200,
	VARFLAG_FNONBROWSABLE	= 0x400,
	VARFLAG_FREPLACEABLE	= 0x800,
	VARFLAG_FIMMEDIATEBIND	= 0x1000
    }	VARFLAGS;

typedef /* [wire_marshal] */ struct tagCLEANLOCALSTORAGE
    {
    IUnknown __RPC_FAR *pInterface;
    PVOID pStorage;
    DWORD flags;
    }	CLEANLOCALSTORAGE;

typedef struct tagCUSTDATAITEM
    {
    GUID guid;
    VARIANTARG varValue;
    }	CUSTDATAITEM;

typedef struct tagCUSTDATAITEM __RPC_FAR *LPCUSTDATAITEM;

typedef struct tagCUSTDATA
    {
    DWORD cCustData;
    /* [size_is] */ LPCUSTDATAITEM prgCustData;
    }	CUSTDATA;

typedef struct tagCUSTDATA __RPC_FAR *LPCUSTDATA;



extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_c_ifspec;
extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_s_ifspec;
#endif /* __IOleAutomationTypes_INTERFACE_DEFINED__ */

#ifndef __ICreateTypeInfo_INTERFACE_DEFINED__
#define __ICreateTypeInfo_INTERFACE_DEFINED__

/* interface ICreateTypeInfo */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ ICreateTypeInfo __RPC_FAR *LPCREATETYPEINFO;


EXTERN_C const IID IID_ICreateTypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020405-0000-0000-C000-000000000046")
    ICreateTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypeFlags( 
            /* [in] */ UINT uTypeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocString( 
            /* [in] */ LPOLESTR pStrDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddRefTypeInfo( 
            /* [in] */ ITypeInfo __RPC_FAR *pTInfo,
            /* [in] */ HREFTYPE __RPC_FAR *phRefType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFuncDesc( 
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddImplType( 
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hRefType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [in] */ INT implTypeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAlignment( 
            /* [in] */ WORD cbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSchema( 
            /* [in] */ LPOLESTR pStrSchema) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddVarDesc( 
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pVarDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFuncAndParamNames( 
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVarName( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypeDescAlias( 
            /* [in] */ TYPEDESC __RPC_FAR *pTDescAlias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineFuncAsDllEntry( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFuncDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVarDocString( 
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFuncHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVarHelpContext( 
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMops( 
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTypeIdldesc( 
            /* [in] */ IDLDESC __RPC_FAR *pIdlDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LayOut( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGuid )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT uTypeFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR pStrDoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVersion )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRefTypeInfo )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfo,
            /* [in] */ HREFTYPE __RPC_FAR *phRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFuncDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddImplType )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImplTypeFlags )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ INT implTypeFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ WORD cbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSchema )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR pStrSchema);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddVarDesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pVarDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncAndParamNames )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarName )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeDescAlias )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ TYPEDESC __RPC_FAR *pTDescAlias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefineFuncAsDllEntry )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarDocString )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarHelpContext )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMops )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeIdldesc )( 
            ICreateTypeInfo __RPC_FAR * This,
            /* [in] */ IDLDESC __RPC_FAR *pIdlDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LayOut )( 
            ICreateTypeInfo __RPC_FAR * This);
        
        END_INTERFACE
    } ICreateTypeInfoVtbl;

    interface ICreateTypeInfo
    {
        CONST_VTBL struct ICreateTypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeInfo_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeInfo_SetTypeFlags(This,uTypeFlags)	\
    (This)->lpVtbl -> SetTypeFlags(This,uTypeFlags)

#define ICreateTypeInfo_SetDocString(This,pStrDoc)	\
    (This)->lpVtbl -> SetDocString(This,pStrDoc)

#define ICreateTypeInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeInfo_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeInfo_AddRefTypeInfo(This,pTInfo,phRefType)	\
    (This)->lpVtbl -> AddRefTypeInfo(This,pTInfo,phRefType)

#define ICreateTypeInfo_AddFuncDesc(This,index,pFuncDesc)	\
    (This)->lpVtbl -> AddFuncDesc(This,index,pFuncDesc)

#define ICreateTypeInfo_AddImplType(This,index,hRefType)	\
    (This)->lpVtbl -> AddImplType(This,index,hRefType)

#define ICreateTypeInfo_SetImplTypeFlags(This,index,implTypeFlags)	\
    (This)->lpVtbl -> SetImplTypeFlags(This,index,implTypeFlags)

#define ICreateTypeInfo_SetAlignment(This,cbAlignment)	\
    (This)->lpVtbl -> SetAlignment(This,cbAlignment)

#define ICreateTypeInfo_SetSchema(This,pStrSchema)	\
    (This)->lpVtbl -> SetSchema(This,pStrSchema)

#define ICreateTypeInfo_AddVarDesc(This,index,pVarDesc)	\
    (This)->lpVtbl -> AddVarDesc(This,index,pVarDesc)

#define ICreateTypeInfo_SetFuncAndParamNames(This,index,rgszNames,cNames)	\
    (This)->lpVtbl -> SetFuncAndParamNames(This,index,rgszNames,cNames)

#define ICreateTypeInfo_SetVarName(This,index,szName)	\
    (This)->lpVtbl -> SetVarName(This,index,szName)

#define ICreateTypeInfo_SetTypeDescAlias(This,pTDescAlias)	\
    (This)->lpVtbl -> SetTypeDescAlias(This,pTDescAlias)

#define ICreateTypeInfo_DefineFuncAsDllEntry(This,index,szDllName,szProcName)	\
    (This)->lpVtbl -> DefineFuncAsDllEntry(This,index,szDllName,szProcName)

#define ICreateTypeInfo_SetFuncDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetFuncDocString(This,index,szDocString)

#define ICreateTypeInfo_SetVarDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetVarDocString(This,index,szDocString)

#define ICreateTypeInfo_SetFuncHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetFuncHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetVarHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetVarHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo_SetMops(This,index,bstrMops)	\
    (This)->lpVtbl -> SetMops(This,index,bstrMops)

#define ICreateTypeInfo_SetTypeIdldesc(This,pIdlDesc)	\
    (This)->lpVtbl -> SetTypeIdldesc(This,pIdlDesc)

#define ICreateTypeInfo_LayOut(This)	\
    (This)->lpVtbl -> LayOut(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetGuid_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeInfo_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT uTypeFlags);


void __RPC_STUB ICreateTypeInfo_SetTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR pStrDoc);


void __RPC_STUB ICreateTypeInfo_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetVersion_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeInfo_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_AddRefTypeInfo_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ ITypeInfo __RPC_FAR *pTInfo,
    /* [in] */ HREFTYPE __RPC_FAR *phRefType);


void __RPC_STUB ICreateTypeInfo_AddRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_AddFuncDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);


void __RPC_STUB ICreateTypeInfo_AddFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_AddImplType_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ HREFTYPE hRefType);


void __RPC_STUB ICreateTypeInfo_AddImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetImplTypeFlags_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ INT implTypeFlags);


void __RPC_STUB ICreateTypeInfo_SetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetAlignment_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ WORD cbAlignment);


void __RPC_STUB ICreateTypeInfo_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetSchema_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR pStrSchema);


void __RPC_STUB ICreateTypeInfo_SetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_AddVarDesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ VARDESC __RPC_FAR *pVarDesc);


void __RPC_STUB ICreateTypeInfo_AddVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetFuncAndParamNames_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames);


void __RPC_STUB ICreateTypeInfo_SetFuncAndParamNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetVarName_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeInfo_SetVarName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetTypeDescAlias_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ TYPEDESC __RPC_FAR *pTDescAlias);


void __RPC_STUB ICreateTypeInfo_SetTypeDescAlias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_DefineFuncAsDllEntry_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDllName,
    /* [in] */ LPOLESTR szProcName);


void __RPC_STUB ICreateTypeInfo_DefineFuncAsDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetFuncDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetFuncDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetVarDocString_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ LPOLESTR szDocString);


void __RPC_STUB ICreateTypeInfo_SetVarDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetFuncHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetFuncHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetVarHelpContext_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeInfo_SetVarHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetMops_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ BSTR bstrMops);


void __RPC_STUB ICreateTypeInfo_SetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_SetTypeIdldesc_Proxy( 
    ICreateTypeInfo __RPC_FAR * This,
    /* [in] */ IDLDESC __RPC_FAR *pIdlDesc);


void __RPC_STUB ICreateTypeInfo_SetTypeIdldesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo_LayOut_Proxy( 
    ICreateTypeInfo __RPC_FAR * This);


void __RPC_STUB ICreateTypeInfo_LayOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateTypeInfo2_INTERFACE_DEFINED__
#define __ICreateTypeInfo2_INTERFACE_DEFINED__

/* interface ICreateTypeInfo2 */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ ICreateTypeInfo2 __RPC_FAR *LPCREATETYPEINFO2;


EXTERN_C const IID IID_ICreateTypeInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002040E-0000-0000-C000-000000000046")
    ICreateTypeInfo2 : public ICreateTypeInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteFuncDesc( 
            /* [in] */ UINT index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteFuncDescByMemId( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteVarDesc( 
            /* [in] */ UINT index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteVarDescByMemId( 
            /* [in] */ MEMBERID memid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteImplType( 
            /* [in] */ UINT index) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustData( 
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFuncCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParamCustData( 
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVarCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetImplTypeCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpStringContext( 
            /* [in] */ ULONG dwHelpStringContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFuncHelpStringContext( 
            /* [in] */ UINT index,
            /* [in] */ ULONG dwHelpStringContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVarHelpStringContext( 
            /* [in] */ UINT index,
            /* [in] */ ULONG dwHelpStringContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invalidate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPOLESTR szName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateTypeInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateTypeInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGuid )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeFlags )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT uTypeFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocString )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ LPOLESTR pStrDoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVersion )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRefTypeInfo )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfo,
            /* [in] */ HREFTYPE __RPC_FAR *phRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddFuncDesc )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddImplType )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ HREFTYPE hRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImplTypeFlags )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ INT implTypeFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ WORD cbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSchema )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ LPOLESTR pStrSchema);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddVarDesc )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ VARDESC __RPC_FAR *pVarDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncAndParamNames )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in][size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarName )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeDescAlias )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ TYPEDESC __RPC_FAR *pTDescAlias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DefineFuncAsDllEntry )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDllName,
            /* [in] */ LPOLESTR szProcName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncDocString )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarDocString )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ LPOLESTR szDocString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncHelpContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarHelpContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMops )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ BSTR bstrMops);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTypeIdldesc )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ IDLDESC __RPC_FAR *pIdlDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LayOut )( 
            ICreateTypeInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFuncDesc )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteFuncDescByMemId )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteVarDesc )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteVarDescByMemId )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteImplType )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustData )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncCustData )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetParamCustData )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarCustData )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetImplTypeCustData )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpStringContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ ULONG dwHelpStringContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFuncHelpStringContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ ULONG dwHelpStringContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVarHelpStringContext )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ ULONG dwHelpStringContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invalidate )( 
            ICreateTypeInfo2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            ICreateTypeInfo2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szName);
        
        END_INTERFACE
    } ICreateTypeInfo2Vtbl;

    interface ICreateTypeInfo2
    {
        CONST_VTBL struct ICreateTypeInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeInfo2_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeInfo2_SetTypeFlags(This,uTypeFlags)	\
    (This)->lpVtbl -> SetTypeFlags(This,uTypeFlags)

#define ICreateTypeInfo2_SetDocString(This,pStrDoc)	\
    (This)->lpVtbl -> SetDocString(This,pStrDoc)

#define ICreateTypeInfo2_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeInfo2_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeInfo2_AddRefTypeInfo(This,pTInfo,phRefType)	\
    (This)->lpVtbl -> AddRefTypeInfo(This,pTInfo,phRefType)

#define ICreateTypeInfo2_AddFuncDesc(This,index,pFuncDesc)	\
    (This)->lpVtbl -> AddFuncDesc(This,index,pFuncDesc)

#define ICreateTypeInfo2_AddImplType(This,index,hRefType)	\
    (This)->lpVtbl -> AddImplType(This,index,hRefType)

#define ICreateTypeInfo2_SetImplTypeFlags(This,index,implTypeFlags)	\
    (This)->lpVtbl -> SetImplTypeFlags(This,index,implTypeFlags)

#define ICreateTypeInfo2_SetAlignment(This,cbAlignment)	\
    (This)->lpVtbl -> SetAlignment(This,cbAlignment)

#define ICreateTypeInfo2_SetSchema(This,pStrSchema)	\
    (This)->lpVtbl -> SetSchema(This,pStrSchema)

#define ICreateTypeInfo2_AddVarDesc(This,index,pVarDesc)	\
    (This)->lpVtbl -> AddVarDesc(This,index,pVarDesc)

#define ICreateTypeInfo2_SetFuncAndParamNames(This,index,rgszNames,cNames)	\
    (This)->lpVtbl -> SetFuncAndParamNames(This,index,rgszNames,cNames)

#define ICreateTypeInfo2_SetVarName(This,index,szName)	\
    (This)->lpVtbl -> SetVarName(This,index,szName)

#define ICreateTypeInfo2_SetTypeDescAlias(This,pTDescAlias)	\
    (This)->lpVtbl -> SetTypeDescAlias(This,pTDescAlias)

#define ICreateTypeInfo2_DefineFuncAsDllEntry(This,index,szDllName,szProcName)	\
    (This)->lpVtbl -> DefineFuncAsDllEntry(This,index,szDllName,szProcName)

#define ICreateTypeInfo2_SetFuncDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetFuncDocString(This,index,szDocString)

#define ICreateTypeInfo2_SetVarDocString(This,index,szDocString)	\
    (This)->lpVtbl -> SetVarDocString(This,index,szDocString)

#define ICreateTypeInfo2_SetFuncHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetFuncHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo2_SetVarHelpContext(This,index,dwHelpContext)	\
    (This)->lpVtbl -> SetVarHelpContext(This,index,dwHelpContext)

#define ICreateTypeInfo2_SetMops(This,index,bstrMops)	\
    (This)->lpVtbl -> SetMops(This,index,bstrMops)

#define ICreateTypeInfo2_SetTypeIdldesc(This,pIdlDesc)	\
    (This)->lpVtbl -> SetTypeIdldesc(This,pIdlDesc)

#define ICreateTypeInfo2_LayOut(This)	\
    (This)->lpVtbl -> LayOut(This)


#define ICreateTypeInfo2_DeleteFuncDesc(This,index)	\
    (This)->lpVtbl -> DeleteFuncDesc(This,index)

#define ICreateTypeInfo2_DeleteFuncDescByMemId(This,memid,invKind)	\
    (This)->lpVtbl -> DeleteFuncDescByMemId(This,memid,invKind)

#define ICreateTypeInfo2_DeleteVarDesc(This,index)	\
    (This)->lpVtbl -> DeleteVarDesc(This,index)

#define ICreateTypeInfo2_DeleteVarDescByMemId(This,memid)	\
    (This)->lpVtbl -> DeleteVarDescByMemId(This,memid)

#define ICreateTypeInfo2_DeleteImplType(This,index)	\
    (This)->lpVtbl -> DeleteImplType(This,index)

#define ICreateTypeInfo2_SetCustData(This,guid,pVarVal)	\
    (This)->lpVtbl -> SetCustData(This,guid,pVarVal)

#define ICreateTypeInfo2_SetFuncCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> SetFuncCustData(This,index,guid,pVarVal)

#define ICreateTypeInfo2_SetParamCustData(This,indexFunc,indexParam,guid,pVarVal)	\
    (This)->lpVtbl -> SetParamCustData(This,indexFunc,indexParam,guid,pVarVal)

#define ICreateTypeInfo2_SetVarCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> SetVarCustData(This,index,guid,pVarVal)

#define ICreateTypeInfo2_SetImplTypeCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> SetImplTypeCustData(This,index,guid,pVarVal)

#define ICreateTypeInfo2_SetHelpStringContext(This,dwHelpStringContext)	\
    (This)->lpVtbl -> SetHelpStringContext(This,dwHelpStringContext)

#define ICreateTypeInfo2_SetFuncHelpStringContext(This,index,dwHelpStringContext)	\
    (This)->lpVtbl -> SetFuncHelpStringContext(This,index,dwHelpStringContext)

#define ICreateTypeInfo2_SetVarHelpStringContext(This,index,dwHelpStringContext)	\
    (This)->lpVtbl -> SetVarHelpStringContext(This,index,dwHelpStringContext)

#define ICreateTypeInfo2_Invalidate(This)	\
    (This)->lpVtbl -> Invalidate(This)

#define ICreateTypeInfo2_SetName(This,szName)	\
    (This)->lpVtbl -> SetName(This,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_DeleteFuncDesc_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index);


void __RPC_STUB ICreateTypeInfo2_DeleteFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_DeleteFuncDescByMemId_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind);


void __RPC_STUB ICreateTypeInfo2_DeleteFuncDescByMemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_DeleteVarDesc_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index);


void __RPC_STUB ICreateTypeInfo2_DeleteVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_DeleteVarDescByMemId_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid);


void __RPC_STUB ICreateTypeInfo2_DeleteVarDescByMemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_DeleteImplType_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index);


void __RPC_STUB ICreateTypeInfo2_DeleteImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetCustData_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeInfo2_SetCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetFuncCustData_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeInfo2_SetFuncCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetParamCustData_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT indexFunc,
    /* [in] */ UINT indexParam,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeInfo2_SetParamCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetVarCustData_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeInfo2_SetVarCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetImplTypeCustData_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeInfo2_SetImplTypeCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetHelpStringContext_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ ULONG dwHelpStringContext);


void __RPC_STUB ICreateTypeInfo2_SetHelpStringContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetFuncHelpStringContext_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ ULONG dwHelpStringContext);


void __RPC_STUB ICreateTypeInfo2_SetFuncHelpStringContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetVarHelpStringContext_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ ULONG dwHelpStringContext);


void __RPC_STUB ICreateTypeInfo2_SetVarHelpStringContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_Invalidate_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This);


void __RPC_STUB ICreateTypeInfo2_Invalidate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeInfo2_SetName_Proxy( 
    ICreateTypeInfo2 __RPC_FAR * This,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeInfo2_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeInfo2_INTERFACE_DEFINED__ */


#ifndef __ICreateTypeLib_INTERFACE_DEFINED__
#define __ICreateTypeLib_INTERFACE_DEFINED__

/* interface ICreateTypeLib */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ ICreateTypeLib __RPC_FAR *LPCREATETYPELIB;


EXTERN_C const IID IID_ICreateTypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020406-0000-0000-C000-000000000046")
    ICreateTypeLib : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTypeInfo( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *ppCTInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ LPOLESTR szName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVersion( 
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGuid( 
            /* [in] */ REFGUID guid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDocString( 
            /* [in] */ LPOLESTR szDoc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpFileName( 
            /* [in] */ LPOLESTR szHelpFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLcid( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLibFlags( 
            /* [in] */ UINT uLibFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAllChanges( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeLibVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateTypeLib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateTypeLib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTypeInfo )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *ppCTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVersion )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGuid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocString )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szDoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpFileName )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpContext )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLcid )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLibFlags )( 
            ICreateTypeLib __RPC_FAR * This,
            /* [in] */ UINT uLibFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAllChanges )( 
            ICreateTypeLib __RPC_FAR * This);
        
        END_INTERFACE
    } ICreateTypeLibVtbl;

    interface ICreateTypeLib
    {
        CONST_VTBL struct ICreateTypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeLib_CreateTypeInfo(This,szName,tkind,ppCTInfo)	\
    (This)->lpVtbl -> CreateTypeInfo(This,szName,tkind,ppCTInfo)

#define ICreateTypeLib_SetName(This,szName)	\
    (This)->lpVtbl -> SetName(This,szName)

#define ICreateTypeLib_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeLib_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeLib_SetDocString(This,szDoc)	\
    (This)->lpVtbl -> SetDocString(This,szDoc)

#define ICreateTypeLib_SetHelpFileName(This,szHelpFileName)	\
    (This)->lpVtbl -> SetHelpFileName(This,szHelpFileName)

#define ICreateTypeLib_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeLib_SetLcid(This,lcid)	\
    (This)->lpVtbl -> SetLcid(This,lcid)

#define ICreateTypeLib_SetLibFlags(This,uLibFlags)	\
    (This)->lpVtbl -> SetLibFlags(This,uLibFlags)

#define ICreateTypeLib_SaveAllChanges(This)	\
    (This)->lpVtbl -> SaveAllChanges(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateTypeLib_CreateTypeInfo_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ TYPEKIND tkind,
    /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *ppCTInfo);


void __RPC_STUB ICreateTypeLib_CreateTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeLib_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetVersion_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ WORD wMajorVerNum,
    /* [in] */ WORD wMinorVerNum);


void __RPC_STUB ICreateTypeLib_SetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetGuid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid);


void __RPC_STUB ICreateTypeLib_SetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetDocString_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szDoc);


void __RPC_STUB ICreateTypeLib_SetDocString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetHelpFileName_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFileName);


void __RPC_STUB ICreateTypeLib_SetHelpFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetHelpContext_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateTypeLib_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetLcid_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ LCID lcid);


void __RPC_STUB ICreateTypeLib_SetLcid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SetLibFlags_Proxy( 
    ICreateTypeLib __RPC_FAR * This,
    /* [in] */ UINT uLibFlags);


void __RPC_STUB ICreateTypeLib_SetLibFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib_SaveAllChanges_Proxy( 
    ICreateTypeLib __RPC_FAR * This);


void __RPC_STUB ICreateTypeLib_SaveAllChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeLib_INTERFACE_DEFINED__ */


#ifndef __ICreateTypeLib2_INTERFACE_DEFINED__
#define __ICreateTypeLib2_INTERFACE_DEFINED__

/* interface ICreateTypeLib2 */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ ICreateTypeLib2 __RPC_FAR *LPCREATETYPELIB2;


EXTERN_C const IID IID_ICreateTypeLib2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002040F-0000-0000-C000-000000000046")
    ICreateTypeLib2 : public ICreateTypeLib
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DeleteTypeInfo( 
            /* [in] */ LPOLESTR szName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustData( 
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpStringContext( 
            /* [in] */ ULONG dwHelpStringContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpStringDll( 
            /* [in] */ LPOLESTR szFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateTypeLib2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateTypeLib2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateTypeLib2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTypeInfo )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ TYPEKIND tkind,
            /* [out] */ ICreateTypeInfo __RPC_FAR *__RPC_FAR *ppCTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVersion )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ WORD wMajorVerNum,
            /* [in] */ WORD wMinorVerNum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGuid )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ REFGUID guid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDocString )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szDoc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpFileName )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFileName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpContext )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLcid )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLibFlags )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ UINT uLibFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAllChanges )( 
            ICreateTypeLib2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTypeInfo )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustData )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [in] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpStringContext )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ ULONG dwHelpStringContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpStringDll )( 
            ICreateTypeLib2 __RPC_FAR * This,
            /* [in] */ LPOLESTR szFileName);
        
        END_INTERFACE
    } ICreateTypeLib2Vtbl;

    interface ICreateTypeLib2
    {
        CONST_VTBL struct ICreateTypeLib2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateTypeLib2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateTypeLib2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateTypeLib2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateTypeLib2_CreateTypeInfo(This,szName,tkind,ppCTInfo)	\
    (This)->lpVtbl -> CreateTypeInfo(This,szName,tkind,ppCTInfo)

#define ICreateTypeLib2_SetName(This,szName)	\
    (This)->lpVtbl -> SetName(This,szName)

#define ICreateTypeLib2_SetVersion(This,wMajorVerNum,wMinorVerNum)	\
    (This)->lpVtbl -> SetVersion(This,wMajorVerNum,wMinorVerNum)

#define ICreateTypeLib2_SetGuid(This,guid)	\
    (This)->lpVtbl -> SetGuid(This,guid)

#define ICreateTypeLib2_SetDocString(This,szDoc)	\
    (This)->lpVtbl -> SetDocString(This,szDoc)

#define ICreateTypeLib2_SetHelpFileName(This,szHelpFileName)	\
    (This)->lpVtbl -> SetHelpFileName(This,szHelpFileName)

#define ICreateTypeLib2_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#define ICreateTypeLib2_SetLcid(This,lcid)	\
    (This)->lpVtbl -> SetLcid(This,lcid)

#define ICreateTypeLib2_SetLibFlags(This,uLibFlags)	\
    (This)->lpVtbl -> SetLibFlags(This,uLibFlags)

#define ICreateTypeLib2_SaveAllChanges(This)	\
    (This)->lpVtbl -> SaveAllChanges(This)


#define ICreateTypeLib2_DeleteTypeInfo(This,szName)	\
    (This)->lpVtbl -> DeleteTypeInfo(This,szName)

#define ICreateTypeLib2_SetCustData(This,guid,pVarVal)	\
    (This)->lpVtbl -> SetCustData(This,guid,pVarVal)

#define ICreateTypeLib2_SetHelpStringContext(This,dwHelpStringContext)	\
    (This)->lpVtbl -> SetHelpStringContext(This,dwHelpStringContext)

#define ICreateTypeLib2_SetHelpStringDll(This,szFileName)	\
    (This)->lpVtbl -> SetHelpStringDll(This,szFileName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateTypeLib2_DeleteTypeInfo_Proxy( 
    ICreateTypeLib2 __RPC_FAR * This,
    /* [in] */ LPOLESTR szName);


void __RPC_STUB ICreateTypeLib2_DeleteTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib2_SetCustData_Proxy( 
    ICreateTypeLib2 __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [in] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ICreateTypeLib2_SetCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib2_SetHelpStringContext_Proxy( 
    ICreateTypeLib2 __RPC_FAR * This,
    /* [in] */ ULONG dwHelpStringContext);


void __RPC_STUB ICreateTypeLib2_SetHelpStringContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateTypeLib2_SetHelpStringDll_Proxy( 
    ICreateTypeLib2 __RPC_FAR * This,
    /* [in] */ LPOLESTR szFileName);


void __RPC_STUB ICreateTypeLib2_SetHelpStringDll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateTypeLib2_INTERFACE_DEFINED__ */


#ifndef __IDispatch_INTERFACE_DEFINED__
#define __IDispatch_INTERFACE_DEFINED__

/* interface IDispatch */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IDispatch __RPC_FAR *LPDISPATCH;

/* DISPID reserved to indicate an "unknown" name */
/* only reserved for data members (properties); reused as a method dispid below */
#define	DISPID_UNKNOWN	( -1 )

/* DISPID reserved for the "value" property */
#define	DISPID_VALUE	( 0 )

/* The following DISPID is reserved to indicate the param
 * that is the right-hand-side (or "put" value) of a PropertyPut
 */
#define	DISPID_PROPERTYPUT	( -3 )

/* DISPID reserved for the standard "NewEnum" method */
#define	DISPID_NEWENUM	( -4 )

/* DISPID reserved for the standard "Evaluate" method */
#define	DISPID_EVALUATE	( -5 )

#define	DISPID_CONSTRUCTOR	( -6 )

#define	DISPID_DESTRUCTOR	( -7 )

#define	DISPID_COLLECT	( -8 )

/* The range -500 through -999 is reserved for Controls */
/* The range 0x80010000 through 0x8001FFFF is reserved for Controls */
/* The range -5000 through -5499 is reserved for ActiveX Accessability */
/* The range -2000 through -2499 is reserved for VB5 */
/* The range -3900 through -3999 is reserved for Forms */
/* The range -5500 through -5550 is reserved for Forms */
/* The remainder of the negative DISPIDs are reserved for future use */

EXTERN_C const IID IID_IDispatch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020400-0000-0000-C000-000000000046")
    IDispatch : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount( 
            /* [out] */ UINT __RPC_FAR *pctinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( 
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispatchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDispatch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDispatch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDispatch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDispatch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        END_INTERFACE
    } IDispatchVtbl;

    interface IDispatch
    {
        CONST_VTBL struct IDispatchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispatch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDispatch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDispatch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDispatch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDispatch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDispatch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDispatch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDispatch_GetTypeInfoCount_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pctinfo);


void __RPC_STUB IDispatch_GetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatch_GetTypeInfo_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ UINT iTInfo,
    /* [in] */ LCID lcid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);


void __RPC_STUB IDispatch_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDispatch_GetIDsOfNames_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);


void __RPC_STUB IDispatch_GetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatch_RemoteInvoke_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pDispParams,
    /* [out] */ VARIANT __RPC_FAR *pVarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
    /* [out] */ UINT __RPC_FAR *pArgErr,
    /* [in] */ UINT cVarRef,
    /* [size_is][in] */ UINT __RPC_FAR *rgVarRefIdx,
    /* [size_is][out][in] */ VARIANTARG __RPC_FAR *rgVarRef);


void __RPC_STUB IDispatch_RemoteInvoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDispatch_INTERFACE_DEFINED__ */


#ifndef __IEnumVARIANT_INTERFACE_DEFINED__
#define __IEnumVARIANT_INTERFACE_DEFINED__

/* interface IEnumVARIANT */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumVARIANT __RPC_FAR *LPENUMVARIANT;


EXTERN_C const IID IID_IEnumVARIANT;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020404-0000-0000-C000-000000000046")
    IEnumVARIANT : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar,
            /* [out] */ ULONG __RPC_FAR *pCeltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumVARIANTVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumVARIANT __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumVARIANT __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar,
            /* [out] */ ULONG __RPC_FAR *pCeltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumVARIANT __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumVARIANT __RPC_FAR * This,
            /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);
        
        END_INTERFACE
    } IEnumVARIANTVtbl;

    interface IEnumVARIANT
    {
        CONST_VTBL struct IEnumVARIANTVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumVARIANT_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumVARIANT_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumVARIANT_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumVARIANT_Next(This,celt,rgVar,pCeltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgVar,pCeltFetched)

#define IEnumVARIANT_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumVARIANT_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumVARIANT_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumVARIANT_RemoteNext_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar,
    /* [out] */ ULONG __RPC_FAR *pCeltFetched);


void __RPC_STUB IEnumVARIANT_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumVARIANT_Skip_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumVARIANT_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumVARIANT_Reset_Proxy( 
    IEnumVARIANT __RPC_FAR * This);


void __RPC_STUB IEnumVARIANT_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumVARIANT_Clone_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumVARIANT_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumVARIANT_INTERFACE_DEFINED__ */


#ifndef __ITypeComp_INTERFACE_DEFINED__
#define __ITypeComp_INTERFACE_DEFINED__

/* interface ITypeComp */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITypeComp __RPC_FAR *LPTYPECOMP;

typedef /* [v1_enum] */ 
enum tagDESCKIND
    {	DESCKIND_NONE	= 0,
	DESCKIND_FUNCDESC	= DESCKIND_NONE + 1,
	DESCKIND_VARDESC	= DESCKIND_FUNCDESC + 1,
	DESCKIND_TYPECOMP	= DESCKIND_VARDESC + 1,
	DESCKIND_IMPLICITAPPOBJ	= DESCKIND_TYPECOMP + 1,
	DESCKIND_MAX	= DESCKIND_IMPLICITAPPOBJ + 1
    }	DESCKIND;

typedef union tagBINDPTR
    {
    FUNCDESC __RPC_FAR *lpfuncdesc;
    VARDESC __RPC_FAR *lpvardesc;
    ITypeComp __RPC_FAR *lptcomp;
    }	BINDPTR;

typedef union tagBINDPTR __RPC_FAR *LPBINDPTR;


EXTERN_C const IID IID_ITypeComp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020403-0000-0000-C000-000000000046")
    ITypeComp : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD wFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [out] */ DESCKIND __RPC_FAR *pDescKind,
            /* [out] */ BINDPTR __RPC_FAR *pBindPtr) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BindType( 
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeCompVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeComp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeComp __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Bind )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [in] */ WORD wFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [out] */ DESCKIND __RPC_FAR *pDescKind,
            /* [out] */ BINDPTR __RPC_FAR *pBindPtr);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BindType )( 
            ITypeComp __RPC_FAR * This,
            /* [in] */ LPOLESTR szName,
            /* [in] */ ULONG lHashVal,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);
        
        END_INTERFACE
    } ITypeCompVtbl;

    interface ITypeComp
    {
        CONST_VTBL struct ITypeCompVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeComp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeComp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeComp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeComp_Bind(This,szName,lHashVal,wFlags,ppTInfo,pDescKind,pBindPtr)	\
    (This)->lpVtbl -> Bind(This,szName,lHashVal,wFlags,ppTInfo,pDescKind,pBindPtr)

#define ITypeComp_BindType(This,szName,lHashVal,ppTInfo,ppTComp)	\
    (This)->lpVtbl -> BindType(This,szName,lHashVal,ppTInfo,ppTComp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_RemoteBind_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD wFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [out] */ DESCKIND __RPC_FAR *pDescKind,
    /* [out] */ LPFUNCDESC __RPC_FAR *ppFuncDesc,
    /* [out] */ LPVARDESC __RPC_FAR *ppVarDesc,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTypeComp,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);


void __RPC_STUB ITypeComp_RemoteBind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_RemoteBindType_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);


void __RPC_STUB ITypeComp_RemoteBindType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeComp_INTERFACE_DEFINED__ */


#ifndef __ITypeInfo_INTERFACE_DEFINED__
#define __ITypeInfo_INTERFACE_DEFINED__

/* interface ITypeInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITypeInfo __RPC_FAR *LPTYPEINFO;


EXTERN_C const IID IID_ITypeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020401-0000-0000-C000-000000000046")
    ITypeInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetTypeAttr( 
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *ppTypeAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetFuncDesc( 
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *ppFuncDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetVarDesc( 
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppVarDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRefTypeOfImplType( 
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *pRefType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImplTypeFlags( 
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pImplTypeFlags) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetIDsOfNames( 
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *pMemId) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ PVOID pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDocumentation( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDllEntry( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ BSTR __RPC_FAR *pBstrDllName,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRefTypeInfo( 
            /* [in] */ HREFTYPE hRefType,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE AddressOfMember( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ PVOID __RPC_FAR *ppv) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ PVOID __RPC_FAR *ppvObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMops( 
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrMops) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetContainingTypeLib( 
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
            /* [out] */ UINT __RPC_FAR *pIndex) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE ReleaseTypeAttr( 
            /* [in] */ TYPEATTR __RPC_FAR *pTypeAttr) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE ReleaseFuncDesc( 
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE ReleaseVarDesc( 
            /* [in] */ VARDESC __RPC_FAR *pVarDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *ppTypeAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeComp )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *ppFuncDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppVarDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRefTypeOfImplType )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *pRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImplTypeFlags )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pImplTypeFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITypeInfo __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *pMemId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ PVOID pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDllEntry )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ BSTR __RPC_FAR *pBstrDllName,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRefTypeInfo )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ HREFTYPE hRefType,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddressOfMember )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ PVOID __RPC_FAR *ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ PVOID __RPC_FAR *ppvObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMops )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrMops);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainingTypeLib )( 
            ITypeInfo __RPC_FAR * This,
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
            /* [out] */ UINT __RPC_FAR *pIndex);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseTypeAttr )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ TYPEATTR __RPC_FAR *pTypeAttr);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFuncDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseVarDesc )( 
            ITypeInfo __RPC_FAR * This,
            /* [in] */ VARDESC __RPC_FAR *pVarDesc);
        
        END_INTERFACE
    } ITypeInfoVtbl;

    interface ITypeInfo
    {
        CONST_VTBL struct ITypeInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeInfo_GetTypeAttr(This,ppTypeAttr)	\
    (This)->lpVtbl -> GetTypeAttr(This,ppTypeAttr)

#define ITypeInfo_GetTypeComp(This,ppTComp)	\
    (This)->lpVtbl -> GetTypeComp(This,ppTComp)

#define ITypeInfo_GetFuncDesc(This,index,ppFuncDesc)	\
    (This)->lpVtbl -> GetFuncDesc(This,index,ppFuncDesc)

#define ITypeInfo_GetVarDesc(This,index,ppVarDesc)	\
    (This)->lpVtbl -> GetVarDesc(This,index,ppVarDesc)

#define ITypeInfo_GetNames(This,memid,rgBstrNames,cMaxNames,pcNames)	\
    (This)->lpVtbl -> GetNames(This,memid,rgBstrNames,cMaxNames,pcNames)

#define ITypeInfo_GetRefTypeOfImplType(This,index,pRefType)	\
    (This)->lpVtbl -> GetRefTypeOfImplType(This,index,pRefType)

#define ITypeInfo_GetImplTypeFlags(This,index,pImplTypeFlags)	\
    (This)->lpVtbl -> GetImplTypeFlags(This,index,pImplTypeFlags)

#define ITypeInfo_GetIDsOfNames(This,rgszNames,cNames,pMemId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,rgszNames,cNames,pMemId)

#define ITypeInfo_Invoke(This,pvInstance,memid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,pvInstance,memid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#define ITypeInfo_GetDocumentation(This,memid,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,memid,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)

#define ITypeInfo_GetDllEntry(This,memid,invKind,pBstrDllName,pBstrName,pwOrdinal)	\
    (This)->lpVtbl -> GetDllEntry(This,memid,invKind,pBstrDllName,pBstrName,pwOrdinal)

#define ITypeInfo_GetRefTypeInfo(This,hRefType,ppTInfo)	\
    (This)->lpVtbl -> GetRefTypeInfo(This,hRefType,ppTInfo)

#define ITypeInfo_AddressOfMember(This,memid,invKind,ppv)	\
    (This)->lpVtbl -> AddressOfMember(This,memid,invKind,ppv)

#define ITypeInfo_CreateInstance(This,pUnkOuter,riid,ppvObj)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObj)

#define ITypeInfo_GetMops(This,memid,pBstrMops)	\
    (This)->lpVtbl -> GetMops(This,memid,pBstrMops)

#define ITypeInfo_GetContainingTypeLib(This,ppTLib,pIndex)	\
    (This)->lpVtbl -> GetContainingTypeLib(This,ppTLib,pIndex)

#define ITypeInfo_ReleaseTypeAttr(This,pTypeAttr)	\
    (This)->lpVtbl -> ReleaseTypeAttr(This,pTypeAttr)

#define ITypeInfo_ReleaseFuncDesc(This,pFuncDesc)	\
    (This)->lpVtbl -> ReleaseFuncDesc(This,pFuncDesc)

#define ITypeInfo_ReleaseVarDesc(This,pVarDesc)	\
    (This)->lpVtbl -> ReleaseVarDesc(This,pVarDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ LPTYPEATTR __RPC_FAR *ppTypeAttr,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);


void __RPC_STUB ITypeInfo_RemoteGetTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo_GetTypeComp_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);


void __RPC_STUB ITypeInfo_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ LPFUNCDESC __RPC_FAR *ppFuncDesc,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);


void __RPC_STUB ITypeInfo_RemoteGetFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ LPVARDESC __RPC_FAR *ppVarDesc,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);


void __RPC_STUB ITypeInfo_RemoteGetVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT __RPC_FAR *pcNames);


void __RPC_STUB ITypeInfo_RemoteGetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo_GetRefTypeOfImplType_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ HREFTYPE __RPC_FAR *pRefType);


void __RPC_STUB ITypeInfo_GetRefTypeOfImplType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo_GetImplTypeFlags_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ INT __RPC_FAR *pImplTypeFlags);


void __RPC_STUB ITypeInfo_GetImplTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalGetIDsOfNames_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalGetIDsOfNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalInvoke_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalInvoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetDocumentation_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);


void __RPC_STUB ITypeInfo_RemoteGetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetDllEntry_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrDllName,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ WORD __RPC_FAR *pwOrdinal);


void __RPC_STUB ITypeInfo_RemoteGetDllEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo_GetRefTypeInfo_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ HREFTYPE hRefType,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);


void __RPC_STUB ITypeInfo_GetRefTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalAddressOfMember_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalAddressOfMember_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteCreateInstance_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);


void __RPC_STUB ITypeInfo_RemoteCreateInstance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo_GetMops_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pBstrMops);


void __RPC_STUB ITypeInfo_GetMops_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_RemoteGetContainingTypeLib_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
    /* [out] */ UINT __RPC_FAR *pIndex);


void __RPC_STUB ITypeInfo_RemoteGetContainingTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalReleaseTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalReleaseTypeAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalReleaseFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalReleaseFuncDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_LocalReleaseVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This);


void __RPC_STUB ITypeInfo_LocalReleaseVarDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeInfo_INTERFACE_DEFINED__ */


#ifndef __ITypeInfo2_INTERFACE_DEFINED__
#define __ITypeInfo2_INTERFACE_DEFINED__

/* interface ITypeInfo2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITypeInfo2 __RPC_FAR *LPTYPEINFO2;


EXTERN_C const IID IID_ITypeInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020412-0000-0000-C000-000000000046")
    ITypeInfo2 : public ITypeInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTypeKind( 
            /* [out] */ TYPEKIND __RPC_FAR *pTypeKind) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeFlags( 
            /* [out] */ ULONG __RPC_FAR *pTypeFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFuncIndexOfMemId( 
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ UINT __RPC_FAR *pFuncIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarIndexOfMemId( 
            /* [in] */ MEMBERID memid,
            /* [out] */ UINT __RPC_FAR *pVarIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCustData( 
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFuncCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamCustData( 
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImplTypeCustData( 
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDocumentation2( 
            /* [in] */ MEMBERID memid,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllCustData( 
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllFuncCustData( 
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllParamCustData( 
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllVarCustData( 
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllImplTypeCustData( 
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeInfo2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeInfo2 __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeAttr )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *ppTypeAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeComp )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFuncDesc )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *ppFuncDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVarDesc )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppVarDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNames )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
            /* [in] */ UINT cMaxNames,
            /* [out] */ UINT __RPC_FAR *pcNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRefTypeOfImplType )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ HREFTYPE __RPC_FAR *pRefType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImplTypeFlags )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ INT __RPC_FAR *pImplTypeFlags);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [size_is][out] */ MEMBERID __RPC_FAR *pMemId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ PVOID pvInstance,
            /* [in] */ MEMBERID memid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDllEntry )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ BSTR __RPC_FAR *pBstrDllName,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ WORD __RPC_FAR *pwOrdinal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRefTypeInfo )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ HREFTYPE hRefType,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddressOfMember )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ PVOID __RPC_FAR *ppv);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ PVOID __RPC_FAR *ppvObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMops )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ BSTR __RPC_FAR *pBstrMops);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContainingTypeLib )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
            /* [out] */ UINT __RPC_FAR *pIndex);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseTypeAttr )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ TYPEATTR __RPC_FAR *pTypeAttr);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseFuncDesc )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseVarDesc )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ VARDESC __RPC_FAR *pVarDesc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeKind )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ TYPEKIND __RPC_FAR *pTypeKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeFlags )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pTypeFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFuncIndexOfMemId )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ INVOKEKIND invKind,
            /* [out] */ UINT __RPC_FAR *pFuncIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVarIndexOfMemId )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [out] */ UINT __RPC_FAR *pVarIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFuncCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParamCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVarCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImplTypeCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation2 )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ MEMBERID memid,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllFuncCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllParamCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT indexFunc,
            /* [in] */ UINT indexParam,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllVarCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllImplTypeCustData )( 
            ITypeInfo2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        END_INTERFACE
    } ITypeInfo2Vtbl;

    interface ITypeInfo2
    {
        CONST_VTBL struct ITypeInfo2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeInfo2_GetTypeAttr(This,ppTypeAttr)	\
    (This)->lpVtbl -> GetTypeAttr(This,ppTypeAttr)

#define ITypeInfo2_GetTypeComp(This,ppTComp)	\
    (This)->lpVtbl -> GetTypeComp(This,ppTComp)

#define ITypeInfo2_GetFuncDesc(This,index,ppFuncDesc)	\
    (This)->lpVtbl -> GetFuncDesc(This,index,ppFuncDesc)

#define ITypeInfo2_GetVarDesc(This,index,ppVarDesc)	\
    (This)->lpVtbl -> GetVarDesc(This,index,ppVarDesc)

#define ITypeInfo2_GetNames(This,memid,rgBstrNames,cMaxNames,pcNames)	\
    (This)->lpVtbl -> GetNames(This,memid,rgBstrNames,cMaxNames,pcNames)

#define ITypeInfo2_GetRefTypeOfImplType(This,index,pRefType)	\
    (This)->lpVtbl -> GetRefTypeOfImplType(This,index,pRefType)

#define ITypeInfo2_GetImplTypeFlags(This,index,pImplTypeFlags)	\
    (This)->lpVtbl -> GetImplTypeFlags(This,index,pImplTypeFlags)

#define ITypeInfo2_GetIDsOfNames(This,rgszNames,cNames,pMemId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,rgszNames,cNames,pMemId)

#define ITypeInfo2_Invoke(This,pvInstance,memid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,pvInstance,memid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)

#define ITypeInfo2_GetDocumentation(This,memid,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,memid,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)

#define ITypeInfo2_GetDllEntry(This,memid,invKind,pBstrDllName,pBstrName,pwOrdinal)	\
    (This)->lpVtbl -> GetDllEntry(This,memid,invKind,pBstrDllName,pBstrName,pwOrdinal)

#define ITypeInfo2_GetRefTypeInfo(This,hRefType,ppTInfo)	\
    (This)->lpVtbl -> GetRefTypeInfo(This,hRefType,ppTInfo)

#define ITypeInfo2_AddressOfMember(This,memid,invKind,ppv)	\
    (This)->lpVtbl -> AddressOfMember(This,memid,invKind,ppv)

#define ITypeInfo2_CreateInstance(This,pUnkOuter,riid,ppvObj)	\
    (This)->lpVtbl -> CreateInstance(This,pUnkOuter,riid,ppvObj)

#define ITypeInfo2_GetMops(This,memid,pBstrMops)	\
    (This)->lpVtbl -> GetMops(This,memid,pBstrMops)

#define ITypeInfo2_GetContainingTypeLib(This,ppTLib,pIndex)	\
    (This)->lpVtbl -> GetContainingTypeLib(This,ppTLib,pIndex)

#define ITypeInfo2_ReleaseTypeAttr(This,pTypeAttr)	\
    (This)->lpVtbl -> ReleaseTypeAttr(This,pTypeAttr)

#define ITypeInfo2_ReleaseFuncDesc(This,pFuncDesc)	\
    (This)->lpVtbl -> ReleaseFuncDesc(This,pFuncDesc)

#define ITypeInfo2_ReleaseVarDesc(This,pVarDesc)	\
    (This)->lpVtbl -> ReleaseVarDesc(This,pVarDesc)


#define ITypeInfo2_GetTypeKind(This,pTypeKind)	\
    (This)->lpVtbl -> GetTypeKind(This,pTypeKind)

#define ITypeInfo2_GetTypeFlags(This,pTypeFlags)	\
    (This)->lpVtbl -> GetTypeFlags(This,pTypeFlags)

#define ITypeInfo2_GetFuncIndexOfMemId(This,memid,invKind,pFuncIndex)	\
    (This)->lpVtbl -> GetFuncIndexOfMemId(This,memid,invKind,pFuncIndex)

#define ITypeInfo2_GetVarIndexOfMemId(This,memid,pVarIndex)	\
    (This)->lpVtbl -> GetVarIndexOfMemId(This,memid,pVarIndex)

#define ITypeInfo2_GetCustData(This,guid,pVarVal)	\
    (This)->lpVtbl -> GetCustData(This,guid,pVarVal)

#define ITypeInfo2_GetFuncCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> GetFuncCustData(This,index,guid,pVarVal)

#define ITypeInfo2_GetParamCustData(This,indexFunc,indexParam,guid,pVarVal)	\
    (This)->lpVtbl -> GetParamCustData(This,indexFunc,indexParam,guid,pVarVal)

#define ITypeInfo2_GetVarCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> GetVarCustData(This,index,guid,pVarVal)

#define ITypeInfo2_GetImplTypeCustData(This,index,guid,pVarVal)	\
    (This)->lpVtbl -> GetImplTypeCustData(This,index,guid,pVarVal)

#define ITypeInfo2_GetDocumentation2(This,memid,lcid,pbstrHelpString,pdwHelpStringContext,pbstrHelpStringDll)	\
    (This)->lpVtbl -> GetDocumentation2(This,memid,lcid,pbstrHelpString,pdwHelpStringContext,pbstrHelpStringDll)

#define ITypeInfo2_GetAllCustData(This,pCustData)	\
    (This)->lpVtbl -> GetAllCustData(This,pCustData)

#define ITypeInfo2_GetAllFuncCustData(This,index,pCustData)	\
    (This)->lpVtbl -> GetAllFuncCustData(This,index,pCustData)

#define ITypeInfo2_GetAllParamCustData(This,indexFunc,indexParam,pCustData)	\
    (This)->lpVtbl -> GetAllParamCustData(This,indexFunc,indexParam,pCustData)

#define ITypeInfo2_GetAllVarCustData(This,index,pCustData)	\
    (This)->lpVtbl -> GetAllVarCustData(This,index,pCustData)

#define ITypeInfo2_GetAllImplTypeCustData(This,index,pCustData)	\
    (This)->lpVtbl -> GetAllImplTypeCustData(This,index,pCustData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeInfo2_GetTypeKind_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [out] */ TYPEKIND __RPC_FAR *pTypeKind);


void __RPC_STUB ITypeInfo2_GetTypeKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetTypeFlags_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pTypeFlags);


void __RPC_STUB ITypeInfo2_GetTypeFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetFuncIndexOfMemId_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [out] */ UINT __RPC_FAR *pFuncIndex);


void __RPC_STUB ITypeInfo2_GetFuncIndexOfMemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetVarIndexOfMemId_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ UINT __RPC_FAR *pVarIndex);


void __RPC_STUB ITypeInfo2_GetVarIndexOfMemId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeInfo2_GetCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetFuncCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeInfo2_GetFuncCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetParamCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT indexFunc,
    /* [in] */ UINT indexParam,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeInfo2_GetParamCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetVarCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeInfo2_GetVarCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetImplTypeCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeInfo2_GetImplTypeCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo2_RemoteGetDocumentation2_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);


void __RPC_STUB ITypeInfo2_RemoteGetDocumentation2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetAllCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeInfo2_GetAllCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetAllFuncCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeInfo2_GetAllFuncCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetAllParamCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT indexFunc,
    /* [in] */ UINT indexParam,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeInfo2_GetAllParamCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetAllVarCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeInfo2_GetAllVarCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeInfo2_GetAllImplTypeCustData_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeInfo2_GetAllImplTypeCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeInfo2_INTERFACE_DEFINED__ */


#ifndef __ITypeLib_INTERFACE_DEFINED__
#define __ITypeLib_INTERFACE_DEFINED__

/* interface ITypeLib */
/* [unique][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagSYSKIND
    {	SYS_WIN16	= 0,
	SYS_WIN32	= SYS_WIN16 + 1,
	SYS_MAC	= SYS_WIN32 + 1
    }	SYSKIND;

typedef /* [v1_enum] */ 
enum tagLIBFLAGS
    {	LIBFLAG_FRESTRICTED	= 0x1,
	LIBFLAG_FCONTROL	= 0x2,
	LIBFLAG_FHIDDEN	= 0x4,
	LIBFLAG_FHASDISKIMAGE	= 0x8
    }	LIBFLAGS;

typedef /* [unique] */ ITypeLib __RPC_FAR *LPTYPELIB;

typedef struct tagTLIBATTR
    {
    GUID guid;
    LCID lcid;
    SYSKIND syskind;
    WORD wMajorVerNum;
    WORD wMinorVerNum;
    WORD wLibFlags;
    }	TLIBATTR;

typedef struct tagTLIBATTR __RPC_FAR *LPTLIBATTR;


EXTERN_C const IID IID_ITypeLib;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020402-0000-0000-C000-000000000046")
    ITypeLib : public IUnknown
    {
    public:
        virtual /* [local] */ UINT STDMETHODCALLTYPE GetTypeInfoCount( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoType( 
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *pTKind) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoOfGuid( 
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTinfo) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLibAttr( 
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *ppTLibAttr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeComp( 
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDocumentation( 
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsName( 
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE FindName( 
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
            /* [out][in] */ USHORT __RPC_FAR *pcFound) = 0;
        
        virtual /* [local] */ void STDMETHODCALLTYPE ReleaseTLibAttr( 
            /* [in] */ TLIBATTR __RPC_FAR *pTLibAttr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLibVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeLib __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeLib __RPC_FAR * This);
        
        /* [local] */ UINT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITypeLib __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoType )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *pTKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoOfGuid )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *ppTLibAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeComp )( 
            ITypeLib __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsName )( 
            ITypeLib __RPC_FAR * This,
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindName )( 
            ITypeLib __RPC_FAR * This,
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
            /* [out][in] */ USHORT __RPC_FAR *pcFound);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseTLibAttr )( 
            ITypeLib __RPC_FAR * This,
            /* [in] */ TLIBATTR __RPC_FAR *pTLibAttr);
        
        END_INTERFACE
    } ITypeLibVtbl;

    interface ITypeLib
    {
        CONST_VTBL struct ITypeLibVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLib_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLib_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLib_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLib_GetTypeInfoCount(This)	\
    (This)->lpVtbl -> GetTypeInfoCount(This)

#define ITypeLib_GetTypeInfo(This,index,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,index,ppTInfo)

#define ITypeLib_GetTypeInfoType(This,index,pTKind)	\
    (This)->lpVtbl -> GetTypeInfoType(This,index,pTKind)

#define ITypeLib_GetTypeInfoOfGuid(This,guid,ppTinfo)	\
    (This)->lpVtbl -> GetTypeInfoOfGuid(This,guid,ppTinfo)

#define ITypeLib_GetLibAttr(This,ppTLibAttr)	\
    (This)->lpVtbl -> GetLibAttr(This,ppTLibAttr)

#define ITypeLib_GetTypeComp(This,ppTComp)	\
    (This)->lpVtbl -> GetTypeComp(This,ppTComp)

#define ITypeLib_GetDocumentation(This,index,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,index,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)

#define ITypeLib_IsName(This,szNameBuf,lHashVal,pfName)	\
    (This)->lpVtbl -> IsName(This,szNameBuf,lHashVal,pfName)

#define ITypeLib_FindName(This,szNameBuf,lHashVal,ppTInfo,rgMemId,pcFound)	\
    (This)->lpVtbl -> FindName(This,szNameBuf,lHashVal,ppTInfo,rgMemId,pcFound)

#define ITypeLib_ReleaseTLibAttr(This,pTLibAttr)	\
    (This)->lpVtbl -> ReleaseTLibAttr(This,pTLibAttr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetTypeInfoCount_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pcTInfo);


void __RPC_STUB ITypeLib_RemoteGetTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeInfo_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);


void __RPC_STUB ITypeLib_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeInfoType_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ TYPEKIND __RPC_FAR *pTKind);


void __RPC_STUB ITypeLib_GetTypeInfoType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeInfoOfGuid_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTinfo);


void __RPC_STUB ITypeLib_GetTypeInfoOfGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ LPTLIBATTR __RPC_FAR *ppTLibAttr,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);


void __RPC_STUB ITypeLib_RemoteGetLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeComp_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);


void __RPC_STUB ITypeLib_GetTypeComp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteGetDocumentation_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ INT index,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);


void __RPC_STUB ITypeLib_RemoteGetDocumentation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteIsName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL __RPC_FAR *pfName,
    /* [out] */ BSTR __RPC_FAR *pBstrLibName);


void __RPC_STUB ITypeLib_RemoteIsName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_RemoteFindName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
    /* [out][in] */ USHORT __RPC_FAR *pcFound,
    /* [out] */ BSTR __RPC_FAR *pBstrLibName);


void __RPC_STUB ITypeLib_RemoteFindName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_LocalReleaseTLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This);


void __RPC_STUB ITypeLib_LocalReleaseTLibAttr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLib_INTERFACE_DEFINED__ */


#ifndef __ITypeLib2_INTERFACE_DEFINED__
#define __ITypeLib2_INTERFACE_DEFINED__

/* interface ITypeLib2 */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ITypeLib2 __RPC_FAR *LPTYPELIB2;


EXTERN_C const IID IID_ITypeLib2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020411-0000-0000-C000-000000000046")
    ITypeLib2 : public ITypeLib
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCustData( 
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetLibStatistics( 
            /* [out] */ ULONG __RPC_FAR *pcUniqueNames,
            /* [out] */ ULONG __RPC_FAR *pcchUniqueNames) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetDocumentation2( 
            /* [in] */ INT index,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAllCustData( 
            /* [out] */ CUSTDATA __RPC_FAR *pCustData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeLib2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeLib2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeLib2 __RPC_FAR * This);
        
        /* [local] */ UINT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ITypeLib2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoType )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ UINT index,
            /* [out] */ TYPEKIND __RPC_FAR *pTKind);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoOfGuid )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTinfo);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLibAttr )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *ppTLibAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeComp )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ INT index,
            /* [out] */ BSTR __RPC_FAR *pBstrName,
            /* [out] */ BSTR __RPC_FAR *pBstrDocString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsName )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [out] */ BOOL __RPC_FAR *pfName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindName )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out][in] */ LPOLESTR szNameBuf,
            /* [in] */ ULONG lHashVal,
            /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
            /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
            /* [out][in] */ USHORT __RPC_FAR *pcFound);
        
        /* [local] */ void ( STDMETHODCALLTYPE __RPC_FAR *ReleaseTLibAttr )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ TLIBATTR __RPC_FAR *pTLibAttr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCustData )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ REFGUID guid,
            /* [out] */ VARIANT __RPC_FAR *pVarVal);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLibStatistics )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcUniqueNames,
            /* [out] */ ULONG __RPC_FAR *pcchUniqueNames);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDocumentation2 )( 
            ITypeLib2 __RPC_FAR * This,
            /* [in] */ INT index,
            /* [in] */ LCID lcid,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
            /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
            /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCustData )( 
            ITypeLib2 __RPC_FAR * This,
            /* [out] */ CUSTDATA __RPC_FAR *pCustData);
        
        END_INTERFACE
    } ITypeLib2Vtbl;

    interface ITypeLib2
    {
        CONST_VTBL struct ITypeLib2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeLib2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeLib2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeLib2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeLib2_GetTypeInfoCount(This)	\
    (This)->lpVtbl -> GetTypeInfoCount(This)

#define ITypeLib2_GetTypeInfo(This,index,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,index,ppTInfo)

#define ITypeLib2_GetTypeInfoType(This,index,pTKind)	\
    (This)->lpVtbl -> GetTypeInfoType(This,index,pTKind)

#define ITypeLib2_GetTypeInfoOfGuid(This,guid,ppTinfo)	\
    (This)->lpVtbl -> GetTypeInfoOfGuid(This,guid,ppTinfo)

#define ITypeLib2_GetLibAttr(This,ppTLibAttr)	\
    (This)->lpVtbl -> GetLibAttr(This,ppTLibAttr)

#define ITypeLib2_GetTypeComp(This,ppTComp)	\
    (This)->lpVtbl -> GetTypeComp(This,ppTComp)

#define ITypeLib2_GetDocumentation(This,index,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)	\
    (This)->lpVtbl -> GetDocumentation(This,index,pBstrName,pBstrDocString,pdwHelpContext,pBstrHelpFile)

#define ITypeLib2_IsName(This,szNameBuf,lHashVal,pfName)	\
    (This)->lpVtbl -> IsName(This,szNameBuf,lHashVal,pfName)

#define ITypeLib2_FindName(This,szNameBuf,lHashVal,ppTInfo,rgMemId,pcFound)	\
    (This)->lpVtbl -> FindName(This,szNameBuf,lHashVal,ppTInfo,rgMemId,pcFound)

#define ITypeLib2_ReleaseTLibAttr(This,pTLibAttr)	\
    (This)->lpVtbl -> ReleaseTLibAttr(This,pTLibAttr)


#define ITypeLib2_GetCustData(This,guid,pVarVal)	\
    (This)->lpVtbl -> GetCustData(This,guid,pVarVal)

#define ITypeLib2_GetLibStatistics(This,pcUniqueNames,pcchUniqueNames)	\
    (This)->lpVtbl -> GetLibStatistics(This,pcUniqueNames,pcchUniqueNames)

#define ITypeLib2_GetDocumentation2(This,index,lcid,pbstrHelpString,pdwHelpStringContext,pbstrHelpStringDll)	\
    (This)->lpVtbl -> GetDocumentation2(This,index,lcid,pbstrHelpString,pdwHelpStringContext,pbstrHelpStringDll)

#define ITypeLib2_GetAllCustData(This,pCustData)	\
    (This)->lpVtbl -> GetAllCustData(This,pCustData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeLib2_GetCustData_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [in] */ REFGUID guid,
    /* [out] */ VARIANT __RPC_FAR *pVarVal);


void __RPC_STUB ITypeLib2_GetCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_RemoteGetLibStatistics_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcUniqueNames,
    /* [out] */ ULONG __RPC_FAR *pcchUniqueNames);


void __RPC_STUB ITypeLib2_RemoteGetLibStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_RemoteGetDocumentation2_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [in] */ INT index,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);


void __RPC_STUB ITypeLib2_RemoteGetDocumentation2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeLib2_GetAllCustData_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [out] */ CUSTDATA __RPC_FAR *pCustData);


void __RPC_STUB ITypeLib2_GetAllCustData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeLib2_INTERFACE_DEFINED__ */


#ifndef __ITypeChangeEvents_INTERFACE_DEFINED__
#define __ITypeChangeEvents_INTERFACE_DEFINED__

/* interface ITypeChangeEvents */
/* [local][unique][uuid][object] */ 

typedef /* [unique] */ ITypeChangeEvents __RPC_FAR *LPTYPECHANGEEVENTS;

typedef 
enum tagCHANGEKIND
    {	CHANGEKIND_ADDMEMBER	= 0,
	CHANGEKIND_DELETEMEMBER	= CHANGEKIND_ADDMEMBER + 1,
	CHANGEKIND_SETNAMES	= CHANGEKIND_DELETEMEMBER + 1,
	CHANGEKIND_SETDOCUMENTATION	= CHANGEKIND_SETNAMES + 1,
	CHANGEKIND_GENERAL	= CHANGEKIND_SETDOCUMENTATION + 1,
	CHANGEKIND_INVALIDATE	= CHANGEKIND_GENERAL + 1,
	CHANGEKIND_CHANGEFAILED	= CHANGEKIND_INVALIDATE + 1,
	CHANGEKIND_MAX	= CHANGEKIND_CHANGEFAILED + 1
    }	CHANGEKIND;


EXTERN_C const IID IID_ITypeChangeEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00020410-0000-0000-C000-000000000046")
    ITypeChangeEvents : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestTypeChange( 
            /* [in] */ CHANGEKIND changeKind,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfoBefore,
            /* [in] */ LPOLESTR pStrName,
            /* [out] */ INT __RPC_FAR *pfCancel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AfterTypeChange( 
            /* [in] */ CHANGEKIND changeKind,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfoAfter,
            /* [in] */ LPOLESTR pStrName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeChangeEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeChangeEvents __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeChangeEvents __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeChangeEvents __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RequestTypeChange )( 
            ITypeChangeEvents __RPC_FAR * This,
            /* [in] */ CHANGEKIND changeKind,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfoBefore,
            /* [in] */ LPOLESTR pStrName,
            /* [out] */ INT __RPC_FAR *pfCancel);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AfterTypeChange )( 
            ITypeChangeEvents __RPC_FAR * This,
            /* [in] */ CHANGEKIND changeKind,
            /* [in] */ ITypeInfo __RPC_FAR *pTInfoAfter,
            /* [in] */ LPOLESTR pStrName);
        
        END_INTERFACE
    } ITypeChangeEventsVtbl;

    interface ITypeChangeEvents
    {
        CONST_VTBL struct ITypeChangeEventsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeChangeEvents_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeChangeEvents_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeChangeEvents_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeChangeEvents_RequestTypeChange(This,changeKind,pTInfoBefore,pStrName,pfCancel)	\
    (This)->lpVtbl -> RequestTypeChange(This,changeKind,pTInfoBefore,pStrName,pfCancel)

#define ITypeChangeEvents_AfterTypeChange(This,changeKind,pTInfoAfter,pStrName)	\
    (This)->lpVtbl -> AfterTypeChange(This,changeKind,pTInfoAfter,pStrName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeChangeEvents_RequestTypeChange_Proxy( 
    ITypeChangeEvents __RPC_FAR * This,
    /* [in] */ CHANGEKIND changeKind,
    /* [in] */ ITypeInfo __RPC_FAR *pTInfoBefore,
    /* [in] */ LPOLESTR pStrName,
    /* [out] */ INT __RPC_FAR *pfCancel);


void __RPC_STUB ITypeChangeEvents_RequestTypeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeChangeEvents_AfterTypeChange_Proxy( 
    ITypeChangeEvents __RPC_FAR * This,
    /* [in] */ CHANGEKIND changeKind,
    /* [in] */ ITypeInfo __RPC_FAR *pTInfoAfter,
    /* [in] */ LPOLESTR pStrName);


void __RPC_STUB ITypeChangeEvents_AfterTypeChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeChangeEvents_INTERFACE_DEFINED__ */


#ifndef __IErrorInfo_INTERFACE_DEFINED__
#define __IErrorInfo_INTERFACE_DEFINED__

/* interface IErrorInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IErrorInfo __RPC_FAR *LPERRORINFO;


EXTERN_C const IID IID_IErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1CF2B120-547D-101B-8E65-08002B2BD119")
    IErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGUID( 
            /* [out] */ GUID __RPC_FAR *pGUID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [out] */ BSTR __RPC_FAR *pBstrSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [out] */ BSTR __RPC_FAR *pBstrDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpFile( 
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpContext( 
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGUID )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSource )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pBstrSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pBstrDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpFile )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHelpContext )( 
            IErrorInfo __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwHelpContext);
        
        END_INTERFACE
    } IErrorInfoVtbl;

    interface IErrorInfo
    {
        CONST_VTBL struct IErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IErrorInfo_GetGUID(This,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,pGUID)

#define IErrorInfo_GetSource(This,pBstrSource)	\
    (This)->lpVtbl -> GetSource(This,pBstrSource)

#define IErrorInfo_GetDescription(This,pBstrDescription)	\
    (This)->lpVtbl -> GetDescription(This,pBstrDescription)

#define IErrorInfo_GetHelpFile(This,pBstrHelpFile)	\
    (This)->lpVtbl -> GetHelpFile(This,pBstrHelpFile)

#define IErrorInfo_GetHelpContext(This,pdwHelpContext)	\
    (This)->lpVtbl -> GetHelpContext(This,pdwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IErrorInfo_GetGUID_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pGUID);


void __RPC_STUB IErrorInfo_GetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IErrorInfo_GetSource_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pBstrSource);


void __RPC_STUB IErrorInfo_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IErrorInfo_GetDescription_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pBstrDescription);


void __RPC_STUB IErrorInfo_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IErrorInfo_GetHelpFile_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);


void __RPC_STUB IErrorInfo_GetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IErrorInfo_GetHelpContext_Proxy( 
    IErrorInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext);


void __RPC_STUB IErrorInfo_GetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICreateErrorInfo_INTERFACE_DEFINED__
#define __ICreateErrorInfo_INTERFACE_DEFINED__

/* interface ICreateErrorInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ICreateErrorInfo __RPC_FAR *LPCREATEERRORINFO;


EXTERN_C const IID IID_ICreateErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22F03340-547D-101B-8E65-08002B2BD119")
    ICreateErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGUID( 
            /* [in] */ REFGUID rguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [in] */ LPOLESTR szSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDescription( 
            /* [in] */ LPOLESTR szDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpFile( 
            /* [in] */ LPOLESTR szHelpFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHelpContext( 
            /* [in] */ DWORD dwHelpContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICreateErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICreateErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGUID )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ REFGUID rguid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSource )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szSource);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDescription )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szDescription);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpFile )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ LPOLESTR szHelpFile);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHelpContext )( 
            ICreateErrorInfo __RPC_FAR * This,
            /* [in] */ DWORD dwHelpContext);
        
        END_INTERFACE
    } ICreateErrorInfoVtbl;

    interface ICreateErrorInfo
    {
        CONST_VTBL struct ICreateErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICreateErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICreateErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICreateErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICreateErrorInfo_SetGUID(This,rguid)	\
    (This)->lpVtbl -> SetGUID(This,rguid)

#define ICreateErrorInfo_SetSource(This,szSource)	\
    (This)->lpVtbl -> SetSource(This,szSource)

#define ICreateErrorInfo_SetDescription(This,szDescription)	\
    (This)->lpVtbl -> SetDescription(This,szDescription)

#define ICreateErrorInfo_SetHelpFile(This,szHelpFile)	\
    (This)->lpVtbl -> SetHelpFile(This,szHelpFile)

#define ICreateErrorInfo_SetHelpContext(This,dwHelpContext)	\
    (This)->lpVtbl -> SetHelpContext(This,dwHelpContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICreateErrorInfo_SetGUID_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ REFGUID rguid);


void __RPC_STUB ICreateErrorInfo_SetGUID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateErrorInfo_SetSource_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szSource);


void __RPC_STUB ICreateErrorInfo_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateErrorInfo_SetDescription_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szDescription);


void __RPC_STUB ICreateErrorInfo_SetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateErrorInfo_SetHelpFile_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ LPOLESTR szHelpFile);


void __RPC_STUB ICreateErrorInfo_SetHelpFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICreateErrorInfo_SetHelpContext_Proxy( 
    ICreateErrorInfo __RPC_FAR * This,
    /* [in] */ DWORD dwHelpContext);


void __RPC_STUB ICreateErrorInfo_SetHelpContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICreateErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ISupportErrorInfo_INTERFACE_DEFINED__
#define __ISupportErrorInfo_INTERFACE_DEFINED__

/* interface ISupportErrorInfo */
/* [unique][uuid][object] */ 

typedef /* [unique] */ ISupportErrorInfo __RPC_FAR *LPSUPPORTERRORINFO;


EXTERN_C const IID IID_ISupportErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF0B3D60-548F-101B-8E65-08002B2BD119")
    ISupportErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InterfaceSupportsErrorInfo( 
            /* [in] */ REFIID riid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISupportErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISupportErrorInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InterfaceSupportsErrorInfo )( 
            ISupportErrorInfo __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        END_INTERFACE
    } ISupportErrorInfoVtbl;

    interface ISupportErrorInfo
    {
        CONST_VTBL struct ISupportErrorInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISupportErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISupportErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISupportErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISupportErrorInfo_InterfaceSupportsErrorInfo(This,riid)	\
    (This)->lpVtbl -> InterfaceSupportsErrorInfo(This,riid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISupportErrorInfo_InterfaceSupportsErrorInfo_Proxy( 
    ISupportErrorInfo __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB ISupportErrorInfo_InterfaceSupportsErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISupportErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ITypeFactory_INTERFACE_DEFINED__
#define __ITypeFactory_INTERFACE_DEFINED__

/* interface ITypeFactory */
/* [uuid][object] */ 


EXTERN_C const IID IID_ITypeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000002E-0000-0000-C000-000000000046")
    ITypeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateFromTypeInfo( 
            /* [in] */ ITypeInfo __RPC_FAR *pTypeInfo,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromTypeInfo )( 
            ITypeFactory __RPC_FAR * This,
            /* [in] */ ITypeInfo __RPC_FAR *pTypeInfo,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);
        
        END_INTERFACE
    } ITypeFactoryVtbl;

    interface ITypeFactory
    {
        CONST_VTBL struct ITypeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeFactory_CreateFromTypeInfo(This,pTypeInfo,riid,ppv)	\
    (This)->lpVtbl -> CreateFromTypeInfo(This,pTypeInfo,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeFactory_CreateFromTypeInfo_Proxy( 
    ITypeFactory __RPC_FAR * This,
    /* [in] */ ITypeInfo __RPC_FAR *pTypeInfo,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITypeFactory_CreateFromTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeFactory_INTERFACE_DEFINED__ */


#ifndef __ITypeMarshal_INTERFACE_DEFINED__
#define __ITypeMarshal_INTERFACE_DEFINED__

/* interface ITypeMarshal */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_ITypeMarshal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000002D-0000-0000-C000-000000000046")
    ITypeMarshal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Size( 
            /* [in] */ PVOID pvType,
            /* [in] */ DWORD dwDestContext,
            /* [in] */ PVOID pvDestContext,
            /* [out] */ ULONG __RPC_FAR *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Marshal( 
            /* [in] */ PVOID pvType,
            /* [in] */ DWORD dwDestContext,
            /* [in] */ PVOID pvDestContext,
            /* [in] */ ULONG cbBufferLength,
            /* [out] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ ULONG __RPC_FAR *pcbWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unmarshal( 
            /* [out] */ PVOID pvType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cbBufferLength,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ ULONG __RPC_FAR *pcbRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Free( 
            /* [in] */ PVOID pvType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeMarshalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ITypeMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ITypeMarshal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ITypeMarshal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Size )( 
            ITypeMarshal __RPC_FAR * This,
            /* [in] */ PVOID pvType,
            /* [in] */ DWORD dwDestContext,
            /* [in] */ PVOID pvDestContext,
            /* [out] */ ULONG __RPC_FAR *pSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Marshal )( 
            ITypeMarshal __RPC_FAR * This,
            /* [in] */ PVOID pvType,
            /* [in] */ DWORD dwDestContext,
            /* [in] */ PVOID pvDestContext,
            /* [in] */ ULONG cbBufferLength,
            /* [out] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ ULONG __RPC_FAR *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unmarshal )( 
            ITypeMarshal __RPC_FAR * This,
            /* [out] */ PVOID pvType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cbBufferLength,
            /* [in] */ BYTE __RPC_FAR *pBuffer,
            /* [out] */ ULONG __RPC_FAR *pcbRead);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Free )( 
            ITypeMarshal __RPC_FAR * This,
            /* [in] */ PVOID pvType);
        
        END_INTERFACE
    } ITypeMarshalVtbl;

    interface ITypeMarshal
    {
        CONST_VTBL struct ITypeMarshalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeMarshal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeMarshal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeMarshal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeMarshal_Size(This,pvType,dwDestContext,pvDestContext,pSize)	\
    (This)->lpVtbl -> Size(This,pvType,dwDestContext,pvDestContext,pSize)

#define ITypeMarshal_Marshal(This,pvType,dwDestContext,pvDestContext,cbBufferLength,pBuffer,pcbWritten)	\
    (This)->lpVtbl -> Marshal(This,pvType,dwDestContext,pvDestContext,cbBufferLength,pBuffer,pcbWritten)

#define ITypeMarshal_Unmarshal(This,pvType,dwFlags,cbBufferLength,pBuffer,pcbRead)	\
    (This)->lpVtbl -> Unmarshal(This,pvType,dwFlags,cbBufferLength,pBuffer,pcbRead)

#define ITypeMarshal_Free(This,pvType)	\
    (This)->lpVtbl -> Free(This,pvType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeMarshal_Size_Proxy( 
    ITypeMarshal __RPC_FAR * This,
    /* [in] */ PVOID pvType,
    /* [in] */ DWORD dwDestContext,
    /* [in] */ PVOID pvDestContext,
    /* [out] */ ULONG __RPC_FAR *pSize);


void __RPC_STUB ITypeMarshal_Size_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeMarshal_Marshal_Proxy( 
    ITypeMarshal __RPC_FAR * This,
    /* [in] */ PVOID pvType,
    /* [in] */ DWORD dwDestContext,
    /* [in] */ PVOID pvDestContext,
    /* [in] */ ULONG cbBufferLength,
    /* [out] */ BYTE __RPC_FAR *pBuffer,
    /* [out] */ ULONG __RPC_FAR *pcbWritten);


void __RPC_STUB ITypeMarshal_Marshal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeMarshal_Unmarshal_Proxy( 
    ITypeMarshal __RPC_FAR * This,
    /* [out] */ PVOID pvType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cbBufferLength,
    /* [in] */ BYTE __RPC_FAR *pBuffer,
    /* [out] */ ULONG __RPC_FAR *pcbRead);


void __RPC_STUB ITypeMarshal_Unmarshal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeMarshal_Free_Proxy( 
    ITypeMarshal __RPC_FAR * This,
    /* [in] */ PVOID pvType);


void __RPC_STUB ITypeMarshal_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeMarshal_INTERFACE_DEFINED__ */


#ifndef __IRecordInfo_INTERFACE_DEFINED__
#define __IRecordInfo_INTERFACE_DEFINED__

/* interface IRecordInfo */
/* [uuid][object][local] */ 

typedef /* [unique] */ IRecordInfo __RPC_FAR *LPRECORDINFO;


EXTERN_C const IID IID_IRecordInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000002F-0000-0000-C000-000000000046")
    IRecordInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RecordInit( 
            /* [out] */ PVOID pvNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecordClear( 
            /* [in] */ PVOID pvExisting) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecordCopy( 
            /* [in] */ PVOID pvExisting,
            /* [out] */ PVOID pvNew) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuid( 
            /* [out] */ GUID __RPC_FAR *pguid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *pbstrName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( 
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTypeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetField( 
            /* [in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [out] */ VARIANT __RPC_FAR *pvarField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldNoCopy( 
            /* [in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [out] */ VARIANT __RPC_FAR *pvarField,
            /* [out] */ PVOID __RPC_FAR *ppvDataCArray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutField( 
            /* [in] */ ULONG wFlags,
            /* [out][in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [in] */ VARIANT __RPC_FAR *pvarField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutFieldNoCopy( 
            /* [in] */ ULONG wFlags,
            /* [out][in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [in] */ VARIANT __RPC_FAR *pvarField) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldNames( 
            /* [out][in] */ ULONG __RPC_FAR *pcNames,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsMatchingType( 
            /* [in] */ IRecordInfo __RPC_FAR *pRecordInfo) = 0;
        
        virtual PVOID STDMETHODCALLTYPE RecordCreate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecordCreateCopy( 
            /* [in] */ PVOID pvSource,
            /* [out] */ PVOID __RPC_FAR *ppvDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RecordDestroy( 
            /* [in] */ PVOID pvRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRecordInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRecordInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRecordInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordInit )( 
            IRecordInfo __RPC_FAR * This,
            /* [out] */ PVOID pvNew);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordClear )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvExisting);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordCopy )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvExisting,
            /* [out] */ PVOID pvNew);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuid )( 
            IRecordInfo __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pguid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IRecordInfo __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IRecordInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRecordInfo __RPC_FAR * This,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTypeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetField )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [out] */ VARIANT __RPC_FAR *pvarField);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldNoCopy )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [out] */ VARIANT __RPC_FAR *pvarField,
            /* [out] */ PVOID __RPC_FAR *ppvDataCArray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutField )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ ULONG wFlags,
            /* [out][in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [in] */ VARIANT __RPC_FAR *pvarField);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFieldNoCopy )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ ULONG wFlags,
            /* [out][in] */ PVOID pvData,
            /* [in] */ LPCOLESTR szFieldName,
            /* [in] */ VARIANT __RPC_FAR *pvarField);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFieldNames )( 
            IRecordInfo __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pcNames,
            /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames);
        
        BOOL ( STDMETHODCALLTYPE __RPC_FAR *IsMatchingType )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ IRecordInfo __RPC_FAR *pRecordInfo);
        
        PVOID ( STDMETHODCALLTYPE __RPC_FAR *RecordCreate )( 
            IRecordInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordCreateCopy )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvSource,
            /* [out] */ PVOID __RPC_FAR *ppvDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RecordDestroy )( 
            IRecordInfo __RPC_FAR * This,
            /* [in] */ PVOID pvRecord);
        
        END_INTERFACE
    } IRecordInfoVtbl;

    interface IRecordInfo
    {
        CONST_VTBL struct IRecordInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRecordInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRecordInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRecordInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRecordInfo_RecordInit(This,pvNew)	\
    (This)->lpVtbl -> RecordInit(This,pvNew)

#define IRecordInfo_RecordClear(This,pvExisting)	\
    (This)->lpVtbl -> RecordClear(This,pvExisting)

#define IRecordInfo_RecordCopy(This,pvExisting,pvNew)	\
    (This)->lpVtbl -> RecordCopy(This,pvExisting,pvNew)

#define IRecordInfo_GetGuid(This,pguid)	\
    (This)->lpVtbl -> GetGuid(This,pguid)

#define IRecordInfo_GetName(This,pbstrName)	\
    (This)->lpVtbl -> GetName(This,pbstrName)

#define IRecordInfo_GetSize(This,pcbSize)	\
    (This)->lpVtbl -> GetSize(This,pcbSize)

#define IRecordInfo_GetTypeInfo(This,ppTypeInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,ppTypeInfo)

#define IRecordInfo_GetField(This,pvData,szFieldName,pvarField)	\
    (This)->lpVtbl -> GetField(This,pvData,szFieldName,pvarField)

#define IRecordInfo_GetFieldNoCopy(This,pvData,szFieldName,pvarField,ppvDataCArray)	\
    (This)->lpVtbl -> GetFieldNoCopy(This,pvData,szFieldName,pvarField,ppvDataCArray)

#define IRecordInfo_PutField(This,wFlags,pvData,szFieldName,pvarField)	\
    (This)->lpVtbl -> PutField(This,wFlags,pvData,szFieldName,pvarField)

#define IRecordInfo_PutFieldNoCopy(This,wFlags,pvData,szFieldName,pvarField)	\
    (This)->lpVtbl -> PutFieldNoCopy(This,wFlags,pvData,szFieldName,pvarField)

#define IRecordInfo_GetFieldNames(This,pcNames,rgBstrNames)	\
    (This)->lpVtbl -> GetFieldNames(This,pcNames,rgBstrNames)

#define IRecordInfo_IsMatchingType(This,pRecordInfo)	\
    (This)->lpVtbl -> IsMatchingType(This,pRecordInfo)

#define IRecordInfo_RecordCreate(This)	\
    (This)->lpVtbl -> RecordCreate(This)

#define IRecordInfo_RecordCreateCopy(This,pvSource,ppvDest)	\
    (This)->lpVtbl -> RecordCreateCopy(This,pvSource,ppvDest)

#define IRecordInfo_RecordDestroy(This,pvRecord)	\
    (This)->lpVtbl -> RecordDestroy(This,pvRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRecordInfo_RecordInit_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out] */ PVOID pvNew);


void __RPC_STUB IRecordInfo_RecordInit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_RecordClear_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvExisting);


void __RPC_STUB IRecordInfo_RecordClear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_RecordCopy_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvExisting,
    /* [out] */ PVOID pvNew);


void __RPC_STUB IRecordInfo_RecordCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetGuid_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pguid);


void __RPC_STUB IRecordInfo_GetGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetName_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrName);


void __RPC_STUB IRecordInfo_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetSize_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IRecordInfo_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetTypeInfo_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTypeInfo);


void __RPC_STUB IRecordInfo_GetTypeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetField_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvData,
    /* [in] */ LPCOLESTR szFieldName,
    /* [out] */ VARIANT __RPC_FAR *pvarField);


void __RPC_STUB IRecordInfo_GetField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetFieldNoCopy_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvData,
    /* [in] */ LPCOLESTR szFieldName,
    /* [out] */ VARIANT __RPC_FAR *pvarField,
    /* [out] */ PVOID __RPC_FAR *ppvDataCArray);


void __RPC_STUB IRecordInfo_GetFieldNoCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_PutField_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ ULONG wFlags,
    /* [out][in] */ PVOID pvData,
    /* [in] */ LPCOLESTR szFieldName,
    /* [in] */ VARIANT __RPC_FAR *pvarField);


void __RPC_STUB IRecordInfo_PutField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_PutFieldNoCopy_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ ULONG wFlags,
    /* [out][in] */ PVOID pvData,
    /* [in] */ LPCOLESTR szFieldName,
    /* [in] */ VARIANT __RPC_FAR *pvarField);


void __RPC_STUB IRecordInfo_PutFieldNoCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_GetFieldNames_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pcNames,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames);


void __RPC_STUB IRecordInfo_GetFieldNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IRecordInfo_IsMatchingType_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ IRecordInfo __RPC_FAR *pRecordInfo);


void __RPC_STUB IRecordInfo_IsMatchingType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


PVOID STDMETHODCALLTYPE IRecordInfo_RecordCreate_Proxy( 
    IRecordInfo __RPC_FAR * This);


void __RPC_STUB IRecordInfo_RecordCreate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_RecordCreateCopy_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvSource,
    /* [out] */ PVOID __RPC_FAR *ppvDest);


void __RPC_STUB IRecordInfo_RecordCreateCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRecordInfo_RecordDestroy_Proxy( 
    IRecordInfo __RPC_FAR * This,
    /* [in] */ PVOID pvRecord);


void __RPC_STUB IRecordInfo_RecordDestroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRecordInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_oaidl_0082 */
/* [local] */ 





typedef struct tagVersionedStream
    {
    GUID guidVersion;
    IStream __RPC_FAR *pStream;
    }	VERSIONEDSTREAM;

typedef struct tagVersionedStream __RPC_FAR *LPVERSIONEDSTREAM;


// Flags for IPropertySetStorage::Create
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

//   (This flag is only supported on StgCreatePropStg & StgOpenPropStg
#define	PROPSETFLAG_UNBUFFERED	( 4 )

//   (This flag causes a version-1 property set to be created
#define	PROPSETFLAG_CASE_SENSITIVE	( 8 )


// Flags for the reservied PID_BEHAVIOR property
#define	PROPSET_BEHAVIOR_CASE_SENSITIVE	( 1 )

#ifdef MIDL_PASS
// This is the PROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT PROPVARIANT;

#else
// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT PROPVARIANT;
#endif
typedef struct tagCAC
    {
    ULONG cElems;
    /* [size_is] */ CHAR __RPC_FAR *pElems;
    }	CAC;

typedef struct tagCAUB
    {
    ULONG cElems;
    /* [size_is] */ UCHAR __RPC_FAR *pElems;
    }	CAUB;

typedef struct tagCAI
    {
    ULONG cElems;
    /* [size_is] */ SHORT __RPC_FAR *pElems;
    }	CAI;

typedef struct tagCAUI
    {
    ULONG cElems;
    /* [size_is] */ USHORT __RPC_FAR *pElems;
    }	CAUI;

typedef struct tagCAL
    {
    ULONG cElems;
    /* [size_is] */ LONG __RPC_FAR *pElems;
    }	CAL;

typedef struct tagCAUL
    {
    ULONG cElems;
    /* [size_is] */ ULONG __RPC_FAR *pElems;
    }	CAUL;

typedef struct tagCAFLT
    {
    ULONG cElems;
    /* [size_is] */ FLOAT __RPC_FAR *pElems;
    }	CAFLT;

typedef struct tagCADBL
    {
    ULONG cElems;
    /* [size_is] */ DOUBLE __RPC_FAR *pElems;
    }	CADBL;

typedef struct tagCACY
    {
    ULONG cElems;
    /* [size_is] */ CY __RPC_FAR *pElems;
    }	CACY;

typedef struct tagCADATE
    {
    ULONG cElems;
    /* [size_is] */ DATE __RPC_FAR *pElems;
    }	CADATE;

typedef struct tagCABSTR
    {
    ULONG cElems;
    /* [size_is] */ BSTR __RPC_FAR *pElems;
    }	CABSTR;

typedef struct tagCABSTRBLOB
    {
    ULONG cElems;
    /* [size_is] */ BSTRBLOB __RPC_FAR *pElems;
    }	CABSTRBLOB;

typedef struct tagCABOOL
    {
    ULONG cElems;
    /* [size_is] */ VARIANT_BOOL __RPC_FAR *pElems;
    }	CABOOL;

typedef struct tagCASCODE
    {
    ULONG cElems;
    /* [size_is] */ SCODE __RPC_FAR *pElems;
    }	CASCODE;

typedef struct tagCAPROPVARIANT
    {
    ULONG cElems;
    /* [size_is] */ PROPVARIANT __RPC_FAR *pElems;
    }	CAPROPVARIANT;

typedef struct tagCAH
    {
    ULONG cElems;
    /* [size_is] */ LARGE_INTEGER __RPC_FAR *pElems;
    }	CAH;

typedef struct tagCAUH
    {
    ULONG cElems;
    /* [size_is] */ ULARGE_INTEGER __RPC_FAR *pElems;
    }	CAUH;

typedef struct tagCALPSTR
    {
    ULONG cElems;
    /* [size_is] */ LPSTR __RPC_FAR *pElems;
    }	CALPSTR;

typedef struct tagCALPWSTR
    {
    ULONG cElems;
    /* [size_is] */ LPWSTR __RPC_FAR *pElems;
    }	CALPWSTR;

typedef struct tagCAFILETIME
    {
    ULONG cElems;
    /* [size_is] */ FILETIME __RPC_FAR *pElems;
    }	CAFILETIME;

typedef struct tagCACLIPDATA
    {
    ULONG cElems;
    /* [size_is] */ CLIPDATA __RPC_FAR *pElems;
    }	CACLIPDATA;

typedef struct tagCACLSID
    {
    ULONG cElems;
    /* [size_is] */ CLSID __RPC_FAR *pElems;
    }	CACLSID;

#ifdef MIDL_PASS
// This is the PROPVARIANT padding layout for marshaling.
typedef BYTE PROPVAR_PAD1;

typedef BYTE PROPVAR_PAD2;

typedef ULONG PROPVAR_PAD3;

#else
// This is the standard C layout of the structure.
typedef WORD PROPVAR_PAD1;
typedef WORD PROPVAR_PAD2;
typedef WORD PROPVAR_PAD3;
#define tag_inner_PROPVARIANT
#endif
#ifndef MIDL_PASS
struct tagPROPVARIANT {
  union {
#endif
struct tag_inner_PROPVARIANT
    {
    VARTYPE vt;
    PROPVAR_PAD1 wReserved1;
    PROPVAR_PAD2 wReserved2;
    PROPVAR_PAD3 wReserved3;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */  /* Empty union arm */ 
        /* [case()] */ CHAR cVal;
        /* [case()] */ UCHAR bVal;
        /* [case()] */ SHORT iVal;
        /* [case()] */ USHORT uiVal;
        /* [case()] */ LONG lVal;
        /* [case()] */ ULONG ulVal;
        /* [case()] */ INT intVal;
        /* [case()] */ UINT uintVal;
        /* [case()] */ LARGE_INTEGER hVal;
        /* [case()] */ ULARGE_INTEGER uhVal;
        /* [case()] */ FLOAT fltVal;
        /* [case()] */ DOUBLE dblVal;
        /* [case()] */ VARIANT_BOOL boolVal;
        /* [case()] */ _VARIANT_BOOL bool;
        /* [case()] */ SCODE scode;
        /* [case()] */ CY cyVal;
        /* [case()] */ DATE date;
        /* [case()] */ FILETIME filetime;
        /* [case()] */ CLSID __RPC_FAR *puuid;
        /* [case()] */ CLIPDATA __RPC_FAR *pclipdata;
        /* [case()] */ BSTR bstrVal;
        /* [case()] */ BSTRBLOB bstrblobVal;
        /* [case()] */ BLOB blob;
        /* [case()] */ LPSTR pszVal;
        /* [case()] */ LPWSTR pwszVal;
        /* [case()] */ IUnknown __RPC_FAR *punkVal;
        /* [case()] */ IDispatch __RPC_FAR *pdispVal;
        /* [case()] */ IStream __RPC_FAR *pStream;
        /* [case()] */ IStorage __RPC_FAR *pStorage;
        /* [case()] */ LPVERSIONEDSTREAM pVersionedStream;
        /* [case()] */ LPSAFEARRAY parray;
        /* [case()] */ CAC cac;
        /* [case()] */ CAUB caub;
        /* [case()] */ CAI cai;
        /* [case()] */ CAUI caui;
        /* [case()] */ CAL cal;
        /* [case()] */ CAUL caul;
        /* [case()] */ CAH cah;
        /* [case()] */ CAUH cauh;
        /* [case()] */ CAFLT caflt;
        /* [case()] */ CADBL cadbl;
        /* [case()] */ CABOOL cabool;
        /* [case()] */ CASCODE cascode;
        /* [case()] */ CACY cacy;
        /* [case()] */ CADATE cadate;
        /* [case()] */ CAFILETIME cafiletime;
        /* [case()] */ CACLSID cauuid;
        /* [case()] */ CACLIPDATA caclipdata;
        /* [case()] */ CABSTR cabstr;
        /* [case()] */ CABSTRBLOB cabstrblob;
        /* [case()] */ CALPSTR calpstr;
        /* [case()] */ CALPWSTR calpwstr;
        /* [case()] */ CAPROPVARIANT capropvar;
        /* [case()] */ CHAR __RPC_FAR *pcVal;
        /* [case()] */ UCHAR __RPC_FAR *pbVal;
        /* [case()] */ SHORT __RPC_FAR *piVal;
        /* [case()] */ USHORT __RPC_FAR *puiVal;
        /* [case()] */ LONG __RPC_FAR *plVal;
        /* [case()] */ ULONG __RPC_FAR *pulVal;
        /* [case()] */ INT __RPC_FAR *pintVal;
        /* [case()] */ UINT __RPC_FAR *puintVal;
        /* [case()] */ FLOAT __RPC_FAR *pfltVal;
        /* [case()] */ DOUBLE __RPC_FAR *pdblVal;
        /* [case()] */ VARIANT_BOOL __RPC_FAR *pboolVal;
        /* [case()] */ DECIMAL __RPC_FAR *pdecVal;
        /* [case()] */ SCODE __RPC_FAR *pscode;
        /* [case()] */ CY __RPC_FAR *pcyVal;
        /* [case()] */ DATE __RPC_FAR *pdate;
        /* [case()] */ BSTR __RPC_FAR *pbstrVal;
        /* [case()] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkVal;
        /* [case()] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispVal;
        /* [case()] */ LPSAFEARRAY __RPC_FAR *pparray;
        /* [case()] */ PROPVARIANT __RPC_FAR *pvarVal;
        }	;
    };
#ifndef MIDL_PASS
    DECIMAL decVal;
  };
};
#endif
#ifdef MIDL_PASS
// This is the LPPROPVARIANT definition for marshaling.
typedef struct tag_inner_PROPVARIANT __RPC_FAR *LPPROPVARIANT;

typedef const PROPVARIANT __RPC_FAR *REFPROPVARIANT;

#else

// This is the standard C layout of the PROPVARIANT.
typedef struct tagPROPVARIANT * LPPROPVARIANT;

#ifndef _REFPROPVARIANT_DEFINED
#define _REFPROPVARIANT_DEFINED
#ifdef __cplusplus
#define REFPROPVARIANT const PROPVARIANT &
#else
#define REFPROPVARIANT const PROPVARIANT * __MIDL_CONST
#endif
#endif

#endif

// Reserved global Property IDs
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_BEHAVIOR	( 0x80000003 )

#define	PID_ILLEGAL	( 0xffffffff )

// Range which is read-only to downlevel implementations
#define	PID_MIN_READONLY	( 0x80000000 )

#define	PID_MAX_READONLY	( 0xbfffffff )

// Property IDs for the DiscardableInformation Property Set

#define PIDDI_THUMBNAIL          0x00000002L // VT_BLOB

// Property IDs for the SummaryInformation Property Set

#define PIDSI_TITLE               0x00000002L  // VT_LPSTR
#define PIDSI_SUBJECT             0x00000003L  // VT_LPSTR
#define PIDSI_AUTHOR              0x00000004L  // VT_LPSTR
#define PIDSI_KEYWORDS            0x00000005L  // VT_LPSTR
#define PIDSI_COMMENTS            0x00000006L  // VT_LPSTR
#define PIDSI_TEMPLATE            0x00000007L  // VT_LPSTR
#define PIDSI_LASTAUTHOR          0x00000008L  // VT_LPSTR
#define PIDSI_REVNUMBER           0x00000009L  // VT_LPSTR
#define PIDSI_EDITTIME            0x0000000aL  // VT_FILETIME (UTC)
#define PIDSI_LASTPRINTED         0x0000000bL  // VT_FILETIME (UTC)
#define PIDSI_CREATE_DTM          0x0000000cL  // VT_FILETIME (UTC)
#define PIDSI_LASTSAVE_DTM        0x0000000dL  // VT_FILETIME (UTC)
#define PIDSI_PAGECOUNT           0x0000000eL  // VT_I4
#define PIDSI_WORDCOUNT           0x0000000fL  // VT_I4
#define PIDSI_CHARCOUNT           0x00000010L  // VT_I4
#define PIDSI_THUMBNAIL           0x00000011L  // VT_CF
#define PIDSI_APPNAME             0x00000012L  // VT_LPSTR
#define PIDSI_DOC_SECURITY        0x00000013L  // VT_I4

// Property IDs for the DocSummaryInformation Property Set

#define PIDDSI_CATEGORY          0x00000002 // VT_LPSTR
#define PIDDSI_PRESFORMAT        0x00000003 // VT_LPSTR
#define PIDDSI_BYTECOUNT         0x00000004 // VT_I4
#define PIDDSI_LINECOUNT         0x00000005 // VT_I4
#define PIDDSI_PARCOUNT          0x00000006 // VT_I4
#define PIDDSI_SLIDECOUNT        0x00000007 // VT_I4
#define PIDDSI_NOTECOUNT         0x00000008 // VT_I4
#define PIDDSI_HIDDENCOUNT       0x00000009 // VT_I4
#define PIDDSI_MMCLIPCOUNT       0x0000000A // VT_I4
#define PIDDSI_SCALE             0x0000000B // VT_BOOL
#define PIDDSI_HEADINGPAIR       0x0000000C // VT_VARIANT | VT_VECTOR
#define PIDDSI_DOCPARTS          0x0000000D // VT_LPSTR | VT_VECTOR
#define PIDDSI_MANAGER           0x0000000E // VT_LPSTR
#define PIDDSI_COMPANY           0x0000000F // VT_LPSTR
#define PIDDSI_LINKSDIRTY        0x00000010 // VT_BOOL


//  FMTID_MediaFileSummaryInfo - Property IDs

#define PIDMSI_EDITOR                   0x00000002L  // VT_LPWSTR
#define PIDMSI_SUPPLIER                 0x00000003L  // VT_LPWSTR
#define PIDMSI_SOURCE                   0x00000004L  // VT_LPWSTR
#define PIDMSI_SEQUENCE_NO              0x00000005L  // VT_LPWSTR
#define PIDMSI_PROJECT                  0x00000006L  // VT_LPWSTR
#define PIDMSI_STATUS                   0x00000007L  // VT_UI4
#define PIDMSI_OWNER                    0x00000008L  // VT_LPWSTR
#define PIDMSI_RATING                   0x00000009L  // VT_LPWSTR
#define PIDMSI_PRODUCTION               0x0000000AL  // VT_FILETIME (UTC)
#define PIDMSI_COPYRIGHT                0x0000000BL  // VT_LPWSTR

//  PIDMSI_STATUS value definitions

enum PIDMSI_STATUS_VALUE
    {	PIDMSI_STATUS_NORMAL	= 0,
	PIDMSI_STATUS_NEW	= PIDMSI_STATUS_NORMAL + 1,
	PIDMSI_STATUS_PRELIM	= PIDMSI_STATUS_NEW + 1,
	PIDMSI_STATUS_DRAFT	= PIDMSI_STATUS_PRELIM + 1,
	PIDMSI_STATUS_INPROGRESS	= PIDMSI_STATUS_DRAFT + 1,
	PIDMSI_STATUS_EDIT	= PIDMSI_STATUS_INPROGRESS + 1,
	PIDMSI_STATUS_REVIEW	= PIDMSI_STATUS_EDIT + 1,
	PIDMSI_STATUS_PROOF	= PIDMSI_STATUS_REVIEW + 1,
	PIDMSI_STATUS_FINAL	= PIDMSI_STATUS_PROOF + 1,
	PIDMSI_STATUS_OTHER	= 0x7fff
    };
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct tagPROPSPEC
    {
    ULONG ulKind;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ PROPID propid;
        /* [case()] */ LPOLESTR lpwstr;
        /* [default] */  /* Empty union arm */ 
        }	;
    }	PROPSPEC;

typedef struct tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    }	STATPROPSTG;

// Macros for parsing the OS Version of the Property Set Header
#define PROPSETHDR_OSVER_KIND(dwOSVer)      HIWORD( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE(LOWORD( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF
typedef struct tagSTATPROPSETSTG
    {
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
    }	STATPROPSETSTG;



extern RPC_IF_HANDLE __MIDL_itf_oaidl_0082_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0082_v0_0_s_ifspec;

#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

/* interface IPropertyStorage */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPropertyStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000138-0000-0000-C000-000000000046")
    IPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
            /* [size_is][out] */ PROPVARIANT __RPC_FAR rgpropvar[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT __RPC_FAR rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
            /* [size_is][out] */ LPOLESTR __RPC_FAR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
            /* [size_is][in] */ const LPOLESTR __RPC_FAR rglpwstrName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD grfCommitFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimes( 
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClass( 
            /* [in] */ REFCLSID clsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stat( 
            /* [out] */ STATPROPSETSTG __RPC_FAR *pstatpsstg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertyStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertyStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadMultiple )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
            /* [size_is][out] */ PROPVARIANT __RPC_FAR rgpropvar[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteMultiple )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
            /* [size_is][in] */ const PROPVARIANT __RPC_FAR rgpropvar[  ],
            /* [in] */ PROPID propidNameFirst);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteMultiple )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpspec,
            /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadPropertyNames )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
            /* [size_is][out] */ LPOLESTR __RPC_FAR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WritePropertyNames )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
            /* [size_is][in] */ const LPOLESTR __RPC_FAR rglpwstrName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeletePropertyNames )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ ULONG cpropid,
            /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert )( 
            IPropertyStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IPropertyStorage __RPC_FAR * This,
            /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTimes )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ const FILETIME __RPC_FAR *pctime,
            /* [in] */ const FILETIME __RPC_FAR *patime,
            /* [in] */ const FILETIME __RPC_FAR *pmtime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClass )( 
            IPropertyStorage __RPC_FAR * This,
            /* [in] */ REFCLSID clsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stat )( 
            IPropertyStorage __RPC_FAR * This,
            /* [out] */ STATPROPSETSTG __RPC_FAR *pstatpsstg);
        
        END_INTERFACE
    } IPropertyStorageVtbl;

    interface IPropertyStorage
    {
        CONST_VTBL struct IPropertyStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyStorage_ReadMultiple(This,cpspec,rgpspec,rgpropvar)	\
    (This)->lpVtbl -> ReadMultiple(This,cpspec,rgpspec,rgpropvar)

#define IPropertyStorage_WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)	\
    (This)->lpVtbl -> WriteMultiple(This,cpspec,rgpspec,rgpropvar,propidNameFirst)

#define IPropertyStorage_DeleteMultiple(This,cpspec,rgpspec)	\
    (This)->lpVtbl -> DeleteMultiple(This,cpspec,rgpspec)

#define IPropertyStorage_ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> ReadPropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IPropertyStorage_WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)	\
    (This)->lpVtbl -> WritePropertyNames(This,cpropid,rgpropid,rglpwstrName)

#define IPropertyStorage_DeletePropertyNames(This,cpropid,rgpropid)	\
    (This)->lpVtbl -> DeletePropertyNames(This,cpropid,rgpropid)

#define IPropertyStorage_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IPropertyStorage_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IPropertyStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#define IPropertyStorage_SetTimes(This,pctime,patime,pmtime)	\
    (This)->lpVtbl -> SetTimes(This,pctime,patime,pmtime)

#define IPropertyStorage_SetClass(This,clsid)	\
    (This)->lpVtbl -> SetClass(This,clsid)

#define IPropertyStorage_Stat(This,pstatpsstg)	\
    (This)->lpVtbl -> Stat(This,pstatpsstg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyStorage_ReadMultiple_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
    /* [size_is][out] */ PROPVARIANT __RPC_FAR rgpropvar[  ]);


void __RPC_STUB IPropertyStorage_ReadMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_WriteMultiple_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ],
    /* [size_is][in] */ const PROPVARIANT __RPC_FAR rgpropvar[  ],
    /* [in] */ PROPID propidNameFirst);


void __RPC_STUB IPropertyStorage_WriteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_DeleteMultiple_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpspec,
    /* [size_is][in] */ const PROPSPEC __RPC_FAR rgpspec[  ]);


void __RPC_STUB IPropertyStorage_DeleteMultiple_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_ReadPropertyNames_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
    /* [size_is][out] */ LPOLESTR __RPC_FAR rglpwstrName[  ]);


void __RPC_STUB IPropertyStorage_ReadPropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_WritePropertyNames_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ],
    /* [size_is][in] */ const LPOLESTR __RPC_FAR rglpwstrName[  ]);


void __RPC_STUB IPropertyStorage_WritePropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_DeletePropertyNames_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ ULONG cpropid,
    /* [size_is][in] */ const PROPID __RPC_FAR rgpropid[  ]);


void __RPC_STUB IPropertyStorage_DeletePropertyNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Commit_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ DWORD grfCommitFlags);


void __RPC_STUB IPropertyStorage_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Revert_Proxy( 
    IPropertyStorage __RPC_FAR * This);


void __RPC_STUB IPropertyStorage_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Enum_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPropertyStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_SetTimes_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ const FILETIME __RPC_FAR *pctime,
    /* [in] */ const FILETIME __RPC_FAR *patime,
    /* [in] */ const FILETIME __RPC_FAR *pmtime);


void __RPC_STUB IPropertyStorage_SetTimes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_SetClass_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [in] */ REFCLSID clsid);


void __RPC_STUB IPropertyStorage_SetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyStorage_Stat_Proxy( 
    IPropertyStorage __RPC_FAR * This,
    /* [out] */ STATPROPSETSTG __RPC_FAR *pstatpsstg);


void __RPC_STUB IPropertyStorage_Stat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyStorage_INTERFACE_DEFINED__ */


#ifndef __IPropertySetStorage_INTERFACE_DEFINED__
#define __IPropertySetStorage_INTERFACE_DEFINED__

/* interface IPropertySetStorage */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IPropertySetStorage __RPC_FAR *LPPROPERTYSETSTORAGE;


EXTERN_C const IID IID_IPropertySetStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013A-0000-0000-C000-000000000046")
    IPropertySetStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ REFFMTID rfmtid,
            /* [unique][in] */ const CLSID __RPC_FAR *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ REFFMTID rfmtid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertySetStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPropertySetStorage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPropertySetStorage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPropertySetStorage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IPropertySetStorage __RPC_FAR * This,
            /* [in] */ REFFMTID rfmtid,
            /* [unique][in] */ const CLSID __RPC_FAR *pclsid,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IPropertySetStorage __RPC_FAR * This,
            /* [in] */ REFFMTID rfmtid,
            /* [in] */ DWORD grfMode,
            /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IPropertySetStorage __RPC_FAR * This,
            /* [in] */ REFFMTID rfmtid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Enum )( 
            IPropertySetStorage __RPC_FAR * This,
            /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IPropertySetStorageVtbl;

    interface IPropertySetStorage
    {
        CONST_VTBL struct IPropertySetStorageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertySetStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertySetStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertySetStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertySetStorage_Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)	\
    (This)->lpVtbl -> Create(This,rfmtid,pclsid,grfFlags,grfMode,ppprstg)

#define IPropertySetStorage_Open(This,rfmtid,grfMode,ppprstg)	\
    (This)->lpVtbl -> Open(This,rfmtid,grfMode,ppprstg)

#define IPropertySetStorage_Delete(This,rfmtid)	\
    (This)->lpVtbl -> Delete(This,rfmtid)

#define IPropertySetStorage_Enum(This,ppenum)	\
    (This)->lpVtbl -> Enum(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertySetStorage_Create_Proxy( 
    IPropertySetStorage __RPC_FAR * This,
    /* [in] */ REFFMTID rfmtid,
    /* [unique][in] */ const CLSID __RPC_FAR *pclsid,
    /* [in] */ DWORD grfFlags,
    /* [in] */ DWORD grfMode,
    /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg);


void __RPC_STUB IPropertySetStorage_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Open_Proxy( 
    IPropertySetStorage __RPC_FAR * This,
    /* [in] */ REFFMTID rfmtid,
    /* [in] */ DWORD grfMode,
    /* [out] */ IPropertyStorage __RPC_FAR *__RPC_FAR *ppprstg);


void __RPC_STUB IPropertySetStorage_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Delete_Proxy( 
    IPropertySetStorage __RPC_FAR * This,
    /* [in] */ REFFMTID rfmtid);


void __RPC_STUB IPropertySetStorage_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertySetStorage_Enum_Proxy( 
    IPropertySetStorage __RPC_FAR * This,
    /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IPropertySetStorage_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertySetStorage_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumSTATPROPSTG __RPC_FAR *LPENUMSTATPROPSTG;


EXTERN_C const IID IID_IEnumSTATPROPSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000139-0000-0000-C000-000000000046")
    IEnumSTATPROPSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumSTATPROPSTG __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumSTATPROPSTG __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumSTATPROPSTG __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumSTATPROPSTG __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumSTATPROPSTG __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumSTATPROPSTG __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumSTATPROPSTG __RPC_FAR * This,
            /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSTGVtbl;

    interface IEnumSTATPROPSTG
    {
        CONST_VTBL struct IEnumSTATPROPSTGVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATPROPSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATPROPSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATPROPSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATPROPSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATPROPSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATPROPSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumSTATPROPSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Skip_Proxy( 
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATPROPSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Reset_Proxy( 
    IEnumSTATPROPSTG __RPC_FAR * This);


void __RPC_STUB IEnumSTATPROPSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Clone_Proxy( 
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [out] */ IEnumSTATPROPSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumSTATPROPSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSTG_INTERFACE_DEFINED__ */


#ifndef __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__
#define __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__

/* interface IEnumSTATPROPSETSTG */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumSTATPROPSETSTG __RPC_FAR *LPENUMSTATPROPSETSTG;


EXTERN_C const IID IID_IEnumSTATPROPSETSTG;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000013B-0000-0000-C000-000000000046")
    IEnumSTATPROPSETSTG : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumSTATPROPSETSTGVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumSTATPROPSETSTG __RPC_FAR * This,
            /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumSTATPROPSETSTGVtbl;

    interface IEnumSTATPROPSETSTG
    {
        CONST_VTBL struct IEnumSTATPROPSETSTGVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumSTATPROPSETSTG_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumSTATPROPSETSTG_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumSTATPROPSETSTG_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumSTATPROPSETSTG_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumSTATPROPSETSTG_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumSTATPROPSETSTG_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumSTATPROPSETSTG_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_RemoteNext_Proxy( 
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumSTATPROPSETSTG_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Skip_Proxy( 
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumSTATPROPSETSTG_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Reset_Proxy( 
    IEnumSTATPROPSETSTG __RPC_FAR * This);


void __RPC_STUB IEnumSTATPROPSETSTG_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Clone_Proxy( 
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [out] */ IEnumSTATPROPSETSTG __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumSTATPROPSETSTG_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumSTATPROPSETSTG_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_oaidl_0086 */
/* [local] */ 

typedef /* [unique] */ IPropertyStorage __RPC_FAR *LPPROPERTYSTORAGE;

WINOLEAUTAPI PropVariantCopy ( PROPVARIANT * pvarDest, const PROPVARIANT * pvarSrc );
WINOLEAUTAPI PropVariantClear ( PROPVARIANT * pvar );
WINOLEAUTAPI FreePropVariantArray ( ULONG cVariants, PROPVARIANT * rgvars );

#define _PROPVARIANTINIT_DEFINED_
#   ifdef __cplusplus
inline void PropVariantInit ( PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}
#   else
#   define PropVariantInit(pvar) memset ( (pvar), 0, sizeof(PROPVARIANT) )
#   endif


#ifndef _STGCREATEPROPSTG_DEFINED_
WINOLEAPI StgCreatePropStg( IUnknown* pUnk, REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgOpenPropStg( IUnknown* pUnk, REFFMTID fmtid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage **ppPropStg );
WINOLEAPI StgCreatePropSetStg( IStorage *pStorage, DWORD dwReserved, IPropertySetStorage **ppPropSetStg);

#define CCH_MAX_PROPSTG_NAME    31
WINOLEAPI FmtIdToPropStgName( const FMTID *pfmtid, LPOLESTR oszName );
WINOLEAPI PropStgNameToFmtId( const LPOLESTR oszName, FMTID *pfmtid );
#endif
#ifndef _SERIALIZEDPROPERTYVALUE_DEFINED_
#define _SERIALIZEDPROPERTYVALUE_DEFINED_
typedef struct tagSERIALIZEDPROPERTYVALUE		// prop
{
    DWORD	dwType;
    BYTE	rgb[1];
} SERIALIZEDPROPERTYVALUE;
#endif
#if ( _MSC_VER >= 800 ) && (! defined (UNDER_CE))
#pragma warning(default:4201) /* Nameless struct/union */
#endif


extern RPC_IF_HANDLE __MIDL_itf_oaidl_0086_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_oaidl_0086_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  CLEANLOCALSTORAGE_UserSize(     unsigned long __RPC_FAR *, unsigned long            , CLEANLOCALSTORAGE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  CLEANLOCALSTORAGE_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, CLEANLOCALSTORAGE __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  CLEANLOCALSTORAGE_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, CLEANLOCALSTORAGE __RPC_FAR * ); 
void                      __RPC_USER  CLEANLOCALSTORAGE_UserFree(     unsigned long __RPC_FAR *, CLEANLOCALSTORAGE __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Proxy( 
    IDispatch __RPC_FAR * This,
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
    /* [out] */ VARIANT __RPC_FAR *pVarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatch_Invoke_Stub( 
    IDispatch __RPC_FAR * This,
    /* [in] */ DISPID dispIdMember,
    /* [in] */ REFIID riid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pDispParams,
    /* [out] */ VARIANT __RPC_FAR *pVarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
    /* [out] */ UINT __RPC_FAR *pArgErr,
    /* [in] */ UINT cVarRef,
    /* [size_is][in] */ UINT __RPC_FAR *rgVarRefIdx,
    /* [size_is][out][in] */ VARIANTARG __RPC_FAR *rgVarRef);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumVARIANT_Next_Proxy( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar,
    /* [out] */ ULONG __RPC_FAR *pCeltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumVARIANT_Next_Stub( 
    IEnumVARIANT __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar,
    /* [out] */ ULONG __RPC_FAR *pCeltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeComp_Bind_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD wFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [out] */ DESCKIND __RPC_FAR *pDescKind,
    /* [out] */ BINDPTR __RPC_FAR *pBindPtr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_Bind_Stub( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [in] */ WORD wFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [out] */ DESCKIND __RPC_FAR *pDescKind,
    /* [out] */ LPFUNCDESC __RPC_FAR *ppFuncDesc,
    /* [out] */ LPVARDESC __RPC_FAR *ppVarDesc,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTypeComp,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeComp_BindType_Proxy( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeComp_BindType_Stub( 
    ITypeComp __RPC_FAR * This,
    /* [in] */ LPOLESTR szName,
    /* [in] */ ULONG lHashVal,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ TYPEATTR __RPC_FAR *__RPC_FAR *ppTypeAttr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetTypeAttr_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ LPTYPEATTR __RPC_FAR *ppTypeAttr,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ FUNCDESC __RPC_FAR *__RPC_FAR *ppFuncDesc);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetFuncDesc_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ LPFUNCDESC __RPC_FAR *ppFuncDesc,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ VARDESC __RPC_FAR *__RPC_FAR *ppVarDesc);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetVarDesc_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ UINT index,
    /* [out] */ LPVARDESC __RPC_FAR *ppVarDesc,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT __RPC_FAR *pcNames);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetNames_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [length_is][size_is][out] */ BSTR __RPC_FAR *rgBstrNames,
    /* [in] */ UINT cMaxNames,
    /* [out] */ UINT __RPC_FAR *pcNames);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetIDsOfNames_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [size_is][out] */ MEMBERID __RPC_FAR *pMemId);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetIDsOfNames_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_Invoke_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ PVOID pvInstance,
    /* [in] */ MEMBERID memid,
    /* [in] */ WORD wFlags,
    /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
    /* [out] */ VARIANT __RPC_FAR *pVarResult,
    /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
    /* [out] */ UINT __RPC_FAR *puArgErr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_Invoke_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetDocumentation_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetDocumentation_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetDllEntry_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [out] */ BSTR __RPC_FAR *pBstrDllName,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ WORD __RPC_FAR *pwOrdinal);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetDllEntry_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrDllName,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ WORD __RPC_FAR *pwOrdinal);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_AddressOfMember_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ INVOKEKIND invKind,
    /* [out] */ PVOID __RPC_FAR *ppv);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_AddressOfMember_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_CreateInstance_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ PVOID __RPC_FAR *ppvObj);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_CreateInstance_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObj);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetContainingTypeLib_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
    /* [out] */ UINT __RPC_FAR *pIndex);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_GetContainingTypeLib_Stub( 
    ITypeInfo __RPC_FAR * This,
    /* [out] */ ITypeLib __RPC_FAR *__RPC_FAR *ppTLib,
    /* [out] */ UINT __RPC_FAR *pIndex);

/* [local] */ void STDMETHODCALLTYPE ITypeInfo_ReleaseTypeAttr_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ TYPEATTR __RPC_FAR *pTypeAttr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_ReleaseTypeAttr_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ void STDMETHODCALLTYPE ITypeInfo_ReleaseFuncDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ FUNCDESC __RPC_FAR *pFuncDesc);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_ReleaseFuncDesc_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ void STDMETHODCALLTYPE ITypeInfo_ReleaseVarDesc_Proxy( 
    ITypeInfo __RPC_FAR * This,
    /* [in] */ VARDESC __RPC_FAR *pVarDesc);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo_ReleaseVarDesc_Stub( 
    ITypeInfo __RPC_FAR * This);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeInfo2_GetDocumentation2_Proxy( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeInfo2_GetDocumentation2_Stub( 
    ITypeInfo2 __RPC_FAR * This,
    /* [in] */ MEMBERID memid,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);

/* [local] */ UINT STDMETHODCALLTYPE ITypeLib_GetTypeInfoCount_Proxy( 
    ITypeLib __RPC_FAR * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_GetTypeInfoCount_Stub( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *pcTInfo);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib_GetLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ TLIBATTR __RPC_FAR *__RPC_FAR *ppTLibAttr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_GetLibAttr_Stub( 
    ITypeLib __RPC_FAR * This,
    /* [out] */ LPTLIBATTR __RPC_FAR *ppTLibAttr,
    /* [out] */ CLEANLOCALSTORAGE __RPC_FAR *pDummy);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib_GetDocumentation_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ INT index,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_GetDocumentation_Stub( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ INT index,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pBstrName,
    /* [out] */ BSTR __RPC_FAR *pBstrDocString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpContext,
    /* [out] */ BSTR __RPC_FAR *pBstrHelpFile);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib_IsName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out][in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL __RPC_FAR *pfName);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_IsName_Stub( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [out] */ BOOL __RPC_FAR *pfName,
    /* [out] */ BSTR __RPC_FAR *pBstrLibName);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib_FindName_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [out][in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
    /* [out][in] */ USHORT __RPC_FAR *pcFound);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_FindName_Stub( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ LPOLESTR szNameBuf,
    /* [in] */ ULONG lHashVal,
    /* [length_is][size_is][out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,
    /* [length_is][size_is][out] */ MEMBERID __RPC_FAR *rgMemId,
    /* [out][in] */ USHORT __RPC_FAR *pcFound,
    /* [out] */ BSTR __RPC_FAR *pBstrLibName);

/* [local] */ void STDMETHODCALLTYPE ITypeLib_ReleaseTLibAttr_Proxy( 
    ITypeLib __RPC_FAR * This,
    /* [in] */ TLIBATTR __RPC_FAR *pTLibAttr);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib_ReleaseTLibAttr_Stub( 
    ITypeLib __RPC_FAR * This);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib2_GetLibStatistics_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcUniqueNames,
    /* [out] */ ULONG __RPC_FAR *pcchUniqueNames);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_GetLibStatistics_Stub( 
    ITypeLib2 __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcUniqueNames,
    /* [out] */ ULONG __RPC_FAR *pcchUniqueNames);

/* [local] */ HRESULT STDMETHODCALLTYPE ITypeLib2_GetDocumentation2_Proxy( 
    ITypeLib2 __RPC_FAR * This,
    /* [in] */ INT index,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ITypeLib2_GetDocumentation2_Stub( 
    ITypeLib2 __RPC_FAR * This,
    /* [in] */ INT index,
    /* [in] */ LCID lcid,
    /* [in] */ DWORD refPtrFlags,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpString,
    /* [out] */ DWORD __RPC_FAR *pdwHelpStringContext,
    /* [out] */ BSTR __RPC_FAR *pbstrHelpStringDll);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Proxy( 
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSTG_Next_Stub( 
    IEnumSTATPROPSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Proxy( 
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumSTATPROPSETSTG_Next_Stub( 
    IEnumSTATPROPSETSTG __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ STATPROPSETSTG __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ntddndis.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ BUILD Version: 0001        // Increment this if a change has global effects

Module Name:

    ntddndis.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Network driver interface device.

Author:

    NDIS/ATM Development Team

Revision History:

    added the correct values for NDIS 3.0.
    added Pnp IoCTLs and structures
    added general co ndis oids.
    added PnP and PM OIDs.

--*/

#ifndef _NTDDNDIS_
#define _NTDDNDIS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
#include <ifdef.h>
#include <devpkey.h>
#include <pciprop.h>
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE

//
// Something to identify new (LH Server and up) applications. 
// User-mode only. For drivers, NDIS_SUPPORT_NDIS61 is already
// defined in ndismain.w.
//
#if !defined(NDIS_SUPPORT_NDIS61)
#if  (defined (UM_NDIS61))
#define NDIS_SUPPORT_NDIS61      1
#else
#define NDIS_SUPPORT_NDIS61      0
#endif
#endif // !defined(NDIS_SUPPORT_NDIS61)

//
// Device Name - this string is the name of the device. It is the name
// that should be passed to NtOpenFile when accessing the device.

//
// Note: For devices that support multiple units, it should be suffixed
//       with the Ascii representation of the unit number.
//

#ifdef UNDER_CE
#define DD_NDIS_DEVICE_NAME TEXT("NDS0:")
#else  //  UNDER_CE
#define DD_NDIS_DEVICE_NAME "\\Device\\UNKNOWN"
#endif  //  UNDER_CE


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning: Remember that the low two bits of the code specify how the
//          buffers are passed to the driver!
//

#define _NDIS_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, request, method, FILE_ANY_ACCESS)

#define IOCTL_NDIS_QUERY_GLOBAL_STATS   _NDIS_CONTROL_CODE(0, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_QUERY_ALL_STATS      _NDIS_CONTROL_CODE(1, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_DO_PNP_OPERATION     _NDIS_CONTROL_CODE(2, METHOD_BUFFERED)
#define IOCTL_NDIS_QUERY_SELECTED_STATS _NDIS_CONTROL_CODE(3, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_ENUMERATE_INTERFACES _NDIS_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_NDIS_ADD_TDI_DEVICE       _NDIS_CONTROL_CODE(5, METHOD_BUFFERED)
#define IOCTL_NDIS_GET_LOG_DATA         _NDIS_CONTROL_CODE(7, METHOD_OUT_DIRECT)
#ifndef UNDER_CE
#define IOCTL_NDIS_GET_VERSION          _NDIS_CONTROL_CODE(8, METHOD_BUFFERED)
#endif  //  UNDER_CE

#ifdef UNDER_CE
//
// Windows CE specific ioctls
//
#define WINCE_IOCTL_START 8
#define	IOCTL_NDIS_POWER_RESUME			_NDIS_CONTROL_CODE( WINCE_IOCTL_START+0, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_REGISTER_ADAPTER		_NDIS_CONTROL_CODE( WINCE_IOCTL_START+1, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_DEREGISTER_ADAPTER	_NDIS_CONTROL_CODE( WINCE_IOCTL_START+2, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_REBIND_ADAPTER		_NDIS_CONTROL_CODE( WINCE_IOCTL_START+3, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_BIND_ADAPTER			_NDIS_CONTROL_CODE( WINCE_IOCTL_START+4, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_UNBIND_ADAPTER		_NDIS_CONTROL_CODE( WINCE_IOCTL_START+5, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_GET_ADAPTER_NAMES	_NDIS_CONTROL_CODE( WINCE_IOCTL_START+6, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_GET_PROTOCOL_NAMES	_NDIS_CONTROL_CODE( WINCE_IOCTL_START+7, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_GET_ADAPTER_BINDINGS	_NDIS_CONTROL_CODE( WINCE_IOCTL_START+8, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_LOAD_MINIPORT		_NDIS_CONTROL_CODE( WINCE_IOCTL_START+9, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_GET_VERSION			_NDIS_CONTROL_CODE( WINCE_IOCTL_START+10, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_LOAD_RETAIL_LOGGER	_NDIS_CONTROL_CODE( WINCE_IOCTL_START+11, METHOD_OUT_DIRECT )
#define	IOCTL_NDIS_UNLOAD_RETAIL_LOGGER _NDIS_CONTROL_CODE( WINCE_IOCTL_START+12, METHOD_OUT_DIRECT )

#define IOCTL_NDIS_RESERVED1            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+13, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED2            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+14, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED3            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+15, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED4            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+16, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED5    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, WINCE_IOCTL_START+17, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NDIS_RESERVED6    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, WINCE_IOCTL_START+18, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_NDIS_RESERVED7            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+19, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_RESERVED8            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+20, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED9            _NDIS_CONTROL_CODE(WINCE_IOCTL_START+21, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED10           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+22, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED11           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+23, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED12           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+24, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED13           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+25, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED14           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+26, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED15           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+27, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED16           _NDIS_CONTROL_CODE(WINCE_IOCTL_START+28, METHOD_BUFFERED)
#else  //  UNDER_CE
#define IOCTL_NDIS_RESERVED1            _NDIS_CONTROL_CODE(9, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED2            _NDIS_CONTROL_CODE(0xA, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED3            _NDIS_CONTROL_CODE(0xB, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED4            _NDIS_CONTROL_CODE(0xC, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED5    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xD, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NDIS_RESERVED6    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xE, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_NDIS_RESERVED7            _NDIS_CONTROL_CODE(0xF, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_RESERVED8            _NDIS_CONTROL_CODE(0x10, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED9            _NDIS_CONTROL_CODE(0x11, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED10           _NDIS_CONTROL_CODE(0x12, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED11           _NDIS_CONTROL_CODE(0x13, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED12           _NDIS_CONTROL_CODE(0x14, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED13           _NDIS_CONTROL_CODE(0x15, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED14           _NDIS_CONTROL_CODE(0x16, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED15           _NDIS_CONTROL_CODE(0x17, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED16           _NDIS_CONTROL_CODE(0x18, METHOD_BUFFERED)
#endif  //  UNDER_CE


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This is the type of an NDIS OID value.
//

typedef ULONG NDIS_OID, *PNDIS_OID;

//
// IOCTL_NDIS_QUERY_ALL_STATS returns a sequence of these, packed
// together.  This structure is unaligned because not all statistics
// have a length that is a ULONG multiple.
//

typedef struct _NDIS_STATISTICS_VALUE
{
    NDIS_OID    Oid;
    ULONG       DataLength;
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE;

typedef NDIS_STATISTICS_VALUE UNALIGNED *PNDIS_STATISTICS_VALUE;

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
typedef struct _NDIS_STATISTICS_VALUE_EX
{
    NDIS_OID    Oid;
    ULONG       DataLength;         // the length of the OID data
    ULONG       Length;             // the length of this instance of NDIS_STATISTICS_VALUE_EX
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE_EX;

typedef NDIS_STATISTICS_VALUE_EX UNALIGNED *PNDIS_STATISTICS_VALUE_EX;
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE


//
// Structure used to define a self-contained variable data structure
//
typedef struct _NDIS_VAR_DATA_DESC
{
    USHORT      Length;         // # of octects of data
    USHORT      MaximumLength;  // # of octects available
    ULONG_PTR   Offset;         // Offset of data relative to the descriptor
} NDIS_VAR_DATA_DESC, *PNDIS_VAR_DATA_DESC;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif // !GUID_DEFINED

//
// NDIS Object Types used in NDIS_OBJECT_HEADER
//
#define NDIS_OBJECT_TYPE_DEFAULT                            0x80    // used when object type is implicit in the API call
#define NDIS_OBJECT_TYPE_MINIPORT_INIT_PARAMETERS           0x81    // used by NDIS in NDIS_MINIPORT_INIT_PARAMETERS
#define NDIS_OBJECT_TYPE_SG_DMA_DESCRIPTION                 0x83    // used by miniport drivers in NDIS_SG_DMA_DESCRIPTION
#define NDIS_OBJECT_TYPE_MINIPORT_INTERRUPT                 0x84    // used by miniport drivers in NDIS_MINIPORT_INTERRUPT_EX
#define NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES           0x85    // used by miniport or filter drivers in NDIS_DEVICE_OBJECT_ATTRIBUTES
#define NDIS_OBJECT_TYPE_BIND_PARAMETERS                    0x86    // used by NDIS in NDIS_BIND_PARAMETERS
#define NDIS_OBJECT_TYPE_OPEN_PARAMETERS                    0x87    // used by protocols in NDIS_OPEN_PARAMETERS
#define NDIS_OBJECT_TYPE_RSS_CAPABILITIES                   0x88    // used by miniport in NDIS_RECEIVE_SCALE_CAPABILITIES
#define NDIS_OBJECT_TYPE_RSS_PARAMETERS                     0x89    // used by miniport and protocol in NDIS_RECEIVE_SCALE_PARAMETERS
#define NDIS_OBJECT_TYPE_MINIPORT_DRIVER_CHARACTERISTICS    0x8A
#define NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS      0x8B
#define NDIS_OBJECT_TYPE_FILTER_PARTIAL_CHARACTERISTICS     0x8C
#define NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES                  0x8D
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS     0x8E
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS   0x8F
#define NDIS_OBJECT_TYPE_CO_PROTOCOL_CHARACTERISTICS        0x90
#define NDIS_OBJECT_TYPE_CO_MINIPORT_CHARACTERISTICS        0x91
#define NDIS_OBJECT_TYPE_MINIPORT_PNP_CHARACTERISTICS       0x92
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_CHARACTERISTICS     0x93
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_CHARACTERISTICS   0x94
#define NDIS_OBJECT_TYPE_PROTOCOL_DRIVER_CHARACTERISTICS    0x95
#define NDIS_OBJECT_TYPE_REQUEST_EX                         0x96
#define NDIS_OBJECT_TYPE_OID_REQUEST                        0x96
#define NDIS_OBJECT_TYPE_TIMER_CHARACTERISTICS              0x97
#define NDIS_OBJECT_TYPE_STATUS_INDICATION                  0x98
#define NDIS_OBJECT_TYPE_FILTER_ATTACH_PARAMETERS           0x99
#define NDIS_OBJECT_TYPE_FILTER_PAUSE_PARAMETERS            0x9A
#define NDIS_OBJECT_TYPE_FILTER_RESTART_PARAMETERS          0x9B
#define NDIS_OBJECT_TYPE_PORT_CHARACTERISTICS               0x9C
#define NDIS_OBJECT_TYPE_PORT_STATE                         0x9D
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES       0x9E
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES            0x9F
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES            0xA0
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES      0xA1
#define NDIS_OBJECT_TYPE_RESTART_GENERAL_ATTRIBUTES                     0xA2
#define NDIS_OBJECT_TYPE_PROTOCOL_RESTART_PARAMETERS                    0xA3
#define NDIS_OBJECT_TYPE_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES    0xA4
#define NDIS_OBJECT_TYPE_CO_CALL_MANAGER_OPTIONAL_HANDLERS              0xA5
#define NDIS_OBJECT_TYPE_CO_CLIENT_OPTIONAL_HANDLERS                    0xA6
#define NDIS_OBJECT_TYPE_OFFLOAD                                        0xA7
#define NDIS_OBJECT_TYPE_OFFLOAD_ENCAPSULATION                          0xA8
#define NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT                           0xA9
#define NDIS_OBJECT_TYPE_DRIVER_WRAPPER_OBJECT                          0xAA
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_HD_SPLIT_ATTRIBUTES                            0xAB
#endif // (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_NSI_NETWORK_RW_STRUCT                          0xAC
#define NDIS_OBJECT_TYPE_NSI_COMPARTMENT_RW_STRUCT                      0xAD
#define NDIS_OBJECT_TYPE_NSI_INTERFACE_PERSIST_RW_STRUCT                0xAE
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES    0xAF
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OBJECT_HEADER
{
    UCHAR   Type;
    UCHAR   Revision;
    USHORT  Size;
} NDIS_OBJECT_HEADER, *PNDIS_OBJECT_HEADER;

#define NDIS_OBJECT_REVISION_1                  1

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE

//
// flags for NDIS_STATISTICS_INFO->SupportedStatistics structure
//
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_RCV             0x00000001
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_RCV            0x00000002
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_RCV            0x00000004
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_RCV                       0x00000008
#define NDIS_STATISTICS_FLAGS_VALID_RCV_DISCARDS                    0x00000010
#define NDIS_STATISTICS_FLAGS_VALID_RCV_ERROR                       0x00000020
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_XMIT            0x00000040
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_XMIT           0x00000080
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_XMIT           0x00000100
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_XMIT                      0x00000200
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_ERROR                      0x00000400
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_DISCARDS                   0x00008000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_RCV              0x00010000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_RCV             0x00020000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_RCV             0x00040000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_XMIT             0x00080000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_XMIT            0x00100000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_XMIT            0x00200000


#define NDIS_STATISTICS_INFO_REVISION_1  1
//
// structure used in OID_GEN_STATISTICS
//
typedef struct _NDIS_STATISTICS_INFO
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       SupportedStatistics;
    ULONG64                     ifInDiscards;           // OID_GEN_RCV_ERROR + OID_GEN_RCV_NO_BUFFER = OID_GEN_RCV_DISCARDS
    ULONG64                     ifInErrors;             // OID_GEN_RCV_ERROR
    ULONG64                     ifHCInOctets;           // OID_GEN_BYTES_RCV = OID_GEN_DIRECTED_BYTES_RCV + OID_GEN_MULTICAST_BYTES_RCV + OID_GEN_BROADCAST_BYTES_RCV
    ULONG64                     ifHCInUcastPkts;        // OID_GEN_DIRECTED_FRAMES_RCV
    ULONG64                     ifHCInMulticastPkts;    // OID_GEN_MULTICAST_FRAMES_RCV
    ULONG64                     ifHCInBroadcastPkts;    // OID_GEN_BROADCAST_FRAMES_RCV
    ULONG64                     ifHCOutOctets;          // OID_GEN_BYTES_XMIT = OID_GEN_DIRECTED_BYTES_XMIT + OID_GEN_MULTICAST_BYTES_XMIT + OID_GEN_BROADCAST_BYTES_XMIT
    ULONG64                     ifHCOutUcastPkts;       // OID_GEN_DIRECTED_FRAMES_XMIT
    ULONG64                     ifHCOutMulticastPkts;   // OID_GEN_MULTICAST_FRAMES_XMIT
    ULONG64                     ifHCOutBroadcastPkts;   // OID_GEN_BROADCAST_FRAMES_XMIT
    ULONG64                     ifOutErrors;            // OID_GEN_XMIT_ERROR
    ULONG64                     ifOutDiscards;          // OID_GEN_XMIT_DISCARDS
    ULONG64                     ifHCInUcastOctets;      // OID_GEN_DIRECTED_BYTES_RCV    
    ULONG64                     ifHCInMulticastOctets;  // OID_GEN_MULTICAST_BYTES_RCV
    ULONG64                     ifHCInBroadcastOctets;  // OID_GEN_BROADCAST_BYTES_RCV        
    ULONG64                     ifHCOutUcastOctets;     // OID_GEN_DIRECTED_BYTES_XMIT    
    ULONG64                     ifHCOutMulticastOctets; // OID_GEN_MULTICAST_BYTES_XMIT
    ULONG64                     ifHCOutBroadcastOctets; // OID_GEN_BROADCAST_BYTES_XMIT                
}NDIS_STATISTICS_INFO, *PNDIS_STATISTICS_INFO;

#define NDIS_SIZEOF_STATISTICS_INFO_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_STATISTICS_INFO, ifHCOutBroadcastOctets)
//
//  interrupt moderation structures and definitions
//

//
// enum value used in NDIS_INTERRUPT_MODERATION_PARAMETERS structure
//
typedef enum _NDIS_INTERRUPT_MODERATION
{
    NdisInterruptModerationUnknown,
    NdisInterruptModerationNotSupported,
    NdisInterruptModerationEnabled,
    NdisInterruptModerationDisabled
} NDIS_INTERRUPT_MODERATION, *PNDIS_INTERRUPT_MODERATION;

//
// Bits used in Flags parameter of NDIS_INTERRUPT_MODERATION_PARAMETERS structure:
//    
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_RESET            0x00000001
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_REINITIALIZE     0x00000002


//
// structure used in OID_GEN_INTERRUPT_MODERATION
//

#define NDIS_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    1

typedef struct _NDIS_INTERRUPT_MODERATION_PARAMETERS
{
    NDIS_OBJECT_HEADER Header;
    ULONG Flags;
    NDIS_INTERRUPT_MODERATION InterruptModeration;
}NDIS_INTERRUPT_MODERATION_PARAMETERS, *PNDIS_INTERRUPT_MODERATION_PARAMETERS;

#define NDIS_SIZEOF_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_INTERRUPT_MODERATION_PARAMETERS, InterruptModeration)

//
// structure used in OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES
//

#define NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1  1

typedef struct _NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    ULONG                   TimeoutArrayLength;
    ULONG                   TimeoutArray[1];
}NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, *PNDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES;

#define NDIS_SIZEOF_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, TimeoutArray)

//
// PCI custom properties. used in OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES
//

#define NDIS_OBJECT_TYPE_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1  1

typedef struct _NDIS_PCI_DEVICE_CUSTOM_PROPERTIES
{
    NDIS_OBJECT_HEADER              Header;
    UINT32                          DeviceType;             // conventional, PCI-X, PCI-E, etc.
    UINT32                          CurrentSpeedAndMode;    // PCI_DEVICE_CONVENTIONAL_xx or PCIX_MODExxx. valid only for conventional and PCI-X devices
    UINT32                          CurrentPayloadSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxPayloadSize;         // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxReadRequestSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          CurrentLinkSpeed;       // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices 
    UINT32                          CurrentLinkWidth;       // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
    UINT32                          MaxLinkSpeed;           // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices
    UINT32                          MaxLinkWidth;           // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
} NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, *PNDIS_PCI_DEVICE_CUSTOM_PROPERTIES;

#define NDIS_SIZEOF_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, MaxLinkWidth)

// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE

//
// General Objects
//

//
//  Required OIDs
//
#define OID_GEN_SUPPORTED_LIST                  0x00010101
#define OID_GEN_HARDWARE_STATUS                 0x00010102
#define OID_GEN_MEDIA_SUPPORTED                 0x00010103
#define OID_GEN_MEDIA_IN_USE                    0x00010104
#define OID_GEN_MAXIMUM_LOOKAHEAD               0x00010105
#define OID_GEN_MAXIMUM_FRAME_SIZE              0x00010106
#define OID_GEN_LINK_SPEED                      0x00010107
#define OID_GEN_TRANSMIT_BUFFER_SPACE           0x00010108
#define OID_GEN_RECEIVE_BUFFER_SPACE            0x00010109
#define OID_GEN_TRANSMIT_BLOCK_SIZE             0x0001010A
#define OID_GEN_RECEIVE_BLOCK_SIZE              0x0001010B
#define OID_GEN_VENDOR_ID                       0x0001010C
#define OID_GEN_VENDOR_DESCRIPTION              0x0001010D
#define OID_GEN_CURRENT_PACKET_FILTER           0x0001010E
#define OID_GEN_CURRENT_LOOKAHEAD               0x0001010F
#define OID_GEN_DRIVER_VERSION                  0x00010110
#define OID_GEN_MAXIMUM_TOTAL_SIZE              0x00010111
#define OID_GEN_PROTOCOL_OPTIONS                0x00010112
#define OID_GEN_MAC_OPTIONS                     0x00010113
#define OID_GEN_MEDIA_CONNECT_STATUS            0x00010114
#define OID_GEN_MAXIMUM_SEND_PACKETS            0x00010115

#ifndef UNDER_CE
//
//  Optional OIDs
//
#endif  //  UNDER_CE
#define OID_GEN_VENDOR_DRIVER_VERSION           0x00010116
#define OID_GEN_SUPPORTED_GUIDS                 0x00010117
#define OID_GEN_NETWORK_LAYER_ADDRESSES         0x00010118  // Set only
#define OID_GEN_TRANSPORT_HEADER_OFFSET         0x00010119  // Set only
#ifdef UNDER_CE
//
//  Optional OIDs
//
#endif  //  UNDER_CE
#define OID_GEN_MEDIA_CAPABILITIES              0x00010201
#define OID_GEN_PHYSICAL_MEDIUM                 0x00010202

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
//
// new optional for NDIS 6.0
//
#define OID_GEN_RECEIVE_SCALE_CAPABILITIES      0x00010203  // query only
#define OID_GEN_RECEIVE_SCALE_PARAMETERS        0x00010204  // query and set

//
// new for NDIS 6.0. NDIS will handle on behalf of the miniports
//
#define OID_GEN_MAC_ADDRESS                     0x00010205  // query and set
#define OID_GEN_MAX_LINK_SPEED                  0x00010206  // query only
#define OID_GEN_LINK_STATE                      0x00010207  // query only

//
// new and required for NDIS 6 miniports
//
#define OID_GEN_LINK_PARAMETERS                 0x00010208  // set only
#define OID_GEN_INTERRUPT_MODERATION            0x00010209  // query and set
#define OID_GEN_NDIS_RESERVED_3                 0x0001020A
#define OID_GEN_NDIS_RESERVED_4                 0x0001020B
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C

#ifdef UNDER_CE
#define OID_GEN_NETWORK_CHANGE        OID_GEN_NDIS_RESERVED_3    //set only
#define OID_GEN_RECV_CYCLE_COUNT      OID_GEN_NDIS_RESERVED_5    //query only
#endif  //  UNDER_CE

//
// Port related OIDs
//
#define OID_GEN_ENUMERATE_PORTS                 0x0001020D  // query only, handled by NDIS
#define OID_GEN_PORT_STATE                      0x0001020E  // query only, handled by NDIS
#define OID_GEN_PORT_AUTHENTICATION_PARAMETERS  0x0001020F  // Set only

//
// optional OID for NDIS 6 miniports
//
#define OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES 0x00010210 // query only

//
// this OID is handled by NDIS for PCI devices
//
#define OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES    0x00010211  // query only
#define OID_GEN_NDIS_RESERVED_6                 0x00010212


// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE

#define OID_GEN_MACHINE_NAME                    0x0001021A  // set only
#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
#define OID_GEN_VLAN_ID                         0x0001021C

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
#define OID_GEN_RECEIVE_HASH                    0x0001021F  // query and set
#define OID_GEN_MINIPORT_RESTART_ATTRIBUTES     0x0001021D

#if (NDIS_SUPPORT_NDIS61)
//
// Optional OID for header data/split
//
#define OID_GEN_HD_SPLIT_PARAMETERS             0x0001021E  // Set only
#define OID_GEN_HD_SPLIT_CURRENT_CONFIG         0x00010220  // Query only
#endif // (NDIS_SUPPORT_NDIS61)

//
// the following OIDs are used in querying interfaces
//
#define OID_GEN_PROMISCUOUS_MODE                0x00010280  // used in querying interfaces
#define OID_GEN_LAST_CHANGE                     0x00010281  // used in querying interfaces
#define OID_GEN_DISCONTINUITY_TIME              0x00010282  // used in querying interfaces
#define OID_GEN_OPERATIONAL_STATUS              0x00010283  // used in querying interfaces
#define OID_GEN_XMIT_LINK_SPEED                 0x00010284  // used in querying interfaces
#define OID_GEN_RCV_LINK_SPEED                  0x00010285  // used in querying interfaces
#define OID_GEN_UNKNOWN_PROTOS                  0x00010286  // used in querying interfaces
#define OID_GEN_INTERFACE_INFO                  0x00010287  // used in querying interfaces
#define OID_GEN_ADMIN_STATUS                    0x00010288  // used in querying interfaces
#define OID_GEN_ALIAS                           0x00010289  // used in querying interfaces
#define OID_GEN_MEDIA_CONNECT_STATUS_EX         0x0001028A  // used in querying interfaces
#define OID_GEN_LINK_SPEED_EX                   0x0001028B  // used in querying interfaces
#define OID_GEN_MEDIA_DUPLEX_STATE              0x0001028C  // used in querying interfaces

// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE

//
//  Required statistics
//
#define OID_GEN_XMIT_OK                         0x00020101
#define OID_GEN_RCV_OK                          0x00020102
#define OID_GEN_XMIT_ERROR                      0x00020103
#define OID_GEN_RCV_ERROR                       0x00020104
#define OID_GEN_RCV_NO_BUFFER                   0x00020105

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
//
// mandatory for NDIS 6.0 and higher miniports
//
#define OID_GEN_STATISTICS                      0x00020106
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE

//
//  Optional statistics
//
#define OID_GEN_DIRECTED_BYTES_XMIT             0x00020201
#define OID_GEN_DIRECTED_FRAMES_XMIT            0x00020202
#define OID_GEN_MULTICAST_BYTES_XMIT            0x00020203
#define OID_GEN_MULTICAST_FRAMES_XMIT           0x00020204
#define OID_GEN_BROADCAST_BYTES_XMIT            0x00020205
#define OID_GEN_BROADCAST_FRAMES_XMIT           0x00020206
#define OID_GEN_DIRECTED_BYTES_RCV              0x00020207
#define OID_GEN_DIRECTED_FRAMES_RCV             0x00020208
#define OID_GEN_MULTICAST_BYTES_RCV             0x00020209
#define OID_GEN_MULTICAST_FRAMES_RCV            0x0002020A
#define OID_GEN_BROADCAST_BYTES_RCV             0x0002020B
#define OID_GEN_BROADCAST_FRAMES_RCV            0x0002020C
#define OID_GEN_RCV_CRC_ERROR                   0x0002020D
#define OID_GEN_TRANSMIT_QUEUE_LENGTH           0x0002020E

#define OID_GEN_GET_TIME_CAPS                   0x0002020F
#define OID_GEN_GET_NETCARD_TIME                0x00020210
#define OID_GEN_NETCARD_LOAD                    0x00020211
#define OID_GEN_DEVICE_PROFILE                  0x00020212

//
// The following are exported by NDIS itself and are only queryable. 
//

//
// the time in milliseconds a driver took to initialize.
//
#define OID_GEN_INIT_TIME_MS                    0x00020213

//
// the number of times the miniport adapter was reset
//
#define OID_GEN_RESET_COUNTS                    0x00020214

//
// the number of timer the miniport reported a media state change
//
#define OID_GEN_MEDIA_SENSE_COUNTS              0x00020215

//
// the friendly name of the adapter
//
#define OID_GEN_FRIENDLY_NAME                   0x00020216

#ifdef UNDER_CE
//
//  backward compatibility
//

//
// returns miniport information such as whether the driver is serialized or not
// if it supports sending multiple packets, etc. refer to NDIS_MINIPORT_XXX flags
//
#define OID_GEN_MINIPORT_INFO                   0x00020217

//
// handled by NDIS to reset the test verification paramters on the
// miniport
//
#define OID_GEN_RESET_VERIFY_PARAMETERS         0x00020218
#endif  //  UNDER_CE

//
// returns miniport information such as whether the driver is serialized or not
// if it supports sending multiple packets, etc. refer to NDIS_MINIPORT_XXX flags
//
#define OID_GEN_NDIS_RESERVED_1                 0x00020217

//
// handled by NDIS to reset the test verification paramters on the
// miniport
//
#define OID_GEN_NDIS_RESERVED_2                 0x00020218
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
//
// more optional OIDs new for NDIS 6.0
//

#define OID_GEN_BYTES_RCV                       0x00020219
#define OID_GEN_BYTES_XMIT                      0x0002021A
#define OID_GEN_RCV_DISCARDS                    0x0002021B
#define OID_GEN_XMIT_DISCARDS                   0x0002021C
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE



//
//  These are connection-oriented general OIDs.
//  These replace the above OIDs for connection-oriented media.
//
#define OID_GEN_CO_SUPPORTED_LIST               OID_GEN_SUPPORTED_LIST
#define OID_GEN_CO_HARDWARE_STATUS              OID_GEN_HARDWARE_STATUS
#define OID_GEN_CO_MEDIA_SUPPORTED              OID_GEN_MEDIA_SUPPORTED
#define OID_GEN_CO_MEDIA_IN_USE                 OID_GEN_MEDIA_IN_USE
#define OID_GEN_CO_LINK_SPEED                   OID_GEN_LINK_SPEED
#define OID_GEN_CO_VENDOR_ID                    OID_GEN_VENDOR_ID
#define OID_GEN_CO_VENDOR_DESCRIPTION           OID_GEN_VENDOR_DESCRIPTION
#define OID_GEN_CO_DRIVER_VERSION               OID_GEN_DRIVER_VERSION
#define OID_GEN_CO_PROTOCOL_OPTIONS             OID_GEN_PROTOCOL_OPTIONS
#define OID_GEN_CO_MAC_OPTIONS                  OID_GEN_MAC_OPTIONS
#define OID_GEN_CO_MEDIA_CONNECT_STATUS         OID_GEN_MEDIA_CONNECT_STATUS
#define OID_GEN_CO_VENDOR_DRIVER_VERSION        OID_GEN_VENDOR_DRIVER_VERSION
#define OID_GEN_CO_SUPPORTED_GUIDS              OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_CO_GET_TIME_CAPS                OID_GEN_GET_TIME_CAPS
#define OID_GEN_CO_GET_NETCARD_TIME             OID_GEN_GET_NETCARD_TIME
#define OID_GEN_CO_MINIMUM_LINK_SPEED           0x00020120

//
//  These are connection-oriented statistics OIDs.
//
#define OID_GEN_CO_XMIT_PDUS_OK                 OID_GEN_XMIT_OK
#define OID_GEN_CO_RCV_PDUS_OK                  OID_GEN_RCV_OK
#define OID_GEN_CO_XMIT_PDUS_ERROR              OID_GEN_XMIT_ERROR
#define OID_GEN_CO_RCV_PDUS_ERROR               OID_GEN_RCV_ERROR
#define OID_GEN_CO_RCV_PDUS_NO_BUFFER           OID_GEN_RCV_NO_BUFFER


#define OID_GEN_CO_RCV_CRC_ERROR                OID_GEN_RCV_CRC_ERROR
#define OID_GEN_CO_TRANSMIT_QUEUE_LENGTH        OID_GEN_TRANSMIT_QUEUE_LENGTH
#define OID_GEN_CO_BYTES_XMIT                   OID_GEN_DIRECTED_BYTES_XMIT
#define OID_GEN_CO_BYTES_RCV                    OID_GEN_DIRECTED_BYTES_RCV
#define OID_GEN_CO_NETCARD_LOAD                 OID_GEN_NETCARD_LOAD
#define OID_GEN_CO_DEVICE_PROFILE               OID_GEN_DEVICE_PROFILE
#define OID_GEN_CO_BYTES_XMIT_OUTSTANDING       0x00020221

//
// 802.3 Objects (Ethernet)
//
#define OID_802_3_PERMANENT_ADDRESS             0x01010101
#define OID_802_3_CURRENT_ADDRESS               0x01010102
#define OID_802_3_MULTICAST_LIST                0x01010103
#define OID_802_3_MAXIMUM_LIST_SIZE             0x01010104
//
// This OID has been deprecated for NDIS 6 drivers. 
//
#define OID_802_3_MAC_OPTIONS                   0x01010105  // deprecated


//
// This Flag has been deprecated for NDIS 6 drivers.
//
#define NDIS_802_3_MAC_OPTION_PRIORITY          0x00000001  // deprecated

#define OID_802_3_RCV_ERROR_ALIGNMENT           0x01020101
#define OID_802_3_XMIT_ONE_COLLISION            0x01020102
#define OID_802_3_XMIT_MORE_COLLISIONS          0x01020103

#define OID_802_3_XMIT_DEFERRED                 0x01020201
#define OID_802_3_XMIT_MAX_COLLISIONS           0x01020202
#define OID_802_3_RCV_OVERRUN                   0x01020203
#define OID_802_3_XMIT_UNDERRUN                 0x01020204
#define OID_802_3_XMIT_HEARTBEAT_FAILURE        0x01020205
#define OID_802_3_XMIT_TIMES_CRS_LOST           0x01020206
#define OID_802_3_XMIT_LATE_COLLISIONS          0x01020207

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
//
// new for NDIS 6
//
#define OID_802_3_ADD_MULTICAST_ADDRESS         0x01010208
#define OID_802_3_DELETE_MULTICAST_ADDRESS      0x01010209
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE


//
// 802.5 Objects (Token-Ring)
//
#define OID_802_5_PERMANENT_ADDRESS             0x02010101
#define OID_802_5_CURRENT_ADDRESS               0x02010102
#define OID_802_5_CURRENT_FUNCTIONAL            0x02010103
#define OID_802_5_CURRENT_GROUP                 0x02010104
#define OID_802_5_LAST_OPEN_STATUS              0x02010105
#define OID_802_5_CURRENT_RING_STATUS           0x02010106
#define OID_802_5_CURRENT_RING_STATE            0x02010107


#define OID_802_5_LINE_ERRORS                   0x02020101
#define OID_802_5_LOST_FRAMES                   0x02020102

#define OID_802_5_BURST_ERRORS                  0x02020201
#define OID_802_5_AC_ERRORS                     0x02020202
#define OID_802_5_ABORT_DELIMETERS              0x02020203
#define OID_802_5_FRAME_COPIED_ERRORS           0x02020204
#define OID_802_5_FREQUENCY_ERRORS              0x02020205
#define OID_802_5_TOKEN_ERRORS                  0x02020206
#define OID_802_5_INTERNAL_ERRORS               0x02020207


//
// FDDI Objects
//
#define OID_FDDI_LONG_PERMANENT_ADDR            0x03010101
#define OID_FDDI_LONG_CURRENT_ADDR              0x03010102
#define OID_FDDI_LONG_MULTICAST_LIST            0x03010103
#define OID_FDDI_LONG_MAX_LIST_SIZE             0x03010104
#define OID_FDDI_SHORT_PERMANENT_ADDR           0x03010105
#define OID_FDDI_SHORT_CURRENT_ADDR             0x03010106
#define OID_FDDI_SHORT_MULTICAST_LIST           0x03010107
#define OID_FDDI_SHORT_MAX_LIST_SIZE            0x03010108

#define OID_FDDI_ATTACHMENT_TYPE                0x03020101
#define OID_FDDI_UPSTREAM_NODE_LONG             0x03020102
#define OID_FDDI_DOWNSTREAM_NODE_LONG           0x03020103
#define OID_FDDI_FRAME_ERRORS                   0x03020104
#define OID_FDDI_FRAMES_LOST                    0x03020105
#define OID_FDDI_RING_MGT_STATE                 0x03020106
#define OID_FDDI_LCT_FAILURES                   0x03020107
#define OID_FDDI_LEM_REJECTS                    0x03020108
#define OID_FDDI_LCONNECTION_STATE              0x03020109

#define OID_FDDI_SMT_STATION_ID                 0x03030201
#define OID_FDDI_SMT_OP_VERSION_ID              0x03030202
#define OID_FDDI_SMT_HI_VERSION_ID              0x03030203
#define OID_FDDI_SMT_LO_VERSION_ID              0x03030204
#define OID_FDDI_SMT_MANUFACTURER_DATA          0x03030205
#define OID_FDDI_SMT_USER_DATA                  0x03030206
#define OID_FDDI_SMT_MIB_VERSION_ID             0x03030207
#define OID_FDDI_SMT_MAC_CT                     0x03030208
#define OID_FDDI_SMT_NON_MASTER_CT              0x03030209
#define OID_FDDI_SMT_MASTER_CT                  0x0303020A
#define OID_FDDI_SMT_AVAILABLE_PATHS            0x0303020B
#define OID_FDDI_SMT_CONFIG_CAPABILITIES        0x0303020C
#define OID_FDDI_SMT_CONFIG_POLICY              0x0303020D
#define OID_FDDI_SMT_CONNECTION_POLICY          0x0303020E
#define OID_FDDI_SMT_T_NOTIFY                   0x0303020F
#define OID_FDDI_SMT_STAT_RPT_POLICY            0x03030210
#define OID_FDDI_SMT_TRACE_MAX_EXPIRATION       0x03030211
#define OID_FDDI_SMT_PORT_INDEXES               0x03030212
#define OID_FDDI_SMT_MAC_INDEXES                0x03030213
#define OID_FDDI_SMT_BYPASS_PRESENT             0x03030214
#define OID_FDDI_SMT_ECM_STATE                  0x03030215
#define OID_FDDI_SMT_CF_STATE                   0x03030216
#define OID_FDDI_SMT_HOLD_STATE                 0x03030217
#define OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG     0x03030218
#define OID_FDDI_SMT_STATION_STATUS             0x03030219
#define OID_FDDI_SMT_PEER_WRAP_FLAG             0x0303021A
#define OID_FDDI_SMT_MSG_TIME_STAMP             0x0303021B
#define OID_FDDI_SMT_TRANSITION_TIME_STAMP      0x0303021C
#define OID_FDDI_SMT_SET_COUNT                  0x0303021D
#define OID_FDDI_SMT_LAST_SET_STATION_ID        0x0303021E
#define OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS     0x0303021F
#define OID_FDDI_MAC_BRIDGE_FUNCTIONS           0x03030220
#define OID_FDDI_MAC_T_MAX_CAPABILITY           0x03030221
#define OID_FDDI_MAC_TVX_CAPABILITY             0x03030222
#define OID_FDDI_MAC_AVAILABLE_PATHS            0x03030223
#define OID_FDDI_MAC_CURRENT_PATH               0x03030224
#define OID_FDDI_MAC_UPSTREAM_NBR               0x03030225
#define OID_FDDI_MAC_DOWNSTREAM_NBR             0x03030226
#define OID_FDDI_MAC_OLD_UPSTREAM_NBR           0x03030227
#define OID_FDDI_MAC_OLD_DOWNSTREAM_NBR         0x03030228
#define OID_FDDI_MAC_DUP_ADDRESS_TEST           0x03030229
#define OID_FDDI_MAC_REQUESTED_PATHS            0x0303022A
#define OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE       0x0303022B
#define OID_FDDI_MAC_INDEX                      0x0303022C
#define OID_FDDI_MAC_SMT_ADDRESS                0x0303022D
#define OID_FDDI_MAC_LONG_GRP_ADDRESS           0x0303022E
#define OID_FDDI_MAC_SHORT_GRP_ADDRESS          0x0303022F
#define OID_FDDI_MAC_T_REQ                      0x03030230
#define OID_FDDI_MAC_T_NEG                      0x03030231
#define OID_FDDI_MAC_T_MAX                      0x03030232
#define OID_FDDI_MAC_TVX_VALUE                  0x03030233
#define OID_FDDI_MAC_T_PRI0                     0x03030234
#define OID_FDDI_MAC_T_PRI1                     0x03030235
#define OID_FDDI_MAC_T_PRI2                     0x03030236
#define OID_FDDI_MAC_T_PRI3                     0x03030237
#define OID_FDDI_MAC_T_PRI4                     0x03030238
#define OID_FDDI_MAC_T_PRI5                     0x03030239
#define OID_FDDI_MAC_T_PRI6                     0x0303023A
#define OID_FDDI_MAC_FRAME_CT                   0x0303023B
#define OID_FDDI_MAC_COPIED_CT                  0x0303023C
#define OID_FDDI_MAC_TRANSMIT_CT                0x0303023D
#define OID_FDDI_MAC_TOKEN_CT                   0x0303023E
#define OID_FDDI_MAC_ERROR_CT                   0x0303023F
#define OID_FDDI_MAC_LOST_CT                    0x03030240
#define OID_FDDI_MAC_TVX_EXPIRED_CT             0x03030241
#define OID_FDDI_MAC_NOT_COPIED_CT              0x03030242
#define OID_FDDI_MAC_LATE_CT                    0x03030243
#define OID_FDDI_MAC_RING_OP_CT                 0x03030244
#define OID_FDDI_MAC_FRAME_ERROR_THRESHOLD      0x03030245
#define OID_FDDI_MAC_FRAME_ERROR_RATIO          0x03030246
#define OID_FDDI_MAC_NOT_COPIED_THRESHOLD       0x03030247
#define OID_FDDI_MAC_NOT_COPIED_RATIO           0x03030248
#define OID_FDDI_MAC_RMT_STATE                  0x03030249
#define OID_FDDI_MAC_DA_FLAG                    0x0303024A
#define OID_FDDI_MAC_UNDA_FLAG                  0x0303024B
#define OID_FDDI_MAC_FRAME_ERROR_FLAG           0x0303024C
#define OID_FDDI_MAC_NOT_COPIED_FLAG            0x0303024D
#define OID_FDDI_MAC_MA_UNITDATA_AVAILABLE      0x0303024E
#define OID_FDDI_MAC_HARDWARE_PRESENT           0x0303024F
#define OID_FDDI_MAC_MA_UNITDATA_ENABLE         0x03030250
#define OID_FDDI_PATH_INDEX                     0x03030251
#define OID_FDDI_PATH_RING_LATENCY              0x03030252
#define OID_FDDI_PATH_TRACE_STATUS              0x03030253
#define OID_FDDI_PATH_SBA_PAYLOAD               0x03030254
#define OID_FDDI_PATH_SBA_OVERHEAD              0x03030255
#define OID_FDDI_PATH_CONFIGURATION             0x03030256
#define OID_FDDI_PATH_T_R_MODE                  0x03030257
#define OID_FDDI_PATH_SBA_AVAILABLE             0x03030258
#define OID_FDDI_PATH_TVX_LOWER_BOUND           0x03030259
#define OID_FDDI_PATH_T_MAX_LOWER_BOUND         0x0303025A
#define OID_FDDI_PATH_MAX_T_REQ                 0x0303025B
#define OID_FDDI_PORT_MY_TYPE                   0x0303025C
#define OID_FDDI_PORT_NEIGHBOR_TYPE             0x0303025D
#define OID_FDDI_PORT_CONNECTION_POLICIES       0x0303025E
#define OID_FDDI_PORT_MAC_INDICATED             0x0303025F
#define OID_FDDI_PORT_CURRENT_PATH              0x03030260
#define OID_FDDI_PORT_REQUESTED_PATHS           0x03030261
#define OID_FDDI_PORT_MAC_PLACEMENT             0x03030262
#define OID_FDDI_PORT_AVAILABLE_PATHS           0x03030263
#define OID_FDDI_PORT_MAC_LOOP_TIME             0x03030264
#define OID_FDDI_PORT_PMD_CLASS                 0x03030265
#define OID_FDDI_PORT_CONNECTION_CAPABILITIES   0x03030266
#define OID_FDDI_PORT_INDEX                     0x03030267
#define OID_FDDI_PORT_MAINT_LS                  0x03030268
#define OID_FDDI_PORT_BS_FLAG                   0x03030269
#define OID_FDDI_PORT_PC_LS                     0x0303026A
#define OID_FDDI_PORT_EB_ERROR_CT               0x0303026B
#define OID_FDDI_PORT_LCT_FAIL_CT               0x0303026C
#define OID_FDDI_PORT_LER_ESTIMATE              0x0303026D
#define OID_FDDI_PORT_LEM_REJECT_CT             0x0303026E
#define OID_FDDI_PORT_LEM_CT                    0x0303026F
#define OID_FDDI_PORT_LER_CUTOFF                0x03030270
#define OID_FDDI_PORT_LER_ALARM                 0x03030271
#define OID_FDDI_PORT_CONNNECT_STATE            0x03030272
#define OID_FDDI_PORT_PCM_STATE                 0x03030273
#define OID_FDDI_PORT_PC_WITHHOLD               0x03030274
#define OID_FDDI_PORT_LER_FLAG                  0x03030275
#define OID_FDDI_PORT_HARDWARE_PRESENT          0x03030276
#define OID_FDDI_SMT_STATION_ACTION             0x03030277
#define OID_FDDI_PORT_ACTION                    0x03030278
#define OID_FDDI_IF_DESCR                       0x03030279
#define OID_FDDI_IF_TYPE                        0x0303027A
#define OID_FDDI_IF_MTU                         0x0303027B
#define OID_FDDI_IF_SPEED                       0x0303027C
#define OID_FDDI_IF_PHYS_ADDRESS                0x0303027D
#define OID_FDDI_IF_ADMIN_STATUS                0x0303027E
#define OID_FDDI_IF_OPER_STATUS                 0x0303027F
#define OID_FDDI_IF_LAST_CHANGE                 0x03030280
#define OID_FDDI_IF_IN_OCTETS                   0x03030281
#define OID_FDDI_IF_IN_UCAST_PKTS               0x03030282
#define OID_FDDI_IF_IN_NUCAST_PKTS              0x03030283
#define OID_FDDI_IF_IN_DISCARDS                 0x03030284
#define OID_FDDI_IF_IN_ERRORS                   0x03030285
#define OID_FDDI_IF_IN_UNKNOWN_PROTOS           0x03030286
#define OID_FDDI_IF_OUT_OCTETS                  0x03030287
#define OID_FDDI_IF_OUT_UCAST_PKTS              0x03030288
#define OID_FDDI_IF_OUT_NUCAST_PKTS             0x03030289
#define OID_FDDI_IF_OUT_DISCARDS                0x0303028A
#define OID_FDDI_IF_OUT_ERRORS                  0x0303028B
#define OID_FDDI_IF_OUT_QLEN                    0x0303028C
#define OID_FDDI_IF_SPECIFIC                    0x0303028D

//
// WAN objects
//
#define OID_WAN_PERMANENT_ADDRESS               0x04010101
#define OID_WAN_CURRENT_ADDRESS                 0x04010102
#define OID_WAN_QUALITY_OF_SERVICE              0x04010103
#define OID_WAN_PROTOCOL_TYPE                   0x04010104
#define OID_WAN_MEDIUM_SUBTYPE                  0x04010105
#define OID_WAN_HEADER_FORMAT                   0x04010106

#define OID_WAN_GET_INFO                        0x04010107
#define OID_WAN_SET_LINK_INFO                   0x04010108
#define OID_WAN_GET_LINK_INFO                   0x04010109

#define OID_WAN_LINE_COUNT                      0x0401010A
#define OID_WAN_PROTOCOL_CAPS                   0x0401010B

#define OID_WAN_GET_BRIDGE_INFO                 0x0401020A
#define OID_WAN_SET_BRIDGE_INFO                 0x0401020B
#define OID_WAN_GET_COMP_INFO                   0x0401020C
#define OID_WAN_SET_COMP_INFO                   0x0401020D
#define OID_WAN_GET_STATS_INFO                  0x0401020E

#ifdef UNDER_CE
//
//  Used to retrieve the IPV6CP negotiated Interface Identifier
//
#define OID_WAN_IPV6CP_INTERFACE_ID             0x04010220
#endif  //  UNDER_CE

//
//  These are connection-oriented WAN OIDs.
//  These replace the above OIDs for CoNDIS WAN Miniports
//
#define OID_WAN_CO_GET_INFO                     0x04010180
#define OID_WAN_CO_SET_LINK_INFO                0x04010181
#define OID_WAN_CO_GET_LINK_INFO                0x04010182
#define OID_WAN_CO_GET_COMP_INFO                0x04010280
#define OID_WAN_CO_SET_COMP_INFO                0x04010281
#define OID_WAN_CO_GET_STATS_INFO               0x04010282


//
// LocalTalk objects
//
#define OID_LTALK_CURRENT_NODE_ID               0x05010102

#define OID_LTALK_IN_BROADCASTS                 0x05020101
#define OID_LTALK_IN_LENGTH_ERRORS              0x05020102

#define OID_LTALK_OUT_NO_HANDLERS               0x05020201
#define OID_LTALK_COLLISIONS                    0x05020202
#define OID_LTALK_DEFERS                        0x05020203
#define OID_LTALK_NO_DATA_ERRORS                0x05020204
#define OID_LTALK_RANDOM_CTS_ERRORS             0x05020205
#define OID_LTALK_FCS_ERRORS                    0x05020206


//
// Arcnet objects
//
#define OID_ARCNET_PERMANENT_ADDRESS            0x06010101
#define OID_ARCNET_CURRENT_ADDRESS              0x06010102

#define OID_ARCNET_RECONFIGURATIONS             0x06020201

//
// TAPI objects
//
#define OID_TAPI_ACCEPT                         0x07030101
#define OID_TAPI_ANSWER                         0x07030102
#define OID_TAPI_CLOSE                          0x07030103
#define OID_TAPI_CLOSE_CALL                     0x07030104
#define OID_TAPI_CONDITIONAL_MEDIA_DETECTION    0x07030105
#define OID_TAPI_CONFIG_DIALOG                  0x07030106
#define OID_TAPI_DEV_SPECIFIC                   0x07030107
#define OID_TAPI_DIAL                           0x07030108
#define OID_TAPI_DROP                           0x07030109
#define OID_TAPI_GET_ADDRESS_CAPS               0x0703010A
#define OID_TAPI_GET_ADDRESS_ID                 0x0703010B
#define OID_TAPI_GET_ADDRESS_STATUS             0x0703010C
#define OID_TAPI_GET_CALL_ADDRESS_ID            0x0703010D
#define OID_TAPI_GET_CALL_INFO                  0x0703010E
#define OID_TAPI_GET_CALL_STATUS                0x0703010F
#define OID_TAPI_GET_DEV_CAPS                   0x07030110
#define OID_TAPI_GET_DEV_CONFIG                 0x07030111
#define OID_TAPI_GET_EXTENSION_ID               0x07030112
#define OID_TAPI_GET_ID                         0x07030113
#define OID_TAPI_GET_LINE_DEV_STATUS            0x07030114
#define OID_TAPI_MAKE_CALL                      0x07030115
#define OID_TAPI_NEGOTIATE_EXT_VERSION          0x07030116
#define OID_TAPI_OPEN                           0x07030117
#define OID_TAPI_PROVIDER_INITIALIZE            0x07030118
#define OID_TAPI_PROVIDER_SHUTDOWN              0x07030119
#define OID_TAPI_SECURE_CALL                    0x0703011A
#define OID_TAPI_SELECT_EXT_VERSION             0x0703011B
#define OID_TAPI_SEND_USER_USER_INFO            0x0703011C
#define OID_TAPI_SET_APP_SPECIFIC               0x0703011D
#define OID_TAPI_SET_CALL_PARAMS                0x0703011E
#define OID_TAPI_SET_DEFAULT_MEDIA_DETECTION    0x0703011F
#define OID_TAPI_SET_DEV_CONFIG                 0x07030120
#define OID_TAPI_SET_MEDIA_MODE                 0x07030121
#define OID_TAPI_SET_STATUS_MESSAGES            0x07030122
#define OID_TAPI_GATHER_DIGITS                  0x07030123
#define OID_TAPI_MONITOR_DIGITS                 0x07030124

#ifdef UNDER_CE
#define OID_TAPI_TRANSLATE_ADDRESS              0x07030200  // CE Only
#define OID_TAPI_CONFIG_DIALOG_EDIT             0x07030201  // CE Only
#endif  //  UNDER_CE

//
// ATM Connection Oriented OIDs
//
#define OID_ATM_SUPPORTED_VC_RATES              0x08010101
#define OID_ATM_SUPPORTED_SERVICE_CATEGORY      0x08010102
#define OID_ATM_SUPPORTED_AAL_TYPES             0x08010103
#define OID_ATM_HW_CURRENT_ADDRESS              0x08010104
#define OID_ATM_MAX_ACTIVE_VCS                  0x08010105
#define OID_ATM_MAX_ACTIVE_VCI_BITS             0x08010106
#define OID_ATM_MAX_ACTIVE_VPI_BITS             0x08010107
#define OID_ATM_MAX_AAL0_PACKET_SIZE            0x08010108
#define OID_ATM_MAX_AAL1_PACKET_SIZE            0x08010109
#define OID_ATM_MAX_AAL34_PACKET_SIZE           0x0801010A
#define OID_ATM_MAX_AAL5_PACKET_SIZE            0x0801010B

#define OID_ATM_SIGNALING_VPIVCI                0x08010201
#define OID_ATM_ASSIGNED_VPI                    0x08010202
#define OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES    0x08010203
#define OID_ATM_RELEASE_ACCESS_NET_RESOURCES    0x08010204
#define OID_ATM_ILMI_VPIVCI                     0x08010205
#define OID_ATM_DIGITAL_BROADCAST_VPIVCI        0x08010206
#define OID_ATM_GET_NEAREST_FLOW                0x08010207
#define OID_ATM_ALIGNMENT_REQUIRED              0x08010208
#define OID_ATM_LECS_ADDRESS                    0x08010209
#define OID_ATM_SERVICE_ADDRESS                 0x0801020A

#define OID_ATM_CALL_PROCEEDING                 0x0801020B  // UNI 4.0
#define OID_ATM_CALL_ALERTING                   0x0801020C  // UNI 4.0
#define OID_ATM_PARTY_ALERTING                  0x0801020D  // UNI 4.0
#define OID_ATM_CALL_NOTIFY                     0x0801020E  // UNI 4.0

#define OID_ATM_MY_IP_NM_ADDRESS                0x0801020F


//
//  ATM specific statistics OIDs.
//
#define OID_ATM_RCV_CELLS_OK                    0x08020101
#define OID_ATM_XMIT_CELLS_OK                   0x08020102
#define OID_ATM_RCV_CELLS_DROPPED               0x08020103

#define OID_ATM_RCV_INVALID_VPI_VCI             0x08020201
#define OID_ATM_CELLS_HEC_ERROR                 0x08020202
#define OID_ATM_RCV_REASSEMBLY_ERROR            0x08020203

#ifdef UNDER_CE
//
//  backward compatibility
//

//
// PCCA (Wireless) object
//

//
// All WirelessWAN devices must support the following OIDs
//

#define OID_WW_GEN_NETWORK_TYPES_SUPPORTED      0x09010101
#define OID_WW_GEN_NETWORK_TYPE_IN_USE          0x09010102
#define OID_WW_GEN_HEADER_FORMATS_SUPPORTED     0x09010103
#define OID_WW_GEN_HEADER_FORMAT_IN_USE         0x09010104
#define OID_WW_GEN_INDICATION_REQUEST           0x09010105
#define OID_WW_GEN_DEVICE_INFO                  0x09010106
#define OID_WW_GEN_OPERATION_MODE               0x09010107
#define OID_WW_GEN_LOCK_STATUS                  0x09010108
#define OID_WW_GEN_DISABLE_TRANSMITTER          0x09010109
#define OID_WW_GEN_NETWORK_ID                   0x0901010A
#define OID_WW_GEN_PERMANENT_ADDRESS            0x0901010B
#define OID_WW_GEN_CURRENT_ADDRESS              0x0901010C
#define OID_WW_GEN_SUSPEND_DRIVER               0x0901010D
#define OID_WW_GEN_BASESTATION_ID               0x0901010E
#define OID_WW_GEN_CHANNEL_ID                   0x0901010F
#define OID_WW_GEN_ENCRYPTION_SUPPORTED         0x09010110
#define OID_WW_GEN_ENCRYPTION_IN_USE            0x09010111
#define OID_WW_GEN_ENCRYPTION_STATE             0x09010112
#define OID_WW_GEN_CHANNEL_QUALITY              0x09010113
#define OID_WW_GEN_REGISTRATION_STATUS          0x09010114
#define OID_WW_GEN_RADIO_LINK_SPEED             0x09010115
#define OID_WW_GEN_LATENCY                      0x09010116
#define OID_WW_GEN_BATTERY_LEVEL                0x09010117
#define OID_WW_GEN_EXTERNAL_POWER               0x09010118

//
// These are optional
//
#define OID_WW_GEN_PING_ADDRESS                 0x09010201
#define OID_WW_GEN_RSSI                         0x09010202
#define OID_WW_GEN_SIM_STATUS                   0x09010203
#define OID_WW_GEN_ENABLE_SIM_PIN               0x09010204
#define OID_WW_GEN_CHANGE_SIM_PIN               0x09010205
#define OID_WW_GEN_SIM_PUK                      0x09010206
#define OID_WW_GEN_SIM_EXCEPTION                0x09010207

//
// Network Dependent OIDs - Mobitex:
//

#define OID_WW_MBX_SUBADDR                      0x09050101
// OID 0x09050102 is reserved and may not be used
#define OID_WW_MBX_FLEXLIST                     0x09050103
#define OID_WW_MBX_GROUPLIST                    0x09050104
#define OID_WW_MBX_TRAFFIC_AREA                 0x09050105
#define OID_WW_MBX_LIVE_DIE                     0x09050106
#define OID_WW_MBX_TEMP_DEFAULTLIST             0x09050107

//
// Network Dependent OIDs - Pinpoint:
//
//
// The following Pin Point characteristics have been deprecated by the
// PCCA and are considered reserved values. They are include here only for
// historical purposes and should not be used
//
#define OID_WW_PIN_LOC_AUTHORIZE                0x09090101
#define OID_WW_PIN_LAST_LOCATION                0x09090102
#define OID_WW_PIN_LOC_FIX                      0x09090103

//
// Network Dependent - CDPD:
//
#define OID_WW_CDPD_SPNI                        0x090D0101
#define OID_WW_CDPD_WASI                        0x090D0102
#define OID_WW_CDPD_AREA_COLOR                  0x090D0103
#define OID_WW_CDPD_TX_POWER_LEVEL              0x090D0104
#define OID_WW_CDPD_EID                         0x090D0105
#define OID_WW_CDPD_HEADER_COMPRESSION          0x090D0106
#define OID_WW_CDPD_DATA_COMPRESSION            0x090D0107
#define OID_WW_CDPD_CHANNEL_SELECT              0x090D0108
#define OID_WW_CDPD_CHANNEL_STATE               0x090D0109
#define OID_WW_CDPD_NEI                         0x090D010A
#define OID_WW_CDPD_NEI_STATE                   0x090D010B
#define OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER 0x090D010C
#define OID_WW_CDPD_SLEEP_MODE                  0x090D010D

//
// At the request of the PCCA STD-201 Annex C working group the following OID
// value has been superceeded by more specific objects. Its value is reserved by
// the PCCA,is included here for historical purposes only, and should not be
// used.
//
#define OID_WW_CDPD_CIRCUIT_SWITCHED            0x090D010E

#define OID_WW_CDPD_TEI                         0x090D010F
#define OID_WW_CDPD_RSSI                        0x090D0110

//
// CDPD Circuit Switched objects
//
#define OID_WW_CDPD_CS_SERVICE_PREFERENCE       0x090D0111
#define OID_WW_CDPD_CS_SERVICE_STATUS           0x090D0112
#define OID_WW_CDPD_CS_INFO                     0x090D0113
#define OID_WW_CDPD_CS_SUSPEND                  0x090D0114
#define OID_WW_CDPD_CS_DEFAULT_DIAL_CODE        0x090D0115
#define OID_WW_CDPD_CS_CALLBACK                 0x090D0116
#define OID_WW_CDPD_CS_SID_LIST                 0x090D0117
#define OID_WW_CDPD_CS_CONFIGURATION            0x090D0118

//
// Network Dependent - Ardis:
//
//
// At the request of Ardis these OID value have been superceeded. Their
// functionality has been merged with the DataTAC objects. Therefore
// these values are reserved by the PCCA, are include here for
// historical purposes only, and should not be used.
//
#define OID_WW_ARD_SNDCP                        0x09110101
#define OID_WW_ARD_TMLY_MSG                     0x09110102
#define OID_WW_ARD_DATAGRAM                     0x09110103

//
// Network Dependent - DataTac:
//

#define OID_WW_TAC_COMPRESSION                  0x09150101

//
// At the request of Motorola, the following two OID values have been
// superceeded. Their functionality has been subsumed by other more specific
// DataTac objects and should not be used. These values are reserved by the
// PCCA and are include here only for historical purposes only.
//
#define OID_WW_TAC_SET_CONFIG                   0x09150102
#define OID_WW_TAC_GET_STATUS                   0x09150103
#define OID_WW_TAC_USER_HEADER                  0x09150104

//
// DataTAC characteristic object values
//
#define OID_WW_TAC_UNIQUE_SDU_TAG               0x09150105
#define OID_WW_TAC_SEND_COMMAND                 0x09150106
#define OID_WW_TAC_GET_RESPONSE                 0x09150107
#define OID_WW_TAC_DISABLE_RECEIVER             0x09150108
#define OID_WW_TAC_ANTENNA_MODE                 0x09150109
#define OID_WW_TAC_FLUSH_DATA                   0x0915010A
#define OID_WW_TAC_SHUTDOWN_DEVICE              0x0915010B
#define OID_WW_TAC_DEVICE_EXCEPTION             0x0915010C
#define OID_WW_TAC_RECEIVE_EXCEPTION            0x0915010D
#define OID_WW_TAC_BUFFER_EXCEPTION             0x0915010E
#define OID_WW_TAC_BATTERY_EXCEPTION            0x0915010F
#define OID_WW_TAC_TRANSMITTER_KEYED            0x09150110
#define OID_WW_TAC_SYSTEM_TABLE                 0x09150111
#define OID_WW_TAC_CHANNEL_TABLE                0x09150112
#define OID_WW_TAC_DCHANNEL_TABLE               0x09150113
#define OID_WW_TAC_RECEIVE_QUEUE_COUNT          0x09150114

//
// DataTac statistic object value
//
#define OID_WW_TAC_STATISTICS                   0x09160101

//
// Network Dependent - Metricom:
//

#define OID_WW_MET_FUNCTION                     0x09190101
#endif  //  UNDER_CE

//
// IEEE 802.11 OIDs
//
#define OID_802_11_BSSID                        0x0D010101
#define OID_802_11_SSID                         0x0D010102
#define OID_802_11_NETWORK_TYPES_SUPPORTED      0x0D010203
#define OID_802_11_NETWORK_TYPE_IN_USE          0x0D010204
#define OID_802_11_TX_POWER_LEVEL               0x0D010205
#define OID_802_11_RSSI                         0x0D010206
#define OID_802_11_RSSI_TRIGGER                 0x0D010207
#define OID_802_11_INFRASTRUCTURE_MODE          0x0D010108
#define OID_802_11_FRAGMENTATION_THRESHOLD      0x0D010209
#define OID_802_11_RTS_THRESHOLD                0x0D01020A
#define OID_802_11_NUMBER_OF_ANTENNAS           0x0D01020B
#define OID_802_11_RX_ANTENNA_SELECTED          0x0D01020C
#define OID_802_11_TX_ANTENNA_SELECTED          0x0D01020D
#define OID_802_11_SUPPORTED_RATES              0x0D01020E
#define OID_802_11_DESIRED_RATES                0x0D010210
#define OID_802_11_CONFIGURATION                0x0D010211
#define OID_802_11_STATISTICS                   0x0D020212
#define OID_802_11_ADD_WEP                      0x0D010113
#define OID_802_11_REMOVE_WEP                   0x0D010114
#define OID_802_11_DISASSOCIATE                 0x0D010115
#define OID_802_11_POWER_MODE                   0x0D010216
#define OID_802_11_BSSID_LIST                   0x0D010217
#define OID_802_11_AUTHENTICATION_MODE          0x0D010118
#define OID_802_11_PRIVACY_FILTER               0x0D010119
#define OID_802_11_BSSID_LIST_SCAN              0x0D01011A
#define OID_802_11_WEP_STATUS                   0x0D01011B
#ifdef UNDER_CE
// Renamed to support more than just WEP encryption
#else  //  UNDER_CE
// Renamed to reflect better the extended set of encryption status
#endif  //  UNDER_CE
#define OID_802_11_ENCRYPTION_STATUS            OID_802_11_WEP_STATUS
#define OID_802_11_RELOAD_DEFAULTS              0x0D01011C

#ifdef UNDER_CE
//
//	Special OIDs for NDIS
//
#define	OID_NDIS_BLOCK_MEDIA_CONNECT		0xffff0001
#define	OID_NDIS_UNBLOCK_MEDIA_CONNECT		0xffff0002
#define	OID_NDIS_EMULATE_MEDIA_CONNECT		0xffff0003
#define	OID_NDIS_EMULATE_MEDIA_DISCONNECT	0xffff0004
#define OID_NDIS_RNDIS_HOST_MAC_ADDRESS     0xffff0005
#endif  //  UNDER_CE

// Added to allow key mapping and default keys
#define OID_802_11_ADD_KEY                      0x0D01011D
#define OID_802_11_REMOVE_KEY                   0x0D01011E
#define OID_802_11_ASSOCIATION_INFORMATION      0x0D01011F
#define OID_802_11_TEST                         0x0D010120
#define OID_802_11_MEDIA_STREAM_MODE            0x0D010121
#define OID_802_11_CAPABILITY                   0x0D010122
#define OID_802_11_PMKID                        0x0D010123
#define OID_802_11_NON_BCAST_SSID_LIST          0x0D010124
#define OID_802_11_RADIO_STATUS                 0x0D010125


//
// some of well known Ethernet frame types (in big endian notation)
//
#define NDIS_ETH_TYPE_IPV4              0x0800  // IPV4
#define NDIS_ETH_TYPE_ARP               0x0806  // ARP
#define NDIS_ETH_TYPE_IPV6              0x86dd  // IPV6
#define NDIS_ETH_TYPE_802_1X            0x888e  // 802.1x
#define NDIS_ETH_TYPE_802_1Q            0x8100  // 802.1p
#define NDIS_ETH_TYPE_SLOW_PROTOCOL     0x8809  // Slow protocols (LACP, etc.)

#define NDIS_802_11_LENGTH_SSID         32
#define NDIS_802_11_LENGTH_RATES        8
#define NDIS_802_11_LENGTH_RATES_EX     16

//
// IEEE 802.11 Structures and definitions
//
// new types for Media Specific Indications
typedef enum _NDIS_802_11_STATUS_TYPE
{
    Ndis802_11StatusType_Authentication,
    Ndis802_11StatusType_MediaStreamMode,
    Ndis802_11StatusType_PMKID_CandidateList,
    Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;

typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];

typedef struct _NDIS_802_11_STATUS_INDICATION
{
    NDIS_802_11_STATUS_TYPE StatusType;
} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;

// mask for authentication/integrity fields
#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS		0x0f

#define NDIS_802_11_AUTH_REQUEST_REAUTH				0x01
#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE			0x02
#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E

typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
{
    ULONG Length;            // Length of structure
    NDIS_802_11_MAC_ADDRESS Bssid;
    ULONG Flags;
} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;

//Added new types for PMKID Candidate lists.
typedef struct _PMKID_CANDIDATE {
    NDIS_802_11_MAC_ADDRESS BSSID;
    ULONG Flags;
} PMKID_CANDIDATE, *PPMKID_CANDIDATE;

typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
{
    ULONG Version;       // Version of the structure
    ULONG NumCandidates; // No. of pmkid candidates
    PMKID_CANDIDATE CandidateList[1];
} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;

//Flags for PMKID Candidate list structure
#define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01

// Added new types for OFDM 5G and 2.4G
typedef enum _NDIS_802_11_NETWORK_TYPE
{
    Ndis802_11FH,
    Ndis802_11DS,
    Ndis802_11OFDM5,
    Ndis802_11OFDM24,
    Ndis802_11Automode,
    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;

typedef struct _NDIS_802_11_NETWORK_TYPE_LIST
{
    ULONG                       NumberOfItems;  // in list below, at least 1
    NDIS_802_11_NETWORK_TYPE    NetworkType [1];
} NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;

typedef enum _NDIS_802_11_POWER_MODE
{
    Ndis802_11PowerModeCAM,
    Ndis802_11PowerModeMAX_PSP,
    Ndis802_11PowerModeFast_PSP,
    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;

typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts

//
// Received Signal Strength Indication
//
typedef LONG   NDIS_802_11_RSSI;           // in dBm

typedef struct _NDIS_802_11_CONFIGURATION_FH
{
    ULONG           Length;             // Length of structure
    ULONG           HopPattern;         // As defined by 802.11, MSB set
    ULONG           HopSet;             // to one if non-802.11
    ULONG           DwellTime;          // units are Kusec
} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;

typedef struct _NDIS_802_11_CONFIGURATION
{
    ULONG           Length;             // Length of structure
    ULONG           BeaconPeriod;       // units are Kusec
    ULONG           ATIMWindow;         // units are Kusec
    ULONG           DSConfig;           // Frequency, units are kHz
    NDIS_802_11_CONFIGURATION_FH    FHConfig;
} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;

typedef struct _NDIS_802_11_STATISTICS
{
    ULONG           Length;             // Length of structure
    LARGE_INTEGER   TransmittedFragmentCount;
    LARGE_INTEGER   MulticastTransmittedFrameCount;
    LARGE_INTEGER   FailedCount;
    LARGE_INTEGER   RetryCount;
    LARGE_INTEGER   MultipleRetryCount;
    LARGE_INTEGER   RTSSuccessCount;
    LARGE_INTEGER   RTSFailureCount;
    LARGE_INTEGER   ACKFailureCount;
    LARGE_INTEGER   FrameDuplicateCount;
    LARGE_INTEGER   ReceivedFragmentCount;
    LARGE_INTEGER   MulticastReceivedFrameCount;
    LARGE_INTEGER   FCSErrorCount;
#ifndef UNDER_CE
    LARGE_INTEGER   TKIPLocalMICFailures;
    LARGE_INTEGER   TKIPICVErrorCount;
    LARGE_INTEGER   TKIPCounterMeasuresInvoked;
    LARGE_INTEGER   TKIPReplays;
    LARGE_INTEGER   CCMPFormatErrors;
    LARGE_INTEGER   CCMPReplays;
    LARGE_INTEGER   CCMPDecryptErrors;
    LARGE_INTEGER   FourWayHandshakeFailures;
    LARGE_INTEGER   WEPUndecryptableCount;
    LARGE_INTEGER   WEPICVErrorCount;
    LARGE_INTEGER   DecryptSuccessCount;
    LARGE_INTEGER   DecryptFailureCount;
#endif  //  UNDER_CE
} NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;

typedef  ULONG  NDIS_802_11_KEY_INDEX;
typedef ULONGLONG   NDIS_802_11_KEY_RSC;

// Key mapping keys require a BSSID
typedef struct _NDIS_802_11_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    ULONG           KeyLength;          // length of key in bytes
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_KEY_RSC KeyRSC;
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_KEY, *PNDIS_802_11_KEY;

typedef struct _NDIS_802_11_REMOVE_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    NDIS_802_11_MAC_ADDRESS BSSID;
} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;

typedef struct _NDIS_802_11_WEP
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;           // 0 is the per-client key, 1-N are the
                                        // global keys
    ULONG           KeyLength;          // length of key in bytes
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_WEP, *PNDIS_802_11_WEP;


typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
{
    Ndis802_11IBSS,
    Ndis802_11Infrastructure,
    Ndis802_11AutoUnknown,
    Ndis802_11InfrastructureMax         // Not a real value, defined as upper bound
} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;

// Add new authentication modes
typedef enum _NDIS_802_11_AUTHENTICATION_MODE
{
    Ndis802_11AuthModeOpen,
    Ndis802_11AuthModeShared,
    Ndis802_11AuthModeAutoSwitch,
    Ndis802_11AuthModeWPA,
    Ndis802_11AuthModeWPAPSK,
    Ndis802_11AuthModeWPANone,
    Ndis802_11AuthModeWPA2,
    Ndis802_11AuthModeWPA2PSK,
    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;

typedef UCHAR   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
typedef UCHAR   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates

typedef struct _NDIS_802_11_SSID
{
    ULONG   SsidLength;         // length of SSID field below, in bytes;
                                // this can be zero.
    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
} NDIS_802_11_SSID, *PNDIS_802_11_SSID;


typedef struct _NDIS_WLAN_BSSID
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES                   SupportedRates;
} NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;

typedef struct _NDIS_802_11_BSSID_LIST
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID Bssid[1];
} NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;

// Added Capabilities, IELength and IEs for each BSSID
typedef struct _NDIS_WLAN_BSSID_EX
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES_EX                SupportedRates;
    ULONG                               IELength;
    UCHAR                               IEs[1];
} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;

typedef struct _NDIS_802_11_BSSID_LIST_EX
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID_EX Bssid[1];
} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;

typedef struct _NDIS_802_11_FIXED_IEs
{
	UCHAR Timestamp[8];
	USHORT BeaconInterval;
	USHORT Capabilities;
} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;

typedef struct _NDIS_802_11_VARIABLE_IEs
{
	UCHAR ElementID;
	UCHAR Length;	// Number of bytes in data field
	UCHAR data[1];
} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;

typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;

typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;

typedef  ULONG   NDIS_802_11_ANTENNA;

typedef enum _NDIS_802_11_PRIVACY_FILTER
{
    Ndis802_11PrivFilterAcceptAll,
    Ndis802_11PrivFilter8021xWEP
} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;

// Added new encryption types
// Also aliased typedef to new name
typedef enum _NDIS_802_11_WEP_STATUS
{
    Ndis802_11WEPEnabled,
    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
    Ndis802_11WEPDisabled,
    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
    Ndis802_11WEPKeyAbsent,
    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
    Ndis802_11WEPNotSupported,
    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
    Ndis802_11Encryption2Enabled,
    Ndis802_11Encryption2KeyAbsent,
    Ndis802_11Encryption3Enabled,
    Ndis802_11Encryption3KeyAbsent
} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;

typedef enum _NDIS_802_11_RELOAD_DEFAULTS
{
    Ndis802_11ReloadWEPKeys
} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;

#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4

#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
#define NDIS_802_11_AI_RESFI_STATUSCODE        2
#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4

typedef struct _NDIS_802_11_AI_REQFI
{
    USHORT Capabilities;
    USHORT ListenInterval;
    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;

typedef struct _NDIS_802_11_AI_RESFI
{
    USHORT Capabilities;
    USHORT StatusCode;
    USHORT AssociationId;
} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;

typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
{
    ULONG Length;
    USHORT AvailableRequestFixedIEs;
    NDIS_802_11_AI_REQFI    RequestFixedIEs;
    ULONG RequestIELength;
    ULONG OffsetRequestIEs;
    USHORT AvailableResponseFixedIEs;
    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
    ULONG ResponseIELength;
    ULONG OffsetResponseIEs;
} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;

typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
{
    NDIS_802_11_STATUS_INDICATION       Status;
    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;

typedef struct _NDIS_802_11_TEST
{
    ULONG Length;
    ULONG Type;
    union
    {
        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
        NDIS_802_11_RSSI RssiTrigger;
    };
} NDIS_802_11_TEST, *PNDIS_802_11_TEST;

// 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
{
    Ndis802_11MediaStreamOff,
    Ndis802_11MediaStreamOn,
} NDIS_802_11_MEDIA_STREAM_MODE, *PNDIS_802_11_MEDIA_STREAM_MODE;

// PMKID Structures
typedef UCHAR   NDIS_802_11_PMKID_VALUE[16];

typedef struct _BSSID_INFO
{
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_PMKID_VALUE PMKID;
} BSSID_INFO, *PBSSID_INFO;

typedef struct _NDIS_802_11_PMKID
{
    ULONG Length;
    ULONG BSSIDInfoCount;
    BSSID_INFO BSSIDInfo[1];
} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;

typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
{
    NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
    NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;

typedef struct _NDIS_802_11_CAPABILITY
{
    ULONG Length;
    ULONG Version;
    ULONG NoOfPMKIDs;
    ULONG NoOfAuthEncryptPairsSupported;
    NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;

typedef struct _NDIS_802_11_NON_BCAST_SSID_LIST
{
    ULONG               NumberOfItems;
    NDIS_802_11_SSID    Non_Bcast_Ssid[1];
} NDIS_802_11_NON_BCAST_SSID_LIST, *PNDIS_802_11_NON_BCAST_SSID_LIST;

// for OID_802_11_RADIO_STATUS
typedef enum _NDIS_802_11_RADIO_STATUS
{
    Ndis802_11RadioStatusOn,
    Ndis802_11RadioStatusHardwareOff,
    Ndis802_11RadioStatusSoftwareOff,
    Ndis802_11RadioStatusHardwareSoftwareOff,
    Ndis802_11RadioStatusMax      // not a real mode, defined as an upper bound
}
NDIS_802_11_RADIO_STATUS, *PNDIS_802_11_RADIO_STATUS;

//
// IRDA objects
//
#define OID_IRDA_RECEIVING                      0x0A010100
#define OID_IRDA_TURNAROUND_TIME                0x0A010101
#define OID_IRDA_SUPPORTED_SPEEDS               0x0A010102
#define OID_IRDA_LINK_SPEED                     0x0A010103
#define OID_IRDA_MEDIA_BUSY                     0x0A010104

#define OID_IRDA_EXTRA_RCV_BOFS                 0x0A010200
#define OID_IRDA_RATE_SNIFF                     0x0A010201
#define OID_IRDA_UNICAST_LIST                   0x0A010202
#define OID_IRDA_MAX_UNICAST_LIST_SIZE          0x0A010203
#define OID_IRDA_MAX_RECEIVE_WINDOW_SIZE        0x0A010204
#define OID_IRDA_MAX_SEND_WINDOW_SIZE           0x0A010205
#ifdef UNDER_CE
#define OID_IRDA_RELEASE_HW_RESOURCES           0x0A01020A
#define OID_IRDA_REACQUIRE_HW_RESOURCES         0x0A01020B
#endif  //  UNDER_CE
#define OID_IRDA_RESERVED1                      0x0A01020A  // The range between OID_IRDA_RESERVED1
#define OID_IRDA_RESERVED2                      0x0A01020F  // and OID_IRDA_RESERVED2 is reserved

#ifdef UNDER_CE
//
//  backward compatibility
//

//
// BPC OIDs
//
#define OID_BPC_ADAPTER_CAPS                    0x0B010100
#define OID_BPC_DEVICES                         0x0B010101
#define OID_BPC_DEVICE_CAPS                     0x0B010102
#define OID_BPC_DEVICE_SETTINGS                 0x0B010103
#define OID_BPC_CONNECTION_STATUS               0x0B010104
#define OID_BPC_ADDRESS_COMPARE                 0x0B010105
#define OID_BPC_PROGRAM_GUIDE                   0x0B010106
#define OID_BPC_LAST_ERROR                      0x0B020107
#define OID_BPC_POOL                            0x0B010108

#define OID_BPC_PROVIDER_SPECIFIC               0x0B020109
#define OID_BPC_ADAPTER_SPECIFIC                0x0B02010A

#define OID_BPC_CONNECT                         0x0B01010B
#define OID_BPC_COMMIT                          0x0B01010C
#define OID_BPC_DISCONNECT                      0x0B01010D
#define OID_BPC_CONNECTION_ENABLE               0x0B01010E
#define OID_BPC_POOL_RESERVE                    0x0B01010F
#define OID_BPC_POOL_RETURN                     0x0B010110
#define OID_BPC_FORCE_RECEIVE                   0x0B010111

#define OID_BPC_LAST                            0x0B020112
#endif  //  UNDER_CE

//
// IEEE1394 mandatory general OIDs.
//
#define OID_1394_LOCAL_NODE_INFO                0x0C010101
#define OID_1394_VC_INFO                        0x0C010102

//
// The following OIDs are not specific to a media.
//

//
// These are objects for Connection-oriented media call-managers.
//
#define OID_CO_ADD_PVC                          0xFE000001
#define OID_CO_DELETE_PVC                       0xFE000002
#define OID_CO_GET_CALL_INFORMATION             0xFE000003
#define OID_CO_ADD_ADDRESS                      0xFE000004
#define OID_CO_DELETE_ADDRESS                   0xFE000005
#define OID_CO_GET_ADDRESSES                    0xFE000006
#define OID_CO_ADDRESS_CHANGE                   0xFE000007
#define OID_CO_SIGNALING_ENABLED                0xFE000008
#define OID_CO_SIGNALING_DISABLED               0xFE000009
#define OID_CO_AF_CLOSE                         0xFE00000A

//
// Objects for call-managers and MCMs that support TAPI access.
//
#define OID_CO_TAPI_CM_CAPS                     0xFE001001
#define OID_CO_TAPI_LINE_CAPS                   0xFE001002
#define OID_CO_TAPI_ADDRESS_CAPS                0xFE001003
#define OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS   0xFE001004
#define OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS   0xFE001005
#define OID_CO_TAPI_TRANSLATE_TAPI_SAP          0xFE001006
#define OID_CO_TAPI_GET_CALL_DIAGNOSTICS        0xFE001007
#define OID_CO_TAPI_REPORT_DIGITS               0xFE001008
#define OID_CO_TAPI_DONT_REPORT_DIGITS          0xFE001009

//
//  PnP and PM OIDs
//
#define OID_PNP_CAPABILITIES                    0xFD010100
#define OID_PNP_SET_POWER                       0xFD010101
#define OID_PNP_QUERY_POWER                     0xFD010102
#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
#define OID_PNP_WAKE_UP_PATTERN_LIST            0xFD010105
#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106

//
//  PnP/PM Statistics (Optional).
//
#define OID_PNP_WAKE_UP_OK                      0xFD020200
#define OID_PNP_WAKE_UP_ERROR                   0xFD020201

//
//  The following bits are defined for OID_PNP_ENABLE_WAKE_UP
//
#define NDIS_PNP_WAKE_UP_MAGIC_PACKET           0x00000001
#define NDIS_PNP_WAKE_UP_PATTERN_MATCH          0x00000002
#define NDIS_PNP_WAKE_UP_LINK_CHANGE            0x00000004

//
//  TCP/IP OIDs
//
#define OID_TCP_TASK_OFFLOAD                    0xFC010201
#define OID_TCP_TASK_IPSEC_ADD_SA               0xFC010202
#define OID_TCP_TASK_IPSEC_DELETE_SA            0xFC010203
#define OID_TCP_SAN_SUPPORT                     0xFC010204
#define OID_TCP_TASK_IPSEC_ADD_UDPESP_SA        0xFC010205
#define OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA     0xFC010206
#define OID_TCP4_OFFLOAD_STATS                  0xFC010207
#define OID_TCP6_OFFLOAD_STATS                  0xFC010208
#define OID_IP4_OFFLOAD_STATS                   0xFC010209
#define OID_IP6_OFFLOAD_STATS                   0xFC01020A
//
// new offload OIDs for NDIS 6
//
#define OID_TCP_OFFLOAD_CURRENT_CONFIG          0xFC01020B          // query only, handled by NDIS
#define OID_TCP_OFFLOAD_PARAMETERS              0xFC01020C          // set only
#define OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES   0xFC01020D          // query only
#define OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG 0xFC01020E        // query only
#define OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES 0xFC01020F // query only
#define OID_OFFLOAD_ENCAPSULATION               0x0101010A

#if (NDIS_SUPPORT_NDIS61)
//
// IPsec Task offload V2 OIDs
//
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_ADD_SA    0xFC030202
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_DELETE_SA 0xFC030203
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_UPDATE_SA 0xFC030204
#endif // (NDIS_SUPPORT_NDIS61)

//
//  Defines for FFP, obsolete
//
#define OID_FFP_SUPPORT                         0xFC010210
#define OID_FFP_FLUSH                           0xFC010211
#define OID_FFP_CONTROL                         0xFC010212
#define OID_FFP_PARAMS                          0xFC010213
#define OID_FFP_DATA                            0xFC010214

#define OID_FFP_DRIVER_STATS                    0xFC020210
#define OID_FFP_ADAPTER_STATS                   0xFC020211


//
// TCP Connection offload OID
//
#define OID_TCP_CONNECTION_OFFLOAD_PARAMETERS   0xFC030201

#ifdef UNDER_CE
//
//  backward compatibility
//

//
//  Defines for QOS
//
#define OID_QOS_TC_SUPPORTED                    0xFB010100
#define OID_QOS_REMAINING_BANDWIDTH             0xFB010101
#define OID_QOS_ISSLOW_FLOW                     0xFB010102
#define OID_QOS_BESTEFFORT_BANDWIDTH            0xFB010103
#define OID_QOS_LATENCY                         0xFB010104
#define OID_QOS_FLOW_IP_CONFORMING              0xFB010105
#define OID_QOS_FLOW_COUNT                      0xFB010106
#define OID_QOS_NON_BESTEFFORT_LIMIT            0xFB010107
#define OID_QOS_SCHEDULING_PROFILES_SUPPORTED   0xFB010108
#define OID_QOS_CURRENT_SCHEDULING_PROFILE      0xFB010109
#define OID_QOS_TIMER_RESOLUTION                0xFB01010A
#define OID_QOS_STATISTICS_BUFFER               0xFB01010B
#define OID_QOS_HIERARCHY_CLASS                 0xFB01010C
#define OID_QOS_FLOW_MODE                       0xFB01010D
#define OID_QOS_ISSLOW_FRAGMENT_SIZE            0xFB01010E
#define OID_QOS_FLOW_IP_NONCONFORMING           0xFB01010F
#define OID_QOS_FLOW_8021P_CONFORMING           0xFB010110
#define OID_QOS_FLOW_8021P_NONCONFORMING        0xFB010111
#define OID_QOS_ENABLE_AVG_STATS                0xFB010112
#define OID_QOS_ENABLE_WINDOW_ADJUSTMENT        0xFB010113
#endif  //  UNDER_CE

//
//  Defines for QOS
//
#define OID_QOS_RESERVED1                       0xFB010100
#define OID_QOS_RESERVED2                       0xFB010101
#define OID_QOS_RESERVED3                       0xFB010102
#define OID_QOS_RESERVED4                       0xFB010103
#define OID_QOS_RESERVED5                       0xFB010104
#define OID_QOS_RESERVED6                       0xFB010105
#define OID_QOS_RESERVED7                       0xFB010106
#define OID_QOS_RESERVED8                       0xFB010107
#define OID_QOS_RESERVED9                       0xFB010108
#define OID_QOS_RESERVED10                      0xFB010109
#define OID_QOS_RESERVED11                      0xFB01010A
#define OID_QOS_RESERVED12                      0xFB01010B
#define OID_QOS_RESERVED13                      0xFB01010C
#define OID_QOS_RESERVED14                      0xFB01010D
#define OID_QOS_RESERVED15                      0xFB01010E
#define OID_QOS_RESERVED16                      0xFB01010F
#define OID_QOS_RESERVED17                      0xFB010110
#define OID_QOS_RESERVED18                      0xFB010111
#define OID_QOS_RESERVED19                      0xFB010112
#define OID_QOS_RESERVED20                      0xFB010113


//
// NDIS Proxy OID_GEN_CO_DEVICE_PROFILE structure. The optional OID and
// this structure is a generic means of describing a CO device's
// capabilites, and is used by the NDIS Proxy to construct a TAPI device
// capabilities structure.
//
typedef struct NDIS_CO_DEVICE_PROFILE
{
    NDIS_VAR_DATA_DESC  DeviceDescription;  // e.g. 'GigabitATMNet'
    NDIS_VAR_DATA_DESC  DevSpecificInfo;    // special features

    ULONG   ulTAPISupplementaryPassThru;// reserved in NT5
    ULONG   ulAddressModes;
    ULONG   ulNumAddresses;
    ULONG   ulBearerModes;
    ULONG   ulMaxTxRate; // bytes per second
    ULONG   ulMinTxRate; // bytes per second
    ULONG   ulMaxRxRate; // bytes per second
    ULONG   ulMinRxRate; // bytes per second
    ULONG   ulMediaModes;

    //
    // Tone/digit generation and recognition capabilities
    //
    ULONG   ulGenerateToneModes;
    ULONG   ulGenerateToneMaxNumFreq;
    ULONG   ulGenerateDigitModes;
    ULONG   ulMonitorToneMaxNumFreq;
    ULONG   ulMonitorToneMaxNumEntries;
    ULONG   ulMonitorDigitModes;
    ULONG   ulGatherDigitsMinTimeout;// milliseconds
    ULONG   ulGatherDigitsMaxTimeout;// milliseconds

    ULONG   ulDevCapFlags;          // Misc. capabilities
    ULONG   ulMaxNumActiveCalls;    // (This * ulMinRate) = total bandwidth (which may equal ulMaxRate)
    ULONG   ulAnswerMode;           // Effect of answering a new call when an
                                    // existing call is non-idle
    //
    // User-User info sizes allowed to accompany each operation
    //
    ULONG   ulUUIAcceptSize;    // bytes
    ULONG   ulUUIAnswerSize;    // bytes
    ULONG   ulUUIMakeCallSize;  // bytes
    ULONG   ulUUIDropSize;      // bytes
    ULONG   ulUUISendUserUserInfoSize; // bytes
    ULONG   ulUUICallInfoSize;  // bytes

} NDIS_CO_DEVICE_PROFILE, *PNDIS_CO_DEVICE_PROFILE;

//
//  Structures for TCP IPsec.
//
#ifndef IP_EXPORT_INCLUDED
typedef ULONG   IPAddr, IPMask;
#endif
typedef ULONG   SPI_TYPE;

typedef enum    _OFFLOAD_OPERATION_E
{
    AUTHENTICATE = 1,
    ENCRYPT
}
    OFFLOAD_OPERATION_E;

typedef struct _OFFLOAD_ALGO_INFO
{
    ULONG   algoIdentifier;
    ULONG   algoKeylen;
    ULONG   algoRounds;
}
    OFFLOAD_ALGO_INFO,
    *POFFLOAD_ALGO_INFO;

typedef enum _OFFLOAD_CONF_ALGO
{
    OFFLOAD_IPSEC_CONF_NONE,
    OFFLOAD_IPSEC_CONF_DES,
    OFFLOAD_IPSEC_CONF_RESERVED,
    OFFLOAD_IPSEC_CONF_3_DES,
    OFFLOAD_IPSEC_CONF_MAX
}
    OFFLOAD_CONF_ALGO;

typedef enum _OFFLOAD_INTEGRITY_ALGO
{
    OFFLOAD_IPSEC_INTEGRITY_NONE,
    OFFLOAD_IPSEC_INTEGRITY_MD5,
    OFFLOAD_IPSEC_INTEGRITY_SHA,
    OFFLOAD_IPSEC_INTEGRITY_MAX
}
    OFFLOAD_INTEGRITY_ALGO;

typedef struct _OFFLOAD_SECURITY_ASSOCIATION
{
    OFFLOAD_OPERATION_E     Operation;
    SPI_TYPE                SPI;
    OFFLOAD_ALGO_INFO       IntegrityAlgo;
    OFFLOAD_ALGO_INFO       ConfAlgo;
    OFFLOAD_ALGO_INFO       Reserved;
}
    OFFLOAD_SECURITY_ASSOCIATION,
    *POFFLOAD_SECURITY_ASSOCIATION;

#define OFFLOAD_MAX_SAS             3

#define OFFLOAD_INBOUND_SA          0x0001
#define OFFLOAD_OUTBOUND_SA         0x0002

typedef struct _OFFLOAD_IPSEC_ADD_SA
{
    IPAddr                          SrcAddr;
    IPMask                          SrcMask;
    IPAddr                          DestAddr;
    IPMask                          DestMask;
    ULONG                           Protocol;
    USHORT                          SrcPort;
    USHORT                          DestPort;
    IPAddr                          SrcTunnelAddr;
    IPAddr                          DestTunnelAddr;
    USHORT                          Flags;
    SHORT                           NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION    SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                          OffloadHandle;
    ULONG                           KeyLen;
    UCHAR                           KeyMat[1];
} OFFLOAD_IPSEC_ADD_SA, *POFFLOAD_IPSEC_ADD_SA;

typedef struct _OFFLOAD_IPSEC_DELETE_SA
{
    HANDLE                          OffloadHandle;
} OFFLOAD_IPSEC_DELETE_SA, *POFFLOAD_IPSEC_DELETE_SA;


typedef enum _UDP_ENCAP_TYPE
{
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE,
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER
} UDP_ENCAP_TYPE, * PUDP_ENCAP_TYPE;


typedef struct _OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY
{
    UDP_ENCAP_TYPE                  UdpEncapType;
    USHORT                          DstEncapPort;
} OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY, * POFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY;


typedef struct _OFFLOAD_IPSEC_ADD_UDPESP_SA
{
    IPAddr                                  SrcAddr;
    IPMask                                  SrcMask;
    IPAddr                                  DstAddr;
    IPMask                                  DstMask;
    ULONG                                   Protocol;
    USHORT                                  SrcPort;
    USHORT                                  DstPort;
    IPAddr                                  SrcTunnelAddr;
    IPAddr                                  DstTunnelAddr;
    USHORT                                  Flags;
    SHORT                                   NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION            SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                                  OffloadHandle;
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY    EncapTypeEntry;
    HANDLE                                  EncapTypeEntryOffldHandle;
    ULONG                                   KeyLen;
    UCHAR                                   KeyMat[1];
} OFFLOAD_IPSEC_ADD_UDPESP_SA, * POFFLOAD_IPSEC_ADD_UDPESP_SA;


typedef struct _OFFLOAD_IPSEC_DELETE_UDPESP_SA
{
    HANDLE                                  OffloadHandle;
    HANDLE                                  EncapTypeEntryOffldHandle;
} OFFLOAD_IPSEC_DELETE_UDPESP_SA, * POFFLOAD_IPSEC_DELETE_UDPESP_SA;


//
// Type to go with OID_GEN_VLAN_ID: the least significant 12 bits are
// used as the VLAN ID (VID) per IEEE 802.1Q. Higher order bits are
// reserved and must be set to 0.
//
typedef ULONG NDIS_VLAN_ID;

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
typedef enum _NDIS_MEDIUM
{
    NdisMedium802_3,
    NdisMedium802_5,
    NdisMediumFddi,
    NdisMediumWan,
    NdisMediumLocalTalk,
    NdisMediumDix,              // defined for convenience, not a real medium
    NdisMediumArcnetRaw,
    NdisMediumArcnet878_2,
    NdisMediumAtm,
    NdisMediumWirelessWan,
    NdisMediumIrda,
    NdisMediumBpc,
    NdisMediumCoWan,
    NdisMedium1394,
    NdisMediumInfiniBand,
// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
    NdisMediumTunnel,
    NdisMediumNative802_11,
#if ( NDIS_SUPPORT_NDIS6 )  //  #ifdef UNDER_CE
    NdisMediumLoopback,
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
    NdisMediumMax               // Not a real medium, defined as an upper-bound
} NDIS_MEDIUM, *PNDIS_MEDIUM;

#ifdef UNDER_CE
//
//  For backwards compatibility.
//
#define NdisMedium802_11    NdisMediumNative802_11
#endif  //  UNDER_CE

//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
typedef enum _NDIS_PHYSICAL_MEDIUM
{
    NdisPhysicalMediumUnspecified,
    NdisPhysicalMediumWirelessLan,
    NdisPhysicalMediumCableModem,
    NdisPhysicalMediumPhoneLine,
    NdisPhysicalMediumPowerLine,
    NdisPhysicalMediumDSL,      // includes ADSL and UADSL (G.Lite)
    NdisPhysicalMediumFibreChannel,
    NdisPhysicalMedium1394,
    NdisPhysicalMediumWirelessWan,
    NdisPhysicalMediumNative802_11,
    NdisPhysicalMediumBluetooth,
#ifdef UNDER_CE
    NdisPhysicalMediumRAS,      // Indicates an underlying RAS connection presented as a virtual 802.3 adapter
#endif  //  UNDER_CE
#if ( NDIS_SUPPORT_NDIS6 )  //  #ifdef UNDER_CE
    NdisPhysicalMediumInfiniband,
    NdisPhysicalMediumWiMax,
    NdisPhysicalMediumUWB,
    NdisPhysicalMedium802_3,
    NdisPhysicalMedium802_5,
    NdisPhysicalMediumIrda,
    NdisPhysicalMediumWiredWAN,
    NdisPhysicalMediumWiredCoWan,
    NdisPhysicalMediumOther,
#endif  //  #endif  //  UNDER_CE
    NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
} NDIS_PHYSICAL_MEDIUM, *PNDIS_PHYSICAL_MEDIUM;

#ifdef UNDER_CE
//
//  For backwards compatibility.
//
#define NdisPhysicalMediumNativeWifi    NdisPhysicalMediumNative802_11
#endif  //  UNDER_CE

//
//  Protocol types supported by ndis. These values need to be consistent with ADDRESS_TYPE_XXX defined in TDI.H
//
#define NDIS_PROTOCOL_ID_DEFAULT        0x00
#define NDIS_PROTOCOL_ID_TCP_IP         0x02
#define NDIS_PROTOCOL_ID_IPX            0x06
#define NDIS_PROTOCOL_ID_NBF            0x07
#define NDIS_PROTOCOL_ID_MAX            0x0F
#define NDIS_PROTOCOL_ID_MASK           0x0F

//
// The following is used with OID_GEN_TRANSPORT_HEADER_OFFSET to indicate the length of the layer-2 header
// for packets sent by a particular protocol.
//
typedef struct _TRANSPORT_HEADER_OFFSET
{
    USHORT      ProtocolType;       // The protocol that is sending this OID (NDIS_PROTOCOL_ID_XXX above)
    USHORT      HeaderOffset;       // The header offset
} TRANSPORT_HEADER_OFFSET, *PTRANSPORT_HEADER_OFFSET;


//
// The structures below need to be consistent with TRANSPORT_ADDRESS structures in TDI.H
//
typedef struct _NETWORK_ADDRESS
{
    USHORT      AddressLength;      // length in bytes of Address[] in this
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    UCHAR       Address[1];         // actually AddressLength bytes long
} NETWORK_ADDRESS, *PNETWORK_ADDRESS;

//
// The following is used with OID_GEN_NETWORK_LAYER_ADDRESSES to set network layer addresses on an interface
//
typedef struct _NETWORK_ADDRESS_LIST
{
    LONG        AddressCount;       // number of addresses following
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    NETWORK_ADDRESS Address[1];     // actually AddressCount elements long
} NETWORK_ADDRESS_LIST, *PNETWORK_ADDRESS_LIST;

//
// IP address - This must remain consistent with TDI_ADDRESS_IP in tdi.h
//
typedef struct _NETWORK_ADDRESS_IP
{
    USHORT      sin_port;
    ULONG       in_addr;
    UCHAR       sin_zero[8];
} NETWORK_ADDRESS_IP, *PNETWORK_ADDRESS_IP;

#define NETWORK_ADDRESS_LENGTH_IP sizeof (NETWORK_ADDRESS_IP)

//
// IPX address - This must remain consistent with TDI_ADDRESS_IPX in tdi.h.
//
typedef struct _NETWORK_ADDRESS_IPX
{
    ULONG       NetworkAddress;
    UCHAR       NodeAddress[6];
    USHORT      Socket;
} NETWORK_ADDRESS_IPX, *PNETWORK_ADDRESS_IPX;

#define NETWORK_ADDRESS_LENGTH_IPX sizeof (NETWORK_ADDRESS_IPX)

//
// Hardware status codes (OID_GEN_HARDWARE_STATUS).
//

typedef enum _NDIS_HARDWARE_STATUS
{
    NdisHardwareStatusReady,
    NdisHardwareStatusInitializing,
    NdisHardwareStatusReset,
    NdisHardwareStatusClosing,
    NdisHardwareStatusNotReady
} NDIS_HARDWARE_STATUS, *PNDIS_HARDWARE_STATUS;


//
// this is the type passed in the OID_GEN_GET_TIME_CAPS request
//
typedef struct _GEN_GET_TIME_CAPS
{
    ULONG                       Flags;  // Bits defined below
    ULONG                       ClockPrecision;
} GEN_GET_TIME_CAPS, *PGEN_GET_TIME_CAPS;

#define READABLE_LOCAL_CLOCK                    0x00000001
#define CLOCK_NETWORK_DERIVED                   0x00000002
#define CLOCK_PRECISION                         0x00000004
#define RECEIVE_TIME_INDICATION_CAPABLE         0x00000008
#define TIMED_SEND_CAPABLE                      0x00000010
#define TIME_STAMP_CAPABLE                      0x00000020

//
// this is the type passed in the OID_GEN_GET_NETCARD_TIME request
//
typedef struct _GEN_GET_NETCARD_TIME
{
    ULONGLONG                   ReadTime;
} GEN_GET_NETCARD_TIME, *PGEN_GET_NETCARD_TIME;

//
//  NDIS PnP routines and definitions.
//
typedef struct _NDIS_PM_PACKET_PATTERN
{
    ULONG   Priority;                   // Importance of the given pattern.
    ULONG   Reserved;                   // Context information for transports.
    ULONG   MaskSize;                   // Size in bytes of the pattern mask.
    ULONG   PatternOffset;              // Offset from beginning of this
                                        // structure to the pattern bytes.
    ULONG   PatternSize;                // Size in bytes of the pattern.
    ULONG   PatternFlags;               // Flags (TBD).
} NDIS_PM_PACKET_PATTERN, *PNDIS_PM_PACKET_PATTERN;


//
//  The following structure defines the device power states.
//
typedef enum _NDIS_DEVICE_POWER_STATE
{
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0,
    NdisDeviceStateD1,
    NdisDeviceStateD2,
    NdisDeviceStateD3,
    NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;

//
//  The following structure defines the wake-up capabilities of the device.
//
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;

//
// the following flags define the -enabled- wake-up capabilities of the device
// passed in the Flags field of NDIS_PNP_CAPABILITIES structure
//
#define NDIS_DEVICE_WAKE_UP_ENABLE                          0x00000001
#define NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE            0x00000002
#define NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE             0x00000004

//
//  This structure defines general PnP capabilities of the miniport driver.
//
typedef struct _NDIS_PNP_CAPABILITIES
{
    ULONG                           Flags;
    NDIS_PM_WAKE_UP_CAPABILITIES    WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

//
// Defines the attachment types for FDDI (OID_FDDI_ATTACHMENT_TYPE).
//
typedef enum _NDIS_FDDI_ATTACHMENT_TYPE
{
    NdisFddiTypeIsolated = 1,
    NdisFddiTypeLocalA,
    NdisFddiTypeLocalB,
    NdisFddiTypeLocalAB,
    NdisFddiTypeLocalS,
    NdisFddiTypeWrapA,
    NdisFddiTypeWrapB,
    NdisFddiTypeWrapAB,
    NdisFddiTypeWrapS,
    NdisFddiTypeCWrapA,
    NdisFddiTypeCWrapB,
    NdisFddiTypeCWrapS,
    NdisFddiTypeThrough
} NDIS_FDDI_ATTACHMENT_TYPE, *PNDIS_FDDI_ATTACHMENT_TYPE;


//
// Defines the ring management states for FDDI (OID_FDDI_RING_MGT_STATE).
//
typedef enum _NDIS_FDDI_RING_MGT_STATE
{
    NdisFddiRingIsolated = 1,
    NdisFddiRingNonOperational,
    NdisFddiRingOperational,
    NdisFddiRingDetect,
    NdisFddiRingNonOperationalDup,
    NdisFddiRingOperationalDup,
    NdisFddiRingDirected,
    NdisFddiRingTrace
} NDIS_FDDI_RING_MGT_STATE, *PNDIS_FDDI_RING_MGT_STATE;


//
// Defines the Lconnection state for FDDI (OID_FDDI_LCONNECTION_STATE).
//
typedef enum _NDIS_FDDI_LCONNECTION_STATE
{
    NdisFddiStateOff = 1,
    NdisFddiStateBreak,
    NdisFddiStateTrace,
    NdisFddiStateConnect,
    NdisFddiStateNext,
    NdisFddiStateSignal,
    NdisFddiStateJoin,
    NdisFddiStateVerify,
    NdisFddiStateActive,
    NdisFddiStateMaintenance
} NDIS_FDDI_LCONNECTION_STATE, *PNDIS_FDDI_LCONNECTION_STATE;


//
// Defines the medium subtypes for WAN medium (OID_WAN_MEDIUM_SUBTYPE).
// Sub-medium used only by connection-oriented WAN devices
// i.e. NdisMediumWan, NdisMediumCoWan.
//
typedef enum _NDIS_WAN_MEDIUM_SUBTYPE
{
    NdisWanMediumHub,
    NdisWanMediumX_25,
    NdisWanMediumIsdn,
    NdisWanMediumSerial,
    NdisWanMediumFrameRelay,
    NdisWanMediumAtm,
    NdisWanMediumSonet,
    NdisWanMediumSW56K,
    NdisWanMediumPPTP,
    NdisWanMediumL2TP,
    NdisWanMediumIrda,
    NdisWanMediumParallel,
    NdisWanMediumPppoe
#if (NTDDI_VERSION >= NTDDI_VISTA)    
    ,
    NdisWanMediumSSTP
#endif //(NTDDI_VERSION >= NTDDI_VISTA)    
} NDIS_WAN_MEDIUM_SUBTYPE, *PNDIS_WAN_MEDIUM_SUBTYPE;


//
// Defines the header format for WAN medium (OID_WAN_HEADER_FORMAT).
//
typedef enum _NDIS_WAN_HEADER_FORMAT
{
    NdisWanHeaderNative,        // src/dest based on subtype, followed by NLPID
    NdisWanHeaderEthernet       // emulation of ethernet header
} NDIS_WAN_HEADER_FORMAT, *PNDIS_WAN_HEADER_FORMAT;


//
// Defines the line quality on a WAN line (OID_WAN_QUALITY_OF_SERVICE).
//
typedef enum _NDIS_WAN_QUALITY
{
    NdisWanRaw,
    NdisWanErrorControl,
    NdisWanReliable
} NDIS_WAN_QUALITY, *PNDIS_WAN_QUALITY;


//
// Defines a protocol's WAN specific capabilities (OID_WAN_PROTOCOL_CAPS).
//
typedef struct _NDIS_WAN_PROTOCOL_CAPS
{
    IN  ULONG   Flags;
    IN  ULONG   Reserved;
} NDIS_WAN_PROTOCOL_CAPS, *PNDIS_WAN_PROTOCOL_CAPS;


//
// Flags used in NDIS_WAN_PROTOCOL_CAPS
//
#define WAN_PROTOCOL_KEEPS_STATS    0x00000001


//
// Defines the state of a token-ring adapter (OID_802_5_CURRENT_RING_STATE).
//
typedef enum _NDIS_802_5_RING_STATE
{
    NdisRingStateOpened = 1,
    NdisRingStateClosed,
    NdisRingStateOpening,
    NdisRingStateClosing,
    NdisRingStateOpenFailure,
    NdisRingStateRingFailure
} NDIS_802_5_RING_STATE, *PNDIS_802_5_RING_STATE;

//
// Defines the state of the LAN media
//
typedef enum _NDIS_MEDIA_STATE
{
    NdisMediaStateConnected,
    NdisMediaStateDisconnected
} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;

//
// The following is set on a per-packet basis as OOB data with NdisClass802_3Priority
//
typedef ULONG   Priority_802_3;         // 0-7 priority levels

//
//  The following structure is used to query OID_GEN_CO_LINK_SPEED and
//  OID_GEN_CO_MINIMUM_LINK_SPEED. The first OID will return the current
//  link speed of the adapter. The second will return the minimum link speed
//  the adapter is capable of.
//
typedef struct _NDIS_CO_LINK_SPEED
{
    ULONG   Outbound;
    ULONG   Inbound;
} NDIS_CO_LINK_SPEED, *PNDIS_CO_LINK_SPEED;

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE

//
// The following structure is used in OID_GEN_LINK_SPEED_EX for interfaces
// and is expressed in bits per second.
//
typedef struct _NDIS_LINK_SPEED
{
    ULONG64     XmitLinkSpeed;
    ULONG64     RcvLinkSpeed;
} NDIS_LINK_SPEED, *PNDIS_LINK_SPEED;



// miniports or interfaces that do not know their current link speed
// can report NDIS_LINK_SPEED_UNKNOWN == ((ULONG64)-1)
#define NDIS_LINK_SPEED_UNKNOWN NET_IF_LINK_SPEED_UNKNOWN
// #endif  //  #endif  //  UNDER_CE

#ifndef _NDIS_
typedef int NDIS_STATUS, *PNDIS_STATUS;
#endif

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE
// Native 802.11 Definitions
#ifndef __WINDOT11_H__
#include <windot11.h>
#endif
// #endif // (NTDDI_VERSION >= NTDDI_VISTA)  //  #endif  //  UNDER_CE


//
//  Structure to be used for OID_GEN_SUPPORTED_GUIDS.
//  This structure describes an OID to GUID mapping.
//  Or a Status to GUID mapping.
//  When ndis receives a request for a give GUID it will
//  query the miniport with the supplied OID.
//
typedef struct _NDIS_GUID
{
    GUID            Guid;
    union
    {
        NDIS_OID    Oid;
        NDIS_STATUS Status;
    };
    ULONG       Size;               //  Size of the data element. If the GUID
                                    //  represents an array then this is the
                                    //  size of an element in the array.
                                    //  This is -1 for strings.
    ULONG       Flags;
} NDIS_GUID, *PNDIS_GUID;

#define fNDIS_GUID_TO_OID                   0x00000001
#define fNDIS_GUID_TO_STATUS                0x00000002
#define fNDIS_GUID_ANSI_STRING              0x00000004
#define fNDIS_GUID_UNICODE_STRING           0x00000008
#define fNDIS_GUID_ARRAY                    0x00000010
#ifndef UNDER_CE
#define fNDIS_GUID_ALLOW_READ               0x00000020
#define fNDIS_GUID_ALLOW_WRITE              0x00000040
#endif  //  UNDER_CE
#define fNDIS_GUID_METHOD                   0x00000080
#define fNDIS_GUID_NDIS_RESERVED            0x00000100 
#define fNDIS_GUID_SUPPORT_COMMON_HEADER    0x00000200

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING         0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                    0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL         0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000
#define NDIS_PACKET_TYPE_NO_LOCAL               0x00010000


//
// Ndis Token-Ring Ring Status Codes (OID_802_5_CURRENT_RING_STATUS).
//
#define NDIS_RING_SIGNAL_LOSS                   0x00008000
#define NDIS_RING_HARD_ERROR                    0x00004000
#define NDIS_RING_SOFT_ERROR                    0x00002000
#define NDIS_RING_TRANSMIT_BEACON               0x00001000
#define NDIS_RING_LOBE_WIRE_FAULT               0x00000800
#define NDIS_RING_AUTO_REMOVAL_ERROR            0x00000400
#define NDIS_RING_REMOVE_RECEIVED               0x00000200
#define NDIS_RING_COUNTER_OVERFLOW              0x00000100
#define NDIS_RING_SINGLE_STATION                0x00000080
#define NDIS_RING_RING_RECOVERY                 0x00000040


//
// Ndis protocol option bits (OID_GEN_PROTOCOL_OPTIONS).
//
#define NDIS_PROT_OPTION_ESTIMATED_LENGTH               0x00000001
#define NDIS_PROT_OPTION_NO_LOOPBACK                    0x00000002
#define NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT              0x00000004
#define NDIS_PROT_OPTION_SEND_RESTRICTED                0x00000008

//
// Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
//
#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA             0x00000001
#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED              0x00000002
#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND              0x00000004
#define NDIS_MAC_OPTION_NO_LOOPBACK                     0x00000008

//
// This flag has been deprecated. Deserialized drivers are
// full duplex drivers
//
#define NDIS_MAC_OPTION_FULL_DUPLEX                     0x00000010  // deprecated


#define NDIS_MAC_OPTION_EOTX_INDICATION                 0x00000020
#define NDIS_MAC_OPTION_8021P_PRIORITY                  0x00000040
#define NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE  0x00000080
#define NDIS_MAC_OPTION_RECEIVE_AT_DPC                  0x00000100
#define NDIS_MAC_OPTION_8021Q_VLAN                      0x00000200
#define NDIS_MAC_OPTION_RESERVED                        0x80000000

//
//  NDIS media capabilities bits (OID_GEN_MEDIA_CAPABILITIES).
//
#define NDIS_MEDIA_CAP_TRANSMIT                 0x00000001  // Supports sending data
#define NDIS_MEDIA_CAP_RECEIVE                  0x00000002  // Supports receiving data

//
//  NDIS MAC option bits for OID_GEN_CO_MAC_OPTIONS.
//
#define NDIS_CO_MAC_OPTION_DYNAMIC_LINK_SPEED   0x00000001

//
// The following is set on a per-packet basis as OOB data with NdisClassIrdaPacketInfo
// This is the per-packet info specified on a per-packet basis
//
typedef struct _NDIS_IRDA_PACKET_INFO
{
    ULONG                       ExtraBOFs;
    ULONG                       MinTurnAroundTime;
} NDIS_IRDA_PACKET_INFO, *PNDIS_IRDA_PACKET_INFO;

#ifdef UNDER_CE
//
//  backward compatibility
//

#ifdef WIRELESS_WAN

//
// Wireless WAN structure definitions
//
//
// currently defined Wireless network subtypes
//
typedef enum _NDIS_WW_NETWORK_TYPE
{
    NdisWWGeneric,
    NdisWWMobitex,
    NdisWWPinpoint,
    NdisWWCDPD,
    NdisWWArdis,
    NdisWWDataTAC,
    NdisWWMetricom,
    NdisWWGSM,
    NdisWWCDMA,
    NdisWWTDMA,
    NdisWWAMPS,
    NdisWWInmarsat,
    NdisWWpACT,
    NdisWWFlex,
    NdisWWIDEN
} NDIS_WW_NETWORK_TYPE;

//
// currently defined header formats
//
typedef enum _NDIS_WW_HEADER_FORMAT
{
    NdisWWDIXEthernetFrames,
    NdisWWMPAKFrames,
    NdisWWRDLAPFrames,
    NdisWWMDC4800Frames,
    NdisWWNCLFrames
} NDIS_WW_HEADER_FORMAT;

//
// currently defined encryption types
//
typedef enum _NDIS_WW_ENCRYPTION_TYPE
{
    NdisWWUnknownEncryption = -1,
    NdisWWNoEncryption,
    NdisWWDefaultEncryption,
    NdisWWDESEncryption,
    NdisWWRC2Encryption,
    NdisWWRC4Encryption,
    NdisWWRC5Encryption
} NDIS_WW_ENCRYPTION_TYPE, *PNDIS_WW_ENCRYPTION_TYPE;

typedef enum _WW_ADDRESS_FORMAT
{
    WW_IEEE_ADDRESS = 0,
    WW_MOBITEX_MAN_ADDRESS,
    WW_DATATAC_RDLAP_ADDRESS,
    WW_DATATAC_MDC4800_ADDRESS,
    WW_DATATAC_RESERVED,
    WW_IPv4_ADDRESS,
    WW_IPv6_ADDRESS,
    WW_PROPRIETARY_ADDRESS,
} WW_ADDRESS_FORMAT;

typedef enum _WW_GEN_SUM_EXCEPTION
{
    SIM_STATUS_OK = 0,
    SIM_STATUS_ERROR,
    SIM_STATUS_MISSING,
    SIM_STATUS_NO_RESPONSE,
    SIM_STATUS_REMOVED,
    SIM_STATUS_CRYPT_ERROR,
    SIM_STATUS_AUTH_ERROR,
    SIM_STATUS_NEED_PIN,
    SIM_STATUS_NEED_PUK,
    SIM_STATUS_WRONG,
} WW_GEN_SIM_EXCEPTION;


//
// OID_WW_GEN_INDICATION_REQUEST
//
typedef struct _NDIS_WW_INDICATION_REQUEST
{
    NDIS_OID            Oid;                    // IN
    ULONG               uIndicationFlag;        // IN
    ULONG               uApplicationToken;      // IN OUT
    HANDLE              hIndicationHandle;      // IN OUT
    INT                 iPollingInterval;       // IN OUT
    NDIS_VAR_DATA_DESC  InitialValue;           // IN OUT
    NDIS_VAR_DATA_DESC  OIDIndicationValue;     // OUT - only valid after indication
    NDIS_VAR_DATA_DESC  TriggerValue;           // IN
} NDIS_WW_INDICATION_REQUEST, *PNDIS_WW_INDICATION_REQUEST;

#define OID_INDICATION_REQUEST_ENABLE           0x0000
#define OID_INDICATION_REQUEST_CANCEL           0x0001

//
// OID_WW_GEN_DEVICE_INFO
//
typedef struct _WW_DEVICE_INFO
{
    NDIS_VAR_DATA_DESC  Manufacturer;
    NDIS_VAR_DATA_DESC  ModelNum;
    NDIS_VAR_DATA_DESC  SWVersionNum;
    NDIS_VAR_DATA_DESC  SerialNum;
} WW_DEVICE_INFO, *PWW_DEVICE_INFO;

//
// OID_WW_GEN_OPERATION_MODE
//
typedef INT WW_OPERATION_MODE;                  //  0 = Normal mode
                                                //  1 = Power saving mode
                                                // -1 = mode unknown

//
// OID_WW_GEN_LOCK_STATUS
//
typedef INT WW_LOCK_STATUS;                     //  0 = unlocked
                                                //  1 = locked
                                                // -1 = unknown lock status

//
// OID_WW_GEN_DISABLE_TRANSMITTER
//
typedef INT WW_DISABLE_TRANSMITTER;             //  0 = transmitter enabled
                                                //  1 = transmitter disabled
                                                // -1 = unknown value

//
// OID_WW_GEN_NETWORK_ID
//
typedef NDIS_VAR_DATA_DESC  WW_NETWORK_ID;

//
// OID_WW_GEN_PERMANENT_ADDRESS 
//
typedef NDIS_VAR_DATA_DESC  WW_PERMANENT_ADDRESS;

//
// OID_WW_GEN_CURRENT_ADDRESS   
//
typedef struct _WW_CURRENT_ADDRESS
{
    NDIS_WW_HEADER_FORMAT   Format;
    NDIS_VAR_DATA_DESC      Address;
} WW_CURRENT_ADDRESS, *PWW_CURRENT_ADDRESS;

//
// OID_WW_GEN_SUSPEND_DRIVER
//
typedef BOOLEAN WW_SUSPEND_DRIVER;              // 0 = driver operational
                                                // 1 = driver suspended
//
// OID_WW_GEN_BASESTATION_ID
//
typedef NDIS_VAR_DATA_DESC  WW_BASESTATION_ID;

//
// OID_WW_GEN_CHANNEL_ID
//
typedef NDIS_VAR_DATA_DESC  WW_CHANNEL_ID;

//
// OID_WW_GEN_ENCRYPTION_STATE
//
typedef BOOLEAN WW_ENCRYPTION_STATE;            // 0 = if encryption is disabled
                                                // 1 = if encryption is enabled

//
// OID_WW_GEN_CHANNEL_QUALITY
//
typedef INT     WW_CHANNEL_QUALITY;             //  0 = Not in network contact,
                                                // 1-100 = Quality of Channel (100 is highest quality).
                                                // -1 = channel quality is unknown

//
// OID_WW_GEN_REGISTRATION_STATUS
//
typedef INT     WW_REGISTRATION_STATUS;         //  0 = Registration denied
                                                //  1 = Registration pending
                                                //  2 = Registered
                                                // -1 = unknown registration status

//
// OID_WW_GEN_RADIO_LINK_SPEED
//
typedef ULONG   WW_RADIO_LINK_SPEED;            // Bits per second.

//
// OID_WW_GEN_LATENCY
//
typedef ULONG   WW_LATENCY;                     //  milliseconds

//
// OID_WW_GEN_BATTERY_LEVEL
//
typedef INT     WW_BATTERY_LEVEL;               //  0-100 = battery level in percentage
                                                //  (100=fully charged)
                                                // -1 = unknown battery level.

//
// OID_WW_GEN_EXTERNAL_POWER
//
typedef INT     WW_EXTERNAL_POWER;              //  0 = no external power connected
                                                //  1 = external power connected
                                                //  -1 = unknown

//
// Ping Address structure
//
typedef struct _WW_PING_ADDRESS
{
    WW_ADDRESS_FORMAT   Format;                 // IN
    NDIS_VAR_DATA_DESC  TargetAddress;          // IN
    UINT                uTime;                  // OUT in milleseconds
} WW_PING_ADDRESS;


//
// RSSI structure
//
typedef struct _WW_RECEIVE_SIGNAL_STRENGTH_INDICATOR
{
    INT                 iDecibels;              // value in DB
    INT                 iFactor;                // power of 10
} WW_RECEIVE_SIGNAL_STRENGTH_INDICATOR;


//
// SIM status structure
//
typedef struct _WW_SIM_STATUS
{
    BOOLEAN             bHasSIM;                // TRUE = SIM required
    BOOLEAN             bBlocked;               // TRUE = SIM PIN access blocked
    BOOLEAN             bLocked;                // TRUE = PIN need to access device
    BOOLEAN             bInitialized;           // TRUE = SIM initialized
    UINT                uCountdown;             // = remaining number of attempt to
                                                // enter correct PIN
} WW_SIM_STATUS;

//
// enable SIM PIN structure
//
typedef struct _WW_ENABLE_SIM_PIN
{
    BOOLEAN             bEnabled;               // TRUE = security feature of SIM enabled
    NDIS_VAR_DATA_DESC  CurrentPIN;             // describes buffer containing PIN value
} WW_ENABLE_SIM_PIN;

//
// SIM PIN structure
//
typedef struct _WW_CHANGE_SIM_PIN
{
    NDIS_VAR_DATA_DESC  OldPIN;                 // describes buffer containing OLD PIN
    NDIS_VAR_DATA_DESC  NewPIN;                 // describes buffer containing new PIN
} WW_CHANGE_SIM_PIN;


//
// new change SIM PUK structure
//
typedef NDIS_VAR_DATA_DESC      WW_ENABLE_SIM_PUK;


//
// OID_WW_MET_FUNCTION
//
typedef NDIS_VAR_DATA_DESC      WW_MET_FUNCTION;

//
// OID_WW_TAC_COMPRESSION
//
typedef BOOLEAN WW_TAC_COMPRESSION;             // Determines whether or not network level compression
                                                // is being used.

//
// OID_WW_TAC_SET_CONFIG
//
// The DataTAC OID that referenced this object has been superceeded. The
// definition is still included for historical purposes only and should not
// be used
//
typedef struct _WW_TAC_SETCONFIG
{
    NDIS_VAR_DATA_DESC  RCV_MODE;               // Select confirmed/unconfirmed
                                                // receive mode
    NDIS_VAR_DATA_DESC  TX_CONTROL;             // Enable or Disable transmitter
    NDIS_VAR_DATA_DESC  RX_CONTROL;             // Enable or disable radio in
                                                // the modem
    NDIS_VAR_DATA_DESC  FLOW_CONTROL;           // Set flow control between DTE
                                                // and DCE
    NDIS_VAR_DATA_DESC  RESET_CNF;              // Reset configuration to
                                                // default
    NDIS_VAR_DATA_DESC  READ_CNF;               // Read the current
                                                // configuration
} WW_TAC_SETCONFIG, *PWW_TAC_SETCONFIG;

//
// OID_WW_TAC_GET_STATUS
//
// The DataTAC OID that referenced this object has been superceeded. The
// definition is still included for historical purposes only and should not
// be used
//
typedef struct _WW_TAC_GETSTATUS
{
    BOOLEAN                 Action;             // Set = Execute command.
    NDIS_VAR_DATA_DESC      Command;
    NDIS_VAR_DATA_DESC      Option;
    NDIS_VAR_DATA_DESC      Response;           // The response to the requested command
                                                // - max. length of string is 256 octets.
} WW_TAC_GETSTATUS, *PWW_TAC_GETSTATUS;

//
// OID_WW_TAC_USER_HEADER
//
typedef NDIS_VAR_DATA_DESC  WW_TAC_USERHEADER;  // This will hold the user header - Max. 64 octets.

// August 25, 1998 @14:16 EDT by Emil Sturniolo - WRQ
// added new DataTAC get response structure
typedef  struct _WW_TAC_GET_RESPONSE
{
    UINT                SDUTag;                 // previousl assigned token
    NDIS_VAR_DATA_DESC  Response;               // response - max 2048 octets
} WW_TAC_GET_RESPONSE;

//
// DataTAC disable receiver structure
//
typedef INT WW_TAC_DISABLE_RECEIVER;            // 0 = receiver enabled
                                                // 1 = receiver disabled
                                                // -1 = state of recevier unknown

//
// DataTAC antenna mode structure
//
typedef INT WW_TAC_ANTENNA_MODE;                // 0 = Automatic Antenna selection
                                                // 1 = Always use primary antenna
                                                // 2 = Always use secondary antenna
                                                // -1 = Antenna algorithm unknown

//
// DataTAC get response structure
//
typedef INT WW_TAC_FLUSH_DATA;                  // 1 = flush buffered data destine to net
                                                // 2 = flush buffered data received from net
                                                // 3 = flush all buffered data

//
// DataTAC shutdown device structure
//
typedef INT WW_TAC_SHUTDOWN_DEVICE;             // 0 = device enabled
                                                // 1 = device disabled
                                                // -1 = state of device unknown

//
// DataTAC transmitter keyed structure
//
typedef BOOLEAN WW_TAC_TRANSMITTER_KEYED;

//
// added new DataTAC system table structure
//
typedef struct _WW_TAC_SYSTEM_TABLE
{
    UINT        SystemCount;
    UCHAR       ContryTable[32];
    UCHAR       PrefixTable[32];
    UCHAR       IDTable[32];
} WW_TAC_SYSTEM_TABLE;

//
// added new DataTAC channel table structure
//
typedef struct _WW_TAC_CHANNEL_TABLE
{
    UINT        ChannelCount;
    UCHAR       ChannelTable[64];
    UCHAR       AttrTable[64];
} WW_TAC_CHANNEL_TABLE;


//
// added new DataTAC statistics structure
//
typedef NDIS_VAR_DATA_DESC WW_TAC_STATISTICS;



//
// OID_WW_ARD_SNDCP
//
// The ARDIS OIDs that referenced these object have been deprecated and merged
// with the new DataTAC objects. Their definition are still included for
// historical purposes only and should not be used.
//
typedef struct _WW_ARD_SNDCP
{
    NDIS_VAR_DATA_DESC  Version;                // The version of SNDCP protocol supported.
    INT                 BlockSize;              // The block size used for SNDCP
    INT                 Window;                 // The window size used in SNDCP
} WW_ARD_SNDCP, *PWW_ARD_SNDCP;

//
// OID_WW_ARD_TMLY_MSG
//
typedef BOOLEAN WW_ARD_CHANNEL_STATUS;          // The current status of the inbound RF Channel.

//
// OID_WW_ARD_DATAGRAM
//
typedef struct _WW_ARD_DATAGRAM
{
    BOOLEAN             LoadLevel;              // Byte that contains the load level info.
    INT                 SessionTime;            // Datagram session time remaining.
    NDIS_VAR_DATA_DESC  HostAddr;               // Host address.
    NDIS_VAR_DATA_DESC  THostAddr;              // Test host address.
} WW_ARD_DATAGRAM, *PWW_ARD_DATAGRAM;

//
// OID_WW_CDPD_SPNI
//
typedef struct _WW_CDPD_SPNI
{
    ULONG   SPNI[10];                           //10 16-bit service provider network IDs
    INT     OperatingMode;                      // 0 = ignore SPNI,
                                                // 1 = require SPNI from list,
                                                // 2 = prefer SPNI from list.
                                                // 3 = exclude SPNI from list.
} WW_CDPD_SPNI, *PWW_CDPD_SPNI;

//
// OID_WW_CDPD_WASI
//
typedef struct _WW_CDPD_WIDE_AREA_SERVICE_ID
{
    ULONG   WASI[10];                           //10 16-bit wide area service IDs
    INT     OperatingMode;                      // 0 = ignore WASI,
                                                // 1 = Require WASI from list,
                                                // 2 = prefer WASI from list
                                                // 3 = exclude WASI from list.
} WW_CDPD_WIDE_AREA_SERVICE_ID, *PWW_CDPD_WIDE_AREA_SERVICE_ID;

//
// OID_WW_CDPD_AREA_COLOR
//
typedef INT     WW_CDPD_AREA_COLOR;

//
// OID_WW_CDPD_TX_POWER_LEVEL
//
typedef ULONG   WW_CDPD_TX_POWER_LEVEL;

//
// OID_WW_CDPD_EID
//
typedef NDIS_VAR_DATA_DESC  WW_CDPD_EID;
//
// OID_WW_CDPD_HEADER_COMPRESSION
//
typedef INT WW_CDPD_HEADER_COMPRESSION;         //  0 = no header compression,
                                                //  1 = always compress headers,
                                                //  2 = compress headers if MD-IS does
                                                // -1 = unknown

//
// OID_WW_CDPD_DATA_COMPRESSION
//
typedef INT WW_CDPD_DATA_COMPRESSION;           // 0  = no data compression,
                                                // 1  = data compression enabled
                                                // -1 = unknown

//
// OID_WW_CDPD_CHANNEL_SELECT
//
typedef struct _WW_CDPD_CHANNEL_SELECT
{
    ULONG   ChannelID;                          // channel number
    ULONG   fixedDuration;                      // duration in seconds
} WW_CDPD_CHANNEL_SELECT, *PWW_CDPD_CHANNEL_SELECT;

//
// OID_WW_CDPD_CHANNEL_STATE
//
typedef enum _WW_CDPD_CHANNEL_STATE
{
    CDPDChannelNotAvail,
    CDPDChannelScanning,
    CDPDChannelInitAcquired,
    CDPDChannelAcquired,
    CDPDChannelSleeping,
    CDPDChannelWaking,
    CDPDChannelCSDialing,
    CDPDChannelCSRedial,
    CDPDChannelCSAnswering,
    CDPDChannelCSConnected,
    CDPDChannelCSSuspended
} WW_CDPD_CHANNEL_STATE, *PWW_CDPD_CHANNEL_STATE;

//
// OID_WW_CDPD_NEI
//
typedef enum _WW_CDPD_NEI_FORMAT
{
    CDPDNeiIPv4,
    CDPDNeiCLNP,
    CDPDNeiIPv6
} WW_CDPD_NEI_FORMAT, *PWW_CDPD_NEI_FORMAT;

typedef enum _WW_CDPD_NEI_TYPE
{
    CDPDNeiIndividual,
    CDPDNeiMulticast,
    CDPDNeiBroadcast
} WW_CDPD_NEI_TYPE;


typedef struct _WW_CDPD_NEI
{
    ULONG               uNeiIndex;
    WW_CDPD_NEI_FORMAT  NeiFormat;
    WW_CDPD_NEI_TYPE    NeiType;
    WORD                NeiGmid;                // group member identifier, only
                                                // meaningful if NeiType ==
                                                // CDPDNeiMulticast
    NDIS_VAR_DATA_DESC  NeiAddress;
} WW_CDPD_NEI;

//
// OID_WW_CDPD_NEI_STATE
//

typedef enum _WW_CDPD_NEI_STATE
{
    CDPDUnknown,
    CDPDRegistered,
    CDPDDeregistered
} WW_CDPD_NEI_STATE, *PWW_CDPD_NEI_STATE;

typedef enum _WW_CDPD_NEI_SUB_STATE
{
    CDPDPending,                                // Registration pending
    CDPDNoReason,                               // Registration denied - no reason given
    CDPDMDISNotCapable,                         // Registration denied - MD-IS not capable of
                                                //  handling M-ES at this time
    CDPDNEINotAuthorized,                       // Registration denied - NEI is not authorized to
                                                //  use this subnetwork
    CDPDInsufficientAuth,                       // Registration denied - M-ES gave insufficient
                                                //  authentication credentials
    CDPDUnsupportedAuth,                        // Registration denied - M-ES gave unsupported
                                                //  authentication credentials
    CDPDUsageExceeded,                          // Registration denied - NEI has exceeded usage
                                                //  limitations
    CDPDDeniedThisNetwork                       // Registration denied on this network, service
                                                //  may be obtained on alternate Service Provider
                                                //  network
} WW_CDPD_NEI_SUB_STATE;

typedef struct _WW_CDPD_NEI_REG_STATE
{
    ULONG               uNeiIndex;
    WW_CDPD_NEI_STATE   NeiState;
    WW_CDPD_NEI_SUB_STATE NeiSubState;
} WW_CDPD_NEI_REG_STATE, *PWW_CDPD_NEI_REG_STATE;

//
// OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER
//
typedef struct _WW_CDPD_SERVICE_PROVIDER_ID
{
    ULONG   SPI[10];                            //10 16-bit service provider IDs
    INT     OperatingMode;                      // 0 = ignore SPI,
                                                // 1 = require SPI from list,
                                                // 2 = prefer SPI from list.
                                                // 3 = SPI from list is excluded
} WW_CDPD_SERVICE_PROVIDER_ID, *PWW_CDPD_SERVICE_PROVIDER_ID;

//
// OID_WW_CDPD_SLEEP_MODE
//
typedef INT WW_CDPD_SLEEP_MODE;

//
// OID_WW_CDPD_TEI
//
typedef ULONG   WW_CDPD_TEI;

//
// OID_WW_CDPD_CIRCUIT_SWITCHED
//
// The CDPD OID that referenced this object has been deprecated and superceeded
// by new discrete CDPD objects. The definition is still included for
// historical purposes only and should not be used.
//
typedef struct _WW_CDPD_CIRCUIT_SWITCHED
{
    INT                 service_preference;  // -1 = unknown,
                                                //  0 = always use packet switched CDPD,
                                                //  1 = always use CS CDPD via AMPS,
                                                //  2 = always use CS CDPD via PSTN,
                                                //  3 = use circuit switched via AMPS only
                                                //  when packet switched is not available.
                                                //  4 = use packet switched only when circuit
                                                //  switched via AMPS is not available.
                                                //  5 = device manuf. defined service
                                                //  preference.
                                                //  6 = device manuf. defined service
                                                //  preference.
    
    INT                 service_status;         // -1 = unknown,
                                                //  0 = packet switched CDPD,
                                                //  1 = circuit switched CDPD via AMPS,
                                                //  2 = circuit switched CDPD via PSTN.
    
    INT                 connect_rate;           //  CS connection bit rate (bits per second).
                                                //  0 = no active connection,
                                                // -1 = unknown

                                                //  Dial code last used to dial.
    NDIS_VAR_DATA_DESC  dial_code[20];
    
    ULONG               sid;                    //  Current AMPS system ID
    
    INT                 a_b_side_selection;     // -1 = unknown,
                                                //  0 = no AMPS service
                                                //  1 = AMPS "A" side channels selected
                                                //  2 = AMPS "B" side channels selected
    
    INT                 AMPS_channel;           // -1= unknown
                                                //  0 = no AMPS service.
                                                //  1-1023 = AMPS channel number in use
    
    ULONG               action;                 //  0 = no action
                                                //  1 = suspend (hangup)
                                                //  2 = dial
    
                                                //  Default dial code for CS CDPD service
                                                //  encoded as specified in the CS CDPD
                                                //  implementor guidelines.
    NDIS_VAR_DATA_DESC  default_dial[20];
    
                                                //  Number for the CS CDPD network to call
                                                //  back the mobile, encoded as specified in
                                                //  the CS CDPD implementor guidelines.
    NDIS_VAR_DATA_DESC  call_back[20];
    
    ULONG               sid_list[10];           //  List of 10 16-bit preferred AMPS
                                                //  system IDs for CS CDPD.
    
    ULONG               inactivity_timer;       //  Wait time after last data before dropping
                                                //  call.
                                                //  0-65535 = inactivity time limit (seconds).
    
    ULONG               receive_timer;          //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               conn_resp_timer;        //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               reconn_resp_timer;      //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               disconn_timer;          //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               NEI_reg_timer;          //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               reconn_retry_timer;     //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               link_reset_timer;       //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               link_reset_ack_timer;   //  secs. per CS-CDPD Implementor Guidelines.
    
    ULONG               n401_retry_limit;       //  per CS-CDPD Implementor Guidelines.
    
    ULONG               n402_retry_limit;       //  per CS-CDPD Implementor Guidelines.
    
    ULONG               n404_retry_limit;       //  per CS-CDPD Implementor Guidelines.
    
    ULONG               n405_retry_limit;       //  per CS-CDPD Implementor Guidelines.
} WW_CDPD_CIRCUIT_SWITCHED, *WW_PCDPD_CIRCUIT_SWITCHED;

typedef ULONG   WW_CDPD_RSSI;

//
// cs-cdpd service preference structure
//
typedef INT WW_CDPD_CS_SERVICE_PREFERENCE;      // 0 = use packet switched CDPD only
                                                // 1 = use CS-CDPD via AMPS only
                                                // 2 = use CS-CDPD via PSTN only
                                                // 3 = use CS-CDPD via AMPS only
                                                //     when packet switched is N/A
                                                // 4 = use packet switched CDPD only
                                                //     when  CS-CDPD via AMPS is N/A
                                                // 5 = Device manufacture defined
                                                //     service preference
                                                // 6 = device manufacture defined
                                                //     service preference
                                                // -1 = unknown

//
// cs-cdpd service status structure
//
typedef INT WW_CDPD_CS_SERVICE_STATUS;          // 0 = Packet switched CDPD
                                                // 1 = CS-CDPD via AMPS
                                                // 2 = CS-CDPD via PSTN
                                                // -1 = unknown



//
// cs-cdpd info structure
//
typedef struct _WW_CDPD_CS_INFO {
    INT                 ConnectRage;            // 0 = no active connection
                                                // -1 = unknown
                                                // all other values represent BPS
    NDIS_VAR_DATA_DESC  DialCode;               // describes buffer of last dial code
    UINT                SID;                    // Current AMPS System ID
    INT                 ABSideSelection;        // 0 = no AMPS service
                                                // 1 = AMPS "A" side channel selected
                                                // 2 = AMPS "B" side channel selected
    INT                 AMPSChannel;            // 0 = no AMPS service
                                                // 1-1023 = current AMPS channel
                                                // -1 = Unknown
                                                // all other values reserved
} WW_CDPD_CS_INFO;



//
// cs-cdpd suspend structure
//
typedef UINT WW_CDPD_CS_SUSPEND;                // 0 = nop; 1 = hang up


//
// cs-cdpd default dial code structure
//
typedef NDIS_VAR_DATA_DESC WW_CDPD_DEFAULT_DIAL_CODE;   // max 20 octets

//
// cs-cdpd callback structure
//
typedef struct _WW_CDPD_CS_CALLBACK
{
    UINT                Enabled;                // 0 = disable; 1 = enable; -1 = unknown
    NDIS_VAR_DATA_DESC  Number;                 // descibes buffer contianing dial code
                                                // max 20 octets
} WW_CDPD_CS_CALLBACK;


//
// cs-cdpd system id list structure
//
typedef struct _WW_CDPD_CS_SID_LIST
{
    UINT    AMPSystemId[10];
} WW_CDPD_CS_SID_LIST;

//
// cs-cdpd configuration structure
//
typedef struct _WW_CDPD_CS_CONFIGURATION
{
    UINT    InactivityTimer;                    // in seconds
    UINT    ReceiveTimer;                       // in seconds
    UINT    ConnResTimer;                       // in seconds
    UINT    ReconnRespTimer;                    // in seconds
    UINT    DisconnTimer;                       // in seconds
    UINT    NEIRegTimer;                        // in seconds
    UINT    ReconnRetryTimer;                   // in seconds
    UINT    LinkResetTimer;                     // in seconds
    UINT    LinkResetAckTimer;                  // in seconds
    UINT    n401RetryLimit;                     // per CS-CDPD Implementers guidelines
    UINT    n402RetryLimit;                     // per CS-CDPD Implementers guidelines
    UINT    n404RetryLimit;                     // per CS-CDPD Implementers guidelines
    UINT    n405RetryLimit;                     // per CS-CDPD Implementers guidelines
} WW_CDPD_CS_CONFIGURATION;


//
// OID_WW_PIN_LOC_AUTHORIZE
//
// The Pin Point OIDs that referenced the structures below have been
// deprecated from the PCCA STD-201 standard. Their definitions are still
// included for historical purposes only and should not be used.
//
typedef INT WW_PIN_AUTHORIZED;                  // 0  = unauthorized
                                                // 1  = authorized
                                                // -1 = unknown

//
// OID_WW_PIN_LAST_LOCATION
// OID_WW_PIN_LOC_FIX
//
typedef struct _WW_PIN_LOCATION
{
    INT     Latitude;                           // Latitude in hundredths of a second
    INT     Longitude;                          // Longitude in hundredths of a second
    INT     Altitude;                           // Altitude in feet
    INT     FixTime;                            // Time of the location fix, since midnight,  local time (of the
                                                // current day), in tenths of a second
    INT     NetTime;                            // Current local network time of the current day, since midnight,
                                                // in tenths of a second
    INT     LocQuality;                         // 0-100 = location quality
    INT     LatReg;                             // Latitude registration offset, in hundredths of a second
    INT     LongReg;                            // Longitude registration offset, in hundredths of a second
    INT     GMTOffset;                          // Offset in minutes of the local time zone from GMT
} WW_PIN_LOCATION, *PWW_PIN_LOCATION;


//
// The following is set on a per-packet basis as OOB data with NdisClassWirelessWanMbxMailbox
//
typedef ULONG   WW_MBX_MAILBOX_FLAG;            // 1 = set mailbox flag, 0 = do not set mailbox flag

//
// OID_WW_MBX_SUBADDR
//
typedef struct _WW_MBX_PMAN
{
    BOOLEAN             ACTION;                 // 0 = Login PMAN,  1 = Logout PMAN
    ULONG               MAN;
    UCHAR               PASSWORD[8];            // Password should be null for Logout and indications.
                                                // Maximum length of password is 8 chars.
} WW_MBX_PMAN, *PWW_MBX_PMAN;

//
// OID_WW_MBX_FLEXLIST
//
typedef struct  _WW_MBX_FLEXLIST
{
    INT     count;                              //  Number of MAN entries used.
                                                // -1=unknown.
    ULONG   MAN[7];                             //  List of MANs.
} WW_MBX_FLEXLIST;

//
// OID_WW_MBX_GROUPLIST
//
typedef struct  _WW_MBX_GROUPLIST
{
    INT  count;                                 //  Number of MAN entries used.
                                                // -1=unknown.
    ULONG   MAN[15];                            //  List of MANs.
} WW_MBX_GROUPLIST;

//
// OID_WW_MBX_TRAFFIC_AREA
//
typedef enum    _WW_MBX_TRAFFIC_AREA
{
    unknown_traffic_area,                       // The driver has no information about the current traffic area.
    in_traffic_area,                            // Mobile unit has entered a subscribed traffic area.
    in_auth_traffic_area,                       // Mobile unit is outside traffic area but is authorized.
    unauth_traffic_area                         // Mobile unit is outside traffic area but is un-authorized.
} WW_MBX_TRAFFIC_AREA;

//
// OID_WW_MBX_LIVE_DIE
//
typedef INT WW_MBX_LIVE_DIE;                    //  0 = DIE last received   
                                                //  1 = LIVE last received
                                                // -1 = unknown

//
// OID_WW_MBX_TEMP_DEFAULTLIST
//
typedef struct _WW_MBX_CHANNEL_PAIR
{
    ULONG               Mobile_Tx;
    ULONG               Mobile_Rx;
} WW_MBX_CHANNEL_PAIR, *PWW_MBX_CHANNEL_PAIR;

typedef struct _WW_MBX_TEMPDEFAULTLIST
{
    ULONG               Length;
    WW_MBX_CHANNEL_PAIR ChannelPair[1];
} WW_MBX_TEMPDEFAULTLIST, *WW_PMBX_TEMPDEFAULTLIST;

#endif // WIRELESS_WAN

//
//
// Base types that were redefined for BPC
//
// BPC_FILETIME is used exactly like FILETIME in Win32
//
// BPC_HANDLE is opaque to everything except the Miniport
//              
typedef struct _BPC_FILETIME
{
    ULONG   dwLowDateTime;
    ULONG   dwHighDateTime;
} BPC_FILETIME, *PBPC_FILETIME;

typedef PVOID   BPC_HANDLE;

//
// BPC Extension Globals
//
//
#define BPC_MIN_DIMENSION       1
#define BPC_MAX_BUFFER_SIZE     64
#define BPC_MIN_BUFFER_SIZE     4
#define BPC_DEVICE_ANY          ((BPC_HANDLE) 0xFFFFFFFF)

//
// Buffer indicate reason codes
//
//
typedef enum _NDIS_BPC_INDICATE_REASON
{
    bpcBufferFull = 0,
    bpcBufferForced,
    bpcBufferTimeOut,
    bpcBufferDiscontinuity,
    bpcBufferOverflow,
    bpcBufferStatusEvent

} NDIS_BPC_INDICATE_REASON, *PNDIS_BPC_INDICATE_REASON;


//
// BPC Stream Types
//
#define BPC_STREAM_TYPE_GENERIC_MIN     0x01000000
#define BPC_STREAM_TYPE_RAW             0x01000000
#define BPC_STREAM_TYPE_MPT_128         0x01000001
#define BPC_STREAM_TYPE_MPT_128_CRC     0x01000002
#define BPC_STREAM_TYPE_IP              0x01000003
#define BPC_STREAM_TYPE_PROVIDER_MIN    0x02000000
#define BPC_STREAM_TYPE_PROVIDER_MAX    0x02ffffff
#define BPC_STREAM_TYPE_ADAPTER_MIN     0x03000000
#define BPC_STREAM_TYPE_ADAPTER_MAX     0x03ffffff


//
// BPC Adapter Capabilities
//
typedef struct _NDIS_BPC_ADAPTER_CAPS
{
    ULONG   ulBPCMajorRev;
    ULONG   ulBPCMinorRev;
    ULONG   ulcHSDataDevices;
    ULONG   ulbpsHSDeviceMax;
    ULONG   ulcLSDataDevices;
    ULONG   ulbpsLSDeviceMax;
    ULONG   ulcTuningDevices;
    ULONG   ulcbLargestStatus;
    ULONG   ulVendorId;
    ULONG   ulAdapterId;
    GUID    guidProvider;

} NDIS_BPC_ADAPTER_CAPS, *PNDIS_BPC_ADAPTER_CAPS;


//
//  BPC Device Enumeration
//
typedef struct _NDIS_BPC_DEVICES
{
    ULONG       ulcDevices;
    BPC_HANDLE  rgnhDevices[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICES, *PNDIS_BPC_DEVICES;

#define CbDevices(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICES, rgnhDevices) + (cnt) * sizeof(BPC_HANDLE))


//
// BPC Device Capabilities Structure
//
typedef struct NDIS_BPC_DEVICE_CAPS
{
    BPC_HANDLE  nhDevice;
    ULONG       ulBPCCaps;
    ULONG       ulbpsMax;
    ULONG       ulcStreamTypes;
    ULONG       rgulStreamTypes[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICE_CAPS, *PNDIS_BPC_DEVICE_CAPS;

#define CbDeviceCaps(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICE_CAPS, rgulStreamTypes) + (cnt) * sizeof(ULONG))


//
// BPC Device Capability Definitions
// (ie Flags that can be set in ulBPCCaps
//
#define BPCCapBusMasteredData   0x01
#define BPCCapIndependentTuner  0x02
#define BPCCapExternalDataBus   0x04
#define BPCCapLowSpeedData      0x10
#define BPCCapHighSpeedData     0x20


//
// BPC Device Settings Structure
//
typedef struct NDIS_BPC_DEVICE_SETTINGS
{
    BPC_HANDLE  nhDevice;
    ULONG       ulBPCCaps;
    ULONG       ulcConnections;
    BOOLEAN     fEnabled;
    ULONG       ulStreamType;
    ULONG       ulcbAddressConnection;
    ULONG       rgulAddressConnection[BPC_MIN_DIMENSION];

} NDIS_BPC_DEVICE_SETTINGS, *PNDIS_BPC_DEVICE_SETTINGS;

#define CbDeviceSettings(cnt) (FIELD_OFFSET(NDIS_BPC_DEVICE_SETTINGS, rgulAddressConnection) + (cnt) * sizeof(ULONG))


//
// BPC Connection State Definitions
// (ie Acceptable values for ulState)
//
#define BPC_CONNECT_STATE_UNCOMMITTED   0
#define BPC_CONNECT_STATE_QUEUED        1
#define BPC_CONNECT_STATE_ACTIVE        2
#define BPC_CONNECT_STATE_DISCONNECTING 3


//
// BPC Connections Status Structure
//
typedef struct NDIS_BPC_CONNECTION_STATUS
{
    BPC_HANDLE  nhConnection;
    BPC_HANDLE  nhDevice;
    ULONG       ulConnectPriority;
    ULONG       ulDisconnectPriority;
    ULONG       ulbpsAverage;
    ULONG       ulbpsBurst;
    ULONG       ulState;
    BOOLEAN     fEnabled;

} NDIS_BPC_CONNECTION_STATUS, *PNDIS_BPC_CONNECTION_STATUS;


//
// BPC Address Comparison Structure
//
typedef struct NDIS_BPC_ADDRESS_COMPARE
{
    BOOLEAN fEqual;
    ULONG   ulcbFirstOffset;
    ULONG   ulcbFirstLength;
    ULONG   ulcbSecondOffset;
    ULONG   ulcbSecondLength;

} NDIS_BPC_ADDRESS_COMPARE, *PNDIS_BPC_ADDRESS_COMPARE;


//
// BPC Program Guide Types
//
// Currently there are no Generic BPC Program Guide types.
//
#define BPC_GUIDE_GENERIC_MIN   0x01000000
#define BPC_GUIDE_GENERIC_MAX   0x01ffffff
#define BPC_GUIDE_PROVIDER_MIN  0x02000000
#define BPC_GUIDE_PROVIDER_MAX  0x02ffffff
#define BPC_GUIDE_ADAPTER_MIN   0x03000000
#define BPC_GUIDE_ADAPTER_MAX   0x03ffffff


//
// BPC Program Guide Structure
//
typedef struct NDIS_BPC_PROGRAM_GUIDE
{
    ULONG       ulGuideType;
    BPC_FILETIME ftLastUpdate;
    ULONG       ulChangeNumber;
    ULONG       ulcbGuideSize;
    ULONG       rgulGuideData[BPC_MIN_DIMENSION];

} NDIS_BPC_PROGRAM_GUIDE, *PNDIS_BPC_PROGRAM_GUIDE;


//
// BPC Extension Errors
// (ie Acceptable values for ulBPCError)
//
typedef enum _NDIS_BPC_ERROR
{
    bpcErrorUnknownFailure = 0xc0ff0000,
    bpcErrorHardwareFailure,
    bpcErrorProviderFailure,
    bpcErrorNoDataDevice,
    bpcErrorNoTuningDevice,
    bpcErrorDeviceNotCapable,
    bpcErrorConflictingDevice,
    bpcErrorConflictingCapability,
    bpcErrorNoBufferMemory,
    bpcErrorNoResources,
    bpcErrorAdapterClosing,
    bpcErrorConnectionClosing,
    bpcErrorTooComplex,
    bpcErrorProviderNotSupported,
    bpcErrorUnknownProviderStructure,
    bpcErrorAddressNotSupported,
    bpcErrorInvalidAddress,
    bpcErrorUnknownAdapterStructure
} NDIS_BPC_ERROR, *PNDIS_BPC_ERROR;


//
//  BPC Last Error Structure
//
typedef struct NDIS_BPC_LAST_ERROR
{
    ULONG       ulErrorContext;
    ULONG       ulBPCError;
    ULONG       ulAdapterError;
    ULONG       ulAdapterContext;

} NDIS_BPC_LAST_ERROR, *PNDIS_BPC_LAST_ERROR;


//
//  BPC Buffer Pool Request/Report Structure
//
typedef struct NDIS_BPC_POOL
{
    BPC_HANDLE  nhConnection;
    ULONG       ulcbPoolSize;
    ULONG       ulcbMaxBufferSize;
    ULONG       ulcbBufferReserved;

} NDIS_BPC_POOL, *PNDIS_BPC_POOL;


//
// BPC Provider and Adapter Specific Structures are defined in the
// BpcXXXX.H file which the Provider/Adapter Manufacturer supplies.
//

//
// BPC Connect Structure
//
typedef struct NDIS_BPC_CONNECT
{
    BPC_HANDLE  nhConnection;
    BPC_HANDLE  nhDevice;
    ULONG       ulConnectPriority;
    ULONG       ulDisconnectPriority;
    BOOLEAN     fImmediate;
    ULONG       ulcbAddress;
    GUID        guidProvider;
    ULONG       rgulAddress[BPC_MIN_DIMENSION];

} NDIS_BPC_CONNECT, *PNDIS_BPC_CONNECT;

#define CbConnect(cnt)  (FIELD_OFFSET(NDIS_BPC_CONNECT, rgulAddress) + (cnt) * sizeof(ULONG))


//
//  BPC Commit Connections Structure
//
typedef struct NDIS_BPC_COMMIT
{
    ULONG       ulcConnections;
    BPC_HANDLE  rgnhConnections[BPC_MIN_DIMENSION];

} NDIS_BPC_COMMIT, *PNDIS_BPC_COMMIT;


//
//  BPC Disconnect Structure
//
typedef struct NDIS_BPC_DISCONNECT
{
    BPC_HANDLE  nhConnection;

} NDIS_BPC_DISCONNECT, *PNDIS_BPC_DISCONNECT;


//
//  BPC Enable Connection Structure
//
typedef struct NDIS_BPC_CONNECTION_ENABLE
{
    BPC_HANDLE  nhConnection;
    BOOLEAN     fEnabled;

} NDIS_BPC_CONNECTION_ENABLE, *PNDIS_BPC_CONNECTION_ENABLE;


//
// BPC Pool Return Structure
//
typedef struct NDIS_BPC_POOL_RETURN
{
    BPC_HANDLE  nhConnection;

} NDIS_BPC_POOL_RETURN, *PNDIS_BPC_POOL_RETURN;


typedef struct NDIS_BPC_FORCE_RECEIVE
{
    BPC_HANDLE  nhConnection;
    ULONG       ulReasonCode;

} NDIS_BPC_FORCE_RECEIVE, *PNDIS_BPC_FORCE_RECEIVE;


//
//  BPC Media Specific Information Structure
//
typedef struct NDIS_BPC_MEDIA_SPECIFIC_INFORMATION
{
    BPC_HANDLE nhConnection;                    // The handle to the data device.
    ULONG       ulBPCStreamType;                // The stream type of the data in packet
    ULONG       ulReasonCode;                   // The reason the buffer was indicated
    PVOID       pvMiniportReserved1;
    ULONG       ulMiniportReserved2;

} NDIS_BPC_MEDIA_SPECIFIC_INFORMATION, *PNDIS_BPC_MEDIA_SPECIFIC_INFORMATION;


//
// BPC Status Categories
//
#define BPC_CATEGORY_BPC            0x01000000
#define BPC_CATEGORY_PROVIDER       0x02000000
#define BPC_CATEGORY_ADAPTER        0x03000000


//
// BPC Status Types for Category BPC_CATEGORY_BPC
//
#define BPC_STATUS_CONNECTED        0x00000001
#define BPC_STATUS_QUEUED           0x00000002
#define BPC_STATUS_ACTIVE           0x00000003
#define BPC_STATUS_DISCONNECTED     0x00000004
#define BPC_STATUS_OVERFLOW         0x00000005
#define BPC_STATUS_DATA_STOP        0x00000006
#define BPC_STATUS_DATA_START       0x00000007
#define BPC_STATUS_DATA_ERROR       0x00000008


//
// BPC Status Indication Structure
//
typedef struct NDIS_BPC_STATUS
{
    ULONG ulStatusCategory;
    ULONG ulStatusType;
    ULONG ulcbStatus;
    ULONG rgulStatus;
} NDIS_BPC_STATUS, *PNDIS_BPC_STATUS;


//
// BPC Connection Status Structure
//
// All BPC Generic Connection Status package this structure
// in rgulStatus to indicate to which connection and device
// the status pertains.
//
typedef struct NDIS_BPC_STATUS_CONNECTION
{
    BPC_HANDLE  nhConnection;
    BPC_HANDLE nhDevice;

} NDIS_BPC_STATUS_CONNECTED, *PNDIS_BPC_STATUS_CONNECTED;
#endif  //  UNDER_CE

// #if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)  //  #ifndef UNDER_CE

//
// The following macro is used to build a NET_LUID
//

#define NDIS_MAKE_NET_LUID(_pNetLuid, _IfType, _NetLuidIndex)       \
{                                                                   \
    (_pNetLuid)->Info.IfType = _IfType;                             \
    (_pNetLuid)->Info.NetLuidIndex = _NetLuidIndex;                 \
    (_pNetLuid)->Info.Reserved = 0;                                 \
}

#define NDIS_IF_MAX_STRING_SIZE IF_MAX_STRING_SIZE
typedef IF_COUNTED_STRING NDIS_IF_COUNTED_STRING, *PNDIS_IF_COUNTED_STRING;

#define NDIS_MAX_PHYS_ADDRESS_LENGTH IF_MAX_PHYS_ADDRESS_LENGTH
typedef IF_PHYSICAL_ADDRESS NDIS_IF_PHYSICAL_ADDRESS, *PNDIS_IF_PHYSICAL_ADDRESS;

//
// NDIS_MEDIA_CONNECT_STATE enum type is used in OID_GEN_MEDIA_CONNECT_STATUS_EX
//
typedef NET_IF_MEDIA_CONNECT_STATE NDIS_MEDIA_CONNECT_STATE, *PNDIS_MEDIA_CONNECT_STATE;

//
// NET_IF_MEDIA_DUPLEX_STATE enum type is used in OID_GEN_MEDIA_DUPLEX_STATE
//
typedef NET_IF_MEDIA_DUPLEX_STATE NDIS_MEDIA_DUPLEX_STATE, *PNDIS_MEDIA_DUPLEX_STATE;

typedef enum _NDIS_SUPPORTED_PAUSE_FUNCTIONS
{
    NdisPauseFunctionsUnsupported,
    NdisPauseFunctionsSendOnly,
    NdisPauseFunctionsReceiveOnly,
    NdisPauseFunctionsSendAndReceive,
    NdisPauseFunctionsUnknown
} NDIS_SUPPORTED_PAUSE_FUNCTIONS, *PNDIS_SUPPORTED_PAUSE_FUNCTIONS;

#define NDIS_LINK_STATE_XMIT_LINK_SPEED_AUTO_NEGOTIATED         0x00000001
#define NDIS_LINK_STATE_RCV_LINK_SPEED_AUTO_NEGOTIATED          0x00000002
#define NDIS_LINK_STATE_DUPLEX_AUTO_NEGOTIATED                  0x00000004
#define NDIS_LINK_STATE_PAUSE_FUNCTIONS_AUTO_NEGOTIATED         0x00000008

    

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_LINK_STATE_REVISION_1      1

typedef struct _NDIS_LINK_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;
} NDIS_LINK_STATE, *PNDIS_LINK_STATE;

#define NDIS_SIZEOF_LINK_STATE_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_STATE, AutoNegotiationFlags)

//
// the following structure is used in OID_GEN_LINK_PARAMETERS
//

#define NDIS_LINK_PARAMETERS_REVISION_1      1

typedef struct _NDIS_LINK_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;    
} NDIS_LINK_PARAMETERS, *PNDIS_LINK_PARAMETERS;

#define NDIS_SIZEOF_LINK_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_PARAMETERS, AutoNegotiationFlags)

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_OPER_STATE_REVISION_1      1

typedef struct _NDIS_OPER_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NET_IF_OPER_STATUS              OperationalStatus;
    ULONG                           OperationalStatusFlags;
} NDIS_OPER_STATE, *PNDIS_OPER_STATE;

#define NDIS_SIZEOF_OPER_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_OPER_STATE, OperationalStatusFlags)

//
// These defines and structures are used with 
// OID_TCP_OFFLOAD_PARAMETERS
//

#define NDIS_OFFLOAD_PARAMETERS_NO_CHANGE                  0

//
// values used in IPv4Checksum, TCPIPv4Checksum, UDPIPv4Checksum
// TCPIPv6Checksum and UDPIPv6Checksum
//
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_TX_ENABLED_RX_DISABLED     2
#define NDIS_OFFLOAD_PARAMETERS_RX_ENABLED_TX_DISABLED     3
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED              4

//
// values used in LsoV1
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_ENABLED              2

//
// values used in IPsecV1
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_AND_ESP_ENABLED   4

//
// values used in LsoV2
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED              2

#if (NDIS_SUPPORT_NDIS61)
//
// values used in IPsecV2 and IPsecV2IPv4
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_AND_ESP_ENABLED   4
#endif // (NDIS_SUPPORT_NDIS61)

//
// values used in TcpConnectionIPv4 and TcpConnectionIPv6 fields
// of NDIS_OFFLOAD_PARAMETERS
//
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_DISABLED     1
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_ENABLED      2

//
// Used in OID_TCP_OFFLOAD_PARAMETERS for setting 
// the offload parameters of a NIC
//

#define NDIS_OFFLOAD_PARAMETERS_REVISION_1            1
#if defined (NDIS_SUPPORT_NDIS61) || defined (UNDER_CE)
#define NDIS_OFFLOAD_REVISION_2    2
#endif // (NDIS_SUPPORT_NDIS61)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_PARAMETERS_REVISION_2            2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OFFLOAD_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;

    UCHAR                   IPv4Checksum;
    UCHAR                   TCPIPv4Checksum;
    UCHAR                   UDPIPv4Checksum;
    
    UCHAR                   TCPIPv6Checksum;
    UCHAR                   UDPIPv6Checksum;

    UCHAR                   LsoV1;
    UCHAR                   IPsecV1;
    
    UCHAR                   LsoV2IPv4;
    UCHAR                   LsoV2IPv6;

    UCHAR                   TcpConnectionIPv4;
    UCHAR                   TcpConnectionIPv6;
    
    ULONG                   Flags;

#if (NDIS_SUPPORT_NDIS61)
    UCHAR                   IPsecV2;
    UCHAR                   IPsecV2IPv4;
    UCHAR                   Reserved1;
    UCHAR                   Reserved2;
#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_OFFLOAD_PARAMETERS, *PNDIS_OFFLOAD_PARAMETERS;

#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, IPsecV2IPv4)
#endif // (NDIS_SUPPORT_NDIS61)

#define NDIS_OFFLOAD_NOT_SUPPORTED             0
#define NDIS_OFFLOAD_SUPPORTED                 1

#define NDIS_OFFLOAD_SET_NO_CHANGE             0
#define NDIS_OFFLOAD_SET_ON                    1
#define NDIS_OFFLOAD_SET_OFF                   2

//
// Encapsulation types that are used during offload in query and set
//
#define NDIS_ENCAPSULATION_NOT_SUPPORTED                0x00000000                         
#define NDIS_ENCAPSULATION_NULL                         0x00000001
#define NDIS_ENCAPSULATION_IEEE_802_3                   0x00000002
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q           0x00000004
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q_IN_OOB    0x00000008
#define NDIS_ENCAPSULATION_IEEE_LLC_SNAP_ROUTED         0x00000010

#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes the large send offload version 1 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions:2;
        ULONG     IpOptions:2;
    } IPv4;
   
} NDIS_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V1;


//
// Describes the checksum task offload capabilities or configuration 
// of the NIC. used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Receive;

} NDIS_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_TCP_IP_CHECKSUM_OFFLOAD;


//
// Describes the IPsec task offload version 1 capabilities 
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5:2;
        ULONG   Sha_1:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4AH;

    struct
    {
        ULONG   Des:2;
        ULONG   Reserved:2;
        ULONG   TripleDes:2;
        ULONG   NullEsp:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4ESP;

} NDIS_IPSEC_OFFLOAD_V1, *PNDIS_IPSEC_OFFLOAD_V1;

//
// Describes the large send offload version 2 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported:2;
         ULONG     TcpOptionsSupported:2;
    }IPv6;

} NDIS_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V2;

#if defined (NDIS_SUPPORT_NDIS61) || defined (UNDER_CE)
//
//  Structures for IPSec Task Offload V2.
//

//
// IPsec Algorithms for Authentication used in AuthenticationAlgorithms field
// of NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_MD5                      0x00000001
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_1                    0x00000002
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_256                  0x00000004
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_128              0x00000008
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_192              0x00000010
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_256              0x00000020

//
// IPsec Algorithms for Encryption used in EncryptionAlgorithms field of
// NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_ENCRYPTION_NONE                          0x00000001
#define IPSEC_OFFLOAD_V2_ENCRYPTION_DES_CBC                       0x00000002
#define IPSEC_OFFLOAD_V2_ENCRYPTION_3_DES_CBC                     0x00000004
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_128                   0x00000008
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_192                   0x00000010
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_256                   0x00000020
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_128                   0x00000040
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_192                   0x00000080
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_256                   0x00000100

//
// IPsec offload V2 capabilities used in  NDIS_OFFLOAD
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2
{
    ULONG       Encapsulation;      // MAC encap types supported
    BOOLEAN     IPv6Supported;      // IPv6 Supported
    BOOLEAN     IPv4Options;                           // Supports offload of packets with IPv4 options
    BOOLEAN     IPv6NonIPsecExtensionHeaders;          // Supports offload of packets with non IPsec Extension headers
    BOOLEAN     Ah;
    BOOLEAN     Esp;
    BOOLEAN     AhEspCombined;
    BOOLEAN     Transport;
    BOOLEAN     Tunnel;
    BOOLEAN     TransportTunnelCombined;
    BOOLEAN     LsoSupported;
    BOOLEAN     ExtendedSequenceNumbers;
    ULONG       UdpEsp;
    ULONG       AuthenticationAlgorithms;     // Bit Mask of Authentication Algorithms
    ULONG       EncryptionAlgorithms;         // Bit Mask of Encryption Algorithms
    ULONG       SaOffloadCapacity;            // Number of SAs that can be offloaded
} NDIS_IPSEC_OFFLOAD_V2, *PNDIS_IPSEC_OFFLOAD_V2;

#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)

//
// flags used in Flags field of NDIS_OFFLOAD structure
//
#define NDIS_OFFLOAD_FLAGS_GROUP_CHECKSUM_CAPABILITIES  0x00000001

//
// Describes TCP/IP task offload capabilities or configuration 
// of the NIC. Used in OID_TCP_OFFLOAD_CURRENT_CONFIG
// and OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES
//
#define NDIS_OFFLOAD_REVISION_1    1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_REVISION_2    2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OFFLOAD
{
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_TCP_IP_CHECKSUM_OFFLOAD        Checksum;

    //
    // Large Send Offload information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V1      LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_IPSEC_OFFLOAD_V1               IPsecV1;
    //
    // Large Send Offload version 2Information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V2      LsoV2;

    ULONG                               Flags;
#if defined(NDIS_SUPPORT_NDIS61) || defined(UNDER_CE)
    //
    //IPsec offload V2
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)
}NDIS_OFFLOAD, *PNDIS_OFFLOAD;

#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)

//
// The following data structures are used with offload related WMI
// guids. NDIS will trnaslate these data structures to those used 
// in OID and status indications
//
typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions;
        ULONG     IpOptions;
    } IPv4;
   
} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Receive;

} NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD;

typedef struct _NDIS_WMI_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5;
        ULONG   Sha_1;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4AH;

    struct
    {
        ULONG   Des;
        ULONG   Reserved;
        ULONG   TripleDes;
        ULONG   NullEsp;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4ESP;

} NDIS_WMI_IPSEC_OFFLOAD_V1, *PNDIS_WMI_IPSEC_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported;
         ULONG     TcpOptionsSupported;
    }IPv6;

} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2;


typedef struct _NDIS_WMI_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_OFFLOAD;
    // Header.Size = sizeof(NDIS_OFFLOAD);
    // Header.Revision  = NDIS_OFFLOAD_REVISION_1;
    //
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD    Checksum;

    //
    // Large Send Offload information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1   LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_WMI_IPSEC_OFFLOAD_V1           IPsecV1;
    //
    // Large Send Offload version 2 Information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2  LsoV2;

    ULONG                               Flags;

#if (NDIS_SUPPORT_NDIS61)
    //
    // IPsec offload version 2 information
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)
}NDIS_WMI_OFFLOAD, *PNDIS_WMI_OFFLOAD;

#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, Flags) 

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)
#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes TCP connection offload capabilities or configuration  
// of the NIC. Used in OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG,
// OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES and 
// NDIS_STATUS_OFFLOAD_RESUME
//
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1              1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_2              2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4:2;
    ULONG SupportIPv6:2;
    ULONG SupportIPv6ExtensionHeaders:2;
    ULONG SupportSack:2;
#if (NDIS_SUPPORT_NDIS61)
    ULONG CongestionAlgorithm:4;
#endif // (NDIS_SUPPORT_NDIS61)
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_TCP_CONNECTION_OFFLOAD, *PNDIS_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)

typedef struct _NDIS_WMI_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4;
    ULONG SupportIPv6;
    ULONG SupportIPv6ExtensionHeaders;
    ULONG SupportSack;
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_WMI_TCP_CONNECTION_OFFLOAD, *PNDIS_WMI_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_WMI_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_TCP_CONNECTION_OFFLOAD, Flags)

#define NDIS_MAXIMUM_PORTS 0x1000000

//
// definitions for NDIS PORTs
//

typedef ULONG NDIS_PORT_NUMBER, *PNDIS_PORT_NUMBER;

//
// port related data structures
//
#define NDIS_DEFAULT_PORT_NUMBER ((NDIS_PORT_NUMBER)0)
    
//
// NDIS_PORT_TYPE defines the application of a port 
//
typedef enum _NDIS_PORT_TYPE
{
    NdisPortTypeUndefined,
    NdisPortTypeBridge,
    NdisPortTypeRasConnection,
    NdisPortType8021xSupplicant,
    NdisPortTypeMax,
}NDIS_PORT_TYPE, *PNDIS_PORT_TYPE;
    
    
//
// NDIS_PORT_AUTHENTICATION_STATE defines the authentication state of a port
// on a particular data path
//
typedef enum _NDIS_PORT_AUTHORIZATION_STATE
{
    NdisPortAuthorizationUnknown,
    NdisPortAuthorized,
    NdisPortUnauthorized,
    NdisPortReauthorizing
} NDIS_PORT_AUTHORIZATION_STATE, *PNDIS_PORT_AUTHORIZATION_STATE;


//
// NDIS_PORT_CONTROLL_STATE specifies if a port is "controlled" 
// i.e. if it needs authentication, on a particular data path
//

typedef enum _NDIS_PORT_CONTROL_STATE
{
    NdisPortControlStateUnknown,
    NdisPortControlStateControlled,
    NdisPortControlStateUncontrolled
} NDIS_PORT_CONTROLL_STATE, *PNDIS_PORT_CONTROLL_STATE;
    
    
    
//
// NDIS_PORT_STATE is used in port state change status indications
// as well as OID_GEN_PORT_STATE query OID
//

#define NDIS_PORT_STATE_REVISION_1     1
typedef struct _NDIS_PORT_STATE
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
    ULONG                           Flags;
}NDIS_PORT_STATE, *PNDIS_PORT_STATE;

#define NDIS_SIZEOF_PORT_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_STATE, Flags)

//
// NDIS_PORT_PARAMETERS is used in OID_GEN_PORT_PARAMETERS set OID
//
#define NDIS_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     1

typedef struct _NDIS_PORT_AUTHENTICATION_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
}NDIS_PORT_AUTHENTICATION_PARAMETERS, *PNDIS_PORT_AUTHENTICATION_PARAMETERS;

#define NDIS_SIZEOF_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_AUTHENTICATION_PARAMETERS, RcvAuthorizationState)


//
// Flags used in NDIS_PORT_CHARACTERISTICS Flags field.
//
#define  NDIS_PORT_CHAR_USE_DEFAULT_AUTH_SETTINGS             0x00000001

//
// NDIS_PORT_CHARACTERISTICS is used in port allocation and 
// arrival notification as part of NDIS_PORT structure
//
#define NDIS_PORT_CHARACTERISTICS_REVISION_1     1
typedef struct _NDIS_PORT_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_PORT_NUMBER                PortNumber;
    ULONG                           Flags;
    NDIS_PORT_TYPE                  Type;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
} NDIS_PORT_CHARACTERISTICS, *PNDIS_PORT_CHARACTERISTICS;
   
#define NDIS_SIZEOF_PORT_CHARACTERISTICS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_CHARACTERISTICS, RcvAuthorizationState)
    
//
// NDIS_PORT structure is used in port activation 
// PnP notification
//
typedef struct _NDIS_PORT NDIS_PORT, *PNDIS_PORT;

struct _NDIS_PORT
{
    PNDIS_PORT                  Next;
    PVOID                       NdisReserved;
    PVOID                       MiniportReserved;
    PVOID                       ProtocolReserved;
    NDIS_PORT_CHARACTERISTICS   PortCharacteristics;
};


#define NDIS_PORT_ARRAY_REVISION_1                1
//
// NDIS_PORT_ARRAY is used in enumerating the ports
//
typedef struct _NDIS_PORT_ARRAY
{
    NDIS_OBJECT_HEADER              Header;
    ULONG                           NumberOfPorts;
    ULONG                           OffsetFirstPort;
    ULONG                           ElementSize;
    NDIS_PORT_CHARACTERISTICS       Ports[1];
}NDIS_PORT_ARRAY, *PNDIS_PORT_ARRAY;

#define NDIS_SIZEOF_PORT_ARRAY_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_ARRAY, Ports);

typedef enum _NDIS_NETWORK_CHANGE_TYPE
{
    NdisPossibleNetworkChange = 1,
    NdisDefinitelyNetworkChange,
    NdisNetworkChangeFromMediaConnect,
    NdisNetworkChangeMax
} NDIS_NETWORK_CHANGE_TYPE, *PNDIS_NETWORK_CHANGE_TYPE;


#define  NDIS_WMI_DEFAULT_METHOD_ID             1

#define  NDIS_WMI_OBJECT_TYPE_SET               0x01
#define  NDIS_WMI_OBJECT_TYPE_METHOD            0x02
#define  NDIS_WMI_OBJECT_TYPE_EVENT             0x03
#define  NDIS_WMI_OBJECT_TYPE_ENUM_ADAPTER      0x04
#define  NDIS_WMI_OBJECT_TYPE_OUTPUT_INFO       0x05

#define NDIS_WMI_METHOD_HEADER_REVISION_1       1 

typedef struct _NDIS_WMI_METHOD_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_METHOD_HEADER, *PNDIS_WMI_METHOD_HEADER;

#define NDIS_SIZEOF_WMI_METHOD_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_METHOD_HEADER, Padding)
       
#define NDIS_WMI_SET_HEADER_REVISION_1         1

typedef struct _NDIS_WMI_SET_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_SET_HEADER, *PNDIS_WMI_SET_HEADER;

#define NDIS_SIZEOF_WMI_SET_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_SET_HEADER, Padding)

#define NDIS_WMI_EVENT_HEADER_REVISION_1      1

typedef struct _NDIS_WMI_EVENT_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    ULONG64              RequestId;    
    NDIS_PORT_NUMBER     PortNumber;
    ULONG                DeviceNameLength;
    ULONG                DeviceNameOffset;
    UCHAR                Padding[4];
} NDIS_WMI_EVENT_HEADER, *PNDIS_WMI_EVENT_HEADER;

#define NDIS_SIZEOF_WMI_EVENT_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_EVENT_HEADER, Padding)

#define NDIS_WMI_ENUM_ADAPTER_REVISION_1       1

typedef struct _NDIS_WMI_ENUM_ADAPTER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    USHORT               DeviceNameLength;
    CHAR                 DeviceName[1];
}NDIS_WMI_ENUM_ADAPTER, *PNDIS_WMI_ENUM_ADAPTER;

#define NDIS_SIZEOF_WMI_ENUM_ADAPTER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_ENUM_ADAPTER, DeviceName)
        
//
// Flags used in standardized keyword *NdisDeviceType
//
#define NDIS_DEVICE_TYPE_ENDPOINT           0x00000001


#if (NDIS_SUPPORT_NDIS61)

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_PARAMETERS
//
#define NDIS_HD_SPLIT_PARAMETERS_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_PARAMETERS
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_PARAMETERS_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_PARAMETERS);
    // 
    NDIS_OBJECT_HEADER      Header;
    ULONG                   HDSplitCombineFlags;
}NDIS_HD_SPLIT_PARAMETERS, *PNDIS_HD_SPLIT_PARAMETERS;

#define NDIS_SIZEOF_HD_SPLIT_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_PARAMETERS, HDSplitCombineFlags)

//
// Flags used in NDIS_HD_SPLIT_PARAMETERS->HDSplitCombineFlags 
// and NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitCombineFlags
//
#define NDIS_HD_SPLIT_COMBINE_ALL_HEADERS          0x00000001

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_CURRENT_CONFIG
//
#define NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_CURRENT_CONFIG
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_CURRENT_CONFIG);
    // 
    NDIS_OBJECT_HEADER          Header;    
    ULONG                       HardwareCapabilities;
    ULONG                       CurrentCapabilities;
    ULONG                       HDSplitFlags;
    ULONG                       HDSplitCombineFlags;
    ULONG                       BackfillSize;
    ULONG                       MaxHeaderSize;
} NDIS_HD_SPLIT_CURRENT_CONFIG, *PNDIS_HD_SPLIT_CURRENT_CONFIG;

#define NDIS_SIZEOF_HD_SPLIT_CURRENT_CONFIG_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_CURRENT_CONFIG, MaxHeaderSize)

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HardwareCapabilities
// and NDIS_HD_SPLIT_ATTRIBUTES->CurrentCapabilities. They are also
// used in NDIS_HD_SPLIT_CURRENT_CONFIG->HardwareCapabilities
// and NDIS_HD_SPLIT_CURRENT_CONFIG->CurrentCapabilities. 
//
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_HEADER_DATA_SPLIT         0x00000001
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV4_OPTIONS              0x00000002
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV6_EXTENSION_HEADERS    0x00000004
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_TCP_OPTIONS               0x00000008

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HDSplitFlags and
// NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitFlags
//
#define NDIS_HD_SPLIT_ENABLE_HEADER_DATA_SPLIT     0x00000001

#endif // (NDIS_SUPPORT_NDIS61)

#define NDIS_WMI_OUTPUT_INFO_REVISION_1    1;

typedef struct NDIS_WMI_OUTPUT_INFO
{
    NDIS_OBJECT_HEADER   Header;
    ULONG                Flags;
    UCHAR                SupportedRevision;
    ULONG                DataOffset;
    
} NDIS_WMI_OUTPUT_INFO, *PNDIS_WMI_OUTPUT_INFO;

#define NDIS_SIZEOF_WMI_OUTPUT_INFO_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OUTPUT_INFO, DataOffset)

// #endif // NTDDI_VERSION >= NTDDI_VISTA  //  #endif  //  UNDER_CE

#ifdef __cplusplus
}
#endif

#ifdef UNDER_CE
//
//  backward compatibility
//

//
// flags used for OID_GEN_MINIPORT_INFO
//

#define NDIS_MINIPORT_BUS_MASTER						0x00000001
#define NDIS_MINIPORT_WDM_DRIVER						0x00000002
#define NDIS_MINIPORT_SG_LIST							0x00000004
#define NDIS_MINIPORT_SUPPORTS_MEDIA_QUERY				0x00000008
#define NDIS_MINIPORT_INDICATES_PACKETS					0x00000010
#define NDIS_MINIPORT_IGNORE_PACKET_QUEUE				0x00000020
#define NDIS_MINIPORT_IGNORE_REQUEST_QUEUE				0x00000040
#define NDIS_MINIPORT_IGNORE_TOKEN_RING_ERRORS			0x00000080
#define NDIS_MINIPORT_INTERMEDIATE_DRIVER				0x00000100
#define NDIS_MINIPORT_IS_NDIS_5							0x00000200
#define NDIS_MINIPORT_IS_CO								0x00000400
#define NDIS_MINIPORT_DESERIALIZE						0x00000800
#define NDIS_MINIPORT_REQUIRES_MEDIA_POLLING			0x00001000
#define NDIS_MINIPORT_SUPPORTS_MEDIA_SENSE				0x00002000
#define NDIS_MINIPORT_NETBOOT_CARD						0x00004000
#define NDIS_MINIPORT_PM_SUPPORTED						0x00008000
#define NDIS_MINIPORT_SUPPORTS_MAC_ADDRESS_OVERWRITE    0x00010000
#define NDIS_MINIPORT_USES_SAFE_BUFFER_APIS				0x00020000
#define NDIS_MINIPORT_HIDDEN							0x00040000
#define NDIS_MINIPORT_SWENUM							0x00080000
#define NDIS_MINIPORT_SURPRISE_REMOVE_OK				0x00100000
#define NDIS_MINIPORT_NO_HALT_ON_SUSPEND				0x00200000
#define NDIS_MINIPORT_HARDWARE_DEVICE					0x00400000
#define NDIS_MINIPORT_SUPPORTS_CANCEL_SEND_PACKETS		0x00800000
#define NDIS_MINIPORT_64BITS_DMA						0x01000000
#endif  //  UNDER_CE

#endif // _NTDDNDIS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\ntstatus.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++ BUILD Version: 0005    // Increment this if a change has global effects


Module Name:

    ntstatus.h

Abstract:

    Constant definitions for the NTSTATUS values.

Author:

    Portable Systems Group 30-Mar-1989

Revision History:

Notes:

    This file is generated by the MC tool from the winerror.msg file.

    Please add new error values to the end of the file.  To do otherwise
    will jumble the error values.

--*/

#pragma once

#ifndef _NTSTATUS_
#define _NTSTATUS_

// begin_ntsecapi

/*lint -save -e767 */  // Don't complain about different definitions // winnt

//
// NTSTATUS
//

typedef long NTSTATUS, *PNTSTATUS;


/////////////////////////////////////////////////////////////////////////
//
// Standard Success values
//
//
/////////////////////////////////////////////////////////////////////////


//
// The success status codes 0 - 63 are reserved for wait completion status.
// FacilityCodes 0x5 - 0xF have been allocated by various drivers.
//
#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L) // ntsubauth

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000

//
//
// Define the facility codes
//
#define FACILITY_USB_ERROR_CODE          0x10
#define FACILITY_TERMINAL_SERVER         0xA
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_IO_ERROR_CODE           0x4
#define FACILITY_HID_ERROR_CODE          0x11
#define FACILITY_FIREWIRE_ERROR_CODE     0x12
#define FACILITY_CLUSTER_ERROR_CODE      0x13
#define FACILITY_ACPI_ERROR_CODE         0x14
#define FACILITY_FWP_ERROR_CODE          0x22


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: STATUS_WAIT_0
//
// MessageText:
//
//  STATUS_WAIT_0
//
#define STATUS_WAIT_0                    ((NTSTATUS)0x00000000L)    // winnt

//
// MessageId: STATUS_WAIT_1
//
// MessageText:
//
//  STATUS_WAIT_1
//
#define STATUS_WAIT_1                    ((NTSTATUS)0x00000001L)

//
// MessageId: STATUS_WAIT_2
//
// MessageText:
//
//  STATUS_WAIT_2
//
#define STATUS_WAIT_2                    ((NTSTATUS)0x00000002L)

//
// MessageId: STATUS_WAIT_3
//
// MessageText:
//
//  STATUS_WAIT_3
//
#define STATUS_WAIT_3                    ((NTSTATUS)0x00000003L)

//
// MessageId: STATUS_WAIT_63
//
// MessageText:
//
//  STATUS_WAIT_63
//
#define STATUS_WAIT_63                   ((NTSTATUS)0x0000003FL)


//
// The success status codes 128 - 191 are reserved for wait completion
// status with an abandoned mutant object.
//
#define STATUS_ABANDONED                        ((NTSTATUS)0x00000080L)

//
// MessageId: STATUS_ABANDONED_WAIT_0
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_0
//
#define STATUS_ABANDONED_WAIT_0          ((NTSTATUS)0x00000080L)    // winnt

//
// MessageId: STATUS_ABANDONED_WAIT_63
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_63
//
#define STATUS_ABANDONED_WAIT_63         ((NTSTATUS)0x000000BFL)

//
// MessageId: STATUS_USER_APC
//
// MessageText:
//
//  The success status codes 256, 257, 258, and 258 are reserved for
//  User APC, Kernel APC, Alerted, and Timeout.
//
#define STATUS_USER_APC                  ((NTSTATUS)0x000000C0L)    // winnt

//
// MessageId: STATUS_KERNEL_APC
//
// MessageText:
//
//  The success status codes 256, 257, 258, and 258 are reserved for
//  User APC, Kernel APC, Alerted, and Timeout.
//
#define STATUS_KERNEL_APC                ((NTSTATUS)0x00000100L)

//
// MessageId: STATUS_ALERTED
//
// MessageText:
//
//  The success status codes 256, 257, 258, and 258 are reserved for
//  User APC, Kernel APC, Alerted, and Timeout.
//
#define STATUS_ALERTED                   ((NTSTATUS)0x00000101L)

//
// MessageId: STATUS_TIMEOUT
//
// MessageText:
//
//  The success status codes 256, 257, 258, and 258 are reserved for
//  User APC, Kernel APC, Alerted, and Timeout.
//
#define STATUS_TIMEOUT                   ((NTSTATUS)0x00000102L)    // winnt

//
// MessageId: STATUS_PENDING
//
// MessageText:
//
//  The operation that was requested is pending completion.
//
#define STATUS_PENDING                   ((NTSTATUS)0x00000103L)    // winnt

//
// MessageId: STATUS_REPARSE
//
// MessageText:
//
//  A reparse should be performed by the Object Manager since the name of the
//  file resulted in a symbolic link.
//
#define STATUS_REPARSE                   ((NTSTATUS)0x00000104L)

//
// MessageId: STATUS_MORE_ENTRIES
//
// MessageText:
//
//  Returned by enumeration APIs to indicate more information is available
//  to successive calls.
//
#define STATUS_MORE_ENTRIES              ((NTSTATUS)0x00000105L)

//
// MessageId: STATUS_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Indicates not all privileges referenced are assigned to the caller.
//  This allows, for example, all privileges to be disabled without having
//  to know exactly which privileges are assigned.
//
#define STATUS_NOT_ALL_ASSIGNED          ((NTSTATUS)0x00000106L)

//
// MessageId: STATUS_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some of the information to be translated has not been translated.
//
#define STATUS_SOME_NOT_MAPPED           ((NTSTATUS)0x00000107L)

//
// MessageId: STATUS_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
//  An open/create operation completed while an oplock break is
//  underway.
//
#define STATUS_OPLOCK_BREAK_IN_PROGRESS  ((NTSTATUS)0x00000108L)

//
// MessageId: STATUS_VOLUME_MOUNTED
//
// MessageText:
//
//  A new volume has been mounted by a file system.
//
#define STATUS_VOLUME_MOUNTED            ((NTSTATUS)0x00000109L)

//
// MessageId: STATUS_RXACT_COMMITTED
//
// MessageText:
//
//  This success level status indicates that the transaction state already
//  exists for the registry sub-tree, but that a transaction commit was
//  previously aborted.  The commit has now been completed.
//  This status value is returned by the runtime library (RTL) registry
//  transaction package (RXact).
//
#define STATUS_RXACT_COMMITTED           ((NTSTATUS)0x0000010AL)

//
// MessageId: STATUS_NOTIFY_CLEANUP
//
// MessageText:
//
//  This indicates that a notify change request has been completed due to
//  closing the handle which made the notify change request.
//
#define STATUS_NOTIFY_CLEANUP            ((NTSTATUS)0x0000010BL)

//
// MessageId: STATUS_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  This indicates that a notify change request is being completed and that the
//  information is not being returned in the caller's buffer.  The caller now
//  needs to enumerate the files to find the changes.
//
#define STATUS_NOTIFY_ENUM_DIR           ((NTSTATUS)0x0000010CL)

//
// MessageId: STATUS_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  {No Quotas}
//  No system quota limits are specifically set for this account.
//
#define STATUS_NO_QUOTAS_FOR_ACCOUNT     ((NTSTATUS)0x0000010DL)

//
// MessageId: STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
//  {Connect Failure on Primary Transport}
//  An attempt was made to connect to the remote server %s on the primary transport, but the
//  connection failed.  The computer WAS able to connect on a secondary transport.
//
#define STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED ((NTSTATUS)0x0000010EL)

//
// MessageId: STATUS_PAGE_FAULT_TRANSITION
//
// MessageText:
//
//  Page fault was a transition fault.
//
#define STATUS_PAGE_FAULT_TRANSITION     ((NTSTATUS)0x00000110L)

//
// MessageId: STATUS_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_DEMAND_ZERO    ((NTSTATUS)0x00000111L)

//
// MessageId: STATUS_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_COPY_ON_WRITE  ((NTSTATUS)0x00000112L)

//
// MessageId: STATUS_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
//  Page fault was a demand zero fault.
//
#define STATUS_PAGE_FAULT_GUARD_PAGE     ((NTSTATUS)0x00000113L)

//
// MessageId: STATUS_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
//  Page fault was satisfied by reading from a secondary storage device.
//
#define STATUS_PAGE_FAULT_PAGING_FILE    ((NTSTATUS)0x00000114L)

//
// MessageId: STATUS_CACHE_PAGE_LOCKED
//
// MessageText:
//
//  Cached page was locked during operation.
//
#define STATUS_CACHE_PAGE_LOCKED         ((NTSTATUS)0x00000115L)

//
// MessageId: STATUS_CRASH_DUMP
//
// MessageText:
//
//  Crash dump exists in paging file.
//
#define STATUS_CRASH_DUMP                ((NTSTATUS)0x00000116L)

//
// MessageId: STATUS_BUFFER_ALL_ZEROS
//
// MessageText:
//
//  Specified buffer contains all zeros.
//
#define STATUS_BUFFER_ALL_ZEROS          ((NTSTATUS)0x00000117L)

//
// MessageId: STATUS_REPARSE_OBJECT
//
// MessageText:
//
//  A reparse should be performed by the Object Manager since the name of the
//  file resulted in a symbolic link.
//
#define STATUS_REPARSE_OBJECT            ((NTSTATUS)0x00000118L)

//
// MessageId: STATUS_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
//  The device has succeeded a query-stop and its resource requirements have changed.
//
#define STATUS_RESOURCE_REQUIREMENTS_CHANGED ((NTSTATUS)0x00000119L)

//
// MessageId: STATUS_TRANSLATION_COMPLETE
//
// MessageText:
//
//  The translator has translated these resources into the global space and no
//  further translations should be performed.
//
#define STATUS_TRANSLATION_COMPLETE      ((NTSTATUS)0x00000120L)

//
// MessageId: STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
//  The directory service evaluated group memberships locally, as it was unable to contact a global catalog server.
//
#define STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY ((NTSTATUS)0x00000121L)



/////////////////////////////////////////////////////////////////////////
//
// Standard Information values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_OBJECT_NAME_EXISTS
//
// MessageText:
//
//  {Object Exists}
//  An attempt was made to create an object and the object name already existed.
//
#define STATUS_OBJECT_NAME_EXISTS        ((NTSTATUS)0x40000000L)

//
// MessageId: STATUS_THREAD_WAS_SUSPENDED
//
// MessageText:
//
//  {Thread Suspended}
//  A thread termination occurred while the thread was suspended. The
//  thread was resumed, and termination proceeded.
//
#define STATUS_THREAD_WAS_SUSPENDED      ((NTSTATUS)0x40000001L)

//
// MessageId: STATUS_WORKING_SET_LIMIT_RANGE
//
// MessageText:
//
//  {Working Set Range Error}
//  An attempt was made to set the working set minimum or maximum
//  to values which are outside of the allowable range.
//
#define STATUS_WORKING_SET_LIMIT_RANGE   ((NTSTATUS)0x40000002L)

//
// MessageId: STATUS_IMAGE_NOT_AT_BASE
//
// MessageText:
//
//  {Image Relocated}
//  An image file could not be mapped at the address specified in
//  the image file.  Local fixups must be performed on this image.
//
#define STATUS_IMAGE_NOT_AT_BASE         ((NTSTATUS)0x40000003L)

//
// MessageId: STATUS_RXACT_STATE_CREATED
//
// MessageText:
//
//  This informational level status indicates that a specified registry
//  sub-tree transaction state did not yet exist and had to be created.
//  This status value is returned by the runtime library (RTL) registry
//  transaction package (RXact).
//
#define STATUS_RXACT_STATE_CREATED       ((NTSTATUS)0x40000004L)

//
// MessageId: STATUS_SEGMENT_NOTIFICATION
//
// MessageText:
//
//  {Segment Load}
//  A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS
//  or Win16 program segment image. An exception is raised so a debugger can
//  load, unload or track symbols and breakpoints within these 16-bit segments.
//
#define STATUS_SEGMENT_NOTIFICATION      ((NTSTATUS)0x40000005L)    // winnt

//
// MessageId: STATUS_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  {Local Session Key}
//  A user session key was requested for a local RPC connection. The session key
//  returned is a constant value and not unique to this connection.
//
#define STATUS_LOCAL_USER_SESSION_KEY    ((NTSTATUS)0x40000006L)

//
// MessageId: STATUS_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
//  {Invalid Current Directory}
//  The process cannot switch to the startup current directory %s.
//  Select OK to set current directory to %s, or select CANCEL
//  to exit.
//
#define STATUS_BAD_CURRENT_DIRECTORY     ((NTSTATUS)0x40000007L)

//
// MessageId: STATUS_SERIAL_MORE_WRITES
//
// MessageText:
//
//  {Serial IOCTL Complete}
//  A serial I/O operation was completed by another write to a serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define STATUS_SERIAL_MORE_WRITES        ((NTSTATUS)0x40000008L)

//
// MessageId: STATUS_REGISTRY_RECOVERED
//
// MessageText:
//
//  {Registry Recovery}
//  One of the files containing the system's Registry data had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//
#define STATUS_REGISTRY_RECOVERED        ((NTSTATUS)0x40000009L)

//
// MessageId: STATUS_FT_READ_RECOVERY_FROM_BACKUP
//
// MessageText:
//
//  {Redundant Read}
//  To satisfy a read request, the NT fault-tolerant file system successfully
//  read the requested data from a redundant copy. This was done because
//  the file system encountered a failure on a member of the fault-tolerant
//  volume, but was unable to reassign the failing area of the device.
//
#define STATUS_FT_READ_RECOVERY_FROM_BACKUP ((NTSTATUS)0x4000000AL)

//
// MessageId: STATUS_FT_WRITE_RECOVERY
//
// MessageText:
//
//  {Redundant Write}
//  To satisfy a write request, the NT fault-tolerant file system successfully
//  wrote a redundant copy of the information. This was done because the
//  file system encountered a failure on a member of the fault-tolerant
//  volume, but was not able to reassign the failing area of the device.
//
#define STATUS_FT_WRITE_RECOVERY         ((NTSTATUS)0x4000000BL)

//
// MessageId: STATUS_SERIAL_COUNTER_TIMEOUT
//
// MessageText:
//
//  {Serial IOCTL Timeout}
//  A serial I/O operation completed because the time-out period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER had not reached zero.)
//
#define STATUS_SERIAL_COUNTER_TIMEOUT    ((NTSTATUS)0x4000000CL)

//
// MessageId: STATUS_NULL_LM_PASSWORD
//
// MessageText:
//
//  {Password Too Complex}
//  The NT password is too complex to be converted to a LAN Manager password.
//  The LAN Manager password returned is a NULL string.
//
#define STATUS_NULL_LM_PASSWORD          ((NTSTATUS)0x4000000DL)

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %s is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)

//
// MessageId: STATUS_RECEIVE_PARTIAL
//
// MessageText:
//
//  {Partial Data Received}
//  The network transport returned partial data to its client. The remaining
//  data will be sent later.
//
#define STATUS_RECEIVE_PARTIAL           ((NTSTATUS)0x4000000FL)

//
// MessageId: STATUS_RECEIVE_EXPEDITED
//
// MessageText:
//
//  {Expedited Data Received}
//  The network transport returned data to its client that was marked as
//  expedited by the remote system.
//
#define STATUS_RECEIVE_EXPEDITED         ((NTSTATUS)0x40000010L)

//
// MessageId: STATUS_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
//  {Partial Expedited Data Received}
//  The network transport returned partial data to its client and this data
//  was marked as expedited by the remote system. The remaining data will
//  be sent later.
//
#define STATUS_RECEIVE_PARTIAL_EXPEDITED ((NTSTATUS)0x40000011L)

//
// MessageId: STATUS_EVENT_DONE
//
// MessageText:
//
//  {TDI Event Done}
//  The TDI indication has completed successfully.
//
#define STATUS_EVENT_DONE                ((NTSTATUS)0x40000012L)

//
// MessageId: STATUS_EVENT_PENDING
//
// MessageText:
//
//  {TDI Event Pending}
//  The TDI indication has entered the pending state.
//
#define STATUS_EVENT_PENDING             ((NTSTATUS)0x40000013L)

//
// MessageId: STATUS_CHECKING_FILE_SYSTEM
//
// MessageText:
//
//  Checking file system on %wZ
//
#define STATUS_CHECKING_FILE_SYSTEM      ((NTSTATUS)0x40000014L)

//
// MessageId: STATUS_FATAL_APP_EXIT
//
// MessageText:
//
//  {Fatal Application Exit}
//  %s
//
#define STATUS_FATAL_APP_EXIT            ((NTSTATUS)0x40000015L)

//
// MessageId: STATUS_PREDEFINED_HANDLE
//
// MessageText:
//
//  The specified registry key is referenced by a predefined handle.
//
#define STATUS_PREDEFINED_HANDLE         ((NTSTATUS)0x40000016L)

//
// MessageId: STATUS_WAS_UNLOCKED
//
// MessageText:
//
//  {Page Unlocked}
//  The page protection of a locked page was changed to 'No Access'
//  and the page was unlocked from memory and from the process.
//
#define STATUS_WAS_UNLOCKED              ((NTSTATUS)0x40000017L)

//
// MessageId: STATUS_SERVICE_NOTIFICATION
//
// MessageText:
//
//  %s
//
#define STATUS_SERVICE_NOTIFICATION      ((NTSTATUS)0x40000018L)

//
// MessageId: STATUS_WAS_LOCKED
//
// MessageText:
//
//  {Page Locked}
//  One of the pages to lock was already locked.
//
#define STATUS_WAS_LOCKED                ((NTSTATUS)0x40000019L)

//
// MessageId: STATUS_LOG_HARD_ERROR
//
// MessageText:
//
//  Application popup: %1 : %2
//
#define STATUS_LOG_HARD_ERROR            ((NTSTATUS)0x4000001AL)

//
// MessageId: STATUS_ALREADY_WIN32
//
// MessageText:
//
//  STATUS_ALREADY_WIN32
//
#define STATUS_ALREADY_WIN32             ((NTSTATUS)0x4000001BL)

//
// MessageId: STATUS_WX86_UNSIMULATE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_UNSIMULATE           ((NTSTATUS)0x4000001CL)

//
// MessageId: STATUS_WX86_CONTINUE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_CONTINUE             ((NTSTATUS)0x4000001DL)

//
// MessageId: STATUS_WX86_SINGLE_STEP
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_SINGLE_STEP          ((NTSTATUS)0x4000001EL)

//
// MessageId: STATUS_WX86_BREAKPOINT
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_BREAKPOINT           ((NTSTATUS)0x4000001FL)

//
// MessageId: STATUS_WX86_EXCEPTION_CONTINUE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_CONTINUE   ((NTSTATUS)0x40000020L)

//
// MessageId: STATUS_WX86_EXCEPTION_LASTCHANCE
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_LASTCHANCE ((NTSTATUS)0x40000021L)

//
// MessageId: STATUS_WX86_EXCEPTION_CHAIN
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_EXCEPTION_CHAIN      ((NTSTATUS)0x40000022L)

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %s is valid, but is for a machine type other than the current machine.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE ((NTSTATUS)0x40000023L)

//
// MessageId: STATUS_NO_YIELD_PERFORMED
//
// MessageText:
//
//  A yield execution was performed and no thread was available to run.
//
#define STATUS_NO_YIELD_PERFORMED        ((NTSTATUS)0x40000024L)

//
// MessageId: STATUS_TIMER_RESUME_IGNORED
//
// MessageText:
//
//  The resumeable flag to a timer API was ignored.
//
#define STATUS_TIMER_RESUME_IGNORED      ((NTSTATUS)0x40000025L)

//
// MessageId: STATUS_ARBITRATION_UNHANDLED
//
// MessageText:
//
//  The arbiter has deferred arbitration of these resources to its parent
//
#define STATUS_ARBITRATION_UNHANDLED     ((NTSTATUS)0x40000026L)

//
// MessageId: STATUS_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
//  The CardBus card in the socket of this pc-card controller:
//  %s
//  will not be supported.  The operating system will support only
//  16-bit (R2) pc-cards on this controller for this system.
//
#define STATUS_CARDBUS_NOT_SUPPORTED     ((NTSTATUS)0x40000027L)

//
// MessageId: STATUS_WX86_CREATEWX86TIB
//
// MessageText:
//
//  Exception status code used by Win32 x86 emulation subsystem.
//
#define STATUS_WX86_CREATEWX86TIB        ((NTSTATUS)0x40000028L)



//
// MessageId: STATUS_MESSAGE_RETRIEVED
//
// MessageText:
//
// The ALPC message being canceled has already been retrieved from the queue on the other side.
//
#define STATUS_MESSAGE_RETRIEVED         ((NTSTATUS)0x4000002EL)

//
// MessageId: STATUS_ALPC_CHECK_COMPLETION_LIST
//
// MessageText:
//
// The receive operation was successful. Check the ALPC completion list for the received message.
//
#define STATUS_ALPC_CHECK_COMPLETION_LIST ((NTSTATUS)0x40000030L)


/////////////////////////////////////////////////////////////////////////
//
// Standard Warning values
//
//
// Note:  Do NOT use the value 0x80000000L, as this is a non-portable value
//        for the NT_SUCCESS macro.  Warning values start with a code of 1.
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_GUARD_PAGE_VIOLATION
//
// MessageText:
//
//  {EXCEPTION}
//  Guard Page Exception
//  A page of memory that marks the end of a data structure, such as a stack
//  or an array, has been accessed.
//
#define STATUS_GUARD_PAGE_VIOLATION      ((NTSTATUS)0x80000001L)    // winnt

//
// MessageId: STATUS_DATATYPE_MISALIGNMENT
//
// MessageText:
//
//  {EXCEPTION}
//  Alignment Fault
//  A datatype misalignment was detected in a load or store instruction.
//
#define STATUS_DATATYPE_MISALIGNMENT     ((NTSTATUS)0x80000002L)    // winnt

//
// MessageId: STATUS_BREAKPOINT
//
// MessageText:
//
//  {EXCEPTION}
//  Breakpoint
//  A breakpoint has been reached.
//
#define STATUS_BREAKPOINT                ((NTSTATUS)0x80000003L)    // winnt

//
// MessageId: STATUS_SINGLE_STEP
//
// MessageText:
//
//  {EXCEPTION}
//  Single Step
//  A single step or trace operation has just been completed.
//
#define STATUS_SINGLE_STEP               ((NTSTATUS)0x80000004L)    // winnt

//
// MessageId: STATUS_BUFFER_OVERFLOW
//
// MessageText:
//
//  {Buffer Overflow}
//  The data was too large to fit into the specified buffer.
//
#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS)0x80000005L)

//
// MessageId: STATUS_NO_MORE_FILES
//
// MessageText:
//
//  {No More Files}
//  No more files were found which match the file specification.
//
#define STATUS_NO_MORE_FILES             ((NTSTATUS)0x80000006L)

//
// MessageId: STATUS_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
//  {Kernel Debugger Awakened}
//  the system debugger was awakened by an interrupt.
//
#define STATUS_WAKE_SYSTEM_DEBUGGER      ((NTSTATUS)0x80000007L)

//
// MessageId: STATUS_HANDLES_CLOSED
//
// MessageText:
//
//  {Handles Closed}
//  Handles to objects have been automatically closed as a result of the
//  requested operation.
//
#define STATUS_HANDLES_CLOSED            ((NTSTATUS)0x8000000AL)

//
// MessageId: STATUS_NO_INHERITANCE
//
// MessageText:
//
//  {Non-Inheritable ACL}
//  An access control list (ACL) contains no components that can be inherited.
//
#define STATUS_NO_INHERITANCE            ((NTSTATUS)0x8000000BL)

//
// MessageId: STATUS_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
//  {GUID Substitution}
//  During the translation of a global identifier (GUID) to a Windows NT
//  security ID (SID), no administratively-defined GUID prefix was found.
//  A substitute prefix was used, which will not compromise system security.
//  However, this may provide a more restrictive access than intended.
//
#define STATUS_GUID_SUBSTITUTION_MADE    ((NTSTATUS)0x8000000CL)

//
// MessageId: STATUS_PARTIAL_COPY
//
// MessageText:
//
//  {Partial Copy}
//  Due to protection conflicts not all the requested bytes could be
//  copied.
//
#define STATUS_PARTIAL_COPY              ((NTSTATUS)0x8000000DL)

//
// MessageId: STATUS_DEVICE_PAPER_EMPTY
//
// MessageText:
//
//  {Out of Paper}
//  The printer is out of paper.
//
#define STATUS_DEVICE_PAPER_EMPTY        ((NTSTATUS)0x8000000EL)

//
// MessageId: STATUS_DEVICE_POWERED_OFF
//
// MessageText:
//
//  {Device Power Is Off}
//  The printer power has been turned off.
//
#define STATUS_DEVICE_POWERED_OFF        ((NTSTATUS)0x8000000FL)

//
// MessageId: STATUS_DEVICE_OFF_LINE
//
// MessageText:
//
//  {Device Offline}
//  The printer has been taken offline.
//
#define STATUS_DEVICE_OFF_LINE           ((NTSTATUS)0x80000010L)

//
// MessageId: STATUS_DEVICE_BUSY
//
// MessageText:
//
//  {Device Busy}
//  The device is currently busy.
//
#define STATUS_DEVICE_BUSY               ((NTSTATUS)0x80000011L)

//
// MessageId: STATUS_NO_MORE_EAS
//
// MessageText:
//
//  {No More EAs}
//  No more extended attributes (EAs) were found for the file.
//
#define STATUS_NO_MORE_EAS               ((NTSTATUS)0x80000012L)

//
// MessageId: STATUS_INVALID_EA_NAME
//
// MessageText:
//
//  {Illegal EA}
//  The specified extended attribute (EA) name contains at least one illegal
//  character.
//
#define STATUS_INVALID_EA_NAME           ((NTSTATUS)0x80000013L)

//
// MessageId: STATUS_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  {Inconsistent EA List}
//  The extended attribute (EA) list is inconsistent.
//
#define STATUS_EA_LIST_INCONSISTENT      ((NTSTATUS)0x80000014L)

//
// MessageId: STATUS_INVALID_EA_FLAG
//
// MessageText:
//
//  {Invalid EA Flag}
//  An invalid extended attribute (EA) flag was set.
//
#define STATUS_INVALID_EA_FLAG           ((NTSTATUS)0x80000015L)

//
// MessageId: STATUS_VERIFY_REQUIRED
//
// MessageText:
//
//  {Verifying Disk}
//  The media has changed and a verify operation is in progress so no
//  reads or writes may be performed to the device, except those used in
//  the verify operation.
//
#define STATUS_VERIFY_REQUIRED           ((NTSTATUS)0x80000016L)

//
// MessageId: STATUS_EXTRANEOUS_INFORMATION
//
// MessageText:
//
//  {Too Much Information}
//  The specified access control list (ACL) contained more information than
//  was expected.
//
#define STATUS_EXTRANEOUS_INFORMATION    ((NTSTATUS)0x80000017L)

//
// MessageId: STATUS_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
//  This warning level status indicates that the transaction state already
//  exists for the registry sub-tree, but that a transaction commit was
//  previously aborted.  The commit has NOT been completed, but has not been
//  rolled back either (so it may still be committed if desired).
//  This status value is returned by the runtime library (RTL) registry
//  transaction package (RXact).
//
#define STATUS_RXACT_COMMIT_NECESSARY    ((NTSTATUS)0x80000018L)

//
// MessageId: STATUS_NO_MORE_ENTRIES
//
// MessageText:
//
//  {No More Entries}
//  No more entries are available from an enumeration operation.
//
#define STATUS_NO_MORE_ENTRIES           ((NTSTATUS)0x8000001AL)

//
// MessageId: STATUS_FILEMARK_DETECTED
//
// MessageText:
//
//  {Filemark Found}
//  A filemark was detected.
//
#define STATUS_FILEMARK_DETECTED         ((NTSTATUS)0x8000001BL)

//
// MessageId: STATUS_MEDIA_CHANGED
//
// MessageText:
//
//  {Media Changed}
//  The media may have changed.
//
#define STATUS_MEDIA_CHANGED             ((NTSTATUS)0x8000001CL)

//
// MessageId: STATUS_BUS_RESET
//
// MessageText:
//
//  {I/O Bus Reset}
//  An I/O bus reset was detected.
//
#define STATUS_BUS_RESET                 ((NTSTATUS)0x8000001DL)

//
// MessageId: STATUS_END_OF_MEDIA
//
// MessageText:
//
//  {End of Media}
//  The end of the media was encountered.
//
#define STATUS_END_OF_MEDIA              ((NTSTATUS)0x8000001EL)

//
// MessageId: STATUS_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  Beginning of tape or partition has been detected.
//
#define STATUS_BEGINNING_OF_MEDIA        ((NTSTATUS)0x8000001FL)

//
// MessageId: STATUS_MEDIA_CHECK
//
// MessageText:
//
//  {Media Changed}
//  The media may have changed.
//
#define STATUS_MEDIA_CHECK               ((NTSTATUS)0x80000020L)

//
// MessageId: STATUS_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a setmark.
//
#define STATUS_SETMARK_DETECTED          ((NTSTATUS)0x80000021L)

//
// MessageId: STATUS_NO_DATA_DETECTED
//
// MessageText:
//
//  During a tape access, the end of the data written is reached.
//
#define STATUS_NO_DATA_DETECTED          ((NTSTATUS)0x80000022L)

//
// MessageId: STATUS_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define STATUS_REDIRECTOR_HAS_OPEN_HANDLES ((NTSTATUS)0x80000023L)

//
// MessageId: STATUS_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define STATUS_SERVER_HAS_OPEN_HANDLES   ((NTSTATUS)0x80000024L)

//
// MessageId: STATUS_ALREADY_DISCONNECTED
//
// MessageText:
//
//  The specified connection has already been disconnected.
//
#define STATUS_ALREADY_DISCONNECTED      ((NTSTATUS)0x80000025L)

//
// MessageId: STATUS_LONGJUMP
//
// MessageText:
//
//  A long jump has been executed.
//
#define STATUS_LONGJUMP                  ((NTSTATUS)0x80000026L)


#define STATUS_USER_BREAK                ((NTSTATUS)0x80000113L)

/////////////////////////////////////////////////////////////////////////
//
//  Standard Error values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
//  {Operation Failed}
//  The requested operation was unsuccessful.
//
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

//
// MessageId: STATUS_NOT_IMPLEMENTED
//
// MessageText:
//
//  {Not Implemented}
//  The requested operation is not implemented.
//
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)

//
// MessageId: STATUS_INVALID_INFO_CLASS
//
// MessageText:
//
//  {Invalid Parameter}
//  The specified information class is not a valid information class for
//  the specified object.
//
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)    // ntsubauth

//
// MessageId: STATUS_INFO_LENGTH_MISMATCH
//
// MessageText:
//
//  The specified information record length does not match the length
//  required for the specified information class.
//
#define STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)

//
// MessageId: STATUS_ACCESS_VIOLATION
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The memory
//  could not be "%s".
//
#define STATUS_ACCESS_VIOLATION          ((NTSTATUS)0xC0000005L)    // winnt

//
// MessageId: STATUS_IN_PAGE_ERROR
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The required
//  data was not placed into memory because of an I/O error status of "0x%08lx".
//
#define STATUS_IN_PAGE_ERROR             ((NTSTATUS)0xC0000006L)    // winnt

//
// MessageId: STATUS_PAGEFILE_QUOTA
//
// MessageText:
//
//  The pagefile quota for the process has been exhausted.
//
#define STATUS_PAGEFILE_QUOTA            ((NTSTATUS)0xC0000007L)

//
// MessageId: STATUS_INVALID_HANDLE
//
// MessageText:
//
//  An invalid HANDLE was specified.
//
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt

//
// MessageId: STATUS_BAD_INITIAL_STACK
//
// MessageText:
//
//  An invalid initial stack was specified in a call to NtCreateThread.
//
#define STATUS_BAD_INITIAL_STACK         ((NTSTATUS)0xC0000009L)

//
// MessageId: STATUS_BAD_INITIAL_PC
//
// MessageText:
//
//  An invalid initial start address was specified in a call to NtCreateThread.
//
#define STATUS_BAD_INITIAL_PC            ((NTSTATUS)0xC000000AL)

//
// MessageId: STATUS_INVALID_CID
//
// MessageText:
//
//  An invalid Client ID was specified.
//
#define STATUS_INVALID_CID               ((NTSTATUS)0xC000000BL)

//
// MessageId: STATUS_TIMER_NOT_CANCELED
//
// MessageText:
//
//  An attempt was made to cancel or set a timer that has an associated APC
//  and the subject thread is not the thread that originally set the timer
//  with an associated APC routine.
//
#define STATUS_TIMER_NOT_CANCELED        ((NTSTATUS)0xC000000CL)

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to a service or function.
//
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//
// MessageId: STATUS_NO_SUCH_DEVICE
//
// MessageText:
//
//  A device which does not exist was specified.
//
#define STATUS_NO_SUCH_DEVICE            ((NTSTATUS)0xC000000EL)

//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %s does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
//  The specified request is not a valid operation for the target device.
//
#define STATUS_INVALID_DEVICE_REQUEST    ((NTSTATUS)0xC0000010L)

//
// MessageId: STATUS_END_OF_FILE
//
// MessageText:
//
//  The end-of-file marker has been reached.  There is no valid data in the
//  file beyond this marker.
//
#define STATUS_END_OF_FILE               ((NTSTATUS)0xC0000011L)

//
// MessageId: STATUS_WRONG_VOLUME
//
// MessageText:
//
//  {Wrong Volume}
//  The wrong volume is in the drive.
//  Please insert volume %s into drive %s.
//
#define STATUS_WRONG_VOLUME              ((NTSTATUS)0xC0000012L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %s.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %s is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_NONEXISTENT_SECTOR
//
// MessageText:
//
//  {Sector Not Found}
//  The specified sector does not exist.
//
#define STATUS_NONEXISTENT_SECTOR        ((NTSTATUS)0xC0000015L)

//
// MessageId: STATUS_MORE_PROCESSING_REQUIRED
//
// MessageText:
//
//  {Still Busy}
//  The specified I/O request packet (IRP) cannot be disposed of because the
//  I/O operation is not complete.
//
#define STATUS_MORE_PROCESSING_REQUIRED  ((NTSTATUS)0xC0000016L)

//
// MessageId: STATUS_NO_MEMORY
//
// MessageText:
//
//  {Not Enough Quota}
//  Not enough virtual memory or paging file quota is available to complete
//  the specified operation.
//
#define STATUS_NO_MEMORY                 ((NTSTATUS)0xC0000017L)    // winnt

//
// MessageId: STATUS_CONFLICTING_ADDRESSES
//
// MessageText:
//
//  {Conflicting Address Range}
//  The specified address range conflicts with the address space.
//
#define STATUS_CONFLICTING_ADDRESSES     ((NTSTATUS)0xC0000018L)

//
// MessageId: STATUS_NOT_MAPPED_VIEW
//
// MessageText:
//
//  Address range to unmap is not a mapped view.
//
#define STATUS_NOT_MAPPED_VIEW           ((NTSTATUS)0xC0000019L)

//
// MessageId: STATUS_UNABLE_TO_FREE_VM
//
// MessageText:
//
//  Virtual memory cannot be freed.
//
#define STATUS_UNABLE_TO_FREE_VM         ((NTSTATUS)0xC000001AL)

//
// MessageId: STATUS_UNABLE_TO_DELETE_SECTION
//
// MessageText:
//
//  Specified section cannot be deleted.
//
#define STATUS_UNABLE_TO_DELETE_SECTION  ((NTSTATUS)0xC000001BL)

//
// MessageId: STATUS_INVALID_SYSTEM_SERVICE
//
// MessageText:
//
//  An invalid system service was specified in a system service call.
//
#define STATUS_INVALID_SYSTEM_SERVICE    ((NTSTATUS)0xC000001CL)

//
// MessageId: STATUS_ILLEGAL_INSTRUCTION
//
// MessageText:
//
//  {EXCEPTION}
//  Illegal Instruction
//  An attempt was made to execute an illegal instruction.
//
#define STATUS_ILLEGAL_INSTRUCTION       ((NTSTATUS)0xC000001DL)    // winnt

//
// MessageId: STATUS_INVALID_LOCK_SEQUENCE
//
// MessageText:
//
//  {Invalid Lock Sequence}
//  An attempt was made to execute an invalid lock sequence.
//
#define STATUS_INVALID_LOCK_SEQUENCE     ((NTSTATUS)0xC000001EL)

//
// MessageId: STATUS_INVALID_VIEW_SIZE
//
// MessageText:
//
//  {Invalid Mapping}
//  An attempt was made to create a view for a section which is bigger
//  than the section.
//
#define STATUS_INVALID_VIEW_SIZE         ((NTSTATUS)0xC000001FL)

//
// MessageId: STATUS_INVALID_FILE_FOR_SECTION
//
// MessageText:
//
//  {Bad File}
//  The attributes of the specified mapping file for a section of memory
//  cannot be read.
//
#define STATUS_INVALID_FILE_FOR_SECTION  ((NTSTATUS)0xC0000020L)

//
// MessageId: STATUS_ALREADY_COMMITTED
//
// MessageText:
//
//  {Already Committed}
//  The specified address range is already committed.
//
#define STATUS_ALREADY_COMMITTED         ((NTSTATUS)0xC0000021L)

//
// MessageId: STATUS_ACCESS_DENIED
//
// MessageText:
//
//  {Access Denied}
//  A process has requested access to an object, but has not been granted
//  those access rights.
//
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)

//
// MessageId: STATUS_BUFFER_TOO_SMALL
//
// MessageText:
//
//  {Buffer Too Small}
//  The buffer is too small to contain the entry.  No information has been
//  written to the buffer.
//
#define STATUS_BUFFER_TOO_SMALL          ((NTSTATUS)0xC0000023L)

//
// MessageId: STATUS_OBJECT_TYPE_MISMATCH
//
// MessageText:
//
//  {Wrong Type}
//  There is a mismatch between the type of object required by the requested
//  operation and the type of object that is specified in the request.
//
#define STATUS_OBJECT_TYPE_MISMATCH      ((NTSTATUS)0xC0000024L)

//
// MessageId: STATUS_NONCONTINUABLE_EXCEPTION
//
// MessageText:
//
//  {EXCEPTION}
//  Cannot Continue
//  Windows NT cannot continue from this exception.
//
#define STATUS_NONCONTINUABLE_EXCEPTION  ((NTSTATUS)0xC0000025L)    // winnt

//
// MessageId: STATUS_INVALID_DISPOSITION
//
// MessageText:
//
//  An invalid exception disposition was returned by an exception handler.
//
#define STATUS_INVALID_DISPOSITION       ((NTSTATUS)0xC0000026L)    // winnt

//
// MessageId: STATUS_UNWIND
//
// MessageText:
//
//  Unwind exception code.
//
#define STATUS_UNWIND                    ((NTSTATUS)0xC0000027L)

//
// MessageId: STATUS_BAD_STACK
//
// MessageText:
//
//  An invalid or unaligned stack was encountered during an unwind operation.
//
#define STATUS_BAD_STACK                 ((NTSTATUS)0xC0000028L)

//
// MessageId: STATUS_INVALID_UNWIND_TARGET
//
// MessageText:
//
//  An invalid unwind target was encountered during an unwind operation.
//
#define STATUS_INVALID_UNWIND_TARGET     ((NTSTATUS)0xC0000029L)

//
// MessageId: STATUS_NOT_LOCKED
//
// MessageText:
//
//  An attempt was made to unlock a page of memory which was not locked.
//
#define STATUS_NOT_LOCKED                ((NTSTATUS)0xC000002AL)

//
// MessageId: STATUS_PARITY_ERROR
//
// MessageText:
//
//  Device parity error on I/O operation.
//
#define STATUS_PARITY_ERROR              ((NTSTATUS)0xC000002BL)

//
// MessageId: STATUS_UNABLE_TO_DECOMMIT_VM
//
// MessageText:
//
//  An attempt was made to decommit uncommitted virtual memory.
//
#define STATUS_UNABLE_TO_DECOMMIT_VM     ((NTSTATUS)0xC000002CL)

//
// MessageId: STATUS_NOT_COMMITTED
//
// MessageText:
//
//  An attempt was made to change the attributes on memory that
//  has not been committed.
//
#define STATUS_NOT_COMMITTED             ((NTSTATUS)0xC000002DL)

//
// MessageId: STATUS_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
//  Invalid Object Attributes specified to NtCreatePort or invalid
//  Port Attributes specified to NtConnectPort
//
#define STATUS_INVALID_PORT_ATTRIBUTES   ((NTSTATUS)0xC000002EL)

//
// MessageId: STATUS_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
//  Length of message passed to NtRequestPort or NtRequestWaitReplyPort
//  was longer than the maximum message allowed by the port.
//
#define STATUS_PORT_MESSAGE_TOO_LONG     ((NTSTATUS)0xC000002FL)

//
// MessageId: STATUS_INVALID_PARAMETER_MIX
//
// MessageText:
//
//  An invalid combination of parameters was specified.
//
#define STATUS_INVALID_PARAMETER_MIX     ((NTSTATUS)0xC0000030L)

//
// MessageId: STATUS_INVALID_QUOTA_LOWER
//
// MessageText:
//
//  An attempt was made to lower a quota limit below the current usage.
//
#define STATUS_INVALID_QUOTA_LOWER       ((NTSTATUS)0xC0000031L)

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt Disk}
//  The file system structure on the disk is corrupt and unusable.
//  Please run the Chkdsk utility on the volume %s.
//
#define STATUS_DISK_CORRUPT_ERROR        ((NTSTATUS)0xC0000032L)

//
// MessageId: STATUS_OBJECT_NAME_INVALID
//
// MessageText:
//
//  Object Name invalid.
//
#define STATUS_OBJECT_NAME_INVALID       ((NTSTATUS)0xC0000033L)

//
// MessageId: STATUS_OBJECT_NAME_NOT_FOUND
//
// MessageText:
//
//  Object Name not found.
//
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

//
// MessageId: STATUS_OBJECT_NAME_COLLISION
//
// MessageText:
//
//  Object Name already exists.
//
#define STATUS_OBJECT_NAME_COLLISION     ((NTSTATUS)0xC0000035L)

//
// MessageId: STATUS_PORT_DISCONNECTED
//
// MessageText:
//
//  Attempt to send a message to a disconnected communication port.
//
#define STATUS_PORT_DISCONNECTED         ((NTSTATUS)0xC0000037L)

//
// MessageId: STATUS_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
//  An attempt was made to attach to a device that was already attached to
//  another device.
//
#define STATUS_DEVICE_ALREADY_ATTACHED   ((NTSTATUS)0xC0000038L)

//
// MessageId: STATUS_OBJECT_PATH_INVALID
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_INVALID       ((NTSTATUS)0xC0000039L)

//
// MessageId: STATUS_OBJECT_PATH_NOT_FOUND
//
// MessageText:
//
//  {Path Not Found}
//  The path %s does not exist.
//
#define STATUS_OBJECT_PATH_NOT_FOUND     ((NTSTATUS)0xC000003AL)

//
// MessageId: STATUS_OBJECT_PATH_SYNTAX_BAD
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_SYNTAX_BAD    ((NTSTATUS)0xC000003BL)

//
// MessageId: STATUS_DATA_OVERRUN
//
// MessageText:
//
//  {Data Overrun}
//  A data overrun error occurred.
//
#define STATUS_DATA_OVERRUN              ((NTSTATUS)0xC000003CL)

//
// MessageId: STATUS_DATA_LATE_ERROR
//
// MessageText:
//
//  {Data Late}
//  A data late error occurred.
//
#define STATUS_DATA_LATE_ERROR           ((NTSTATUS)0xC000003DL)

//
// MessageId: STATUS_DATA_ERROR
//
// MessageText:
//
//  {Data Error}
//  An error in reading or writing data occurred.
//
#define STATUS_DATA_ERROR                ((NTSTATUS)0xC000003EL)

//
// MessageId: STATUS_CRC_ERROR
//
// MessageText:
//
//  {Bad CRC}
//  A cyclic redundancy check (CRC) checksum error occurred.
//
#define STATUS_CRC_ERROR                 ((NTSTATUS)0xC000003FL)

//
// MessageId: STATUS_SECTION_TOO_BIG
//
// MessageText:
//
//  {Section Too Large}
//  The specified section is too big to map the file.
//
#define STATUS_SECTION_TOO_BIG           ((NTSTATUS)0xC0000040L)

//
// MessageId: STATUS_PORT_CONNECTION_REFUSED
//
// MessageText:
//
//  The NtConnectPort request is refused.
//
#define STATUS_PORT_CONNECTION_REFUSED   ((NTSTATUS)0xC0000041L)

//
// MessageId: STATUS_INVALID_PORT_HANDLE
//
// MessageText:
//
//  The type of port handle is invalid for the operation requested.
//
#define STATUS_INVALID_PORT_HANDLE       ((NTSTATUS)0xC0000042L)

//
// MessageId: STATUS_SHARING_VIOLATION
//
// MessageText:
//
//  A file cannot be opened because the share access flags are
//  incompatible.
//
#define STATUS_SHARING_VIOLATION         ((NTSTATUS)0xC0000043L)

//
// MessageId: STATUS_QUOTA_EXCEEDED
//
// MessageText:
//
//  Insufficient quota exists to complete the operation
//
#define STATUS_QUOTA_EXCEEDED            ((NTSTATUS)0xC0000044L)

//
// MessageId: STATUS_INVALID_PAGE_PROTECTION
//
// MessageText:
//
//  The specified page protection was not valid.
//
#define STATUS_INVALID_PAGE_PROTECTION   ((NTSTATUS)0xC0000045L)

//
// MessageId: STATUS_MUTANT_NOT_OWNED
//
// MessageText:
//
//  An attempt to release a mutant object was made by a thread that was not the
//  owner of the mutant object.
//
#define STATUS_MUTANT_NOT_OWNED          ((NTSTATUS)0xC0000046L)

//
// MessageId: STATUS_SEMAPHORE_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to release a semaphore such that its maximum count
//  would have been exceeded.
//
#define STATUS_SEMAPHORE_LIMIT_EXCEEDED  ((NTSTATUS)0xC0000047L)

//
// MessageId: STATUS_PORT_ALREADY_SET
//
// MessageText:
//
//  An attempt to set a processes DebugPort or ExceptionPort was made,
//  but a port already exists in the process.
//
#define STATUS_PORT_ALREADY_SET          ((NTSTATUS)0xC0000048L)

//
// MessageId: STATUS_SECTION_NOT_IMAGE
//
// MessageText:
//
//  An attempt was made to query image information on a section
//  which does not map an image.
//
#define STATUS_SECTION_NOT_IMAGE         ((NTSTATUS)0xC0000049L)

//
// MessageId: STATUS_SUSPEND_COUNT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to suspend a thread whose suspend count
//  was at its maximum.
//
#define STATUS_SUSPEND_COUNT_EXCEEDED    ((NTSTATUS)0xC000004AL)

//
// MessageId: STATUS_THREAD_IS_TERMINATING
//
// MessageText:
//
//  An attempt was made to suspend a thread that has begun
//  termination.
//
#define STATUS_THREAD_IS_TERMINATING     ((NTSTATUS)0xC000004BL)

//
// MessageId: STATUS_BAD_WORKING_SET_LIMIT
//
// MessageText:
//
//  An attempt was made to set the working set limit to an
//  invalid value (minimum greater than maximum, etc).
//
#define STATUS_BAD_WORKING_SET_LIMIT     ((NTSTATUS)0xC000004CL)

//
// MessageId: STATUS_INCOMPATIBLE_FILE_MAP
//
// MessageText:
//
//  A section was created to map a file which is not compatible
//  to an already existing section which maps the same file.
//
#define STATUS_INCOMPATIBLE_FILE_MAP     ((NTSTATUS)0xC000004DL)

//
// MessageId: STATUS_SECTION_PROTECTION
//
// MessageText:
//
//  A view to a section specifies a protection which is incompatible
//  with the initial view's protection.
//
#define STATUS_SECTION_PROTECTION        ((NTSTATUS)0xC000004EL)

//
// MessageId: STATUS_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  An operation involving EAs failed because the file system does not
//  support EAs.
//
#define STATUS_EAS_NOT_SUPPORTED         ((NTSTATUS)0xC000004FL)

//
// MessageId: STATUS_EA_TOO_LARGE
//
// MessageText:
//
//  An EA operation failed because EA set is too large.
//
#define STATUS_EA_TOO_LARGE              ((NTSTATUS)0xC0000050L)

//
// MessageId: STATUS_NONEXISTENT_EA_ENTRY
//
// MessageText:
//
//  An EA operation failed because the name or EA index is invalid.
//
#define STATUS_NONEXISTENT_EA_ENTRY      ((NTSTATUS)0xC0000051L)

//
// MessageId: STATUS_NO_EAS_ON_FILE
//
// MessageText:
//
//  The file for which EAs were requested has no EAs.
//
#define STATUS_NO_EAS_ON_FILE            ((NTSTATUS)0xC0000052L)

//
// MessageId: STATUS_EA_CORRUPT_ERROR
//
// MessageText:
//
//  The EA is corrupt and non-readable.
//
#define STATUS_EA_CORRUPT_ERROR          ((NTSTATUS)0xC0000053L)

//
// MessageId: STATUS_FILE_LOCK_CONFLICT
//
// MessageText:
//
//  A requested read/write cannot be granted due to a conflicting file lock.
//
#define STATUS_FILE_LOCK_CONFLICT        ((NTSTATUS)0xC0000054L)

//
// MessageId: STATUS_LOCK_NOT_GRANTED
//
// MessageText:
//
//  A requested file lock cannot be granted due to other existing locks.
//
#define STATUS_LOCK_NOT_GRANTED          ((NTSTATUS)0xC0000055L)

//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
//  A non close operation has been requested of a file object with a
//  delete pending.
//
#define STATUS_DELETE_PENDING            ((NTSTATUS)0xC0000056L)

//
// MessageId: STATUS_CTL_FILE_NOT_SUPPORTED
//
// MessageText:
//
//  An attempt was made to set the control attribute on a file.  This
//  attribute is not supported in the target file system.
//
#define STATUS_CTL_FILE_NOT_SUPPORTED    ((NTSTATUS)0xC0000057L)

//
// MessageId: STATUS_UNKNOWN_REVISION
//
// MessageText:
//
//  Indicates a revision number encountered or specified is not one
//  known by the service.  It may be a more recent revision than the
//  service is aware of.
//
#define STATUS_UNKNOWN_REVISION          ((NTSTATUS)0xC0000058L)

//
// MessageId: STATUS_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define STATUS_REVISION_MISMATCH         ((NTSTATUS)0xC0000059L)

//
// MessageId: STATUS_INVALID_OWNER
//
// MessageText:
//
//  Indicates a particular Security ID may not be assigned as the
//  owner of an object.
//
#define STATUS_INVALID_OWNER             ((NTSTATUS)0xC000005AL)

//
// MessageId: STATUS_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  Indicates a particular Security ID may not be assigned as the
//  primary group of an object.
//
#define STATUS_INVALID_PRIMARY_GROUP     ((NTSTATUS)0xC000005BL)

//
// MessageId: STATUS_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//
#define STATUS_NO_IMPERSONATION_TOKEN    ((NTSTATUS)0xC000005CL)

//
// MessageId: STATUS_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  A mandatory group may not be disabled.
//
#define STATUS_CANT_DISABLE_MANDATORY    ((NTSTATUS)0xC000005DL)

//
// MessageId: STATUS_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//
#define STATUS_NO_LOGON_SERVERS          ((NTSTATUS)0xC000005EL)

//
// MessageId: STATUS_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//
#define STATUS_NO_SUCH_LOGON_SESSION     ((NTSTATUS)0xC000005FL)

//
// MessageId: STATUS_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//
#define STATUS_NO_SUCH_PRIVILEGE         ((NTSTATUS)0xC0000060L)

//
// MessageId: STATUS_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//
#define STATUS_PRIVILEGE_NOT_HELD        ((NTSTATUS)0xC0000061L)

//
// MessageId: STATUS_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define STATUS_INVALID_ACCOUNT_NAME      ((NTSTATUS)0xC0000062L)

//
// MessageId: STATUS_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define STATUS_USER_EXISTS               ((NTSTATUS)0xC0000063L)

//
// MessageId: STATUS_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define STATUS_NO_SUCH_USER              ((NTSTATUS)0xC0000064L)     // ntsubauth

//
// MessageId: STATUS_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define STATUS_GROUP_EXISTS              ((NTSTATUS)0xC0000065L)

//
// MessageId: STATUS_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define STATUS_NO_SUCH_GROUP             ((NTSTATUS)0xC0000066L)

//
// MessageId: STATUS_MEMBER_IN_GROUP
//
// MessageText:
//
//  The specified user account is already in the specified group account.
//  Also used to indicate a group cannot be deleted because it contains
//  a member.
//
#define STATUS_MEMBER_IN_GROUP           ((NTSTATUS)0xC0000067L)

//
// MessageId: STATUS_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define STATUS_MEMBER_NOT_IN_GROUP       ((NTSTATUS)0xC0000068L)

//
// MessageId: STATUS_LAST_ADMIN
//
// MessageText:
//
//  Indicates the requested operation would disable or delete the last
//  remaining administration account.  This is not allowed to prevent
//  creating a situation in which the system cannot be administrated.
//
#define STATUS_LAST_ADMIN                ((NTSTATUS)0xC0000069L)

//
// MessageId: STATUS_WRONG_PASSWORD
//
// MessageText:
//
//  When trying to update a password, this return status indicates that
//  the value provided as the current password is not correct.
//
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)     // ntsubauth

//
// MessageId: STATUS_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  When trying to update a password, this return status indicates that
//  the value provided for the new password contains values that are
//  not allowed in passwords.
//
#define STATUS_ILL_FORMED_PASSWORD       ((NTSTATUS)0xC000006BL)

//
// MessageId: STATUS_PASSWORD_RESTRICTION
//
// MessageText:
//
//  When trying to update a password, this status indicates that some
//  password update rule has been violated.  For example, the password
//  may not meet length criteria.
//
#define STATUS_PASSWORD_RESTRICTION      ((NTSTATUS)0xC000006CL)     // ntsubauth

//
// MessageId: STATUS_LOGON_FAILURE
//
// MessageText:
//
//  The attempted logon is invalid.  This is either due to a bad username
//  or authentication information.
//
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Indicates a referenced user name and authentication information are
//  valid, but some user account restriction has prevented successful
//  authentication (such as time-of-day restrictions).
//
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)     // ntsubauth

//
// MessageId: STATUS_INVALID_LOGON_HOURS
//
// MessageText:
//
//  The user account has time restrictions and may not be logged onto
//  at this time.
//
#define STATUS_INVALID_LOGON_HOURS       ((NTSTATUS)0xC000006FL)     // ntsubauth

//
// MessageId: STATUS_INVALID_WORKSTATION
//
// MessageText:
//
//  The user account is restricted such that it may not be used to
//  log on from the source workstation.
//
#define STATUS_INVALID_WORKSTATION       ((NTSTATUS)0xC0000070L)     // ntsubauth

//
// MessageId: STATUS_PASSWORD_EXPIRED
//
// MessageText:
//
//  The user account's password has expired.
//
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_DISABLED
//
// MessageText:
//
//  The referenced account is currently disabled and may not be logged on to.
//
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)     // ntsubauth

//
// MessageId: STATUS_NONE_MAPPED
//
// MessageText:
//
//  None of the information to be translated has been translated.
//
#define STATUS_NONE_MAPPED               ((NTSTATUS)0xC0000073L)

//
// MessageId: STATUS_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  The number of LUIDs requested may not be allocated with a single
//  allocation.
//
#define STATUS_TOO_MANY_LUIDS_REQUESTED  ((NTSTATUS)0xC0000074L)

//
// MessageId: STATUS_LUIDS_EXHAUSTED
//
// MessageText:
//
//  Indicates there are no more LUIDs to allocate.
//
#define STATUS_LUIDS_EXHAUSTED           ((NTSTATUS)0xC0000075L)

//
// MessageId: STATUS_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  Indicates the sub-authority value is invalid for the particular use.
//
#define STATUS_INVALID_SUB_AUTHORITY     ((NTSTATUS)0xC0000076L)

//
// MessageId: STATUS_INVALID_ACL
//
// MessageText:
//
//  Indicates the ACL structure is not valid.
//
#define STATUS_INVALID_ACL               ((NTSTATUS)0xC0000077L)

//
// MessageId: STATUS_INVALID_SID
//
// MessageText:
//
//  Indicates the SID structure is not valid.
//
#define STATUS_INVALID_SID               ((NTSTATUS)0xC0000078L)

//
// MessageId: STATUS_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  Indicates the SECURITY_DESCRIPTOR structure is not valid.
//
#define STATUS_INVALID_SECURITY_DESCR    ((NTSTATUS)0xC0000079L)

//
// MessageId: STATUS_PROCEDURE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified procedure address cannot be found in the
//  DLL.
//
#define STATUS_PROCEDURE_NOT_FOUND       ((NTSTATUS)0xC000007AL)

//
// MessageId: STATUS_INVALID_IMAGE_FORMAT
//
// MessageText:
//
//  {Bad Image}
//  The application or DLL %s is not a valid Windows NT image.
//  Please check this against your installation diskette.
//
#define STATUS_INVALID_IMAGE_FORMAT      ((NTSTATUS)0xC000007BL)

//
// MessageId: STATUS_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that doesn't exist.
//  This is typically done by referencing the token associated with a thread
//  when the thread is not impersonating a client.
//
#define STATUS_NO_TOKEN                  ((NTSTATUS)0xC000007CL)

//
// MessageId: STATUS_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  Indicates that an attempt to build either an inherited ACL or ACE
//  was not successful.
//  This can be caused by a number of things.  One of the more probable
//  causes is the replacement of a CreatorId with an SID that didn't fit
//  into the ACE or ACL.
//
#define STATUS_BAD_INHERITANCE_ACL       ((NTSTATUS)0xC000007DL)

//
// MessageId: STATUS_RANGE_NOT_LOCKED
//
// MessageText:
//
//  The range specified in NtUnlockFile was not locked.
//
#define STATUS_RANGE_NOT_LOCKED          ((NTSTATUS)0xC000007EL)

//
// MessageId: STATUS_DISK_FULL
//
// MessageText:
//
//  An operation failed because the disk was full.
//
#define STATUS_DISK_FULL                 ((NTSTATUS)0xC000007FL)

//
// MessageId: STATUS_SERVER_DISABLED
//
// MessageText:
//
//  The GUID allocation server is [already] disabled at the moment.
//
#define STATUS_SERVER_DISABLED           ((NTSTATUS)0xC0000080L)

//
// MessageId: STATUS_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The GUID allocation server is [already] enabled at the moment.
//
#define STATUS_SERVER_NOT_DISABLED       ((NTSTATUS)0xC0000081L)

//
// MessageId: STATUS_TOO_MANY_GUIDS_REQUESTED
//
// MessageText:
//
//  Too many GUIDs were requested from the allocation server at once.
//
#define STATUS_TOO_MANY_GUIDS_REQUESTED  ((NTSTATUS)0xC0000082L)

//
// MessageId: STATUS_GUIDS_EXHAUSTED
//
// MessageText:
//
//  The GUIDs could not be allocated because the Authority Agent was
//  exhausted.
//
#define STATUS_GUIDS_EXHAUSTED           ((NTSTATUS)0xC0000083L)

//
// MessageId: STATUS_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define STATUS_INVALID_ID_AUTHORITY      ((NTSTATUS)0xC0000084L)

//
// MessageId: STATUS_AGENTS_EXHAUSTED
//
// MessageText:
//
//  There are no more authority agent values available for the given
//  identifier authority value.
//
#define STATUS_AGENTS_EXHAUSTED          ((NTSTATUS)0xC0000085L)

//
// MessageId: STATUS_INVALID_VOLUME_LABEL
//
// MessageText:
//
//  An invalid volume label has been specified.
//
#define STATUS_INVALID_VOLUME_LABEL      ((NTSTATUS)0xC0000086L)

//
// MessageId: STATUS_SECTION_NOT_EXTENDED
//
// MessageText:
//
//  A mapped section could not be extended.
//
#define STATUS_SECTION_NOT_EXTENDED      ((NTSTATUS)0xC0000087L)

//
// MessageId: STATUS_NOT_MAPPED_DATA
//
// MessageText:
//
//  Specified section to flush does not map a data file.
//
#define STATUS_NOT_MAPPED_DATA           ((NTSTATUS)0xC0000088L)

//
// MessageId: STATUS_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified image file did not contain a resource
//  section.
//
#define STATUS_RESOURCE_DATA_NOT_FOUND   ((NTSTATUS)0xC0000089L)

//
// MessageId: STATUS_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource type cannot be found in the
//  image file.
//
#define STATUS_RESOURCE_TYPE_NOT_FOUND   ((NTSTATUS)0xC000008AL)

//
// MessageId: STATUS_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource name cannot be found in the
//  image file.
//
#define STATUS_RESOURCE_NAME_NOT_FOUND   ((NTSTATUS)0xC000008BL)

//
// MessageId: STATUS_ARRAY_BOUNDS_EXCEEDED
//
// MessageText:
//
//  {EXCEPTION}
//  Array bounds exceeded.
//
#define STATUS_ARRAY_BOUNDS_EXCEEDED     ((NTSTATUS)0xC000008CL)    // winnt

//
// MessageId: STATUS_FLOAT_DENORMAL_OPERAND
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point denormal operand.
//
#define STATUS_FLOAT_DENORMAL_OPERAND    ((NTSTATUS)0xC000008DL)    // winnt

//
// MessageId: STATUS_FLOAT_DIVIDE_BY_ZERO
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point division by zero.
//
#define STATUS_FLOAT_DIVIDE_BY_ZERO      ((NTSTATUS)0xC000008EL)    // winnt

//
// MessageId: STATUS_FLOAT_INEXACT_RESULT
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point inexact result.
//
#define STATUS_FLOAT_INEXACT_RESULT      ((NTSTATUS)0xC000008FL)    // winnt

//
// MessageId: STATUS_FLOAT_INVALID_OPERATION
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point invalid operation.
//
#define STATUS_FLOAT_INVALID_OPERATION   ((NTSTATUS)0xC0000090L)    // winnt

//
// MessageId: STATUS_FLOAT_OVERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point overflow.
//
#define STATUS_FLOAT_OVERFLOW            ((NTSTATUS)0xC0000091L)    // winnt

//
// MessageId: STATUS_FLOAT_STACK_CHECK
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point stack check.
//
#define STATUS_FLOAT_STACK_CHECK         ((NTSTATUS)0xC0000092L)    // winnt

//
// MessageId: STATUS_FLOAT_UNDERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Floating-point underflow.
//
#define STATUS_FLOAT_UNDERFLOW           ((NTSTATUS)0xC0000093L)    // winnt

//
// MessageId: STATUS_INTEGER_DIVIDE_BY_ZERO
//
// MessageText:
//
//  {EXCEPTION}
//  Integer division by zero.
//
#define STATUS_INTEGER_DIVIDE_BY_ZERO    ((NTSTATUS)0xC0000094L)    // winnt

//
// MessageId: STATUS_INTEGER_OVERFLOW
//
// MessageText:
//
//  {EXCEPTION}
//  Integer overflow.
//
#define STATUS_INTEGER_OVERFLOW          ((NTSTATUS)0xC0000095L)    // winnt

//
// MessageId: STATUS_PRIVILEGED_INSTRUCTION
//
// MessageText:
//
//  {EXCEPTION}
//  Privileged instruction.
//
#define STATUS_PRIVILEGED_INSTRUCTION    ((NTSTATUS)0xC0000096L)    // winnt

//
// MessageId: STATUS_TOO_MANY_PAGING_FILES
//
// MessageText:
//
//  An attempt was made to install more paging files than the
//  system supports.
//
#define STATUS_TOO_MANY_PAGING_FILES     ((NTSTATUS)0xC0000097L)

//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  When a block of memory is allotted for future updates, such as the memory
//  allocated to hold discretionary access control and primary group information,
//  successive updates may exceed the amount of memory originally allotted.
//  Since quota may already have been charged to several processes which have
//  handles to the object, it is not reasonable to alter the size of the
//  allocated memory.  Instead, a request that requires more memory than has
//  been allotted must fail and the STATUS_ALLOTED_SPACE_EXCEEDED error returned.
//
#define STATUS_ALLOTTED_SPACE_EXCEEDED   ((NTSTATUS)0xC0000099L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth

//
// MessageId: STATUS_DFS_EXIT_PATH_FOUND
//
// MessageText:
//
//  An attempt has been made to open a DFS exit path control file.
//
#define STATUS_DFS_EXIT_PATH_FOUND       ((NTSTATUS)0xC000009BL)

//
// MessageId: STATUS_DEVICE_DATA_ERROR
//
// MessageText:
//
//  STATUS_DEVICE_DATA_ERROR
//
#define STATUS_DEVICE_DATA_ERROR         ((NTSTATUS)0xC000009CL)

//
// MessageId: STATUS_DEVICE_NOT_CONNECTED
//
// MessageText:
//
//  STATUS_DEVICE_NOT_CONNECTED
//
#define STATUS_DEVICE_NOT_CONNECTED      ((NTSTATUS)0xC000009DL)

//
// MessageId: STATUS_DEVICE_POWER_FAILURE
//
// MessageText:
//
//  STATUS_DEVICE_POWER_FAILURE
//
#define STATUS_DEVICE_POWER_FAILURE      ((NTSTATUS)0xC000009EL)

//
// MessageId: STATUS_FREE_VM_NOT_AT_BASE
//
// MessageText:
//
//  Virtual memory cannot be freed as base address is not the base
//  of the region and a region size of zero was specified.
//
#define STATUS_FREE_VM_NOT_AT_BASE       ((NTSTATUS)0xC000009FL)

//
// MessageId: STATUS_MEMORY_NOT_ALLOCATED
//
// MessageText:
//
//  An attempt was made to free virtual memory which is not allocated.
//
#define STATUS_MEMORY_NOT_ALLOCATED      ((NTSTATUS)0xC00000A0L)

//
// MessageId: STATUS_WORKING_SET_QUOTA
//
// MessageText:
//
//  The working set is not big enough to allow the requested pages to be
//  locked.
//
#define STATUS_WORKING_SET_QUOTA         ((NTSTATUS)0xC00000A1L)

//
// MessageId: STATUS_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
//  {Write Protect Error}
//  The disk cannot be written to because it is write protected.
//  Please remove the write protection from the volume %s in drive %s.
//
#define STATUS_MEDIA_WRITE_PROTECTED     ((NTSTATUS)0xC00000A2L)

//
// MessageId: STATUS_DEVICE_NOT_READY
//
// MessageText:
//
//  {Drive Not Ready}
//  The drive is not ready for use; its door may be open.
//  Please check drive %s and make sure that a disk is inserted
//  and that the drive door is closed.
//
#define STATUS_DEVICE_NOT_READY          ((NTSTATUS)0xC00000A3L)

//
// MessageId: STATUS_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//
#define STATUS_INVALID_GROUP_ATTRIBUTES  ((NTSTATUS)0xC00000A4L)

//
// MessageId: STATUS_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  A specified impersonation level is invalid.
//  Also used to indicate a required impersonation level was not provided.
//
#define STATUS_BAD_IMPERSONATION_LEVEL   ((NTSTATUS)0xC00000A5L)

//
// MessageId: STATUS_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  An attempt was made to open an Anonymous level token.
//  Anonymous tokens may not be opened.
//
#define STATUS_CANT_OPEN_ANONYMOUS       ((NTSTATUS)0xC00000A6L)

//
// MessageId: STATUS_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define STATUS_BAD_VALIDATION_CLASS      ((NTSTATUS)0xC00000A7L)

//
// MessageId: STATUS_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of a token object is inappropriate for its attempted use.
//
#define STATUS_BAD_TOKEN_TYPE            ((NTSTATUS)0xC00000A8L)

//
// MessageId: STATUS_BAD_MASTER_BOOT_RECORD
//
// MessageText:
//
//  The type of a token object is inappropriate for its attempted use.
//
#define STATUS_BAD_MASTER_BOOT_RECORD    ((NTSTATUS)0xC00000A9L)

//
// MessageId: STATUS_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
//  An attempt was made to execute an instruction at an unaligned address
//  and the host system does not support unaligned instruction references.
//
#define STATUS_INSTRUCTION_MISALIGNMENT  ((NTSTATUS)0xC00000AAL)

//
// MessageId: STATUS_INSTANCE_NOT_AVAILABLE
//
// MessageText:
//
//  The maximum named pipe instance count has been reached.
//
#define STATUS_INSTANCE_NOT_AVAILABLE    ((NTSTATUS)0xC00000ABL)

//
// MessageId: STATUS_PIPE_NOT_AVAILABLE
//
// MessageText:
//
//  An instance of a named pipe cannot be found in the listening state.
//
#define STATUS_PIPE_NOT_AVAILABLE        ((NTSTATUS)0xC00000ACL)

//
// MessageId: STATUS_INVALID_PIPE_STATE
//
// MessageText:
//
//  The named pipe is not in the connected or closing state.
//
#define STATUS_INVALID_PIPE_STATE        ((NTSTATUS)0xC00000ADL)

//
// MessageId: STATUS_PIPE_BUSY
//
// MessageText:
//
//  The specified pipe is set to complete operations and there are current
//  I/O operations queued so it cannot be changed to queue operations.
//
#define STATUS_PIPE_BUSY                 ((NTSTATUS)0xC00000AEL)

//
// MessageId: STATUS_ILLEGAL_FUNCTION
//
// MessageText:
//
//  The specified handle is not open to the server end of the named pipe.
//
#define STATUS_ILLEGAL_FUNCTION          ((NTSTATUS)0xC00000AFL)

//
// MessageId: STATUS_PIPE_DISCONNECTED
//
// MessageText:
//
//  The specified named pipe is in the disconnected state.
//
#define STATUS_PIPE_DISCONNECTED         ((NTSTATUS)0xC00000B0L)

//
// MessageId: STATUS_PIPE_CLOSING
//
// MessageText:
//
//  The specified named pipe is in the closing state.
//
#define STATUS_PIPE_CLOSING              ((NTSTATUS)0xC00000B1L)

//
// MessageId: STATUS_PIPE_CONNECTED
//
// MessageText:
//
//  The specified named pipe is in the connected state.
//
#define STATUS_PIPE_CONNECTED            ((NTSTATUS)0xC00000B2L)

//
// MessageId: STATUS_PIPE_LISTENING
//
// MessageText:
//
//  The specified named pipe is in the listening state.
//
#define STATUS_PIPE_LISTENING            ((NTSTATUS)0xC00000B3L)

//
// MessageId: STATUS_INVALID_READ_MODE
//
// MessageText:
//
//  The specified named pipe is not in message mode.
//
#define STATUS_INVALID_READ_MODE         ((NTSTATUS)0xC00000B4L)

//
// MessageId: STATUS_IO_TIMEOUT
//
// MessageText:
//
//  {Device Timeout}
//  The specified I/O operation on %s was not completed before the time-out
//  period expired.
//
#define STATUS_IO_TIMEOUT                ((NTSTATUS)0xC00000B5L)

//
// MessageId: STATUS_FILE_FORCED_CLOSED
//
// MessageText:
//
//  The specified file has been closed by another process.
//
#define STATUS_FILE_FORCED_CLOSED        ((NTSTATUS)0xC00000B6L)

//
// MessageId: STATUS_PROFILING_NOT_STARTED
//
// MessageText:
//
//  Profiling not started.
//
#define STATUS_PROFILING_NOT_STARTED     ((NTSTATUS)0xC00000B7L)

//
// MessageId: STATUS_PROFILING_NOT_STOPPED
//
// MessageText:
//
//  Profiling not stopped.
//
#define STATUS_PROFILING_NOT_STOPPED     ((NTSTATUS)0xC00000B8L)

//
// MessageId: STATUS_COULD_NOT_INTERPRET
//
// MessageText:
//
//  The passed ACL did not contain the minimum required information.
//
#define STATUS_COULD_NOT_INTERPRET       ((NTSTATUS)0xC00000B9L)

//
// MessageId: STATUS_FILE_IS_A_DIRECTORY
//
// MessageText:
//
//  The file that was specified as a target is a directory and the caller
//  specified that it could be anything but a directory.
//
#define STATUS_FILE_IS_A_DIRECTORY       ((NTSTATUS)0xC00000BAL)

//
// Network specific errors.
//
//
//
// MessageId: STATUS_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define STATUS_NOT_SUPPORTED             ((NTSTATUS)0xC00000BBL)

//
// MessageId: STATUS_REMOTE_NOT_LISTENING
//
// MessageText:
//
//  This remote computer is not listening.
//
#define STATUS_REMOTE_NOT_LISTENING      ((NTSTATUS)0xC00000BCL)

//
// MessageId: STATUS_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define STATUS_DUPLICATE_NAME            ((NTSTATUS)0xC00000BDL)

//
// MessageId: STATUS_BAD_NETWORK_PATH
//
// MessageText:
//
//  The network path cannot be located.
//
#define STATUS_BAD_NETWORK_PATH          ((NTSTATUS)0xC00000BEL)

//
// MessageId: STATUS_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define STATUS_NETWORK_BUSY              ((NTSTATUS)0xC00000BFL)

//
// MessageId: STATUS_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  This device does not exist.
//
#define STATUS_DEVICE_DOES_NOT_EXIST     ((NTSTATUS)0xC00000C0L)

//
// MessageId: STATUS_TOO_MANY_COMMANDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define STATUS_TOO_MANY_COMMANDS         ((NTSTATUS)0xC00000C1L)

//
// MessageId: STATUS_ADAPTER_HARDWARE_ERROR
//
// MessageText:
//
//  An I/O adapter hardware error has occurred.
//
#define STATUS_ADAPTER_HARDWARE_ERROR    ((NTSTATUS)0xC00000C2L)

//
// MessageId: STATUS_INVALID_NETWORK_RESPONSE
//
// MessageText:
//
//  The network responded incorrectly.
//
#define STATUS_INVALID_NETWORK_RESPONSE  ((NTSTATUS)0xC00000C3L)

//
// MessageId: STATUS_UNEXPECTED_NETWORK_ERROR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define STATUS_UNEXPECTED_NETWORK_ERROR  ((NTSTATUS)0xC00000C4L)

//
// MessageId: STATUS_BAD_REMOTE_ADAPTER
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define STATUS_BAD_REMOTE_ADAPTER        ((NTSTATUS)0xC00000C5L)

//
// MessageId: STATUS_PRINT_QUEUE_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define STATUS_PRINT_QUEUE_FULL          ((NTSTATUS)0xC00000C6L)

//
// MessageId: STATUS_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is not available on the server.
//
#define STATUS_NO_SPOOL_SPACE            ((NTSTATUS)0xC00000C7L)

//
// MessageId: STATUS_PRINT_CANCELLED
//
// MessageText:
//
//  The requested print file has been canceled.
//
#define STATUS_PRINT_CANCELLED           ((NTSTATUS)0xC00000C8L)

//
// MessageId: STATUS_NETWORK_NAME_DELETED
//
// MessageText:
//
//  The network name was deleted.
//
#define STATUS_NETWORK_NAME_DELETED      ((NTSTATUS)0xC00000C9L)

//
// MessageId: STATUS_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define STATUS_NETWORK_ACCESS_DENIED     ((NTSTATUS)0xC00000CAL)

//
// MessageId: STATUS_BAD_DEVICE_TYPE
//
// MessageText:
//
//  {Incorrect Network Resource Type}
//  The specified device type (LPT, for example) conflicts with the actual
//  device type on the remote resource.
//
#define STATUS_BAD_DEVICE_TYPE           ((NTSTATUS)0xC00000CBL)

//
// MessageId: STATUS_BAD_NETWORK_NAME
//
// MessageText:
//
//  {Network Name Not Found}
//  The specified share name cannot be found on the remote server.
//
#define STATUS_BAD_NETWORK_NAME          ((NTSTATUS)0xC00000CCL)

//
// MessageId: STATUS_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network adapter card was exceeded.
//
#define STATUS_TOO_MANY_NAMES            ((NTSTATUS)0xC00000CDL)

//
// MessageId: STATUS_TOO_MANY_SESSIONS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define STATUS_TOO_MANY_SESSIONS         ((NTSTATUS)0xC00000CEL)

//
// MessageId: STATUS_SHARING_PAUSED
//
// MessageText:
//
//  File sharing has been temporarily paused.
//
#define STATUS_SHARING_PAUSED            ((NTSTATUS)0xC00000CFL)

//
// MessageId: STATUS_REQUEST_NOT_ACCEPTED
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time
//  because there are already as many connections as the computer can accept.
//
#define STATUS_REQUEST_NOT_ACCEPTED      ((NTSTATUS)0xC00000D0L)

//
// MessageId: STATUS_REDIRECTOR_PAUSED
//
// MessageText:
//
//  Print or disk redirection is temporarily paused.
//
#define STATUS_REDIRECTOR_PAUSED         ((NTSTATUS)0xC00000D1L)

//
// MessageId: STATUS_NET_WRITE_FAULT
//
// MessageText:
//
//  A network data fault occurred.
//
#define STATUS_NET_WRITE_FAULT           ((NTSTATUS)0xC00000D2L)

//
// MessageId: STATUS_PROFILING_AT_LIMIT
//
// MessageText:
//
//  The number of active profiling objects is at the maximum and no more may be started.
//
#define STATUS_PROFILING_AT_LIMIT        ((NTSTATUS)0xC00000D3L)

//
// MessageId: STATUS_NOT_SAME_DEVICE
//
// MessageText:
//
//  {Incorrect Volume}
//  The target file of a rename request is located on a different device
//  than the source of the rename request.
//
#define STATUS_NOT_SAME_DEVICE           ((NTSTATUS)0xC00000D4L)

//
// MessageId: STATUS_FILE_RENAMED
//
// MessageText:
//
//  The file specified has been renamed and thus cannot be modified.
//
#define STATUS_FILE_RENAMED              ((NTSTATUS)0xC00000D5L)

//
// MessageId: STATUS_VIRTUAL_CIRCUIT_CLOSED
//
// MessageText:
//
//  {Network Request Timeout}
//  The session with a remote server has been disconnected because the time-out
//  interval for a request has expired.
//
#define STATUS_VIRTUAL_CIRCUIT_CLOSED    ((NTSTATUS)0xC00000D6L)

//
// MessageId: STATUS_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Indicates an attempt was made to operate on the security of
//  an object that does not have security associated with it.
//
#define STATUS_NO_SECURITY_ON_OBJECT     ((NTSTATUS)0xC00000D7L)

//
// MessageId: STATUS_CANT_WAIT
//
// MessageText:
//
//  Used to indicate that an operation cannot continue without blocking
//  for I/O.
//
#define STATUS_CANT_WAIT                 ((NTSTATUS)0xC00000D8L)

//
// MessageId: STATUS_PIPE_EMPTY
//
// MessageText:
//
//  Used to indicate that a read operation was done on an empty pipe.
//
#define STATUS_PIPE_EMPTY                ((NTSTATUS)0xC00000D9L)

//
// MessageId: STATUS_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Configuration information could not be read from the domain
//  controller, either because the machine is unavailable, or
//  access has been denied.
//
#define STATUS_CANT_ACCESS_DOMAIN_INFO   ((NTSTATUS)0xC00000DAL)

//
// MessageId: STATUS_CANT_TERMINATE_SELF
//
// MessageText:
//
//  Indicates that a thread attempted to terminate itself by default
//  (called NtTerminateThread with NULL) and it was the last thread
//  in the current process.
//
#define STATUS_CANT_TERMINATE_SELF       ((NTSTATUS)0xC00000DBL)

//
// MessageId: STATUS_INVALID_SERVER_STATE
//
// MessageText:
//
//  Indicates the Sam Server was in the wrong state to
//  perform the desired operation.
//
#define STATUS_INVALID_SERVER_STATE      ((NTSTATUS)0xC00000DCL)

//
// MessageId: STATUS_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  Indicates the Domain was in the wrong state to
//  perform the desired operation.
//
#define STATUS_INVALID_DOMAIN_STATE      ((NTSTATUS)0xC00000DDL)

//
// MessageId: STATUS_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define STATUS_INVALID_DOMAIN_ROLE       ((NTSTATUS)0xC00000DEL)

//
// MessageId: STATUS_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified Domain did not exist.
//
#define STATUS_NO_SUCH_DOMAIN            ((NTSTATUS)0xC00000DFL)

//
// MessageId: STATUS_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified Domain already exists.
//
#define STATUS_DOMAIN_EXISTS             ((NTSTATUS)0xC00000E0L)

//
// MessageId: STATUS_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server
//  for this release.
//
#define STATUS_DOMAIN_LIMIT_EXCEEDED     ((NTSTATUS)0xC00000E1L)

//
// MessageId: STATUS_OPLOCK_NOT_GRANTED
//
// MessageText:
//
//  Error status returned when oplock request is denied.
//
#define STATUS_OPLOCK_NOT_GRANTED        ((NTSTATUS)0xC00000E2L)

//
// MessageId: STATUS_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
//  Error status returned when an invalid oplock acknowledgment
//  is received by a file system.
//
#define STATUS_INVALID_OPLOCK_PROTOCOL   ((NTSTATUS)0xC00000E3L)

//
// MessageId: STATUS_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  This error indicates that the requested operation cannot be
//  completed due to a catastrophic media failure or on-disk data
//  structure corruption.
//
#define STATUS_INTERNAL_DB_CORRUPTION    ((NTSTATUS)0xC00000E4L)

//
// MessageId: STATUS_INTERNAL_ERROR
//
// MessageText:
//
//  This error indicates that the SAM server has encountered an
//  internal consistency error in its database.  This catastrophic
//  failure will prevent further operation of SAM.
//
#define STATUS_INTERNAL_ERROR            ((NTSTATUS)0xC00000E5L)

//
// MessageId: STATUS_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Indicates generic access types were contained in an access mask
//  which should already be mapped to non-generic access types.
//
#define STATUS_GENERIC_NOT_MAPPED        ((NTSTATUS)0xC00000E6L)

//
// MessageId: STATUS_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  Indicates a security descriptor is not in the necessary format (absolute
//  or self-relative).
//
#define STATUS_BAD_DESCRIPTOR_FORMAT     ((NTSTATUS)0xC00000E7L)

//
// Status codes raised by the Cache Manager which must be considered as
// "expected" by its callers.
//
//
// MessageId: STATUS_INVALID_USER_BUFFER
//
// MessageText:
//
//  An access to a user buffer failed at an "expected" point in time.
//  This code is defined since the caller does not want to accept
//  STATUS_ACCESS_VIOLATION in its filter.
//
#define STATUS_INVALID_USER_BUFFER       ((NTSTATUS)0xC00000E8L)

//
// MessageId: STATUS_UNEXPECTED_IO_ERROR
//
// MessageText:
//
//  If an I/O error is returned which is not defined in the standard FsRtl filter,
//  it is converted to the following error which is guaranteed to be in the
//  filter.  In this case information is lost, however, the filter correctly
//  handles the exception.
//
#define STATUS_UNEXPECTED_IO_ERROR       ((NTSTATUS)0xC00000E9L)

//
// MessageId: STATUS_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter,
//  it is converted to one of the following errors which is guaranteed to be in the
//  filter.  In this case information is lost, however, the filter correctly
//  handles the exception.
//
#define STATUS_UNEXPECTED_MM_CREATE_ERR  ((NTSTATUS)0xC00000EAL)

//
// MessageId: STATUS_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter,
//  it is converted to one of the following errors which is guaranteed to be in the
//  filter.  In this case information is lost, however, the filter correctly
//  handles the exception.
//
#define STATUS_UNEXPECTED_MM_MAP_ERROR   ((NTSTATUS)0xC00000EBL)

//
// MessageId: STATUS_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
//  If an MM error is returned which is not defined in the standard FsRtl filter,
//  it is converted to one of the following errors which is guaranteed to be in the
//  filter.  In this case information is lost, however, the filter correctly
//  handles the exception.
//
#define STATUS_UNEXPECTED_MM_EXTEND_ERR  ((NTSTATUS)0xC00000ECL)

//
// MessageId: STATUS_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//
#define STATUS_NOT_LOGON_PROCESS         ((NTSTATUS)0xC00000EDL)

//
// MessageId: STATUS_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  An attempt has been made to start a new session manager or
//  LSA logon session with an ID that is already in use.
//
#define STATUS_LOGON_SESSION_EXISTS      ((NTSTATUS)0xC00000EEL)

//
// MessageId: STATUS_INVALID_PARAMETER_1
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the first argument.
//
#define STATUS_INVALID_PARAMETER_1       ((NTSTATUS)0xC00000EFL)

//
// MessageId: STATUS_INVALID_PARAMETER_2
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the second argument.
//
#define STATUS_INVALID_PARAMETER_2       ((NTSTATUS)0xC00000F0L)

//
// MessageId: STATUS_INVALID_PARAMETER_3
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the third argument.
//
#define STATUS_INVALID_PARAMETER_3       ((NTSTATUS)0xC00000F1L)

//
// MessageId: STATUS_INVALID_PARAMETER_4
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fourth argument.
//
#define STATUS_INVALID_PARAMETER_4       ((NTSTATUS)0xC00000F2L)

//
// MessageId: STATUS_INVALID_PARAMETER_5
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fifth argument.
//
#define STATUS_INVALID_PARAMETER_5       ((NTSTATUS)0xC00000F3L)

//
// MessageId: STATUS_INVALID_PARAMETER_6
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the sixth argument.
//
#define STATUS_INVALID_PARAMETER_6       ((NTSTATUS)0xC00000F4L)

//
// MessageId: STATUS_INVALID_PARAMETER_7
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the seventh argument.
//
#define STATUS_INVALID_PARAMETER_7       ((NTSTATUS)0xC00000F5L)

//
// MessageId: STATUS_INVALID_PARAMETER_8
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eighth argument.
//
#define STATUS_INVALID_PARAMETER_8       ((NTSTATUS)0xC00000F6L)

//
// MessageId: STATUS_INVALID_PARAMETER_9
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the ninth argument.
//
#define STATUS_INVALID_PARAMETER_9       ((NTSTATUS)0xC00000F7L)

//
// MessageId: STATUS_INVALID_PARAMETER_10
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the tenth argument.
//
#define STATUS_INVALID_PARAMETER_10      ((NTSTATUS)0xC00000F8L)

//
// MessageId: STATUS_INVALID_PARAMETER_11
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eleventh argument.
//
#define STATUS_INVALID_PARAMETER_11      ((NTSTATUS)0xC00000F9L)

//
// MessageId: STATUS_INVALID_PARAMETER_12
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the twelfth argument.
//
#define STATUS_INVALID_PARAMETER_12      ((NTSTATUS)0xC00000FAL)

//
// MessageId: STATUS_REDIRECTOR_NOT_STARTED
//
// MessageText:
//
//   An attempt was made to access a network file, but the network software
//   was not yet started.
//
#define STATUS_REDIRECTOR_NOT_STARTED    ((NTSTATUS)0xC00000FBL)

//
// MessageId: STATUS_REDIRECTOR_STARTED
//
// MessageText:
//
//   An attempt was made to start the redirector, but the redirector
//   has already been started.
//
#define STATUS_REDIRECTOR_STARTED        ((NTSTATUS)0xC00000FCL)

//
// MessageId: STATUS_STACK_OVERFLOW
//
// MessageText:
//
//  A new guard page for the stack cannot be created.
//
#define STATUS_STACK_OVERFLOW            ((NTSTATUS)0xC00000FDL)    // winnt

//
// MessageId: STATUS_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define STATUS_NO_SUCH_PACKAGE           ((NTSTATUS)0xC00000FEL)

//
// MessageId: STATUS_BAD_FUNCTION_TABLE
//
// MessageText:
//
//  A malformed function table was encountered during an unwind operation.
//
#define STATUS_BAD_FUNCTION_TABLE        ((NTSTATUS)0xC00000FFL)

//
// MessageId: STATUS_VARIABLE_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified environment variable name was not found
//  in the specified environment block.
//
#define STATUS_VARIABLE_NOT_FOUND        ((NTSTATUS)0xC0000100L)

//
// MessageId: STATUS_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
//  Indicates that the directory trying to be deleted is not empty.
//
#define STATUS_DIRECTORY_NOT_EMPTY       ((NTSTATUS)0xC0000101L)

//
// MessageId: STATUS_FILE_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt File}
//  The file or directory %s is corrupt and unreadable.
//  Please run the Chkdsk utility.
//
#define STATUS_FILE_CORRUPT_ERROR        ((NTSTATUS)0xC0000102L)

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//
#define STATUS_NOT_A_DIRECTORY           ((NTSTATUS)0xC0000103L)

//
// MessageId: STATUS_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//
#define STATUS_BAD_LOGON_SESSION_STATE   ((NTSTATUS)0xC0000104L)

//
// MessageId: STATUS_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  An internal LSA error has occurred.  An authentication package has
//  requested the creation of a Logon Session but the ID of an already
//  existing Logon Session has been specified.
//
#define STATUS_LOGON_SESSION_COLLISION   ((NTSTATUS)0xC0000105L)

//
// MessageId: STATUS_NAME_TOO_LONG
//
// MessageText:
//
//  A specified name string is too long for its intended use.
//
#define STATUS_NAME_TOO_LONG             ((NTSTATUS)0xC0000106L)

//
// MessageId: STATUS_FILES_OPEN
//
// MessageText:
//
//  The user attempted to force close the files on a redirected
//  drive, but there were opened files on the drive, and the user
//  did not specify a sufficient level of force.
//
#define STATUS_FILES_OPEN                ((NTSTATUS)0xC0000107L)

//
// MessageId: STATUS_CONNECTION_IN_USE
//
// MessageText:
//
//  The user attempted to force close the files on a redirected
//  drive, but there were opened directories on the drive, and the user
//  did not specify a sufficient level of force.
//
#define STATUS_CONNECTION_IN_USE         ((NTSTATUS)0xC0000108L)

//
// MessageId: STATUS_MESSAGE_NOT_FOUND
//
// MessageText:
//
//  RtlFindMessage could not locate the requested message ID in the
//  message table resource.
//
#define STATUS_MESSAGE_NOT_FOUND         ((NTSTATUS)0xC0000109L)

//
// MessageId: STATUS_PROCESS_IS_TERMINATING
//
// MessageText:
//
//  An attempt was made to duplicate an object handle into or out
//  of an exiting process.
//
#define STATUS_PROCESS_IS_TERMINATING    ((NTSTATUS)0xC000010AL)

//
// MessageId: STATUS_INVALID_LOGON_TYPE
//
// MessageText:
//
//  Indicates an invalid value has been provided for the LogonType
//  requested.
//
#define STATUS_INVALID_LOGON_TYPE        ((NTSTATUS)0xC000010BL)

//
// MessageId: STATUS_NO_GUID_TRANSLATION
//
// MessageText:
//
//  Indicates that an attempt was made to assign protection to a
//  file system file or directory and one of the SIDs in the security
//  descriptor could not be translated into a GUID that could be stored
//  by the file system.
//  This causes the protection attempt to fail, which may cause a file
//  creation attempt to fail.
//
#define STATUS_NO_GUID_TRANSLATION       ((NTSTATUS)0xC000010CL)

//
// MessageId: STATUS_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Indicates that an attempt has been made to impersonate via a named
//  pipe that has not yet been read from.
//
#define STATUS_CANNOT_IMPERSONATE        ((NTSTATUS)0xC000010DL)

//
// MessageId: STATUS_IMAGE_ALREADY_LOADED
//
// MessageText:
//
//  Indicates that the specified image is already loaded.
//
#define STATUS_IMAGE_ALREADY_LOADED      ((NTSTATUS)0xC000010EL)


//
// ============================================================
// NOTE: The following ABIOS error code should be reserved on
//       non ABIOS kernel.  Eventually, I will remove the ifdef
//       ABIOS.
// ============================================================
//
//
// MessageId: STATUS_ABIOS_NOT_PRESENT
//
// MessageText:
//
//  STATUS_ABIOS_NOT_PRESENT
//
#define STATUS_ABIOS_NOT_PRESENT         ((NTSTATUS)0xC000010FL)

//
// MessageId: STATUS_ABIOS_LID_NOT_EXIST
//
// MessageText:
//
//  STATUS_ABIOS_LID_NOT_EXIST
//
#define STATUS_ABIOS_LID_NOT_EXIST       ((NTSTATUS)0xC0000110L)

//
// MessageId: STATUS_ABIOS_LID_ALREADY_OWNED
//
// MessageText:
//
//  STATUS_ABIOS_LID_ALREADY_OWNED
//
#define STATUS_ABIOS_LID_ALREADY_OWNED   ((NTSTATUS)0xC0000111L)

//
// MessageId: STATUS_ABIOS_NOT_LID_OWNER
//
// MessageText:
//
//  STATUS_ABIOS_NOT_LID_OWNER
//
#define STATUS_ABIOS_NOT_LID_OWNER       ((NTSTATUS)0xC0000112L)

//
// MessageId: STATUS_ABIOS_INVALID_COMMAND
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_COMMAND
//
#define STATUS_ABIOS_INVALID_COMMAND     ((NTSTATUS)0xC0000113L)

//
// MessageId: STATUS_ABIOS_INVALID_LID
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_LID
//
#define STATUS_ABIOS_INVALID_LID         ((NTSTATUS)0xC0000114L)

//
// MessageId: STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
// MessageText:
//
//  STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
#define STATUS_ABIOS_SELECTOR_NOT_AVAILABLE ((NTSTATUS)0xC0000115L)

//
// MessageId: STATUS_ABIOS_INVALID_SELECTOR
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_SELECTOR
//
#define STATUS_ABIOS_INVALID_SELECTOR    ((NTSTATUS)0xC0000116L)

//
// MessageId: STATUS_NO_LDT
//
// MessageText:
//
//  Indicates that an attempt was made to change the size of the LDT for
//  a process that has no LDT.
//
#define STATUS_NO_LDT                    ((NTSTATUS)0xC0000117L)

//
// MessageId: STATUS_INVALID_LDT_SIZE
//
// MessageText:
//
//  Indicates that an attempt was made to grow an LDT by setting its size,
//  or that the size was not an even number of selectors.
//
#define STATUS_INVALID_LDT_SIZE          ((NTSTATUS)0xC0000118L)

//
// MessageId: STATUS_INVALID_LDT_OFFSET
//
// MessageText:
//
//  Indicates that the starting value for the LDT information was not
//  an integral multiple of the selector size.
//
#define STATUS_INVALID_LDT_OFFSET        ((NTSTATUS)0xC0000119L)

//
// MessageId: STATUS_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
//  Indicates that the user supplied an invalid descriptor when trying
//  to set up Ldt descriptors.
//
#define STATUS_INVALID_LDT_DESCRIPTOR    ((NTSTATUS)0xC000011AL)

//
// MessageId: STATUS_INVALID_IMAGE_NE_FORMAT
//
// MessageText:
//
//  The specified image file did not have the correct format. It
//  appears to be NE format.
//
#define STATUS_INVALID_IMAGE_NE_FORMAT   ((NTSTATUS)0xC000011BL)

//
// MessageId: STATUS_RXACT_INVALID_STATE
//
// MessageText:
//
//  Indicates that the transaction state of a registry sub-tree is
//  incompatible with the requested operation.
//  For example, a request has been made to start a new transaction with
//  one already in progress, or a request has been made to apply a transaction
//  when one is not currently in progress.
//  This status value is returned by the runtime library (RTL) registry
//  transaction package (RXact).
//
#define STATUS_RXACT_INVALID_STATE       ((NTSTATUS)0xC000011CL)

//
// MessageId: STATUS_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  Indicates an error has occurred during a registry transaction commit.
//  The database has been left in an unknown, but probably inconsistent,
//  state.  The state of the registry transaction is left as COMMITTING.
//  This status value is returned by the runtime library (RTL) registry
//  transaction package (RXact).
//
#define STATUS_RXACT_COMMIT_FAILURE      ((NTSTATUS)0xC000011DL)

//
// MessageId: STATUS_MAPPED_FILE_SIZE_ZERO
//
// MessageText:
//
//  An attempt was made to map a file of size zero with the
//  maximum size specified as zero.
//
#define STATUS_MAPPED_FILE_SIZE_ZERO     ((NTSTATUS)0xC000011EL)

//
// MessageId: STATUS_TOO_MANY_OPENED_FILES
//
// MessageText:
//
//  Too many files are opened on a remote server.  This error should only
//  be returned by the NT redirector on a remote drive.
//
#define STATUS_TOO_MANY_OPENED_FILES     ((NTSTATUS)0xC000011FL)

//
// MessageId: STATUS_CANCELLED
//
// MessageText:
//
//  The I/O request was canceled.
//
#define STATUS_CANCELLED                 ((NTSTATUS)0xC0000120L)

//
// MessageId: STATUS_CANNOT_DELETE
//
// MessageText:
//
//  An attempt has been made to remove a file or directory that cannot
//  be deleted.
//
#define STATUS_CANNOT_DELETE             ((NTSTATUS)0xC0000121L)

//
// MessageId: STATUS_INVALID_COMPUTER_NAME
//
// MessageText:
//
//  Indicates a name specified as a remote computer name is syntactically
//  invalid.
//
#define STATUS_INVALID_COMPUTER_NAME     ((NTSTATUS)0xC0000122L)

//
// MessageId: STATUS_FILE_DELETED
//
// MessageText:
//
//  An I/O request other than close was performed on a file after it has
//  been deleted, which can only happen to a request which did not complete
//  before the last handle was closed via NtClose.
//
#define STATUS_FILE_DELETED              ((NTSTATUS)0xC0000123L)

//
// MessageId: STATUS_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Indicates an operation has been attempted on a built-in (special)
//  SAM account which is incompatible with built-in accounts.  For
//  example, built-in accounts cannot be deleted.
//
#define STATUS_SPECIAL_ACCOUNT           ((NTSTATUS)0xC0000124L)

//
// MessageId: STATUS_SPECIAL_GROUP
//
// MessageText:
//
//  The operation requested may not be performed on the specified
//  group because it is a built-in special group.
//
#define STATUS_SPECIAL_GROUP             ((NTSTATUS)0xC0000125L)

//
// MessageId: STATUS_SPECIAL_USER
//
// MessageText:
//
//  The operation requested may not be performed on the specified
//  user because it is a built-in special user.
//
#define STATUS_SPECIAL_USER              ((NTSTATUS)0xC0000126L)

//
// MessageId: STATUS_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  Indicates a member cannot be removed from a group because the
//  group is currently the member's primary group.
//
#define STATUS_MEMBERS_PRIMARY_GROUP     ((NTSTATUS)0xC0000127L)

//
// MessageId: STATUS_FILE_CLOSED
//
// MessageText:
//
//  An I/O request other than close and several other special case
//  operations was attempted using a file object that had already been
//  closed.
//
#define STATUS_FILE_CLOSED               ((NTSTATUS)0xC0000128L)

//
// MessageId: STATUS_TOO_MANY_THREADS
//
// MessageText:
//
//  Indicates a process has too many threads to perform the requested
//  action.  For example, assignment of a primary token may only be
//  performed when a process has zero or one threads.
//
#define STATUS_TOO_MANY_THREADS          ((NTSTATUS)0xC0000129L)

//
// MessageId: STATUS_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
//  An attempt was made to operate on a thread within a specific process,
//  but the thread specified is not in the process specified.
//
#define STATUS_THREAD_NOT_IN_PROCESS     ((NTSTATUS)0xC000012AL)

//
// MessageId: STATUS_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  An attempt was made to establish a token for use as a primary token
//  but the token is already in use.  A token can only be the primary token
//  of one process at a time.
//
#define STATUS_TOKEN_ALREADY_IN_USE      ((NTSTATUS)0xC000012BL)

//
// MessageId: STATUS_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
//  Page file quota was exceeded.
//
#define STATUS_PAGEFILE_QUOTA_EXCEEDED   ((NTSTATUS)0xC000012CL)

//
// MessageId: STATUS_COMMITMENT_LIMIT
//
// MessageText:
//
//  {Out of Virtual Memory}
//  Your system is running low on virtual memory. To free virtual memory immediately, close some open programs. To increase your system's virtual memory, increase the paging file size or create a new paging file.
//  
//  1. Right-click My Computer, click Properties, click the Advanced tab, and then click the Performance tab.
//  2. Under Virtual Memory, click Change. Under Drive [Volume Label], select the drive you want.
//  3. To increase the paging file size, click the Maximum Size (MB) box, and then type a larger paging file size.
//    -Or-
//     To create a new paging file, click the Initial Size (MB) box, and then type a paging file size.
//  
//  When you have finished, click Set, and then click OK.
//
#define STATUS_COMMITMENT_LIMIT          ((NTSTATUS)0xC000012DL)

//
// MessageId: STATUS_INVALID_IMAGE_LE_FORMAT
//
// MessageText:
//
//  The specified image file did not have the correct format, it
//  appears to be LE format.
//
#define STATUS_INVALID_IMAGE_LE_FORMAT   ((NTSTATUS)0xC000012EL)

//
// MessageId: STATUS_INVALID_IMAGE_NOT_MZ
//
// MessageText:
//
//  The specified image file did not have the correct format, it
//  did not have an initial MZ.
//
#define STATUS_INVALID_IMAGE_NOT_MZ      ((NTSTATUS)0xC000012FL)

//
// MessageId: STATUS_INVALID_IMAGE_PROTECT
//
// MessageText:
//
//  The specified image file did not have the correct format, it
//  did not have a proper e_lfarlc in the MZ header.
//
#define STATUS_INVALID_IMAGE_PROTECT     ((NTSTATUS)0xC0000130L)

//
// MessageId: STATUS_INVALID_IMAGE_WIN_16
//
// MessageText:
//
//  The specified image file did not have the correct format, it
//  appears to be a 16-bit Windows image.
//
#define STATUS_INVALID_IMAGE_WIN_16      ((NTSTATUS)0xC0000131L)

//
// MessageId: STATUS_LOGON_SERVER_CONFLICT
//
// MessageText:
//
//  The Netlogon service cannot start because another Netlogon service running
//  in the domain conflicts with the specified role.
//
#define STATUS_LOGON_SERVER_CONFLICT     ((NTSTATUS)0xC0000132L)

//
// MessageId: STATUS_TIME_DIFFERENCE_AT_DC
//
// MessageText:
//
//  The time at the Primary Domain Controller is different than the
//  time at the Backup Domain Controller or member server by too large
//  an amount.
//
#define STATUS_TIME_DIFFERENCE_AT_DC     ((NTSTATUS)0xC0000133L)

//
// MessageId: STATUS_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
//  The SAM database on a Windows NT Server is
//  significantly out of synchronization with the copy on the Domain
//  Controller.  A complete synchronization is required.
//
#define STATUS_SYNCHRONIZATION_REQUIRED  ((NTSTATUS)0xC0000134L)

//
// MessageId: STATUS_DLL_NOT_FOUND
//
// MessageText:
//
//  {Unable To Locate DLL}
//  The dynamic link library %s could not be found in the specified path %s.
//
#define STATUS_DLL_NOT_FOUND             ((NTSTATUS)0xC0000135L)

//
// MessageId: STATUS_OPEN_FAILED
//
// MessageText:
//
//  The NtCreateFile API failed.  This error should never be returned to an
//  application, it is a place holder for the NT Lan Manager Redirector to
//  use in its internal error mapping routines.
//
#define STATUS_OPEN_FAILED               ((NTSTATUS)0xC0000136L)

//
// MessageId: STATUS_IO_PRIVILEGE_FAILED
//
// MessageText:
//
//  {Privilege Failed}
//  The I/O permissions for the process could not be changed.
//
#define STATUS_IO_PRIVILEGE_FAILED       ((NTSTATUS)0xC0000137L)

//
// MessageId: STATUS_ORDINAL_NOT_FOUND
//
// MessageText:
//
//  {Ordinal Not Found}
//  The ordinal %ld could not be located in the dynamic link library %s.
//
#define STATUS_ORDINAL_NOT_FOUND         ((NTSTATUS)0xC0000138L)

//
// MessageId: STATUS_ENTRYPOINT_NOT_FOUND
//
// MessageText:
//
//  {Entry Point Not Found}
//  The procedure entry point %s could not be located in the dynamic link library %s.
//
#define STATUS_ENTRYPOINT_NOT_FOUND      ((NTSTATUS)0xC0000139L)

//
// MessageId: STATUS_CONTROL_C_EXIT
//
// MessageText:
//
//  {Application Exit by CTRL+C}
//  The application terminated as a result of a CTRL+C.
//
#define STATUS_CONTROL_C_EXIT            ((NTSTATUS)0xC000013AL)    // winnt

//
// MessageId: STATUS_LOCAL_DISCONNECT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on your computer has closed a network
//  connection. There may or may not be I/O requests outstanding.
//
#define STATUS_LOCAL_DISCONNECT          ((NTSTATUS)0xC000013BL)

//
// MessageId: STATUS_REMOTE_DISCONNECT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on a remote computer has closed a network
//  connection. There may or may not be I/O requests outstanding.
//
#define STATUS_REMOTE_DISCONNECT         ((NTSTATUS)0xC000013CL)

//
// MessageId: STATUS_REMOTE_RESOURCES
//
// MessageText:
//
//  {Insufficient Resources on Remote Computer}
//  The remote computer has insufficient resources to complete the
//  network request. For instance, there may not be enough memory
//  available on the remote computer to carry out the request at
//  this time.
//
#define STATUS_REMOTE_RESOURCES          ((NTSTATUS)0xC000013DL)

//
// MessageId: STATUS_LINK_FAILED
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  An existing connection (virtual circuit) has been broken at the
//  remote computer. There is probably something wrong with the
//  network software protocol or the network hardware on the
//  remote computer.
//
#define STATUS_LINK_FAILED               ((NTSTATUS)0xC000013EL)

//
// MessageId: STATUS_LINK_TIMEOUT
//
// MessageText:
//
//  {Virtual Circuit Closed}
//  The network transport on your computer has closed a network
//  connection because it had to wait too long for a response
//  from the remote computer.
//
#define STATUS_LINK_TIMEOUT              ((NTSTATUS)0xC000013FL)

//
// MessageId: STATUS_INVALID_CONNECTION
//
// MessageText:
//
//  The connection handle given to the transport was invalid.
//
#define STATUS_INVALID_CONNECTION        ((NTSTATUS)0xC0000140L)

//
// MessageId: STATUS_INVALID_ADDRESS
//
// MessageText:
//
//  The address handle given to the transport was invalid.
//
#define STATUS_INVALID_ADDRESS           ((NTSTATUS)0xC0000141L)

//
// MessageId: STATUS_DLL_INIT_FAILED
//
// MessageText:
//
//  {DLL Initialization Failed}
//  Initialization of the dynamic link library %s failed. The process is
//  terminating abnormally.
//
#define STATUS_DLL_INIT_FAILED           ((NTSTATUS)0xC0000142L)

//
// MessageId: STATUS_MISSING_SYSTEMFILE
//
// MessageText:
//
//  {Missing System File}
//  The required system file %s is bad or missing.
//
#define STATUS_MISSING_SYSTEMFILE        ((NTSTATUS)0xC0000143L)

//
// MessageId: STATUS_UNHANDLED_EXCEPTION
//
// MessageText:
//
//  {Application Error}
//  The exception %s (0x%08lx) occurred in the application at location 0x%08lx.
//
#define STATUS_UNHANDLED_EXCEPTION       ((NTSTATUS)0xC0000144L)

//
// MessageId: STATUS_APP_INIT_FAILURE
//
// MessageText:
//
//  {Application Error}
//  The application failed to initialize properly (0x%lx).  Click on OK to
//  terminate the application.
//
#define STATUS_APP_INIT_FAILURE          ((NTSTATUS)0xC0000145L)

//
// MessageId: STATUS_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
//  {Unable to Create Paging File}
//  The creation of the paging file %s failed (%lx). The requested size was %ld.
//
#define STATUS_PAGEFILE_CREATE_FAILED    ((NTSTATUS)0xC0000146L)

//
// MessageId: STATUS_NO_PAGEFILE
//
// MessageText:
//
//  {No Paging File Specified}
//  No paging file was specified in the system configuration.
//
#define STATUS_NO_PAGEFILE               ((NTSTATUS)0xC0000147L)

//
// MessageId: STATUS_INVALID_LEVEL
//
// MessageText:
//
//  {Incorrect System Call Level}
//  An invalid level was passed into the specified system call.
//
#define STATUS_INVALID_LEVEL             ((NTSTATUS)0xC0000148L)

//
// MessageId: STATUS_WRONG_PASSWORD_CORE
//
// MessageText:
//
//  {Incorrect Password to LAN Manager Server}
//  You specified an incorrect password to a LAN Manager 2.x or MS-NET server.
//
#define STATUS_WRONG_PASSWORD_CORE       ((NTSTATUS)0xC0000149L)

//
// MessageId: STATUS_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
//  {EXCEPTION}
//  A real-mode application issued a floating-point instruction and floating-point
//  hardware is not present.
//
#define STATUS_ILLEGAL_FLOAT_CONTEXT     ((NTSTATUS)0xC000014AL)

//
// MessageId: STATUS_PIPE_BROKEN
//
// MessageText:
//
//  The pipe operation has failed because the other end of the pipe has been
//  closed.
//
#define STATUS_PIPE_BROKEN               ((NTSTATUS)0xC000014BL)

//
// MessageId: STATUS_REGISTRY_CORRUPT
//
// MessageText:
//
//  {The Registry Is Corrupt}
//  The structure of one of the files that contains Registry data is corrupt, or
//  the image of the file in memory is corrupt, or the file could not
//  be recovered because the alternate copy or log was absent or corrupt.
//
#define STATUS_REGISTRY_CORRUPT          ((NTSTATUS)0xC000014CL)

//
// MessageId: STATUS_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the Registry failed unrecoverably.
//  The Registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the Registry.
//
#define STATUS_REGISTRY_IO_FAILED        ((NTSTATUS)0xC000014DL)

//
// MessageId: STATUS_NO_EVENT_PAIR
//
// MessageText:
//
//  An event pair synchronization operation was performed using the thread
//  specific client/server event pair object, but no event pair object was
//  associated with the thread.
//
#define STATUS_NO_EVENT_PAIR             ((NTSTATUS)0xC000014EL)

//
// MessageId: STATUS_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupt.
//
#define STATUS_UNRECOGNIZED_VOLUME       ((NTSTATUS)0xC000014FL)

//
// MessageId: STATUS_SERIAL_NO_DEVICE_INITED
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//
#define STATUS_SERIAL_NO_DEVICE_INITED   ((NTSTATUS)0xC0000150L)

//
// MessageId: STATUS_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define STATUS_NO_SUCH_ALIAS             ((NTSTATUS)0xC0000151L)

//
// MessageId: STATUS_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define STATUS_MEMBER_NOT_IN_ALIAS       ((NTSTATUS)0xC0000152L)

//
// MessageId: STATUS_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define STATUS_MEMBER_IN_ALIAS           ((NTSTATUS)0xC0000153L)

//
// MessageId: STATUS_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define STATUS_ALIAS_EXISTS              ((NTSTATUS)0xC0000154L)

//
// MessageId: STATUS_LOGON_NOT_GRANTED
//
// MessageText:
//
//  A requested type of logon (e.g., Interactive, Network, Service) is not
//  granted by the target system's local security policy.  Please ask the
//  system administrator to grant the necessary form of logon.
//
#define STATUS_LOGON_NOT_GRANTED         ((NTSTATUS)0xC0000155L)

//
// MessageId: STATUS_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.  The length and number of secrets is limited to satisfy United
//  States State Department export restrictions.
//
#define STATUS_TOO_MANY_SECRETS          ((NTSTATUS)0xC0000156L)

//
// MessageId: STATUS_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.  The length and
//  number of secrets is limited to satisfy United States State Department
//  export restrictions.
//
#define STATUS_SECRET_TOO_LONG           ((NTSTATUS)0xC0000157L)

//
// MessageId: STATUS_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The Local Security Authority (LSA) database contains an internal inconsistency.
//
#define STATUS_INTERNAL_DB_ERROR         ((NTSTATUS)0xC0000158L)

//
// MessageId: STATUS_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in fullscreen mode.
//
#define STATUS_FULLSCREEN_MODE           ((NTSTATUS)0xC0000159L)

//
// MessageId: STATUS_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.  This is a very unusual situation.  Remove the user from
//  some global or local groups to reduce the number of security ids to
//  incorporate into the security context.
//
#define STATUS_TOO_MANY_CONTEXT_IDS      ((NTSTATUS)0xC000015AL)

//
// MessageId: STATUS_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  A user has requested a type of logon (e.g., interactive or network) that
//  has not been granted.  An administrator has control over who may logon
//  interactively and through the network.
//
#define STATUS_LOGON_TYPE_NOT_GRANTED    ((NTSTATUS)0xC000015BL)

//
// MessageId: STATUS_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the registry, and the
//  specified file is not in the format of a registry file.
//
#define STATUS_NOT_REGISTRY_FILE         ((NTSTATUS)0xC000015CL)

//
// MessageId: STATUS_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  An attempt was made to change a user password in the security account manager
//  without providing the necessary NT cross-encrypted password.
//
#define STATUS_NT_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS)0xC000015DL)

//
// MessageId: STATUS_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
//  A Windows NT Server has incorrect configuration.
//
#define STATUS_DOMAIN_CTRLR_CONFIG_ERROR ((NTSTATUS)0xC000015EL)

//
// MessageId: STATUS_FT_MISSING_MEMBER
//
// MessageText:
//
//  An attempt was made to explicitly access the secondary copy of information
//  via a device control to the Fault Tolerance driver and the secondary copy
//  is not present in the system.
//
#define STATUS_FT_MISSING_MEMBER         ((NTSTATUS)0xC000015FL)

//
// MessageId: STATUS_ILL_FORMED_SERVICE_ENTRY
//
// MessageText:
//
//  A configuration registry node representing a driver service entry was ill-formed
//  and did not contain required value entries.
//
#define STATUS_ILL_FORMED_SERVICE_ENTRY  ((NTSTATUS)0xC0000160L)

//
// MessageId: STATUS_ILLEGAL_CHARACTER
//
// MessageText:
//
//  An illegal character was encountered.  For a multi-byte character set this
//  includes a lead byte without a succeeding trail byte.  For the Unicode character set
//  this includes the characters 0xFFFF and 0xFFFE.
//
#define STATUS_ILLEGAL_CHARACTER         ((NTSTATUS)0xC0000161L)

//
// MessageId: STATUS_UNMAPPABLE_CHARACTER
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define STATUS_UNMAPPABLE_CHARACTER      ((NTSTATUS)0xC0000162L)

//
// MessageId: STATUS_UNDEFINED_CHARACTER
//
// MessageText:
//
//  The Unicode character is not defined in the Unicode character set installed on
//  the system.
//
#define STATUS_UNDEFINED_CHARACTER       ((NTSTATUS)0xC0000163L)

//
// MessageId: STATUS_FLOPPY_VOLUME
//
// MessageText:
//
//  The paging file cannot be created on a floppy diskette.
//
#define STATUS_FLOPPY_VOLUME             ((NTSTATUS)0xC0000164L)

//
// MessageId: STATUS_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy disk, an ID address mark was not found.
//
#define STATUS_FLOPPY_ID_MARK_NOT_FOUND  ((NTSTATUS)0xC0000165L)

//
// MessageId: STATUS_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy disk, the track address from the sector ID field
//  was found to be different than the track address maintained by the controller.
//
#define STATUS_FLOPPY_WRONG_CYLINDER     ((NTSTATUS)0xC0000166L)

//
// MessageId: STATUS_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  {Floppy Disk Error}
//  The floppy disk controller reported an error that is not recognized by the
//  floppy disk driver.
//
#define STATUS_FLOPPY_UNKNOWN_ERROR      ((NTSTATUS)0xC0000167L)

//
// MessageId: STATUS_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  {Floppy Disk Error}
//  While accessing a floppy-disk, the controller returned inconsistent results
//  via its registers.
//
#define STATUS_FLOPPY_BAD_REGISTERS      ((NTSTATUS)0xC0000168L)

//
// MessageId: STATUS_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define STATUS_DISK_RECALIBRATE_FAILED   ((NTSTATUS)0xC0000169L)

//
// MessageId: STATUS_DISK_OPERATION_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define STATUS_DISK_OPERATION_FAILED     ((NTSTATUS)0xC000016AL)

//
// MessageId: STATUS_DISK_RESET_FAILED
//
// MessageText:
//
//  {Hard Disk Error}
//  While accessing the hard disk, a disk controller reset was needed, but even that failed.
//
#define STATUS_DISK_RESET_FAILED         ((NTSTATUS)0xC000016BL)

//
// MessageId: STATUS_SHARED_IRQ_BUSY
//
// MessageText:
//
//  An attempt was made to open a device that was sharing an IRQ with other devices.
//  At least one other device that uses that IRQ was already opened.  Two concurrent
//  opens of devices that share an IRQ and only work via interrupts is not supported
//  for the particular bus type that the devices use.
//
#define STATUS_SHARED_IRQ_BUSY           ((NTSTATUS)0xC000016CL)

//
// MessageId: STATUS_FT_ORPHANING
//
// MessageText:
//
//  {FT Orphaning}
//  A disk that is part of a fault-tolerant volume can no longer be accessed.
//
#define STATUS_FT_ORPHANING              ((NTSTATUS)0xC000016DL)

//
// MessageId: STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
//  The system bios failed to connect a system interrupt to the device or bus for
//  which the device is connected.
//
#define STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT ((NTSTATUS)0xC000016EL)

//
// MessageId: STATUS_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define STATUS_PARTITION_FAILURE         ((NTSTATUS)0xC0000172L)

//
// MessageId: STATUS_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//
#define STATUS_INVALID_BLOCK_LENGTH      ((NTSTATUS)0xC0000173L)

//
// MessageId: STATUS_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define STATUS_DEVICE_NOT_PARTITIONED    ((NTSTATUS)0xC0000174L)

//
// MessageId: STATUS_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Attempt to lock the eject media mechanism fails.
//
#define STATUS_UNABLE_TO_LOCK_MEDIA      ((NTSTATUS)0xC0000175L)

//
// MessageId: STATUS_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unload media fails.
//
#define STATUS_UNABLE_TO_UNLOAD_MEDIA    ((NTSTATUS)0xC0000176L)

//
// MessageId: STATUS_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape was detected.
//
#define STATUS_EOM_OVERFLOW              ((NTSTATUS)0xC0000177L)

//
// MessageId: STATUS_NO_MEDIA
//
// MessageText:
//
//  {No Media}
//  There is no media in the drive.
//  Please insert media into drive %s.
//
#define STATUS_NO_MEDIA                  ((NTSTATUS)0xC0000178L)

//
// MessageId: STATUS_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//
#define STATUS_NO_SUCH_MEMBER            ((NTSTATUS)0xC000017AL)

//
// MessageId: STATUS_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the
//  wrong account type.
//
#define STATUS_INVALID_MEMBER            ((NTSTATUS)0xC000017BL)

//
// MessageId: STATUS_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a registry key which has been marked for deletion.
//
#define STATUS_KEY_DELETED               ((NTSTATUS)0xC000017CL)

//
// MessageId: STATUS_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate required space in a registry log.
//
#define STATUS_NO_LOG_SPACE              ((NTSTATUS)0xC000017DL)

//
// MessageId: STATUS_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many Sids have been specified.
//
#define STATUS_TOO_MANY_SIDS             ((NTSTATUS)0xC000017EL)

//
// MessageId: STATUS_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  An attempt was made to change a user password in the security account manager
//  without providing the necessary LM cross-encrypted password.
//
#define STATUS_LM_CROSS_ENCRYPTION_REQUIRED ((NTSTATUS)0xC000017FL)

//
// MessageId: STATUS_KEY_HAS_CHILDREN
//
// MessageText:
//
//  An attempt was made to create a symbolic link in a registry key that already
//  has subkeys or values.
//
#define STATUS_KEY_HAS_CHILDREN          ((NTSTATUS)0xC0000180L)

//
// MessageId: STATUS_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  An attempt was made to create a Stable subkey under a Volatile parent key.
//
#define STATUS_CHILD_MUST_BE_VOLATILE    ((NTSTATUS)0xC0000181L)

//
// MessageId: STATUS_DEVICE_CONFIGURATION_ERROR
//
// MessageText:
//
//  The I/O device is configured incorrectly or the configuration parameters to the
//  driver are incorrect.
//
#define STATUS_DEVICE_CONFIGURATION_ERROR ((NTSTATUS)0xC0000182L)

//
// MessageId: STATUS_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
//  An error was detected between two drivers or within an I/O driver.
//
#define STATUS_DRIVER_INTERNAL_ERROR     ((NTSTATUS)0xC0000183L)

//
// MessageId: STATUS_INVALID_DEVICE_STATE
//
// MessageText:
//
//  The device is not in a valid state to perform this request.
//
#define STATUS_INVALID_DEVICE_STATE      ((NTSTATUS)0xC0000184L)

//
// MessageId: STATUS_IO_DEVICE_ERROR
//
// MessageText:
//
//  The I/O device reported an I/O error.
//
#define STATUS_IO_DEVICE_ERROR           ((NTSTATUS)0xC0000185L)

//
// MessageId: STATUS_DEVICE_PROTOCOL_ERROR
//
// MessageText:
//
//  A protocol error was detected between the driver and the device.
//
#define STATUS_DEVICE_PROTOCOL_ERROR     ((NTSTATUS)0xC0000186L)

//
// MessageId: STATUS_BACKUP_CONTROLLER
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define STATUS_BACKUP_CONTROLLER         ((NTSTATUS)0xC0000187L)

//
// MessageId: STATUS_LOG_FILE_FULL
//
// MessageText:
//
//  Log file space is insufficient to support this operation.
//
#define STATUS_LOG_FILE_FULL             ((NTSTATUS)0xC0000188L)

//
// MessageId: STATUS_TOO_LATE
//
// MessageText:
//
//  A write operation was attempted to a volume after it was dismounted.
//
#define STATUS_TOO_LATE                  ((NTSTATUS)0xC0000189L)

//
// MessageId: STATUS_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret for the primary domain in
//  the local LSA database.
//
#define STATUS_NO_TRUST_LSA_SECRET       ((NTSTATUS)0xC000018AL)

//
// MessageId: STATUS_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows NT Server does not have a computer
//  account for this workstation trust relationship.
//
#define STATUS_NO_TRUST_SAM_ACCOUNT      ((NTSTATUS)0xC000018BL)

//
// MessageId: STATUS_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The logon request failed because the trust relationship between the
//  primary domain and the trusted domain failed.
//
#define STATUS_TRUSTED_DOMAIN_FAILURE    ((NTSTATUS)0xC000018CL)

//
// MessageId: STATUS_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The logon request failed because the trust relationship between this
//  workstation and the primary domain failed.
//
#define STATUS_TRUSTED_RELATIONSHIP_FAILURE ((NTSTATUS)0xC000018DL)

//
// MessageId: STATUS_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The Eventlog log file is corrupt.
//
#define STATUS_EVENTLOG_FILE_CORRUPT     ((NTSTATUS)0xC000018EL)

//
// MessageId: STATUS_EVENTLOG_CANT_START
//
// MessageText:
//
//  No Eventlog log file could be opened.  The Eventlog service did not start.
//
#define STATUS_EVENTLOG_CANT_START       ((NTSTATUS)0xC000018FL)

//
// MessageId: STATUS_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed. This may be because the validation authority can't
//  be reached.
//
#define STATUS_TRUST_FAILURE             ((NTSTATUS)0xC0000190L)

//
// MessageId: STATUS_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to acquire a mutant such that its maximum count
//  would have been exceeded.
//
#define STATUS_MUTANT_LIMIT_EXCEEDED     ((NTSTATUS)0xC0000191L)

//
// MessageId: STATUS_NETLOGON_NOT_STARTED
//
// MessageText:
//
//   An attempt was made to logon, but the netlogon service was not started.
//
#define STATUS_NETLOGON_NOT_STARTED      ((NTSTATUS)0xC0000192L)

//
// MessageId: STATUS_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)    // ntsubauth

//
// MessageId: STATUS_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  {EXCEPTION}
//  Possible deadlock condition.
//
#define STATUS_POSSIBLE_DEADLOCK         ((NTSTATUS)0xC0000194L)

//
// MessageId: STATUS_NETWORK_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define STATUS_NETWORK_CREDENTIAL_CONFLICT ((NTSTATUS)0xC0000195L)

//
// MessageId: STATUS_REMOTE_SESSION_LIMIT
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there
//  are already too many sessions established to that server.
//
#define STATUS_REMOTE_SESSION_LIMIT      ((NTSTATUS)0xC0000196L)

//
// MessageId: STATUS_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The log file has changed between reads.
//
#define STATUS_EVENTLOG_FILE_CHANGED     ((NTSTATUS)0xC0000197L)

//
// MessageId: STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an Interdomain Trust account.  Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT ((NTSTATUS)0xC0000198L)

//
// MessageId: STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a Computer Account.  Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT ((NTSTATUS)0xC0000199L)

//
// MessageId: STATUS_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an Server Trust account.  Use your global user account or local user account to access this server.
//
#define STATUS_NOLOGON_SERVER_TRUST_ACCOUNT ((NTSTATUS)0xC000019AL)

//
// MessageId: STATUS_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or SID of the domain specified is inconsistent with the trust information for that domain.
//
#define STATUS_DOMAIN_TRUST_INCONSISTENT ((NTSTATUS)0xC000019BL)

//
// MessageId: STATUS_FS_DRIVER_REQUIRED
//
// MessageText:
//
//  A volume has been accessed for which a file system driver is required that has not yet been loaded.
//
#define STATUS_FS_DRIVER_REQUIRED        ((NTSTATUS)0xC000019CL)

//
// MessageId: STATUS_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define STATUS_NO_USER_SESSION_KEY       ((NTSTATUS)0xC0000202L)

//
// MessageId: STATUS_USER_SESSION_DELETED
//
// MessageText:
//
//  The remote user session has been deleted.
//
#define STATUS_USER_SESSION_DELETED      ((NTSTATUS)0xC0000203L)

//
// MessageId: STATUS_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  Indicates the specified resource language ID cannot be found in the
//  image file.
//
#define STATUS_RESOURCE_LANG_NOT_FOUND   ((NTSTATUS)0xC0000204L)

//
// MessageId: STATUS_INSUFF_SERVER_RESOURCES
//
// MessageText:
//
//  Insufficient server resources exist to complete the request.
//
#define STATUS_INSUFF_SERVER_RESOURCES   ((NTSTATUS)0xC0000205L)

//
// MessageId: STATUS_INVALID_BUFFER_SIZE
//
// MessageText:
//
//  The size of the buffer is invalid for the specified operation.
//
#define STATUS_INVALID_BUFFER_SIZE       ((NTSTATUS)0xC0000206L)

//
// MessageId: STATUS_INVALID_ADDRESS_COMPONENT
//
// MessageText:
//
//  The transport rejected the network address specified as invalid.
//
#define STATUS_INVALID_ADDRESS_COMPONENT ((NTSTATUS)0xC0000207L)

//
// MessageId: STATUS_INVALID_ADDRESS_WILDCARD
//
// MessageText:
//
//  The transport rejected the network address specified due to an
//  invalid use of a wildcard.
//
#define STATUS_INVALID_ADDRESS_WILDCARD  ((NTSTATUS)0xC0000208L)

//
// MessageId: STATUS_TOO_MANY_ADDRESSES
//
// MessageText:
//
//  The transport address could not be opened because all the available
//  addresses are in use.
//
#define STATUS_TOO_MANY_ADDRESSES        ((NTSTATUS)0xC0000209L)

//
// MessageId: STATUS_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
//  The transport address could not be opened because it already exists.
//
#define STATUS_ADDRESS_ALREADY_EXISTS    ((NTSTATUS)0xC000020AL)

//
// MessageId: STATUS_ADDRESS_CLOSED
//
// MessageText:
//
//  The transport address is now closed.
//
#define STATUS_ADDRESS_CLOSED            ((NTSTATUS)0xC000020BL)

//
// MessageId: STATUS_CONNECTION_DISCONNECTED
//
// MessageText:
//
//  The transport connection is now disconnected.
//
#define STATUS_CONNECTION_DISCONNECTED   ((NTSTATUS)0xC000020CL)

//
// MessageId: STATUS_CONNECTION_RESET
//
// MessageText:
//
//  The transport connection has been reset.
//
#define STATUS_CONNECTION_RESET          ((NTSTATUS)0xC000020DL)

//
// MessageId: STATUS_TOO_MANY_NODES
//
// MessageText:
//
//  The transport cannot dynamically acquire any more nodes.
//
#define STATUS_TOO_MANY_NODES            ((NTSTATUS)0xC000020EL)

//
// MessageId: STATUS_TRANSACTION_ABORTED
//
// MessageText:
//
//  The transport aborted a pending transaction.
//
#define STATUS_TRANSACTION_ABORTED       ((NTSTATUS)0xC000020FL)

//
// MessageId: STATUS_TRANSACTION_TIMED_OUT
//
// MessageText:
//
//  The transport timed out a request waiting for a response.
//
#define STATUS_TRANSACTION_TIMED_OUT     ((NTSTATUS)0xC0000210L)

//
// MessageId: STATUS_TRANSACTION_NO_RELEASE
//
// MessageText:
//
//  The transport did not receive a release for a pending response.
//
#define STATUS_TRANSACTION_NO_RELEASE    ((NTSTATUS)0xC0000211L)

//
// MessageId: STATUS_TRANSACTION_NO_MATCH
//
// MessageText:
//
//  The transport did not find a transaction matching the specific
//  token.
//
#define STATUS_TRANSACTION_NO_MATCH      ((NTSTATUS)0xC0000212L)

//
// MessageId: STATUS_TRANSACTION_RESPONDED
//
// MessageText:
//
//  The transport had previously responded to a transaction request.
//
#define STATUS_TRANSACTION_RESPONDED     ((NTSTATUS)0xC0000213L)

//
// MessageId: STATUS_TRANSACTION_INVALID_ID
//
// MessageText:
//
//  The transport does not recognized the transaction request
//  identifier specified.
//
#define STATUS_TRANSACTION_INVALID_ID    ((NTSTATUS)0xC0000214L)

//
// MessageId: STATUS_TRANSACTION_INVALID_TYPE
//
// MessageText:
//
//  The transport does not recognize the transaction request
//  type specified.
//
#define STATUS_TRANSACTION_INVALID_TYPE  ((NTSTATUS)0xC0000215L)

//
// MessageId: STATUS_NOT_SERVER_SESSION
//
// MessageText:
//
//  The transport can only process the specified request on
//  the server side of a session.
//
#define STATUS_NOT_SERVER_SESSION        ((NTSTATUS)0xC0000216L)

//
// MessageId: STATUS_NOT_CLIENT_SESSION
//
// MessageText:
//
//  The transport can only process the specified request on
//  the client side of a session.
//
#define STATUS_NOT_CLIENT_SESSION        ((NTSTATUS)0xC0000217L)

//
// MessageId: STATUS_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
//  {Registry File Failure}
//  The registry cannot load the hive (file):
//  %s
//  or its log or alternate.
//  It is corrupt, absent, or not writeable.
//
#define STATUS_CANNOT_LOAD_REGISTRY_FILE ((NTSTATUS)0xC0000218L)

//
// MessageId: STATUS_DEBUG_ATTACH_FAILED
//
// MessageText:
//
//  {Unexpected Failure in DebugActiveProcess}
//  An unexpected failure occurred while processing a DebugActiveProcess API
//  request.  You may choose OK to terminate the process, or Cancel to
//  ignore the error.
//
#define STATUS_DEBUG_ATTACH_FAILED       ((NTSTATUS)0xC0000219L)

//
// MessageId: STATUS_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
//  {Fatal System Error}
//  The %s system process terminated unexpectedly
//  with a status of 0x%08x (0x%08x 0x%08x).
//  The system has been shut down.
//
#define STATUS_SYSTEM_PROCESS_TERMINATED ((NTSTATUS)0xC000021AL)

//
// MessageId: STATUS_DATA_NOT_ACCEPTED
//
// MessageText:
//
//  {Data Not Accepted}
//  The TDI client could not handle the data received during an
//  indication.
//
#define STATUS_DATA_NOT_ACCEPTED         ((NTSTATUS)0xC000021BL)

//
// MessageId: STATUS_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  {Unable to Retrieve Browser Server List}
//  The list of servers for this workgroup is not currently available.
//
#define STATUS_NO_BROWSER_SERVERS_FOUND  ((NTSTATUS)0xC000021CL)

//
// MessageId: STATUS_VDM_HARD_ERROR
//
// MessageText:
//
//  NTVDM encountered a hard error.
//
#define STATUS_VDM_HARD_ERROR            ((NTSTATUS)0xC000021DL)

//
// MessageId: STATUS_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
//  {Cancel Timeout}
//  The driver %s failed to complete a cancelled I/O request in the allotted time.
//
#define STATUS_DRIVER_CANCEL_TIMEOUT     ((NTSTATUS)0xC000021EL)

//
// MessageId: STATUS_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
//  {Reply Message Mismatch}
//  An attempt was made to reply to an LPC message, but the thread specified
//  by the client ID in the message was not waiting on that message.
//
#define STATUS_REPLY_MESSAGE_MISMATCH    ((NTSTATUS)0xC000021FL)

//
// MessageId: STATUS_MAPPED_ALIGNMENT
//
// MessageText:
//
//  {Mapped View Aligment Incorrect}
//  An attempt was made to map a view of a file, but either the specified base
//  address or the offset into the file were not aligned on the proper
//  allocation granularity.
//
#define STATUS_MAPPED_ALIGNMENT          ((NTSTATUS)0xC0000220L)

//
// MessageId: STATUS_IMAGE_CHECKSUM_MISMATCH
//
// MessageText:
//
//  {Bad Image Checksum}
//  The image %s is possibly corrupt. The header checksum does not
//  match the computed checksum.
//
#define STATUS_IMAGE_CHECKSUM_MISMATCH   ((NTSTATUS)0xC0000221L)

//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
//  {Lost Delayed-Write Data}
//  The system was attempting to transfer file data from buffers to %s.
//  The write operation failed, and only some of the data may have been
//  written to the file.
//
#define STATUS_LOST_WRITEBEHIND_DATA     ((NTSTATUS)0xC0000222L)

//
// MessageId: STATUS_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
//  The parameter(s) passed to the server in the client/server shared memory
//  window were invalid. Too much data may have been put in the shared memory
//  window.
//
#define STATUS_CLIENT_SERVER_PARAMETERS_INVALID ((NTSTATUS)0xC0000223L)

//
// MessageId: STATUS_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user must change his password before he logs on the first time.
//
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)    // ntsubauth

//
// MessageId: STATUS_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define STATUS_NOT_FOUND                 ((NTSTATUS)0xC0000225L)

//
// MessageId: STATUS_NOT_TINY_STREAM
//
// MessageText:
//
//  The stream is not a tiny stream.
//
#define STATUS_NOT_TINY_STREAM           ((NTSTATUS)0xC0000226L)

//
// MessageId: STATUS_RECOVERY_FAILURE
//
// MessageText:
//
//  A transaction recover failed.
//
#define STATUS_RECOVERY_FAILURE          ((NTSTATUS)0xC0000227L)

//
// MessageId: STATUS_STACK_OVERFLOW_READ
//
// MessageText:
//
//  The request must be handled by the stack overflow code.
//
#define STATUS_STACK_OVERFLOW_READ       ((NTSTATUS)0xC0000228L)

//
// MessageId: STATUS_FAIL_CHECK
//
// MessageText:
//
//  A consistancy check failed.
//
#define STATUS_FAIL_CHECK                ((NTSTATUS)0xC0000229L)

//
// MessageId: STATUS_DUPLICATE_OBJECTID
//
// MessageText:
//
//  The attempt to insert the ID in the index failed because the
//  ID is already in the index.
//
#define STATUS_DUPLICATE_OBJECTID        ((NTSTATUS)0xC000022AL)

//
// MessageId: STATUS_OBJECTID_EXISTS
//
// MessageText:
//
//  The attempt to set the object's ID failed because the object
//  already has an ID.
//
#define STATUS_OBJECTID_EXISTS           ((NTSTATUS)0xC000022BL)

//
// MessageId: STATUS_CONVERT_TO_LARGE
//
// MessageText:
//
//  Internal OFS status codes indicating how an allocation operation is
//  handled.  Either it is retried after the containing onode is moved
//  or the extent stream is converted to a large stream.
//
#define STATUS_CONVERT_TO_LARGE          ((NTSTATUS)0xC000022CL)

//
// MessageId: STATUS_RETRY
//
// MessageText:
//
//  The request needs to be retried.
//
#define STATUS_RETRY                     ((NTSTATUS)0xC000022DL)

//
// MessageId: STATUS_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
//  The attempt to find the object found an object matching by ID
//  on the volume but it is out of the scope of the handle used
//  for the operation.
//
#define STATUS_FOUND_OUT_OF_SCOPE        ((NTSTATUS)0xC000022EL)

//
// MessageId: STATUS_ALLOCATE_BUCKET
//
// MessageText:
//
//  The bucket array must be grown.  Retry transaction after doing so.
//
#define STATUS_ALLOCATE_BUCKET           ((NTSTATUS)0xC000022FL)

//
// MessageId: STATUS_PROPSET_NOT_FOUND
//
// MessageText:
//
//  The property set specified does not exist on the object.
//
#define STATUS_PROPSET_NOT_FOUND         ((NTSTATUS)0xC0000230L)

//
// MessageId: STATUS_MARSHALL_OVERFLOW
//
// MessageText:
//
//  The user/kernel marshalling buffer has overflowed.
//
#define STATUS_MARSHALL_OVERFLOW         ((NTSTATUS)0xC0000231L)

//
// MessageId: STATUS_INVALID_VARIANT
//
// MessageText:
//
//  The supplied variant structure contains invalid data.
//
#define STATUS_INVALID_VARIANT           ((NTSTATUS)0xC0000232L)

//
// MessageId: STATUS_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find a domain controller for this domain.
//
#define STATUS_DOMAIN_CONTROLLER_NOT_FOUND ((NTSTATUS)0xC0000233L)

//
// MessageId: STATUS_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The user account has been automatically locked because too many invalid logon
//  attempts or password change attempts have been requested.
//
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)    // ntsubauth

//
// MessageId: STATUS_HANDLE_NOT_CLOSABLE
//
// MessageText:
//
//  NtClose was called on a handle that was protected from close via NtSetInformationObject.
//
#define STATUS_HANDLE_NOT_CLOSABLE       ((NTSTATUS)0xC0000235L)

//
// MessageId: STATUS_CONNECTION_REFUSED
//
// MessageText:
//
//  The transport connection attempt was refused by the remote system.
//
#define STATUS_CONNECTION_REFUSED        ((NTSTATUS)0xC0000236L)

//
// MessageId: STATUS_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The transport connection was gracefully closed.
//
#define STATUS_GRACEFUL_DISCONNECT       ((NTSTATUS)0xC0000237L)

//
// MessageId: STATUS_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The transport endpoint already has an address associated with it.
//
#define STATUS_ADDRESS_ALREADY_ASSOCIATED ((NTSTATUS)0xC0000238L)

//
// MessageId: STATUS_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the transport endpoint.
//
#define STATUS_ADDRESS_NOT_ASSOCIATED    ((NTSTATUS)0xC0000239L)

//
// MessageId: STATUS_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a nonexistent transport connection.
//
#define STATUS_CONNECTION_INVALID        ((NTSTATUS)0xC000023AL)

//
// MessageId: STATUS_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active transport connection.
//
#define STATUS_CONNECTION_ACTIVE         ((NTSTATUS)0xC000023BL)

//
// MessageId: STATUS_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//
#define STATUS_NETWORK_UNREACHABLE       ((NTSTATUS)0xC000023CL)

//
// MessageId: STATUS_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//
#define STATUS_HOST_UNREACHABLE          ((NTSTATUS)0xC000023DL)

//
// MessageId: STATUS_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//
#define STATUS_PROTOCOL_UNREACHABLE      ((NTSTATUS)0xC000023EL)

//
// MessageId: STATUS_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination port of the transport
//  on the remote system.
//
#define STATUS_PORT_UNREACHABLE          ((NTSTATUS)0xC000023FL)

//
// MessageId: STATUS_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//
#define STATUS_REQUEST_ABORTED           ((NTSTATUS)0xC0000240L)

//
// MessageId: STATUS_CONNECTION_ABORTED
//
// MessageText:
//
//  The transport connection was aborted by the local system.
//
#define STATUS_CONNECTION_ABORTED        ((NTSTATUS)0xC0000241L)

//
// MessageId: STATUS_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
//  The specified buffer contains ill-formed data.
//
#define STATUS_BAD_COMPRESSION_BUFFER    ((NTSTATUS)0xC0000242L)

//
// MessageId: STATUS_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user mapped section open.
//
#define STATUS_USER_MAPPED_FILE          ((NTSTATUS)0xC0000243L)

//
// MessageId: STATUS_AUDIT_FAILED
//
// MessageText:
//
//  {Audit Failed}
//  An attempt to generate a security audit failed.
//
#define STATUS_AUDIT_FAILED              ((NTSTATUS)0xC0000244L)

//
// MessageId: STATUS_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
//  The timer resolution was not previously set by the current process.
//
#define STATUS_TIMER_RESOLUTION_NOT_SET  ((NTSTATUS)0xC0000245L)

//
// MessageId: STATUS_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of
//  concurrent connections for this account has been reached.
//
#define STATUS_CONNECTION_COUNT_LIMIT    ((NTSTATUS)0xC0000246L)

//
// MessageId: STATUS_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to login during an unauthorized time of day for this account.
//
#define STATUS_LOGIN_TIME_RESTRICTION    ((NTSTATUS)0xC0000247L)

//
// MessageId: STATUS_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to login from this station.
//
#define STATUS_LOGIN_WKSTA_RESTRICTION   ((NTSTATUS)0xC0000248L)

//
// MessageId: STATUS_IMAGE_MP_UP_MISMATCH
//
// MessageText:
//
//  {UP/MP Image Mismatch}
//  The image %s has been modified for use on a uniprocessor system,
//  but you are running it on a multiprocessor machine.
//  Please reinstall the image file.
//
#define STATUS_IMAGE_MP_UP_MISMATCH      ((NTSTATUS)0xC0000249L)

//
// MessageId: STATUS_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
//  There is insufficient account information to log you on.
//
#define STATUS_INSUFFICIENT_LOGON_INFO   ((NTSTATUS)0xC0000250L)

//
// MessageId: STATUS_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
//  {Invalid DLL Entrypoint}
//  The dynamic link library %s is not written correctly. The stack pointer has been left in an inconsistent state.
//  The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue
//  execution. Selecting NO may cause the application to operate incorrectly.
//
#define STATUS_BAD_DLL_ENTRYPOINT        ((NTSTATUS)0xC0000251L)

//
// MessageId: STATUS_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
//  {Invalid Service Callback Entrypoint}
//  The %s service is not written correctly. The stack pointer has been left in an inconsistent state.
//  The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the
//  service to continue operation. However, the service process may operate incorrectly.
//
#define STATUS_BAD_SERVICE_ENTRYPOINT    ((NTSTATUS)0xC0000252L)

//
// MessageId: STATUS_LPC_REPLY_LOST
//
// MessageText:
//
//  The server received the messages but did not send a reply.
//
#define STATUS_LPC_REPLY_LOST            ((NTSTATUS)0xC0000253L)

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
//  The system has detected an IP address conflict with another system on the
//  network. The local interface has been disabled. More details are available in
//  the system event log. Consult your network administrator to resolve the
//  conflict.
//
#define STATUS_IP_ADDRESS_CONFLICT1      ((NTSTATUS)0xC0000254L)

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
//  The system has detected an IP address conflict with another system on the
//  network. Network operations on this system may be disrupted as a result.
//  More details are available in the system event log. Consult your network
//  administrator immediately to resolve the conflict.
//
#define STATUS_IP_ADDRESS_CONFLICT2      ((NTSTATUS)0xC0000255L)

//
// MessageId: STATUS_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
//  {Low on Registry Quota}
//  Your maximum registry size is too small. Right-click My Computer, click Properties, click the Advanced tab, then click the Performace button.
//  Under Virtual Memory, click Change, and then increase the maximum registry size.
//
#define STATUS_REGISTRY_QUOTA_LIMIT      ((NTSTATUS)0xC0000256L)

//
// MessageId: STATUS_PATH_NOT_COVERED
//
// MessageText:
//
//  The contacted server does not support the indicated part of the DFS namespace.
//
#define STATUS_PATH_NOT_COVERED          ((NTSTATUS)0xC0000257L)

//
// MessageId: STATUS_NO_CALLBACK_ACTIVE
//
// MessageText:
//
//  A callback return system service cannot be executed when no callback is active.
//
#define STATUS_NO_CALLBACK_ACTIVE        ((NTSTATUS)0xC0000258L)

//
// MessageId: STATUS_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of connections.
//  No more connections can be made to the service at this time
//  because there are already as many connections as the service can accept.
//
#define STATUS_LICENSE_QUOTA_EXCEEDED    ((NTSTATUS)0xC0000259L)

//
// MessageId: STATUS_PWD_TOO_SHORT
//
// MessageText:
//
//  The password provided is too short to meet the policy of your user account.
//  Please choose a longer password.
//
#define STATUS_PWD_TOO_SHORT             ((NTSTATUS)0xC000025AL)

//
// MessageId: STATUS_PWD_TOO_RECENT
//
// MessageText:
//
//  The policy of your user account does not allow you to change passwords too
//  frequently.  This is done to prevent users from changing back to a familiar, but
//  potentially discovered, password.  If you feel your password has been compromised
//  then please contact your administrator immediately to have a new one assigned.
//
#define STATUS_PWD_TOO_RECENT            ((NTSTATUS)0xC000025BL)

//
// MessageId: STATUS_PWD_HISTORY_CONFLICT
//
// MessageText:
//
//  You have attempted to change your password to one that you have used in the past.
//  The policy of your user account does not allow this.  Please select a password
//  that you have not previously used.
//
#define STATUS_PWD_HISTORY_CONFLICT      ((NTSTATUS)0xC000025CL)

//
// MessageId: STATUS_PLUGPLAY_NO_DEVICE
//
// MessageText:
//
//  You have attempted to load a legacy device driver while its device instance had
//  been disabled.
//
#define STATUS_PLUGPLAY_NO_DEVICE        ((NTSTATUS)0xC000025EL)

//
// MessageId: STATUS_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
//  The specified compression format is unsupported.
//
#define STATUS_UNSUPPORTED_COMPRESSION   ((NTSTATUS)0xC000025FL)

//
// MessageId: STATUS_INVALID_HW_PROFILE
//
// MessageText:
//
//  The specified hardware profile configuration is invalid.
//
#define STATUS_INVALID_HW_PROFILE        ((NTSTATUS)0xC0000260L)

//
// MessageId: STATUS_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
//  The specified Plug and Play registry device path is invalid.
//
#define STATUS_INVALID_PLUGPLAY_DEVICE_PATH ((NTSTATUS)0xC0000261L)

//
// MessageId: STATUS_DRIVER_ORDINAL_NOT_FOUND
//
// MessageText:
//
//  {Driver Entry Point Not Found}
//  The %s device driver could not locate the ordinal %ld in driver %s.
//
#define STATUS_DRIVER_ORDINAL_NOT_FOUND  ((NTSTATUS)0xC0000262L)

//
// MessageId: STATUS_DRIVER_ENTRYPOINT_NOT_FOUND
//
// MessageText:
//
//  {Driver Entry Point Not Found}
//  The %s device driver could not locate the entry point %s in driver %s.
//
#define STATUS_DRIVER_ENTRYPOINT_NOT_FOUND ((NTSTATUS)0xC0000263L)

//
// MessageId: STATUS_RESOURCE_NOT_OWNED
//
// MessageText:
//
//  {Application Error}
//  The application attempted to release a resource it did not own.  Click on OK to
//  terminate the application.
//
#define STATUS_RESOURCE_NOT_OWNED        ((NTSTATUS)0xC0000264L)

//
// MessageId: STATUS_TOO_MANY_LINKS
//
// MessageText:
//
//  An attempt was made to create more links on a file than
//  the file system supports.
//
#define STATUS_TOO_MANY_LINKS            ((NTSTATUS)0xC0000265L)

//
// MessageId: STATUS_QUOTA_LIST_INCONSISTENT
//
// MessageText:
//
//  The specified quota list is internally inconsistent with its descriptor.
//
#define STATUS_QUOTA_LIST_INCONSISTENT   ((NTSTATUS)0xC0000266L)

//
// MessageId: STATUS_FILE_IS_OFFLINE
//
// MessageText:
//
//  The specified file has been relocated to offline storage.
//
#define STATUS_FILE_IS_OFFLINE           ((NTSTATUS)0xC0000267L)

//
// MessageId: STATUS_EVALUATION_EXPIRATION
//
// MessageText:
//
//  {Windows NT Evaluation Notification}
//  The evaluation period for this installation of Windows NT has expired.
//  This system will shutdown in 1 hour. To restore access to this installation
//  of Windows NT, please upgrade this installation using a licensed distribution
//  of this product.
//
#define STATUS_EVALUATION_EXPIRATION     ((NTSTATUS)0xC0000268L)

//
// MessageId: STATUS_ILLEGAL_DLL_RELOCATION
//
// MessageText:
//
//  {Illegal System DLL Relocation}
//  The system DLL %s was relocated in memory. The application will not run properly.
//  The relocation occured because the DLL %s occupied an address range reserved for
//  Windows NT system DLL's. The vendor supplying the DLL should be contacted for a new DLL.
//
#define STATUS_ILLEGAL_DLL_RELOCATION    ((NTSTATUS)0xC0000269L)

//
// MessageId: STATUS_LICENSE_VIOLATION
//
// MessageText:
//
//  {License Violation}
//  The system has detected tampering with your registered product type. This is a violation
//  of your software license. Tampering with product type is not permitted.
//
#define STATUS_LICENSE_VIOLATION         ((NTSTATUS)0xC000026AL)

//
// MessageId: STATUS_DLL_INIT_FAILED_LOGOFF
//
// MessageText:
//
//  {DLL Initialization Failed}
//  The application failed to initialize because the window station is shutting down.
//
#define STATUS_DLL_INIT_FAILED_LOGOFF    ((NTSTATUS)0xC000026BL)

//
// MessageId: STATUS_DRIVER_UNABLE_TO_LOAD
//
// MessageText:
//
//  {Unable to Load Device Driver}
//  %s device driver could not be loaded.
//  Error Status was 0x%x
//
#define STATUS_DRIVER_UNABLE_TO_LOAD     ((NTSTATUS)0xC000026CL)

//
// MessageId: STATUS_DFS_UNAVAILABLE
//
// MessageText:
//
//  DFS is unavailable on the contacted server.
//
#define STATUS_DFS_UNAVAILABLE           ((NTSTATUS)0xC000026DL)

//
// MessageId: STATUS_VOLUME_DISMOUNTED
//
// MessageText:
//
//  An operation was attempted to a volume after it was dismounted.
//
#define STATUS_VOLUME_DISMOUNTED         ((NTSTATUS)0xC000026EL)

//
// MessageId: STATUS_WX86_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in the Win32 x86 emulation subsystem.
//
#define STATUS_WX86_INTERNAL_ERROR       ((NTSTATUS)0xC000026FL)

//
// MessageId: STATUS_WX86_FLOAT_STACK_CHECK
//
// MessageText:
//
//  Win32 x86 emulation subsystem Floating-point stack check.
//
#define STATUS_WX86_FLOAT_STACK_CHECK    ((NTSTATUS)0xC0000270L)

//
// MessageId: STATUS_VALIDATE_CONTINUE
//
// MessageText:
//
//  The validation process needs to continue on to the next step.
//
#define STATUS_VALIDATE_CONTINUE         ((NTSTATUS)0xC0000271L)

//
// MessageId: STATUS_NO_MATCH
//
// MessageText:
//
//  There was no match for the specified key in the index.
//
#define STATUS_NO_MATCH                  ((NTSTATUS)0xC0000272L)

//
// MessageId: STATUS_NO_MORE_MATCHES
//
// MessageText:
//
//  There are no more matches for the current index enumeration.
//
#define STATUS_NO_MORE_MATCHES           ((NTSTATUS)0xC0000273L)

//
// MessageId: STATUS_INVALID_VLM_OPERATION
//
// MessageText:
//
//  The specified Very Large Memory (64-bit Virtual Addressing) operation is invalid.
//
#define STATUS_INVALID_VLM_OPERATION     ((NTSTATUS)0xC0000274L)

//
// MessageId: STATUS_NOT_A_REPARSE_POINT
//
// MessageText:
//
//  The NTFS file or directory is not a reparse point.
//
#define STATUS_NOT_A_REPARSE_POINT       ((NTSTATUS)0xC0000275L)

//
// MessageId: STATUS_IO_REPARSE_TAG_INVALID
//
// MessageText:
//
//  The NT I/O reparse tag passed for the NTFS reparse point is invalid.
//
#define STATUS_IO_REPARSE_TAG_INVALID    ((NTSTATUS)0xC0000276L)

//
// MessageId: STATUS_IO_REPARSE_TAG_MISMATCH
//
// MessageText:
//
//  The NT I/O reparse tag does not match the one present in the NTFS reparse point.
//
#define STATUS_IO_REPARSE_TAG_MISMATCH   ((NTSTATUS)0xC0000277L)

//
// MessageId: STATUS_IO_REPARSE_DATA_INVALID
//
// MessageText:
//
//  The user data passed for the NTFS reparse point is invalid.
//
#define STATUS_IO_REPARSE_DATA_INVALID   ((NTSTATUS)0xC0000278L)

//
// MessageId: STATUS_IO_REPARSE_TAG_NOT_HANDLED
//
// MessageText:
//
//  The layered file system driver for this IO tag did not handle it when needed.
//
#define STATUS_IO_REPARSE_TAG_NOT_HANDLED ((NTSTATUS)0xC0000279L)

//
// MessageId: STATUS_REPARSE_POINT_NOT_RESOLVED
//
// MessageText:
//
//  The NTFS symbolic link could not be resolved even though the initial file name is valid.
//
#define STATUS_REPARSE_POINT_NOT_RESOLVED ((NTSTATUS)0xC0000280L)

//
// MessageId: STATUS_DIRECTORY_IS_A_REPARSE_POINT
//
// MessageText:
//
//  The NTFS directory is a reparse point.
//
#define STATUS_DIRECTORY_IS_A_REPARSE_POINT ((NTSTATUS)0xC0000281L)

//
// MessageId: STATUS_RANGE_LIST_CONFLICT
//
// MessageText:
//
//  The range could not be added to the range list because of a conflict.
//
#define STATUS_RANGE_LIST_CONFLICT       ((NTSTATUS)0xC0000282L)

//
// MessageId: STATUS_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
//  The specified medium changer source element contains no media.
//
#define STATUS_SOURCE_ELEMENT_EMPTY      ((NTSTATUS)0xC0000283L)

//
// MessageId: STATUS_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
//  The specified medium changer destination element already contains media.
//
#define STATUS_DESTINATION_ELEMENT_FULL  ((NTSTATUS)0xC0000284L)

//
// MessageId: STATUS_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
//  The specified medium changer element does not exist.
//
#define STATUS_ILLEGAL_ELEMENT_ADDRESS   ((NTSTATUS)0xC0000285L)

//
// MessageId: STATUS_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
//  The specified element is contained within a magazine that is no longer present.
//
#define STATUS_MAGAZINE_NOT_PRESENT      ((NTSTATUS)0xC0000286L)

//
// MessageId: STATUS_REINITIALIZATION_NEEDED
//
// MessageText:
//
//  The device requires reinitialization due to hardware errors.
//
#define STATUS_REINITIALIZATION_NEEDED   ((NTSTATUS)0xC0000287L)

//
// MessageId: STATUS_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
//  The device has indicated that cleaning is necessary.
//
#define STATUS_DEVICE_REQUIRES_CLEANING  ((NTSTATUS)0x80000288L)

//
// MessageId: STATUS_DEVICE_DOOR_OPEN
//
// MessageText:
//
//  The device has indicated that it's door is open. Further operations require it closed and secured.
//
#define STATUS_DEVICE_DOOR_OPEN          ((NTSTATUS)0x80000289L)

//
// MessageId: STATUS_ENCRYPTION_FAILED
//
// MessageText:
//
//  The file encryption attempt failed.
//
#define STATUS_ENCRYPTION_FAILED         ((NTSTATUS)0xC000028AL)

//
// MessageId: STATUS_DECRYPTION_FAILED
//
// MessageText:
//
//  The file decryption attempt failed.
//
#define STATUS_DECRYPTION_FAILED         ((NTSTATUS)0xC000028BL)

//
// MessageId: STATUS_RANGE_NOT_FOUND
//
// MessageText:
//
//  The specified range could not be found in the range list.
//
#define STATUS_RANGE_NOT_FOUND           ((NTSTATUS)0xC000028CL)

//
// MessageId: STATUS_NO_RECOVERY_POLICY
//
// MessageText:
//
//  There is no encryption recovery policy configured for this system.
//
#define STATUS_NO_RECOVERY_POLICY        ((NTSTATUS)0xC000028DL)

//
// MessageId: STATUS_NO_EFS
//
// MessageText:
//
//  The required encryption driver is not loaded for this system.
//
#define STATUS_NO_EFS                    ((NTSTATUS)0xC000028EL)

//
// MessageId: STATUS_WRONG_EFS
//
// MessageText:
//
//  The file was encrypted with a different encryption driver than is currently loaded.
//
#define STATUS_WRONG_EFS                 ((NTSTATUS)0xC000028FL)

//
// MessageId: STATUS_NO_USER_KEYS
//
// MessageText:
//
//  There are no EFS keys defined for the user.
//
#define STATUS_NO_USER_KEYS              ((NTSTATUS)0xC0000290L)

//
// MessageId: STATUS_FILE_NOT_ENCRYPTED
//
// MessageText:
//
//  The specified file is not encrypted.
//
#define STATUS_FILE_NOT_ENCRYPTED        ((NTSTATUS)0xC0000291L)

//
// MessageId: STATUS_NOT_EXPORT_FORMAT
//
// MessageText:
//
//  The specified file is not in the defined EFS export format.
//
#define STATUS_NOT_EXPORT_FORMAT         ((NTSTATUS)0xC0000292L)

//
// MessageId: STATUS_FILE_ENCRYPTED
//
// MessageText:
//
//  The specified file is encrypted and the user does not have the ability to decrypt it.
//
#define STATUS_FILE_ENCRYPTED            ((NTSTATUS)0xC0000293L)

//
// MessageId: STATUS_WAKE_SYSTEM
//
// MessageText:
//
//  The system has awoken
//
#define STATUS_WAKE_SYSTEM               ((NTSTATUS)0x40000294L)

//
// MessageId: STATUS_WMI_GUID_NOT_FOUND
//
// MessageText:
//
//  The guid passed was not recognized as valid by a WMI data provider.
//
#define STATUS_WMI_GUID_NOT_FOUND        ((NTSTATUS)0xC0000295L)

//
// MessageId: STATUS_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
//  The instance name passed was not recognized as valid by a WMI data provider.
//
#define STATUS_WMI_INSTANCE_NOT_FOUND    ((NTSTATUS)0xC0000296L)

//
// MessageId: STATUS_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
//  The data item id passed was not recognized as valid by a WMI data provider.
//
#define STATUS_WMI_ITEMID_NOT_FOUND      ((NTSTATUS)0xC0000297L)

//
// MessageId: STATUS_WMI_TRY_AGAIN
//
// MessageText:
//
//  The WMI request could not be completed and should be retried.
//
#define STATUS_WMI_TRY_AGAIN             ((NTSTATUS)0xC0000298L)

//
// MessageId: STATUS_SHARED_POLICY
//
// MessageText:
//
//  The policy object is shared and can only be modified at the root
//
#define STATUS_SHARED_POLICY             ((NTSTATUS)0xC0000299L)

//
// MessageId: STATUS_POLICY_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The policy object does not exist when it should
//
#define STATUS_POLICY_OBJECT_NOT_FOUND   ((NTSTATUS)0xC000029AL)

//
// MessageId: STATUS_POLICY_ONLY_IN_DS
//
// MessageText:
//
//  The requested policy information only lives in the Ds
//
#define STATUS_POLICY_ONLY_IN_DS         ((NTSTATUS)0xC000029BL)

//
// MessageId: STATUS_VOLUME_NOT_UPGRADED
//
// MessageText:
//
//  The volume must be upgraded to enable this feature
//
#define STATUS_VOLUME_NOT_UPGRADED       ((NTSTATUS)0xC000029CL)

//
// MessageId: STATUS_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
//  The remote storage service is not operational at this time.
//
#define STATUS_REMOTE_STORAGE_NOT_ACTIVE ((NTSTATUS)0xC000029DL)

//
// MessageId: STATUS_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
//  The remote storage service encountered a media error.
//
#define STATUS_REMOTE_STORAGE_MEDIA_ERROR ((NTSTATUS)0xC000029EL)

//
// MessageId: STATUS_NO_TRACKING_SERVICE
//
// MessageText:
//
//  The tracking (workstation) service is not running.
//
#define STATUS_NO_TRACKING_SERVICE       ((NTSTATUS)0xC000029FL)

//
// MessageId: STATUS_SERVER_SID_MISMATCH
//
// MessageText:
//
//  The server process is running under a SID different than that required by client.
//
#define STATUS_SERVER_SID_MISMATCH       ((NTSTATUS)0xC00002A0L)

//
// Directory Service specific Errors
//
//
// MessageId: STATUS_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
//  The specified directory service attribute or value does not exist.
//
#define STATUS_DS_NO_ATTRIBUTE_OR_VALUE  ((NTSTATUS)0xC00002A1L)

//
// MessageId: STATUS_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
//  The attribute syntax specified to the directory service is invalid.
//
#define STATUS_DS_INVALID_ATTRIBUTE_SYNTAX ((NTSTATUS)0xC00002A2L)

//
// MessageId: STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
//  The attribute type specified to the directory service is not defined.
//
#define STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED ((NTSTATUS)0xC00002A3L)

//
// MessageId: STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
//  The specified directory service attribute or value already exists.
//
#define STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS ((NTSTATUS)0xC00002A4L)

//
// MessageId: STATUS_DS_BUSY
//
// MessageText:
//
//  The directory service is busy.
//
#define STATUS_DS_BUSY                   ((NTSTATUS)0xC00002A5L)

//
// MessageId: STATUS_DS_UNAVAILABLE
//
// MessageText:
//
//  The directory service is not available.
//
#define STATUS_DS_UNAVAILABLE            ((NTSTATUS)0xC00002A6L)

//
// MessageId: STATUS_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
//  The directory service was unable to allocate a relative identifier.
//
#define STATUS_DS_NO_RIDS_ALLOCATED      ((NTSTATUS)0xC00002A7L)

//
// MessageId: STATUS_DS_NO_MORE_RIDS
//
// MessageText:
//
//  The directory service has exhausted the pool of relative identifiers.
//
#define STATUS_DS_NO_MORE_RIDS           ((NTSTATUS)0xC00002A8L)

//
// MessageId: STATUS_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
//  The requested operation could not be performed because the directory service is not the master
//  for that type of operation.
//
#define STATUS_DS_INCORRECT_ROLE_OWNER   ((NTSTATUS)0xC00002A9L)

//
// MessageId: STATUS_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
//  The directory service was unable to initialize the subsystem that allocates relative identifiers.
//
#define STATUS_DS_RIDMGR_INIT_ERROR      ((NTSTATUS)0xC00002AAL)

//
// MessageId: STATUS_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
//  The requested operation did not satisfy one or more constraints associated with
//  the class of the object.
//
#define STATUS_DS_OBJ_CLASS_VIOLATION    ((NTSTATUS)0xC00002ABL)

//
// MessageId: STATUS_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
//  The directory service can perform the requested operation only on a leaf object.
//
#define STATUS_DS_CANT_ON_NON_LEAF       ((NTSTATUS)0xC00002ACL)

//
// MessageId: STATUS_DS_CANT_ON_RDN
//
// MessageText:
//
//  The directory service cannot perform the requested operation on the
//  Relatively Defined Name (RDN) attribute of an object.
//
#define STATUS_DS_CANT_ON_RDN            ((NTSTATUS)0xC00002ADL)

//
// MessageId: STATUS_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
//  The directory service detected an attempt to modify the object class of an object.
//
#define STATUS_DS_CANT_MOD_OBJ_CLASS     ((NTSTATUS)0xC00002AEL)

//
// MessageId: STATUS_DS_CROSS_DOM_MOVE_FAILED
//
// MessageText:
//
//  An error occured while performing a cross domain move operation.
//
#define STATUS_DS_CROSS_DOM_MOVE_FAILED  ((NTSTATUS)0xC00002AFL)

//
// MessageId: STATUS_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
//  Unable to Contact the Global Catalog Server.
//
#define STATUS_DS_GC_NOT_AVAILABLE       ((NTSTATUS)0xC00002B0L)

//
// MessageId: STATUS_DIRECTORY_SERVICE_REQUIRED
//
// MessageText:
//
//  The requested operation requires a directory service, and none was available.
//
#define STATUS_DIRECTORY_SERVICE_REQUIRED ((NTSTATUS)0xC00002B1L)

//
// MessageId: STATUS_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
//  The reparse attribute cannot be set as it is incompatible with an existing attribute.
//
#define STATUS_REPARSE_ATTRIBUTE_CONFLICT ((NTSTATUS)0xC00002B2L)

//
// MessageId: STATUS_CANT_ENABLE_DENY_ONLY
//
// MessageText:
//
//  A group marked use for deny only  can not be enabled.
//
#define STATUS_CANT_ENABLE_DENY_ONLY     ((NTSTATUS)0xC00002B3L)

//
// MessageId: STATUS_FLOAT_MULTIPLE_FAULTS
//
// MessageText:
//
//  {EXCEPTION}
//  Multiple floating point faults.
//
#define STATUS_FLOAT_MULTIPLE_FAULTS     ((NTSTATUS)0xC00002B4L)    // winnt

//
// MessageId: STATUS_FLOAT_MULTIPLE_TRAPS
//
// MessageText:
//
//  {EXCEPTION}
//  Multiple floating point traps.
//
#define STATUS_FLOAT_MULTIPLE_TRAPS      ((NTSTATUS)0xC00002B5L)    // winnt

//
// MessageId: STATUS_DEVICE_REMOVED
//
// MessageText:
//
//  The device has been removed.
//
#define STATUS_DEVICE_REMOVED            ((NTSTATUS)0xC00002B6L)

//
// MessageId: STATUS_JOURNAL_DELETE_IN_PROGRESS
//
// MessageText:
//
//  The volume change journal is being deleted.
//
#define STATUS_JOURNAL_DELETE_IN_PROGRESS ((NTSTATUS)0xC00002B7L)

//
// MessageId: STATUS_JOURNAL_NOT_ACTIVE
//
// MessageText:
//
//  The volume change journal service is not active.
//
#define STATUS_JOURNAL_NOT_ACTIVE        ((NTSTATUS)0xC00002B8L)

//
// MessageId: STATUS_NOINTERFACE
//
// MessageText:
//
//  The requested interface is not supported.
//
#define STATUS_NOINTERFACE               ((NTSTATUS)0xC00002B9L)

//
// MessageId: STATUS_ILLEGAL_VLM_REFERENCE
//
// MessageText:
//
//  {EXCEPTION}
//  VLM Alignment Fault
//  A misaligned or illegal reference was made to a 64-bit VLM address
//
#define STATUS_ILLEGAL_VLM_REFERENCE     ((NTSTATUS)0xC00002C0L)     // winnt

//
// MessageId: STATUS_DS_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  A directory service resource limit has been exceeded.
//
#define STATUS_DS_ADMIN_LIMIT_EXCEEDED   ((NTSTATUS)0xC00002C1L)

//
// MessageId: STATUS_DRIVER_FAILED_SLEEP
//
// MessageText:
//
//  {System Standby Failed}
//  The system cannot go to standby mode because the driver %s
//  failed the request to standby.
//
#define STATUS_DRIVER_FAILED_SLEEP       ((NTSTATUS)0xC00002C2L)

//
// MessageId: STATUS_MUTUAL_AUTHENTICATION_FAILED
//
// MessageText:
//
//  Mutual Authentication failed. The server's password is out of date
//  at the domain controller.
//
#define STATUS_MUTUAL_AUTHENTICATION_FAILED ((NTSTATUS)0xC00002C3L)

//
// MessageId: STATUS_CORRUPT_SYSTEM_FILE
//
// MessageText:
//
//  The system file %1 has become corrupt and has been replaced.
//
#define STATUS_CORRUPT_SYSTEM_FILE       ((NTSTATUS)0xC00002C4L)

//
// MessageId: STATUS_DATATYPE_MISALIGNMENT_ERROR
//
// MessageText:
//
//  {EXCEPTION}
//  Alignment Error
//  A datatype misalignment error was detected in a load or store instruction.
//
#define STATUS_DATATYPE_MISALIGNMENT_ERROR ((NTSTATUS)0xC00002C5L)    

//
// MessageId: STATUS_WMI_READ_ONLY
//
// MessageText:
//
//  The WMI data item or data block is read only.
//
#define STATUS_WMI_READ_ONLY             ((NTSTATUS)0xC00002C6L)

//
// MessageId: STATUS_WMI_SET_FAILURE
//
// MessageText:
//
//  The WMI data item or data block could not be changed.
//
#define STATUS_WMI_SET_FAILURE           ((NTSTATUS)0xC00002C7L)

//
// MessageId: STATUS_COMMITMENT_MINIMUM
//
// MessageText:
//
//  {Virtual Memory Minimum Too Low}
//  Your system is running low on virtual memory. The system will automatically increase this for you, but some applications may have their memory requests denied while this automatic increase is ongoing.  To avoid this in the future, increase the initial paging file size or create a new paging file.
//  
//  1. Right-click My Computer, click Properties, click the Advanced tab, and then click the Performance tab.
//  2. Under Virtual Memory, click Change. Under Drive [Volume Label], select the drive you want.
//  3. To increase the paging file size, click the Initial Size (MB) box, and then type a larger paging file size.
//    -Or-
//     To create a new paging file, click the Initial Size (MB) box, and then type a paging file size.
//  
//  When you have finished, click Set, and then click OK.
//
#define STATUS_COMMITMENT_MINIMUM        ((NTSTATUS)0xC00002C8L)

//
// MessageId: STATUS_REG_NAT_CONSUMPTION
//
// MessageText:
//
//  {EXCEPTION}
//  Register NaT consumption faults.
//  A NaT value is consumed on a non speculative instruction.
//
#define STATUS_REG_NAT_CONSUMPTION       ((NTSTATUS)0xC00002C9L)    // winnt

//
// MessageId: STATUS_TRANSPORT_FULL
//
// MessageText:
//
//  The medium changer's tranport element contains media, which is causing the operation to fail.
//
#define STATUS_TRANSPORT_FULL            ((NTSTATUS)0xC00002CAL)

//
// MessageId: STATUS_SAM_INIT_FAILURE
//
// MessageText:
//
//  Security Accounts Manager initialization failed because of the following error:
//  %s
//  Error Status: 0x%x
//  Please click OK to shutdown this system and select Safe Mode during next reboot, check the event log for more detailed information.
//
#define STATUS_SAM_INIT_FAILURE          ((NTSTATUS)0xC00002CBL)

//
// MessageId: STATUS_STACK_BUFFER_OVERRUN
//
// MessageText:
//
//  The system detected an overrun of a stack-based buffer in this application.  This
//  overrun could potentially allow a malicious user to gain control of this application.
//
#define STATUS_STACK_BUFFER_OVERRUN      ((NTSTATUS)0xC0000409L)

//
// MessageId: STATUS_WOW_ASSERTION
//
// MessageText:
//
//  WOW Assertion Error.
//
#define STATUS_WOW_ASSERTION             ((NTSTATUS)0xC0009898L)

// MessageId: STATUS_INVALID_SIGNATURE
//
// MessageText:
//
// The cryptographic signature is invalid.
//
#define STATUS_INVALID_SIGNATURE         ((NTSTATUS)0xC000A000L)

//
// MessageId: STATUS_HMAC_NOT_SUPPORTED
//
// MessageText:
//
// The cryptographic provider does not support HMAC.
//
#define STATUS_HMAC_NOT_SUPPORTED        ((NTSTATUS)0xC000A001L)

//
// MessageId: STATUS_AUTH_TAG_MISMATCH
//
// MessageText:
//
// The computed authentication tag did not match the input authentication tag.
//
#define STATUS_AUTH_TAG_MISMATCH         ((NTSTATUS)0xC000A002L)

/*++

 MessageId's 0xa010 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*/
//
// MessageId: STATUS_IPSEC_QUEUE_OVERFLOW
//
// MessageText:
//
// The IPSEC queue overflowed.
//
#define STATUS_IPSEC_QUEUE_OVERFLOW      ((NTSTATUS)0xC000A010L)

//
// MessageId: STATUS_ND_QUEUE_OVERFLOW
//
// MessageText:
//
// The neighbor discovery queue overflowed.
//
#define STATUS_ND_QUEUE_OVERFLOW         ((NTSTATUS)0xC000A011L)

//
// MessageId: STATUS_HOPLIMIT_EXCEEDED
//
// MessageText:
//
// An ICMP hop limit exceeded error was received.
//
#define STATUS_HOPLIMIT_EXCEEDED         ((NTSTATUS)0xC000A012L)

//
// MessageId: STATUS_PROTOCOL_NOT_SUPPORTED
//
// MessageText:
//
// The protocol is not installed on the local machine.
//
#define STATUS_PROTOCOL_NOT_SUPPORTED    ((NTSTATUS)0xC000A013L)

//
// MessageId: STATUS_FASTPATH_REJECTED
//
// MessageText:
//
// An operation or data has been rejected while on the network fast path.
//
#define STATUS_FASTPATH_REJECTED         ((NTSTATUS)0xC000A014L)

/*++

 MessageId's 0xa014 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*/
//
// MessageId: RPC_NT_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//
#define RPC_NT_INVALID_STRING_BINDING    ((NTSTATUS)0xC0020001L)

//
// MessageId: RPC_NT_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//
#define RPC_NT_WRONG_KIND_OF_BINDING     ((NTSTATUS)0xC0020002L)

//
// MessageId: RPC_NT_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//
#define RPC_NT_INVALID_BINDING           ((NTSTATUS)0xC0020003L)

//
// MessageId: RPC_NT_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//
#define RPC_NT_PROTSEQ_NOT_SUPPORTED     ((NTSTATUS)0xC0020004L)

//
// MessageId: RPC_NT_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//
#define RPC_NT_INVALID_RPC_PROTSEQ       ((NTSTATUS)0xC0020005L)

//
// MessageId: RPC_NT_INVALID_STRING_UUID
//
// MessageText:
//
//  The string UUID is invalid.
//
#define RPC_NT_INVALID_STRING_UUID       ((NTSTATUS)0xC0020006L)

//
// MessageId: RPC_NT_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//
#define RPC_NT_INVALID_ENDPOINT_FORMAT   ((NTSTATUS)0xC0020007L)

//
// MessageId: RPC_NT_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//
#define RPC_NT_INVALID_NET_ADDR          ((NTSTATUS)0xC0020008L)

//
// MessageId: RPC_NT_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//
#define RPC_NT_NO_ENDPOINT_FOUND         ((NTSTATUS)0xC0020009L)

//
// MessageId: RPC_NT_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//
#define RPC_NT_INVALID_TIMEOUT           ((NTSTATUS)0xC002000AL)

//
// MessageId: RPC_NT_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object UUID was not found.
//
#define RPC_NT_OBJECT_NOT_FOUND          ((NTSTATUS)0xC002000BL)

//
// MessageId: RPC_NT_ALREADY_REGISTERED
//
// MessageText:
//
//  The object UUID has already been registered.
//
#define RPC_NT_ALREADY_REGISTERED        ((NTSTATUS)0xC002000CL)

//
// MessageId: RPC_NT_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type UUID has already been registered.
//
#define RPC_NT_TYPE_ALREADY_REGISTERED   ((NTSTATUS)0xC002000DL)

//
// MessageId: RPC_NT_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//
#define RPC_NT_ALREADY_LISTENING         ((NTSTATUS)0xC002000EL)

//
// MessageId: RPC_NT_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//
#define RPC_NT_NO_PROTSEQS_REGISTERED    ((NTSTATUS)0xC002000FL)

//
// MessageId: RPC_NT_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//
#define RPC_NT_NOT_LISTENING             ((NTSTATUS)0xC0020010L)

//
// MessageId: RPC_NT_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//
#define RPC_NT_UNKNOWN_MGR_TYPE          ((NTSTATUS)0xC0020011L)

//
// MessageId: RPC_NT_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//
#define RPC_NT_UNKNOWN_IF                ((NTSTATUS)0xC0020012L)

//
// MessageId: RPC_NT_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//
#define RPC_NT_NO_BINDINGS               ((NTSTATUS)0xC0020013L)

//
// MessageId: RPC_NT_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//
#define RPC_NT_NO_PROTSEQS               ((NTSTATUS)0xC0020014L)

//
// MessageId: RPC_NT_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//
#define RPC_NT_CANT_CREATE_ENDPOINT      ((NTSTATUS)0xC0020015L)

//
// MessageId: RPC_NT_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//
#define RPC_NT_OUT_OF_RESOURCES          ((NTSTATUS)0xC0020016L)

//
// MessageId: RPC_NT_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//
#define RPC_NT_SERVER_UNAVAILABLE        ((NTSTATUS)0xC0020017L)

//
// MessageId: RPC_NT_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//
#define RPC_NT_SERVER_TOO_BUSY           ((NTSTATUS)0xC0020018L)

//
// MessageId: RPC_NT_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//
#define RPC_NT_INVALID_NETWORK_OPTIONS   ((NTSTATUS)0xC0020019L)

//
// MessageId: RPC_NT_NO_CALL_ACTIVE
//
// MessageText:
//
//  There are no remote procedure calls active on this thread.
//
#define RPC_NT_NO_CALL_ACTIVE            ((NTSTATUS)0xC002001AL)

//
// MessageId: RPC_NT_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//
#define RPC_NT_CALL_FAILED               ((NTSTATUS)0xC002001BL)

//
// MessageId: RPC_NT_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//
#define RPC_NT_CALL_FAILED_DNE           ((NTSTATUS)0xC002001CL)

//
// MessageId: RPC_NT_PROTOCOL_ERROR
//
// MessageText:
//
//  An RPC protocol error occurred.
//
#define RPC_NT_PROTOCOL_ERROR            ((NTSTATUS)0xC002001DL)

//
// MessageId: RPC_NT_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//
#define RPC_NT_UNSUPPORTED_TRANS_SYN     ((NTSTATUS)0xC002001FL)

//
// MessageId: RPC_NT_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The type UUID is not supported.
//
#define RPC_NT_UNSUPPORTED_TYPE          ((NTSTATUS)0xC0020021L)

//
// MessageId: RPC_NT_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//
#define RPC_NT_INVALID_TAG               ((NTSTATUS)0xC0020022L)

//
// MessageId: RPC_NT_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//
#define RPC_NT_INVALID_BOUND             ((NTSTATUS)0xC0020023L)

//
// MessageId: RPC_NT_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//
#define RPC_NT_NO_ENTRY_NAME             ((NTSTATUS)0xC0020024L)

//
// MessageId: RPC_NT_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//
#define RPC_NT_INVALID_NAME_SYNTAX       ((NTSTATUS)0xC0020025L)

//
// MessageId: RPC_NT_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//
#define RPC_NT_UNSUPPORTED_NAME_SYNTAX   ((NTSTATUS)0xC0020026L)

//
// MessageId: RPC_NT_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a UUID.
//
#define RPC_NT_UUID_NO_ADDRESS           ((NTSTATUS)0xC0020028L)

//
// MessageId: RPC_NT_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//
#define RPC_NT_DUPLICATE_ENDPOINT        ((NTSTATUS)0xC0020029L)

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//
#define RPC_NT_UNKNOWN_AUTHN_TYPE        ((NTSTATUS)0xC002002AL)

//
// MessageId: RPC_NT_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//
#define RPC_NT_MAX_CALLS_TOO_SMALL       ((NTSTATUS)0xC002002BL)

//
// MessageId: RPC_NT_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//
#define RPC_NT_STRING_TOO_LONG           ((NTSTATUS)0xC002002CL)

//
// MessageId: RPC_NT_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//
#define RPC_NT_PROTSEQ_NOT_FOUND         ((NTSTATUS)0xC002002DL)

//
// MessageId: RPC_NT_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//
#define RPC_NT_PROCNUM_OUT_OF_RANGE      ((NTSTATUS)0xC002002EL)

//
// MessageId: RPC_NT_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//
#define RPC_NT_BINDING_HAS_NO_AUTH       ((NTSTATUS)0xC002002FL)

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//
#define RPC_NT_UNKNOWN_AUTHN_SERVICE     ((NTSTATUS)0xC0020030L)

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//
#define RPC_NT_UNKNOWN_AUTHN_LEVEL       ((NTSTATUS)0xC0020031L)

//
// MessageId: RPC_NT_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//
#define RPC_NT_INVALID_AUTH_IDENTITY     ((NTSTATUS)0xC0020032L)

//
// MessageId: RPC_NT_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//
#define RPC_NT_UNKNOWN_AUTHZ_SERVICE     ((NTSTATUS)0xC0020033L)

//
// MessageId: EPT_NT_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//
#define EPT_NT_INVALID_ENTRY             ((NTSTATUS)0xC0020034L)

//
// MessageId: EPT_NT_CANT_PERFORM_OP
//
// MessageText:
//
//  The operation cannot be performed.
//
#define EPT_NT_CANT_PERFORM_OP           ((NTSTATUS)0xC0020035L)

//
// MessageId: EPT_NT_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//
#define EPT_NT_NOT_REGISTERED            ((NTSTATUS)0xC0020036L)

//
// MessageId: RPC_NT_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//
#define RPC_NT_NOTHING_TO_EXPORT         ((NTSTATUS)0xC0020037L)

//
// MessageId: RPC_NT_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//
#define RPC_NT_INCOMPLETE_NAME           ((NTSTATUS)0xC0020038L)

//
// MessageId: RPC_NT_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//
#define RPC_NT_INVALID_VERS_OPTION       ((NTSTATUS)0xC0020039L)

//
// MessageId: RPC_NT_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//
#define RPC_NT_NO_MORE_MEMBERS           ((NTSTATUS)0xC002003AL)

//
// MessageId: RPC_NT_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//
#define RPC_NT_NOT_ALL_OBJS_UNEXPORTED   ((NTSTATUS)0xC002003BL)

//
// MessageId: RPC_NT_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//
#define RPC_NT_INTERFACE_NOT_FOUND       ((NTSTATUS)0xC002003CL)

//
// MessageId: RPC_NT_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//
#define RPC_NT_ENTRY_ALREADY_EXISTS      ((NTSTATUS)0xC002003DL)

//
// MessageId: RPC_NT_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//
#define RPC_NT_ENTRY_NOT_FOUND           ((NTSTATUS)0xC002003EL)

//
// MessageId: RPC_NT_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//
#define RPC_NT_NAME_SERVICE_UNAVAILABLE  ((NTSTATUS)0xC002003FL)

//
// MessageId: RPC_NT_INVALID_NAF_ID
//
// MessageText:
//
//  The network address family is invalid.
//
#define RPC_NT_INVALID_NAF_ID            ((NTSTATUS)0xC0020040L)

//
// MessageId: RPC_NT_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//
#define RPC_NT_CANNOT_SUPPORT            ((NTSTATUS)0xC0020041L)

//
// MessageId: RPC_NT_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//
#define RPC_NT_NO_CONTEXT_AVAILABLE      ((NTSTATUS)0xC0020042L)

//
// MessageId: RPC_NT_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in RPC.
//
#define RPC_NT_INTERNAL_ERROR            ((NTSTATUS)0xC0020043L)

//
// MessageId: RPC_NT_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer divide by zero.
//
#define RPC_NT_ZERO_DIVIDE               ((NTSTATUS)0xC0020044L)

//
// MessageId: RPC_NT_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//
#define RPC_NT_ADDRESS_ERROR             ((NTSTATUS)0xC0020045L)

//
// MessageId: RPC_NT_FP_DIV_ZERO
//
// MessageText:
//
//  A floating point operation at the RPC server caused a divide by zero.
//
#define RPC_NT_FP_DIV_ZERO               ((NTSTATUS)0xC0020046L)

//
// MessageId: RPC_NT_FP_UNDERFLOW
//
// MessageText:
//
//  A floating point underflow occurred at the RPC server.
//
#define RPC_NT_FP_UNDERFLOW              ((NTSTATUS)0xC0020047L)

//
// MessageId: RPC_NT_FP_OVERFLOW
//
// MessageText:
//
//  A floating point overflow occurred at the RPC server.
//
#define RPC_NT_FP_OVERFLOW               ((NTSTATUS)0xC0020048L)

//
// MessageId: RPC_NT_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for auto-handle binding has been exhausted.
//
#define RPC_NT_NO_MORE_ENTRIES           ((NTSTATUS)0xC0030001L)

//
// MessageId: RPC_NT_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  The file designated by DCERPCCHARTRANS cannot be opened.
//
#define RPC_NT_SS_CHAR_TRANS_OPEN_FAIL   ((NTSTATUS)0xC0030002L)

//
// MessageId: RPC_NT_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//
#define RPC_NT_SS_CHAR_TRANS_SHORT_FILE  ((NTSTATUS)0xC0030003L)

//
// MessageId: RPC_NT_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle is passed as an [in] parameter.
//
#define RPC_NT_SS_IN_NULL_CONTEXT        ((NTSTATUS)0xC0030004L)

//
// MessageId: RPC_NT_SS_CONTEXT_MISMATCH
//
// MessageText:
//
//  The context handle does not match any known context handles.
//
#define RPC_NT_SS_CONTEXT_MISMATCH       ((NTSTATUS)0xC0030005L)

//
// MessageId: RPC_NT_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a call.
//
#define RPC_NT_SS_CONTEXT_DAMAGED        ((NTSTATUS)0xC0030006L)

//
// MessageId: RPC_NT_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//
#define RPC_NT_SS_HANDLES_MISMATCH       ((NTSTATUS)0xC0030007L)

//
// MessageId: RPC_NT_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the call handle.
//
#define RPC_NT_SS_CANNOT_GET_CALL_HANDLE ((NTSTATUS)0xC0030008L)

//
// MessageId: RPC_NT_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//
#define RPC_NT_NULL_REF_POINTER          ((NTSTATUS)0xC0030009L)

//
// MessageId: RPC_NT_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//
#define RPC_NT_ENUM_VALUE_OUT_OF_RANGE   ((NTSTATUS)0xC003000AL)

//
// MessageId: RPC_NT_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//
#define RPC_NT_BYTE_COUNT_TOO_SMALL      ((NTSTATUS)0xC003000BL)

//
// MessageId: RPC_NT_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//
#define RPC_NT_BAD_STUB_DATA             ((NTSTATUS)0xC003000CL)

//
// MessageId: RPC_NT_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//
#define RPC_NT_CALL_IN_PROGRESS          ((NTSTATUS)0xC0020049L)

//
// MessageId: RPC_NT_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//
#define RPC_NT_NO_MORE_BINDINGS          ((NTSTATUS)0xC002004AL)

//
// MessageId: RPC_NT_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//
#define RPC_NT_GROUP_MEMBER_NOT_FOUND    ((NTSTATUS)0xC002004BL)

//
// MessageId: EPT_NT_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database entry could not be created.
//
#define EPT_NT_CANT_CREATE               ((NTSTATUS)0xC002004CL)

//
// MessageId: RPC_NT_INVALID_OBJECT
//
// MessageText:
//
//  The object UUID is the nil UUID.
//
#define RPC_NT_INVALID_OBJECT            ((NTSTATUS)0xC002004DL)

//
// MessageId: RPC_NT_NO_INTERFACES
//
// MessageText:
//
//  No interfaces have been registered.
//
#define RPC_NT_NO_INTERFACES             ((NTSTATUS)0xC002004FL)

//
// MessageId: RPC_NT_CALL_CANCELLED
//
// MessageText:
//
//  The remote procedure call was cancelled.
//
#define RPC_NT_CALL_CANCELLED            ((NTSTATUS)0xC0020050L)

//
// MessageId: RPC_NT_BINDING_INCOMPLETE
//
// MessageText:
//
//  The binding handle does not contain all required information.
//
#define RPC_NT_BINDING_INCOMPLETE        ((NTSTATUS)0xC0020051L)

//
// MessageId: RPC_NT_COMM_FAILURE
//
// MessageText:
//
//  A communications failure occurred during a remote procedure call.
//
#define RPC_NT_COMM_FAILURE              ((NTSTATUS)0xC0020052L)

//
// MessageId: RPC_NT_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
//  The requested authentication level is not supported.
//
#define RPC_NT_UNSUPPORTED_AUTHN_LEVEL   ((NTSTATUS)0xC0020053L)

//
// MessageId: RPC_NT_NO_PRINC_NAME
//
// MessageText:
//
//  No principal name registered.
//
#define RPC_NT_NO_PRINC_NAME             ((NTSTATUS)0xC0020054L)

//
// MessageId: RPC_NT_NOT_RPC_ERROR
//
// MessageText:
//
//  The error specified is not a valid Windows NT RPC error code.
//
#define RPC_NT_NOT_RPC_ERROR             ((NTSTATUS)0xC0020055L)

//
// MessageId: RPC_NT_UUID_LOCAL_ONLY
//
// MessageText:
//
//  A UUID that is valid only on this computer has been allocated.
//
#define RPC_NT_UUID_LOCAL_ONLY           ((NTSTATUS)0x40020056L)

//
// MessageId: RPC_NT_SEC_PKG_ERROR
//
// MessageText:
//
//  A security package specific error occurred.
//
#define RPC_NT_SEC_PKG_ERROR             ((NTSTATUS)0xC0020057L)

//
// MessageId: RPC_NT_NOT_CANCELLED
//
// MessageText:
//
//  Thread is not cancelled.
//
#define RPC_NT_NOT_CANCELLED             ((NTSTATUS)0xC0020058L)

//
// MessageId: RPC_NT_INVALID_ES_ACTION
//
// MessageText:
//
//  Invalid operation on the encoding/decoding handle.
//
#define RPC_NT_INVALID_ES_ACTION         ((NTSTATUS)0xC0030059L)

//
// MessageId: RPC_NT_WRONG_ES_VERSION
//
// MessageText:
//
//  Incompatible version of the serializing package.
//
#define RPC_NT_WRONG_ES_VERSION          ((NTSTATUS)0xC003005AL)

//
// MessageId: RPC_NT_WRONG_STUB_VERSION
//
// MessageText:
//
//  Incompatible version of the RPC stub.
//
#define RPC_NT_WRONG_STUB_VERSION        ((NTSTATUS)0xC003005BL)

//
// MessageId: RPC_NT_INVALID_PIPE_OBJECT
//
// MessageText:
//
//  The RPC pipe object is invalid or corrupted.
//
#define RPC_NT_INVALID_PIPE_OBJECT       ((NTSTATUS)0xC003005CL)

//
// MessageId: RPC_NT_INVALID_PIPE_OPERATION
//
// MessageText:
//
//  An invalid operation was attempted on an RPC pipe object.
//
//
// MessageId: STATUS_PER_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust creation quota has been exceeded.
//
#define STATUS_PER_USER_TRUST_QUOTA_EXCEEDED ((NTSTATUS)0xC0000401L)

//
// MessageId: STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The total delegated trust creation quota has been exceeded.
//
#define STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED ((NTSTATUS)0xC0000402L)

//
// MessageId: STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust deletion quota has been exceeded.
//
#define STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED ((NTSTATUS)0xC0000403L)

//
// MessageId: STATUS_DS_NAME_NOT_UNIQUE
//
// MessageText:
//
// The requested name already exists as a unique identifier.
//
#define STATUS_DS_NAME_NOT_UNIQUE        ((NTSTATUS)0xC0000404L)

//
// MessageId: STATUS_DS_DUPLICATE_ID_FOUND
//
// MessageText:
//
// The requested object has a non-unique identifier and cannot be retrieved.
//
#define STATUS_DS_DUPLICATE_ID_FOUND     ((NTSTATUS)0xC0000405L)

//
// MessageId: STATUS_DS_GROUP_CONVERSION_ERROR
//
// MessageText:
//
// The group cannot be converted due to attribute restrictions on the requested group type.
//
#define STATUS_DS_GROUP_CONVERSION_ERROR ((NTSTATUS)0xC0000406L)

//
// MessageId: STATUS_VOLSNAP_PREPARE_HIBERNATE
//
// MessageText:
//
// {Volume Shadow Copy Service}
// Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
//
#define STATUS_VOLSNAP_PREPARE_HIBERNATE ((NTSTATUS)0xC0000407L)

//
// MessageId: STATUS_USER2USER_REQUIRED
//
// MessageText:
//
// Kerberos sub-protocol User2User is required.
//
#define STATUS_USER2USER_REQUIRED        ((NTSTATUS)0xC0000408L)

//
// MessageId: STATUS_STACK_BUFFER_OVERRUN
//
// MessageText:
//
// The system detected an overrun of a stack-based buffer in this application.  This
// overrun could potentially allow a malicious user to gain control of this application.
//
#define STATUS_STACK_BUFFER_OVERRUN      ((NTSTATUS)0xC0000409L)

//
// MessageId: STATUS_NO_S4U_PROT_SUPPORT
//
// MessageText:
//
// The Kerberos subsystem encountered an error.  A service for user protocol request was made
// against a domain controller which does not support service for user.
//
#define STATUS_NO_S4U_PROT_SUPPORT       ((NTSTATUS)0xC000040AL)

//
// MessageId: STATUS_CROSSREALM_DELEGATION_FAILURE
//
// MessageText:
//
// An attempt was made by this server to make a Kerberos constrained delegation request for a target
// outside of the server's realm.  This is not supported, and indicates a misconfiguration on this
// server's allowed to delegate to list.  Please contact your administrator.
//
#define STATUS_CROSSREALM_DELEGATION_FAILURE ((NTSTATUS)0xC000040BL)

//
// MessageId: STATUS_REVOCATION_OFFLINE_KDC
//
// MessageText:
//
// The revocation status of the domain controller certificate used for smartcard
// authentication could not be determined.  There is additional information in the system event
// log. Please contact your system administrator.
//
#define STATUS_REVOCATION_OFFLINE_KDC    ((NTSTATUS)0xC000040CL)

//
// MessageId: STATUS_ISSUING_CA_UNTRUSTED_KDC
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the
// domain controller certificate used for authentication.  There is additional information in
// the system event log.  Please contact your system administrator.
//
#define STATUS_ISSUING_CA_UNTRUSTED_KDC  ((NTSTATUS)0xC000040DL)

//
// MessageId: STATUS_KDC_CERT_EXPIRED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has expired.
// Please contact your system administrator with the contents of your system event log.
//
#define STATUS_KDC_CERT_EXPIRED          ((NTSTATUS)0xC000040EL)

//
// MessageId: STATUS_KDC_CERT_REVOKED
//
// MessageText:
//
// The domain controller certificate used for smartcard logon has been revoked.
// Please contact your system administrator with the contents of your system event log.
//
#define STATUS_KDC_CERT_REVOKED          ((NTSTATUS)0xC000040FL)

//
// MessageId: STATUS_PARAMETER_QUOTA_EXCEEDED
//
// MessageText:
//
// Data present in one of the parameters is more than the function can operate on.
//
#define STATUS_PARAMETER_QUOTA_EXCEEDED  ((NTSTATUS)0xC0000410L)

//
// MessageId: STATUS_HIBERNATION_FAILURE
//
// MessageText:
//
// The system has failed to hibernate (The error code is %hs).  Hibernation will be disabled until the system is restarted.
//
#define STATUS_HIBERNATION_FAILURE       ((NTSTATUS)0xC0000411L)

//
// MessageId: STATUS_DELAY_LOAD_FAILED
//
// MessageText:
//
// An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
//
#define STATUS_DELAY_LOAD_FAILED         ((NTSTATUS)0xC0000412L)

//
// MessageId: STATUS_AUTHENTICATION_FIREWALL_FAILED
//
// MessageText:
//
// Logon Failure: The machine you are logging onto is protected by an authentication firewall.  The specified account is not allowed to authenticate to the machine.
//
#define STATUS_AUTHENTICATION_FIREWALL_FAILED ((NTSTATUS)0xC0000413L)

//
// MessageId: STATUS_VDM_DISALLOWED
//
// MessageText:
//
// %hs is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
//
#define STATUS_VDM_DISALLOWED            ((NTSTATUS)0xC0000414L)

//
// MessageId: STATUS_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally.  Save your work and reboot the system to restore full display functionality.
// The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.
//
#define STATUS_HUNG_DISPLAY_DRIVER_THREAD ((NTSTATUS)0xC0000415L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
//
// MessageText:
//
// The Desktop heap encountered an error while allocating session memory.  There is more information in the system event log.
//
#define STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE ((NTSTATUS)0xC0000416L)

//
// MessageId: STATUS_INVALID_CRUNTIME_PARAMETER
//
// MessageText:
//
// An invalid parameter was passed to a C runtime function.
//
#define STATUS_INVALID_CRUNTIME_PARAMETER ((NTSTATUS)0xC0000417L)

//
// MessageId: STATUS_NTLM_BLOCKED
//
// MessageText:
//
// The authentication failed since NTLM was blocked.
//
#define STATUS_NTLM_BLOCKED              ((NTSTATUS)0xC0000418L)

/*++

MessageId=0x0420 Facility=System Severity=ERROR SymbolicName=STATUS_ASSERTION_FAILURE
Language=English
An assertion failure has occurred.
.

--*/

#define STATUS_ASSERTION_FAILURE         ((NTSTATUS)0xC0000420L)

//
// MessageId: STATUS_VERIFIER_STOP
//
// MessageText:
//
// Application verifier has found an error in the current process.
//
#define STATUS_VERIFIER_STOP             ((NTSTATUS)0xC0000421L)

/*++

 MessageId=0x0423 Facility=System Severity=ERROR SymbolicName=STATUS_CALLBACK_POP_STACK
 Language=English
 An exception has occurred in a user mode callback and the kernel callback frame should be removed.
 .

--*/

#define STATUS_CALLBACK_POP_STACK        ((NTSTATUS)0xC0000423L)

//
// MessageId: STATUS_INCOMPATIBLE_DRIVER_BLOCKED
//
// MessageText:
//
// %2 has been blocked from loading due to incompatibility with this system. Please contact your software
// vendor for a compatible version of the driver.
//
#define STATUS_INCOMPATIBLE_DRIVER_BLOCKED ((NTSTATUS)0xC0000424L)

//
// MessageId: STATUS_HIVE_UNLOADED
//
// MessageText:
//
// Illegal operation attempted on a registry key which has already been unloaded.
//
#define STATUS_HIVE_UNLOADED             ((NTSTATUS)0xC0000425L)

//
// MessageId: STATUS_COMPRESSION_DISABLED
//
// MessageText:
//
// Compression is disabled for this volume.
//
#define STATUS_COMPRESSION_DISABLED      ((NTSTATUS)0xC0000426L)

//
// MessageId: STATUS_FILE_SYSTEM_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a file system limitation
//
#define STATUS_FILE_SYSTEM_LIMITATION    ((NTSTATUS)0xC0000427L)

//
// MessageId: STATUS_INVALID_IMAGE_HASH
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
//
#define STATUS_INVALID_IMAGE_HASH        ((NTSTATUS)0xC0000428L)

//
// MessageId: STATUS_NOT_CAPABLE
//
// MessageText:
//
// The implementation is not capable of performing the request.
//
#define STATUS_NOT_CAPABLE               ((NTSTATUS)0xC0000429L)

//
// MessageId: STATUS_REQUEST_OUT_OF_SEQUENCE
//
// MessageText:
//
// The requested operation is out of order with respect to other operations.
//
#define STATUS_REQUEST_OUT_OF_SEQUENCE   ((NTSTATUS)0xC000042AL)

//
// MessageId: STATUS_IMPLEMENTATION_LIMIT
//
// MessageText:
//
// An operation attempted to exceed an implementation-defined limit.
//
#define STATUS_IMPLEMENTATION_LIMIT      ((NTSTATUS)0xC000042BL)

//
// MessageId: STATUS_ELEVATION_REQUIRED
//
// MessageText:
//
// The requested operation requires elevation.
//
#define STATUS_ELEVATION_REQUIRED        ((NTSTATUS)0xC000042CL)

//
// MessageId: STATUS_BEYOND_VDL
//
// MessageText:
//
// The operation was attempted beyond the valid data length of the file.
//
#define STATUS_BEYOND_VDL                ((NTSTATUS)0xC0000432L)

//
// MessageId: STATUS_ENCOUNTERED_WRITE_IN_PROGRESS
//
// MessageText:
//
// The attempted write operation encountered a write already in progress for some portion of the range.
//
#define STATUS_ENCOUNTERED_WRITE_IN_PROGRESS ((NTSTATUS)0xC0000433L)

//
// MessageId: STATUS_PTE_CHANGED
//
// MessageText:
//
// The page fault mappings changed in the middle of processing a fault so the operation must be retried.
//
#define STATUS_PTE_CHANGED               ((NTSTATUS)0xC0000434L)

//
// MessageId: STATUS_PURGE_FAILED
//
// MessageText:
//
// The attempt to purge this file from memory failed to purge some or all the data from memory.
//
#define STATUS_PURGE_FAILED              ((NTSTATUS)0xC0000435L)

//
// MessageId: STATUS_CRED_REQUIRES_CONFIRMATION
//
// MessageText:
//
// The requested credential requires confirmation.
//
#define STATUS_CRED_REQUIRES_CONFIRMATION ((NTSTATUS)0xC0000440L)

//
// MessageId: STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The remote server sent an invalid response for a file being opened with Client Side Encryption.
//
#define STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE ((NTSTATUS)0xC0000441L)

//
// MessageId: STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER
//
// MessageText:
//
// Client Side Encryption is not supported by the remote server even though it claims to support it.
//
#define STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER ((NTSTATUS)0xC0000442L)

//
// MessageId: STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
//
// MessageText:
//
// File is encrypted and should be opened in Client Side Encryption mode.
//
#define STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE ((NTSTATUS)0xC0000443L)

//
// MessageId: STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
//
// MessageText:
//
// A new encrypted file is being created and a $EFS needs to be provided.
//
#define STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE ((NTSTATUS)0xC0000444L)

//
// MessageId: STATUS_CS_ENCRYPTION_FILE_NOT_CSE
//
// MessageText:
//
// The SMB client requested a CSE FSCTL on a non-CSE file.
//
#define STATUS_CS_ENCRYPTION_FILE_NOT_CSE ((NTSTATUS)0xC0000445L)

//
// MessageId: STATUS_INVALID_LABEL
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the label of an object.
//
#define STATUS_INVALID_LABEL             ((NTSTATUS)0xC0000446L)

//
// MessageId: STATUS_DRIVER_PROCESS_TERMINATED
//
// MessageText:
//
// The process hosting the driver for this device has terminated.
//
#define STATUS_DRIVER_PROCESS_TERMINATED ((NTSTATUS)0xC0000450L)

//
// MessageId: STATUS_AMBIGUOUS_SYSTEM_DEVICE
//
// MessageText:
//
// The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
//
#define STATUS_AMBIGUOUS_SYSTEM_DEVICE   ((NTSTATUS)0xC0000451L)

//
// MessageId: STATUS_SYSTEM_DEVICE_NOT_FOUND
//
// MessageText:
//
// The requested system device cannot be found.
//
#define STATUS_SYSTEM_DEVICE_NOT_FOUND   ((NTSTATUS)0xC0000452L)

//
// MessageId: STATUS_RESTART_BOOT_APPLICATION
//
// MessageText:
//
// This boot application must be restarted.
//
#define STATUS_RESTART_BOOT_APPLICATION  ((NTSTATUS)0xC0000453L)

/*++

 MessageId's 0xa010 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*/
//
// MessageId: STATUS_IPSEC_QUEUE_OVERFLOW
//
// MessageText:
//
// The IPSEC queue overflowed.
//
#define STATUS_IPSEC_QUEUE_OVERFLOW      ((NTSTATUS)0xC000A010L)

//
// MessageId: STATUS_ND_QUEUE_OVERFLOW
//
// MessageText:
//
// The neighbor discovery queue overflowed.
//
#define STATUS_ND_QUEUE_OVERFLOW         ((NTSTATUS)0xC000A011L)

//
// MessageId: STATUS_HOPLIMIT_EXCEEDED
//
// MessageText:
//
// An ICMP hop limit exceeded error was received.
//
#define STATUS_HOPLIMIT_EXCEEDED         ((NTSTATUS)0xC000A012L)

//
// MessageId: STATUS_PROTOCOL_NOT_SUPPORTED
//
// MessageText:
//
// The protocol is not installed on the local machine.
//
#define STATUS_PROTOCOL_NOT_SUPPORTED    ((NTSTATUS)0xC000A013L)

//
// MessageId: STATUS_FASTPATH_REJECTED
//
// MessageText:
//
// An operation or data has been rejected while on the network fast path.
//
#define STATUS_FASTPATH_REJECTED         ((NTSTATUS)0xC000A014L)

/*++

 MessageId's 0xa014 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*/
#define RPC_NT_INVALID_PIPE_OPERATION    ((NTSTATUS)0xC003005DL)

//
// MessageId: RPC_NT_WRONG_PIPE_VERSION
//
// MessageText:
//
//  Unsupported RPC pipe version.
//
#define RPC_NT_WRONG_PIPE_VERSION        ((NTSTATUS)0xC003005EL)

//
// MessageId: RPC_NT_PIPE_CLOSED
//
// MessageText:
//
//  The RPC pipe object has already been closed.
//
#define RPC_NT_PIPE_CLOSED               ((NTSTATUS)0xC003005FL)

//
// MessageId: RPC_NT_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
//  The RPC call completed before all pipes were processed.
//
#define RPC_NT_PIPE_DISCIPLINE_ERROR     ((NTSTATUS)0xC0030060L)

//
// MessageId: RPC_NT_PIPE_EMPTY
//
// MessageText:
//
//  No more data is available from the RPC pipe.
//
#define RPC_NT_PIPE_EMPTY                ((NTSTATUS)0xC0030061L)

//
// MessageId: RPC_NT_INVALID_ASYNC_HANDLE
//
// MessageText:
//
//  Invalid asynchronous remote procedure call handle.
//
#define RPC_NT_INVALID_ASYNC_HANDLE      ((NTSTATUS)0xC0020062L)

//
// MessageId: RPC_NT_INVALID_ASYNC_CALL
//
// MessageText:
//
//  Invalid asynchronous RPC call handle for this operation.
//
#define RPC_NT_INVALID_ASYNC_CALL        ((NTSTATUS)0xC0020063L)

//
// MessageId: RPC_NT_SEND_INCOMPLETE
//
// MessageText:
//
//  Some data remains to be sent in the request buffer.
//
#define RPC_NT_SEND_INCOMPLETE           ((NTSTATUS)0x400200AFL)

//
// MessageId: STATUS_ACPI_INVALID_OPCODE
//
// MessageText:
//
//  An attempt was made to run an invalid AML opcode
//
#define STATUS_ACPI_INVALID_OPCODE       ((NTSTATUS)0xC0140001L)

//
// MessageId: STATUS_ACPI_STACK_OVERFLOW
//
// MessageText:
//
//  The AML Interpreter Stack has overflown
//
#define STATUS_ACPI_STACK_OVERFLOW       ((NTSTATUS)0xC0140002L)

//
// MessageId: STATUS_ACPI_ASSERT_FAILED
//
// MessageText:
//
//  An inconsistent state has occured
//
#define STATUS_ACPI_ASSERT_FAILED        ((NTSTATUS)0xC0140003L)

//
// MessageId: STATUS_ACPI_INVALID_INDEX
//
// MessageText:
//
//  An attempt was made to access an array outside of its bounds
//
#define STATUS_ACPI_INVALID_INDEX        ((NTSTATUS)0xC0140004L)

//
// MessageId: STATUS_ACPI_INVALID_ARGUMENT
//
// MessageText:
//
//  A required argument was not specified
//
#define STATUS_ACPI_INVALID_ARGUMENT     ((NTSTATUS)0xC0140005L)

//
// MessageId: STATUS_ACPI_FATAL
//
// MessageText:
//
//  A fatal error has occured
//
#define STATUS_ACPI_FATAL                ((NTSTATUS)0xC0140006L)

//
// MessageId: STATUS_ACPI_INVALID_SUPERNAME
//
// MessageText:
//
//  An invalid SuperName was specified
//
#define STATUS_ACPI_INVALID_SUPERNAME    ((NTSTATUS)0xC0140007L)

//
// MessageId: STATUS_ACPI_INVALID_ARGTYPE
//
// MessageText:
//
//  An argument with an incorrect type was specified
//
#define STATUS_ACPI_INVALID_ARGTYPE      ((NTSTATUS)0xC0140008L)

//
// MessageId: STATUS_ACPI_INVALID_OBJTYPE
//
// MessageText:
//
//  An object with an incorrect type was specified
//
#define STATUS_ACPI_INVALID_OBJTYPE      ((NTSTATUS)0xC0140009L)

//
// MessageId: STATUS_ACPI_INVALID_TARGETTYPE
//
// MessageText:
//
//  A target with an incorrect type was specified
//
#define STATUS_ACPI_INVALID_TARGETTYPE   ((NTSTATUS)0xC014000AL)

//
// MessageId: STATUS_ACPI_INCORRECT_ARGUMENT_COUNT
//
// MessageText:
//
//  An incorrect number of arguments were specified
//
#define STATUS_ACPI_INCORRECT_ARGUMENT_COUNT ((NTSTATUS)0xC014000BL)

//
// MessageId: STATUS_ACPI_ADDRESS_NOT_MAPPED
//
// MessageText:
//
//  An address failed to translate
//
#define STATUS_ACPI_ADDRESS_NOT_MAPPED   ((NTSTATUS)0xC014000CL)

//
// MessageId: STATUS_ACPI_INVALID_EVENTTYPE
//
// MessageText:
//
//  An incorrect event type was specified
//
#define STATUS_ACPI_INVALID_EVENTTYPE    ((NTSTATUS)0xC014000DL)

//
// MessageId: STATUS_ACPI_HANDLER_COLLISION
//
// MessageText:
//
//  A handler for the target already exists
//
#define STATUS_ACPI_HANDLER_COLLISION    ((NTSTATUS)0xC014000EL)

//
// MessageId: STATUS_ACPI_INVALID_DATA
//
// MessageText:
//
//  Invalid data for the target was specified
//
#define STATUS_ACPI_INVALID_DATA         ((NTSTATUS)0xC014000FL)

//
// MessageId: STATUS_ACPI_INVALID_REGION
//
// MessageText:
//
//  An invalid region for the target was specified
//
#define STATUS_ACPI_INVALID_REGION       ((NTSTATUS)0xC0140010L)

//
// MessageId: STATUS_ACPI_INVALID_ACCESS_SIZE
//
// MessageText:
//
//  An attempt was made to access a field outside of the defined range
//
#define STATUS_ACPI_INVALID_ACCESS_SIZE  ((NTSTATUS)0xC0140011L)

//
// MessageId: STATUS_ACPI_ACQUIRE_GLOBAL_LOCK
//
// MessageText:
//
//  The Global system lock could not be acquired
//
#define STATUS_ACPI_ACQUIRE_GLOBAL_LOCK  ((NTSTATUS)0xC0140012L)

//
// MessageId: STATUS_ACPI_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to reinitialize the ACPI subsystem
//
#define STATUS_ACPI_ALREADY_INITIALIZED  ((NTSTATUS)0xC0140013L)

//
// MessageId: STATUS_ACPI_NOT_INITIALIZED
//
// MessageText:
//
//  The ACPI subsystem has not been initialized
//
#define STATUS_ACPI_NOT_INITIALIZED      ((NTSTATUS)0xC0140014L)

//
// MessageId: STATUS_ACPI_INVALID_MUTEX_LEVEL
//
// MessageText:
//
//  An incorrect mutex was specified
//
#define STATUS_ACPI_INVALID_MUTEX_LEVEL  ((NTSTATUS)0xC0140015L)

//
// MessageId: STATUS_ACPI_MUTEX_NOT_OWNED
//
// MessageText:
//
//  The mutex is not currecntly owned
//
#define STATUS_ACPI_MUTEX_NOT_OWNED      ((NTSTATUS)0xC0140016L)

//
// MessageId: STATUS_ACPI_MUTEX_NOT_OWNER
//
// MessageText:
//
//  An attempt was made to access the mutex by a process that was not the owner
//
#define STATUS_ACPI_MUTEX_NOT_OWNER      ((NTSTATUS)0xC0140017L)

//
// MessageId: STATUS_ACPI_RS_ACCESS
//
// MessageText:
//
//  An error occurred during an access to Region Space
//
#define STATUS_ACPI_RS_ACCESS            ((NTSTATUS)0xC0140018L)

//
// MessageId: STATUS_ACPI_INVALID_TABLE
//
// MessageText:
//
//  An attempt was made to use an incorrect table
//
#define STATUS_ACPI_INVALID_TABLE        ((NTSTATUS)0xC0140019L)

//
// MessageId: STATUS_ACPI_REG_HANDLER_FAILED
//
// MessageText:
//
//  The registration of an ACPI event failed
//
#define STATUS_ACPI_REG_HANDLER_FAILED   ((NTSTATUS)0xC0140020L)

//
// MessageId: STATUS_ACPI_POWER_REQUEST_FAILED
//
// MessageText:
//
//  An ACPI Power Object failed to transition state
//
#define STATUS_ACPI_POWER_REQUEST_FAILED ((NTSTATUS)0xC0140021L)

//
// Termainl Server specific Errors
//
//
// MessageId: STATUS_CTX_WINSTATION_NAME_INVALID
//
// MessageText:
//
//  Session name %1 is invalid.
//
#define STATUS_CTX_WINSTATION_NAME_INVALID ((NTSTATUS)0xC00A0001L)

//
// MessageId: STATUS_CTX_INVALID_PD
//
// MessageText:
//
//  The protocol driver %1 is invalid.
//
#define STATUS_CTX_INVALID_PD            ((NTSTATUS)0xC00A0002L)

//
// MessageId: STATUS_CTX_PD_NOT_FOUND
//
// MessageText:
//
//  The protocol driver %1 was not found in the system path.
//
#define STATUS_CTX_PD_NOT_FOUND          ((NTSTATUS)0xC00A0003L)

//
// MessageId: STATUS_CTX_CDM_CONNECT
//
// MessageText:
//
//  The Client Drive Mapping Service Has Connected on Terminal Connection.
//
#define STATUS_CTX_CDM_CONNECT           ((NTSTATUS)0x400A0004L)

//
// MessageId: STATUS_CTX_CDM_DISCONNECT
//
// MessageText:
//
//  The Client Drive Mapping Service Has Disconnected on Terminal Connection.
//
#define STATUS_CTX_CDM_DISCONNECT        ((NTSTATUS)0x400A0005L)

//
// MessageId: STATUS_CTX_CLOSE_PENDING
//
// MessageText:
//
//  A close operation is pending on the Terminal Connection.
//
#define STATUS_CTX_CLOSE_PENDING         ((NTSTATUS)0xC00A0006L)

//
// MessageId: STATUS_CTX_NO_OUTBUF
//
// MessageText:
//
//  There are no free output buffers available.
//
#define STATUS_CTX_NO_OUTBUF             ((NTSTATUS)0xC00A0007L)

//
// MessageId: STATUS_CTX_MODEM_INF_NOT_FOUND
//
// MessageText:
//
//  The MODEM.INF file was not found.
//
#define STATUS_CTX_MODEM_INF_NOT_FOUND   ((NTSTATUS)0xC00A0008L)

//
// MessageId: STATUS_CTX_INVALID_MODEMNAME
//
// MessageText:
//
//  The modem (%1) was not found in MODEM.INF.
//
#define STATUS_CTX_INVALID_MODEMNAME     ((NTSTATUS)0xC00A0009L)

//
// MessageId: STATUS_CTX_RESPONSE_ERROR
//
// MessageText:
//
//  The modem did not accept the command sent to it.
//  Verify the configured modem name matches the attached modem.
//
#define STATUS_CTX_RESPONSE_ERROR        ((NTSTATUS)0xC00A000AL)

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_TIMEOUT
//
// MessageText:
//
//  The modem did not respond to the command sent to it.
//  Verify the modem is properly cabled and powered on.
//
#define STATUS_CTX_MODEM_RESPONSE_TIMEOUT ((NTSTATUS)0xC00A000BL)

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_NO_CARRIER
//
// MessageText:
//
//  Carrier detect has failed or carrier has been dropped due to disconnect.
//
#define STATUS_CTX_MODEM_RESPONSE_NO_CARRIER ((NTSTATUS)0xC00A000CL)

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE
//
// MessageText:
//
//  Dial tone not detected within required time.
//  Verify phone cable is properly attached and functional.
//
#define STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE ((NTSTATUS)0xC00A000DL)

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_BUSY
//
// MessageText:
//
//  Busy signal detected at remote site on callback.
//
#define STATUS_CTX_MODEM_RESPONSE_BUSY   ((NTSTATUS)0xC00A000EL)

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_VOICE
//
// MessageText:
//
//  Voice detected at remote site on callback.
//
#define STATUS_CTX_MODEM_RESPONSE_VOICE  ((NTSTATUS)0xC00A000FL)

//
// MessageId: STATUS_CTX_TD_ERROR
//
// MessageText:
//
//  Transport driver error
//
#define STATUS_CTX_TD_ERROR              ((NTSTATUS)0xC00A0010L)

//
// MessageId: STATUS_CTX_LICENSE_CLIENT_INVALID
//
// MessageText:
//
//  The client you are using is not licensed to
//  use this system.  Your logon request is denied.
//
#define STATUS_CTX_LICENSE_CLIENT_INVALID ((NTSTATUS)0xC00A0012L)

//
// MessageId: STATUS_CTX_WINSTATION_NOT_FOUND
//
// MessageText:
//
//  The specified session cannot be found.
//
#define STATUS_CTX_WINSTATION_NOT_FOUND  ((NTSTATUS)0xC00A0015L)

//
// MessageId: STATUS_CTX_WINSTATION_NAME_COLLISION
//
// MessageText:
//
//  The specified session name is already in use.
//
#define STATUS_CTX_WINSTATION_NAME_COLLISION ((NTSTATUS)0xC00A0016L)

//
// MessageId: STATUS_CTX_WINSTATION_BUSY
//
// MessageText:
//
//  The requested operation cannot be completed because
//  the Terminal Connection is currently busy processing a connect,
//  disconnect, reset, or delete operation.
//
#define STATUS_CTX_WINSTATION_BUSY       ((NTSTATUS)0xC00A0017L)

//
// MessageId: STATUS_CTX_BAD_VIDEO_MODE
//
// MessageText:
//
//  An attempt has been made to connect to a session
//  whose video mode is not supported by the current client.
//
#define STATUS_CTX_BAD_VIDEO_MODE        ((NTSTATUS)0xC00A0018L)

//
// MessageId: STATUS_CTX_GRAPHICS_INVALID
//
// MessageText:
//
//  The application attempted to enable DOS graphics mode.
//  DOS graphics mode is not supported.
//
#define STATUS_CTX_GRAPHICS_INVALID      ((NTSTATUS)0xC00A0022L)

//
// MessageId: STATUS_CTX_NOT_CONSOLE
//
// MessageText:
//
//  The requested operation can be performed only on the system console.
//  This is most often the result of a driver or system DLL requiring
//  direct console access.
//
#define STATUS_CTX_NOT_CONSOLE           ((NTSTATUS)0xC00A0024L)

//
// MessageId: STATUS_CTX_CLIENT_QUERY_TIMEOUT
//
// MessageText:
//
//  The client failed to respond to the server connect message.
//
#define STATUS_CTX_CLIENT_QUERY_TIMEOUT  ((NTSTATUS)0xC00A0026L)

//
// MessageId: STATUS_CTX_CONSOLE_DISCONNECT
//
// MessageText:
//
//  Disconnecting the console session is not supported.
//
#define STATUS_CTX_CONSOLE_DISCONNECT    ((NTSTATUS)0xC00A0027L)

//
// MessageId: STATUS_CTX_CONSOLE_CONNECT
//
// MessageText:
//
//  Reconnecting a disconnected session to the console is not supported.
//
#define STATUS_CTX_CONSOLE_CONNECT       ((NTSTATUS)0xC00A0028L)

//
// MessageId: STATUS_CTX_SHADOW_DENIED
//
// MessageText:
//
//  The request to shadow another session was denied.
//
#define STATUS_CTX_SHADOW_DENIED         ((NTSTATUS)0xC00A002AL)

//
// MessageId: STATUS_CTX_WINSTATION_ACCESS_DENIED
//
// MessageText:
//
//  A process has requested access to a session,
//  but has not been granted those access rights.
//
#define STATUS_CTX_WINSTATION_ACCESS_DENIED ((NTSTATUS)0xC00A002BL)

//
// MessageId: STATUS_CTX_INVALID_WD
//
// MessageText:
//
//  The Terminal Connection driver %1 is invalid.
//
#define STATUS_CTX_INVALID_WD            ((NTSTATUS)0xC00A002EL)

//
// MessageId: STATUS_CTX_WD_NOT_FOUND
//
// MessageText:
//
//  The Terminal Connection driver %1 was not found in the system path.
//
#define STATUS_CTX_WD_NOT_FOUND          ((NTSTATUS)0xC00A002FL)

//
// MessageId: STATUS_CTX_SHADOW_INVALID
//
// MessageText:
//
//  The requested session cannot be shadowed.
//  This may be because the session is disconnected or
//  does not currently have a user logged on.  Also, you cannot
//  shadow a session from the system console or shadow the
//  system console.
//
#define STATUS_CTX_SHADOW_INVALID        ((NTSTATUS)0xC00A0030L)

//
// MessageId: STATUS_CTX_SHADOW_DISABLED
//
// MessageText:
//
//  The requested session is not configured to allow shadowing.
//
#define STATUS_CTX_SHADOW_DISABLED       ((NTSTATUS)0xC00A0031L)

//
// MessageId: STATUS_RDP_PROTOCOL_ERROR
//
// MessageText:
//
//  The RDP protocol component %1 detected an error in the protocol stream and has
//  disconnected the client.
//
#define STATUS_RDP_PROTOCOL_ERROR        ((NTSTATUS)0xC00A0032L)


//start vista ntstatus.h for FWP codes

//
// FWP error codes (fwpkclnt.sys)
//

//
// MessageId: STATUS_FWP_CALLOUT_NOT_FOUND
//
// MessageText:
//
// The callout does not exist.
//
#define STATUS_FWP_CALLOUT_NOT_FOUND     ((NTSTATUS)0xC0220001L)

//
// MessageId: STATUS_FWP_CONDITION_NOT_FOUND
//
// MessageText:
//
// The filter condition does not exist.
//
#define STATUS_FWP_CONDITION_NOT_FOUND   ((NTSTATUS)0xC0220002L)

//
// MessageId: STATUS_FWP_FILTER_NOT_FOUND
//
// MessageText:
//
// The filter does not exist.
//
#define STATUS_FWP_FILTER_NOT_FOUND      ((NTSTATUS)0xC0220003L)

//
// MessageId: STATUS_FWP_LAYER_NOT_FOUND
//
// MessageText:
//
// The layer does not exist.
//
#define STATUS_FWP_LAYER_NOT_FOUND       ((NTSTATUS)0xC0220004L)

//
// MessageId: STATUS_FWP_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The provider does not exist.
//
#define STATUS_FWP_PROVIDER_NOT_FOUND    ((NTSTATUS)0xC0220005L)

//
// MessageId: STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND
//
// MessageText:
//
// The provider context does not exist.
//
#define STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND ((NTSTATUS)0xC0220006L)

//
// MessageId: STATUS_FWP_SUBLAYER_NOT_FOUND
//
// MessageText:
//
// The sublayer does not exist.
//
#define STATUS_FWP_SUBLAYER_NOT_FOUND    ((NTSTATUS)0xC0220007L)

//
// MessageId: STATUS_FWP_NOT_FOUND
//
// MessageText:
//
// The object does not exist.
//
#define STATUS_FWP_NOT_FOUND             ((NTSTATUS)0xC0220008L)

//
// MessageId: STATUS_FWP_ALREADY_EXISTS
//
// MessageText:
//
// An object with that GUID or LUID already exists.
//
#define STATUS_FWP_ALREADY_EXISTS        ((NTSTATUS)0xC0220009L)

//
// MessageId: STATUS_FWP_IN_USE
//
// MessageText:
//
// The object is referenced by other objects so cannot be deleted.
//
#define STATUS_FWP_IN_USE                ((NTSTATUS)0xC022000AL)

//
// MessageId: STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within a dynamic session.
//
#define STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS ((NTSTATUS)0xC022000BL)

//
// MessageId: STATUS_FWP_WRONG_SESSION
//
// MessageText:
//
// The call was made from the wrong session so cannot be completed.
//
#define STATUS_FWP_WRONG_SESSION         ((NTSTATUS)0xC022000CL)

//
// MessageId: STATUS_FWP_NO_TXN_IN_PROGRESS
//
// MessageText:
//
// The call must be made from within an explicit transaction.
//
#define STATUS_FWP_NO_TXN_IN_PROGRESS    ((NTSTATUS)0xC022000DL)

//
// MessageId: STATUS_FWP_TXN_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within an explicit transaction.
//
#define STATUS_FWP_TXN_IN_PROGRESS       ((NTSTATUS)0xC022000EL)

//
// MessageId: STATUS_FWP_TXN_ABORTED
//
// MessageText:
//
// The explicit transaction has been forcibly cancelled.
//
#define STATUS_FWP_TXN_ABORTED           ((NTSTATUS)0xC022000FL)

//
// MessageId: STATUS_FWP_SESSION_ABORTED
//
// MessageText:
//
// The session has been cancelled.
//
#define STATUS_FWP_SESSION_ABORTED       ((NTSTATUS)0xC0220010L)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_TXN
//
// MessageText:
//
// The call is not allowed from within a read-only transaction.
//
#define STATUS_FWP_INCOMPATIBLE_TXN      ((NTSTATUS)0xC0220011L)

//
// MessageId: STATUS_FWP_TIMEOUT
//
// MessageText:
//
// The call timed out while waiting to acquire the transaction lock.
//
#define STATUS_FWP_TIMEOUT               ((NTSTATUS)0xC0220012L)

//
// MessageId: STATUS_FWP_NET_EVENTS_DISABLED
//
// MessageText:
//
// Collection of network diagnostic events is disabled.
//
#define STATUS_FWP_NET_EVENTS_DISABLED   ((NTSTATUS)0xC0220013L)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_LAYER
//
// MessageText:
//
// The operation is not supported by the specified layer.
//
#define STATUS_FWP_INCOMPATIBLE_LAYER    ((NTSTATUS)0xC0220014L)

//
// MessageId: STATUS_FWP_KM_CLIENTS_ONLY
//
// MessageText:
//
// The call is allowed for kernel-mode callers only.
//
#define STATUS_FWP_KM_CLIENTS_ONLY       ((NTSTATUS)0xC0220015L)

//
// MessageId: STATUS_FWP_LIFETIME_MISMATCH
//
// MessageText:
//
// The call tried to associate two objects with incompatible lifetimes.
//
#define STATUS_FWP_LIFETIME_MISMATCH     ((NTSTATUS)0xC0220016L)

//
// MessageId: STATUS_FWP_BUILTIN_OBJECT
//
// MessageText:
//
// The object is built in so cannot be deleted.
//
#define STATUS_FWP_BUILTIN_OBJECT        ((NTSTATUS)0xC0220017L)

//
// MessageId: STATUS_FWP_TOO_MANY_CALLOUTS
//
// MessageText:
//
// The maximum number of callouts has been reached.
//
#define STATUS_FWP_TOO_MANY_CALLOUTS     ((NTSTATUS)0xC0220018L)

//
// MessageId: STATUS_FWP_NOTIFICATION_DROPPED
//
// MessageText:
//
// A notification could not be delivered because a message queue is at its maximum capacity.
//
#define STATUS_FWP_NOTIFICATION_DROPPED  ((NTSTATUS)0xC0220019L)

//
// MessageId: STATUS_FWP_TRAFFIC_MISMATCH
//
// MessageText:
//
// The traffic parameters do not match those for the security association context.
//
#define STATUS_FWP_TRAFFIC_MISMATCH      ((NTSTATUS)0xC022001AL)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_SA_STATE
//
// MessageText:
//
// The call is not allowed for the current security association state.
//
#define STATUS_FWP_INCOMPATIBLE_SA_STATE ((NTSTATUS)0xC022001BL)

//
// MessageId: STATUS_FWP_NULL_POINTER
//
// MessageText:
//
// A required pointer is null.
//
#define STATUS_FWP_NULL_POINTER          ((NTSTATUS)0xC022001CL)

//
// MessageId: STATUS_FWP_INVALID_ENUMERATOR
//
// MessageText:
//
// An enumerator is not valid.
//
#define STATUS_FWP_INVALID_ENUMERATOR    ((NTSTATUS)0xC022001DL)

//
// MessageId: STATUS_FWP_INVALID_FLAGS
//
// MessageText:
//
// The flags field contains an invalid value.
//
#define STATUS_FWP_INVALID_FLAGS         ((NTSTATUS)0xC022001EL)

//
// MessageId: STATUS_FWP_INVALID_NET_MASK
//
// MessageText:
//
// A network mask is not valid.
//
#define STATUS_FWP_INVALID_NET_MASK      ((NTSTATUS)0xC022001FL)

//
// MessageId: STATUS_FWP_INVALID_RANGE
//
// MessageText:
//
// An FWP_RANGE is not valid.
//
#define STATUS_FWP_INVALID_RANGE         ((NTSTATUS)0xC0220020L)

//
// MessageId: STATUS_FWP_INVALID_INTERVAL
//
// MessageText:
//
// The time interval is not valid.
//
#define STATUS_FWP_INVALID_INTERVAL      ((NTSTATUS)0xC0220021L)

//
// MessageId: STATUS_FWP_ZERO_LENGTH_ARRAY
//
// MessageText:
//
// An array that must contain at least one element is zero length.
//
#define STATUS_FWP_ZERO_LENGTH_ARRAY     ((NTSTATUS)0xC0220022L)

//
// MessageId: STATUS_FWP_NULL_DISPLAY_NAME
//
// MessageText:
//
// The displayData.name field cannot be null.
//
#define STATUS_FWP_NULL_DISPLAY_NAME     ((NTSTATUS)0xC0220023L)

//
// MessageId: STATUS_FWP_INVALID_ACTION_TYPE
//
// MessageText:
//
// The action type is not one of the allowed action types for a filter.
//
#define STATUS_FWP_INVALID_ACTION_TYPE   ((NTSTATUS)0xC0220024L)

//
// MessageId: STATUS_FWP_INVALID_WEIGHT
//
// MessageText:
//
// The filter weight is not valid.
//
#define STATUS_FWP_INVALID_WEIGHT        ((NTSTATUS)0xC0220025L)

//
// MessageId: STATUS_FWP_MATCH_TYPE_MISMATCH
//
// MessageText:
//
// A filter condition contains a match type that is not compatible with the operands.
//
#define STATUS_FWP_MATCH_TYPE_MISMATCH   ((NTSTATUS)0xC0220026L)

//
// MessageId: STATUS_FWP_TYPE_MISMATCH
//
// MessageText:
//
// An FWP_VALUE or FWPM_CONDITION_VALUE is of the wrong type.
//
#define STATUS_FWP_TYPE_MISMATCH         ((NTSTATUS)0xC0220027L)

//
// MessageId: STATUS_FWP_OUT_OF_BOUNDS
//
// MessageText:
//
// An integer value is outside the allowed range.
//
#define STATUS_FWP_OUT_OF_BOUNDS         ((NTSTATUS)0xC0220028L)

//
// MessageId: STATUS_FWP_RESERVED
//
// MessageText:
//
// A reserved field is non-zero.
//
#define STATUS_FWP_RESERVED              ((NTSTATUS)0xC0220029L)

//
// MessageId: STATUS_FWP_DUPLICATE_CONDITION
//
// MessageText:
//
// A filter cannot contain multiple conditions operating on a single field.
//
#define STATUS_FWP_DUPLICATE_CONDITION   ((NTSTATUS)0xC022002AL)

//
// MessageId: STATUS_FWP_DUPLICATE_KEYMOD
//
// MessageText:
//
// A policy cannot contain the same keying module more than once.
//
#define STATUS_FWP_DUPLICATE_KEYMOD      ((NTSTATUS)0xC022002BL)

//
// MessageId: STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The action type is not compatible with the layer.
//
#define STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER ((NTSTATUS)0xC022002CL)

//
// MessageId: STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER
//
// MessageText:
//
// The action type is not compatible with the sublayer.
//
#define STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER ((NTSTATUS)0xC022002DL)

//
// MessageId: STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The raw context or the provider context is not compatible with the layer.
//
#define STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER ((NTSTATUS)0xC022002EL)

//
// MessageId: STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT
//
// MessageText:
//
// The raw context or the provider context is not compatible with the callout.
//
#define STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT ((NTSTATUS)0xC022002FL)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_AUTH_METHOD
//
// MessageText:
//
// The authentication method is not compatible with the policy type.
//
#define STATUS_FWP_INCOMPATIBLE_AUTH_METHOD ((NTSTATUS)0xC0220030L)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_DH_GROUP
//
// MessageText:
//
// The Diffie-Hellman group is not compatible with the policy type.
//
#define STATUS_FWP_INCOMPATIBLE_DH_GROUP ((NTSTATUS)0xC0220031L)

//
// MessageId: STATUS_FWP_EM_NOT_SUPPORTED
//
// MessageText:
//
// An IKE policy cannot contain an Extended Mode policy.
//
#define STATUS_FWP_EM_NOT_SUPPORTED      ((NTSTATUS)0xC0220032L)

//
// MessageId: STATUS_FWP_NEVER_MATCH
//
// MessageText:
//
// The enumeration template or subscription will never match any objects.
//
#define STATUS_FWP_NEVER_MATCH           ((NTSTATUS)0xC0220033L)

//
// MessageId: STATUS_FWP_PROVIDER_CONTEXT_MISMATCH
//
// MessageText:
//
// The provider context is of the wrong type.
//
#define STATUS_FWP_PROVIDER_CONTEXT_MISMATCH ((NTSTATUS)0xC0220034L)

//
// MessageId: STATUS_FWP_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
#define STATUS_FWP_INVALID_PARAMETER     ((NTSTATUS)0xC0220035L)

//
// MessageId: STATUS_FWP_TOO_MANY_SUBLAYERS
//
// MessageText:
//
// The maximum number of sublayers has been reached.
//
#define STATUS_FWP_TOO_MANY_SUBLAYERS    ((NTSTATUS)0xC0220036L)

//
// MessageId: STATUS_FWP_CALLOUT_NOTIFICATION_FAILED
//
// MessageText:
//
// The notification function for a callout returned an error.
//
#define STATUS_FWP_CALLOUT_NOTIFICATION_FAILED ((NTSTATUS)0xC0220037L)

//
// MessageId: STATUS_FWP_INVALID_AUTH_TRANSFORM
//
// MessageText:
//
// The IPsec authentication transform is not valid.
//
#define STATUS_FWP_INVALID_AUTH_TRANSFORM ((NTSTATUS)0xC0220038L)

//
// MessageId: STATUS_FWP_INVALID_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not valid.
//
#define STATUS_FWP_INVALID_CIPHER_TRANSFORM ((NTSTATUS)0xC0220039L)

//
// MessageId: STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not compatible with the policy.
//
#define STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM ((NTSTATUS)0xC022003AL)

//
// MessageId: STATUS_FWP_INVALID_TRANSFORM_COMBINATION
//
// MessageText:
//
// The combination of IPsec transform types is not valid.
//
#define STATUS_FWP_INVALID_TRANSFORM_COMBINATION ((NTSTATUS)0xC022003BL)

//
// MessageId: STATUS_FWP_TCPIP_NOT_READY
//
// MessageText:
//
// The TCP/IP stack is not ready.
//
#define STATUS_FWP_TCPIP_NOT_READY       ((NTSTATUS)0xC0220100L)

//
// MessageId: STATUS_FWP_INJECT_HANDLE_CLOSING
//
// MessageText:
//
// The injection handle is being closed by another thread.
//
#define STATUS_FWP_INJECT_HANDLE_CLOSING ((NTSTATUS)0xC0220101L)

//
// MessageId: STATUS_FWP_INJECT_HANDLE_STALE
//
// MessageText:
//
// The injection handle is stale.
//
#define STATUS_FWP_INJECT_HANDLE_STALE   ((NTSTATUS)0xC0220102L)

//
// MessageId: STATUS_FWP_CANNOT_PEND
//
// MessageText:
//
// The classify cannot be pended.
//
#define STATUS_FWP_CANNOT_PEND           ((NTSTATUS)0xC0220103L)

//
// MessageId: STATUS_FWP_DROP_NOICMP
//
// MessageText:
//
// The packet should be dropped, no ICMP should be sent.
//
#define STATUS_FWP_DROP_NOICMP           ((NTSTATUS)0xC0220104L)

//end vista ntstatus.h for FWP codes
//
// NDIS error codes (ndis.dll)
//

//
// MessageId: STATUS_NDIS_CLOSING
//
// MessageText:
//
// The binding to the network interface is being closed.
//
#define STATUS_NDIS_CLOSING              ((NTSTATUS)0xC0230002L)

//
// MessageId: STATUS_NDIS_BAD_VERSION
//
// MessageText:
//
// An invalid version was specified.
//
#define STATUS_NDIS_BAD_VERSION          ((NTSTATUS)0xC0230004L)

//
// MessageId: STATUS_NDIS_BAD_CHARACTERISTICS
//
// MessageText:
//
// An invalid characteristics table was used.
//
#define STATUS_NDIS_BAD_CHARACTERISTICS  ((NTSTATUS)0xC0230005L)

//
// MessageId: STATUS_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// Failed to find the network interface or network interface is not ready.
//
#define STATUS_NDIS_ADAPTER_NOT_FOUND    ((NTSTATUS)0xC0230006L)

//
// MessageId: STATUS_NDIS_OPEN_FAILED
//
// MessageText:
//
// Failed to open the network interface.
//
#define STATUS_NDIS_OPEN_FAILED          ((NTSTATUS)0xC0230007L)

//
// MessageId: STATUS_NDIS_DEVICE_FAILED
//
// MessageText:
//
// Network interface has encountered an internal unrecoverable failure.
//
#define STATUS_NDIS_DEVICE_FAILED        ((NTSTATUS)0xC0230008L)

//
// MessageId: STATUS_NDIS_MULTICAST_FULL
//
// MessageText:
//
// The multicast list on the network interface is full.
//
#define STATUS_NDIS_MULTICAST_FULL       ((NTSTATUS)0xC0230009L)

//
// MessageId: STATUS_NDIS_MULTICAST_EXISTS
//
// MessageText:
//
// An attempt was made to add a duplicate multicast address to the list.
//
#define STATUS_NDIS_MULTICAST_EXISTS     ((NTSTATUS)0xC023000AL)

//
// MessageId: STATUS_NDIS_MULTICAST_NOT_FOUND
//
// MessageText:
//
// At attempt was made to remove a multicast address that was never added.
//
#define STATUS_NDIS_MULTICAST_NOT_FOUND  ((NTSTATUS)0xC023000BL)

//
// MessageId: STATUS_NDIS_REQUEST_ABORTED
//
// MessageText:
//
// Netowork interface aborted the request.
//
#define STATUS_NDIS_REQUEST_ABORTED      ((NTSTATUS)0xC023000CL)

//
// MessageId: STATUS_NDIS_RESET_IN_PROGRESS
//
// MessageText:
//
// Network interface can not process the request because it is being reset.
//
#define STATUS_NDIS_RESET_IN_PROGRESS    ((NTSTATUS)0xC023000DL)

//
// MessageId: STATUS_NDIS_NOT_SUPPORTED
//
// MessageText:
//
// Netword interface does not support this request.
//
#define STATUS_NDIS_NOT_SUPPORTED        ((NTSTATUS)0xC02300BBL)

//
// MessageId: STATUS_NDIS_INVALID_PACKET
//
// MessageText:
//
// An attempt was made to send an invalid packet on a network interface.
//
#define STATUS_NDIS_INVALID_PACKET       ((NTSTATUS)0xC023000FL)

//
// MessageId: STATUS_NDIS_ADAPTER_NOT_READY
//
// MessageText:
//
// Network interface is not ready to complete this operation.
//
#define STATUS_NDIS_ADAPTER_NOT_READY    ((NTSTATUS)0xC0230011L)

//
// MessageId: STATUS_NDIS_INVALID_LENGTH
//
// MessageText:
//
// The length of the buffer submitted for this operation is not valid.
//
#define STATUS_NDIS_INVALID_LENGTH       ((NTSTATUS)0xC0230014L)

//
// MessageId: STATUS_NDIS_INVALID_DATA
//
// MessageText:
//
// The data used for this operation is not valid.
//
#define STATUS_NDIS_INVALID_DATA         ((NTSTATUS)0xC0230015L)

//
// MessageId: STATUS_NDIS_BUFFER_TOO_SHORT
//
// MessageText:
//
// The length of buffer submitted for this operation is too small.
//
#define STATUS_NDIS_BUFFER_TOO_SHORT     ((NTSTATUS)0xC0230016L)

//
// MessageId: STATUS_NDIS_INVALID_OID
//
// MessageText:
//
// Network interface does not support this OID (Object Identifier)
//
#define STATUS_NDIS_INVALID_OID          ((NTSTATUS)0xC0230017L)

//
// MessageId: STATUS_NDIS_ADAPTER_REMOVED
//
// MessageText:
//
// The network interface has been removed.
//
#define STATUS_NDIS_ADAPTER_REMOVED      ((NTSTATUS)0xC0230018L)

//
// MessageId: STATUS_NDIS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Network interface does not support this media type.
//
#define STATUS_NDIS_UNSUPPORTED_MEDIA    ((NTSTATUS)0xC0230019L)

//
// MessageId: STATUS_NDIS_GROUP_ADDRESS_IN_USE
//
// MessageText:
//
// An attempt was made to remove a token ring group address that is in use by other components.
//
#define STATUS_NDIS_GROUP_ADDRESS_IN_USE ((NTSTATUS)0xC023001AL)

//
// MessageId: STATUS_NDIS_FILE_NOT_FOUND
//
// MessageText:
//
// An attempt was made to map a file that can not be found.
//
#define STATUS_NDIS_FILE_NOT_FOUND       ((NTSTATUS)0xC023001BL)

//
// MessageId: STATUS_NDIS_ERROR_READING_FILE
//
// MessageText:
//
// An error occured while NDIS tried to map the file.
//
#define STATUS_NDIS_ERROR_READING_FILE   ((NTSTATUS)0xC023001CL)

//
// MessageId: STATUS_NDIS_ALREADY_MAPPED
//
// MessageText:
//
// An attempt was made to map a file that is alreay mapped.
//
#define STATUS_NDIS_ALREADY_MAPPED       ((NTSTATUS)0xC023001DL)

//
// MessageId: STATUS_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// An attempt to allocate a hardware resource failed because the resource is used by another component.
//
#define STATUS_NDIS_RESOURCE_CONFLICT    ((NTSTATUS)0xC023001EL)

//
// MessageId: STATUS_NDIS_MEDIA_DISCONNECTED
//
// MessageText:
//
// The I/O operation failed because network media is disconnected or wireless access point is out of range.
//
#define STATUS_NDIS_MEDIA_DISCONNECTED   ((NTSTATUS)0xC023001FL)

//
// MessageId: STATUS_NDIS_INVALID_ADDRESS
//
// MessageText:
//
// The network address used in the request is invalid.
//
#define STATUS_NDIS_INVALID_ADDRESS      ((NTSTATUS)0xC0230022L)

//
// MessageId: STATUS_NDIS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//
#define STATUS_NDIS_INVALID_DEVICE_REQUEST ((NTSTATUS)0xC0230010L)

//
// MessageId: STATUS_NDIS_PAUSED
//
// MessageText:
//
// The offload operation on the network interface has been paused.
//
#define STATUS_NDIS_PAUSED               ((NTSTATUS)0xC023002AL)

//
// MessageId: STATUS_NDIS_INTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface was not found.
//
#define STATUS_NDIS_INTERFACE_NOT_FOUND  ((NTSTATUS)0xC023002BL)

//
// MessageId: STATUS_NDIS_UNSUPPORTED_REVISION
//
// MessageText:
//
// The revision number specified in the structure is not supported.
//
#define STATUS_NDIS_UNSUPPORTED_REVISION ((NTSTATUS)0xC023002CL)

//
// MessageId: STATUS_NDIS_INVALID_PORT
//
// MessageText:
//
// The specified port does not exist on this network interface.
//
#define STATUS_NDIS_INVALID_PORT         ((NTSTATUS)0xC023002DL)

//
// MessageId: STATUS_NDIS_INVALID_PORT_STATE
//
// MessageText:
//
// The current state of the specified port on this network interface does not support the requested operation.
//
#define STATUS_NDIS_INVALID_PORT_STATE   ((NTSTATUS)0xC023002EL)

//
// MessageId: STATUS_NDIS_LOW_POWER_STATE
//
// MessageText:
//
// The miniport adapter is in lower power state.
//
#define STATUS_NDIS_LOW_POWER_STATE      ((NTSTATUS)0xC023002FL)


//
// NDIS error codes (802.11 wireless LAN)
//

//
// MessageId: STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED
//
// MessageText:
//
// The wireless local area network interface is in auto configuration mode and doesn't support the requested parameter change operation.
//
#define STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED ((NTSTATUS)0xC0232000L)

//
// MessageId: STATUS_NDIS_DOT11_MEDIA_IN_USE
//
// MessageText:
//
// The wireless local area network interface is busy and can not perform the requested operation.
//
#define STATUS_NDIS_DOT11_MEDIA_IN_USE   ((NTSTATUS)0xC0232001L)

//
// MessageId: STATUS_NDIS_DOT11_POWER_STATE_INVALID
//
// MessageText:
//
// The wireless local area network interface is power down and doesn't support the requested operation.
//
#define STATUS_NDIS_DOT11_POWER_STATE_INVALID ((NTSTATUS)0xC0232002L)

//
// NDIS informational codes(ndis.sys)
//

//
// MessageId: STATUS_NDIS_INDICATION_REQUIRED
//
// MessageText:
//
// The request will be completed later by NDIS status indication.
//
#define STATUS_NDIS_INDICATION_REQUIRED  ((NTSTATUS)0x40230001L)

//
// MessageId: STATUS_OBJECTID_NOT_FOUND
//
// MessageText:
//
// An object ID was not found in the file.
//
#define STATUS_OBJECTID_NOT_FOUND        ((NTSTATUS)0xC00002F0L)

//
// MessageId: STATUS_NO_IP_ADDRESSES
//
// MessageText:
//
// Unable to accomplish the requested task because the local machine does not have any IP addresses.
//
#define STATUS_NO_IP_ADDRESSES           ((NTSTATUS)0xC00002F1L)

//
// MessageId: STATUS_WRONG_CREDENTIAL_HANDLE
//
// MessageText:
//
// The supplied credential handle does not match the credential associated with the security context.
//
#define STATUS_WRONG_CREDENTIAL_HANDLE   ((NTSTATUS)0xC00002F2L)

//
// MessageId: STATUS_CRYPTO_SYSTEM_INVALID
//
// MessageText:
//
// The crypto system or checksum function is invalid because a required function is unavailable.
//
#define STATUS_CRYPTO_SYSTEM_INVALID     ((NTSTATUS)0xC00002F3L)

//
// MessageId: STATUS_MAX_REFERRALS_EXCEEDED
//
// MessageText:
//
// The number of maximum ticket referrals has been exceeded.
//
#define STATUS_MAX_REFERRALS_EXCEEDED    ((NTSTATUS)0xC00002F4L)

//
// MessageId: STATUS_MUST_BE_KDC
//
// MessageText:
//
// The local machine must be a Kerberos KDC (domain controller) and it is not.
//
#define STATUS_MUST_BE_KDC               ((NTSTATUS)0xC00002F5L)

//
// MessageId: STATUS_STRONG_CRYPTO_NOT_SUPPORTED
//
// MessageText:
//
// The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.
//
#define STATUS_STRONG_CRYPTO_NOT_SUPPORTED ((NTSTATUS)0xC00002F6L)

//
// MessageId: STATUS_TOO_MANY_PRINCIPALS
//
// MessageText:
//
// The KDC reply contained more than one principal name.
//
#define STATUS_TOO_MANY_PRINCIPALS       ((NTSTATUS)0xC00002F7L)

//
// MessageId: STATUS_NO_PA_DATA
//
// MessageText:
//
// Expected to find PA data for a hint of what etype to use, but it was not found.
//
#define STATUS_NO_PA_DATA                ((NTSTATUS)0xC00002F8L)

//
// MessageId: STATUS_PKINIT_NAME_MISMATCH
//
// MessageText:
//
// The client certificate does not contain a valid UPN, or does not match the client name
// in the logon request.  Please contact your administrator.
//
#define STATUS_PKINIT_NAME_MISMATCH      ((NTSTATUS)0xC00002F9L)

//
// MessageId: STATUS_SMARTCARD_LOGON_REQUIRED
//
// MessageText:
//
// Smartcard logon is required and was not used.
//
#define STATUS_SMARTCARD_LOGON_REQUIRED  ((NTSTATUS)0xC00002FAL)

//
// MessageId: STATUS_KDC_INVALID_REQUEST
//
// MessageText:
//
// An invalid request was sent to the KDC.
//
#define STATUS_KDC_INVALID_REQUEST       ((NTSTATUS)0xC00002FBL)

//
// MessageId: STATUS_KDC_UNABLE_TO_REFER
//
// MessageText:
//
// The KDC was unable to generate a referral for the service requested.
//
#define STATUS_KDC_UNABLE_TO_REFER       ((NTSTATUS)0xC00002FCL)

//
// MessageId: STATUS_KDC_UNKNOWN_ETYPE
//
// MessageText:
//
// The encryption type requested is not supported by the KDC.
//
#define STATUS_KDC_UNKNOWN_ETYPE         ((NTSTATUS)0xC00002FDL)

//
// MessageId: STATUS_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
#define STATUS_SHUTDOWN_IN_PROGRESS      ((NTSTATUS)0xC00002FEL)

//
// MessageId: STATUS_SERVER_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The server machine is shutting down.
//
#define STATUS_SERVER_SHUTDOWN_IN_PROGRESS ((NTSTATUS)0xC00002FFL)

/*lint -restore */  // Resume checking for different macro definitions // winnt
// end_ntsecapi




//start vista ntstatus.h for IPSEC codes

//
// IPSEC error codes (tcpip.sys)
//

//
// MessageId: STATUS_IPSEC_BAD_SPI
//
// MessageText:
//
// The SPI in the packet does not match a valid IPsec SA.
//
#define STATUS_IPSEC_BAD_SPI             ((NTSTATUS)0xC0360001L)

//
// MessageId: STATUS_IPSEC_SA_LIFETIME_EXPIRED
//
// MessageText:
//
// Packet was received on an IPsec SA whose lifetime has expired.
//
#define STATUS_IPSEC_SA_LIFETIME_EXPIRED ((NTSTATUS)0xC0360002L)

//
// MessageId: STATUS_IPSEC_WRONG_SA
//
// MessageText:
//
// Packet was received on an IPsec SA that doesn't match the packet characteristics.
//
#define STATUS_IPSEC_WRONG_SA            ((NTSTATUS)0xC0360003L)

//
// MessageId: STATUS_IPSEC_REPLAY_CHECK_FAILED
//
// MessageText:
//
// Packet sequence number replay check failed.
//
#define STATUS_IPSEC_REPLAY_CHECK_FAILED ((NTSTATUS)0xC0360004L)

//
// MessageId: STATUS_IPSEC_INVALID_PACKET
//
// MessageText:
//
// IPsec header and/or trailer in the packet is invalid.
//
#define STATUS_IPSEC_INVALID_PACKET      ((NTSTATUS)0xC0360005L)

//
// MessageId: STATUS_IPSEC_INTEGRITY_CHECK_FAILED
//
// MessageText:
//
// IPsec integrity check failed.
//
#define STATUS_IPSEC_INTEGRITY_CHECK_FAILED ((NTSTATUS)0xC0360006L)

//
// MessageId: STATUS_IPSEC_CLEAR_TEXT_DROP
//
// MessageText:
//
// IPsec dropped a clear text packet.
//
#define STATUS_IPSEC_CLEAR_TEXT_DROP     ((NTSTATUS)0xC0360007L)
//end vista ntstatus.h for IPSEC codes 



// Begin ntstatus.h for ALPC codes
//
// MessageId: STATUS_MESSAGE_LOST
//
// MessageText:
//
// The ALPC message requested is no longer available.
//
#define STATUS_MESSAGE_LOST              ((NTSTATUS)0xC0000701L)

// MessageId: STATUS_INVALID_MESSAGE
//
// MessageText:
//
// The ALPC message supplied is invalid.
//
#define STATUS_INVALID_MESSAGE           ((NTSTATUS)0xC0000702L)

// MessageId: STATUS_REQUEST_CANCELED
//
// MessageText:
//
// The ALPC message has been canceled.
//
#define STATUS_REQUEST_CANCELED          ((NTSTATUS)0xC0000703L)

// MessageId: STATUS_RESOURCE_IN_USE
//
// MessageText:
//
// The resource requested is already in use.
//
#define STATUS_RESOURCE_IN_USE           ((NTSTATUS)0xC0000708L)

// end ntstatus.h for ALPC codes

#endif // _NTSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\obexerr.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*****************************************************************************
*
*
* Module Name:
*
*    obexerr.h
*
* Abstract:
*
*    Error codes for OBEX
*
*****************************************************************************/

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __OBEXERR_H__
#define __OBEXERR_H__

//--------------------------------------------------------------------------
//     Core OBEX Error messages
//--------------------------------------------------------------------------

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// OBEX error codes from the IrOBEX spec mapped into HRESULTS
//
#define IR_OBEX_ERROR_BASE      0x0600
#define E_OBEX_BASE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, IR_OBEX_ERROR_BASE)
#define HRESULT_FROM_OBEX(x)    ( (x == 0x20) ? S_OK : E_OBEX_BASE | x )
#define OBEX_FROM_HRESULT       ( (x == S_OK) ? OBEX_REPLY_SUCCESS : x & 0x000000FF )
#define IS_OBEX_ERR(x)          ( (x & 0x00000F00) == IR_OBEX_ERROR_BASE )

//
// Windows specific error codes
//
#define WIN_OBEX_ERROR_BASE         0x0500
#define MAKE_OBEX_HRESULT(x)        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, WIN_OBEX_ERROR_BASE + x)

//
// MessageId: OBEX_E_DISCONNECTED
//
// MessageText:
//
//  The connection has been disconnected.
//
#define OBEX_E_DISCONNECTED                     MAKE_OBEX_HRESULT(0)

//
// MessageId: OBEX_E_ABORTED
//
// MessageText:
//
//  The request has been aborted.
//
#define OBEX_E_ABORTED                          MAKE_OBEX_HRESULT(1)

//
// MessageId: OBEX_E_NOT_INITIALIZED
//
// MessageText:
//
//  OBEX has not been initialized.
//
#define OBEX_E_NOT_INITIALIZED                  MAKE_OBEX_HRESULT(2)

//
// MessageId: OBEX_E_TRANSPORT_NOT_AVAILABLE
//
// MessageText:
//
//  The requested transport is not available.
//
#define OBEX_E_TRANSPORT_NOT_AVAILABLE          MAKE_OBEX_HRESULT(3)

// MessageId: OBEX_E_TRANSPORT_INIT
//
// MessageText:
//
//  An error occurred while initializing the transports.
//
#define OBEX_E_TRANSPORT_INIT                   MAKE_OBEX_HRESULT(4)

// MessageId: OBEX_E_ALREADY_CONNECTED
//
// MessageText:
//
//  A connection to the device has already been established.
//
#define OBEX_E_ALREADY_CONNECTED                MAKE_OBEX_HRESULT(5)

// MessageId: OBEX_E_NOT_CONNECTED
//
// MessageText:
//
//  A connection to the device has not been established.
//
#define OBEX_E_NOT_CONNECTED                    MAKE_OBEX_HRESULT(6)

// MessageId: OBEX_E_CANT_CONNECT
//
// MessageText:
//
//  A connection to the OBEX service on the remote device could not be established.
//
#define OBEX_E_CANT_CONNECT                     MAKE_OBEX_HRESULT(7)

// MessageId: OBEX_E_TIMEOUT
//
// MessageText:
//
//  A timeout occurred while communicating on the network.
//
#define OBEX_E_TIMEOUT                          MAKE_OBEX_HRESULT(8)

// MessageId: OBEX_E_NETWORK_ERROR
//
// MessageText:
//
//  An unspecified network error occurred.
//
#define OBEX_E_NETWORK_ERROR                    MAKE_OBEX_HRESULT(9)

// MessageId: OBEX_E_DEVICE_NOT_FOUND
//
// MessageText:
//
//  The specified device could not be located.
//
#define OBEX_E_DEVICE_NOT_FOUND                 MAKE_OBEX_HRESULT(0xA)

// MessageId: OBEX_E_SERIVCE_ALREADY_REGISTERED
//
// MessageText:
//
//  The specified service has already been registered.
//
#define OBEX_E_SERIVCE_ALREADY_REGISTERED       MAKE_OBEX_HRESULT(0xB)

// MessageId: OBEX_E_UNEXPECTED
//
// MessageText:
//
//  The unexpected error occurred.
//
#define OBEX_E_UNEXPECTED                       MAKE_OBEX_HRESULT(0xC)

// MessageId: OBEX_E_CONNECTION_NOT_ACCEPTED
//
// MessageText:
//
//  The connection has not yet been accepted.
//
#define OBEX_E_CONNECTION_NOT_ACCEPTED          MAKE_OBEX_HRESULT(0xD)

// MessageId: OBEX_E_STREAM_CLOSED
//
// MessageText:
//
//  The stream has been closed and can no longer be used.
//
#define OBEX_E_STREAM_CLOSED                    MAKE_OBEX_HRESULT(0xE)

#endif // #ifndef __OBEXERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\obexstrings.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*
 *	Copyright (c) Microsoft Corporation. All rights reserved.
 */


#ifndef OBEX_STRINGS_H
#define OBEX_STRINGS_H

// general strings
#define c_szDevicePropName              L"Name"
#define c_szDevicePropAddress           L"Address"
#define c_szDevicePropTransport         L"Transport"
#define c_szDeviceServiceUUID           L"ServiceUUID"
#define c_szIrda                        L"IrDA"
#define c_szBluetooth                   L"Bluetooth"
#define c_szIp                          L"TCP/IP"
#define c_szServiceName                 L"ServiceName"
#define c_szPort                        L"Port"
#define c_szIpPort                      L"650"
#define c_szCap1                        L"1"
#define c_szCap2                        L"2"
#define c_szCap4                        L"4"
#define c_szIrdaPort1                   L"OBEX:IrXfer"
#define c_szIrdaPort2                   L"OBEX"
#define c_szObex                        L"OBEX"
#define c_szInboxName                   L"Push Profile (Inbox)"
#define c_szFileBrowsingName            L"File Browsing"
#define c_szSyncName                    L"IrMC Syncronization"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\oaldma.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Module Name:  
    OALDMA.h

Abstract:  
    Constant definitions for DMA function.

Notes: 

--*/
// Define Structure and prototype for OAL DMA Function.
#ifndef __OALDMA_H_
#define __OALDMA_H_
#include <ceddk.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    CE_DMA_Speed_Compatible = 0, 
    CE_DMA_Speed_Slow, 
    CE_DMA_Speed_Medium,
    CE_DMA_Speed_High, 
    CE_DMA_Speed_Highest
} CE_DMA_SPEED;
    
typedef enum {
    CeWidth8Bits = 0, 
    CeWidth16Bits,
    CeWidth32Bits,
    CeWidth64Bits
} CE_REGISTER_ACCESS_WIDTH;

#define DMA_ADAPTER_ANY MAXDWORD
/*
  Size: Size of this structure in bytes.
  DemandMode: Set this to true if Device and DMA hardware has hardware handshaking.
  InterfaceType: Interface type on this device. It could be internal, pci, and etc. it can be found 
      from registry.
  BusNumber:    Bus number that indicates location of this hardware. It can be found from registry.
  RegisterAccessWidth: It indicates whether 8-bit, 16-bit, 32-bit or 64-bits of operation should be 
      perform during DMA Transfer.
  DmaSpeed: DMA Speed is used by this function to determine the DMA Adapter or Channel. The fastest 
      device should allocate highest priority DMA Adaptor and Channel.
  DmaAdapter: This is optional parameter. If this system only has one DMA Adapter or application 
      does not care which DMA adapter it should use, set it to DMA_ADAPTER_ANY.
  This structure is used by function DMAGetAdapter.
*/
typedef struct _DEVICE_DMA_REQUIREMENT_INFO {
  ULONG             Size;
  BOOLEAN           DemandMode;
  BOOLEAN           BusMaster;
  INTERFACE_TYPE    InterfaceType;
  ULONG             BusNumber;   
  ULONG             DeviceLocation; // For PCI, this is PCI_SLOT_NUMBER
  ULONG             DmaAdapter;
  CE_REGISTER_ACCESS_WIDTH  CeDmaWidth;
  CE_DMA_SPEED      DmaSpeed;
  DWORD             dwFlags;    // Transfer Flags that user will used for this 
} DEVICE_DMA_REQUIREMENT_INFO, *PDEVICE_DMA_REQUIREMENT_INFO;



/*
  Size: Size of this structure in bytes.
  DemandMode: Set this to true if Device and DMA hardware has hardware handshaking.
  InterfaceType: Interface type on this device. It could be internal, pci, and etc. it can be found 
    from registry.
  BusNumber:    Bus number that indicates location of this hardware. It can be found from registry.
  NumberOfTransferDescriptor: It indicates how many DMA transfer hardware can queue. Although 
    hardware only can activate one DMA transfer at one time, Multiple Transfer Descriptor support 
    will reduce software turn around time and make the data stream much more consistent.
  MaximumSizeOfEachTransfer: It indicates hardware limitation for each transfer. If any size of 
  issued transfer by OALIssueTransfer is bigger than MaxmimunSizeOfEachTransfer, it will fail.
  DmaAdapter: This system adjusted value which return by OALGetDmaAdapt.
  DmaWidth, DmaSpeed & DemandMode: Copied from DMA_REQUIREMENT_INFO. It should be same.
*/
typedef struct _CE_DMA_ADAPTER {
  ULONG             Size;  
  INTERFACE_TYPE    InterfaceType;
  ULONG             BusNumber;
  ULONG             DeviceLocation; // For PCI, this is PCI_SLOT_NUMBER
  ULONG             DmaAdapter;
  ULONG             MaximumSizeOfMappingRegister;
  ULONG             AddressBoundary;
  ULONG             AddressAlignment;
  PHYSICAL_ADDRESS  DmaSystemMemoryRangeStart;
  ULONG             DmaSystemMemoryRangeLength;
  // Copy From DMA_REQUIREMENT INFO
  CE_REGISTER_ACCESS_WIDTH  CeDmaWidth;
  CE_DMA_SPEED      DmaSpeed;
  BOOLEAN           DemandMode;
  BOOLEAN           BusMaster;
  DWORD             dwFlags;    // Transfer Flags that user will used for this 
  // May be more parameter needed here... Others.
} CE_DMA_ADAPTER, *PCE_DMA_ADAPTER;

typedef HANDLE DMA_CHANNEL_HANDLE ;
typedef HANDLE DMA_TRANSFER_HANDLE,*PDMA_TRANSFER_HANDLE;
typedef HANDLE DMA_BUFFER_HANDLE ;

typedef struct _CE_DMA_BUFFER_BLOCK {
    DWORD dwLength;
    PVOID virtualAddress;
    PHYSICAL_ADDRESS physicalAddress;
} CE_DMA_BUFFER_BLOCK,*PCE_DMA_BUFFER_BLOCK;


// Get DMA Adapter .
/* The DMAGetAdapter routine fill out a pointer to the DMA adapter structure for a physical device.*/
BOOL DMAGetAdapter (
    IN PDEVICE_DMA_REQUIREMENT_INFO pDeviceDmaRequirementInfo, //  Device Description. It descript what is capable Adapt supported.
    IN OUT PCE_DMA_ADAPTER pDmaAdapter
);


/* The AllocateAdapterChannel routine prepares the system for a DMA operation on behalf of the target device 
   and return handle that can be used by DMAAllocateChannel
*/
#define DMA_CHANNEL_ANY MAXDWORD
DMA_CHANNEL_HANDLE DMAAllocateChannel(
    IN PCE_DMA_ADAPTER     pDmaAdapter,
    IN ULONG            ulRequestedChannel,
    IN ULONG            ulAddressSpace,
    IN PHYSICAL_ADDRESS phDeviceIoAddress
);

/* This function frees a DMA Channel buffer allocated by OALAllocateAdapterChannel, along with all resources 
   the DMA Channel uses
*/
BOOL DMAFreeChannel(
   IN DMA_CHANNEL_HANDLE Channel
);


// DMA Transfer.
#define DMA_FLAGS_WRITE_TO_DEVICE       0x00000001
#define DMA_FLAGS_INC_DEVICE_ADDRESS    0x00000002
#define DMA_FLAGS_RESET_DEVICE_ADDRESS  0x00000004
#define DMA_FLAGS_USER_OPTIONAL_DEVICE  0x00000008
#define DMA_FLAGS_NOT_AUTO_START        0x80000000
/* The DMAIssueTransfer routine sets up map descriptor registers for a channel to map a DMA transfer 
   from a locked-down buffer if there is no other DMA transfers queued in the DMA Channel. Otherwise, this 
   transfer should be queued
*/
BOOL DMAIssueTransfer(
  IN HANDLE hDmaChannel,
  IN PDMA_TRANSFER_HANDLE phDmaHandle,
  IN DWORD  dwFlags,
  IN PHYSICAL_ADDRESS  SystemMemoryPhysicalAddress,
  IN PVOID CurrentVa,
  IN ULONG Length,
  IN HANDLE hNotifyHandle,
  IN PVOID Context1, IN PVOID Context2,
  IN PHYSICAL_ADDRESS  phOpDeviceIoAddress
);

/* The DMAIssueMultiBufferTransfer queue up multiple transfer in queue at once. 
*/
BOOL DMAIssueMultiBufferTransfer(
  IN HANDLE hDmaChannel,
  IN PDMA_TRANSFER_HANDLE phDmaHandle,
  IN DWORD  dwFlags,
  IN DWORD dwNumOfTransfer,
  CE_DMA_BUFFER_BLOCK pCeDmaBufferBlock[],
  IN HANDLE hNotifyHandle,
  IN PVOID Context1, IN PVOID Context2,
  IN PHYSICAL_ADDRESS  phOpDeviceIoAddress
);
//This function cancels an active DMA transfer.
BOOL DMACancelTransfer(
    IN DMA_TRANSFER_HANDLE DmaTransferHandle
);
//This function get contexts for a DMA Transfer
BOOL DMAGetContexts(
  IN DMA_TRANSFER_HANDLE hDmaTransferHandle,
  OUT PVOID * pContext1, OUT PVOID * pContext2
  );
// Put this Tranfser to Auto Start Mode
BOOL DMAStartTransfer(
  IN DMA_TRANSFER_HANDLE hDmaTransferHandle
  );    
//This function closes a DMA Transfer and release all related resource.
BOOL DMACloseTransfer(
    IN DMA_TRANSFER_HANDLE DmaTransferHandle
);

//This function get current active or queued DMA transfer status
typedef enum _DMA_STATUS {
    DMA_TRANSFER_COMPLETE = 0 ,
    DMA_TRANSFER_IN_PROGRESS,
    DMA_TRANSFER_IN_QUEUE,
    DMA_TRANSFER_COMPLETE_WITH_ERROR,
    DMA_TRANSFER_COMPLETE_WITH_CANCELED
} DMA_STATUS_CODE, *PDMA_STATUS_CODE ;
BOOL DMAGetStatus (
  IN DMA_TRANSFER_HANDLE hDmaTransferHandle,
  OUT PDWORD lpCompletedLength,
  OUT PDWORD lpCompletionCode
);

// Used to issue DMA transfer directly to hardware.
BOOL DMAIssueRawTransfer(
  IN OUT DMA_TRANSFER_HANDLE * phDmaHandle,
  IN HANDLE hDmaChannel,
  IN PVOID lpInPtr,
  IN DWORD nInLen,
  IN HANDLE hNotifyHandle,
  IN PVOID NotifyContext1,PVOID NotifyContext2
);

// Used to control DMA whose status in DMA_TRANSFER_IN_PROGRESS by hardware.
BOOL DMARawTransferControl(
  IN DMA_TRANSFER_HANDLE hDmaHandle,
  IN DWORD dwIoControl,
  IN PVOID lpInPtr,
  IN DWORD nInLen,
  IN OUT LPVOID lpOutBuffer,
  IN DWORD nOutBufferSize,
  IN LPDWORD lpBytesReturned
);

PVOID 
OALDMAAllocBuffer (
    IN  PCE_DMA_ADAPTER       Adapter,
    IN  ULONG              Length,
    OUT PPHYSICAL_ADDRESS  LogicalAddress,
    IN  BOOLEAN            CacheEnabled
    );
VOID
OALDMAFreeBuffer(
    IN PCE_DMA_ADAPTER      Adapter,
    IN ULONG             Length,
    IN PHYSICAL_ADDRESS  LogicalAddress,
    IN PVOID             VirtualAddress,
    IN BOOLEAN           CacheEnabled
    );

DMA_BUFFER_HANDLE DMAOpenBuffer(
    IN PCE_DMA_ADAPTER pDmaAdapter, 
    IN DWORD dwNumBuffer, 
    IN const PVOID pBufferArray[], 
    IN const DWORD aLength[]
);

DWORD DMAGetBufferPhysAddr (
    IN DMA_BUFFER_HANDLE hBuffer, 
    IN DWORD  NumOfBufferBlock, 
    IN OUT CE_DMA_BUFFER_BLOCK ceDmaBufferBlockArray[]
);

BOOL DMATransferOnBlocks(
    IN DMA_BUFFER_HANDLE hBuffer,
    IN HANDLE hDmaChannel,
    IN OUT PDMA_TRANSFER_HANDLE phDmaHandle,
    IN DWORD  dwFlags,
    IN PVOID  pBufferContext,
    IN HANDLE hNotifyHandle,
    IN PVOID Context1, IN PVOID Context2,
    IN PHYSICAL_ADDRESS  phOpDeviceIoAddress
);

BOOL DMAFlushBlockBuffer(
    IN DMA_BUFFER_HANDLE hBuffer
);

BOOL DMACloseBuffer(
    IN DMA_BUFFER_HANDLE hBuffer
);

#ifdef __cplusplus
};
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\obexparser.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#if ! defined(__obexparser_HXX__)
#define __obexparser_HXX__

#include <svsutil.hxx>

//
//	Obex packet structure and operation opcodes
//
//	<NF> == "netowrk format"
//
//	Packet:
//		1 byte			- opCode
//		2 bytes <NF>	- total length (headers + 3 bytes)
//		sequence of headers
//	Header:
//		1 byte			- header id + type
//		header data
//
//	Operation codes
//
#define OBEX_TYPE_UNICODE			0x00
#define OBEX_TYPE_BYTESEQ			0x40
#define OBEX_TYPE_BYTE				0x80
#define OBEX_TYPE_DWORD 			0xc0

#define OBEX_TYPE_MASK				0xc0

#define OBEX_HID_COUNT				(0x00 | OBEX_TYPE_DWORD)
#define OBEX_HID_NAME				(0x01 | OBEX_TYPE_UNICODE)
#define OBEX_HID_TYPE				(0x02 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_LENGTH				(0x03 | OBEX_TYPE_DWORD)
#define OBEX_HID_TIME_ISO			(0x04 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_TIME_COMPAT		(0x04 | OBEX_TYPE_DWORD)
#define OBEX_HID_DESCRIPTION		(0x05 | OBEX_TYPE_UNICODE)
#define OBEX_HID_TARGET				(0x06 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_HTTP				(0x07 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_BODY				(0x08 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_BODY_END			(0x09 | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_WHO				(0x0a | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_CONNECTIONID		(0x0b | OBEX_TYPE_DWORD)
#define OBEX_HID_APP_PARAMS			(0x0c | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_AUTH_CHALLENGE		(0x0d | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_AUTH_RESPONSE		(0x0e | OBEX_TYPE_BYTESEQ)
#define OBEX_HID_CLASS				(0x0f | OBEX_TYPE_BYTESEQ)

#define OBEX_OP_OPMASK				0x7f
#define OBEX_OP_ISFINAL				0x80

#define OBEX_OP_CONNECT				(0x00 | OBEX_OP_ISFINAL)
#define OBEX_OP_DISCONNECT			(0x01 | OBEX_OP_ISFINAL)
#define OBEX_OP_PUT					 0x02
#define OBEX_OP_GET					 0x03
#define OBEX_OP_SETPATH				(0x05 | OBEX_OP_ISFINAL)
#define OBEX_OP_ABORT				(0x7f | OBEX_OP_ISFINAL)

#define OBEX_STAT_CONTINUE			0x10

#define OBEX_STAT_OK				0x20
#define OBEX_STAT_CREATED			0x21
#define OBEX_STAT_ACCEPTED			0x22
#define OBEX_STAT_NONAUTHINFO		0x23
#define OBEX_STAT_NOCONTENT			0x24
#define OBEX_STAT_RESETCONTENT		0x25
#define OBEX_STAT_PARTIALCONTENT	0x26

#define OBEX_STAT_MULTIPLECHOICES	0x30
#define OBEX_STAT_MOVEDPERM			0x31
#define OBEX_STAT_MOVEDTEMP			0x32
#define OBEX_STAT_SEEOTHER			0x33
#define OBEX_STAT_NOTMODIFIED		0x34
#define OBEX_STAT_USEPROXY			0x35

#define OBEX_STAT_BADREQUEST		0x40
#define OBEX_STAT_UNAUTHORIZED		0x41
#define OBEX_STAT_PAYMENTREQD		0x42
#define OBEX_STAT_FORBIDDEN			0x43
#define OBEX_STAT_NOTFOUND			0x44
#define OBEX_STAT_NOTALLOWED		0x45
#define OBEX_STAT_NOTACCEPTABLE		0x46
#define OBEX_STAT_PROXYAUTHREQD		0x47
#define OBEX_STAT_REQUESTTIMEOUT	0x48
#define OBEX_STAT_CONFLICT			0x49
#define OBEX_STAT_GONE				0x4a
#define OBEX_STAT_LENGTHREQD		0x4b
#define OBEX_STAT_PRECONDITIONFAIL	0x4c
#define OBEX_STAT_REQENTITYTOOBIG	0x4d
#define OBEX_STAT_REQURLTOOBIG		0x4e
#define OBEX_STAT_UNSUPPORTEDMEDIA	0x4f

#define OBEX_STAT_INTERNALERROR		0x50
#define OBEX_STAT_NOTIMPLEMENTED	0x51
#define OBEX_STAT_BADGATEWAY		0x52
#define OBEX_STAT_SERVICEUNAVAIL	0x53
#define OBEX_STAT_GATEWAYTIMEOUT	0x54
#define OBEX_STAT_HTTPVUNSUPPORTED	0x55

#define OBEX_INVALID_CONNECTION		0xffffffff

#define OBEX_MAX_PACKET_SIZE		0xffff
#define OBEX_MIN_PACKET_SIZE		0xff

typedef union _obex_packet_data {
	struct {
		char			version;
		char			flags;
		unsigned short	maxlen;
	} ConnectRequestResponse;

	struct {
		char			flags;
		char			constants;
	} SetPathRequest;
} ObexPacketData;

class ObexParser {
private:
	int Trim (void) {
		if (current - start > (int)length) {
			current = start + length;
			return TRUE;
		}

		return FALSE;
	}

	int HeaderLength (void) {
		unsigned char bType = Type ();
		return ((bType == OBEX_TYPE_UNICODE) || (bType == OBEX_TYPE_BYTESEQ)) ?
				((current[1] << 8) | current[2]) : ((bType == OBEX_TYPE_BYTE) ? 2 : 5);
	}

public:
	unsigned char	*start;
	unsigned char	*current;
	unsigned int	length;

	unsigned char	*ppkt;

	unsigned int	uiOp;

	ObexParser (unsigned char *a_start, unsigned int a_length) {
		SVSUTIL_ASSERT ((a_length <= OBEX_MAX_PACKET_SIZE) && (a_length >= 3) && ((unsigned int)((a_start[1] << 8) | a_start[2]) == a_length));

		uiOp = *a_start;

		a_start += 3;
		a_length -= 3;

		if ((uiOp == OBEX_OP_CONNECT) && (a_length >= 4)) {
			ppkt = a_start;
			a_start += 4;
			a_length -= 4;
		} else if ((uiOp == OBEX_OP_SETPATH) && (a_length >= 2)) {
			ppkt = a_start;
			a_start += 2;
			a_length -= 2;
		} else
			ppkt = NULL;

		start = current = a_start;
		length = a_length;
	}

	unsigned int Op (void) {
		return uiOp;
	}

	int __EOF (void) {
		SVSUTIL_ASSERT (current - start <= (int)length);
		return current - start == (int)length;
	}

	int Type (void) {
		if (__EOF())
			return 0xffffffff;

		return *current & OBEX_TYPE_MASK;
	}

	int Code (void) {
		if (__EOF())
			return 0xffffffff;

		return *current;
	}

	int Length (void) {
		unsigned char bType = Type ();
		return ((bType == OBEX_TYPE_UNICODE) || (bType == OBEX_TYPE_BYTESEQ)) ?
				((current[1] << 8) | current[2]) - 3 : ((bType == OBEX_TYPE_BYTE) ? 1 :
				((bType == OBEX_TYPE_DWORD) ? 4 : 0));
	}

	int Next (void) {
		if (__EOF())
			return FALSE;

		current += HeaderLength ();

		return ! Trim();
	}

	int IsA (unsigned char	ucId) {
		if (__EOF())
			return FALSE;

		return *current == ucId;
	}

	int GetString (WCHAR **pszString) {
		if (__EOF() || (Type() != OBEX_TYPE_UNICODE))
			return FALSE;

		int len = HeaderLength ();
		if (len == 3) {
			*pszString = NULL;
			return TRUE;
		}

		if ((len < 3) || (current[len - 1] != '\0') || (current[len - 2] != '\0') || ((len -= 3) & 1))
			return FALSE;

		WCHAR *szRes = (WCHAR *)g_funcAlloc (len, g_pvAllocData);
		memcpy (szRes, &current[3], len);

		*pszString = szRes;

		return TRUE;
	}

	int GetString (WCHAR *szBuffer, int cChars) {
		if (__EOF() || (Type() != OBEX_TYPE_UNICODE))
			return FALSE;

		int len = HeaderLength ();

		if (len == 3) {
			if (cChars <= 0)
				return FALSE;

			*szBuffer = '\0';
			return TRUE;
		}

		if ((len < 3) || (current[len - 1] != '\0') || (current[len - 2] != '\0') || ((len -= 3) & 1) ||
			((int)(len / sizeof(WCHAR)) > (int)cChars))
			return FALSE;

		memcpy (szBuffer, &current[3], len);
		return TRUE;
	}

	int GetBytes (void **pBytes) {
		if (__EOF() || (Type() != OBEX_TYPE_BYTESEQ))
			return FALSE;

		int len = HeaderLength () - 3;
		if (len < 0)
			return FALSE;

		if (len == 0) {
			*pBytes = NULL;
			return TRUE;
		}

		unsigned char *pRes = (unsigned char *)g_funcAlloc (len, g_pvAllocData);
		memcpy (pRes, &current[3], len);

		*pBytes = pRes;

		return TRUE;
	}

	int GetBytes (void *pBuffer, int cBytes) {
		if (__EOF() || (Type() != OBEX_TYPE_BYTESEQ))
			return FALSE;

		int len = HeaderLength () - 3;
		if ((len < 0) || (len > cBytes))
			return FALSE;

		if (len > 0)
			memcpy (pBuffer, &current[3], len);

		return TRUE;
	}

	int GetBytes (unsigned char **pBuffer, int *pcBytes) {
		if (__EOF() || (Type() != OBEX_TYPE_BYTESEQ))
			return FALSE;

		int len = HeaderLength () - 3;
		if (len < 0)
			return FALSE;

		*pcBytes = len;
		*pBuffer = current + 3;

		return TRUE;
	}

	int GetDWORD (DWORD *pDW) {
		if (__EOF() || (Type() != OBEX_TYPE_DWORD))
			return FALSE;

		*pDW = (current[1] << 24) | (current[2] << 16) | (current[3] << 8) | current[4];

		return TRUE;
	}

	int GetBYTE (BYTE *pB) {
		if (__EOF() || (Type() != OBEX_TYPE_DWORD))
			return FALSE;

		*pB = current[1];

		return TRUE;
	}

	int GetCommandData (ObexPacketData *pPkt) {

		if (Op () == OBEX_OP_CONNECT) {
			if (! ppkt)
				return FALSE;
			pPkt->ConnectRequestResponse.version = ppkt[0];
			pPkt->ConnectRequestResponse.flags = ppkt[1];
			pPkt->ConnectRequestResponse.maxlen = (ppkt[2] << 8) | ppkt[3];
			return TRUE;
		} else if (Op () == OBEX_OP_SETPATH) {
			if (! ppkt)
				return FALSE;
			pPkt->SetPathRequest.flags = ppkt[0];
			pPkt->SetPathRequest.constants = ppkt[1];
			return TRUE;
		}

		return TRUE;
	}
};

#endif	// __obexparser_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\obex.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0543 */
/* Compiler settings for Obex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __Obex_h__
#define __Obex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObex_FWD_DEFINED__
#define __IObex_FWD_DEFINED__
typedef interface IObex IObex;
#endif 	/* __IObex_FWD_DEFINED__ */


#ifndef __IObex2_FWD_DEFINED__
#define __IObex2_FWD_DEFINED__
typedef interface IObex2 IObex2;
#endif 	/* __IObex2_FWD_DEFINED__ */


#ifndef __IObexDevice_FWD_DEFINED__
#define __IObexDevice_FWD_DEFINED__
typedef interface IObexDevice IObexDevice;
#endif 	/* __IObexDevice_FWD_DEFINED__ */


#ifndef __IHeaderCollection_FWD_DEFINED__
#define __IHeaderCollection_FWD_DEFINED__
typedef interface IHeaderCollection IHeaderCollection;
#endif 	/* __IHeaderCollection_FWD_DEFINED__ */


#ifndef __IObexSink_FWD_DEFINED__
#define __IObexSink_FWD_DEFINED__
typedef interface IObexSink IObexSink;
#endif 	/* __IObexSink_FWD_DEFINED__ */


#ifndef __IObexService_FWD_DEFINED__
#define __IObexService_FWD_DEFINED__
typedef interface IObexService IObexService;
#endif 	/* __IObexService_FWD_DEFINED__ */


#ifndef __IObexServiceConnection_FWD_DEFINED__
#define __IObexServiceConnection_FWD_DEFINED__
typedef interface IObexServiceConnection IObexServiceConnection;
#endif 	/* __IObexServiceConnection_FWD_DEFINED__ */


#ifndef __IInboxSink_FWD_DEFINED__
#define __IInboxSink_FWD_DEFINED__
typedef interface IInboxSink IInboxSink;
#endif 	/* __IInboxSink_FWD_DEFINED__ */


#ifndef __IHeaderEnum_FWD_DEFINED__
#define __IHeaderEnum_FWD_DEFINED__
typedef interface IHeaderEnum IHeaderEnum;
#endif 	/* __IHeaderEnum_FWD_DEFINED__ */


#ifndef __IPropertyBagEnum_FWD_DEFINED__
#define __IPropertyBagEnum_FWD_DEFINED__
typedef interface IPropertyBagEnum IPropertyBagEnum;
#endif 	/* __IPropertyBagEnum_FWD_DEFINED__ */


#ifndef __IDeviceEnum_FWD_DEFINED__
#define __IDeviceEnum_FWD_DEFINED__
typedef interface IDeviceEnum IDeviceEnum;
#endif 	/* __IDeviceEnum_FWD_DEFINED__ */


#ifndef __IObexCaps_FWD_DEFINED__
#define __IObexCaps_FWD_DEFINED__
typedef interface IObexCaps IObexCaps;
#endif 	/* __IObexCaps_FWD_DEFINED__ */


#ifndef __IObexResponse_FWD_DEFINED__
#define __IObexResponse_FWD_DEFINED__
typedef interface IObexResponse IObexResponse;
#endif 	/* __IObexResponse_FWD_DEFINED__ */


#ifndef __Obex_FWD_DEFINED__
#define __Obex_FWD_DEFINED__

#ifdef __cplusplus
typedef class Obex Obex;
#else
typedef struct Obex Obex;
#endif /* __cplusplus */

#endif 	/* __Obex_FWD_DEFINED__ */


#ifndef __HeaderCollection_FWD_DEFINED__
#define __HeaderCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class HeaderCollection HeaderCollection;
#else
typedef struct HeaderCollection HeaderCollection;
#endif /* __cplusplus */

#endif 	/* __HeaderCollection_FWD_DEFINED__ */


#ifndef __PropertyBag_FWD_DEFINED__
#define __PropertyBag_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertyBag PropertyBag;
#else
typedef struct PropertyBag PropertyBag;
#endif /* __cplusplus */

#endif 	/* __PropertyBag_FWD_DEFINED__ */


#ifndef __IrdaTransport_FWD_DEFINED__
#define __IrdaTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class IrdaTransport IrdaTransport;
#else
typedef struct IrdaTransport IrdaTransport;
#endif /* __cplusplus */

#endif 	/* __IrdaTransport_FWD_DEFINED__ */


#ifndef __BthTransport_FWD_DEFINED__
#define __BthTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class BthTransport BthTransport;
#else
typedef struct BthTransport BthTransport;
#endif /* __cplusplus */

#endif 	/* __BthTransport_FWD_DEFINED__ */


#ifndef __IpTransport_FWD_DEFINED__
#define __IpTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class IpTransport IpTransport;
#else
typedef struct IpTransport IpTransport;
#endif /* __cplusplus */

#endif 	/* __IpTransport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_Obex_0000_0000 */
/* [local] */ 

#include <obexerr.h>
#define LPPROPERTYBAG2 LPPROPERTYBAG







#define	OBEX_VERSION_10	( 0x10 )

#define	OBEX_VERSION	( OBEX_VERSION_10 )

#define	INVALID_CONN_ID	( 0xffffffff )

#define	SEND_DEVICE_UPDATES	( 0x1 )

typedef 
enum _OBEX_EVENT
    {	OE_QUERY_PASSWORD	= 0,
	OE_NEW_CONNECTION	= ( OE_QUERY_PASSWORD + 1 ) ,
	OE_NEW_COMMAND	= ( OE_NEW_CONNECTION + 1 ) ,
	OE_ABORT	= ( OE_NEW_COMMAND + 1 ) ,
	OE_DISCONNECT	= ( OE_ABORT + 1 ) ,
	OE_DEVICE_ARRIVAL	= ( OE_DISCONNECT + 1 ) ,
	OE_DEVICE_DEPARTURE	= ( OE_DEVICE_ARRIVAL + 1 ) ,
	OE_DEVICE_UPDATE	= ( OE_DEVICE_DEPARTURE + 1 ) 
    } 	OBEX_EVENT;

typedef enum _OBEX_EVENT *LPOBEX_EVENT;

typedef 
enum _INBOX_EVENT
    {	IE_MIME	= 0,
	IE_SYNC	= ( IE_MIME + 1 ) 
    } 	INBOX_EVENT;

typedef enum _INBOX_EVENT *LPINBOX_EVENT;

typedef struct _INBOX_EVENT_DATA
    {
    DWORD dwRequest;
    DWORD dwInboxEvent;
    LPCWSTR pszName;
    LPCWSTR pszInboxDestination;
    IHeaderCollection *pHeaderCol;
    IStream *pStream;
    } 	INBOX_EVENT_DATA;

typedef struct _INBOX_EVENT_DATA *PINBOX_EVENT_DATA;

#define	SETPATH_FLAG_BACKUP	( 0x1 )

#define	SETPATH_FLAG_DONT_CREATE	( 0x2 )

#define	OBEX_HEADER_UNICODE	( 0 )

#define	OBEX_HEADER_STREAM	( 0x40 )

#define	OBEX_HEADER_1BYTE	( 0x80 )

#define	OBEX_HEADER_4BYTE	( 0xc0 )

#define	OBEX_HEADER_COUNT	( ( 0 | OBEX_HEADER_4BYTE )  )

#define	OBEX_HEADER_NAME	( ( 0x1 | OBEX_HEADER_UNICODE )  )

#define	OBEX_HEADER_TYPE	( ( 0x2 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_LENGTH	( ( 0x3 | OBEX_HEADER_4BYTE )  )

#define	OBEX_HEADER_TIME_ISO	( ( 0x4 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_TIME_COMPAT	( ( 0x4 | OBEX_HEADER_4BYTE )  )

#define	OBEX_HEADER_DESCRIPTION	( ( 0x5 | OBEX_HEADER_UNICODE )  )

#define	OBEX_HEADER_TARGET	( ( 0x6 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_HTTP	( ( 0x7 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_BODY	( ( 0x8 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_END_OF_BODY	( ( 0x9 | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_WHO	( ( 0xa | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_CONNECTION_ID	( ( 0xb | OBEX_HEADER_4BYTE )  )

#define	OBEX_HEADER_APP_PARAMS	( ( 0xc | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_AUTH_CHALLENGE	( ( 0xd | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_AUTH_RESPONSE	( ( 0xe | OBEX_HEADER_STREAM )  )

#define	OBEX_HEADER_OBJECT_CLASS	( ( 0xf | OBEX_HEADER_STREAM )  )

typedef struct _OBEX_HEADER
    {
    byte bId;
    /* [switch_type] */ union 
        {
        LPWSTR pszData;
        DWORD dwData;
        byte bData;
        struct 
            {
            DWORD dwSize;
            byte *pbaData;
            } 	ba;
        } 	value;
    } 	OBEX_HEADER;

typedef struct _OBEX_REQUEST
    {
    DWORD dwRequest;
    DWORD dwFlags;
    IHeaderCollection *pHeaderCol;
    BOOL fStream;
    IStream *pStream;
    } 	OBEX_REQUEST;

typedef struct _OBEX_REQUEST *POBEX_REQUEST;

#define	OBEX_OPCODE_FINALBIT	( 0x80 )

#define	OBEX_OPCODE_CONNECT	( ( 0 | OBEX_OPCODE_FINALBIT )  )

#define	OBEX_OPCODE_DISCONNECT	( ( 0x1 | OBEX_OPCODE_FINALBIT )  )

#define	OBEX_OPCODE_PUT	( 0x2 )

#define	OBEX_OPCODE_GET	( 0x3 )

#define	OBEX_OPCODE_SET_PATH	( ( 0x5 | OBEX_OPCODE_FINALBIT )  )

#define	OBEX_OPCODE_ABORT	( ( 0x7f | OBEX_OPCODE_FINALBIT )  )

#define	OBEX_REPLY_CONTINUE	( 0x10 )

#define	OBEX_REPLY_SUCCESS	( 0x20 )

#define	OBEX_REPLY_CREATED	( 0x21 )

#define	OBEX_REPLY_ACCEPTED	( 0x22 )

#define	OBEX_REPLY_NON_AUTHORITATIVE_INFO	( 0x23 )

#define	OBEX_REPLY_NO_CONTENT	( 0x24 )

#define	OBEX_REPLY_RESET_CONTENT	( 0x25 )

#define	OBEX_REPLY_PARTIAL_CONTENT	( 0x26 )

#define	OBEX_REPLY_MULIPLE_CHOICES	( 0x30 )

#define	OBEX_REPLY_MOVED_PERMANENTLY	( 0x31 )

#define	OBEX_REPLY_MOVED_TEMPORARILY	( 0x32 )

#define	OBEX_REPLY_SEE_OTHER	( 0x33 )

#define	OBEX_REPLY_NOT_NODIFIED	( 0x34 )

#define	OBEX_REPLY_USE_PROXY	( 0x35 )

#define	OBEX_REPLY_FAIL_BAD_REQUEST	( 0x40 )

#define	OBEX_REPLY_FAIL_UNAUTHORIZED	( 0x41 )

#define	OBEX_REPLY_FAIL_PAYMENT_REQUIRED	( 0x42 )

#define	OBEX_REPLY_FAIL_FORBIDDEN	( 0x43 )

#define	OBEX_REPLY_FAIL_NOT_FOUND	( 0x44 )

#define	OBEX_REPLY_FAIL_METHOD_NOT_ALLOWED	( 0x45 )

#define	OBEX_REPLY_FAIL_NOT_ACCEPTABLE	( 0x46 )

#define	OBEX_REPLY_FAIL_PROXY_AUTHORIZATION_REQUIRED	( 0x47 )

#define	OBEX_REPLY_FAIL_REQUEST_TIME_OUT	( 0x48 )

#define	OBEX_REPLY_FAIL_CONFLICT	( 0x49 )

#define	OBEX_REPLY_FAIL_GONE	( 0x4a )

#define	OBEX_REPLY_FAIL_LENGTH_REQUIRED	( 0x4b )

#define	OBEX_REPLY_FAIL_PRECONDITION_FAILED	( 0x4c )

#define	OBEX_REPLY_FAIL_REQUESTED_ENTITY_TOO_LARGE	( 0x4d )

#define	OBEX_REPLY_FAIL_REQUEST_URL_TOO_LARGE	( 0x4e )

#define	OBEX_REPLY_FAIL_UNSUPPORTED_MEDIA_TYPE	( 0x4f )

#define	OBEX_REPLY_FAIL_INTERNAL_SERVER_ERROR	( 0x50 )

#define	OBEX_REPLY_FAIL_NOT_IMPLEMENTED	( 0x51 )

#define	OBEX_REPLY_FAIL_BAD_GATEWAY	( 0x52 )

#define	OBEX_REPLY_FAIL_SERVICE_UNAVAILABLE	( 0x53 )

#define	OBEX_REPLY_FAIL_GATEWAY_TIMEOUT	( 0x54 )

#define	OBEX_REPLY_FAIL_HTTP_VERSION_NOT_SUPPORTED	( 0x55 )

#define	OBEX_REPLY_FAIL_DATABASE_FULL	( 0x60 )

#define	OBEX_REPLY_FAIL_DATABASE_LOCKED	( 0x61 )

#define	OBEX_DEVICE_CAP_UNKNOWN	( 0 )

#define	OBEX_DEVICE_CAP_PUSH	( 0x1 )

#define	OBEX_DEVICE_CAP_FILE_BROWSE	( 0x2 )

#define	OBEX_DEVICE_CAP_SYNC	( 0x4 )



extern RPC_IF_HANDLE __MIDL_itf_Obex_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_Obex_0000_0000_v0_0_s_ifspec;

#ifndef __IObex_INTERFACE_DEFINED__
#define __IObex_INTERFACE_DEFINED__

/* interface IObex */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C5A5B12-2979-42D1-9E15-A63E34383B58")
    IObex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IDeviceEnum **ppDeviceEnum,
            /* [in] */ REFCLSID uuidTransport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTransports( 
            /* [out] */ IPropertyBagEnum **ppTransportEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterService( 
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexService **ppService) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BindToDevice( 
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexDevice **ppDevice) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StartDeviceEnum( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE StopDeviceEnum( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObex * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDevices )( 
            IObex * This,
            /* [out] */ IDeviceEnum **ppDeviceEnum,
            /* [in] */ REFCLSID uuidTransport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumTransports )( 
            IObex * This,
            /* [out] */ IPropertyBagEnum **ppTransportEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IObex * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexService **ppService);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BindToDevice )( 
            IObex * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexDevice **ppDevice);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartDeviceEnum )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopDeviceEnum )( 
            IObex * This);
        
        END_INTERFACE
    } IObexVtbl;

    interface IObex
    {
        CONST_VTBL struct IObexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObex_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define IObex_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IObex_EnumDevices(This,ppDeviceEnum,uuidTransport)	\
    ( (This)->lpVtbl -> EnumDevices(This,ppDeviceEnum,uuidTransport) ) 

#define IObex_EnumTransports(This,ppTransportEnum)	\
    ( (This)->lpVtbl -> EnumTransports(This,ppTransportEnum) ) 

#define IObex_RegisterService(This,pPropertyBag,ppService)	\
    ( (This)->lpVtbl -> RegisterService(This,pPropertyBag,ppService) ) 

#define IObex_BindToDevice(This,pPropertyBag,ppDevice)	\
    ( (This)->lpVtbl -> BindToDevice(This,pPropertyBag,ppDevice) ) 

#define IObex_StartDeviceEnum(This)	\
    ( (This)->lpVtbl -> StartDeviceEnum(This) ) 

#define IObex_StopDeviceEnum(This)	\
    ( (This)->lpVtbl -> StopDeviceEnum(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObex_INTERFACE_DEFINED__ */


#ifndef __IObex2_INTERFACE_DEFINED__
#define __IObex2_INTERFACE_DEFINED__

/* interface IObex2 */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObex2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8FF83D03-CD48-420a-83DD-52D39E8607E2")
    IObex2 : public IObex
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE PauseDeviceEnum( 
            BOOL fPauseOn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObex2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObex2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObex2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObex2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IObex2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IObex2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDevices )( 
            IObex2 * This,
            /* [out] */ IDeviceEnum **ppDeviceEnum,
            /* [in] */ REFCLSID uuidTransport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumTransports )( 
            IObex2 * This,
            /* [out] */ IPropertyBagEnum **ppTransportEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IObex2 * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexService **ppService);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BindToDevice )( 
            IObex2 * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexDevice **ppDevice);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StartDeviceEnum )( 
            IObex2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *StopDeviceEnum )( 
            IObex2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *PauseDeviceEnum )( 
            IObex2 * This,
            BOOL fPauseOn);
        
        END_INTERFACE
    } IObex2Vtbl;

    interface IObex2
    {
        CONST_VTBL struct IObex2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObex2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObex2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObex2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObex2_Initialize(This)	\
    ( (This)->lpVtbl -> Initialize(This) ) 

#define IObex2_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IObex2_EnumDevices(This,ppDeviceEnum,uuidTransport)	\
    ( (This)->lpVtbl -> EnumDevices(This,ppDeviceEnum,uuidTransport) ) 

#define IObex2_EnumTransports(This,ppTransportEnum)	\
    ( (This)->lpVtbl -> EnumTransports(This,ppTransportEnum) ) 

#define IObex2_RegisterService(This,pPropertyBag,ppService)	\
    ( (This)->lpVtbl -> RegisterService(This,pPropertyBag,ppService) ) 

#define IObex2_BindToDevice(This,pPropertyBag,ppDevice)	\
    ( (This)->lpVtbl -> BindToDevice(This,pPropertyBag,ppDevice) ) 

#define IObex2_StartDeviceEnum(This)	\
    ( (This)->lpVtbl -> StartDeviceEnum(This) ) 

#define IObex2_StopDeviceEnum(This)	\
    ( (This)->lpVtbl -> StopDeviceEnum(This) ) 


#define IObex2_PauseDeviceEnum(This,fPauseOn)	\
    ( (This)->lpVtbl -> PauseDeviceEnum(This,fPauseOn) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObex2_INTERFACE_DEFINED__ */


#ifndef __IObexDevice_INTERFACE_DEFINED__
#define __IObexDevice_INTERFACE_DEFINED__

/* interface IObexDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ED60A15-6FB0-4A81-8ED3-49097A8E292C")
    IObexDevice : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [unique][string][in] */ LPCWSTR pszPassword,
            /* [in] */ DWORD dwCapability,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ IHeaderCollection *pHeaders,
            /* [out] */ IStream **ppStream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ IHeaderCollection *pHeaders,
            /* [unique][out][in] */ IStream **ppStream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ LPCWSTR pszPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [in] */ DWORD dwCapability,
            /* [out] */ IStorage **ppStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexDevice * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IObexDevice * This,
            /* [unique][string][in] */ LPCWSTR pszPassword,
            /* [in] */ DWORD dwCapability,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders,
            /* [out] */ IStream **ppStream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders,
            /* [unique][out][in] */ IStream **ppStream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IObexDevice * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            IObexDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IObexDevice * This,
            /* [in] */ LPCWSTR pszPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IObexDevice * This,
            /* [in] */ DWORD dwCapability,
            /* [out] */ IStorage **ppStorage);
        
        END_INTERFACE
    } IObexDeviceVtbl;

    interface IObexDevice
    {
        CONST_VTBL struct IObexDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexDevice_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexDevice_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexDevice_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexDevice_Connect(This,pszPassword,dwCapability,pHeaders)	\
    ( (This)->lpVtbl -> Connect(This,pszPassword,dwCapability,pHeaders) ) 

#define IObexDevice_Disconnect(This,pHeaders)	\
    ( (This)->lpVtbl -> Disconnect(This,pHeaders) ) 

#define IObexDevice_Get(This,pHeaders,ppStream)	\
    ( (This)->lpVtbl -> Get(This,pHeaders,ppStream) ) 

#define IObexDevice_Put(This,pHeaders,ppStream)	\
    ( (This)->lpVtbl -> Put(This,pHeaders,ppStream) ) 

#define IObexDevice_Abort(This,pHeaders)	\
    ( (This)->lpVtbl -> Abort(This,pHeaders) ) 

#define IObexDevice_SetPath(This,pszName,dwFlags,pHeaders)	\
    ( (This)->lpVtbl -> SetPath(This,pszName,dwFlags,pHeaders) ) 

#define IObexDevice_EnumProperties(This,riid,ppv)	\
    ( (This)->lpVtbl -> EnumProperties(This,riid,ppv) ) 

#define IObexDevice_SetPassword(This,pszPassword)	\
    ( (This)->lpVtbl -> SetPassword(This,pszPassword) ) 

#define IObexDevice_BindToStorage(This,dwCapability,ppStorage)	\
    ( (This)->lpVtbl -> BindToStorage(This,dwCapability,ppStorage) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexDevice_INTERFACE_DEFINED__ */


#ifndef __IHeaderCollection_INTERFACE_DEFINED__
#define __IHeaderCollection_INTERFACE_DEFINED__

/* interface IHeaderCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6561D66B-8CC1-49F9-8071-632D288EDAF3")
    IHeaderCollection : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddByteArray( 
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddLong( 
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddByte( 
            /* [in] */ byte Id,
            /* [in] */ byte pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddUnicodeString( 
            /* [in] */ byte Id,
            /* [in] */ LPCWSTR pszData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ byte Id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddCount( 
            /* [in] */ unsigned long ulCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddName( 
            /* [in] */ LPCWSTR pszName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddType( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddLength( 
            /* [in] */ unsigned long ulLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTimeOld( 
            /* [in] */ unsigned long ulTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTime( 
            /* [in] */ FILETIME *pFiletime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDescription( 
            /* [in] */ LPCWSTR pszDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTarget( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHTTP( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBody( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddEndOfBody( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWho( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddConnectionId( 
            /* [in] */ unsigned long ulConnectionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAppParams( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddObjectClass( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumHeaders( 
            /* [out] */ IHeaderEnum **pHeaderEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHeaderCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHeaderCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHeaderCollection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddByteArray )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddLong )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddByte )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ byte pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddUnicodeString )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ LPCWSTR pszData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IHeaderCollection * This,
            /* [in] */ byte Id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IHeaderCollection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddCount )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddName )( 
            IHeaderCollection * This,
            /* [in] */ LPCWSTR pszName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddType )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddLength )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTimeOld )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTime )( 
            IHeaderCollection * This,
            /* [in] */ FILETIME *pFiletime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDescription )( 
            IHeaderCollection * This,
            /* [in] */ LPCWSTR pszDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTarget )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddHTTP )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBody )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddEndOfBody )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddWho )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddConnectionId )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulConnectionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAppParams )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddObjectClass )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumHeaders )( 
            IHeaderCollection * This,
            /* [out] */ IHeaderEnum **pHeaderEnum);
        
        END_INTERFACE
    } IHeaderCollectionVtbl;

    interface IHeaderCollection
    {
        CONST_VTBL struct IHeaderCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCollection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHeaderCollection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHeaderCollection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHeaderCollection_AddByteArray(This,Id,ulSize,pData)	\
    ( (This)->lpVtbl -> AddByteArray(This,Id,ulSize,pData) ) 

#define IHeaderCollection_AddLong(This,Id,ulData)	\
    ( (This)->lpVtbl -> AddLong(This,Id,ulData) ) 

#define IHeaderCollection_AddByte(This,Id,pData)	\
    ( (This)->lpVtbl -> AddByte(This,Id,pData) ) 

#define IHeaderCollection_AddUnicodeString(This,Id,pszData)	\
    ( (This)->lpVtbl -> AddUnicodeString(This,Id,pszData) ) 

#define IHeaderCollection_Remove(This,Id)	\
    ( (This)->lpVtbl -> Remove(This,Id) ) 

#define IHeaderCollection_RemoveAll(This)	\
    ( (This)->lpVtbl -> RemoveAll(This) ) 

#define IHeaderCollection_AddCount(This,ulCount)	\
    ( (This)->lpVtbl -> AddCount(This,ulCount) ) 

#define IHeaderCollection_AddName(This,pszName)	\
    ( (This)->lpVtbl -> AddName(This,pszName) ) 

#define IHeaderCollection_AddType(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddType(This,ulSize,pData) ) 

#define IHeaderCollection_AddLength(This,ulLength)	\
    ( (This)->lpVtbl -> AddLength(This,ulLength) ) 

#define IHeaderCollection_AddTimeOld(This,ulTime)	\
    ( (This)->lpVtbl -> AddTimeOld(This,ulTime) ) 

#define IHeaderCollection_AddTime(This,pFiletime)	\
    ( (This)->lpVtbl -> AddTime(This,pFiletime) ) 

#define IHeaderCollection_AddDescription(This,pszDescription)	\
    ( (This)->lpVtbl -> AddDescription(This,pszDescription) ) 

#define IHeaderCollection_AddTarget(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddTarget(This,ulSize,pData) ) 

#define IHeaderCollection_AddHTTP(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddHTTP(This,ulSize,pData) ) 

#define IHeaderCollection_AddBody(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddBody(This,ulSize,pData) ) 

#define IHeaderCollection_AddEndOfBody(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddEndOfBody(This,ulSize,pData) ) 

#define IHeaderCollection_AddWho(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddWho(This,ulSize,pData) ) 

#define IHeaderCollection_AddConnectionId(This,ulConnectionId)	\
    ( (This)->lpVtbl -> AddConnectionId(This,ulConnectionId) ) 

#define IHeaderCollection_AddAppParams(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddAppParams(This,ulSize,pData) ) 

#define IHeaderCollection_AddObjectClass(This,ulSize,pData)	\
    ( (This)->lpVtbl -> AddObjectClass(This,ulSize,pData) ) 

#define IHeaderCollection_EnumHeaders(This,pHeaderEnum)	\
    ( (This)->lpVtbl -> EnumHeaders(This,pHeaderEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHeaderCollection_INTERFACE_DEFINED__ */


#ifndef __IObexSink_INTERFACE_DEFINED__
#define __IObexSink_INTERFACE_DEFINED__

/* interface IObexSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80DFC5AB-BF07-4612-BACE-AEBC0129590A")
    IObexSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ OBEX_EVENT Event,
            /* [in] */ IUnknown *pUnk1,
            /* [in] */ IUnknown *pUnk2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IObexSink * This,
            /* [in] */ OBEX_EVENT Event,
            /* [in] */ IUnknown *pUnk1,
            /* [in] */ IUnknown *pUnk2);
        
        END_INTERFACE
    } IObexSinkVtbl;

    interface IObexSink
    {
        CONST_VTBL struct IObexSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexSink_Notify(This,Event,pUnk1,pUnk2)	\
    ( (This)->lpVtbl -> Notify(This,Event,pUnk1,pUnk2) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexSink_INTERFACE_DEFINED__ */


#ifndef __IObexService_INTERFACE_DEFINED__
#define __IObexService_INTERFACE_DEFINED__

/* interface IObexService */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B00990A-010D-4F19-AE6C-D60DA9B3783E")
    IObexService : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [out] */ IObexServiceConnection **ppConnection,
            /* [in] */ boolean fWait) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ LPCWSTR pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IObexService * This,
            /* [out] */ IObexServiceConnection **ppConnection,
            /* [in] */ boolean fWait);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IObexService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IObexService * This,
            /* [in] */ LPCWSTR pszPassword);
        
        END_INTERFACE
    } IObexServiceVtbl;

    interface IObexService
    {
        CONST_VTBL struct IObexServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexService_GetConnection(This,ppConnection,fWait)	\
    ( (This)->lpVtbl -> GetConnection(This,ppConnection,fWait) ) 

#define IObexService_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IObexService_SetPassword(This,pszPassword)	\
    ( (This)->lpVtbl -> SetPassword(This,pszPassword) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexService_INTERFACE_DEFINED__ */


#ifndef __IObexServiceConnection_INTERFACE_DEFINED__
#define __IObexServiceConnection_INTERFACE_DEFINED__

/* interface IObexServiceConnection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexServiceConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB258BBB-678B-414A-81A3-CB98B669EDD7")
    IObexServiceConnection : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Accept( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ IHeaderCollection *pExtraHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [out][in] */ OBEX_REQUEST *pRequest,
            /* [in] */ boolean fWait) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendResponse( 
            /* [in] */ DWORD dwResponse,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumHeaders( 
            /* [out] */ IHeaderEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexServiceConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexServiceConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexServiceConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexServiceConnection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Accept )( 
            IObexServiceConnection * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IObexServiceConnection * This,
            /* [in] */ IHeaderCollection *pExtraHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCommand )( 
            IObexServiceConnection * This,
            /* [out][in] */ OBEX_REQUEST *pRequest,
            /* [in] */ boolean fWait);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendResponse )( 
            IObexServiceConnection * This,
            /* [in] */ DWORD dwResponse,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            IObexServiceConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumHeaders )( 
            IObexServiceConnection * This,
            /* [out] */ IHeaderEnum **ppEnum);
        
        END_INTERFACE
    } IObexServiceConnectionVtbl;

    interface IObexServiceConnection
    {
        CONST_VTBL struct IObexServiceConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexServiceConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexServiceConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexServiceConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexServiceConnection_Accept(This,pHeaders)	\
    ( (This)->lpVtbl -> Accept(This,pHeaders) ) 

#define IObexServiceConnection_Close(This,pExtraHeaders)	\
    ( (This)->lpVtbl -> Close(This,pExtraHeaders) ) 

#define IObexServiceConnection_GetCommand(This,pRequest,fWait)	\
    ( (This)->lpVtbl -> GetCommand(This,pRequest,fWait) ) 

#define IObexServiceConnection_SendResponse(This,dwResponse,pHeaders)	\
    ( (This)->lpVtbl -> SendResponse(This,dwResponse,pHeaders) ) 

#define IObexServiceConnection_EnumProperties(This,riid,ppv)	\
    ( (This)->lpVtbl -> EnumProperties(This,riid,ppv) ) 

#define IObexServiceConnection_EnumHeaders(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumHeaders(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexServiceConnection_INTERFACE_DEFINED__ */


#ifndef __IInboxSink_INTERFACE_DEFINED__
#define __IInboxSink_INTERFACE_DEFINED__

/* interface IInboxSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInboxSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5335417D-96D5-4AB4-9EF0-8F29C82232A3")
    IInboxSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ INBOX_EVENT_DATA *pInboxData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInboxSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInboxSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInboxSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInboxSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IInboxSink * This,
            /* [in] */ INBOX_EVENT_DATA *pInboxData);
        
        END_INTERFACE
    } IInboxSinkVtbl;

    interface IInboxSink
    {
        CONST_VTBL struct IInboxSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInboxSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInboxSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInboxSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInboxSink_Notify(This,pInboxData)	\
    ( (This)->lpVtbl -> Notify(This,pInboxData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInboxSink_INTERFACE_DEFINED__ */


#ifndef __IHeaderEnum_INTERFACE_DEFINED__
#define __IHeaderEnum_INTERFACE_DEFINED__

/* interface IHeaderEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5507423D-0DD6-443D-A3CF-756D8E725C77")
    IHeaderEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ OBEX_HEADER **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IHeaderEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHeaderEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHeaderEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHeaderEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IHeaderEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ OBEX_HEADER **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IHeaderEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IHeaderEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IHeaderEnum * This,
            /* [out] */ IHeaderEnum **ppenum);
        
        END_INTERFACE
    } IHeaderEnumVtbl;

    interface IHeaderEnum
    {
        CONST_VTBL struct IHeaderEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderEnum_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IHeaderEnum_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IHeaderEnum_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IHeaderEnum_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IHeaderEnum_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IHeaderEnum_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IHeaderEnum_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IHeaderEnum_INTERFACE_DEFINED__ */


#ifndef __IPropertyBagEnum_INTERFACE_DEFINED__
#define __IPropertyBagEnum_INTERFACE_DEFINED__

/* interface IPropertyBagEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertyBagEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6194770D-2B61-47DE-8628-33C42E091181")
    IPropertyBagEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPPROPERTYBAG *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IPropertyBagEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyBagEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyBagEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyBagEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyBagEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IPropertyBagEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPPROPERTYBAG *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IPropertyBagEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IPropertyBagEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IPropertyBagEnum * This,
            /* [out] */ IPropertyBagEnum **ppenum);
        
        END_INTERFACE
    } IPropertyBagEnumVtbl;

    interface IPropertyBagEnum
    {
        CONST_VTBL struct IPropertyBagEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyBagEnum_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPropertyBagEnum_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPropertyBagEnum_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPropertyBagEnum_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IPropertyBagEnum_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IPropertyBagEnum_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IPropertyBagEnum_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPropertyBagEnum_INTERFACE_DEFINED__ */


#ifndef __IDeviceEnum_INTERFACE_DEFINED__
#define __IDeviceEnum_INTERFACE_DEFINED__

/* interface IDeviceEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDeviceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53B5F567-DFE3-46DF-985A-BB993AE1AB00")
    IDeviceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IObexDevice **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDeviceEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDeviceEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IObexDevice **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDeviceEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDeviceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDeviceEnum * This,
            /* [out] */ IDeviceEnum **ppenum);
        
        END_INTERFACE
    } IDeviceEnumVtbl;

    interface IDeviceEnum
    {
        CONST_VTBL struct IDeviceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceEnum_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDeviceEnum_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDeviceEnum_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDeviceEnum_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IDeviceEnum_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IDeviceEnum_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IDeviceEnum_Clone(This,ppenum)	\
    ( (This)->lpVtbl -> Clone(This,ppenum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDeviceEnum_INTERFACE_DEFINED__ */


#ifndef __IObexCaps_INTERFACE_DEFINED__
#define __IObexCaps_INTERFACE_DEFINED__

/* interface IObexCaps */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexCaps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("265CB2AB-EEDE-4f0e-A2D9-DF03C067EE56")
    IObexCaps : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetCaps( 
            /* [in] */ DWORD dwCaps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexCapsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexCaps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexCaps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexCaps * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetCaps )( 
            IObexCaps * This,
            /* [in] */ DWORD dwCaps);
        
        END_INTERFACE
    } IObexCapsVtbl;

    interface IObexCaps
    {
        CONST_VTBL struct IObexCapsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexCaps_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexCaps_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexCaps_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexCaps_SetCaps(This,dwCaps)	\
    ( (This)->lpVtbl -> SetCaps(This,dwCaps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexCaps_INTERFACE_DEFINED__ */


#ifndef __IObexResponse_INTERFACE_DEFINED__
#define __IObexResponse_INTERFACE_DEFINED__

/* interface IObexResponse */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexResponse;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dddc1a8f-1e12-46d8-856c-d238a85ad10f")
    IObexResponse : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLastResponseCode( 
            /* [size_is][out] */ BYTE *pResponseCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexResponse * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexResponse * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexResponse * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLastResponseCode )( 
            IObexResponse * This,
            /* [size_is][out] */ BYTE *pResponseCode);
        
        END_INTERFACE
    } IObexResponseVtbl;

    interface IObexResponse
    {
        CONST_VTBL struct IObexResponseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexResponse_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IObexResponse_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IObexResponse_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IObexResponse_GetLastResponseCode(This,pResponseCode)	\
    ( (This)->lpVtbl -> GetLastResponseCode(This,pResponseCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IObexResponse_INTERFACE_DEFINED__ */



#ifndef __OBEXLib_LIBRARY_DEFINED__
#define __OBEXLib_LIBRARY_DEFINED__

/* library OBEXLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_OBEXLib;

EXTERN_C const CLSID CLSID_Obex;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc00-59b6-40bb-aa2b-89eb49ef274e")
Obex;
#endif

EXTERN_C const CLSID CLSID_HeaderCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc01-59b6-40bb-aa2b-89eb49ef274e")
HeaderCollection;
#endif

EXTERN_C const CLSID CLSID_PropertyBag;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc05-59b6-40bb-aa2b-89eb49ef274e")
PropertyBag;
#endif

EXTERN_C const CLSID CLSID_IrdaTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC02-59B6-40BB-AA2B-89EB49EF274E")
IrdaTransport;
#endif

EXTERN_C const CLSID CLSID_BthTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC03-59B6-40BB-AA2B-89EB49EF274E")
BthTransport;
#endif

EXTERN_C const CLSID CLSID_IpTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC04-59B6-40BB-AA2B-89EB49EF274E")
IpTransport;
#endif
#endif /* __OBEXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\obexserver.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#if ! defined (__obex_H__)
#define __obex_H__

#include <ws2bth.h>

//
//	Requests
//
#define OBEX_REQ_REQUEST			0x00000001
#define OBEX_REQ_CLOSE				0x00000002
#define OBEX_REQ_INIT				0x00000003
#define OBEX_REQ_UNLOAD				0x00000004

//
//	Responses
//
#define OBEX_RESP_RESPOND			0x00000001
#define OBEX_RESP_OK				0x00000002
#define OBEX_RESP_ACCEPT			0x00000003
#define OBEX_RESP_REJECT			0x00000004
#define OBEX_RESP_DENY				0x00000005
#define OBEX_RESP_CONTINUE			0x00000006
#define OBEX_RESP_ABORT				0x00000007
#define OBEX_RESP_DISCONNECT		0x00000008
#define OBEX_RESP_HANGUP			0x00000009

//
//	Obex Service Transaction
//
//	When obex server receives request, it parses it into headers and values and calls service
//	referenced in the request through ServiceCallback. Service must format the response and
//	send it through ServerCallback or ask obex server to format and send one of the standard
//	canned responses such as disconnect, abort, accept, reject or continue.
//
//	Service callback shall not return until the request is dispatched.
//
//	Service callback shall use routines supplied in ObexTransaction structure
//	for its internal memory allocation. Service shall not spin threads or store
//	pointers into Server's code.
//

typedef void *(*MemAlloc)(int cBytes);
typedef void (*MemFree)  (void *pMem);
typedef int  (*ServerCallback)  (unsigned int uiOp, unsigned int uiId, struct _obex_command *pCommand);
typedef int  (*ServiceCallback) (struct _obex_transaction *pTrans);

//return values (for return code)
//  0  ==  FAILED (transport supports auth)
//  1  ==  SUCCESS
//  2  ==  NOT_SUPPORTED (transport doesnt support auth)
typedef HRESULT  (*AuthCallback) (unsigned int uiTransactionId, UINT *uiRetCode);


//return values (for return code)
//  0  ==  FAILED (transport supports auth)
//  1  ==  SUCCESS
//  2  ==  NOT_SUPPORTED (transport doesnt support auth)
typedef HRESULT  (*EncryptionCallback) (unsigned int uiTransactionId, UINT *uiRetCode);


//compute a hash of the passed in token,  pDestSize is [in/out] taking the size
//   of the destbuffer and returning the size used
typedef HRESULT  (*ComputeHash) (unsigned char *orig, unsigned int len, unsigned char *dest, unsigned int *pDestSize);

//get peer information of the passed in transaction ID;
//   remoteInfo is the [out] struct that will be filled.
//return values (for return code)
//  S_OK                == success
//  ERROR_NOT_SUPPORTED == currently only support Bluetooth (AF_BT), so any other transport will see this error.
//  E_FAIL              == failure related to getting the remote info.
typedef HRESULT  (*GetRemoteInfo) (unsigned int uiTransactionId, struct _obex_bt_remote_info& remoteInfo);

typedef union {
	unsigned char	uc;
	unsigned int	ui;
	WCHAR			*pwsz;
	struct {
		unsigned int	cuc;
		unsigned char	*puc;
	} caub;
} ObexVariant;

typedef struct _obex_command {
	unsigned int	uiOp;
	unsigned int	uiResp;
	unsigned int	fFinal;
	ObexPacketData	sPktData;
	unsigned int	cProp;
	unsigned int	*aPropID;
	ObexVariant		*aPropVar;
} ObexCommand;

typedef struct _obex_transaction {
	unsigned int	uiConnectionId;
	unsigned int	uiTransactionId;

	unsigned int	uiOp;

	ObexCommand		*pObex;

	MemAlloc		ObexAlloc;
	MemFree			ObexFree;
	ServerCallback	ObexExecute;
	AuthCallback	ObexAuthRequest;
	EncryptionCallback ObexEncryptionRequest;	
    ComputeHash     ObexComputeHash;
    GetRemoteInfo ObexGetRemoteInfo;
} ObexTransaction;

typedef struct _obex_bt_remote_info {
    //       The pwszName member is the remote device's friendly name.
    BT_ADDR     address;
    WCHAR       pwszName[BTH_MAX_NAME_SIZE];
} ObexRemoteInfo;

//
//	AF_INET, AF_IRDA, [AF_BT]
//
#define OBEX_PROTOCOLS				2

#define OBEX_KEY_BASE		L"Software\\Microsoft\\Obex"
#define OBEX_KEY_SERVERS	L"Software\\Microsoft\\Obex\\Services"
#define OBEX_KEY_OBJECTS	L"Software\\Microsoft\\Obex\\Objects"

//
//	File browser API
//
#if defined (__cplusplus)
extern "C" {
#endif

extern "C" GUID CLSID_FileExchange;

#if defined (__cplusplus)
};
#endif

#define OBEX_TCP_PORT			650



#endif // __obex_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\objbase.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  File:       objbase.h
//
//  Contents:   Component object model defintions.
//
//----------------------------------------------------------------------------

#include <rpc.h>
#include <rpcndr.h>

#if !defined( _OBJBASE_H_ )
#define _OBJBASE_H_

#include <pshpack8.h>

#if defined (UNDER_CE)
#define STORAGE_NONPERSISTENT  0x535447
#endif

#ifdef _MAC
#ifndef _WLM_NOFORCE_LIBS

#ifdef _WLMDLL
        #ifdef _DEBUG
                #pragma comment(lib, "oledlgd.lib")
                #pragma comment(lib, "msvcoled.lib")
        #else
                #pragma comment(lib, "oledlg.lib")
                #pragma comment(lib, "msvcole.lib")
        #endif
#else
        #ifdef _DEBUG
                #pragma comment(lib, "wlmoled.lib")
                #pragma comment(lib, "ole2uid.lib")
        #else
                #pragma comment(lib, "wlmole.lib")
                #pragma comment(lib, "ole2ui.lib")
        #endif
        #pragma data_seg(".drectve")
        static char _gszWlmOLEUIResourceDirective[] = "/macres:ole2ui.rsc";
        #pragma data_seg()
#endif

#pragma comment(lib, "uuid.lib")

#ifdef _DEBUG
    #pragma comment(lib, "ole2d.lib")
    #pragma comment(lib, "ole2autd.lib")
#else
    #pragma comment(lib, "ole2.lib")
    #pragma comment(lib, "ole2auto.lib")
#endif

#endif // !_WLM_NOFORCE_LIBS
#endif // _MAC

// Component Object Model defines, and macros

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

#define IFACEMETHOD(method)         __override STDMETHOD(method)
#define IFACEMETHOD_(type,method)   __override STDMETHOD_(type,method)
#define IFACEMETHODV(method)        __override STDMETHODV(method)
#define IFACEMETHODV_(type,method)  __override STDMETHODV_(type,method)

#define IFACEMETHODIMP          __override STDMETHODIMP
#define IFACEMETHODIMP_(type)   __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#define IFACEMETHODIMPV          __override STDMETHODIMPV
#define IFACEMETHODIMPV_(type)   __override STDMETHODIMPV_(type)


#if defined(_OLE32_) || defined(OLE_NO_DECLSPEC_IMPORT)
#define WINOLEAPI        STDAPI
#define WINOLEAPI_(type) STDAPI_(type)
#else

#ifdef _68K_
#ifndef REQUIRESAPPLEPASCAL
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT PASCAL
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type PASCAL
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT PASCAL HRESULT
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT PASCAL type
#endif
#else
#define WINOLEAPI        EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define WINOLEAPI_(type) EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#endif

#endif

/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simultaneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declarations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */

#if defined(__cplusplus) && !defined(CINTERFACE)
//#define interface               struct FAR
#define interface struct
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface
#define DECLARE_INTERFACE_IID(iface, iid)               interface DECLSPEC_UUID(iid)  iface
#define DECLARE_INTERFACE_IID_(iface, baseiface, iid)   interface DECLSPEC_UUID(iid)  iface : public baseiface

#if !defined(BEGIN_INTERFACE)
#if defined(_MPPC_)  && \
    ( (defined(_MSC_VER) || defined(__SC__) || defined(__MWERKS__)) && \
    !defined(NO_NULL_VTABLE_ENTRY) )
   #define BEGIN_INTERFACE virtual void a() {}
   #define END_INTERFACE
#else
   #define BEGIN_INTERFACE
   #define END_INTERFACE
#endif
#endif

//  IID_PPV_ARGS(ppType)
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
extern "C++"
{
    template<typename T> void** IID_PPV_ARGS_Helper(T** pp) 
    {
        // make sure everyone derives from IUnknown
        static_cast<IUnknown*>(*pp);
        
        return reinterpret_cast<void**>(pp);
    }
}

#define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), IID_PPV_ARGS_Helper(ppType)


#else

#define interface               struct

#define STDMETHOD(method)       HRESULT (STDMETHODCALLTYPE * method)
#define STDMETHOD_(type,method) type (STDMETHODCALLTYPE * method)

#if !defined(BEGIN_INTERFACE)
#if defined(_MPPC_)
    #define BEGIN_INTERFACE       void    *b;
    #define END_INTERFACE
#else
    #define BEGIN_INTERFACE
    #define END_INTERFACE
#endif
#endif


#define PURE
#define THIS_                   INTERFACE FAR* This,
#define THIS                    INTERFACE FAR* This
#ifdef CONST_VTABLE
#undef CONST_VTBL
#define CONST_VTBL const
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    const struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef const struct iface##Vtbl iface##Vtbl; \
                                const struct iface##Vtbl
#else
#undef CONST_VTBL
#define CONST_VTBL
#define DECLARE_INTERFACE(iface)    typedef interface iface { \
                                    struct iface##Vtbl FAR* lpVtbl; \
                                } iface; \
                                typedef struct iface##Vtbl iface##Vtbl; \
                                struct iface##Vtbl
#endif
#define DECLARE_INTERFACE_(iface, baseiface)    DECLARE_INTERFACE(iface)
#define DECLARE_INTERFACE_IID(iface, iid)               DECLARE_INTERFACE(iface)
#define DECLARE_INTERFACE_IID_(iface, baseiface, iid)   DECLARE_INTERFACE_(iface, baseiface)
#endif




/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT
#endif  // __cplusplus
#endif  // FARSTRUCT



#ifndef HUGEP
#if defined(_WIN32) || defined(_MPPC_)
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP


#ifdef _MAC
#if !defined(OLE2ANSI)
#define OLE2ANSI
#endif
#endif

#include <stdlib.h>

#define LISet32(li, v) ((li).HighPart = (v) < 0 ? -1 : 0, (li).LowPart = (v))

#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))






#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

// With DCOM, CLSCTX_REMOTE_SERVER should be included
#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER| \
                                 CLSCTX_REMOTE_SERVER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER|CLSCTX_REMOTE_SERVER)
#else
#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER )

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)
#endif


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
                                // and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
                                // context.
    REGCLS_SUSPENDED      = 4,  // register is as suspended, will be activated
                                // when app calls CoResumeClassObjects
    REGCLS_SURROGATE      = 8   // must be used when a surrogate process
                                // is registering a class object that will be 
                                // loaded in the surrogate
} REGCLS;

// interface marshaling definitions
#define MARSHALINTERFACE_MIN 500 // minimum number of bytes for interface marshl


//
// Common typedefs for parameters used in Storage API's, gleaned from storage.h
// Also contains Storage error codes, which should be moved into the storage
// idl files.
//


#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT             0x00000000L
#define STGM_TRANSACTED         0x00010000L
#define STGM_SIMPLE             0x08000000L

#define STGM_READ               0x00000000L
#define STGM_WRITE              0x00000001L
#define STGM_READWRITE          0x00000002L

#define STGM_SHARE_DENY_NONE    0x00000040L
#define STGM_SHARE_DENY_READ    0x00000030L
#define STGM_SHARE_DENY_WRITE   0x00000020L
#define STGM_SHARE_EXCLUSIVE    0x00000010L

#define STGM_PRIORITY           0x00040000L
#define STGM_DELETEONRELEASE    0x04000000L
#if (WINVER >= 400)
#define STGM_NOSCRATCH          0x00100000L
#endif /* WINVER */

#define STGM_CREATE             0x00001000L
#define STGM_CONVERT            0x00020000L
#define STGM_FAILIFTHERE        0x00000000L

#define STGM_NOSNAPSHOT         0x00200000L

/*  flags for internet asyncronous and layout docfile */
#define ASYNC_MODE_COMPATIBILITY    0x00000001L
#define ASYNC_MODE_DEFAULT          0x00000000L

#define STGTY_REPEAT                0x00000100L
#define STG_TOEND                   0xFFFFFFFFL

#define STG_LAYOUT_SEQUENTIAL       0x00000000L
#define STG_LAYOUT_INTERLEAVED      0x00000001L




/* here is where we pull in the MIDL generated headers for the interfaces */
typedef interface    IRpcStubBuffer     IRpcStubBuffer;
typedef interface    IRpcChannelBuffer  IRpcChannelBuffer;

#include <wtypes.h>
#include <unknwn.h>
#include <objidl.h>

#if defined(UNDER_CE)

// For CE, we'll simply reuse the definitions from guiddef.h rather
// than copying and pasting them into this file (objbase.h)
//



 
#include <guiddef.h>

#else // UNDER_CE

// macros to define byte pattern for a GUID.
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including objbase.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in ole2.lib.  The GUIDs in ole2.lib are all defined in the same text
// segment GUID_TEXT.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of objbase.h and then include initguid.h
// after objbase.h followed by one or more of the guid defintion files.

#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#ifdef _OLE32_


// Faster (but makes code fatter) inline version...use sparingly
#ifdef __cplusplus
#ifndef __INLINEISEQUALGUID__
#define __INLINEISEQUALGUID__
inline BOOL  InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif  // !__INLINEISEQUALGUID__
#else   // ! __cplusplus
#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])
#endif  // __cplusplus

#ifdef _OLE32PRIV_
BOOL _fastcall wIsEqualGUID(REFGUID rguid1, REFGUID rguid2);
#define IsEqualGUID(rguid1, rguid2) wIsEqualGUID(rguid1, rguid2)
#else
#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
#endif  // _OLE32PRIV_

#else   // ! _OLE32_
#ifdef __cplusplus
inline BOOL IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#else   //  ! __cplusplus
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))
#endif  //  __cplusplus
#endif  //  _OLE32_

#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)

#ifdef __cplusplus

// because GUID is defined elsewhere, the operator == and !=
// are moved outside the class to global scope.

#ifdef _OLE32_
inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
    return IsEqualGUID(guidOne,guidOther);
}
#else   // !_OLE32_
inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
#ifdef _WIN32
    return !memcmp(&guidOne,&guidOther,sizeof(GUID));
#else
    return !_fmemcmp(&guidOne,&guidOther,sizeof(GUID)); }
#endif
}
#endif // _OLE32_

inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

#endif // __cpluscplus

#endif // UNDER_CE

#ifndef INITGUID
#include <cguid.h>
#endif

// COM initialization flags; passed to CoInitialize.
typedef enum tagCOINIT
{
  COINIT_APARTMENTTHREADED  = 0x2,      // Apartment model

#if  (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
  // These constants are only valid on Windows NT 4.0
  COINIT_MULTITHREADED      = 0x0,      // OLE calls objects on any thread.
  COINIT_DISABLE_OLE1DDE    = 0x4,      // Don't use DDE for Ole1 support.
  COINIT_SPEED_OVER_MEMORY  = 0x8,      // Trade memory for speed.
#endif // DCOM
} COINIT;



// @CESYSGEN IF OLE32_DCOMOLE


/****** STD Object API Prototypes *****************************************/

WINOLEAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

WINOLEAPI  CoInitialize(LPVOID pvReserved);
WINOLEAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
WINOLEAPI_(DWORD) CoGetCurrentProcess(void);
WINOLEAPI  CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
WINOLEAPI  CoRevokeMallocSpy(void);
WINOLEAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMBASE || OLE32_COM

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);
#endif // DCOM

WINOLEAPI_(void)  CoUninitialize(void);

// @CESYSGEN ENDIF

#if DBG == 1
WINOLEAPI_(ULONG) DebugCoGetRpcFault( void );
WINOLEAPI_(void) DebugCoSetRpcFault( ULONG );
#endif

// @CESYSGEN IF OLE32_DCOMOLE

/* register/revoke/get class objects */

WINOLEAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
WINOLEAPI  CoRevokeClassObject(DWORD dwRegister);
WINOLEAPI  CoResumeClassObjects(void);
WINOLEAPI  CoSuspendClassObjects(void);
WINOLEAPI_(ULONG) CoAddRefServerProcess(void);
WINOLEAPI_(ULONG) CoReleaseServerProcess(void);
WINOLEAPI  CoGetPSClsid(REFIID riid, CLSID *pClsid);
WINOLEAPI  CoRegisterPSClsid(REFIID riid, REFCLSID rclsid);

// Registering surrogate processes
WINOLEAPI  CoRegisterSurrogate(LPSURROGATE pSurrogate);

/* marshaling interface pointers */

WINOLEAPI CoGetMarshalSizeMax(ULONG *pulSize, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
WINOLEAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
WINOLEAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
WINOLEAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
WINOLEAPI CoReleaseMarshalData(LPSTREAM pStm);
WINOLEAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
WINOLEAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
WINOLEAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

WINOLEAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);
WINOLEAPI_(BOOL) CoHasStrongExternalConnections(LPUNKNOWN pUnk);

// Apartment model inter-thread interface passing helpers
WINOLEAPI CoMarshalInterThreadInterfaceInStream(REFIID riid, LPUNKNOWN pUnk,
                    LPSTREAM *ppStm);

WINOLEAPI CoGetInterfaceAndReleaseStream(LPSTREAM pStm, REFIID iid,
                    LPVOID FAR* ppv);

WINOLEAPI CoCreateFreeThreadedMarshaler(LPUNKNOWN  punkOuter,
                    LPUNKNOWN *ppunkMarshal);

// @CESYSGEN ENDIF

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMBASE || OLE32_MCOMLIB

WINOLEAPI_(HINSTANCE) CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
WINOLEAPI_(void) CoFreeLibrary(HINSTANCE hInst);
WINOLEAPI_(void) CoFreeAllLibraries(void);
WINOLEAPI_(void) CoFreeUnusedLibraries(void);
WINOLEAPI_(void) CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM

/* Call Security. */

WINOLEAPI CoInitializeSecurity(
                    PSECURITY_DESCRIPTOR         pSecDesc,
                    LONG                         cAuthSvc,
                    SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
                    void                        *pReserved1,
                    DWORD                        dwAuthnLevel,
                    DWORD                        dwImpLevel,
                    void                        *pReserved2,
                    DWORD                        dwCapabilities,
                    void                        *pReserved3 );
WINOLEAPI CoGetCallContext( REFIID riid, void **ppInterface );
WINOLEAPI CoQueryProxyBlanket(
    IUnknown                  *pProxy,
    DWORD                     *pwAuthnSvc,
    DWORD                     *pAuthzSvc,
    OLECHAR                  **pServerPrincName,
    DWORD                     *pAuthnLevel,
    DWORD                     *pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,
    DWORD                     *pCapabilites );
WINOLEAPI CoSetProxyBlanket(
    IUnknown                 *pProxy,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthnLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities );
WINOLEAPI CoCopyProxy(
    IUnknown    *pProxy,
    IUnknown   **ppCopy );
WINOLEAPI CoQueryClientBlanket(
    DWORD             *pAuthnSvc,
    DWORD             *pAuthzSvc,
    OLECHAR          **pServerPrincName,
    DWORD             *pAuthnLevel,
    DWORD             *pImpLevel,
    RPC_AUTHZ_HANDLE  *pPrivs,
    DWORD             *pCapabilities );
WINOLEAPI CoImpersonateClient();
WINOLEAPI CoRevertToSelf();
WINOLEAPI CoQueryAuthenticationServices(
    DWORD *pcAuthSvc,
    SOLE_AUTHENTICATION_SERVICE **asAuthSvc );
WINOLEAPI CoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject );

#define COM_RIGHTS_EXECUTE 1

#endif // DCOM

// @CESYSGEN ENDIF

/* helper for creating instances */

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMBASE || OLE32_COM

WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


WINOLEAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM

WINOLEAPI CoGetInstanceFromFile(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pClsid,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    DWORD                       grfMode,
    OLECHAR *                   pwszName,
    DWORD                       dwCount,
    MULTI_QI        *           pResults );

WINOLEAPI CoGetInstanceFromIStorage(
    COSERVERINFO *              pServerInfo,
    CLSID       *               pClsid,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    struct IStorage *           pstg,
    DWORD                       dwCount,
    MULTI_QI        *           pResults );

WINOLEAPI CoCreateInstanceEx(
    REFCLSID                    Clsid,
    IUnknown    *               punkOuter, // only relevant locally
    DWORD                       dwClsCtx,
    COSERVERINFO *              pServerInfo,
    DWORD                       dwCount,
    MULTI_QI        *           pResults );

WINOLEAPI_(void) UpdateDCOMSettings (void);

#endif // DCOM

// @CESYSGEN ENDIF

/* other helpers */

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMSTR || OLE32_COM

WINOLEAPI StringFromCLSID(REFCLSID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);
WINOLEAPI StringFromIID(REFIID rclsid, LPOLESTR FAR* lplpsz);
WINOLEAPI IIDFromString(LPOLESTR lpsz, LPIID lpiid);
WINOLEAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
WINOLEAPI ProgIDFromCLSID (REFCLSID clsid, LPOLESTR FAR* lplpszProgID);
WINOLEAPI CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);
WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMGUID

WINOLEAPI CoCreateGuid(GUID FAR *pguid);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE

WINOLEAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
WINOLEAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime);
WINOLEAPI  CoFileTimeNow( FILETIME FAR* lpFileTime );


WINOLEAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );

#if (_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM) // DCOM
WINOLEAPI CoRegisterChannelHook( REFGUID ExtensionUuid, IChannelHook *pChannelHook );
#endif // DCOM

/* TreatAs APIS */

WINOLEAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
WINOLEAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);

// @CESYSGEN ENDIF

/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at
 * the same time.
 */

//#ifdef _MAC
//typedef STDAPICALLTYPE HRESULT (* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
//#else
typedef HRESULT (STDAPICALLTYPE * LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);
//#endif

//#ifdef _MAC
//typedef STDAPICALLTYPE HRESULT (* LPFNCANUNLOADNOW)(void);
//#else
typedef HRESULT (STDAPICALLTYPE * LPFNCANUNLOADNOW)(void);
//#endif

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);

STDAPI  DllCanUnloadNow(void);


/****** Default Memory Allocation ******************************************/

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMMEM || OLE32_COM

WINOLEAPI_(LPVOID) CoTaskMemAlloc(ULONG cb);
WINOLEAPI_(LPVOID) CoTaskMemRealloc(LPVOID pv, ULONG cb);
WINOLEAPI_(void)   CoTaskMemFree(LPVOID pv);
WINOLEAPI_(UINT)   CoTaskMemSize(LPVOID pv);

// @CESYSGEN ENDIF

/****** DV APIs ***********************************************************/


WINOLEAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

WINOLEAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
                                        REFIID iid, LPVOID FAR* ppv);




/****** Storage API Prototypes ********************************************/

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_DOCFILE || OLE32_STG

WINOLEAPI StgCreateDocfile(const OLECHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgOpenStorage(const OLECHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
WINOLEAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);

WINOLEAPI StgIsStorageFile(const OLECHAR FAR* pwcsName);
WINOLEAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

WINOLEAPI StgSetTimes(OLECHAR const FAR* lpszName,
                   FILETIME const FAR* pctime,
                   FILETIME const FAR* patime,
                   FILETIME const FAR* pmtime);

WINOLEAPI StgOpenAsyncDocfileOnIFillLockBytes( IFillLockBytes *pflb,
             DWORD grfMode,
             DWORD asyncFlags,
             IStorage **ppstgOpen);

WINOLEAPI StgGetIFillLockBytesOnILockBytes( ILockBytes *pilb,
             IFillLockBytes **ppflb);

WINOLEAPI StgGetIFillLockBytesOnFile(OLECHAR const *pwcsName,
             IFillLockBytes **ppflb);


WINOLEAPI StgOpenLayoutDocfile(OLECHAR const *pwcsDfName,
             DWORD grfMode,
             DWORD reserved,
             IStorage **ppstgOpen);


// @CESYSGEN ENDIF

//
//  Moniker APIs
//

// @CESYSGEN IF OLE32_DCOMOLE

WINOLEAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
WINOLEAPI  CoGetObject(LPCWSTR pszName, BIND_OPTS *pBindOptions, REFIID riid, void **ppv);
WINOLEAPI  MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName,
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
WINOLEAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL dwReserved);
WINOLEAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMMON

WINOLEAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE

WINOLEAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE || OLE32_MCOMMON

WINOLEAPI  GetClassFile (LPCOLESTR szFilename, CLSID FAR* pclsid);

// @CESYSGEN ENDIF

// @CESYSGEN IF OLE32_DCOMOLE

WINOLEAPI  CreateClassMoniker(REFCLSID rclsid, LPMONIKER FAR* ppmk);

WINOLEAPI  CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER FAR* ppmk);

WINOLEAPI  CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem,
    LPMONIKER FAR* ppmk);
WINOLEAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
WINOLEAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

WINOLEAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);

// @CESYSGEN ENDIF

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

//
//   API set ready event - (only relavent for DCOM based builds)
//   indicates that DCOM services (DCOMSSD + LPCD) are available.
// 
#define DCOM_EVENTNAME_API_SET_READY        L"SYSTEM/DCOMApiSetReady"

#endif     // __OBJBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\objerror.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
/*++


Module Name: objerror.h


--*/

#include <winerror.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\wm7\sfone7\Include\objidl.h ===
//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this sample source code is subject to the terms of the Microsoft
// license agreement under which you licensed this sample source code. If
// you did not accept the terms of the license agreement, you are not
// authorized to use this sample source code. For the terms of the license,
// please see the license agreement between you and Microsoft or, if applicable,
// see the LICENSE.RTF on your install media or the root of your tools installation.
// THE SAMPLE SOURCE CODE IS PROVIDED "AS IS", WITH NO WARRANTIES OR INDEMNITIES.
//
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* at Mon Jan 29 15:41:24 2007
 */
/* Compiler settings for .\objidl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __objidl_h__
#define __objidl_h__

/* Forward Declarations */ 

#ifndef __IMarshal_FWD_DEFINED__
#define __IMarshal_FWD_DEFINED__
typedef interface IMarshal IMarshal;
#endif 	/* __IMarshal_FWD_DEFINED__ */


#ifndef __IMalloc_FWD_DEFINED__
#define __IMalloc_FWD_DEFINED__
typedef interface IMalloc IMalloc;
#endif 	/* __IMalloc_FWD_DEFINED__ */


#ifndef __IMallocSpy_FWD_DEFINED__
#define __IMallocSpy_FWD_DEFINED__
typedef interface IMallocSpy IMallocSpy;
#endif 	/* __IMallocSpy_FWD_DEFINED__ */


#ifndef __IStdMarshalInfo_FWD_DEFINED__
#define __IStdMarshalInfo_FWD_DEFINED__
typedef interface IStdMarshalInfo IStdMarshalInfo;
#endif 	/* __IStdMarshalInfo_FWD_DEFINED__ */


#ifndef __IExternalConnection_FWD_DEFINED__
#define __IExternalConnection_FWD_DEFINED__
typedef interface IExternalConnection IExternalConnection;
#endif 	/* __IExternalConnection_FWD_DEFINED__ */


#ifndef __IMultiQI_FWD_DEFINED__
#define __IMultiQI_FWD_DEFINED__
typedef interface IMultiQI IMultiQI;
#endif 	/* __IMultiQI_FWD_DEFINED__ */


#ifndef __IEnumUnknown_FWD_DEFINED__
#define __IEnumUnknown_FWD_DEFINED__
typedef interface IEnumUnknown IEnumUnknown;
#endif 	/* __IEnumUnknown_FWD_DEFINED__ */


#ifndef __IBindCtx_FWD_DEFINED__
#define __IBindCtx_FWD_DEFINED__
typedef interface IBindCtx IBindCtx;
#endif 	/* __IBindCtx_FWD_DEFINED__ */


#ifndef __IEnumMoniker_FWD_DEFINED__
#define __IEnumMoniker_FWD_DEFINED__
typedef interface IEnumMoniker IEnumMoniker;
#endif 	/* __IEnumMoniker_FWD_DEFINED__ */


#ifndef __IRunnableObject_FWD_DEFINED__
#define __IRunnableObject_FWD_DEFINED__
typedef interface IRunnableObject IRunnableObject;
#endif 	/* __IRunnableObject_FWD_DEFINED__ */


#ifndef __IRunningObjectTable_FWD_DEFINED__
#define __IRunningObjectTable_FWD_DEFINED__
typedef interface IRunningObjectTable IRunningObjectTable;
#endif 	/* __IRunningObjectTable_FWD_DEFINED__ */


#ifndef __IPersist_FWD_DEFINED__
#define __IPersist_FWD_DEFINED__
typedef interface IPersist IPersist;
#endif 	/* __IPersist_FWD_DEFINED__ */


#ifndef __IPersistStream_FWD_DEFINED__
#define __IPersistStream_FWD_DEFINED__
typedef interface IPersistStream IPersistStream;
#endif 	/* __IPersistStream_FWD_DEFINED__ */


#ifndef __IMoniker_FWD_DEFINED__
#define __IMoniker_FWD_DEFINED__
typedef interface IMoniker IMoniker;
#endif 	/* __IMoniker_FWD_DEFINED__ */


#ifndef __IROTData_FWD_DEFINED__
#define __IROTData_FWD_DEFINED__
typedef interface IROTData IROTData;
#endif 	/* __IROTData_FWD_DEFINED__ */


#ifndef __IEnumString_FWD_DEFINED__
#define __IEnumString_FWD_DEFINED__
typedef interface IEnumString IEnumString;
#endif 	/* __IEnumString_FWD_DEFINED__ */


#ifndef __ISequentialStream_FWD_DEFINED__
#define __ISequentialStream_FWD_DEFINED__
typedef interface ISequentialStream ISequentialStream;
#endif 	/* __ISequentialStream_FWD_DEFINED__ */


#ifndef __IStream_FWD_DEFINED__
#define __IStream_FWD_DEFINED__
typedef interface IStream IStream;
#endif 	/* __IStream_FWD_DEFINED__ */


#ifndef __IEnumSTATSTG_FWD_DEFINED__
#define __IEnumSTATSTG_FWD_DEFINED__
typedef interface IEnumSTATSTG IEnumSTATSTG;
#endif 	/* __IEnumSTATSTG_FWD_DEFINED__ */


#ifndef __IStorage_FWD_DEFINED__
#define __IStorage_FWD_DEFINED__
typedef interface IStorage IStorage;
#endif 	/* __IStorage_FWD_DEFINED__ */


#ifndef __IPersistFile_FWD_DEFINED__
#define __IPersistFile_FWD_DEFINED__
typedef interface IPersistFile IPersistFile;
#endif 	/* __IPersistFile_FWD_DEFINED__ */


#ifndef __IPersistStorage_FWD_DEFINED__
#define __IPersistStorage_FWD_DEFINED__
typedef interface IPersistStorage IPersistStorage;
#endif 	/* __IPersistStorage_FWD_DEFINED__ */


#ifndef __ILockBytes_FWD_DEFINED__
#define __ILockBytes_FWD_DEFINED__
typedef interface ILockBytes ILockBytes;
#endif 	/* __ILockBytes_FWD_DEFINED__ */


#ifndef __IEnumFORMATETC_FWD_DEFINED__
#define __IEnumFORMATETC_FWD_DEFINED__
typedef interface IEnumFORMATETC IEnumFORMATETC;
#endif 	/* __IEnumFORMATETC_FWD_DEFINED__ */


#ifndef __IEnumSTATDATA_FWD_DEFINED__
#define __IEnumSTATDATA_FWD_DEFINED__
typedef interface IEnumSTATDATA IEnumSTATDATA;
#endif 	/* __IEnumSTATDATA_FWD_DEFINED__ */


#ifndef __IRootStorage_FWD_DEFINED__
#define __IRootStorage_FWD_DEFINED__
typedef interface IRootStorage IRootStorage;
#endif 	/* __IRootStorage_FWD_DEFINED__ */


#ifndef __IAdviseSink_FWD_DEFINED__
#define __IAdviseSink_FWD_DEFINED__
typedef interface IAdviseSink IAdviseSink;
#endif 	/* __IAdviseSink_FWD_DEFINED__ */


#ifndef __IAdviseSink2_FWD_DEFINED__
#define __IAdviseSink2_FWD_DEFINED__
typedef interface IAdviseSink2 IAdviseSink2;
#endif 	/* __IAdviseSink2_FWD_DEFINED__ */


#ifndef __IDataObject_FWD_DEFINED__
#define __IDataObject_FWD_DEFINED__
typedef interface IDataObject IDataObject;
#endif 	/* __IDataObject_FWD_DEFINED__ */


#ifndef __IDataAdviseHolder_FWD_DEFINED__
#define __IDataAdviseHolder_FWD_DEFINED__
typedef interface IDataAdviseHolder IDataAdviseHolder;
#endif 	/* __IDataAdviseHolder_FWD_DEFINED__ */


#ifndef __IMessageFilter_FWD_DEFINED__
#define __IMessageFilter_FWD_DEFINED__
typedef interface IMessageFilter IMessageFilter;
#endif 	/* __IMessageFilter_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer_FWD_DEFINED__
#define __IRpcChannelBuffer_FWD_DEFINED__
typedef interface IRpcChannelBuffer IRpcChannelBuffer;
#endif 	/* __IRpcChannelBuffer_FWD_DEFINED__ */


#ifndef __IRpcChannelBuffer2_FWD_DEFINED__
#define __IRpcChannelBuffer2_FWD_DEFINED__
typedef interface IRpcChannelBuffer2 IRpcChannelBuffer2;
#endif 	/* __IRpcChannelBuffer2_FWD_DEFINED__ */


#ifndef __IRpcProxyBuffer_FWD_DEFINED__
#define __IRpcProxyBuffer_FWD_DEFINED__
typedef interface IRpcProxyBuffer IRpcProxyBuffer;
#endif 	/* __IRpcProxyBuffer_FWD_DEFINED__ */


#ifndef __IRpcStubBuffer_FWD_DEFINED__
#define __IRpcStubBuffer_FWD_DEFINED__
typedef interface IRpcStubBuffer IRpcStubBuffer;
#endif 	/* __IRpcStubBuffer_FWD_DEFINED__ */


#ifndef __IPSFactoryBuffer_FWD_DEFINED__
#define __IPSFactoryBuffer_FWD_DEFINED__
typedef interface IPSFactoryBuffer IPSFactoryBuffer;
#endif 	/* __IPSFactoryBuffer_FWD_DEFINED__ */


#ifndef __IChannelHook_FWD_DEFINED__
#define __IChannelHook_FWD_DEFINED__
typedef interface IChannelHook IChannelHook;
#endif 	/* __IChannelHook_FWD_DEFINED__ */


#ifndef __IClientSecurity_FWD_DEFINED__
#define __IClientSecurity_FWD_DEFINED__
typedef interface IClientSecurity IClientSecurity;
#endif 	/* __IClientSecurity_FWD_DEFINED__ */


#ifndef __IServerSecurity_FWD_DEFINED__
#define __IServerSecurity_FWD_DEFINED__
typedef interface IServerSecurity IServerSecurity;
#endif 	/* __IServerSecurity_FWD_DEFINED__ */


#ifndef __IClassActivator_FWD_DEFINED__
#define __IClassActivator_FWD_DEFINED__
typedef interface IClassActivator IClassActivator;
#endif 	/* __IClassActivator_FWD_DEFINED__ */


#ifndef __IRpcOptions_FWD_DEFINED__
#define __IRpcOptions_FWD_DEFINED__
typedef interface IRpcOptions IRpcOptions;
#endif 	/* __IRpcOptions_FWD_DEFINED__ */


#ifndef __IFillLockBytes_FWD_DEFINED__
#define __IFillLockBytes_FWD_DEFINED__
typedef interface IFillLockBytes IFillLockBytes;
#endif 	/* __IFillLockBytes_FWD_DEFINED__ */


#ifndef __IProgressNotify_FWD_DEFINED__
#define __IProgressNotify_FWD_DEFINED__
typedef interface IProgressNotify IProgressNotify;
#endif 	/* __IProgressNotify_FWD_DEFINED__ */


#ifndef __ILayoutStorage_FWD_DEFINED__
#define __ILayoutStorage_FWD_DEFINED__
typedef interface ILayoutStorage ILayoutStorage;
#endif 	/* __ILayoutStorage_FWD_DEFINED__ */


#ifndef __ISurrogate_FWD_DEFINED__
#define __ISurrogate_FWD_DEFINED__
typedef interface ISurrogate ISurrogate;
#endif 	/* __ISurrogate_FWD_DEFINED__ */


#ifndef __IGlobalInterfaceTable_FWD_DEFINED__
#define __IGlobalInterfaceTable_FWD_DEFINED__
typedef interface IGlobalInterfaceTable IGlobalInterfaceTable;
#endif 	/* __IGlobalInterfaceTable_FWD_DEFINED__ */


#ifndef __IComBinding_FWD_DEFINED__
#define __IComBinding_FWD_DEFINED__
typedef interface IComBinding IComBinding;
#endif 	/* __IComBinding_FWD_DEFINED__ */


#ifndef __ISynchronize_FWD_DEFINED__
#define __ISynchronize_FWD_DEFINED__
typedef interface ISynchronize ISynchronize;
#endif 	/* __ISynchronize_FWD_DEFINED__ */


#ifndef __ISynchronizeHandle_FWD_DEFINED__
#define __ISynchronizeHandle_FWD_DEFINED__
typedef interface ISynchronizeHandle ISynchronizeHandle;
#endif 	/* __ISynchronizeHandle_FWD_DEFINED__ */


#ifndef __ISynchronizeEvent_FWD_DEFINED__
#define __ISynchronizeEvent_FWD_DEFINED__
typedef interface ISynchronizeEvent ISynchronizeEvent;
#endif 	/* __ISynchronizeEvent_FWD_DEFINED__ */


#ifndef __ISynchronizeContainer_FWD_DEFINED__
#define __ISynchronizeContainer_FWD_DEFINED__
typedef interface ISynchronizeContainer ISynchronizeContainer;
#endif 	/* __ISynchronizeContainer_FWD_DEFINED__ */


#ifndef __ISynchronizeMutex_FWD_DEFINED__
#define __ISynchronizeMutex_FWD_DEFINED__
typedef interface ISynchronizeMutex ISynchronizeMutex;
#endif 	/* __ISynchronizeMutex_FWD_DEFINED__ */


#ifndef __ICancelMethodCalls_FWD_DEFINED__
#define __ICancelMethodCalls_FWD_DEFINED__
typedef interface ICancelMethodCalls ICancelMethodCalls;
#endif 	/* __ICancelMethodCalls_FWD_DEFINED__ */


#ifndef __ICallFactory_FWD_DEFINED__
#define __ICallFactory_FWD_DEFINED__
typedef interface ICallFactory ICallFactory;
#endif 	/* __ICallFactory_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_objidl_0000 */
/* [local] */ 

//
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
//
// Use of this source code is subject to the terms of the Microsoft end-user
// license agreement (EULA) under which you licensed this SOFTWARE PRODUCT.
// If you did not accept the terms of the EULA, you are not authorized to use
// this source code. For a copy of the EULA, please see the LICENSE.RTF on your
// install media.
//














extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_v0_0_s_ifspec;

#ifndef __IMarshal_INTERFACE_DEFINED__
#define __IMarshal_INTERFACE_DEFINED__

/* interface IMarshal */
/* [uuid][object][local] */ 

typedef /* [unique] */ IMarshal __RPC_FAR *LPMARSHAL;


EXTERN_C const IID IID_IMarshal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000003-0000-0000-C000-000000000046")
    IMarshal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetUnmarshalClass( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMarshalSizeMax( 
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalInterface( 
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseMarshalData( 
            /* [unique][in] */ IStream __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisconnectObject( 
            /* [in] */ DWORD dwReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarshalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMarshal __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMarshal __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnmarshalClass )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ CLSID __RPC_FAR *pCid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarshalSizeMax )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags,
            /* [out] */ DWORD __RPC_FAR *pSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [unique][in] */ void __RPC_FAR *pv,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [in] */ DWORD mshlflags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnmarshalInterface )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseMarshalData )( 
            IMarshal __RPC_FAR * This,
            /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisconnectObject )( 
            IMarshal __RPC_FAR * This,
            /* [in] */ DWORD dwReserved);
        
        END_INTERFACE
    } IMarshalVtbl;

    interface IMarshal
    {
        CONST_VTBL struct IMarshalVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarshal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarshal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarshal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarshal_GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)	\
    (This)->lpVtbl -> GetUnmarshalClass(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pCid)

#define IMarshal_GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)	\
    (This)->lpVtbl -> GetMarshalSizeMax(This,riid,pv,dwDestContext,pvDestContext,mshlflags,pSize)

#define IMarshal_MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)	\
    (This)->lpVtbl -> MarshalInterface(This,pStm,riid,pv,dwDestContext,pvDestContext,mshlflags)

#define IMarshal_UnmarshalInterface(This,pStm,riid,ppv)	\
    (This)->lpVtbl -> UnmarshalInterface(This,pStm,riid,ppv)

#define IMarshal_ReleaseMarshalData(This,pStm)	\
    (This)->lpVtbl -> ReleaseMarshalData(This,pStm)

#define IMarshal_DisconnectObject(This,dwReserved)	\
    (This)->lpVtbl -> DisconnectObject(This,dwReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarshal_GetUnmarshalClass_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ CLSID __RPC_FAR *pCid);


void __RPC_STUB IMarshal_GetUnmarshalClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshal_GetMarshalSizeMax_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags,
    /* [out] */ DWORD __RPC_FAR *pSize);


void __RPC_STUB IMarshal_GetMarshalSizeMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshal_MarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [unique][in] */ void __RPC_FAR *pv,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [in] */ DWORD mshlflags);


void __RPC_STUB IMarshal_MarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshal_UnmarshalInterface_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IMarshal_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshal_ReleaseMarshalData_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [unique][in] */ IStream __RPC_FAR *pStm);


void __RPC_STUB IMarshal_ReleaseMarshalData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarshal_DisconnectObject_Proxy( 
    IMarshal __RPC_FAR * This,
    /* [in] */ DWORD dwReserved);


void __RPC_STUB IMarshal_DisconnectObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarshal_INTERFACE_DEFINED__ */


#ifndef __IMalloc_INTERFACE_DEFINED__
#define __IMalloc_INTERFACE_DEFINED__

/* interface IMalloc */
/* [uuid][object][local] */ 

typedef /* [unique] */ IMalloc __RPC_FAR *LPMALLOC;


EXTERN_C const IID IID_IMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000002-0000-0000-C000-000000000046")
    IMalloc : public IUnknown
    {
    public:
        virtual void __RPC_FAR *STDMETHODCALLTYPE Alloc( 
            /* [in] */ ULONG cb) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE Realloc( 
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb) = 0;
        
        virtual void STDMETHODCALLTYPE Free( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetSize( 
            /* [in] */ void __RPC_FAR *pv) = 0;
        
        virtual int STDMETHODCALLTYPE DidAlloc( 
            void __RPC_FAR *pv) = 0;
        
        virtual void STDMETHODCALLTYPE HeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMalloc __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMalloc __RPC_FAR * This);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Alloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ ULONG cb);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Realloc )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv,
            /* [in] */ ULONG cb);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Free )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetSize )( 
            IMalloc __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pv);
        
        int ( STDMETHODCALLTYPE __RPC_FAR *DidAlloc )( 
            IMalloc __RPC_FAR * This,
            void __RPC_FAR *pv);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *HeapMinimize )( 
            IMalloc __RPC_FAR * This);
        
        END_INTERFACE
    } IMallocVtbl;

    interface IMalloc
    {
        CONST_VTBL struct IMallocVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#define IMalloc_Realloc(This,pv,cb)	\
    (This)->lpVtbl -> Realloc(This,pv,cb)

#define IMalloc_Free(This,pv)	\
    (This)->lpVtbl -> Free(This,pv)

#define IMalloc_GetSize(This,pv)	\
    (This)->lpVtbl -> GetSize(This,pv)

#define IMalloc_DidAlloc(This,pv)	\
    (This)->lpVtbl -> DidAlloc(This,pv)

#define IMalloc_HeapMinimize(This)	\
    (This)->lpVtbl -> HeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void __RPC_FAR *STDMETHODCALLTYPE IMalloc_Alloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMalloc_Realloc_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv,
    /* [in] */ ULONG cb);


void __RPC_STUB IMalloc_Realloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMalloc_Free_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IMalloc_GetSize_Proxy( 
    IMalloc __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pv);


void __RPC_STUB IMalloc_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int STDMETHODCALLTYPE IMalloc_DidAlloc_Proxy( 
    IMalloc __RPC_FAR * This,
    void __RPC_FAR *pv);


void __RPC_STUB IMalloc_DidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMalloc_HeapMinimize_Proxy( 
    IMalloc __RPC_FAR * This);


void __RPC_STUB IMalloc_HeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMalloc_INTERFACE_DEFINED__ */


#ifndef __IMallocSpy_INTERFACE_DEFINED__
#define __IMallocSpy_INTERFACE_DEFINED__

/* interface IMallocSpy */
/* [uuid][object][local] */ 

typedef /* [unique] */ IMallocSpy __RPC_FAR *LPMALLOCSPY;


EXTERN_C const IID IID_IMallocSpy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000001d-0000-0000-C000-000000000046")
    IMallocSpy : public IUnknown
    {
    public:
        virtual ULONG STDMETHODCALLTYPE PreAlloc( 
            /* [in] */ ULONG cbRequest) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE PostAlloc( 
            /* [in] */ void __RPC_FAR *pActual) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE PreFree( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void STDMETHODCALLTYPE PostFree( 
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG STDMETHODCALLTYPE PreRealloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE PostRealloc( 
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE PreGetSize( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual ULONG STDMETHODCALLTYPE PostGetSize( 
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual void __RPC_FAR *STDMETHODCALLTYPE PreDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed) = 0;
        
        virtual int STDMETHODCALLTYPE PostDidAlloc( 
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual) = 0;
        
        virtual void STDMETHODCALLTYPE PreHeapMinimize( void) = 0;
        
        virtual void STDMETHODCALLTYPE PostHeapMinimize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMallocSpyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMallocSpy __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *PreAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbRequest);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *PostAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *PreFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PostFree )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *PreRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ ULONG cbRequest,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *PostRealloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *PreGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *PostGetSize )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ ULONG cbActual,
            /* [in] */ BOOL fSpyed);
        
        void __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *PreDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed);
        
        int ( STDMETHODCALLTYPE __RPC_FAR *PostDidAlloc )( 
            IMallocSpy __RPC_FAR * This,
            /* [in] */ void __RPC_FAR *pRequest,
            /* [in] */ BOOL fSpyed,
            /* [in] */ int fActual);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PreHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PostHeapMinimize )( 
            IMallocSpy __RPC_FAR * This);
        
        END_INTERFACE
    } IMallocSpyVtbl;

    interface IMallocSpy
    {
        CONST_VTBL struct IMallocSpyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMallocSpy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMallocSpy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMallocSpy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMallocSpy_PreAlloc(This,cbRequest)	\
    (This)->lpVtbl -> PreAlloc(This,cbRequest)

#define IMallocSpy_PostAlloc(This,pActual)	\
    (This)->lpVtbl -> PostAlloc(This,pActual)

#define IMallocSpy_PreFree(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreFree(This,pRequest,fSpyed)

#define IMallocSpy_PostFree(This,fSpyed)	\
    (This)->lpVtbl -> PostFree(This,fSpyed)

#define IMallocSpy_PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)	\
    (This)->lpVtbl -> PreRealloc(This,pRequest,cbRequest,ppNewRequest,fSpyed)

#define IMallocSpy_PostRealloc(This,pActual,fSpyed)	\
    (This)->lpVtbl -> PostRealloc(This,pActual,fSpyed)

#define IMallocSpy_PreGetSize(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreGetSize(This,pRequest,fSpyed)

#define IMallocSpy_PostGetSize(This,cbActual,fSpyed)	\
    (This)->lpVtbl -> PostGetSize(This,cbActual,fSpyed)

#define IMallocSpy_PreDidAlloc(This,pRequest,fSpyed)	\
    (This)->lpVtbl -> PreDidAlloc(This,pRequest,fSpyed)

#define IMallocSpy_PostDidAlloc(This,pRequest,fSpyed,fActual)	\
    (This)->lpVtbl -> PostDidAlloc(This,pRequest,fSpyed,fActual)

#define IMallocSpy_PreHeapMinimize(This)	\
    (This)->lpVtbl -> PreHeapMinimize(This)

#define IMallocSpy_PostHeapMinimize(This)	\
    (This)->lpVtbl -> PostHeapMinimize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



ULONG STDMETHODCALLTYPE IMallocSpy_PreAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbRequest);


void __RPC_STUB IMallocSpy_PreAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMallocSpy_PostAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual);


void __RPC_STUB IMallocSpy_PostAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMallocSpy_PreFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMallocSpy_PostFree_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IMallocSpy_PreRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ ULONG cbRequest,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppNewRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMallocSpy_PostRealloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostRealloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMallocSpy_PreGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IMallocSpy_PostGetSize_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ ULONG cbActual,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PostGetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void __RPC_FAR *STDMETHODCALLTYPE IMallocSpy_PreDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed);


void __RPC_STUB IMallocSpy_PreDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


int STDMETHODCALLTYPE IMallocSpy_PostDidAlloc_Proxy( 
    IMallocSpy __RPC_FAR * This,
    /* [in] */ void __RPC_FAR *pRequest,
    /* [in] */ BOOL fSpyed,
    /* [in] */ int fActual);


void __RPC_STUB IMallocSpy_PostDidAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMallocSpy_PreHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PreHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IMallocSpy_PostHeapMinimize_Proxy( 
    IMallocSpy __RPC_FAR * This);


void __RPC_STUB IMallocSpy_PostHeapMinimize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMallocSpy_INTERFACE_DEFINED__ */


#ifndef __IStdMarshalInfo_INTERFACE_DEFINED__
#define __IStdMarshalInfo_INTERFACE_DEFINED__

/* interface IStdMarshalInfo */
/* [uuid][object][local] */ 

typedef /* [unique] */ IStdMarshalInfo __RPC_FAR *LPSTDMARSHALINFO;


EXTERN_C const IID IID_IStdMarshalInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000018-0000-0000-C000-000000000046")
    IStdMarshalInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassForHandler( 
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStdMarshalInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStdMarshalInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClassForHandler )( 
            IStdMarshalInfo __RPC_FAR * This,
            /* [in] */ DWORD dwDestContext,
            /* [unique][in] */ void __RPC_FAR *pvDestContext,
            /* [out] */ CLSID __RPC_FAR *pClsid);
        
        END_INTERFACE
    } IStdMarshalInfoVtbl;

    interface IStdMarshalInfo
    {
        CONST_VTBL struct IStdMarshalInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStdMarshalInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStdMarshalInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStdMarshalInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStdMarshalInfo_GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)	\
    (This)->lpVtbl -> GetClassForHandler(This,dwDestContext,pvDestContext,pClsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStdMarshalInfo_GetClassForHandler_Proxy( 
    IStdMarshalInfo __RPC_FAR * This,
    /* [in] */ DWORD dwDestContext,
    /* [unique][in] */ void __RPC_FAR *pvDestContext,
    /* [out] */ CLSID __RPC_FAR *pClsid);


void __RPC_STUB IStdMarshalInfo_GetClassForHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStdMarshalInfo_INTERFACE_DEFINED__ */


#ifndef __IExternalConnection_INTERFACE_DEFINED__
#define __IExternalConnection_INTERFACE_DEFINED__

/* interface IExternalConnection */
/* [uuid][local][object] */ 

typedef /* [unique] */ IExternalConnection __RPC_FAR *LPEXTERNALCONNECTION;

typedef 
enum tagEXTCONN
    {	EXTCONN_STRONG	= 0x1,
	EXTCONN_WEAK	= 0x2,
	EXTCONN_CALLABLE	= 0x4
    }	EXTCONN;


EXTERN_C const IID IID_IExternalConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000019-0000-0000-C000-000000000046")
    IExternalConnection : public IUnknown
    {
    public:
        virtual DWORD STDMETHODCALLTYPE AddConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved) = 0;
        
        virtual DWORD STDMETHODCALLTYPE ReleaseConnection( 
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved,
            /* [in] */ BOOL fLastReleaseCloses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExternalConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExternalConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExternalConnection __RPC_FAR * This);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *AddConnection )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved);
        
        DWORD ( STDMETHODCALLTYPE __RPC_FAR *ReleaseConnection )( 
            IExternalConnection __RPC_FAR * This,
            /* [in] */ DWORD extconn,
            /* [in] */ DWORD reserved,
            /* [in] */ BOOL fLastReleaseCloses);
        
        END_INTERFACE
    } IExternalConnectionVtbl;

    interface IExternalConnection
    {
        CONST_VTBL struct IExternalConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExternalConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExternalConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExternalConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExternalConnection_AddConnection(This,extconn,reserved)	\
    (This)->lpVtbl -> AddConnection(This,extconn,reserved)

#define IExternalConnection_ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)	\
    (This)->lpVtbl -> ReleaseConnection(This,extconn,reserved,fLastReleaseCloses)

#endif /* COBJMACROS */


#endif 	/* C style interface */



DWORD STDMETHODCALLTYPE IExternalConnection_AddConnection_Proxy( 
    IExternalConnection __RPC_FAR * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved);


void __RPC_STUB IExternalConnection_AddConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DWORD STDMETHODCALLTYPE IExternalConnection_ReleaseConnection_Proxy( 
    IExternalConnection __RPC_FAR * This,
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved,
    /* [in] */ BOOL fLastReleaseCloses);


void __RPC_STUB IExternalConnection_ReleaseConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExternalConnection_INTERFACE_DEFINED__ */


#ifndef __IMultiQI_INTERFACE_DEFINED__
#define __IMultiQI_INTERFACE_DEFINED__

/* interface IMultiQI */
/* [uuid][local][object] */ 

typedef /* [unique] */ IMultiQI __RPC_FAR *LPMULTIQI;

typedef struct tagMULTI_QI
    {
    const IID __RPC_FAR *pIID;
    IUnknown __RPC_FAR *pItf;
    HRESULT hr;
    }	MULTI_QI;


EXTERN_C const IID IID_IMultiQI;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000020-0000-0000-C000-000000000046")
    IMultiQI : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryMultipleInterfaces( 
            /* [in] */ ULONG cMQIs,
            /* [out][in] */ MULTI_QI __RPC_FAR *pMQIs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultiQIVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMultiQI __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMultiQI __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMultiQI __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryMultipleInterfaces )( 
            IMultiQI __RPC_FAR * This,
            /* [in] */ ULONG cMQIs,
            /* [out][in] */ MULTI_QI __RPC_FAR *pMQIs);
        
        END_INTERFACE
    } IMultiQIVtbl;

    interface IMultiQI
    {
        CONST_VTBL struct IMultiQIVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultiQI_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMultiQI_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMultiQI_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMultiQI_QueryMultipleInterfaces(This,cMQIs,pMQIs)	\
    (This)->lpVtbl -> QueryMultipleInterfaces(This,cMQIs,pMQIs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMultiQI_QueryMultipleInterfaces_Proxy( 
    IMultiQI __RPC_FAR * This,
    /* [in] */ ULONG cMQIs,
    /* [out][in] */ MULTI_QI __RPC_FAR *pMQIs);


void __RPC_STUB IMultiQI_QueryMultipleInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMultiQI_INTERFACE_DEFINED__ */


#ifndef __IEnumUnknown_INTERFACE_DEFINED__
#define __IEnumUnknown_INTERFACE_DEFINED__

/* interface IEnumUnknown */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumUnknown __RPC_FAR *LPENUMUNKNOWN;


EXTERN_C const IID IID_IEnumUnknown;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000100-0000-0000-C000-000000000046")
    IEnumUnknown : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumUnknownVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumUnknown __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumUnknown __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumUnknown __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumUnknown __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumUnknown __RPC_FAR * This,
            /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumUnknownVtbl;

    interface IEnumUnknown
    {
        CONST_VTBL struct IEnumUnknownVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumUnknown_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumUnknown_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumUnknown_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumUnknown_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumUnknown_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumUnknown_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumUnknown_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumUnknown_RemoteNext_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumUnknown_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUnknown_Skip_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumUnknown_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUnknown_Reset_Proxy( 
    IEnumUnknown __RPC_FAR * This);


void __RPC_STUB IEnumUnknown_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUnknown_Clone_Proxy( 
    IEnumUnknown __RPC_FAR * This,
    /* [out] */ IEnumUnknown __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumUnknown_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumUnknown_INTERFACE_DEFINED__ */


#ifndef __IBindCtx_INTERFACE_DEFINED__
#define __IBindCtx_INTERFACE_DEFINED__

/* interface IBindCtx */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IBindCtx __RPC_FAR *LPBC;

typedef /* [unique] */ IBindCtx __RPC_FAR *LPBINDCTX;

typedef struct tagBIND_OPTS
    {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    }	BIND_OPTS;

typedef struct tagBIND_OPTS __RPC_FAR *LPBIND_OPTS;

#if defined(__cplusplus)
    typedef struct tagBIND_OPTS2 : tagBIND_OPTS{
    DWORD           dwTrackFlags;
    DWORD           dwClassContext;
    LCID            locale;
    COSERVERINFO *  pServerInfo;
    } BIND_OPTS2, * LPBIND_OPTS2;
#else
typedef struct tagBIND_OPTS2
    {
    DWORD cbStruct;
    DWORD grfFlags;
    DWORD grfMode;
    DWORD dwTickCountDeadline;
    DWORD dwTrackFlags;
    DWORD dwClassContext;
    LCID locale;
    COSERVERINFO __RPC_FAR *pServerInfo;
    }	BIND_OPTS2;

typedef struct tagBIND_OPTS2 __RPC_FAR *LPBIND_OPTS2;

#endif
typedef 
enum tagBIND_FLAGS
    {	BIND_MAYBOTHERUSER	= 1,
	BIND_JUSTTESTEXISTENCE	= 2
    }	BIND_FLAGS;


EXTERN_C const IID IID_IBindCtx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0000000e-0000-0000-C000-000000000046")
    IBindCtx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterObjectBound( 
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeObjectBound( 
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseBoundObjects( void) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetBindOptions( 
            /* [in] */ BIND_OPTS __RPC_FAR *pbindopts) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetBindOptions( 
            /* [out][in] */ BIND_OPTS __RPC_FAR *pbindopts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunningObjectTable( 
            /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterObjectParam( 
            /* [in] */ LPOLESTR pszKey,
            /* [unique][in] */ IUnknown __RPC_FAR *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectParam( 
            /* [in] */ LPOLESTR pszKey,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumObjectParam( 
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeObjectParam( 
            /* [in] */ LPOLESTR pszKey) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBindCtxVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IBindCtx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IBindCtx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterObjectBound )( 
            IBindCtx __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeObjectBound )( 
            IBindCtx __RPC_FAR * This,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseBoundObjects )( 
            IBindCtx __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBindOptions )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ BIND_OPTS __RPC_FAR *pbindopts);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBindOptions )( 
            IBindCtx __RPC_FAR * This,
            /* [out][in] */ BIND_OPTS __RPC_FAR *pbindopts);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRunningObjectTable )( 
            IBindCtx __RPC_FAR * This,
            /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey,
            /* [unique][in] */ IUnknown __RPC_FAR *punk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeObjectParam )( 
            IBindCtx __RPC_FAR * This,
            /* [in] */ LPOLESTR pszKey);
        
        END_INTERFACE
    } IBindCtxVtbl;

    interface IBindCtx
    {
        CONST_VTBL struct IBindCtxVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBindCtx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBindCtx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBindCtx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBindCtx_RegisterObjectBound(This,punk)	\
    (This)->lpVtbl -> RegisterObjectBound(This,punk)

#define IBindCtx_RevokeObjectBound(This,punk)	\
    (This)->lpVtbl -> RevokeObjectBound(This,punk)

#define IBindCtx_ReleaseBoundObjects(This)	\
    (This)->lpVtbl -> ReleaseBoundObjects(This)

#define IBindCtx_SetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> SetBindOptions(This,pbindopts)

#define IBindCtx_GetBindOptions(This,pbindopts)	\
    (This)->lpVtbl -> GetBindOptions(This,pbindopts)

#define IBindCtx_GetRunningObjectTable(This,pprot)	\
    (This)->lpVtbl -> GetRunningObjectTable(This,pprot)

#define IBindCtx_RegisterObjectParam(This,pszKey,punk)	\
    (This)->lpVtbl -> RegisterObjectParam(This,pszKey,punk)

#define IBindCtx_GetObjectParam(This,pszKey,ppunk)	\
    (This)->lpVtbl -> GetObjectParam(This,pszKey,ppunk)

#define IBindCtx_EnumObjectParam(This,ppenum)	\
    (This)->lpVtbl -> EnumObjectParam(This,ppenum)

#define IBindCtx_RevokeObjectParam(This,pszKey)	\
    (This)->lpVtbl -> RevokeObjectParam(This,pszKey)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBindCtx_RegisterObjectBound_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RegisterObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_RevokeObjectBound_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RevokeObjectBound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_ReleaseBoundObjects_Proxy( 
    IBindCtx __RPC_FAR * This);


void __RPC_STUB IBindCtx_ReleaseBoundObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_RemoteSetBindOptions_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ BIND_OPTS2 __RPC_FAR *pbindopts);


void __RPC_STUB IBindCtx_RemoteSetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindCtx_RemoteGetBindOptions_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out][in] */ BIND_OPTS2 __RPC_FAR *pbindopts);


void __RPC_STUB IBindCtx_RemoteGetBindOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_GetRunningObjectTable_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out] */ IRunningObjectTable __RPC_FAR *__RPC_FAR *pprot);


void __RPC_STUB IBindCtx_GetRunningObjectTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_RegisterObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey,
    /* [unique][in] */ IUnknown __RPC_FAR *punk);


void __RPC_STUB IBindCtx_RegisterObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_GetObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunk);


void __RPC_STUB IBindCtx_GetObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_EnumObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [out] */ IEnumString __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IBindCtx_EnumObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBindCtx_RevokeObjectParam_Proxy( 
    IBindCtx __RPC_FAR * This,
    /* [in] */ LPOLESTR pszKey);


void __RPC_STUB IBindCtx_RevokeObjectParam_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBindCtx_INTERFACE_DEFINED__ */


#ifndef __IEnumMoniker_INTERFACE_DEFINED__
#define __IEnumMoniker_INTERFACE_DEFINED__

/* interface IEnumMoniker */
/* [unique][uuid][object] */ 

typedef /* [unique] */ IEnumMoniker __RPC_FAR *LPENUMMONIKER;


EXTERN_C const IID IID_IEnumMoniker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000102-0000-0000-C000-000000000046")
    IEnumMoniker : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMonikerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMoniker __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMoniker __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMoniker __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMoniker __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMoniker __RPC_FAR * This,
            /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumMonikerVtbl;

    interface IEnumMoniker
    {
        CONST_VTBL struct IEnumMonikerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMoniker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMoniker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMoniker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMoniker_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumMoniker_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumMoniker_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMoniker_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumMoniker_RemoteNext_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IMoniker __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumMoniker_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMoniker_Skip_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumMoniker_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMoniker_Reset_Proxy( 
    IEnumMoniker __RPC_FAR * This);


void __RPC_STUB IEnumMoniker_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMoniker_Clone_Proxy( 
    IEnumMoniker __RPC_FAR * This,
    /* [out] */ IEnumMoniker __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumMoniker_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMoniker_INTERFACE_DEFINED__ */


#ifndef __IRunnableObject_INTERFACE_DEFINED__
#define __IRunnableObject_INTERFACE_DEFINED__

/* interface IRunnableObject */
/* [uuid][object] */ 

typedef /* [unique] */ IRunnableObject __RPC_FAR *LPRUNNABLEOBJECT;


EXTERN_C const IID IID_IRunnableObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00000126-0000-0000-C000-000000000046")
    IRunnableObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRunningClass( 
            /* [