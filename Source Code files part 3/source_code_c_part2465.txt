	fprintf (f, "%s\n", sv.lightstyles[i]);
		else
			fprintf (f,"m\n");
	}


	ED_WriteGlobals (f);
	for (i=0 ; i<sv.num_edicts ; i++)
	{
		ED_Write (f, EDICT_NUM(i));
		fflush (f);
	}
	fclose (f);
	Con_Printf ("done.\n");
}


/*
===============
Host_Loadgame_f
===============
*/
void Host_Loadgame_f (void)
{
#ifdef _XBOX
	WCHAR   wszName[MAX_GAMENAME];
	CHAR    szPath[MAX_PATH];
	DWORD   dwErr;
#endif // XBOX
	char	name[MAX_OSPATH];
	FILE	*f;
	char	mapname[MAX_QPATH];
	float	time, tfloat;
	char	str[32768], *start;
	int		i, r;
	edict_t	*ent;
	int		entnum;
	int		version;
	float			spawn_parms[NUM_SPAWN_PARMS];

	if (cmd_source != src_command)
		return;

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("load <savename> : load a game\n");
		return;
	}

	cls.demonum = -1;		// stop demo loop in case this fails

#ifdef _XBOX
	MultiByteToWideChar(CP_ACP, 0, Cmd_Argv(1), -1, wszName, ARRAYSIZE(wszName));

	// NOTE: Hard disk only for now (hardcoded U: drive)

	dwErr = XCreateSaveGame("U:\\", wszName, OPEN_EXISTING, 0, szPath, ARRAYSIZE(szPath));

	if (ERROR_SUCCESS != dwErr)
	{
		Con_Printf ("ERROR: couldn't open savegame directory.\n");
		return;
	}

	sprintf (name, "%s%s", szPath, Cmd_Argv(1));
#else  // XBOX
	sprintf (name, "%s/%s", com_gamedir, Cmd_Argv(1));
#endif // XBOX

	COM_DefaultExtension (name, ".sav");
	
// we can't call SCR_BeginLoadingPlaque, because too much stack space has
// been used.  The menu calls it before stuffing loadgame command
//	SCR_BeginLoadingPlaque ();

	Con_Printf ("Loading game from %s...\n", name);
	f = fopen (name, "r");
	if (!f)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		return;
	}

	fscanf (f, "%i\n", &version);
	if (version != SAVEGAME_VERSION)
	{
		fclose (f);
		Con_Printf ("Savegame is version %i, not %i\n", version, SAVEGAME_VERSION);
		return;
	}
	fscanf (f, "%s\n", str);
	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
		fscanf (f, "%f\n", &spawn_parms[i]);
// this silliness is so we can load 1.06 save files, which have float skill values
	fscanf (f, "%f\n", &tfloat);
	current_skill = (int)(tfloat + 0.1);
	Cvar_SetValue ("skill", (float)current_skill);

#ifdef QUAKE2
	Cvar_SetValue ("deathmatch", 0);
	Cvar_SetValue ("coop", 0);
	Cvar_SetValue ("teamplay", 0);
#endif

	fscanf (f, "%s\n",mapname);
	fscanf (f, "%f\n",&time);

	CL_Disconnect_f ();
	
#ifdef QUAKE2
	SV_SpawnServer (mapname, NULL);
#else
	SV_SpawnServer (mapname);
#endif
	if (!sv.active)
	{
		Con_Printf ("Couldn't load map\n");
		return;
	}
	sv.paused = true;		// pause until all clients connect
	sv.loadgame = true;

// load the light styles

	for (i=0 ; i<MAX_LIGHTSTYLES ; i++)
	{
		fscanf (f, "%s\n", str);
		sv.lightstyles[i] = Hunk_Alloc (strlen(str)+1);
		strcpy (sv.lightstyles[i], str);
	}

// load the edicts out of the savegame file
	entnum = -1;		// -1 is the globals
	while (!feof(f))
	{
		for (i=0 ; i<sizeof(str)-1 ; i++)
		{
			r = fgetc (f);
			if (r == EOF || !r)
				break;
			str[i] = (char)r;
			if (r == '}')
			{
				i++;
				break;
			}
		}
		if (i == sizeof(str)-1)
			Sys_Error ("Loadgame buffer overflow");
		str[i] = 0;
		start = str;
		start = COM_Parse(str);
		if (!com_token[0])
			break;		// end of file
		if (strcmp(com_token,"{"))
			Sys_Error ("First token isn't a brace");
			
		if (entnum == -1)
		{	// parse the global vars
			ED_ParseGlobals (start);
		}
		else
		{	// parse an edict

			ent = EDICT_NUM(entnum);
			memset (&ent->v, 0, progs->entityfields * 4);
			ent->free = false;
			ED_ParseEdict (start, ent);
	
		// link it into the bsp tree
			if (!ent->free)
				SV_LinkEdict (ent, false);
		}

		entnum++;
	}
	
	sv.num_edicts = entnum;
	sv.time = time;

	fclose (f);

	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
		svs.clients->spawn_parms[i] = spawn_parms[i];

	if (cls.state != ca_dedicated)
	{
		CL_EstablishConnection ("local");
		Host_Reconnect_f ();
	}
}

#ifdef QUAKE2
void SaveGamestate()
{
	char	name[256];
	FILE	*f;
	int		i;
	char	comment[SAVEGAME_COMMENT_LENGTH+1];
	edict_t	*ent;

	sprintf (name, "%s/%s.gip", com_gamedir, sv.name);
	
	Con_Printf ("Saving game to %s...\n", name);
	f = fopen (name, "w");
	if (!f)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		return;
	}
	
	fprintf (f, "%i\n", SAVEGAME_VERSION);
	Host_SavegameComment (comment);
	fprintf (f, "%s\n", comment);
//	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
//		fprintf (f, "%f\n", svs.clients->spawn_parms[i]);
	fprintf (f, "%f\n", skill.value);
	fprintf (f, "%s\n", sv.name);
	fprintf (f, "%f\n", sv.time);

// write the light styles

	for (i=0 ; i<MAX_LIGHTSTYLES ; i++)
	{
		if (sv.lightstyles[i])
			fprintf (f, "%s\n", sv.lightstyles[i]);
		else
			fprintf (f,"m\n");
	}


	for (i=svs.maxclients+1 ; i<sv.num_edicts ; i++)
	{
		ent = EDICT_NUM(i);
		if ((int)ent->v.flags & FL_ARCHIVE_OVERRIDE)
			continue;
		fprintf (f, "%i\n",i);
		ED_Write (f, ent);
		fflush (f);
	}
	fclose (f);
	Con_Printf ("done.\n");
}

int LoadGamestate(char *level, char *startspot)
{
	char	name[MAX_OSPATH];
	FILE	*f;
	char	mapname[MAX_QPATH];
	float	time, sk;
	char	str[32768], *start;
	int		i, r;
	edict_t	*ent;
	int		entnum;
	int		version;
//	float	spawn_parms[NUM_SPAWN_PARMS];

	sprintf (name, "%s/%s.gip", com_gamedir, level);
	
	Con_Printf ("Loading game from %s...\n", name);
	f = fopen (name, "r");
	if (!f)
	{
		Con_Printf ("ERROR: couldn't open.\n");
		return -1;
	}

	fscanf (f, "%i\n", &version);
	if (version != SAVEGAME_VERSION)
	{
		fclose (f);
		Con_Printf ("Savegame is version %i, not %i\n", version, SAVEGAME_VERSION);
		return -1;
	}
	fscanf (f, "%s\n", str);
//	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
//		fscanf (f, "%f\n", &spawn_parms[i]);
	fscanf (f, "%f\n", &sk);
	Cvar_SetValue ("skill", sk);

	fscanf (f, "%s\n",mapname);
	fscanf (f, "%f\n",&time);

	SV_SpawnServer (mapname, startspot);

	if (!sv.active)
	{
		Con_Printf ("Couldn't load map\n");
		return -1;
	}

// load the light styles
	for (i=0 ; i<MAX_LIGHTSTYLES ; i++)
	{
		fscanf (f, "%s\n", str);
		sv.lightstyles[i] = Hunk_Alloc (strlen(str)+1);
		strcpy (sv.lightstyles[i], str);
	}

// load the edicts out of the savegame file
	while (!feof(f))
	{
		fscanf (f, "%i\n",&entnum);
		for (i=0 ; i<sizeof(str)-1 ; i++)
		{
			r = fgetc (f);
			if (r == EOF || !r)
				break;
			str[i] = r;
			if (r == '}')
			{
				i++;
				break;
			}
		}
		if (i == sizeof(str)-1)
			Sys_Error ("Loadgame buffer overflow");
		str[i] = 0;
		start = str;
		start = COM_Parse(str);
		if (!com_token[0])
			break;		// end of file
		if (strcmp(com_token,"{"))
			Sys_Error ("First token isn't a brace");
			
		// parse an edict

		ent = EDICT_NUM(entnum);
		memset (&ent->v, 0, progs->entityfields * 4);
		ent->free = false;
		ED_ParseEdict (start, ent);
	
		// link it into the bsp tree
		if (!ent->free)
			SV_LinkEdict (ent, false);
	}
	
//	sv.num_edicts = entnum;
	sv.time = time;
	fclose (f);

//	for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
//		svs.clients->spawn_parms[i] = spawn_parms[i];

	return 0;
}

// changing levels within a unit
void Host_Changelevel2_f (void)
{
	char	level[MAX_QPATH];
	char	_startspot[MAX_QPATH];
	char	*startspot;

	if (Cmd_Argc() < 2)
	{
		Con_Printf ("changelevel2 <levelname> : continue game on a new level in the unit\n");
		return;
	}
	if (!sv.active || cls.demoplayback)
	{
		Con_Printf ("Only the server may changelevel\n");
		return;
	}

	strcpy (level, Cmd_Argv(1));
	if (Cmd_Argc() == 2)
		startspot = NULL;
	else
	{
		strcpy (_startspot, Cmd_Argv(2));
		startspot = _startspot;
	}

	SV_SaveSpawnparms ();

	// save the current level's state
	SaveGamestate ();

	// try to restore the new level
	if (LoadGamestate (level, startspot))
		SV_SpawnServer (level, startspot);
}
#endif


//============================================================================

/*
======================
Host_Name_f
======================
*/
void Host_Name_f (void)
{
	char	*newName;

	if (Cmd_Argc () == 1)
	{
		Con_Printf ("\"name\" is \"%s\"\n", cl_name.string);
		return;
	}
	if (Cmd_Argc () == 2)
		newName = Cmd_Argv(1);	
	else
		newName = Cmd_Args();
	newName[15] = 0;

	if (cmd_source == src_command)
	{
		if (Q_strcmp(cl_name.string, newName) == 0)
			return;
		Cvar_Set ("_cl_name", newName);
		if (cls.state == ca_connected)
			Cmd_ForwardToServer ();
		return;
	}

	if (host_client->name[0] && strcmp(host_client->name, "unconnected") )
		if (Q_strcmp(host_client->name, newName) != 0)
			Con_Printf ("%s renamed to %s\n", host_client->name, newName);
	Q_strcpy (host_client->name, newName);
	host_client->edict->v.netname = host_client->name - pr_strings;
	
// send notification to all clients
	
	MSG_WriteByte (&sv.reliable_datagram, svc_updatename);
	MSG_WriteByte (&sv.reliable_datagram, host_client - svs.clients);
	MSG_WriteString (&sv.reliable_datagram, host_client->name);
}

	
void Host_Version_f (void)
{
	Con_Printf ("Version %4.2f\n", VERSION);
	Con_Printf ("Exe: "__TIME__" "__DATE__"\n");
}

#ifdef IDGODS
void Host_Please_f (void)
{
	client_t *cl;
	int			j;
	
	if (cmd_source != src_command)
		return;

	if ((Cmd_Argc () == 3) && Q_strcmp(Cmd_Argv(1), "#") == 0)
	{
		j = Q_atof(Cmd_Argv(2)) - 1;
		if (j < 0 || j >= svs.maxclients)
			return;
		if (!svs.clients[j].active)
			return;
		cl = &svs.clients[j];
		if (cl->privileged)
		{
			cl->privileged = false;
			cl->edict->v.flags = (int)cl->edict->v.flags & ~(FL_GODMODE|FL_NOTARGET);
			cl->edict->v.movetype = MOVETYPE_WALK;
			noclip_anglehack = false;
		}
		else
			cl->privileged = true;
	}

	if (Cmd_Argc () != 2)
		return;

	for (j=0, cl = svs.clients ; j<svs.maxclients ; j++, cl++)
	{
		if (!cl->active)
			continue;
		if (Q_strcasecmp(cl->name, Cmd_Argv(1)) == 0)
		{
			if (cl->privileged)
			{
				cl->privileged = false;
				cl->edict->v.flags = (int)cl->edict->v.flags & ~(FL_GODMODE|FL_NOTARGET);
				cl->edict->v.movetype = MOVETYPE_WALK;
				noclip_anglehack = false;
			}
			else
				cl->privileged = true;
			break;
		}
	}
}
#endif


void Host_Say(qboolean teamonly)
{
	client_t *client;
	client_t *save;
	int		j;
	char	*p;
	unsigned char	text[64];
	qboolean	fromServer = false;

	if (cmd_source == src_command)
	{
		if (cls.state == ca_dedicated)
		{
			fromServer = true;
			teamonly = false;
		}
		else
		{
			Cmd_ForwardToServer ();
			return;
		}
	}

	if (Cmd_Argc () < 2)
		return;

	save = host_client;

	p = Cmd_Args();
// remove quotes if present
	if (*p == '"')
	{
		p++;
		p[Q_strlen(p)-1] = 0;
	}

// turn on color set 1
	if (!fromServer)
		sprintf (text, "%c%s: ", 1, save->name);
	else
		sprintf (text, "%c<%s> ", 1, hostname.string);

	j = sizeof(text) - 2 - Q_strlen(text);  // -2 for /n and null terminator
	if (Q_strlen(p) > j)
		p[j] = 0;

	strcat (text, p);
	strcat (text, "\n");

	for (j = 0, client = svs.clients; j < svs.maxclients; j++, client++)
	{
		if (!client || !client->active || !client->spawned)
			continue;
		if (teamplay.value && teamonly && client->edict->v.team != save->edict->v.team)
			continue;
		host_client = client;
		SV_ClientPrintf("%s", text);
	}
	host_client = save;

	Sys_Printf("%s", &text[1]);
}


void Host_Say_f(void)
{
	Host_Say(false);
}


void Host_Say_Team_f(void)
{
	Host_Say(true);
}


void Host_Tell_f(void)
{
	client_t *client;
	client_t *save;
	int		j;
	char	*p;
	char	text[64];

	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (Cmd_Argc () < 3)
		return;

	Q_strcpy(text, host_client->name);
	Q_strcat(text, ": ");

	p = Cmd_Args();

// remove quotes if present
	if (*p == '"')
	{
		p++;
		p[Q_strlen(p)-1] = 0;
	}

// check length & truncate if necessary
	j = sizeof(text) - 2 - Q_strlen(text);  // -2 for /n and null terminator
	if (Q_strlen(p) > j)
		p[j] = 0;

	strcat (text, p);
	strcat (text, "\n");

	save = host_client;
	for (j = 0, client = svs.clients; j < svs.maxclients; j++, client++)
	{
		if (!client->active || !client->spawned)
			continue;
		if (Q_strcasecmp(client->name, Cmd_Argv(1)))
			continue;
		host_client = client;
		SV_ClientPrintf("%s", text);
		break;
	}
	host_client = save;
}


/*
==================
Host_Color_f
==================
*/
void Host_Color_f(void)
{
	int		top, bottom;
	int		playercolor;
	
	if (Cmd_Argc() == 1)
	{
		Con_Printf ("\"color\" is \"%i %i\"\n", ((int)cl_color.value) >> 4, ((int)cl_color.value) & 0x0f);
		Con_Printf ("color <0-13> [0-13]\n");
		return;
	}

	if (Cmd_Argc() == 2)
		top = bottom = atoi(Cmd_Argv(1));
	else
	{
		top = atoi(Cmd_Argv(1));
		bottom = atoi(Cmd_Argv(2));
	}
	
	top &= 15;
	if (top > 13)
		top = 13;
	bottom &= 15;
	if (bottom > 13)
		bottom = 13;
	
	playercolor = top*16 + bottom;

	if (cmd_source == src_command)
	{
		Cvar_SetValue ("_cl_color", playercolor);
		if (cls.state == ca_connected)
			Cmd_ForwardToServer ();
		return;
	}

	host_client->colors = playercolor;
	host_client->edict->v.team = bottom + 1;

// send notification to all clients
	MSG_WriteByte (&sv.reliable_datagram, svc_updatecolors);
	MSG_WriteByte (&sv.reliable_datagram, host_client - svs.clients);
	MSG_WriteByte (&sv.reliable_datagram, host_client->colors);
}

/*
==================
Host_Kill_f
==================
*/
void Host_Kill_f (void)
{
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (sv_player->v.health <= 0)
	{
		SV_ClientPrintf ("Can't suicide -- allready dead!\n");
		return;
	}
	
	pr_global_struct->time = sv.time;
	pr_global_struct->self = EDICT_TO_PROG(sv_player);
	PR_ExecuteProgram (pr_global_struct->ClientKill);
}


/*
==================
Host_Pause_f
==================
*/
void Host_Pause_f (void)
{
	
	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}
	if (!pausable.value)
		SV_ClientPrintf ("Pause not allowed.\n");
	else
	{
		sv.paused ^= 1;

		if (sv.paused)
		{
			SV_BroadcastPrintf ("%s paused the game\n", pr_strings + sv_player->v.netname);
		}
		else
		{
			SV_BroadcastPrintf ("%s unpaused the game\n",pr_strings + sv_player->v.netname);
		}

	// send notification to all clients
		MSG_WriteByte (&sv.reliable_datagram, svc_setpause);
		MSG_WriteByte (&sv.reliable_datagram, sv.paused);
	}
}

//===========================================================================


/*
==================
Host_PreSpawn_f
==================
*/
void Host_PreSpawn_f (void)
{
	if (cmd_source == src_command)
	{
		Con_Printf ("prespawn is not valid from the console\n");
		return;
	}

	if (host_client->spawned)
	{
		Con_Printf ("prespawn not valid -- allready spawned\n");
		return;
	}
	
	SZ_Write (&host_client->message, sv.signon.data, sv.signon.cursize);
	MSG_WriteByte (&host_client->message, svc_signonnum);
	MSG_WriteByte (&host_client->message, 2);
	host_client->sendsignon = true;
}

/*
==================
Host_Spawn_f
==================
*/
void Host_Spawn_f (void)
{
	int		i;
	client_t	*client;
	edict_t	*ent;

	if (cmd_source == src_command)
	{
		Con_Printf ("spawn is not valid from the console\n");
		return;
	}

	if (host_client->spawned)
	{
		Con_Printf ("Spawn not valid -- allready spawned\n");
		return;
	}

// run the entrance script
	if (sv.loadgame)
	{	// loaded games are fully inited allready
		// if this is the last client to be connected, unpause
		sv.paused = false;
	}
	else
	{
		// set up the edict
		ent = host_client->edict;

		memset (&ent->v, 0, progs->entityfields * 4);
		ent->v.colormap = NUM_FOR_EDICT(ent);
		ent->v.team = (host_client->colors & 15) + 1;
		ent->v.netname = host_client->name - pr_strings;

		// copy spawn parms out of the client_t

		for (i=0 ; i< NUM_SPAWN_PARMS ; i++)
			(&pr_global_struct->parm1)[i] = host_client->spawn_parms[i];

		// call the spawn function

		pr_global_struct->time = sv.time;
		pr_global_struct->self = EDICT_TO_PROG(sv_player);
		PR_ExecuteProgram (pr_global_struct->ClientConnect);

		if ((Sys_FloatTime() - host_client->netconnection->connecttime) <= sv.time)
			Sys_Printf ("%s entered the game\n", host_client->name);

		PR_ExecuteProgram (pr_global_struct->PutClientInServer);	
	}


// send all current names, colors, and frag counts
	SZ_Clear (&host_client->message);

// send time of update
	MSG_WriteByte (&host_client->message, svc_time);
	MSG_WriteFloat (&host_client->message, sv.time);

	for (i=0, client = svs.clients ; i<svs.maxclients ; i++, client++)
	{
		MSG_WriteByte (&host_client->message, svc_updatename);
		MSG_WriteByte (&host_client->message, i);
		MSG_WriteString (&host_client->message, client->name);
		MSG_WriteByte (&host_client->message, svc_updatefrags);
		MSG_WriteByte (&host_client->message, i);
		MSG_WriteShort (&host_client->message, client->old_frags);
		MSG_WriteByte (&host_client->message, svc_updatecolors);
		MSG_WriteByte (&host_client->message, i);
		MSG_WriteByte (&host_client->message, client->colors);
	}
	
// send all current light styles
	for (i=0 ; i<MAX_LIGHTSTYLES ; i++)
	{
		MSG_WriteByte (&host_client->message, svc_lightstyle);
		MSG_WriteByte (&host_client->message, (char)i);
		MSG_WriteString (&host_client->message, sv.lightstyles[i]);
	}

//
// send some stats
//
	MSG_WriteByte (&host_client->message, svc_updatestat);
	MSG_WriteByte (&host_client->message, STAT_TOTALSECRETS);
	MSG_WriteLong (&host_client->message, pr_global_struct->total_secrets);

	MSG_WriteByte (&host_client->message, svc_updatestat);
	MSG_WriteByte (&host_client->message, STAT_TOTALMONSTERS);
	MSG_WriteLong (&host_client->message, pr_global_struct->total_monsters);

	MSG_WriteByte (&host_client->message, svc_updatestat);
	MSG_WriteByte (&host_client->message, STAT_SECRETS);
	MSG_WriteLong (&host_client->message, pr_global_struct->found_secrets);

	MSG_WriteByte (&host_client->message, svc_updatestat);
	MSG_WriteByte (&host_client->message, STAT_MONSTERS);
	MSG_WriteLong (&host_client->message, pr_global_struct->killed_monsters);

	
//
// send a fixangle
// Never send a roll angle, because savegames can catch the server
// in a state where it is expecting the client to correct the angle
// and it won't happen if the game was just loaded, so you wind up
// with a permanent head tilt
	ent = EDICT_NUM( 1 + (host_client - svs.clients) );
	MSG_WriteByte (&host_client->message, svc_setangle);
	for (i=0 ; i < 2 ; i++)
		MSG_WriteAngle (&host_client->message, ent->v.angles[i] );
	MSG_WriteAngle (&host_client->message, 0 );

	SV_WriteClientdataToMessage (sv_player, &host_client->message);

	MSG_WriteByte (&host_client->message, svc_signonnum);
	MSG_WriteByte (&host_client->message, 3);
	host_client->sendsignon = true;
}

/*
==================
Host_Begin_f
==================
*/
void Host_Begin_f (void)
{
	if (cmd_source == src_command)
	{
		Con_Printf ("begin is not valid from the console\n");
		return;
	}

	host_client->spawned = true;
}

//===========================================================================


/*
==================
Host_Kick_f

Kicks a user off of the server
==================
*/
void Host_Kick_f (void)
{
	char		*who;
	char		*message = NULL;
	client_t	*save;
	int			i;
	qboolean	byNumber = false;

	if (cmd_source == src_command)
	{
		if (!sv.active)
		{
			Cmd_ForwardToServer ();
			return;
		}
	}
	else if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	save = host_client;

	if (Cmd_Argc() > 2 && Q_strcmp(Cmd_Argv(1), "#") == 0)
	{
		i = Q_atof(Cmd_Argv(2)) - 1;
		if (i < 0 || i >= svs.maxclients)
			return;
		if (!svs.clients[i].active)
			return;
		host_client = &svs.clients[i];
		byNumber = true;
	}
	else
	{
		for (i = 0, host_client = svs.clients; i < svs.maxclients; i++, host_client++)
		{
			if (!host_client->active)
				continue;
			if (Q_strcasecmp(host_client->name, Cmd_Argv(1)) == 0)
				break;
		}
	}

	if (i < svs.maxclients)
	{
		if (cmd_source == src_command)
			if (cls.state == ca_dedicated)
				who = "Console";
			else
				who = cl_name.string;
		else
			who = save->name;

		// can't kick yourself!
		if (host_client == save)
			return;

		if (Cmd_Argc() > 2)
		{
			message = COM_Parse(Cmd_Args());
			if (byNumber)
			{
				message++;							// skip the #
				while (*message == ' ')				// skip white space
					message++;
				message += Q_strlen(Cmd_Argv(2));	// skip the number
			}
			while (*message && *message == ' ')
				message++;
		}
		if (message)
			SV_ClientPrintf ("Kicked by %s: %s\n", who, message);
		else
			SV_ClientPrintf ("Kicked by %s\n", who);
		SV_DropClient (false);
	}

	host_client = save;
}

/*
===============================================================================

DEBUGGING TOOLS

===============================================================================
*/

/*
==================
Host_Give_f
==================
*/
void Host_Give_f (void)
{
	char	*t;
	int		v, w;
	eval_t	*val;

	if (cmd_source == src_command)
	{
		Cmd_ForwardToServer ();
		return;
	}

	if (pr_global_struct->deathmatch && !host_client->privileged)
		return;

	t = Cmd_Argv(1);
	v = atoi (Cmd_Argv(2));
	
	switch (t[0])
	{
   case '0':
   case '1':
   case '2':
   case '3':
   case '4':
   case '5':
   case '6':
   case '7':
   case '8':
   case '9':
      // MED 01/04/97 added hipnotic give stuff
      if (hipnotic)
      {
         if (t[0] == '6')
         {
            if (t[1] == 'a')
               sv_player->v.items = (int)sv_player->v.items | HIT_PROXIMITY_GUN;
            else
               sv_player->v.items = (int)sv_player->v.items | IT_GRENADE_LAUNCHER;
         }
         else if (t[0] == '9')
            sv_player->v.items = (int)sv_player->v.items | HIT_LASER_CANNON;
         else if (t[0] == '0')
            sv_player->v.items = (int)sv_player->v.items | HIT_MJOLNIR;
         else if (t[0] >= '2')
            sv_player->v.items = (int)sv_player->v.items | (IT_SHOTGUN << (t[0] - '2'));
      }
      else
      {
         if (t[0] >= '2')
            sv_player->v.items = (int)sv_player->v.items | (IT_SHOTGUN << (t[0] - '2'));
      }
		break;
	
    case 's':
		if (rogue)
		{
	        val = GetEdictFieldValue(sv_player, "ammo_shells1");
		    if (val)
			    val->_float = v;
		}

        sv_player->v.ammo_shells = v;
        break;		
    case 'n':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_nails1");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon <= IT_LIGHTNING)
					sv_player->v.ammo_nails = v;
			}
		}
		else
		{
			sv_player->v.ammo_nails = v;
		}
        break;		
    case 'l':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_lava_nails");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon > IT_LIGHTNING)
					sv_player->v.ammo_nails = v;
			}
		}
        break;
    case 'r':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_rockets1");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon <= IT_LIGHTNING)
					sv_player->v.ammo_rockets = v;
			}
		}
		else
		{
			sv_player->v.ammo_rockets = v;
		}
        break;		
    case 'm':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_multi_rockets");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon > IT_LIGHTNING)
					sv_player->v.ammo_rockets = v;
			}
		}
        break;		
    case 'h':
        sv_player->v.health = v;
        break;		
    case 'c':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_cells1");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon <= IT_LIGHTNING)
					sv_player->v.ammo_cells = v;
			}
		}
		else
		{
			sv_player->v.ammo_cells = v;
		}
        break;		
    case 'p':
		if (rogue)
		{
			val = GetEdictFieldValue(sv_player, "ammo_plasma");
			if (val)
			{
				val->_float = v;
				if (sv_player->v.weapon > IT_LIGHTNING)
					sv_player->v.ammo_cells = v;
			}
		}
        break;		
    }
}

edict_t	*FindViewthing (void)
{
	int		i;
	edict_t	*e;
	
	for (i=0 ; i<sv.num_edicts ; i++)
	{
		e = EDICT_NUM(i);
		if ( !strcmp (pr_strings + e->v.classname, "viewthing") )
			return e;
	}
	Con_Printf ("No viewthing on map\n");
	return NULL;
}

/*
==================
Host_Viewmodel_f
==================
*/
void Host_Viewmodel_f (void)
{
	edict_t	*e;
	model_t	*m;

	e = FindViewthing ();
	if (!e)
		return;

	m = Mod_ForName (Cmd_Argv(1), false);
	if (!m)
	{
		Con_Printf ("Can't load %s\n", Cmd_Argv(1));
		return;
	}
	
	e->v.frame = 0;
	cl.model_precache[(int)e->v.modelindex] = m;
}

/*
==================
Host_Viewframe_f
==================
*/
void Host_Viewframe_f (void)
{
	edict_t	*e;
	int		f;
	model_t	*m;

	e = FindViewthing ();
	if (!e)
		return;
	m = cl.model_precache[(int)e->v.modelindex];

	f = atoi(Cmd_Argv(1));
	if (f >= m->numframes)
		f = m->numframes-1;

	e->v.frame = f;		
}


void PrintFrameName (model_t *m, int frame)
{
	aliashdr_t 			*hdr;
	maliasframedesc_t	*pframedesc;

	hdr = (aliashdr_t *)Mod_Extradata (m);
	if (!hdr)
		return;
	pframedesc = &hdr->frames[frame];
	
	Con_Printf ("frame %i: %s\n", frame, pframedesc->name);
}

/*
==================
Host_Viewnext_f
==================
*/
void Host_Viewnext_f (void)
{
	edict_t	*e;
	model_t	*m;
	
	e = FindViewthing ();
	if (!e)
		return;
	m = cl.model_precache[(int)e->v.modelindex];

	e->v.frame = e->v.frame + 1;
	if (e->v.frame >= m->numframes)
		e->v.frame = m->numframes - 1;

	PrintFrameName (m, e->v.frame);		
}

/*
==================
Host_Viewprev_f
==================
*/
void Host_Viewprev_f (void)
{
	edict_t	*e;
	model_t	*m;

	e = FindViewthing ();
	if (!e)
		return;

	m = cl.model_precache[(int)e->v.modelindex];

	e->v.frame = e->v.frame - 1;
	if (e->v.frame < 0)
		e->v.frame = 0;

	PrintFrameName (m, e->v.frame);		
}

/*
===============================================================================

DEMO LOOP CONTROL

===============================================================================
*/


/*
==================
Host_Startdemos_f
==================
*/
void Host_Startdemos_f (void)
{
	int		i, c;

	if (cls.state == ca_dedicated)
	{
		if (!sv.active)
			Cbuf_AddText ("map start\n");
		return;
	}

	c = Cmd_Argc() - 1;
	if (c > MAX_DEMOS)
	{
		Con_Printf ("Max %i demos in demoloop\n", MAX_DEMOS);
		c = MAX_DEMOS;
	}
	Con_Printf ("%i demo(s) in loop\n", c);

	for (i=1 ; i<c+1 ; i++)
		strncpy (cls.demos[i-1], Cmd_Argv(i), sizeof(cls.demos[0])-1);

	if (!sv.active && cls.demonum != -1 && !cls.demoplayback)
	{
		cls.demonum = 0;
		CL_NextDemo ();
	}
	else
		cls.demonum = -1;
}


/*
==================
Host_Demos_f

Return to looping demos
==================
*/
void Host_Demos_f (void)
{
	if (cls.state == ca_dedicated)
		return;
	if (cls.demonum == -1)
		cls.demonum = 1;
	CL_Disconnect_f ();
	CL_NextDemo ();
}

/*
==================
Host_Stopdemo_f

Return to looping demos
==================
*/
void Host_Stopdemo_f (void)
{
	if (cls.state == ca_dedicated)
		return;
	if (!cls.demoplayback)
		return;
	CL_StopPlayback ();
	CL_Disconnect ();
}

//=============================================================================

/*
==================
Host_InitCommands
==================
*/
void Host_InitCommands (void)
{
	Cmd_AddCommand ("status", Host_Status_f);
	Cmd_AddCommand ("quit", Host_Quit_f);
	Cmd_AddCommand ("god", Host_God_f);
	Cmd_AddCommand ("notarget", Host_Notarget_f);
	Cmd_AddCommand ("fly", Host_Fly_f);
	Cmd_AddCommand ("map", Host_Map_f);
	Cmd_AddCommand ("restart", Host_Restart_f);
	Cmd_AddCommand ("changelevel", Host_Changelevel_f);
#ifdef QUAKE2
	Cmd_AddCommand ("changelevel2", Host_Changelevel2_f);
#endif
	Cmd_AddCommand ("connect", Host_Connect_f);
	Cmd_AddCommand ("reconnect", Host_Reconnect_f);
	Cmd_AddCommand ("name", Host_Name_f);
	Cmd_AddCommand ("noclip", Host_Noclip_f);
	Cmd_AddCommand ("version", Host_Version_f);
#ifdef IDGODS
	Cmd_AddCommand ("please", Host_Please_f);
#endif
	Cmd_AddCommand ("say", Host_Say_f);
	Cmd_AddCommand ("say_team", Host_Say_Team_f);
	Cmd_AddCommand ("tell", Host_Tell_f);
	Cmd_AddCommand ("color", Host_Color_f);
	Cmd_AddCommand ("kill", Host_Kill_f);
	Cmd_AddCommand ("pause", Host_Pause_f);
	Cmd_AddCommand ("spawn", Host_Spawn_f);
	Cmd_AddCommand ("begin", Host_Begin_f);
	Cmd_AddCommand ("prespawn", Host_PreSpawn_f);
	Cmd_AddCommand ("kick", Host_Kick_f);
	Cmd_AddCommand ("ping", Host_Ping_f);
	Cmd_AddCommand ("load", Host_Loadgame_f);
	Cmd_AddCommand ("save", Host_Savegame_f);
	Cmd_AddCommand ("give", Host_Give_f);

	Cmd_AddCommand ("startdemos", Host_Startdemos_f);
	Cmd_AddCommand ("demos", Host_Demos_f);
	Cmd_AddCommand ("stopdemo", Host_Stopdemo_f);

	Cmd_AddCommand ("viewmodel", Host_Viewmodel_f);
	Cmd_AddCommand ("viewframe", Host_Viewframe_f);
	Cmd_AddCommand ("viewnext", Host_Viewnext_f);
	Cmd_AddCommand ("viewprev", Host_Viewprev_f);

	Cmd_AddCommand ("mcache", Mod_Print);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl_vidnt.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// gl_vidnt.c -- NT GL vid component

#include "quakedef.h"
#include "xquake.h"

PROC  WINAPI wglGetProcAddress(LPCSTR s);
HGLRC WINAPI wglGetCurrentContext(VOID);
BOOL  WINAPI wglMakeCurrent(HDC hdc, HGLRC hglrc);
BOOL  WINAPI wglDeleteContext(HGLRC hglrc);
HGLRC WINAPI wglCreateContext(HDC /* hdc */);

#define MAX_MODE_LIST	30
#define VID_ROW_SIZE	3
#define WARP_WIDTH		320
#define WARP_HEIGHT		200
#define MAXWIDTH		10000
#define MAXHEIGHT		10000
#define BASEWIDTH		320
#define BASEHEIGHT		200

typedef struct {
	modestate_t	type;
	int			width;
	int			height;
	int			modenum;
	int			dib;
	int			fullscreen;
	int			bpp;
	int			halfscreen;
	char		modedesc[17];
} vmode_t;

typedef struct {
	int			width;
	int			height;
} lmode_t;

lmode_t	lowresmodes[] = {
	{320, 200},
	{320, 240},
	{400, 300},
	{512, 384},
};

const char *gl_vendor;
const char *gl_renderer;
const char *gl_version;
const char *gl_extensions;

qboolean		DDActive;
qboolean		scr_skipupdate;

static vmode_t	modelist[2];
static int		nummodes = 2;
static vmode_t	*pcurrentmode = modelist;
static vmode_t	badmode;

static qboolean	vid_initialized = false;
static qboolean vid_canalttab = false;
static qboolean vid_wassuspended = false;

int			DIBWidth, DIBHeight;

int			vid_realmode;
int         vid_modenum;
unsigned char	vid_curpal[256*3];
static qboolean fullsbardraw = false;

static float vid_gamma = 1.0;

HGLRC	baseRC;

glvert_t glv;

#ifdef D3DQUAKE
cvar_t	gl_ztrick = {"gl_ztrick","0"};
#else
cvar_t	gl_ztrick = {"gl_ztrick","1"};
#endif

viddef_t	vid;				// global video state

unsigned short	d_8to16table[256];
unsigned	d_8to24table[256];
unsigned char d_15to8table[65536];

float		gldepthmin, gldepthmax;

modestate_t	modestate = MS_UNINIT;

void VID_MenuDraw (void);
void VID_MenuKey (int key);

char *VID_GetModeDescription (int mode);
void ClearAllStates (void);
void GL_Init (void);

PROC glArrayElementEXT;
PROC glColorPointerEXT;
PROC glTexCoordPointerEXT;
PROC glVertexPointerEXT;

typedef void (APIENTRY *lp3DFXFUNC) (int, int, int, int, int, const void*);
lp3DFXFUNC glColorTableEXT;
qboolean is8bit = false;
qboolean isPermedia = false;
qboolean gl_mtexable = false;

//====================================

#define MODE_FULLSCREEN_DEFAULT 3

int vid_default;

cvar_t		vid_mode = {"vid_mode","0", false};
// Note that 0 is MODE_WINDOWED
cvar_t		_vid_default_mode = {"_vid_default_mode","0", true};
// Note that 3 is MODE_FULLSCREEN_DEFAULT
cvar_t		_vid_default_mode_win = {"_vid_default_mode_win","3", true};
cvar_t		vid_wait = {"vid_wait","0"};
cvar_t		vid_nopageflip = {"vid_nopageflip","0", true};
cvar_t		_vid_wait_override = {"_vid_wait_override", "0", true};
cvar_t		vid_config_x = {"vid_config_x","800", true};
cvar_t		vid_config_y = {"vid_config_y","600", true};
cvar_t		vid_stretch_by_2 = {"vid_stretch_by_2","1", true};

// direct draw software compatability stuff

void VID_HandlePause (qboolean pause)
{
}

void VID_ForceLockState (int lk)
{
}

void VID_LockBuffer (void)
{
}

void VID_UnlockBuffer (void)
{
}

int VID_ForceUnlockedAndReturnState (void)
{
	return 0;
}

void D_BeginDirectRect (int x, int y, byte *pbitmap, int width, int height)
{
}

void D_EndDirectRect (int x, int y, int width, int height)
{
}

qboolean VID_SetFullDIBMode (int modenum)
{
	int				lastmodestate, width, height;

	lastmodestate = modestate;
	modestate = MS_FULLDIB;

	DIBWidth = modelist[modenum].width;
	DIBHeight = modelist[modenum].height;

	if (vid.conheight > modelist[modenum].height)
		vid.conheight = modelist[modenum].height;
	if (vid.conwidth > modelist[modenum].width)
		vid.conwidth = modelist[modenum].width;
	vid.width = vid.conwidth;
	vid.height = vid.conheight;

	vid.numpages = 2;

	return true;
}


int VID_SetMode (int modenum, unsigned char *palette)
{
	int				temp;
	qboolean		stat;

// so Con_Printfs don't mess us up by forcing vid and snd updates
	temp = scr_disabled_for_loading;
	scr_disabled_for_loading = true;

#if !defined(XBOX)
	CDAudio_Pause ();
#endif !defined(XBOX)

	if (modelist[modenum].type == MS_FULLDIB)
	{
		stat = VID_SetFullDIBMode(modenum);
	}
	else
	{
		Sys_Error ("VID_SetMode: Bad mode type in modelist");
	}


#if !defined(XBOX)
	CDAudio_Resume ();
#endif !defined(XBOX)
	scr_disabled_for_loading = temp;

	if (!stat)
	{
		Sys_Error ("Couldn't set video mode");
	}

// now we try to make sure we get the focus on the mode switch, because
// sometimes in some systems we don't.  We grab the foreground, then
// finish setting up, pump all our messages, and sleep for a little while
// to let messages finish bouncing around the system, then we put
// ourselves at the top of the z order, then grab the foreground again,
// Who knows if it helps, but it probably doesn't hurt
	VID_SetPalette (palette);
	vid_modenum = modenum;
	Cvar_SetValue ("vid_mode", (float)vid_modenum);

	if (!msg_suppress_1)
		Con_SafePrintf ("Video mode %s initialized.\n", VID_GetModeDescription (vid_modenum));

	VID_SetPalette (palette);

	vid.recalc_refdef = 1;

	return true;
}


//====================================

BINDTEXFUNCPTR bindTexFunc;

#define TEXTURE_EXT_STRING "GL_EXT_texture_object"


void CheckTextureExtensions (void)
{
	char		*tmp;
	qboolean	texture_ext;
	HINSTANCE	hInstGL;

	texture_ext = FALSE;
	/* check for texture extension */
	tmp = (unsigned char *)glGetString(GL_EXTENSIONS);
	while (*tmp)
	{
		if (strncmp((const char*)tmp, TEXTURE_EXT_STRING, strlen(TEXTURE_EXT_STRING)) == 0)
			texture_ext = TRUE;
		tmp++;
	}

/* load library and get procedure adresses for texture extension API */
	if ((bindTexFunc = (BINDTEXFUNCPTR)
		wglGetProcAddress((LPCSTR) "glBindTextureEXT")) == NULL)
	{
		Sys_Error ("GetProcAddress for BindTextureEXT failed");
		return;
	}
}

void CheckArrayExtensions (void)
{
	char		*tmp;

	/* check for texture extension */
	tmp = (unsigned char *)glGetString(GL_EXTENSIONS);
	while (*tmp)
	{
		if (strncmp((const char*)tmp, "GL_EXT_vertex_array", strlen("GL_EXT_vertex_array")) == 0)
		{
			if (
((glArrayElementEXT = wglGetProcAddress("glArrayElementEXT")) == NULL) ||
((glColorPointerEXT = wglGetProcAddress("glColorPointerEXT")) == NULL) ||
((glTexCoordPointerEXT = wglGetProcAddress("glTexCoordPointerEXT")) == NULL) ||
((glVertexPointerEXT = wglGetProcAddress("glVertexPointerEXT")) == NULL) )
			{
				Sys_Error ("GetProcAddress for vertex extension failed");
				return;
			}
			return;
		}
		tmp++;
	}

	Sys_Error ("Vertex array extension not present");
}

//int		texture_mode = GL_NEAREST;
//int		texture_mode = GL_NEAREST_MIPMAP_NEAREST;
//int		texture_mode = GL_NEAREST_MIPMAP_LINEAR;
int		texture_mode = GL_LINEAR;
//int		texture_mode = GL_LINEAR_MIPMAP_NEAREST;
//int		texture_mode = GL_LINEAR_MIPMAP_LINEAR;

int		texture_extension_number = 1;

#ifdef _WIN32
void CheckMultiTextureExtensions(void)
{
	if (strstr(gl_extensions, "GL_SGIS_multitexture ")) {
		Con_Printf("Multitexture extensions found.\n");
		qglMTexCoord2fSGIS = (void *) wglGetProcAddress("glMTexCoord2fSGIS");
		qglSelectTextureSGIS = (void *) wglGetProcAddress("glSelectTextureSGIS");
		gl_mtexable = true;
	}
}
#else
void CheckMultiTextureExtensions(void)
{
		gl_mtexable = true;
}
#endif

/*
===============
GL_Init
===============
*/
void GL_Init (void)
{
	gl_vendor = glGetString (GL_VENDOR);
	Con_Printf ("GL_VENDOR: %s\n", gl_vendor);
	gl_renderer = glGetString (GL_RENDERER);
	Con_Printf ("GL_RENDERER: %s\n", gl_renderer);

	gl_version = glGetString (GL_VERSION);
	Con_Printf ("GL_VERSION: %s\n", gl_version);
	gl_extensions = glGetString (GL_EXTENSIONS);
	Con_Printf ("GL_EXTENSIONS: %s\n", gl_extensions);

//	Con_Printf ("%s %s\n", gl_renderer, gl_version);

	CheckTextureExtensions ();
	CheckMultiTextureExtensions ();

	glClearColor (1,0,0,0);
	glCullFace(GL_FRONT);
	glEnable(GL_TEXTURE_2D);

	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_GREATER, 0.666);

	glPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
	glShadeModel (GL_FLAT);

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

	glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

//	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);

#if 0
	CheckArrayExtensions ();

	glEnable (GL_VERTEX_ARRAY_EXT);
	glEnable (GL_TEXTURE_COORD_ARRAY_EXT);
	glVertexPointerEXT (3, GL_FLOAT, 0, 0, &glv.x);
	glTexCoordPointerEXT (2, GL_FLOAT, 0, 0, &glv.s);
	glColorPointerEXT (3, GL_FLOAT, 0, 0, &glv.r);
#endif
}

/*
=================
GL_BeginRendering

=================
*/
void GL_BeginRendering (int *x, int *y, int *width, int *height)
{
	extern cvar_t gl_clear;

	*x = *y = 0;
	*width = DIBWidth;
	*height = DIBHeight;

//    if (!wglMakeCurrent( maindc, baseRC ))
//		Sys_Error ("wglMakeCurrent failed");

//	glViewport (*x, *y, *width, *height);
}

#ifdef D3DQUAKE
// Call our swap buffer instead of the standard one
void FakeSwapBuffers();
#endif

void GL_EndRendering (void)
{
	if (!scr_skipupdate || block_drawing)
#ifdef D3DQUAKE
		FakeSwapBuffers();
#else
		SwapBuffers(maindc);
#endif

// handle the mouse state when windowed if that's changed
	if (fullsbardraw)
		Sbar_Changed();
}

void	VID_SetPalette (unsigned char *palette)
{
	byte	*pal;
	unsigned r,g,b;
	unsigned v;
	int     r1,g1,b1;
	int		j,k,l,m;
	unsigned short i;
	unsigned	*table;
	FILE *f;
	char s[255];
	HWND hDlg, hProgress;
	float gamma;

//
// 8 8 8 encoding
//
	pal = palette;
	table = d_8to24table;
	for (i=0 ; i<256 ; i++)
	{
		r = pal[0];
		g = pal[1];
		b = pal[2];
		pal += 3;
		
//		v = (255<<24) + (r<<16) + (g<<8) + (b<<0);
//		v = (255<<0) + (r<<8) + (g<<16) + (b<<24);
		v = (255<<24) + (r<<0) + (g<<8) + (b<<16);
		*table++ = v;
	}
	d_8to24table[255] &= 0xffffff;	// 255 is transparent

	// JACK: 3D distance calcs - k is last closest, l is the distance.
	// FIXME: Precalculate this and cache to disk.
	for (i=0; i < (1<<15); i++) {
		/* Maps
			000000000000000
			000000000011111 = Red  = 0x1F
			000001111100000 = Blue = 0x03E0
			111110000000000 = Grn  = 0x7C00
		*/
		r = ((i & 0x1F) << 3)+4;
		g = ((i & 0x03E0) >> 2)+4;
		b = ((i & 0x7C00) >> 7)+4;
		pal = (unsigned char *)d_8to24table;
		for (v=0,k=0,l=10000*10000; v<256; v++,pal+=4) {
			r1 = r-pal[0];
			g1 = g-pal[1];
			b1 = b-pal[2];
			j = (r1*r1)+(g1*g1)+(b1*b1);
			if (j<l) {
				k=v;
				l=j;
			}
		}
		d_15to8table[i]=(byte)k;
	}
}

BOOL	gammaworks;

void	VID_ShiftPalette (unsigned char *palette)
{
	extern	byte ramps[3][256];
	
//	VID_SetPalette (palette);

//	gammaworks = SetDeviceGammaRamp (maindc, ramps);
}


void VID_SetDefaultMode (void)
{
}


void	VID_Shutdown (void)
{
   	HGLRC hRC;

	if (vid_initialized)
	{
		vid_canalttab = false;
		hRC = wglGetCurrentContext();

    	wglMakeCurrent(NULL, NULL);

    	if (hRC)
    	    wglDeleteContext(hRC);
	}
}


//==========================================================================
#ifndef D3DQUAKE

BOOL bSetupPixelFormat(HDC hDC)
{
    static PIXELFORMATDESCRIPTOR pfd = {
	sizeof(PIXELFORMATDESCRIPTOR),	// size of this pfd
	1,				// version number
	PFD_DRAW_TO_WINDOW 		// support window
	|  PFD_SUPPORT_OPENGL 	// support OpenGL
	|  PFD_DOUBLEBUFFER ,	// double buffered
	PFD_TYPE_RGBA,			// RGBA type
	24,				// 24-bit color depth
	0, 0, 0, 0, 0, 0,		// color bits ignored
	0,				// no alpha buffer
	0,				// shift bit ignored
	0,				// no accumulation buffer
	0, 0, 0, 0, 			// accum bits ignored
	32,				// 32-bit z-buffer	
	0,				// no stencil buffer
	0,				// no auxiliary buffer
	PFD_MAIN_PLANE,			// main layer
	0,				// reserved
	0, 0, 0				// layer masks ignored
    };
    int pixelformat;

    if ( (pixelformat = ChoosePixelFormat(hDC, &pfd)) == 0 )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    if (SetPixelFormat(hDC, pixelformat, &pfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    return TRUE;
}

#endif

byte        scantokey[128] =
					{
//  0           1       2       3       4       5       6       7
//  8           9       A       B       C       D       E       F
	0  ,    27,     '1',    '2',    '3',    '4',    '5',    '6',
	'7',    '8',    '9',    '0',    '-',    '=',    K_BACKSPACE, 9, // 0
	'q',    'w',    'e',    'r',    't',    'y',    'u',    'i',
	'o',    'p',    '[',    ']',    13 ,    K_CTRL,'a',  's',      // 1
	'd',    'f',    'g',    'h',    'j',    'k',    'l',    ';',
	'\'' ,    '`',    K_SHIFT,'\\',  'z',    'x',    'c',    'v',      // 2
	'b',    'n',    'm',    ',',    '.',    '/',    K_SHIFT,'*',
	K_ALT,' ',   0  ,    K_F1, K_F2, K_F3, K_F4, K_F5,   // 3
	K_F6, K_F7, K_F8, K_F9, K_F10, K_PAUSE  ,    0  , K_HOME,
	K_UPARROW,K_PGUP,'-',K_LEFTARROW,'5',K_RIGHTARROW,'+',K_END, //4
	K_DOWNARROW,K_PGDN,K_INS,K_DEL,0,0,             0,              K_F11,
	K_F12,0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 5
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 6
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0         // 7
					};

byte        shiftscantokey[128] =
					{
//  0           1       2       3       4       5       6       7
//  8           9       A       B       C       D       E       F
	0  ,    27,     '!',    '@',    '#',    '$',    '%',    '^',
	'&',    '*',    '(',    ')',    '_',    '+',    K_BACKSPACE, 9, // 0
	'Q',    'W',    'E',    'R',    'T',    'Y',    'U',    'I',
	'O',    'P',    '{',    '}',    13 ,    K_CTRL,'A',  'S',      // 1
	'D',    'F',    'G',    'H',    'J',    'K',    'L',    ':',
	'"' ,    '~',    K_SHIFT,'|',  'Z',    'X',    'C',    'V',      // 2
	'B',    'N',    'M',    '<',    '>',    '?',    K_SHIFT,'*',
	K_ALT,' ',   0  ,    K_F1, K_F2, K_F3, K_F4, K_F5,   // 3
	K_F6, K_F7, K_F8, K_F9, K_F10, K_PAUSE  ,    0  , K_HOME,
	K_UPARROW,K_PGUP,'_',K_LEFTARROW,'%',K_RIGHTARROW,'+',K_END, //4
	K_DOWNARROW,K_PGDN,K_INS,K_DEL,0,0,             0,              K_F11,
	K_F12,0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 5
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,        // 6
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0,
	0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0  ,    0         // 7
					};


/*
=======
MapKey

Map from windows to quake keynums
=======
*/
int MapKey (int key)
{
	key = (key>>16)&255;
	if (key > 127)
		return 0;
	if (scantokey[key] == 0)
		Con_DPrintf("key 0x%02x has no translation\n", key);
	return scantokey[key];
}

/*
===================================================================

MAIN WINDOW

===================================================================
*/

/*
================
ClearAllStates
================
*/
void ClearAllStates (void)
{
	int		i;
	
// send an up event for each key, to make sure the server clears them all
	for (i=0 ; i<256 ; i++)
	{
		Key_Event (i, false);
	}

	Key_ClearStates ();

#if !defined(XBOX)
	IN_ClearStates ();
#endif !defined(XBOX)
}

/*
=================
VID_NumModes
=================
*/
int VID_NumModes (void)
{
	return nummodes;
}

	
/*
=================
VID_GetModePtr
=================
*/
vmode_t *VID_GetModePtr (int modenum)
{

	if ((modenum >= 0) && (modenum < nummodes))
		return &modelist[modenum];
	else
		return &badmode;
}


/*
=================
VID_GetModeDescription
=================
*/
char *VID_GetModeDescription (int mode)
{
	char		*pinfo;
	vmode_t		*pv;
	static char	temp[100];

	if ((mode < 0) || (mode >= nummodes))
		return NULL;

	pv = VID_GetModePtr (mode);
	pinfo = pv->modedesc;

	return pinfo;
}


// KJB: Added this to return the mode driver name in description for console

char *VID_GetExtModeDescription (int mode)
{
	static char	pinfo[40];
	vmode_t		*pv;

	if ((mode < 0) || (mode >= nummodes))
		return NULL;

	pv = VID_GetModePtr (mode);
	sprintf(pinfo,"%s fullscreen", pv->modedesc);

	return pinfo;
}


/*
=================
VID_DescribeCurrentMode_f
=================
*/
void VID_DescribeCurrentMode_f (void)
{
	Con_Printf ("%s\n", VID_GetExtModeDescription (vid_modenum));
}


/*
=================
VID_NumModes_f
=================
*/
void VID_NumModes_f (void)
{

	if (nummodes == 1)
		Con_Printf ("%d video mode is available\n", nummodes);
	else
		Con_Printf ("%d video modes are available\n", nummodes);
}


/*
=================
VID_DescribeMode_f
=================
*/
void VID_DescribeMode_f (void)
{
	int		t, modenum;
	
	modenum = Q_atoi (Cmd_Argv(1));

	Con_Printf ("%s\n", VID_GetExtModeDescription (modenum));
}


/*
=================
VID_DescribeModes_f
=================
*/
void VID_DescribeModes_f (void)
{
	int			i, lnummodes, t;
	char		*pinfo;
	vmode_t		*pv;

	lnummodes = VID_NumModes ();

	for (i=1 ; i<lnummodes ; i++)
	{
		pv = VID_GetModePtr (i);
		pinfo = VID_GetExtModeDescription (i);
		Con_Printf ("%2d: %s\n", i, pinfo);
	}
    }


void VID_InitDIB (HINSTANCE hInstance)
{
	int				i;

	modelist[0].type = 0;

    modelist[0].width = 640;

	if (modelist[0].width < 320)
		modelist[0].width = 320;

	modelist[0].height = modelist[0].width * 240/320;

	if (modelist[0].height < 240)
		modelist[0].height = 240;

	sprintf (modelist[0].modedesc, "%dx%d",
			 modelist[0].width, modelist[0].height);

	modelist[0].modenum = 0;
	modelist[0].dib = 1;
	modelist[0].fullscreen = 0;
	modelist[0].halfscreen = 0;
	modelist[0].bpp = 0;
}


/*
=================
VID_InitFullDIB
=================
*/
void VID_InitFullDIB (HINSTANCE hInstance)
{
    modelist[1].type = MS_FULLDIB;
    modelist[1].width = 640;
    modelist[1].height = 480;
    modelist[1].modenum = 0;
    modelist[1].halfscreen = 0;
    modelist[1].dib = 1;
    modelist[1].fullscreen = 1;
    modelist[1].bpp = 32;
    strcpy(modelist[1].modedesc, "640x480x32");
}

qboolean VID_Is8bit() {
	return is8bit;
}

#define GL_SHARED_TEXTURE_PALETTE_EXT 0x81FB

void VID_Init8bitPalette()
{
	// Check for 8bit Extensions and initialize them.
	int i;
	char thePalette[256*3];
	char *oldPalette, *newPalette;

	glColorTableEXT = (void *)wglGetProcAddress("glColorTableEXT");
    if (!glColorTableEXT || strstr(gl_extensions, "GL_EXT_shared_texture_palette"))
		return;

	Con_SafePrintf("8-bit GL extensions enabled.\n");
    glEnable( GL_SHARED_TEXTURE_PALETTE_EXT );
	oldPalette = (char *) d_8to24table; //d_8to24table3dfx;
	newPalette = thePalette;
	for (i=0;i<256;i++) {
		*newPalette++ = *oldPalette++;
		*newPalette++ = *oldPalette++;
		*newPalette++ = *oldPalette++;
		oldPalette++;
	}
	glColorTableEXT(GL_SHARED_TEXTURE_PALETTE_EXT, GL_RGB, 256, GL_RGB, GL_UNSIGNED_BYTE,
		(void *) thePalette);
	is8bit = TRUE;
}

static void Check_Gamma (unsigned char *pal)
{
	float	f, inf;
	unsigned char	palette[768];
	int		i;

	
	vid_gamma = 0.7; // default to 0.7 on non-3dfx hardware

	for (i=0 ; i<768 ; i++)
	{
		f = pow ( (pal[i]+1)/256.0 , vid_gamma );
		inf = f*255 + 0.5;
		if (inf < 0)
			inf = 0;
		if (inf > 255)
			inf = 255;
		palette[i] = inf;
	}

	memcpy (pal, palette, sizeof(palette));
}

#ifdef D3DQUAKE
void d3dInitSetForce16BitTextures(int force16bitTextures);
void d3dSetMode(int fullscreen, int width, int height, int bpp, int zbpp);

#ifdef _XBOX
extern void FGL_SetAAType(int mstype);

void FGL_SetAAType_f(void)
{
    int         c;
    char        *endptr;
    char        cmd[1024];
    int         mstype = -1;

    c = Cmd_Argc();

    if(c == 2)
    {
        char *sztype = Cmd_Argv(1);

        if(sztype[0] == '0' && sztype[1] == 'x')
            sztype += 2;

        mstype = strtoul(sztype, &endptr, 16);
    }

    FGL_SetAAType(mstype);
}
#endif  // XBOX

#endif

/*
===================
VID_Init
===================
*/
void	VID_Init (unsigned char *palette)
{
	int		i, existingmode;
	int		basenummodes, width, height, bpp, findbpp, done;
	byte	*ptmp;

	Cvar_RegisterVariable (&vid_mode);
	Cvar_RegisterVariable (&vid_wait);
	Cvar_RegisterVariable (&vid_nopageflip);
	Cvar_RegisterVariable (&_vid_wait_override);
	Cvar_RegisterVariable (&_vid_default_mode);
	Cvar_RegisterVariable (&_vid_default_mode_win);
	Cvar_RegisterVariable (&vid_config_x);
	Cvar_RegisterVariable (&vid_config_y);
	Cvar_RegisterVariable (&vid_stretch_by_2);
	Cvar_RegisterVariable (&gl_ztrick);

	Cmd_AddCommand ("vid_nummodes", VID_NumModes_f);
	Cmd_AddCommand ("vid_describecurrentmode", VID_DescribeCurrentMode_f);
	Cmd_AddCommand ("vid_describemode", VID_DescribeMode_f);
	Cmd_AddCommand ("vid_describemodes", VID_DescribeModes_f);

	VID_InitDIB (global_hInstance);
	basenummodes = nummodes = 1;

	VID_InitFullDIB (global_hInstance);

#ifdef D3DQUAKE
	bpp = 16;
#endif

    width = 640;
	bpp = 15;
	findbpp = 1;

	done = 0;

    vid_default = 1;
    done = 1;

#if 0
	do
	{
		for (i=1, vid_default=0 ; i<nummodes ; i++)
		{
			if ((modelist[i].width == width) && (modelist[i].bpp == bpp))
			{
				vid_default = i;
				done = 1;
				break;
			}
		}

		if (!done)
		{
			if (findbpp)
			{
				switch (bpp)
				{
				case 15:
					bpp = 16;
					break;
				case 16:
					bpp = 32;
					break;
				case 32:
					bpp = 24;
					break;
				case 24:
					done = 1;
					break;
				}
			}
			else
			{
				done = 1;
			}
		}
	} while (!done);
#endif

	if (!vid_default)
	{
		Sys_Error ("Specified video mode not available");
	}

	vid_initialized = true;
	vid.conwidth = 640;

	vid.conwidth &= 0xfff8; // make it a multiple of eight

	if (vid.conwidth < 320)
		vid.conwidth = 320;

	// pick a conheight that matches with correct aspect
	vid.conheight = vid.conwidth*3 / 4;

	if (vid.conheight < 200)
		vid.conheight = 200;

	vid.maxwarpwidth = WARP_WIDTH;
	vid.maxwarpheight = WARP_HEIGHT;
	vid.colormap = host_colormap;
	vid.fullbright = 256 - LittleLong (*((int *)vid.colormap + 2048));

	Check_Gamma(palette);
	VID_SetPalette (palette);

	VID_SetMode (vid_default, palette);

#ifdef D3DQUAKE
	{
		int zbpp = bpp > 16 ? 24 : 16;
#ifdef _XBOX
		qboolean windowed = TRUE;
#else
		qboolean windowed = FALSE;
#endif
		d3dSetMode(windowed, modelist[0].width, modelist[0].height, bpp, zbpp);
	}
#else
	bSetupPixelFormat(maindc);
#endif

    baseRC = wglCreateContext( 0 );
	if (!baseRC)
		Sys_Error ("Could not initialize GL (wglCreateContext failed).\n\nMake sure you in are 65535 color mode, and try running -window.");
    if (!wglMakeCurrent( 0, baseRC ))
		Sys_Error ("wglMakeCurrent failed");

	GL_Init ();

	vid_realmode = vid_modenum;

	// Check for 3DFX Extensions and initialize them.
	VID_Init8bitPalette();

	vid_menudrawfn = VID_MenuDraw;
	vid_menukeyfn = VID_MenuKey;

	strcpy (badmode.modedesc, "Bad mode");
	vid_canalttab = true;

#ifdef _XBOX
     Cmd_AddCommand ("setaa", FGL_SetAAType_f);
#endif
}


//========================================================
// Video menu stuff
//========================================================

extern void M_Menu_Options_f (void);
extern void M_Print (int cx, int cy, char *str);
extern void M_PrintWhite (int cx, int cy, char *str);
extern void M_DrawCharacter (int cx, int line, int num);
extern void M_DrawTransPic (int x, int y, qpic_t *pic);
extern void M_DrawPic (int x, int y, qpic_t *pic);

static int	vid_line, vid_wmodes;

typedef struct
{
	int		modenum;
	char	*desc;
	int		iscur;
} modedesc_t;

#define MAX_COLUMN_SIZE		9
#define MODE_AREA_HEIGHT	(MAX_COLUMN_SIZE + 2)
#define MAX_MODEDESCS		(MAX_COLUMN_SIZE*3)

static modedesc_t	modedescs[MAX_MODEDESCS];

/*
================
VID_MenuDraw
================
*/
void VID_MenuDraw (void)
{
	qpic_t		*p;
	char		*ptr;
	int			lnummodes, i, j, k, column, row, dup, dupmode;
	char		temp[100];
	vmode_t		*pv;

	p = Draw_CachePic ("gfx/vidmodes.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	vid_wmodes = 0;
	lnummodes = VID_NumModes ();
	
	for (i=1 ; (i<lnummodes) && (vid_wmodes < MAX_MODEDESCS) ; i++)
	{
		ptr = VID_GetModeDescription (i);
		pv = VID_GetModePtr (i);

		k = vid_wmodes;

		modedescs[k].modenum = i;
		modedescs[k].desc = ptr;
		modedescs[k].iscur = 0;

		if (i == vid_modenum)
			modedescs[k].iscur = 1;

		vid_wmodes++;

	}

	if (vid_wmodes > 0)
	{
		M_Print (2*8, 36+0*8, "Fullscreen Modes (WIDTHxHEIGHTxBPP)");

		column = 8;
		row = 36+2*8;

		for (i=0 ; i<vid_wmodes ; i++)
		{
			if (modedescs[i].iscur)
				M_PrintWhite (column, row, modedescs[i].desc);
			else
				M_Print (column, row, modedescs[i].desc);

			column += 13*8;

			if ((i % VID_ROW_SIZE) == (VID_ROW_SIZE - 1))
			{
				column = 8;
				row += 8;
			}
		}
	}

	M_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*2,
			 "Video modes must be set from the");
	M_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*3,
			 "command line with -width <width>");
	M_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*4,
			 "and -bpp <bits-per-pixel>");
	M_Print (3*8, 36 + MODE_AREA_HEIGHT * 8 + 8*6,
			 "Select windowed mode with -window");
}


/*
================
VID_MenuKey
================
*/
void VID_MenuKey (int key)
{
	switch (key)
	{
	case K_ESCAPE:
		S_LocalSound ("misc/menu1.wav");
		M_Menu_Options_f ();
		break;

	default:
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\menu.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

//
// the net drivers should just set the apropriate bits in m_activenet,
// instead of having the menu code look through their internal tables
//
#define	MNET_IPX		1
#define	MNET_TCP		2

extern	int	m_activenet;

//
// menus
//
void M_Init (void);
void M_Keydown (int key);
void M_Draw (void);
void M_ToggleMenu_f (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\in_win.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// in_win.c -- windows 95 mouse and joystick code
// 02/21/97 JCB Added extended DirectInput code to support external controllers.

#if !defined(XBOX)

#include <dinput.h>
#include "quakedef.h"
#include "xquake.h"
#include "dosisms.h"

#define DINPUT_BUFFERSIZE           16
#define iDirectInputCreate(a,b,c,d)	pDirectInputCreate(a,b,c,d)

HRESULT (WINAPI *pDirectInputCreate)(HINSTANCE hinst, DWORD dwVersion,
	LPDIRECTINPUT * lplpDirectInput, LPUNKNOWN punkOuter);

// mouse variables
cvar_t	m_filter = {"m_filter","0"};

int			mouse_buttons;
int			mouse_oldbuttonstate;
POINT		current_pos;
int			mouse_x, mouse_y, old_mouse_x, old_mouse_y, mx_accum, my_accum;

static qboolean	restore_spi;
static int		originalmouseparms[3], newmouseparms[3] = {0, 0, 1};

unsigned int uiWheelMessage;
qboolean	mouseactive;
qboolean		mouseinitialized;
static qboolean	mouseparmsvalid, mouseactivatetoggle;
static qboolean	mouseshowtoggle = 1;
static qboolean	dinput_acquired;

static unsigned int		mstate_di;

// joystick defines and variables
// where should defines be moved?
#define JOY_ABSOLUTE_AXIS	0x00000000		// control like a joystick
#define JOY_RELATIVE_AXIS	0x00000010		// control like a mouse, spinner, trackball
#define	JOY_MAX_AXES		6				// X, Y, Z, R, U, V
#define JOY_AXIS_X			0
#define JOY_AXIS_Y			1
#define JOY_AXIS_Z			2
#define JOY_AXIS_R			3
#define JOY_AXIS_U			4
#define JOY_AXIS_V			5

enum _ControlList
{
	AxisNada = 0, AxisForward, AxisLook, AxisSide, AxisTurn
};

DWORD	dwAxisFlags[JOY_MAX_AXES] =
{
	JOY_RETURNX, JOY_RETURNY, JOY_RETURNZ, JOY_RETURNR, JOY_RETURNU, JOY_RETURNV
};

DWORD	dwAxisMap[JOY_MAX_AXES];
DWORD	dwControlMap[JOY_MAX_AXES];
PDWORD	pdwRawValue[JOY_MAX_AXES];

// none of these cvars are saved over a session
// this means that advanced controller configuration needs to be executed
// each time.  this avoids any problems with getting back to a default usage
// or when changing from one controller to another.  this way at least something
// works.
cvar_t	in_joystick = {"joystick","0", true};
cvar_t	joy_name = {"joyname", "joystick"};
cvar_t	joy_advanced = {"joyadvanced", "0"};
cvar_t	joy_advaxisx = {"joyadvaxisx", "0"};
cvar_t	joy_advaxisy = {"joyadvaxisy", "0"};
cvar_t	joy_advaxisz = {"joyadvaxisz", "0"};
cvar_t	joy_advaxisr = {"joyadvaxisr", "0"};
cvar_t	joy_advaxisu = {"joyadvaxisu", "0"};
cvar_t	joy_advaxisv = {"joyadvaxisv", "0"};
cvar_t	joy_forwardthreshold = {"joyforwardthreshold", "0.15"};
cvar_t	joy_sidethreshold = {"joysidethreshold", "0.15"};
cvar_t	joy_pitchthreshold = {"joypitchthreshold", "0.15"};
cvar_t	joy_yawthreshold = {"joyyawthreshold", "0.15"};
cvar_t	joy_forwardsensitivity = {"joyforwardsensitivity", "-1.0"};
cvar_t	joy_sidesensitivity = {"joysidesensitivity", "-1.0"};
cvar_t	joy_pitchsensitivity = {"joypitchsensitivity", "1.0"};
cvar_t	joy_yawsensitivity = {"joyyawsensitivity", "-1.0"};
cvar_t	joy_wwhack1 = {"joywwhack1", "0.0"};
cvar_t	joy_wwhack2 = {"joywwhack2", "0.0"};

qboolean	joy_avail, joy_advancedinit, joy_haspov;
DWORD		joy_oldbuttonstate, joy_oldpovstate;

int			joy_id;
DWORD		joy_flags;
DWORD		joy_numbuttons;

static LPDIRECTINPUT		g_pdi;
static LPDIRECTINPUTDEVICE	g_pMouse;

static JOYINFOEX	ji;

static HINSTANCE hInstDI;

static qboolean	dinput;

typedef struct MYDATA {
	LONG  lX;                   // X axis goes here
	LONG  lY;                   // Y axis goes here
	LONG  lZ;                   // Z axis goes here
	BYTE  bButtonA;             // One button goes here
	BYTE  bButtonB;             // Another button goes here
	BYTE  bButtonC;             // Another button goes here
	BYTE  bButtonD;             // Another button goes here
} MYDATA;

static DIOBJECTDATAFORMAT rgodf[] = {
  { &GUID_XAxis,    FIELD_OFFSET(MYDATA, lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
  { &GUID_YAxis,    FIELD_OFFSET(MYDATA, lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
  { &GUID_ZAxis,    FIELD_OFFSET(MYDATA, lZ),       0x80000000 | DIDFT_AXIS | DIDFT_ANYINSTANCE,   0,},
  { 0,              FIELD_OFFSET(MYDATA, bButtonA), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
  { 0,              FIELD_OFFSET(MYDATA, bButtonB), DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
  { 0,              FIELD_OFFSET(MYDATA, bButtonC), 0x80000000 | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
  { 0,              FIELD_OFFSET(MYDATA, bButtonD), 0x80000000 | DIDFT_BUTTON | DIDFT_ANYINSTANCE, 0,},
};

#define NUM_OBJECTS (sizeof(rgodf) / sizeof(rgodf[0]))

static DIDATAFORMAT	df = {
	sizeof(DIDATAFORMAT),       // this structure
	sizeof(DIOBJECTDATAFORMAT), // size of object data format
	DIDF_RELAXIS,               // absolute axis coordinates
	sizeof(MYDATA),             // device data size
	NUM_OBJECTS,                // number of objects
	rgodf,                      // and here they are
};

// forward-referenced functions
void IN_StartupJoystick (void);
void Joy_AdvancedUpdate_f (void);
void IN_JoyMove (usercmd_t *cmd);


/*
===========
Force_CenterView_f
===========
*/
void Force_CenterView_f (void)
{
	cl.viewangles[PITCH] = 0;
}


/*
===========
IN_UpdateClipCursor
===========
*/
void IN_UpdateClipCursor (void)
{

	if (mouseinitialized && mouseactive && !dinput)
	{
		ClipCursor (&window_rect);
	}
}


/*
===========
IN_ShowMouse
===========
*/
void IN_ShowMouse (void)
{

	if (!mouseshowtoggle)
	{
		ShowCursor (TRUE);
		mouseshowtoggle = 1;
	}
}


/*
===========
IN_HideMouse
===========
*/
void IN_HideMouse (void)
{

	if (mouseshowtoggle)
	{
		ShowCursor (FALSE);
		mouseshowtoggle = 0;
	}
}


/*
===========
IN_ActivateMouse
===========
*/
void IN_ActivateMouse (void)
{

	mouseactivatetoggle = true;

	if (mouseinitialized)
	{
		if (dinput)
		{
			if (g_pMouse)
			{
				if (!dinput_acquired)
				{
					IDirectInputDevice_Acquire(g_pMouse);
					dinput_acquired = true;
				}
			}
			else
			{
				return;
			}
		}
		else
		{
			if (mouseparmsvalid)
				restore_spi = SystemParametersInfo (SPI_SETMOUSE, 0, newmouseparms, 0);

			SetCursorPos (window_center_x, window_center_y);
			SetCapture (mainwindow);
			ClipCursor (&window_rect);
		}

		mouseactive = true;
	}
}


/*
===========
IN_SetQuakeMouseState
===========
*/
void IN_SetQuakeMouseState (void)
{
	if (mouseactivatetoggle)
		IN_ActivateMouse ();
}


/*
===========
IN_DeactivateMouse
===========
*/
void IN_DeactivateMouse (void)
{

	mouseactivatetoggle = false;

	if (mouseinitialized)
	{
		if (dinput)
		{
			if (g_pMouse)
			{
				if (dinput_acquired)
				{
					IDirectInputDevice_Unacquire(g_pMouse);
					dinput_acquired = false;
				}
			}
		}
		else
		{
			if (restore_spi)
				SystemParametersInfo (SPI_SETMOUSE, 0, originalmouseparms, 0);

			ClipCursor (NULL);
			ReleaseCapture ();
		}

		mouseactive = false;
	}
}


/*
===========
IN_RestoreOriginalMouseState
===========
*/
void IN_RestoreOriginalMouseState (void)
{
	if (mouseactivatetoggle)
	{
		IN_DeactivateMouse ();
		mouseactivatetoggle = true;
	}

// try to redraw the cursor so it gets reinitialized, because sometimes it
// has garbage after the mode switch
	ShowCursor (TRUE);
	ShowCursor (FALSE);
}


/*
===========
IN_InitDInput
===========
*/
qboolean IN_InitDInput (void)
{
    HRESULT		hr;
	DIPROPDWORD	dipdw = {
		{
			sizeof(DIPROPDWORD),        // diph.dwSize
			sizeof(DIPROPHEADER),       // diph.dwHeaderSize
			0,                          // diph.dwObj
			DIPH_DEVICE,                // diph.dwHow
		},
		DINPUT_BUFFERSIZE,              // dwData
	};

	if (!hInstDI)
	{
		hInstDI = LoadLibrary(TEXT("dinput.dll"));
		
		if (hInstDI == NULL)
		{
			Con_SafePrintf ("Couldn't load dinput.dll\n");
			return false;
		}
	}

	if (!pDirectInputCreate)
	{
		pDirectInputCreate = (void *)GetProcAddress(hInstDI,"DirectInputCreateA");

		if (!pDirectInputCreate)
		{
			Con_SafePrintf ("Couldn't get DI proc addr\n");
			return false;
		}
	}

// register with DirectInput and get an IDirectInput to play with.
	hr = iDirectInputCreate(global_hInstance, DIRECTINPUT_VERSION, &g_pdi, NULL);

	if (FAILED(hr))
	{
		return false;
	}

// obtain an interface to the system mouse device.
	hr = IDirectInput_CreateDevice(g_pdi, &GUID_SysMouse, &g_pMouse, NULL);

	if (FAILED(hr))
	{
		Con_SafePrintf ("Couldn't open DI mouse device\n");
		return false;
	}

// set the data format to "mouse format".
	hr = IDirectInputDevice_SetDataFormat(g_pMouse, &df);

	if (FAILED(hr))
	{
		Con_SafePrintf ("Couldn't set DI mouse format\n");
		return false;
	}

// set the cooperativity level.
	hr = IDirectInputDevice_SetCooperativeLevel(g_pMouse, mainwindow,
			DISCL_EXCLUSIVE | DISCL_FOREGROUND);

	if (FAILED(hr))
	{
		Con_SafePrintf ("Couldn't set DI coop level\n");
		return false;
	}


// set the buffer size to DINPUT_BUFFERSIZE elements.
// the buffer size is a DWORD property associated with the device
	hr = IDirectInputDevice_SetProperty(g_pMouse, DIPROP_BUFFERSIZE, &dipdw.diph);

	if (FAILED(hr))
	{
		Con_SafePrintf ("Couldn't set DI buffersize\n");
		return false;
	}

	return true;
}


/*
===========
IN_StartupMouse
===========
*/
void IN_StartupMouse (void)
{
	HDC			hdc;

	if ( COM_CheckParm ("-nomouse") ) 
		return; 

	mouseinitialized = true;

	if (COM_CheckParm ("-dinput"))
	{
		dinput = IN_InitDInput ();

		if (dinput)
		{
			Con_SafePrintf ("DirectInput initialized\n");
		}
		else
		{
			Con_SafePrintf ("DirectInput not initialized\n");
		}
	}

	if (!dinput)
	{
		mouseparmsvalid = SystemParametersInfo (SPI_GETMOUSE, 0, originalmouseparms, 0);

		if (mouseparmsvalid)
		{
			if ( COM_CheckParm ("-noforcemspd") ) 
				newmouseparms[2] = originalmouseparms[2];

			if ( COM_CheckParm ("-noforcemaccel") ) 
			{
				newmouseparms[0] = originalmouseparms[0];
				newmouseparms[1] = originalmouseparms[1];
			}

			if ( COM_CheckParm ("-noforcemparms") ) 
			{
				newmouseparms[0] = originalmouseparms[0];
				newmouseparms[1] = originalmouseparms[1];
				newmouseparms[2] = originalmouseparms[2];
			}
		}
	}

	mouse_buttons = 3;

// if a fullscreen video mode was set before the mouse was initialized,
// set the mouse state appropriately
	if (mouseactivatetoggle)
		IN_ActivateMouse ();
}


/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
	// mouse variables
	Cvar_RegisterVariable (&m_filter);

	// joystick variables
	Cvar_RegisterVariable (&in_joystick);
	Cvar_RegisterVariable (&joy_name);
	Cvar_RegisterVariable (&joy_advanced);
	Cvar_RegisterVariable (&joy_advaxisx);
	Cvar_RegisterVariable (&joy_advaxisy);
	Cvar_RegisterVariable (&joy_advaxisz);
	Cvar_RegisterVariable (&joy_advaxisr);
	Cvar_RegisterVariable (&joy_advaxisu);
	Cvar_RegisterVariable (&joy_advaxisv);
	Cvar_RegisterVariable (&joy_forwardthreshold);
	Cvar_RegisterVariable (&joy_sidethreshold);
	Cvar_RegisterVariable (&joy_pitchthreshold);
	Cvar_RegisterVariable (&joy_yawthreshold);
	Cvar_RegisterVariable (&joy_forwardsensitivity);
	Cvar_RegisterVariable (&joy_sidesensitivity);
	Cvar_RegisterVariable (&joy_pitchsensitivity);
	Cvar_RegisterVariable (&joy_yawsensitivity);
	Cvar_RegisterVariable (&joy_wwhack1);
	Cvar_RegisterVariable (&joy_wwhack2);

	Cmd_AddCommand ("force_centerview", Force_CenterView_f);
	Cmd_AddCommand ("joyadvancedupdate", Joy_AdvancedUpdate_f);

	uiWheelMessage = RegisterWindowMessage ( TEXT("MSWHEEL_ROLLMSG") );

	IN_StartupMouse ();
	IN_StartupJoystick ();
}

/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{

	IN_DeactivateMouse ();
	IN_ShowMouse ();

    if (g_pMouse)
	{
		IDirectInputDevice_Release(g_pMouse);
		g_pMouse = NULL;
	}

    if (g_pdi)
	{
		IDirectInput_Release(g_pdi);
		g_pdi = NULL;
	}
}


/*
===========
IN_MouseEvent
===========
*/
void IN_MouseEvent (int mstate)
{
	int	i;

	if (mouseactive && !dinput)
	{
	// perform button actions
		for (i=0 ; i<mouse_buttons ; i++)
		{
			if ( (mstate & (1<<i)) &&
				!(mouse_oldbuttonstate & (1<<i)) )
			{
				Key_Event (K_MOUSE1 + i, true);
			}

			if ( !(mstate & (1<<i)) &&
				(mouse_oldbuttonstate & (1<<i)) )
			{
				Key_Event (K_MOUSE1 + i, false);
			}
		}	
			
		mouse_oldbuttonstate = mstate;
	}
}


/*
===========
IN_MouseMove
===========
*/
void IN_MouseMove (usercmd_t *cmd)
{
	int					mx, my;
	HDC					hdc;
	int					i;
	DIDEVICEOBJECTDATA	od;
	DWORD				dwElements;
	HRESULT				hr;

	if (!mouseactive)
		return;

	if (dinput)
	{
		mx = 0;
		my = 0;

		for (;;)
		{
			dwElements = 1;

			hr = IDirectInputDevice_GetDeviceData(g_pMouse,
					sizeof(DIDEVICEOBJECTDATA), &od, &dwElements, 0);

			if ((hr == DIERR_INPUTLOST) || (hr == DIERR_NOTACQUIRED))
			{
				dinput_acquired = true;
				IDirectInputDevice_Acquire(g_pMouse);
				break;
			}

			/* Unable to read data or no data available */
			if (FAILED(hr) || dwElements == 0)
			{
				break;
			}

			/* Look at the element to see what happened */

			switch (od.dwOfs)
			{
				case DIMOFS_X:
					mx += od.dwData;
					break;

				case DIMOFS_Y:
					my += od.dwData;
					break;

				case DIMOFS_BUTTON0:
					if (od.dwData & 0x80)
						mstate_di |= 1;
					else
						mstate_di &= ~1;
					break;

				case DIMOFS_BUTTON1:
					if (od.dwData & 0x80)
						mstate_di |= (1<<1);
					else
						mstate_di &= ~(1<<1);
					break;
					
				case DIMOFS_BUTTON2:
					if (od.dwData & 0x80)
						mstate_di |= (1<<2);
					else
						mstate_di &= ~(1<<2);
					break;
			}
		}

	// perform button actions
		for (i=0 ; i<mouse_buttons ; i++)
		{
			if ( (mstate_di & (1<<i)) &&
				!(mouse_oldbuttonstate & (1<<i)) )
			{
				Key_Event (K_MOUSE1 + i, true);
			}

			if ( !(mstate_di & (1<<i)) &&
				(mouse_oldbuttonstate & (1<<i)) )
			{
				Key_Event (K_MOUSE1 + i, false);
			}
		}	
			
		mouse_oldbuttonstate = mstate_di;
	}
	else
	{
		GetCursorPos (&current_pos);
		mx = current_pos.x - window_center_x + mx_accum;
		my = current_pos.y - window_center_y + my_accum;
		mx_accum = 0;
		my_accum = 0;
	}

//if (mx ||  my)
//	Con_DPrintf("mx=%d, my=%d\n", mx, my);

	if (m_filter.value)
	{
		mouse_x = (mx + old_mouse_x) * 0.5;
		mouse_y = (my + old_mouse_y) * 0.5;
	}
	else
	{
		mouse_x = mx;
		mouse_y = my;
	}

	old_mouse_x = mx;
	old_mouse_y = my;

	mouse_x *= sensitivity.value;
	mouse_y *= sensitivity.value;

// add mouse X/Y movement to cmd
	if ( (in_strafe.state & 1) || (lookstrafe.value && (in_mlook.state & 1) ))
		cmd->sidemove += m_side.value * mouse_x;
	else
		cl.viewangles[YAW] -= m_yaw.value * mouse_x;

	if (in_mlook.state & 1)
		V_StopPitchDrift ();
		
	if ( (in_mlook.state & 1) && !(in_strafe.state & 1))
	{
		cl.viewangles[PITCH] += m_pitch.value * mouse_y;
		if (cl.viewangles[PITCH] > 80)
			cl.viewangles[PITCH] = 80;
		if (cl.viewangles[PITCH] < -70)
			cl.viewangles[PITCH] = -70;
	}
	else
	{
		if ((in_strafe.state & 1) && noclip_anglehack)
			cmd->upmove -= m_forward.value * mouse_y;
		else
			cmd->forwardmove -= m_forward.value * mouse_y;
	}

// if the mouse has moved, force it to the center, so there's room to move
	if (mx || my)
	{
		SetCursorPos (window_center_x, window_center_y);
	}
}


/*
===========
IN_Move
===========
*/
void IN_Move (usercmd_t *cmd)
{

	if (ActiveApp && !Minimized)
	{
		IN_MouseMove (cmd);
		IN_JoyMove (cmd);
	}
}


/*
===========
IN_Accumulate
===========
*/
void IN_Accumulate (void)
{
	int		mx, my;
	HDC	hdc;

	if (mouseactive)
	{
		if (!dinput)
		{
			GetCursorPos (&current_pos);

			mx_accum += current_pos.x - window_center_x;
			my_accum += current_pos.y - window_center_y;

		// force the mouse to the center, so there's room to move
			SetCursorPos (window_center_x, window_center_y);
		}
	}
}


/*
===================
IN_ClearStates
===================
*/
void IN_ClearStates (void)
{

	if (mouseactive)
	{
		mx_accum = 0;
		my_accum = 0;
		mouse_oldbuttonstate = 0;
	}
}


/* 
=============== 
IN_StartupJoystick 
=============== 
*/  
void IN_StartupJoystick (void) 
{ 
	int			i, numdevs;
	JOYCAPS		jc;
	MMRESULT	mmr;
 
 	// assume no joystick
	joy_avail = false; 

	// abort startup if user requests no joystick
	if ( COM_CheckParm ("-nojoy") ) 
		return; 
 
	// verify joystick driver is present
	if ((numdevs = joyGetNumDevs ()) == 0)
	{
		Con_Printf ("\njoystick not found -- driver not present\n\n");
		return;
	}

	// cycle through the joystick ids for the first valid one
	for (joy_id=0 ; joy_id<numdevs ; joy_id++)
	{
		memset (&ji, 0, sizeof(ji));
		ji.dwSize = sizeof(ji);
		ji.dwFlags = JOY_RETURNCENTERED;

		if ((mmr = joyGetPosEx (joy_id, &ji)) == JOYERR_NOERROR)
			break;
	} 

	// abort startup if we didn't find a valid joystick
	if (mmr != JOYERR_NOERROR)
	{
		Con_Printf ("\njoystick not found -- no valid joysticks (%x)\n\n", mmr);
		return;
	}

	// get the capabilities of the selected joystick
	// abort startup if command fails
	memset (&jc, 0, sizeof(jc));
	if ((mmr = joyGetDevCaps (joy_id, &jc, sizeof(jc))) != JOYERR_NOERROR)
	{
		Con_Printf ("\njoystick not found -- invalid joystick capabilities (%x)\n\n", mmr); 
		return;
	}

	// save the joystick's number of buttons and POV status
	joy_numbuttons = jc.wNumButtons;
	joy_haspov = jc.wCaps & JOYCAPS_HASPOV;

	// old button and POV states default to no buttons pressed
	joy_oldbuttonstate = joy_oldpovstate = 0;

	// mark the joystick as available and advanced initialization not completed
	// this is needed as cvars are not available during initialization

	joy_avail = true; 
	joy_advancedinit = false;

	Con_Printf ("\njoystick detected\n\n"); 
}


/*
===========
RawValuePointer
===========
*/
PDWORD RawValuePointer (int axis)
{
	switch (axis)
	{
	case JOY_AXIS_X:
		return &ji.dwXpos;
	case JOY_AXIS_Y:
		return &ji.dwYpos;
	case JOY_AXIS_Z:
		return &ji.dwZpos;
	case JOY_AXIS_R:
		return &ji.dwRpos;
	case JOY_AXIS_U:
		return &ji.dwUpos;
	case JOY_AXIS_V:
		return &ji.dwVpos;
	}
}


/*
===========
Joy_AdvancedUpdate_f
===========
*/
void Joy_AdvancedUpdate_f (void)
{

	// called once by IN_ReadJoystick and by user whenever an update is needed
	// cvars are now available
	int	i;
	DWORD dwTemp;

	// initialize all the maps
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		dwAxisMap[i] = AxisNada;
		dwControlMap[i] = JOY_ABSOLUTE_AXIS;
		pdwRawValue[i] = RawValuePointer(i);
	}

	if( joy_advanced.value == 0.0)
	{
		// default joystick initialization
		// 2 axes only with joystick control
		dwAxisMap[JOY_AXIS_X] = AxisTurn;
		// dwControlMap[JOY_AXIS_X] = JOY_ABSOLUTE_AXIS;
		dwAxisMap[JOY_AXIS_Y] = AxisForward;
		// dwControlMap[JOY_AXIS_Y] = JOY_ABSOLUTE_AXIS;
	}
	else
	{
		if (Q_strcmp (joy_name.string, "joystick") != 0)
		{
			// notify user of advanced controller
			Con_Printf ("\n%s configured\n\n", joy_name.string);
		}

		// advanced initialization here
		// data supplied by user via joy_axisn cvars
		dwTemp = (DWORD) joy_advaxisx.value;
		dwAxisMap[JOY_AXIS_X] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_X] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisy.value;
		dwAxisMap[JOY_AXIS_Y] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Y] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisz.value;
		dwAxisMap[JOY_AXIS_Z] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_Z] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisr.value;
		dwAxisMap[JOY_AXIS_R] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_R] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisu.value;
		dwAxisMap[JOY_AXIS_U] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_U] = dwTemp & JOY_RELATIVE_AXIS;
		dwTemp = (DWORD) joy_advaxisv.value;
		dwAxisMap[JOY_AXIS_V] = dwTemp & 0x0000000f;
		dwControlMap[JOY_AXIS_V] = dwTemp & JOY_RELATIVE_AXIS;
	}

	// compute the axes to collect from DirectInput
	joy_flags = JOY_RETURNCENTERED | JOY_RETURNBUTTONS | JOY_RETURNPOV;
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		if (dwAxisMap[i] != AxisNada)
		{
			joy_flags |= dwAxisFlags[i];
		}
	}
}


/*
===========
IN_Commands
===========
*/

int RemapToXBox[] = {
	    // Marking on Hammerhead controller
	K_GC_A,  // A
	K_GC_B,  // B
	K_GC_BLACK,  // C
	K_GC_X,  // D
	K_GC_Y,  // E
	K_GC_WHITE,  // F
	K_GC_LEFT_TRIGGER,  // Left Shoulder
	K_GC_RIGHT_TRIGGER,  // Right Sholder
	K_GC_LEFT_THUMB,  // Left Bottom
	K_GC_RIGHT_THUMB,  // Right Bottom
	K_GC_START, // Start
	K_GC_BACK  // Back
};

int hatMap[] = {
	K_GC_DPAD_UP, // up
	K_GC_DPAD_RIGHT, // right
	K_GC_DPAD_DOWN, // down
	K_GC_DPAD_LEFT  // left
};

void IN_Commands (void)
{
	int		i, key_index;
	DWORD	buttonstate, povstate;

	if (!joy_avail)
	{
		return;
	}

	
	// loop through the joystick buttons
	// key a joystick event or auxillary event for higher number buttons for each state change
	buttonstate = ji.dwButtons;
	for (i=0 ; i < joy_numbuttons ; i++)
	{
		if ( (buttonstate & (1<<i)) && !(joy_oldbuttonstate & (1<<i)) )
		{
#if 0
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			Key_Event (key_index + i, true);
#else
			Key_Event (RemapToXBox[i], true);
#endif
		}

		if ( !(buttonstate & (1<<i)) && (joy_oldbuttonstate & (1<<i)) )
		{
#if 0
			key_index = (i < 4) ? K_JOY1 : K_AUX1;
			Key_Event (key_index + i, false);
#else
			Key_Event (RemapToXBox[i], false);
#endif
		}
	}
	joy_oldbuttonstate = buttonstate;

	if (joy_haspov)
	{
		// convert POV information into 4 bits of state information
		// this avoids any potential problems related to moving from one
		// direction to another without going through the center position
		povstate = 0;
		if(ji.dwPOV != JOY_POVCENTERED)
		{
			if (ji.dwPOV == JOY_POVFORWARD)
				povstate |= 0x01;
			if (ji.dwPOV == JOY_POVRIGHT)
				povstate |= 0x02;
			if (ji.dwPOV == JOY_POVBACKWARD)
				povstate |= 0x04;
			if (ji.dwPOV == JOY_POVLEFT)
				povstate |= 0x08;
		}
		// determine which bits have changed and key an auxillary event for each change
		for (i=0 ; i < 4 ; i++)
		{
			if ( (povstate & (1<<i)) && !(joy_oldpovstate & (1<<i)) )
			{
#if 0
				Key_Event (K_AUX29 + i, true);
#else
				Key_Event (hatMap[i], true);
#endif
			}

			if ( !(povstate & (1<<i)) && (joy_oldpovstate & (1<<i)) )
			{
#if 0
				Key_Event (K_AUX29 + i, false);
#else
				Key_Event (hatMap[i], false);
#endif
			}
		}
		joy_oldpovstate = povstate;
	}
}


/* 
=============== 
IN_ReadJoystick
=============== 
*/  
qboolean IN_ReadJoystick (void)
{

	memset (&ji, 0, sizeof(ji));
	ji.dwSize = sizeof(ji);
	ji.dwFlags = joy_flags;

	if (joyGetPosEx (joy_id, &ji) == JOYERR_NOERROR)
	{
		// this is a hack -- there is a bug in the Logitech WingMan Warrior DirectInput Driver
		// rather than having 32768 be the zero point, they have the zero point at 32668
		// go figure -- anyway, now we get the full resolution out of the device
		if (joy_wwhack1.value != 0.0)
		{
			ji.dwUpos += 100;
		}
		return true;
	}
	else
	{
		// read error occurred
		// turning off the joystick seems too harsh for 1 read error,\
		// but what should be done?
		// Con_Printf ("IN_ReadJoystick: no response\n");
		// joy_avail = false;
		return false;
	}
}


/*
===========
IN_JoyMove
===========
*/
void IN_JoyMove (usercmd_t *cmd)
{
	float	speed, aspeed;
	float	fAxisValue, fTemp;
	int		i;

	// complete initialization if first time in
	// this is needed as cvars are not available at initialization time
	if( joy_advancedinit != true )
	{
		Joy_AdvancedUpdate_f();
		joy_advancedinit = true;
	}

	// verify joystick is available and that the user wants to use it
	if (!joy_avail || !in_joystick.value)
	{
		return; 
	}
 
	// collect the joystick data, if possible
	if (IN_ReadJoystick () != true)
	{
		return;
	}

	if (in_speed.state & 1)
		speed = cl_movespeedkey.value;
	else
		speed = 1;
	aspeed = speed * host_frametime;

	// loop through the axes
	for (i = 0; i < JOY_MAX_AXES; i++)
	{
		// get the floating point zero-centered, potentially-inverted data for the current axis
		fAxisValue = (float) *pdwRawValue[i];
		// move centerpoint to zero
		fAxisValue -= 32768.0;

		if (joy_wwhack2.value != 0.0)
		{
			if (dwAxisMap[i] == AxisTurn)
			{
				// this is a special formula for the Logitech WingMan Warrior
				// y=ax^b; where a = 300 and b = 1.3
				// also x values are in increments of 800 (so this is factored out)
				// then bounds check result to level out excessively high spin rates
				fTemp = 300.0 * pow(abs(fAxisValue) / 800.0, 1.3);
				if (fTemp > 14000.0)
					fTemp = 14000.0;
				// restore direction information
				fAxisValue = (fAxisValue > 0.0) ? fTemp : -fTemp;
			}
		}

		// convert range from -32768..32767 to -1..1 
		fAxisValue /= 32768.0;

		switch (dwAxisMap[i])
		{
		case AxisForward:
			if ((joy_advanced.value == 0.0) && (in_mlook.state & 1))
			{
				// user wants forward control to become look control
				if (fabs(fAxisValue) > joy_pitchthreshold.value)
				{		
					// if mouse invert is on, invert the joystick pitch value
					// only absolute control support here (joy_advanced is false)
					if (m_pitch.value < 0.0)
					{
						cl.viewangles[PITCH] -= (fAxisValue * joy_pitchsensitivity.value) * aspeed * cl_pitchspeed.value;
					}
					else
					{
						cl.viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity.value) * aspeed * cl_pitchspeed.value;
					}
					V_StopPitchDrift();
				}
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if(lookspring.value == 0.0)
						V_StopPitchDrift();
				}
			}
			else
			{
				// user wants forward control to be forward control
				if (fabs(fAxisValue) > joy_forwardthreshold.value)
				{
					cmd->forwardmove += (fAxisValue * joy_forwardsensitivity.value) * speed * cl_forwardspeed.value;
				}
			}
			break;

		case AxisSide:
			if (fabs(fAxisValue) > joy_sidethreshold.value)
			{
				cmd->sidemove += (fAxisValue * joy_sidesensitivity.value) * speed * cl_sidespeed.value;
			}
			break;

		case AxisTurn:
			if ((in_strafe.state & 1) || (lookstrafe.value && (in_mlook.state & 1)))
			{
				// user wants turn control to become side control
				if (fabs(fAxisValue) > joy_sidethreshold.value)
				{
					cmd->sidemove -= (fAxisValue * joy_sidesensitivity.value) * speed * cl_sidespeed.value;
				}
			}
			else
			{
				// user wants turn control to be turn control
				if (fabs(fAxisValue) > joy_yawthreshold.value)
				{
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						cl.viewangles[YAW] += (fAxisValue * joy_yawsensitivity.value) * aspeed * cl_yawspeed.value;
					}
					else
					{
						cl.viewangles[YAW] += (fAxisValue * joy_yawsensitivity.value) * speed * 180.0;
					}

				}
			}
			break;

		case AxisLook:
			if (in_mlook.state & 1)
			{
				if (fabs(fAxisValue) > joy_pitchthreshold.value)
				{
					// pitch movement detected and pitch movement desired by user
					if(dwControlMap[i] == JOY_ABSOLUTE_AXIS)
					{
						cl.viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity.value) * aspeed * cl_pitchspeed.value;
					}
					else
					{
						cl.viewangles[PITCH] += (fAxisValue * joy_pitchsensitivity.value) * speed * 180.0;
					}
					V_StopPitchDrift();
				}
				else
				{
					// no pitch movement
					// disable pitch return-to-center unless requested by user
					// *** this code can be removed when the lookspring bug is fixed
					// *** the bug always has the lookspring feature on
					if(lookspring.value == 0.0)
						V_StopPitchDrift();
				}
			}
			break;

		default:
			break;
		}
	}

	// bounds check pitch
	if (cl.viewangles[PITCH] > 80.0)
		cl.viewangles[PITCH] = 80.0;
	if (cl.viewangles[PITCH] < -70.0)
		cl.viewangles[PITCH] = -70.0;
}

#endif !defined(XBOX)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\mathlib.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// mathlib.c -- math primitives

#include <math.h>
#include "quakedef.h"

void Sys_Error (char *error, ...);

vec3_t vec3_origin = {0,0,0};
int nanmask = 255<<23;

/*-----------------------------------------------------------------*/

#define DEG2RAD( a ) ( a * M_PI ) / 180.0F

void ProjectPointOnPlane( vec3_t dst, const vec3_t p, const vec3_t normal )
{
	float d;
	vec3_t n;
	float inv_denom;

	inv_denom = 1.0F / DotProduct( normal, normal );

	d = DotProduct( normal, p ) * inv_denom;

	n[0] = normal[0] * inv_denom;
	n[1] = normal[1] * inv_denom;
	n[2] = normal[2] * inv_denom;

	dst[0] = p[0] - d * n[0];
	dst[1] = p[1] - d * n[1];
	dst[2] = p[2] - d * n[2];
}

/*
** assumes "src" is normalized
*/
void PerpendicularVector( vec3_t dst, const vec3_t src )
{
	int	pos;
	int i;
	float minelem = 1.0F;
	vec3_t tempvec;

	/*
	** find the smallest magnitude axially aligned vector
	*/
	for ( pos = 0, i = 0; i < 3; i++ )
	{
		if ( fabs( src[i] ) < minelem )
		{
			pos = i;
			minelem = fabs( src[i] );
		}
	}
	tempvec[0] = tempvec[1] = tempvec[2] = 0.0F;
	tempvec[pos] = 1.0F;

	/*
	** project the point onto the plane defined by src
	*/
	ProjectPointOnPlane( dst, tempvec, src );

	/*
	** normalize the result
	*/
	VectorNormalize( dst );
}

#ifdef _WIN32
#pragma optimize( "", off )
#endif


void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees )
{
	float	m[3][3];
	float	im[3][3];
	float	zrot[3][3];
	float	tmpmat[3][3];
	float	rot[3][3];
	int	i;
	vec3_t vr, vup, vf;

	vf[0] = dir[0];
	vf[1] = dir[1];
	vf[2] = dir[2];

	PerpendicularVector( vr, dir );
	CrossProduct( vr, vf, vup );

	m[0][0] = vr[0];
	m[1][0] = vr[1];
	m[2][0] = vr[2];

	m[0][1] = vup[0];
	m[1][1] = vup[1];
	m[2][1] = vup[2];

	m[0][2] = vf[0];
	m[1][2] = vf[1];
	m[2][2] = vf[2];

	memcpy( im, m, sizeof( im ) );

	im[0][1] = m[1][0];
	im[0][2] = m[2][0];
	im[1][0] = m[0][1];
	im[1][2] = m[2][1];
	im[2][0] = m[0][2];
	im[2][1] = m[1][2];

	memset( zrot, 0, sizeof( zrot ) );
	zrot[0][0] = zrot[1][1] = zrot[2][2] = 1.0F;

	zrot[0][0] = cos( DEG2RAD( degrees ) );
	zrot[0][1] = sin( DEG2RAD( degrees ) );
	zrot[1][0] = -sin( DEG2RAD( degrees ) );
	zrot[1][1] = cos( DEG2RAD( degrees ) );

	R_ConcatRotations( m, zrot, tmpmat );
	R_ConcatRotations( tmpmat, im, rot );

	for ( i = 0; i < 3; i++ )
	{
		dst[i] = rot[i][0] * point[0] + rot[i][1] * point[1] + rot[i][2] * point[2];
	}
}

#ifdef _WIN32
#pragma optimize( "", on )
#endif

/*-----------------------------------------------------------------*/


float	anglemod(float a)
{
#if 0
	if (a >= 0)
		a -= 360*(int)(a/360);
	else
		a += 360*( 1 + (int)(-a/360) );
#endif
	a = (360.0/65536) * ((int)(a*(65536/360.0)) & 65535);
	return a;
}

/*
==================
BOPS_Error

Split out like this for ASM to call.
==================
*/
void BOPS_Error (void)
{
	Sys_Error ("BoxOnPlaneSide:  Bad signbits");
}


#if	!id386

/*
==================
BoxOnPlaneSide

Returns 1, 2, or 1 + 2
==================
*/
int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, mplane_t *p)
{
	float	dist1, dist2;
	int		sides;

#if 0	// this is done by the BOX_ON_PLANE_SIDE macro before calling this
		// function
// fast axial cases
	if (p->type < 3)
	{
		if (p->dist <= emins[p->type])
			return 1;
		if (p->dist >= emaxs[p->type])
			return 2;
		return 3;
	}
#endif
	
// general case
	switch (p->signbits)
	{
	case 0:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
		break;
	case 1:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
		break;
	case 2:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
		break;
	case 3:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
		break;
	case 4:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
		break;
	case 5:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emaxs[2];
		break;
	case 6:
dist1 = p->normal[0]*emaxs[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emins[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
		break;
	case 7:
dist1 = p->normal[0]*emins[0] + p->normal[1]*emins[1] + p->normal[2]*emins[2];
dist2 = p->normal[0]*emaxs[0] + p->normal[1]*emaxs[1] + p->normal[2]*emaxs[2];
		break;
	default:
		dist1 = dist2 = 0;		// shut up compiler
		BOPS_Error ();
		break;
	}

#if 0
	int		i;
	vec3_t	corners[2];

	for (i=0 ; i<3 ; i++)
	{
		if (plane->normal[i] < 0)
		{
			corners[0][i] = emins[i];
			corners[1][i] = emaxs[i];
		}
		else
		{
			corners[1][i] = emins[i];
			corners[0][i] = emaxs[i];
		}
	}
	dist = DotProduct (plane->normal, corners[0]) - plane->dist;
	dist2 = DotProduct (plane->normal, corners[1]) - plane->dist;
	sides = 0;
	if (dist1 >= 0)
		sides = 1;
	if (dist2 < 0)
		sides |= 2;

#endif

	sides = 0;
	if (dist1 >= p->dist)
		sides = 1;
	if (dist2 < p->dist)
		sides |= 2;

#ifdef PARANOID
if (sides == 0)
	Sys_Error ("BoxOnPlaneSide: sides==0");
#endif

	return sides;
}

#endif


void AngleVectors (vec3_t angles, vec3_t forward, vec3_t right, vec3_t up)
{
	float		angle;
	float		sr, sp, sy, cr, cp, cy;
	
	angle = angles[YAW] * (M_PI*2 / 360);
	sy = sin(angle);
	cy = cos(angle);
	angle = angles[PITCH] * (M_PI*2 / 360);
	sp = sin(angle);
	cp = cos(angle);
	angle = angles[ROLL] * (M_PI*2 / 360);
	sr = sin(angle);
	cr = cos(angle);

	forward[0] = cp*cy;
	forward[1] = cp*sy;
	forward[2] = -sp;
	right[0] = (-1*sr*sp*cy+-1*cr*-sy);
	right[1] = (-1*sr*sp*sy+-1*cr*cy);
	right[2] = -1*sr*cp;
	up[0] = (cr*sp*cy+-sr*-sy);
	up[1] = (cr*sp*sy+-sr*cy);
	up[2] = cr*cp;
}

int VectorCompare (vec3_t v1, vec3_t v2)
{
	int		i;
	
	for (i=0 ; i<3 ; i++)
		if (v1[i] != v2[i])
			return 0;
			
	return 1;
}

void VectorMA (vec3_t veca, float scale, vec3_t vecb, vec3_t vecc)
{
	vecc[0] = veca[0] + scale*vecb[0];
	vecc[1] = veca[1] + scale*vecb[1];
	vecc[2] = veca[2] + scale*vecb[2];
}


vec_t _DotProduct (vec3_t v1, vec3_t v2)
{
	return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out)
{
	out[0] = veca[0]-vecb[0];
	out[1] = veca[1]-vecb[1];
	out[2] = veca[2]-vecb[2];
}

void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out)
{
	out[0] = veca[0]+vecb[0];
	out[1] = veca[1]+vecb[1];
	out[2] = veca[2]+vecb[2];
}

void _VectorCopy (vec3_t in, vec3_t out)
{
	out[0] = in[0];
	out[1] = in[1];
	out[2] = in[2];
}

void CrossProduct (vec3_t v1, vec3_t v2, vec3_t cross)
{
	cross[0] = v1[1]*v2[2] - v1[2]*v2[1];
	cross[1] = v1[2]*v2[0] - v1[0]*v2[2];
	cross[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

/* already defined in math.h -- double sqrt(double x); */

vec_t Length(vec3_t v)
{
	int		i;
	float	length;
	
	length = 0;
	for (i=0 ; i< 3 ; i++)
		length += v[i]*v[i];
	length = sqrt (length);		// FIXME

	return length;
}

float VectorNormalize (vec3_t v)
{
	float	length, ilength;

	length = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
	length = sqrt (length);		// FIXME

	if (length)
	{
		ilength = 1/length;
		v[0] *= ilength;
		v[1] *= ilength;
		v[2] *= ilength;
	}
		
	return length;

}

void VectorInverse (vec3_t v)
{
	v[0] = -v[0];
	v[1] = -v[1];
	v[2] = -v[2];
}

void VectorScale (vec3_t in, vec_t scale, vec3_t out)
{
	out[0] = in[0]*scale;
	out[1] = in[1]*scale;
	out[2] = in[2]*scale;
}


int Q_log2(int val)
{
	int answer=0;
	while (val>>=1)
		answer++;
	return answer;
}


/*
================
R_ConcatRotations
================
*/
void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
				in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
				in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
				in1[0][2] * in2[2][2];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
				in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
				in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
				in1[1][2] * in2[2][2];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
				in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
				in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
				in1[2][2] * in2[2][2];
}


/*
================
R_ConcatTransforms
================
*/
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4])
{
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
				in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
				in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
				in1[0][2] * in2[2][2];
	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
				in1[0][2] * in2[2][3] + in1[0][3];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
				in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
				in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
				in1[1][2] * in2[2][2];
	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
				in1[1][2] * in2[2][3] + in1[1][3];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
				in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
				in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
				in1[2][2] * in2[2][2];
	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
				in1[2][2] * in2[2][3] + in1[2][3];
}


/*
===================
FloorDivMod

Returns mathematically correct (floor-based) quotient and remainder for
numer and denom, both of which should contain no fractional part. The
quotient must fit in 32 bits.
====================
*/

void FloorDivMod (double numer, double denom, int *quotient,
		int *rem)
{
	int		q, r;
	double	x;

#ifndef PARANOID
	if (denom <= 0.0)
		Sys_Error ("FloorDivMod: bad denominator %d\n", denom);

//	if ((floor(numer) != numer) || (floor(denom) != denom))
//		Sys_Error ("FloorDivMod: non-integer numer or denom %f %f\n",
//				numer, denom);
#endif

	if (numer >= 0.0)
	{

		x = floor(numer / denom);
		q = (int)x;
		r = (int)floor(numer - (x * denom));
	}
	else
	{
	//
	// perform operations with positive values, and fix mod to make floor-based
	//
		x = floor(-numer / denom);
		q = -(int)x;
		r = (int)floor(-numer - (x * denom));
		if (r != 0)
		{
			q--;
			r = (int)denom - r;
		}
	}

	*quotient = q;
	*rem = r;
}


/*
===================
GreatestCommonDivisor
====================
*/
int GreatestCommonDivisor (int i1, int i2)
{
	if (i1 > i2)
	{
		if (i2 == 0)
			return (i1);
		return GreatestCommonDivisor (i2, i1 % i2);
	}
	else
	{
		if (i1 == 0)
			return (i2);
		return GreatestCommonDivisor (i1, i2 % i1);
	}
}


#if	!id386

// TODO: move to nonintel.c

/*
===================
Invert24To16

Inverts an 8.24 value to a 16.16 value
====================
*/

fixed16_t Invert24To16(fixed16_t val)
{
	if (val < 256)
		return (0xFFFFFFFF);

	return (fixed16_t)
			(((double)0x10000 * (double)0x1000000 / (double)val) + 0.5);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\keys.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

//
// these are the key numbers that should be passed to Key_Event
//
#define	K_TAB			9
#define	K_ENTER			13
#define	K_ESCAPE		27
#define	K_SPACE			32

// normal keys should be passed as lowercased ascii

#define	K_BACKSPACE		127
#define	K_UPARROW		128
#define	K_DOWNARROW		129
#define	K_LEFTARROW		130
#define	K_RIGHTARROW	131

#define	K_ALT			132
#define	K_CTRL			133
#define	K_SHIFT			134
#define	K_F1			135
#define	K_F2			136
#define	K_F3			137
#define	K_F4			138
#define	K_F5			139
#define	K_F6			140
#define	K_F7			141
#define	K_F8			142
#define	K_F9			143
#define	K_F10			144
#define	K_F11			145
#define	K_F12			146
#define	K_INS			147
#define	K_DEL			148
#define	K_PGDN			149
#define	K_PGUP			150
#define	K_HOME			151
#define	K_END			152

#define K_PAUSE			255

//
// mouse buttons generate virtual keys
//
#define	K_MOUSE1		200
#define	K_MOUSE2		201
#define	K_MOUSE3		202

//
// joystick buttons
//
#define	K_JOY1			203
#define	K_JOY2			204
#define	K_JOY3			205
#define	K_JOY4			206

//
// aux keys are for multi-buttoned joysticks to generate so they can use
// the normal binding process
//

#define	K_AUX1			207
#define	K_AUX2			208
#define	K_AUX3			209


#define K_GC_BASE            210 //The first GC key
#define K_GC_DPAD_UP         210
#define K_GC_DPAD_DOWN       211
#define K_GC_DPAD_LEFT       212
#define K_GC_DPAD_RIGHT      213
#define K_GC_START           214
#define K_GC_BACK            215
#define K_GC_LEFT_THUMB      216
#define K_GC_RIGHT_THUMB     217
#define K_GC_A               218
#define K_GC_B               219
#define K_GC_X               220
#define K_GC_Y               221
#define K_GC_BLACK           222
#define K_GC_WHITE           223
#define K_GC_LEFT_TRIGGER    224
#define K_GC_RIGHT_TRIGGER   225



#define	K_AUX20			226
#define	K_AUX21			227
#define	K_AUX22			228
#define	K_AUX23			229
#define	K_AUX24			230
#define	K_AUX25			231
#define	K_AUX26			232
#define	K_AUX27			233
#define	K_AUX28			234
#define	K_AUX29			235
#define	K_AUX30			236
#define	K_AUX31			237
#define	K_AUX32			238

// JACK: Intellimouse(c) Mouse Wheel Support

#define K_MWHEELUP		239
#define K_MWHEELDOWN	240



typedef enum {key_game, key_console, key_message, key_menu} keydest_t;

extern keydest_t	key_dest;
extern char *keybindings[256];
extern	int		key_repeats[256];
extern	int		key_count;			// incremented every key event
extern	int		key_lastpress;

void Key_Event (int key, qboolean down);
void Key_Init (void);
void Key_WriteBindings (FILE *f);
void Key_SetBinding (int keynum, char *binding);
void Key_ClearStates (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\in_xbox.cpp ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// in_xbox.c -- xbox game controller code

#include <xtl.h>
#include <xbdm.h>
#include "quakedef.h"
#include "xquake.h"
#include "xgc.h"

CGameControllers *g_pGameControllers;
XINPUT_STATE      g_GameControllerState;
DWORD             g_dwGcCmdUp;
DWORD             g_dwGcCmdDown;
BOOL              g_fInitDone = FALSE;

extern "C"
{
cvar_t	gcforwardthreshold = {"gcforwardthreshold", "0.15"};
cvar_t	gcsidethreshold = {"gcsidethreshold", "0.15"};
cvar_t	gcpitchthreshold = {"gcpitchthreshold", "0.15"};
cvar_t	gcyawthreshold = {"gcyawthreshold", "0.15"};
cvar_t	gcbuttonthreshold = {"gcbuttonthreshold", "50"};
cvar_t	gcforwardsensitivity = {"gcforwardsensitivity", "1.0"};
cvar_t	gcsidesensitivity = {"gcsidesensitivity", "1.0"};
cvar_t	gcpitchsensitivity = {"gcpitchsensitivity", "1.0"};
cvar_t	gcyawsensitivity = {"gcyawsensitivity", "-1.0"};
cvar_t	gcswaphorizontalthumbs = {"gcswaphorizontalthumbs", "0"};
cvar_t	gcswapverticalthumbs = {"gcswapverticalthumbs", "0"};
}

/*
===========
IN_Init
===========
*/
void IN_Init (void)
{
    //Initialize core peripheral port support
    XInitDevices(0,NULL);

#ifdef DEBUG_KEYBOARD
    XINPUT_DEBUG_KEYQUEUE_PARAMETERS parameters;
    memset(&parameters,0,sizeof(parameters));
    parameters.dwFlags = XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN | XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT | XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP;
    parameters.dwQueueSize = 32;
    parameters.dwRepeatDelay = 400; // ms
    parameters.dwRepeatInterval = 150; // ms
    XInputDebugInitKeyboardQueue(&parameters);
#endif // DEBUG_KEYBOARD

    Cvar_RegisterVariable (&gcforwardthreshold);
	Cvar_RegisterVariable (&gcsidethreshold);
	Cvar_RegisterVariable (&gcpitchthreshold);
	Cvar_RegisterVariable (&gcyawthreshold);
    Cvar_RegisterVariable (&gcbuttonthreshold);
	Cvar_RegisterVariable (&gcforwardsensitivity);
	Cvar_RegisterVariable (&gcsidesensitivity);
	Cvar_RegisterVariable (&gcpitchsensitivity);
	Cvar_RegisterVariable (&gcyawsensitivity);
    Cvar_RegisterVariable (&gcswaphorizontalthumbs);
    Cvar_RegisterVariable (&gcswapverticalthumbs);
    g_dwGcCmdUp = 0;
    g_dwGcCmdDown = 0;
    memset(&g_GameControllerState, 0, sizeof(XINPUT_STATE));
    g_pGameControllers = new CGameControllers;

    g_fInitDone = TRUE;
}


/*
===========
IN_Shutdown
===========
*/
void IN_Shutdown (void)
{
    delete g_pGameControllers;
}

#ifdef DEBUG_KEYBOARD
byte        xvkToQuake[256] = {
//  0       1       2       3       4       5       6       7       8       9       A       B       C       D       E       F
    0,      0,      0,      0,      0,      0,      0,      0,      K_BACKSPACE, 0, 0,      0,      0,      13,     0,      0,   // 0    
    K_SHIFT,K_CTRL, K_ALT,  K_PAUSE,0,      0,      0,      0,      0,      0,      0,      27,     0,      0,      0,      0,   // 1    
    ' ',    K_PGDN, K_PGUP, K_END,  K_HOME, K_LEFTARROW,K_UPARROW,K_RIGHTARROW,K_DOWNARROW,0,0,0,   0,      K_INS,  K_DEL,  0,   // 2    
    '0',    '1',    '2',    '3',    '4',    '5',    '6',    '7',    '8',    '9',    0,      0,      0,      0,      0,      0,   // 3    
    0,      'a',    'b',    'c',    'd',    'e',    'f',    'g',    'h',    'i',    'j',    'k',    'l',    'm',    'n',    'o', // 4    
    'p',    'q',    'r',    's',    't',    'u',    'v',    'w',    'x',    'y',    'z',    0,      0,      0,      0,      0,   // 5    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // 6    
    K_F1,   K_F2,   K_F3,   K_F4,   K_F5,   K_F6,   K_F7,   K_F8,   K_F9,   K_F10,  K_F11,  K_F12,  0,      0,      0,      0,   // 7    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // 8    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // 9    
    K_SHIFT,K_SHIFT,0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // a    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      ';',    '=',    ',',    '-',    '.',    '/', // b    
    '`',    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // c    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      '[',    '\\',   ']',    '\'',   0,   // d    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,   // e    
    0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0,      0    // f  
};

/*
=======
MapKey

Map from Xbox to quake keynums
=======
*/
int MapKey (int key)
{
	if (key < 0 || key > 255)
		return 0;
	if (xvkToQuake[key] == 0)
		Con_DPrintf("key 0x%02x has no translation\n", key);
	return xvkToQuake[key];
}

#endif

/*
===========
IN_Move
===========
*/
void IN_Move (usercmd_t *cmd)
{
    XINPUT_STATE newState;

    //
    //  Read the game controller packet
    //  and make sure that it was received.
    //
    if(!g_fInitDone)
    {
        return;
    }

#ifdef DEBUG_KEYBOARD
    {
        XINPUT_DEBUG_KEYSTROKE keystroke;
        memset(&keystroke,0,sizeof(keystroke));
        XInputDebugGetKeystroke(&keystroke);
        if(keystroke.VirtualKey){
            Con_Printf ("Got keystroke virtualKey: 0x%08x flags: 0x%08x ascii: 0x%08x\n", keystroke.VirtualKey, keystroke.Flags, keystroke.Ascii);
            bool keyDown = ( keystroke.Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP ) != 0;
            Key_Event(MapKey(keystroke.VirtualKey), keyDown);
        }
    }
#endif // DEBUG_KEYBOARD

    if(FALSE == g_pGameControllers->GetState(&newState))
    {
        return;
    }

    //
    //  First process buttons up and buttons down.
    //  We would send these until IN_Commands
    //  but we will preprocess them here.
    //
    if(newState.dwPacketNumber != g_GameControllerState.dwPacketNumber)
    {
        //
        //  Mark keyup and keydown events for the first eight
        //  buttons (digital)
        //

        g_dwGcCmdDown = (newState.Gamepad.wButtons & ~g_GameControllerState.Gamepad.wButtons) & 0xFF;
        g_dwGcCmdUp = (~newState.Gamepad.wButtons & g_GameControllerState.Gamepad.wButtons) & 0xFF;

        for(int i=0; i<8; i++)
        {
           if(
               (newState.Gamepad.bAnalogButtons[i] > gcbuttonthreshold.value) &&
               (g_GameControllerState.Gamepad.bAnalogButtons[i] <= gcbuttonthreshold.value)
           ) {
                g_dwGcCmdDown |= ((0x100) << i);
           } else if (
               (newState.Gamepad.bAnalogButtons[i] <= gcbuttonthreshold.value) &&
               (g_GameControllerState.Gamepad.bAnalogButtons[i] > gcbuttonthreshold.value)
               )
           {
                g_dwGcCmdUp |= ((0x100) << i);
           }
        }

        //
        //  Now copy the new state over the existing one
        //
        memcpy(&g_GameControllerState, &newState, sizeof(XINPUT_STATE));
    }


    //
    //  Handle the axes now.
    //

    float rAxisValue, speed, aspeed;
    if (in_speed.state & 1)
		speed = cl_movespeedkey.value;
	else
		speed = 1;
	aspeed = speed * host_frametime;

    //
    //  Right Thumb X (is turn) - unless swap = 1
    //
    if(1.0==gcswaphorizontalthumbs.value)
    {
        rAxisValue = ((float)newState.Gamepad.sThumbLX) / 32768.0;
    } else
    {
        rAxisValue = ((float)newState.Gamepad.sThumbRX) / 32768.0;
    }
    if (fabs(rAxisValue) > gcyawthreshold.value)
	{
       cl.viewangles[YAW] += (rAxisValue * gcyawsensitivity.value) * aspeed * cl_yawspeed.value;
    }

    //
    //  Right Thumb Y (is look) - unless swap = 1
    //
    if(1.0==gcswapverticalthumbs.value)
    {
        rAxisValue = ((float)newState.Gamepad.sThumbLY) / 32768.0;
    } else
    {
        rAxisValue = ((float)newState.Gamepad.sThumbRY) / 32768.0;
    }
    if (fabs(rAxisValue) > gcpitchthreshold.value)
	{
	    cl.viewangles[PITCH] += (rAxisValue * gcpitchsensitivity.value) * aspeed * cl_pitchspeed.value;
	    V_StopPitchDrift();
    } else
    {
	    if(lookspring.value == 0.0) V_StopPitchDrift();
	}

    // bounds check pitch
	if (cl.viewangles[PITCH] > 80.0)
		cl.viewangles[PITCH] = 80.0;
	if (cl.viewangles[PITCH] < -70.0)
		cl.viewangles[PITCH] = -70.0;

    //
    //  Left Thumb X (is side-to-side - strafe) - unless swap = 1
    //
    if(1.0==gcswaphorizontalthumbs.value)
    {
        rAxisValue = ((float)newState.Gamepad.sThumbRX) / 32768.0;
    } else
    {
        rAxisValue = ((float)newState.Gamepad.sThumbLX) / 32768.0;
    }
    if (fabs(rAxisValue) > gcsidethreshold.value)
    {
        cmd->sidemove += (rAxisValue * gcsidesensitivity.value) * speed * cl_sidespeed.value;
    }

    //
    //  Right Thumb Y (is forward-back) - unless swap = 1
    //
    if(1.0==gcswapverticalthumbs.value)
    {
        rAxisValue = ((float)newState.Gamepad.sThumbRY) / 32768.0;
    } else
    {
        rAxisValue = ((float)newState.Gamepad.sThumbLY) / 32768.0;
    }
    if (fabs(rAxisValue) > gcforwardthreshold.value)
    {
        cmd->forwardmove += (rAxisValue * gcforwardsensitivity.value) * speed * cl_forwardspeed.value;
    }
}


/*
===================
IN_ClearStates
===================
*/
void IN_ClearStates (void)
{
    memset(&g_GameControllerState, 0, sizeof(XINPUT_STATE));
    g_dwGcCmdUp = 0;
    g_dwGcCmdDown = 0;
}

#ifdef _XBOX
bool RXCmdHandleRCmds();
#endif

/*
===========
IN_Commands
===========
*/
void IN_Commands (void)
{
	if(!g_fInitDone)
    {
        return;
    }
    //
    //  Send key events for all of the buttons
    //
    for(int i=0; i < 16; i++)
    {
        if(g_dwGcCmdUp & (1 << i))
        {
            Key_Event (K_GC_BASE+i, false);
        } else if(g_dwGcCmdDown & (1 << i))
        {
            Key_Event (K_GC_BASE+i, true);
        }
    }

    RXCmdHandleRCmds();
}

#ifdef _XBOX

// our critical section
bool g_fcsRxcmdInited = false;
CRITICAL_SECTION g_csRxcmd;

// command prefix
static const char g_szCmd[] = "x";

// processorproc buffer
#define CCH_MAXCMDLEN       256
static char g_szRemoteBuf[CCH_MAXCMDLEN];

//=========================================================================
// Name: RXCmdPRocessorProc
// Desc: Cmd notification proc
//
//  This is what is called by the Xbox debug monitor to have us process
//  a command.
//=========================================================================
HRESULT __stdcall RXCmdProcessorProc(LPCSTR szCommand, LPSTR szResp,
    DWORD cchResp, PDM_CMDCONT pdmcc)
{
    // skip over prefix
    char *szCmd = (char *)szCommand + lstrlenA(g_szCmd) + 1;

    // g_szRemoteBuf needs to be protected by the critical section
    EnterCriticalSection(&g_csRxcmd);

    if(g_szRemoteBuf[0])
        Q_strncpy(szResp, "Cannot execute - previous command still pending", cchResp);
    else
    {
        Q_strncpy(szResp, "Ack.", cchResp);
        Q_strncpy(g_szRemoteBuf, szCmd, sizeof(g_szRemoteBuf) / sizeof(g_szRemoteBuf[0]));
    }

    LeaveCriticalSection(&g_csRxcmd);
    return XBDM_NOERR;
}

//=========================================================================
// Name: RXCmdHandleRCmds
// Desc: Poll routine called by app
//
//  The application should call this function periodically, usually every
//  frame.  This will check to see if there is a command waiting to be
//  executed, and if so, execute it.
//=========================================================================
bool RXCmdHandleRCmds()
{
    static BOOL fRegistered = false;
    char        cmd[CCH_MAXCMDLEN];

    // Initialize ourselves when we're first called.
    if(!fRegistered)
    {
        // init our critical section
        if(!g_fcsRxcmdInited)
        {
            InitializeCriticalSection(&g_csRxcmd);
            g_fcsRxcmdInited = true;
        }

        // register our command handler with the debug monitor
        HRESULT hr = DmRegisterCommandProcessor(g_szCmd, RXCmdProcessorProc);
        if(FAILED(hr))
            return false;

        fRegistered = true;
    }

    // If there's nothing waiting, return.
    if(!g_szRemoteBuf[0])
        return false;

    //
    // Grab a copy of the command to free up
    // the critical section
    //
    EnterCriticalSection(&g_csRxcmd);

    lstrcpyA(cmd, g_szRemoteBuf);
    g_szRemoteBuf[0] = 0;

    LeaveCriticalSection(&g_csRxcmd);

    // go through and handle all backspace characters (0x8)
    int ichcur = 0;
    for(int ich = 0; cmd[ich]; ich++)
    {
        if(cmd[ich] == 0x8)
        {
            if(ichcur)
                ichcur--;
        }
        else
        {
            cmd[ichcur++] = cmd[ich];
        }
    }
    cmd[ichcur] = 0;

    if(cmd[0] == 0x3)
    {
        // if prefixed by the ctrl+c character then send as key events
        for(int ich = 1; cmd[ich]; ich++)
        {
            Key_Event(cmd[ich], true);
            Key_Event(cmd[ich], false);
        }
    }
    else
    {
        Con_Printf("%s\n", cmd);
        Cbuf_AddText(cmd);
    }
    return true;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\menu.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "quakedef.h"

#ifdef _WIN32
#include "xquake.h"
#endif

void (*vid_menudrawfn)(void);
void (*vid_menukeyfn)(int key);

enum {m_none, m_main, m_singleplayer, m_load, m_save, m_multiplayer, m_setup, m_net, m_options, m_video, m_keys, m_help, m_quit, m_serialconfig, m_modemconfig, m_lanconfig, m_gameoptions, m_search, m_slist} m_state;

void M_Menu_Main_f (void);
	void M_Menu_SinglePlayer_f (void);
		void M_Menu_Load_f (void);
		void M_Menu_Save_f (void);
	void M_Menu_MultiPlayer_f (void);
		void M_Menu_Setup_f (void);
		void M_Menu_Net_f (void);
	void M_Menu_Options_f (void);
		void M_Menu_Keys_f (void);
		void M_Menu_Video_f (void);
	void M_Menu_Help_f (void);
	void M_Menu_Quit_f (void);
void M_Menu_SerialConfig_f (void);
	void M_Menu_ModemConfig_f (void);
void M_Menu_LanConfig_f (void);
void M_Menu_GameOptions_f (void);
void M_Menu_Search_f (void);
void M_Menu_ServerList_f (void);

void M_Main_Draw (void);
	void M_SinglePlayer_Draw (void);
		void M_Load_Draw (void);
		void M_Save_Draw (void);
	void M_MultiPlayer_Draw (void);
		void M_Setup_Draw (void);
		void M_Net_Draw (void);
	void M_Options_Draw (void);
		void M_Keys_Draw (void);
		void M_Video_Draw (void);
	void M_Help_Draw (void);
	void M_Quit_Draw (void);
void M_SerialConfig_Draw (void);
	void M_ModemConfig_Draw (void);
void M_LanConfig_Draw (void);
void M_GameOptions_Draw (void);
void M_Search_Draw (void);
void M_ServerList_Draw (void);

void M_Main_Key (int key);
	void M_SinglePlayer_Key (int key);
		void M_Load_Key (int key);
		void M_Save_Key (int key);
	void M_MultiPlayer_Key (int key);
		void M_Setup_Key (int key);
		void M_Net_Key (int key);
	void M_Options_Key (int key);
		void M_Keys_Key (int key);
		void M_Video_Key (int key);
	void M_Help_Key (int key);
	void M_Quit_Key (int key);
void M_SerialConfig_Key (int key);
	void M_ModemConfig_Key (int key);
void M_LanConfig_Key (int key);
void M_GameOptions_Key (int key);
void M_Search_Key (int key);
void M_ServerList_Key (int key);

qboolean	m_entersound;		// play after drawing a frame, so caching
								// won't disrupt the sound
qboolean	m_recursiveDraw;

int			m_return_state;
qboolean	m_return_onerror;
char		m_return_reason [32];

#define StartingGame	(m_multiplayer_cursor == 1)
#define JoiningGame		(m_multiplayer_cursor == 0)
#define SerialConfig	(m_net_cursor == 0)
#define DirectConfig	(m_net_cursor == 1)
#define	IPXConfig		(m_net_cursor == 2)
#define	TCPIPConfig		(m_net_cursor == 3)

void M_ConfigureNetSubsystem(void);

/*
================
M_DrawCharacter

Draws one solid graphics character
================
*/
void M_DrawCharacter (int cx, int line, int num)
{
	Draw_Character ( cx + ((vid.width - 320)>>1), line, num);
}

void M_Print (int cx, int cy, char *str)
{
	while (*str)
	{
		M_DrawCharacter (cx, cy, (*str)+128);
		str++;
		cx += 8;
	}
}

void M_PrintWhite (int cx, int cy, char *str)
{
	while (*str)
	{
		M_DrawCharacter (cx, cy, *str);
		str++;
		cx += 8;
	}
}

void M_DrawTransPic (int x, int y, qpic_t *pic)
{
	Draw_TransPic (x + ((vid.width - 320)>>1), y, pic);
}

void M_DrawPic (int x, int y, qpic_t *pic)
{
	Draw_Pic (x + ((vid.width - 320)>>1), y, pic);
}

byte identityTable[256];
byte translationTable[256];

void M_BuildTranslationTable(int top, int bottom)
{
	int		j;
	byte	*dest, *source;

	for (j = 0; j < 256; j++)
		identityTable[j] = (byte)j;
	dest = translationTable;
	source = identityTable;
	memcpy (dest, source, 256);

	if (top < 128)	// the artists made some backwards ranges.  sigh.
		memcpy (dest + TOP_RANGE, source + top, 16);
	else
		for (j=0 ; j<16 ; j++)
			dest[TOP_RANGE+j] = source[top+15-j];

	if (bottom < 128)
		memcpy (dest + BOTTOM_RANGE, source + bottom, 16);
	else
		for (j=0 ; j<16 ; j++)
			dest[BOTTOM_RANGE+j] = source[bottom+15-j];
}


void M_DrawTransPicTranslate (int x, int y, qpic_t *pic)
{
	Draw_TransPicTranslate (x + ((vid.width - 320)>>1), y, pic, translationTable);
}


void M_DrawTextBox (int x, int y, int width, int lines)
{
	qpic_t	*p;
	int		cx, cy;
	int		n;

	// draw left side
	cx = x;
	cy = y;
	p = Draw_CachePic ("gfx/box_tl.lmp");
	M_DrawTransPic (cx, cy, p);
	p = Draw_CachePic ("gfx/box_ml.lmp");
	for (n = 0; n < lines; n++)
	{
		cy += 8;
		M_DrawTransPic (cx, cy, p);
	}
	p = Draw_CachePic ("gfx/box_bl.lmp");
	M_DrawTransPic (cx, cy+8, p);

	// draw middle
	cx += 8;
	while (width > 0)
	{
		cy = y;
		p = Draw_CachePic ("gfx/box_tm.lmp");
		M_DrawTransPic (cx, cy, p);
		p = Draw_CachePic ("gfx/box_mm.lmp");
		for (n = 0; n < lines; n++)
		{
			cy += 8;
			if (n == 1)
				p = Draw_CachePic ("gfx/box_mm2.lmp");
			M_DrawTransPic (cx, cy, p);
		}
		p = Draw_CachePic ("gfx/box_bm.lmp");
		M_DrawTransPic (cx, cy+8, p);
		width -= 2;
		cx += 16;
	}

	// draw right side
	cy = y;
	p = Draw_CachePic ("gfx/box_tr.lmp");
	M_DrawTransPic (cx, cy, p);
	p = Draw_CachePic ("gfx/box_mr.lmp");
	for (n = 0; n < lines; n++)
	{
		cy += 8;
		M_DrawTransPic (cx, cy, p);
	}
	p = Draw_CachePic ("gfx/box_br.lmp");
	M_DrawTransPic (cx, cy+8, p);
}

//=============================================================================

int m_save_demonum;

/*
================
M_ToggleMenu_f
================
*/
void M_ToggleMenu_f (void)
{
	m_entersound = true;

	if (key_dest == key_menu)
	{
		if (m_state != m_main)
		{
			M_Menu_Main_f ();
			return;
		}
		key_dest = key_game;
		m_state = m_none;
		return;
	}
	if (key_dest == key_console)
	{
		Con_ToggleConsole_f ();
	}
	else
	{
		M_Menu_Main_f ();
	}
}


//=============================================================================
/* MAIN MENU */

int	m_main_cursor;
#define	MAIN_ITEMS	5


void M_Menu_Main_f (void)
{
	if (key_dest != key_menu)
	{
		m_save_demonum = cls.demonum;
		cls.demonum = -1;
	}
	key_dest = key_menu;
	m_state = m_main;
	m_entersound = true;
}


void M_Main_Draw (void)
{
	int		f;
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/ttl_main.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);
	M_DrawTransPic (72, 32, Draw_CachePic ("gfx/mainmenu.lmp") );

	f = (int)(host_time * 10)%6;

	M_DrawTransPic (54, 32 + m_main_cursor * 20,Draw_CachePic( va("gfx/menudot%i.lmp", f+1 ) ) );
}


void M_Main_Key (int key)
{
	switch (key)
	{
	
    case K_GC_BACK:
		key_dest = key_game;
		m_state = m_none;
		cls.demonum = m_save_demonum;
		if (cls.demonum != -1 && !cls.demoplayback && cls.state != ca_connected)
			CL_NextDemo ();
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		if (++m_main_cursor >= MAIN_ITEMS)
			m_main_cursor = 0;
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		if (--m_main_cursor < 0)
			m_main_cursor = MAIN_ITEMS - 1;
		break;

    case K_GC_START:
		m_entersound = true;

		switch (m_main_cursor)
		{
		case 0:
			M_Menu_SinglePlayer_f ();
			break;

		case 1:
			M_Menu_MultiPlayer_f ();
			break;

		case 2:
			M_Menu_Options_f ();
			break;

		case 3:
			M_Menu_Help_f ();
			break;

		case 4:
			M_Menu_Quit_f ();
			break;
		}
	}
}

//=============================================================================
/* SINGLE PLAYER MENU */

int	m_singleplayer_cursor;
#define	SINGLEPLAYER_ITEMS	3


void M_Menu_SinglePlayer_f (void)
{
	key_dest = key_menu;
	m_state = m_singleplayer;
	m_entersound = true;
}


void M_SinglePlayer_Draw (void)
{
	int		f;
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/ttl_sgl.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);
	M_DrawTransPic (72, 32, Draw_CachePic ("gfx/sp_menu.lmp") );

	f = (int)(host_time * 10)%6;

	M_DrawTransPic (54, 32 + m_singleplayer_cursor * 20,Draw_CachePic( va("gfx/menudot%i.lmp", f+1 ) ) );
}


void M_SinglePlayer_Key (int key)
{
	switch (key)
	{
    case K_GC_BACK:
		M_Menu_Main_f ();
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		if (++m_singleplayer_cursor >= SINGLEPLAYER_ITEMS)
			m_singleplayer_cursor = 0;
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		if (--m_singleplayer_cursor < 0)
			m_singleplayer_cursor = SINGLEPLAYER_ITEMS - 1;
		break;

	case K_GC_START:

		m_entersound = true;

		switch (m_singleplayer_cursor)
		{
		case 0:
			if (sv.active)
				if (!SCR_ModalMessage("Are you sure you want to\nstart a new game?\n"))
					break;
			key_dest = key_game;
			if (sv.active)
				Cbuf_AddText ("disconnect\n");
			Cbuf_AddText ("maxplayers 1\n");
			Cbuf_AddText ("map start\n");
			break;

		case 1:
			M_Menu_Load_f ();
			break;

		case 2:
			M_Menu_Save_f ();
			break;
		}
	}
}

//=============================================================================
/* LOAD/SAVE MENU */

int		load_cursor;		// 0 < load_cursor < MAX_SAVEGAMES

#define	MAX_SAVEGAMES		12
char	m_filenames[MAX_SAVEGAMES][SAVEGAME_COMMENT_LENGTH+1];
int		loadable[MAX_SAVEGAMES];

#ifdef _XBOX
#define ARRAYSIZE(x) (sizeof(x) / sizeof(x[0]))
#endif // XBOX

void M_ScanSaves (void)
{
#ifdef _XBOX
	WCHAR   wszName[MAX_GAMENAME];
	CHAR    szPath[MAX_PATH];
	DWORD   dwErr;
#endif // XBOX
	int		i, j;
	char	name[MAX_OSPATH];
	FILE	*f;
	int		version;

	for (i=0 ; i<MAX_SAVEGAMES ; i++)
	{
		strcpy (m_filenames[i], "--- UNUSED SLOT ---");
		loadable[i] = false;
#ifdef _XBOX
		swprintf (wszName, L"s%i", i);

		// NOTE: Hard disk only for now (hardcoded U: drive)

		dwErr = XCreateSaveGame("U:\\", wszName, OPEN_EXISTING, 0, szPath, ARRAYSIZE(szPath));

		if (ERROR_SUCCESS != dwErr)
		{
			continue;
		}

		sprintf (name, "%ss%i.sav", szPath, i);
#else  // XBOX
		sprintf (name, "%s/s%i.sav", com_gamedir, i);
#endif // XBOX
		f = fopen (name, "r");
		if (!f)
			continue;
		fscanf (f, "%i\n", &version);
		fscanf (f, "%79s\n", name);
		strncpy (m_filenames[i], name, sizeof(m_filenames[i])-1);

	// change _ back to space
		for (j=0 ; j<SAVEGAME_COMMENT_LENGTH ; j++)
			if (m_filenames[i][j] == '_')
				m_filenames[i][j] = ' ';
		loadable[i] = true;
		fclose (f);
	}
}

void M_Menu_Load_f (void)
{
	m_entersound = true;
	m_state = m_load;
	key_dest = key_menu;
	M_ScanSaves ();
}


void M_Menu_Save_f (void)
{
	if (!sv.active)
		return;
	if (cl.intermission)
		return;
	if (svs.maxclients != 1)
		return;
	m_entersound = true;
	m_state = m_save;
	key_dest = key_menu;
	M_ScanSaves ();
}


void M_Load_Draw (void)
{
	int		i;
	qpic_t	*p;

	p = Draw_CachePic ("gfx/p_load.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	for (i=0 ; i< MAX_SAVEGAMES; i++)
		M_Print (16, 32 + 8*i, m_filenames[i]);

// line cursor
	M_DrawCharacter (8, 32 + load_cursor*8, 12+((int)(realtime*4)&1));
}


void M_Save_Draw (void)
{
	int		i;
	qpic_t	*p;

	p = Draw_CachePic ("gfx/p_save.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	for (i=0 ; i<MAX_SAVEGAMES ; i++)
		M_Print (16, 32 + 8*i, m_filenames[i]);

// line cursor
	M_DrawCharacter (8, 32 + load_cursor*8, 12+((int)(realtime*4)&1));
}


void M_Load_Key (int k)
{
	switch (k)
	{
    case K_GC_BACK:
		M_Menu_SinglePlayer_f ();
		break;

    
	case K_GC_START:
		S_LocalSound ("misc/menu2.wav");
		if (!loadable[load_cursor])
			return;
		m_state = m_none;
		key_dest = key_game;

	// Host_Loadgame_f can't bring up the loading plaque because too much
	// stack space has been used, so do it now
		SCR_BeginLoadingPlaque ();

	// issue the load command
		Cbuf_AddText (va ("load s%i\n", load_cursor) );
		return;

    case K_GC_DPAD_LEFT:
    case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		load_cursor--;
		if (load_cursor < 0)
			load_cursor = MAX_SAVEGAMES-1;
		break;
    
    case K_GC_DPAD_RIGHT:
	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		load_cursor++;
		if (load_cursor >= MAX_SAVEGAMES)
			load_cursor = 0;
		break;
	}
}


void M_Save_Key (int k)
{
	switch (k)
	{
	case K_GC_BACK:
		M_Menu_SinglePlayer_f ();
		break;

    case K_GC_START:
		m_state = m_none;
		key_dest = key_game;
		Cbuf_AddText (va("save s%i\n", load_cursor));
		return;

	case K_GC_DPAD_LEFT:
    case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		load_cursor--;
		if (load_cursor < 0)
			load_cursor = MAX_SAVEGAMES-1;
		break;

	case K_GC_DPAD_RIGHT:
    case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		load_cursor++;
		if (load_cursor >= MAX_SAVEGAMES)
			load_cursor = 0;
		break;
	}
}

//=============================================================================
/* MULTIPLAYER MENU */

int	m_multiplayer_cursor;
#define	MULTIPLAYER_ITEMS	3


void M_Menu_MultiPlayer_f (void)
{
	key_dest = key_menu;
	m_state = m_multiplayer;
	m_entersound = true;
}


void M_MultiPlayer_Draw (void)
{
	int		f;
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);
	M_DrawTransPic (72, 32, Draw_CachePic ("gfx/mp_menu.lmp") );

	f = (int)(host_time * 10)%6;

	M_DrawTransPic (54, 32 + m_multiplayer_cursor * 20,Draw_CachePic( va("gfx/menudot%i.lmp", f+1 ) ) );

	if (serialAvailable || ipxAvailable || tcpipAvailable)
		return;
	M_PrintWhite ((320/2) - ((27*8)/2), 148, "No Communications Available");
}


void M_MultiPlayer_Key (int key)
{
	switch (key)
	{
    case K_GC_BACK:
		M_Menu_Main_f ();
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		if (++m_multiplayer_cursor >= MULTIPLAYER_ITEMS)
			m_multiplayer_cursor = 0;
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		if (--m_multiplayer_cursor < 0)
			m_multiplayer_cursor = MULTIPLAYER_ITEMS - 1;
		break;

	case K_GC_DPAD_RIGHT:
    case K_GC_START:
		m_entersound = true;
		switch (m_multiplayer_cursor)
		{
		case 0:
			if (serialAvailable || ipxAvailable || tcpipAvailable)
				M_Menu_Net_f ();
			break;

		case 1:
			if (serialAvailable || ipxAvailable || tcpipAvailable)
				M_Menu_Net_f ();
			break;

		case 2:
			M_Menu_Setup_f ();
			break;
		}
	}
}

//=============================================================================
/* SETUP MENU */

int		setup_cursor = 4;
int		setup_cursor_table[] = {40, 56, 80, 104, 140};

char	setup_hostname[16];
char	setup_myname[16];
int		setup_oldtop;
int		setup_oldbottom;
int		setup_top;
int		setup_bottom;

#define	NUM_SETUP_CMDS	5

void M_Menu_Setup_f (void)
{
	key_dest = key_menu;
	m_state = m_setup;
	m_entersound = true;
	Q_strcpy(setup_myname, cl_name.string);
	Q_strcpy(setup_hostname, hostname.string);
	setup_top = setup_oldtop = ((int)cl_color.value) >> 4;
	setup_bottom = setup_oldbottom = ((int)cl_color.value) & 15;
}


void M_Setup_Draw (void)
{
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	M_Print (64, 40, "Hostname");
	M_DrawTextBox (160, 32, 16, 1);
	M_Print (168, 40, setup_hostname);

	M_Print (64, 56, "Your name");
	M_DrawTextBox (160, 48, 16, 1);
	M_Print (168, 56, setup_myname);

	M_Print (64, 80, "Shirt color");
	M_Print (64, 104, "Pants color");

	M_DrawTextBox (64, 140-8, 14, 1);
	M_Print (72, 140, "Accept Changes");

	p = Draw_CachePic ("gfx/bigbox.lmp");
	M_DrawTransPic (160, 64, p);
	p = Draw_CachePic ("gfx/menuplyr.lmp");
	M_BuildTranslationTable(setup_top*16, setup_bottom*16);
	M_DrawTransPicTranslate (172, 72, p);

	M_DrawCharacter (56, setup_cursor_table [setup_cursor], 12+((int)(realtime*4)&1));

	if (setup_cursor == 0)
		M_DrawCharacter (168 + 8*strlen(setup_hostname), setup_cursor_table [setup_cursor], 10+((int)(realtime*4)&1));

	if (setup_cursor == 1)
		M_DrawCharacter (168 + 8*strlen(setup_myname), setup_cursor_table [setup_cursor], 10+((int)(realtime*4)&1));
}


void M_Setup_Key (int k)
{
	int			l;

	switch (k)
	{
	case K_GC_BACK:
		M_Menu_MultiPlayer_f ();
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		setup_cursor--;
		if (setup_cursor < 0)
			setup_cursor = NUM_SETUP_CMDS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		setup_cursor++;
		if (setup_cursor >= NUM_SETUP_CMDS)
			setup_cursor = 0;
		break;

	case K_GC_DPAD_LEFT:
		if (setup_cursor < 2)
			return;
		S_LocalSound ("misc/menu3.wav");
		if (setup_cursor == 2)
			setup_top = setup_top - 1;
		if (setup_cursor == 3)
			setup_bottom = setup_bottom - 1;
		break;
	case K_GC_DPAD_RIGHT:
		if (setup_cursor < 2)
			return;
forward:
		S_LocalSound ("misc/menu3.wav");
		if (setup_cursor == 2)
			setup_top = setup_top + 1;
		if (setup_cursor == 3)
			setup_bottom = setup_bottom + 1;
		break;

    case K_GC_START:
		if (setup_cursor == 0 || setup_cursor == 1)
			return;

		if (setup_cursor == 2 || setup_cursor == 3)
			goto forward;

		// setup_cursor == 4 (OK)
		if (Q_strcmp(cl_name.string, setup_myname) != 0)
			Cbuf_AddText ( va ("name \"%s\"\n", setup_myname) );
		if (Q_strcmp(hostname.string, setup_hostname) != 0)
			Cvar_Set("hostname", setup_hostname);
		if (setup_top != setup_oldtop || setup_bottom != setup_oldbottom)
			Cbuf_AddText( va ("color %i %i\n", setup_top, setup_bottom) );
		m_entersound = true;
		M_Menu_MultiPlayer_f ();
		break;

	case K_GC_BLACK:
    case K_GC_WHITE:
		if (setup_cursor == 0)
		{
			if (strlen(setup_hostname))
				setup_hostname[strlen(setup_hostname)-1] = 0;
		}

		if (setup_cursor == 1)
		{
			if (strlen(setup_myname))
				setup_myname[strlen(setup_myname)-1] = 0;
		}
		break;

	default:
		if (k < 32 || k > 127)
			break;
		if (setup_cursor == 0)
		{
			l = strlen(setup_hostname);
			if (l < 15)
			{
				setup_hostname[l+1] = 0;
				setup_hostname[l] = (char)k;
			}
		}
		if (setup_cursor == 1)
		{
			l = strlen(setup_myname);
			if (l < 15)
			{
				setup_myname[l+1] = 0;
				setup_myname[l] = (char)k;
			}
		}
	}

	if (setup_top > 13)
		setup_top = 0;
	if (setup_top < 0)
		setup_top = 13;
	if (setup_bottom > 13)
		setup_bottom = 0;
	if (setup_bottom < 0)
		setup_bottom = 13;
}

//=============================================================================
/* NET MENU */

int	m_net_cursor;
int m_net_items;
int m_net_saveHeight;

char *net_helpMessage [] =
{
/* .........1.........2.... */
  "                        ",
  " Two computers connected",
  "   through two modems.  ",
  "                        ",

  "                        ",
  " Two computers connected",
  " by a null-modem cable. ",
  "                        ",

  " Novell network LANs    ",
  " or Windows 95 DOS-box. ",
  "                        ",
  "(LAN=Local Area Network)",

  " Commonly used to play  ",
  " over the Internet, but ",
  " also used on a Local   ",
  " Area Network.          "
};

void M_Menu_Net_f (void)
{
	key_dest = key_menu;
	m_state = m_net;
	m_entersound = true;
	m_net_items = 4;

	if (m_net_cursor >= m_net_items)
		m_net_cursor = 0;
	m_net_cursor--;
	M_Net_Key (K_GC_DPAD_DOWN);
}


void M_Net_Draw (void)
{
	int		f;
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	f = 32;

	if (serialAvailable)
	{
		p = Draw_CachePic ("gfx/netmen1.lmp");
	}
	else
	{
#ifdef _WIN32
		p = NULL;
#else
		p = Draw_CachePic ("gfx/dim_modm.lmp");
#endif
	}

	if (p)
		M_DrawTransPic (72, f, p);

	f += 19;

	if (serialAvailable)
	{
		p = Draw_CachePic ("gfx/netmen2.lmp");
	}
	else
	{
#ifdef _WIN32
		p = NULL;
#else
		p = Draw_CachePic ("gfx/dim_drct.lmp");
#endif
	}

	if (p)
		M_DrawTransPic (72, f, p);

	f += 19;
	if (ipxAvailable)
		p = Draw_CachePic ("gfx/netmen3.lmp");
	else
		p = Draw_CachePic ("gfx/dim_ipx.lmp");
	M_DrawTransPic (72, f, p);

	f += 19;
	if (tcpipAvailable)
		p = Draw_CachePic ("gfx/netmen4.lmp");
	else
		p = Draw_CachePic ("gfx/dim_tcp.lmp");
	M_DrawTransPic (72, f, p);

	if (m_net_items == 5)	// JDC, could just be removed
	{
		f += 19;
		p = Draw_CachePic ("gfx/netmen5.lmp");
		M_DrawTransPic (72, f, p);
	}

	f = (320-26*8)/2;
	M_DrawTextBox (f, 134, 24, 4);
	f += 8;
	M_Print (f, 142, net_helpMessage[m_net_cursor*4+0]);
	M_Print (f, 150, net_helpMessage[m_net_cursor*4+1]);
	M_Print (f, 158, net_helpMessage[m_net_cursor*4+2]);
	M_Print (f, 166, net_helpMessage[m_net_cursor*4+3]);

	f = (int)(host_time * 10)%6;
	M_DrawTransPic (54, 32 + m_net_cursor * 20,Draw_CachePic( va("gfx/menudot%i.lmp", f+1 ) ) );
}


void M_Net_Key (int k)
{
again:
	switch (k)
	{
	case K_GC_BACK:
        M_Menu_MultiPlayer_f ();
		break;

	case K_GC_DPAD_LEFT:
    case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		if (++m_net_cursor >= m_net_items)
			m_net_cursor = 0;
		break;

	case K_GC_DPAD_UP:
    case K_GC_DPAD_RIGHT:
		S_LocalSound ("misc/menu1.wav");
		if (--m_net_cursor < 0)
			m_net_cursor = m_net_items - 1;
		break;

	case K_GC_START:
		m_entersound = true;

		switch (m_net_cursor)
		{
		case 0:
			M_Menu_SerialConfig_f ();
			break;

		case 1:
			M_Menu_SerialConfig_f ();
			break;

		case 2:
			M_Menu_LanConfig_f ();
			break;

		case 3:
			M_Menu_LanConfig_f ();
			break;

		case 4:
// multiprotocol
			break;
		}
	}

	if (m_net_cursor == 0 && !serialAvailable)
		goto again;
	if (m_net_cursor == 1 && !serialAvailable)
		goto again;
	if (m_net_cursor == 2 && !ipxAvailable)
		goto again;
	if (m_net_cursor == 3 && !tcpipAvailable)
		goto again;
}

//=============================================================================
/* OPTIONS MENU */

#ifdef _WIN32
#define	OPTIONS_ITEMS	14
#else
#define	OPTIONS_ITEMS	13
#endif

#define	SLIDER_RANGE	10

int		options_cursor;

void M_Menu_Options_f (void)
{
	key_dest = key_menu;
	m_state = m_options;
	m_entersound = true;

#ifdef _WIN32
	if ((options_cursor == 13) && (modestate != MS_WINDOWED))
	{
		options_cursor = 0;
	}
#endif
}


void M_AdjustSliders (int dir)
{
	S_LocalSound ("misc/menu3.wav");

	switch (options_cursor)
	{
	case 3:	// screen size
		scr_viewsize.value += dir * 10;
		if (scr_viewsize.value < 30)
			scr_viewsize.value = 30;
		if (scr_viewsize.value > 120)
			scr_viewsize.value = 120;
		Cvar_SetValue ("viewsize", scr_viewsize.value);
		break;
	case 4:	// gamma
		v_gamma.value -= dir * 0.05;
		if (v_gamma.value < 0.5)
			v_gamma.value = 0.5;
		if (v_gamma.value > 1)
			v_gamma.value = 1;
		Cvar_SetValue ("gamma", v_gamma.value);
		break;
	case 5:	// mouse speed
		sensitivity.value += dir * 0.5;
		if (sensitivity.value < 1)
			sensitivity.value = 1;
		if (sensitivity.value > 11)
			sensitivity.value = 11;
		Cvar_SetValue ("sensitivity", sensitivity.value);
		break;
	case 6:	// music volume
#ifdef _WIN32
		bgmvolume.value += dir * 1.0;
#else
		bgmvolume.value += dir * 0.1;
#endif
		if (bgmvolume.value < 0)
			bgmvolume.value = 0;
		if (bgmvolume.value > 1)
			bgmvolume.value = 1;
		Cvar_SetValue ("bgmvolume", bgmvolume.value);
		break;
	case 7:	// sfx volume
		volume.value += dir * 0.1;
		if (volume.value < 0)
			volume.value = 0;
		if (volume.value > 1)
			volume.value = 1;
		Cvar_SetValue ("volume", volume.value);
		break;

	case 8:	// allways run
		if (cl_forwardspeed.value > 200)
		{
			Cvar_SetValue ("cl_forwardspeed", 200);
			Cvar_SetValue ("cl_backspeed", 200);
		}
		else
		{
			Cvar_SetValue ("cl_forwardspeed", 400);
			Cvar_SetValue ("cl_backspeed", 400);
		}
		break;

	case 9:	// invert mouse
		Cvar_SetValue ("m_pitch", -m_pitch.value);
		break;

	case 10:	// lookspring
		Cvar_SetValue ("lookspring", !lookspring.value);
		break;

	case 11:	// lookstrafe
		Cvar_SetValue ("lookstrafe", !lookstrafe.value);
		break;
	}
}


void M_DrawSlider (int x, int y, float range)
{
	int	i;

	if (range < 0)
		range = 0;
	if (range > 1)
		range = 1;
	M_DrawCharacter (x-8, y, 128);
	for (i=0 ; i<SLIDER_RANGE ; i++)
		M_DrawCharacter (x + i*8, y, 129);
	M_DrawCharacter (x+i*8, y, 130);
	M_DrawCharacter (x + (SLIDER_RANGE-1)*8 * range, y, 131);
}

void M_DrawCheckbox (int x, int y, int on)
{
#if 0
	if (on)
		M_DrawCharacter (x, y, 131);
	else
		M_DrawCharacter (x, y, 129);
#endif
	if (on)
		M_Print (x, y, "on");
	else
		M_Print (x, y, "off");
}

void M_Options_Draw (void)
{
	float		r;
	qpic_t	*p;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_option.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	M_Print (16, 32, "    Customize controls");
	M_Print (16, 40, "         Go to console");
	M_Print (16, 48, "     Reset to defaults");

	M_Print (16, 56, "           Screen size");
	r = (scr_viewsize.value - 30) / (120 - 30);
	M_DrawSlider (220, 56, r);

	M_Print (16, 64, "            Brightness");
	r = (1.0 - v_gamma.value) / 0.5;
	M_DrawSlider (220, 64, r);

	M_Print (16, 72, "           Mouse Speed");
	r = (sensitivity.value - 1)/10;
	M_DrawSlider (220, 72, r);

	M_Print (16, 80, "       CD Music Volume");
	r = bgmvolume.value;
	M_DrawSlider (220, 80, r);

	M_Print (16, 88, "          Sound Volume");
	r = volume.value;
	M_DrawSlider (220, 88, r);

	M_Print (16, 96,  "            Always Run");
	M_DrawCheckbox (220, 96, cl_forwardspeed.value > 200);

	M_Print (16, 104, "          Invert Mouse");
	M_DrawCheckbox (220, 104, m_pitch.value < 0);

	M_Print (16, 112, "            Lookspring");
	M_DrawCheckbox (220, 112, lookspring.value);

	M_Print (16, 120, "            Lookstrafe");
	M_DrawCheckbox (220, 120, lookstrafe.value);

	if (vid_menudrawfn)
		M_Print (16, 128, "         Video Options");

// cursor
	M_DrawCharacter (200, 32 + options_cursor*8, 12+((int)(realtime*4)&1));
}


void M_Options_Key (int k)
{
	switch (k)
	{
	case K_GC_BACK:
		M_Menu_Main_f ();
		break;

	case K_GC_START:
		m_entersound = true;
		switch (options_cursor)
		{
		case 0:
			M_Menu_Keys_f ();
			break;
		case 1:
			m_state = m_none;
			Con_ToggleConsole_f ();
			break;
		case 2:
			Cbuf_AddText ("exec default.cfg\n");
			break;
		case 12:
			M_Menu_Video_f ();
			break;
		default:
			M_AdjustSliders (1);
			break;
		}
		return;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		options_cursor--;
		if (options_cursor < 0)
			options_cursor = OPTIONS_ITEMS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		options_cursor++;
		if (options_cursor >= OPTIONS_ITEMS)
			options_cursor = 0;
		break;

	case K_GC_DPAD_LEFT:
		M_AdjustSliders (-1);
		break;

	case K_GC_DPAD_RIGHT:
		M_AdjustSliders (1);
		break;
	}

	if (options_cursor == 12 && vid_menudrawfn == NULL)
	{
		if (k == K_GC_DPAD_UP)
			options_cursor = 11;
		else
			options_cursor = 0;
	}

#ifdef _WIN32
	if ((options_cursor == 13) && (modestate != MS_WINDOWED))
	{
		if (k == K_GC_DPAD_UP)
			options_cursor = 12;
		else
			options_cursor = 0;
	}
#endif
}

//=============================================================================
/* KEYS MENU */

char *bindnames[][2] =
{
{"+attack", 		"attack"},
{"impulse 10", 		"change weapon"},
{"+jump", 			"jump / swim up"},
{"+forward", 		"walk forward"},
{"+back", 			"backpedal"},
{"+left", 			"turn left"},
{"+right", 			"turn right"},
{"+speed", 			"run"},
{"+moveleft", 		"step left"},
{"+moveright", 		"step right"},
{"+strafe", 		"sidestep"},
{"+lookup", 		"look up"},
{"+lookdown", 		"look down"},
{"centerview", 		"center view"},
{"+mlook", 			"mouse look"},
{"+klook", 			"keyboard look"},
{"+moveup",			"swim up"},
{"+movedown",		"swim down"}
};

#define	NUMCOMMANDS	(sizeof(bindnames)/sizeof(bindnames[0]))

int		keys_cursor;
int		bind_grab;

void M_Menu_Keys_f (void)
{
	key_dest = key_menu;
	m_state = m_keys;
	m_entersound = true;
}


void M_FindKeysForCommand (char *command, int *twokeys)
{
	int		count;
	int		j;
	int		l;
	char	*b;

	twokeys[0] = twokeys[1] = -1;
	l = strlen(command);
	count = 0;

	for (j=0 ; j<256 ; j++)
	{
		b = keybindings[j];
		if (!b)
			continue;
		if (!strncmp (b, command, l) )
		{
			twokeys[count] = j;
			count++;
			if (count == 2)
				break;
		}
	}
}

void M_UnbindCommand (char *command)
{
	int		j;
	int		l;
	char	*b;

	l = strlen(command);

	for (j=0 ; j<256 ; j++)
	{
		b = keybindings[j];
		if (!b)
			continue;
		if (!strncmp (b, command, l) )
			Key_SetBinding (j, "");
	}
}


void M_Keys_Draw (void)
{
	int		i, l;
	int		keys[2];
	char	*name;
	int		x, y;
	qpic_t	*p;

	p = Draw_CachePic ("gfx/ttl_cstm.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	if (bind_grab)
		M_Print (12, 32, "Press a key or button for this action");
	else
		M_Print (18, 32, "Enter to change, backspace to clear");

// search for known bindings
	for (i=0 ; i<NUMCOMMANDS ; i++)
	{
		y = 48 + 8*i;

		M_Print (16, y, bindnames[i][1]);

		l = strlen (bindnames[i][0]);

		M_FindKeysForCommand (bindnames[i][0], keys);

		if (keys[0] == -1)
		{
			M_Print (140, y, "???");
		}
		else
		{
			name = Key_KeynumToString (keys[0]);
			M_Print (140, y, name);
			x = strlen(name) * 8;
			if (keys[1] != -1)
			{
				M_Print (140 + x + 8, y, "or");
				M_Print (140 + x + 32, y, Key_KeynumToString (keys[1]));
			}
		}
	}

	if (bind_grab)
		M_DrawCharacter (130, 48 + keys_cursor*8, '=');
	else
		M_DrawCharacter (130, 48 + keys_cursor*8, 12+((int)(realtime*4)&1));
}


void M_Keys_Key (int k)
{
	char	cmd[80];
	int		keys[2];

	if (bind_grab)
	{	// defining a key
		S_LocalSound ("misc/menu1.wav");
		if (k == K_GC_BACK)
		{
			bind_grab = false;
		}
		else if (k != '`')
		{
			sprintf (cmd, "bind \"%s\" \"%s\"\n", Key_KeynumToString (k), bindnames[keys_cursor][0]);
			Cbuf_InsertText (cmd);
		}

		bind_grab = false;
		return;
	}

	switch (k)
	{
	case K_GC_BACK:
		M_Menu_Options_f ();
		break;

	case K_GC_DPAD_LEFT:
	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		keys_cursor--;
		if (keys_cursor < 0)
			keys_cursor = NUMCOMMANDS-1;
		break;

	case K_GC_DPAD_DOWN:
	case K_GC_DPAD_RIGHT:
		S_LocalSound ("misc/menu1.wav");
		keys_cursor++;
		if (keys_cursor >= NUMCOMMANDS)
			keys_cursor = 0;
		break;

	case K_GC_START:		// go into bind mode
		M_FindKeysForCommand (bindnames[keys_cursor][0], keys);
		S_LocalSound ("misc/menu2.wav");
		if (keys[1] != -1)
			M_UnbindCommand (bindnames[keys_cursor][0]);
		bind_grab = true;
		break;

	case K_GC_BLACK:		// delete bindings
	case K_GC_WHITE:		// delete bindings
		S_LocalSound ("misc/menu2.wav");
		M_UnbindCommand (bindnames[keys_cursor][0]);
		break;
	}
}

//=============================================================================
/* VIDEO MENU */

void M_Menu_Video_f (void)
{
	key_dest = key_menu;
	m_state = m_video;
	m_entersound = true;
}


void M_Video_Draw (void)
{
	(*vid_menudrawfn) ();
}


void M_Video_Key (int key)
{
	(*vid_menukeyfn) (key);
}

//=============================================================================
/* HELP MENU */

int		help_page;
#define	NUM_HELP_PAGES	6


void M_Menu_Help_f (void)
{
	key_dest = key_menu;
	m_state = m_help;
	m_entersound = true;
	help_page = 0;
}



void M_Help_Draw (void)
{
	M_DrawPic (0, 0, Draw_CachePic ( va("gfx/help%i.lmp", help_page)) );
}


void M_Help_Key (int key)
{
	switch (key)
	{
	case K_GC_BACK:
		M_Menu_Main_f ();
		break;

	case K_GC_DPAD_UP:
	case K_GC_DPAD_RIGHT:
		m_entersound = true;
		if (++help_page >= NUM_HELP_PAGES)
			help_page = 0;
		break;

	case K_GC_DPAD_DOWN:
	case K_GC_DPAD_LEFT:
		m_entersound = true;
		if (--help_page < 0)
			help_page = NUM_HELP_PAGES-1;
		break;
	}

}

//=============================================================================
/* QUIT MENU */

int		msgNumber;
int		m_quit_prevstate;
qboolean	wasInMenus;

#ifndef	_WIN32
char *quitMessage [] = 
{
/* .........1.........2.... */
  "  Are you gonna quit    ",
  "  this game just like   ",
  "   everything else?     ",
  "                        ",
 
  " Milord, methinks that  ",
  "   thou art a lowly     ",
  " quitter. Is this true? ",
  "                        ",

  " Do I need to bust your ",
  "  face open for trying  ",
  "        to quit?        ",
  "                        ",

  " Man, I oughta smack you",
  "   for trying to quit!  ",
  "     Press Y to get     ",
  "      smacked out.      ",
 
  " Press Y to quit like a ",
  "   big loser in life.   ",
  "  Press N to stay proud ",
  "    and successful!     ",
 
  "   If you press Y to    ",
  "  quit, I will summon   ",
  "  Satan all over your   ",
  "      hard drive!       ",
 
  "  Um, Asmodeus dislikes ",
  " his children trying to ",
  " quit. Press Y to return",
  "   to your Tinkertoys.  ",
 
  "  If you quit now, I'll ",
  "  throw a blanket-party ",
  "   for you next time!   ",
  "                        "
};
#endif

void M_Menu_Quit_f (void)
{
	if (m_state == m_quit)
		return;
	wasInMenus = (key_dest == key_menu);
	key_dest = key_menu;
	m_quit_prevstate = m_state;
	m_state = m_quit;
	m_entersound = true;
	msgNumber = rand()&7;
}


void M_Quit_Key (int key)
{
	switch (key)
	{
	case K_GC_BACK:
		if (wasInMenus)
		{
			m_state = m_quit_prevstate;
			m_entersound = true;
		}
		else
		{
			key_dest = key_game;
			m_state = m_none;
		}
		break;

	case K_GC_START:
		key_dest = key_console;
		Host_Quit_f ();
		break;

	default:
		break;
	}

}


void M_Quit_Draw (void)
{
	if (wasInMenus)
	{
		m_state = m_quit_prevstate;
		m_recursiveDraw = true;
		M_Draw ();
		m_state = m_quit;
	}

#ifdef _WIN32
	M_DrawTextBox (0, 0, 38, 23);
	M_PrintWhite (16, 12,  "  Quake version 1.09 by id Software\n\n");
	M_PrintWhite (16, 28,  "Programming        Art \n");
	M_Print (16, 36,  " John Carmack       Adrian Carmack\n");
	M_Print (16, 44,  " Michael Abrash     Kevin Cloud\n");
	M_Print (16, 52,  " John Cash          Paul Steed\n");
	M_Print (16, 60,  " Dave 'Zoid' Kirsch\n");
	M_PrintWhite (16, 68,  "Design             Biz\n");
	M_Print (16, 76,  " John Romero        Jay Wilbur\n");
	M_Print (16, 84,  " Sandy Petersen     Mike Wilson\n");
	M_Print (16, 92,  " American McGee     Donna Jackson\n");
	M_Print (16, 100,  " Tim Willits        Todd Hollenshead\n");
	M_PrintWhite (16, 108, "Support            Projects\n");
	M_Print (16, 116, " Barrett Alexander  Shawn Green\n");
	M_PrintWhite (16, 124, "Sound Effects\n");
	M_Print (16, 132, " Trent Reznor and Nine Inch Nails\n\n");
	M_PrintWhite (16, 140, "Quake is a trademark of Id Software,\n");
	M_PrintWhite (16, 148, "inc., (c)1996 Id Software, inc. All\n");
	M_PrintWhite (16, 156, "rights reserved. NIN logo is a\n");
	M_PrintWhite (16, 164, "registered trademark licensed to\n");
	M_PrintWhite (16, 172, "Nothing Interactive, Inc. All rights\n");
	M_PrintWhite (16, 180, "reserved. Press y to exit\n");
#else
	M_DrawTextBox (56, 76, 24, 4);
	M_Print (64, 84,  quitMessage[msgNumber*4+0]);
	M_Print (64, 92,  quitMessage[msgNumber*4+1]);
	M_Print (64, 100, quitMessage[msgNumber*4+2]);
	M_Print (64, 108, quitMessage[msgNumber*4+3]);
#endif
}

//=============================================================================

/* SERIAL CONFIG MENU */

int		serialConfig_cursor;
int		serialConfig_cursor_table[] = {48, 64, 80, 96, 112, 132};
#define	NUM_SERIALCONFIG_CMDS	6

static int ISA_uarts[]	= {0x3f8,0x2f8,0x3e8,0x2e8};
static int ISA_IRQs[]	= {4,3,4,3};
int serialConfig_baudrate[] = {9600,14400,19200,28800,38400,57600};

int		serialConfig_comport;
int		serialConfig_irq ;
int		serialConfig_baud;
char	serialConfig_phone[16];

void M_Menu_SerialConfig_f (void)
{
	int		n;
	int		port;
	int		baudrate;
	qboolean	useModem;

	key_dest = key_menu;
	m_state = m_serialconfig;
	m_entersound = true;
	if (JoiningGame && SerialConfig)
		serialConfig_cursor = 4;
	else
		serialConfig_cursor = 5;

	(*GetComPortConfig) (0, &port, &serialConfig_irq, &baudrate, &useModem);

	// map uart's port to COMx
	for (n = 0; n < 4; n++)
		if (ISA_uarts[n] == port)
			break;
	if (n == 4)
	{
		n = 0;
		serialConfig_irq = 4;
	}
	serialConfig_comport = n + 1;

	// map baudrate to index
	for (n = 0; n < 6; n++)
		if (serialConfig_baudrate[n] == baudrate)
			break;
	if (n == 6)
		n = 5;
	serialConfig_baud = n;

	m_return_onerror = false;
	m_return_reason[0] = 0;
}


void M_SerialConfig_Draw (void)
{
	qpic_t	*p;
	int		basex;
	char	*startJoin;
	char	*directModem;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	basex = (320-p->width)/2;
	M_DrawPic (basex, 4, p);

	if (StartingGame)
		startJoin = "New Game";
	else
		startJoin = "Join Game";
	if (SerialConfig)
		directModem = "Modem";
	else
		directModem = "Direct Connect";
	M_Print (basex, 32, va ("%s - %s", startJoin, directModem));
	basex += 8;

	M_Print (basex, serialConfig_cursor_table[0], "Port");
	M_DrawTextBox (160, 40, 4, 1);
	M_Print (168, serialConfig_cursor_table[0], va("COM%u", serialConfig_comport));

	M_Print (basex, serialConfig_cursor_table[1], "IRQ");
	M_DrawTextBox (160, serialConfig_cursor_table[1]-8, 1, 1);
	M_Print (168, serialConfig_cursor_table[1], va("%u", serialConfig_irq));

	M_Print (basex, serialConfig_cursor_table[2], "Baud");
	M_DrawTextBox (160, serialConfig_cursor_table[2]-8, 5, 1);
	M_Print (168, serialConfig_cursor_table[2], va("%u", serialConfig_baudrate[serialConfig_baud]));

	if (SerialConfig)
	{
		M_Print (basex, serialConfig_cursor_table[3], "Modem Setup...");
		if (JoiningGame)
		{
			M_Print (basex, serialConfig_cursor_table[4], "Phone number");
			M_DrawTextBox (160, serialConfig_cursor_table[4]-8, 16, 1);
			M_Print (168, serialConfig_cursor_table[4], serialConfig_phone);
		}
	}

	if (JoiningGame)
	{
		M_DrawTextBox (basex, serialConfig_cursor_table[5]-8, 7, 1);
		M_Print (basex+8, serialConfig_cursor_table[5], "Connect");
	}
	else
	{
		M_DrawTextBox (basex, serialConfig_cursor_table[5]-8, 2, 1);
		M_Print (basex+8, serialConfig_cursor_table[5], "OK");
	}

	M_DrawCharacter (basex-8, serialConfig_cursor_table [serialConfig_cursor], 12+((int)(realtime*4)&1));

	if (serialConfig_cursor == 4)
		M_DrawCharacter (168 + 8*strlen(serialConfig_phone), serialConfig_cursor_table [serialConfig_cursor], 10+((int)(realtime*4)&1));

	if (*m_return_reason)
		M_PrintWhite (basex, 148, m_return_reason);
}


void M_SerialConfig_Key (int key)
{
	int		l;

	switch (key)
	{
	case K_GC_BACK:
		M_Menu_Net_f ();
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		serialConfig_cursor--;
		if (serialConfig_cursor < 0)
			serialConfig_cursor = NUM_SERIALCONFIG_CMDS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		serialConfig_cursor++;
		if (serialConfig_cursor >= NUM_SERIALCONFIG_CMDS)
			serialConfig_cursor = 0;
		break;

	case K_GC_DPAD_LEFT:
		if (serialConfig_cursor > 2)
			break;
		S_LocalSound ("misc/menu3.wav");

		if (serialConfig_cursor == 0)
		{
			serialConfig_comport--;
			if (serialConfig_comport == 0)
				serialConfig_comport = 4;
			serialConfig_irq = ISA_IRQs[serialConfig_comport-1];
		}

		if (serialConfig_cursor == 1)
		{
			serialConfig_irq--;
			if (serialConfig_irq == 6)
				serialConfig_irq = 5;
			if (serialConfig_irq == 1)
				serialConfig_irq = 7;
		}

		if (serialConfig_cursor == 2)
		{
			serialConfig_baud--;
			if (serialConfig_baud < 0)
				serialConfig_baud = 5;
		}

		break;

	case K_GC_DPAD_RIGHT:
		if (serialConfig_cursor > 2)
			break;
forward:
		S_LocalSound ("misc/menu3.wav");

		if (serialConfig_cursor == 0)
		{
			serialConfig_comport++;
			if (serialConfig_comport > 4)
				serialConfig_comport = 1;
			serialConfig_irq = ISA_IRQs[serialConfig_comport-1];
		}

		if (serialConfig_cursor == 1)
		{
			serialConfig_irq++;
			if (serialConfig_irq == 6)
				serialConfig_irq = 7;
			if (serialConfig_irq == 8)
				serialConfig_irq = 2;
		}

		if (serialConfig_cursor == 2)
		{
			serialConfig_baud++;
			if (serialConfig_baud > 5)
				serialConfig_baud = 0;
		}

		break;

	case K_GC_START:
		if (serialConfig_cursor < 3)
			goto forward;

		m_entersound = true;

		if (serialConfig_cursor == 3)
		{
			(*SetComPortConfig) (0, ISA_uarts[serialConfig_comport-1], serialConfig_irq, serialConfig_baudrate[serialConfig_baud], SerialConfig);

			M_Menu_ModemConfig_f ();
			break;
		}

		if (serialConfig_cursor == 4)
		{
			serialConfig_cursor = 5;
			break;
		}

		// serialConfig_cursor == 5 (OK/CONNECT)
		(*SetComPortConfig) (0, ISA_uarts[serialConfig_comport-1], serialConfig_irq, serialConfig_baudrate[serialConfig_baud], SerialConfig);

		M_ConfigureNetSubsystem ();

		if (StartingGame)
		{
			M_Menu_GameOptions_f ();
			break;
		}

		m_return_state = m_state;
		m_return_onerror = true;
		key_dest = key_game;
		m_state = m_none;

		if (SerialConfig)
			Cbuf_AddText (va ("connect \"%s\"\n", serialConfig_phone));
		else
			Cbuf_AddText ("connect\n");
		break;

	case K_BACKSPACE:
		if (serialConfig_cursor == 4)
		{
			if (strlen(serialConfig_phone))
				serialConfig_phone[strlen(serialConfig_phone)-1] = 0;
		}
		break;

	default:
		if (key < 32 || key > 127)
			break;
		if (serialConfig_cursor == 4)
		{
			l = strlen(serialConfig_phone);
			if (l < 15)
			{
				serialConfig_phone[l+1] = 0;
				serialConfig_phone[l] = (char)key;
			}
		}
	}

	if (DirectConfig && (serialConfig_cursor == 3 || serialConfig_cursor == 4))
		if (key == K_GC_DPAD_UP)
			serialConfig_cursor = 2;
		else
			serialConfig_cursor = 5;

	if (SerialConfig && StartingGame && serialConfig_cursor == 4)
		if (key == K_GC_DPAD_UP)
			serialConfig_cursor = 3;
		else
			serialConfig_cursor = 5;
}

//=============================================================================
/* MODEM CONFIG MENU */

int		modemConfig_cursor;
int		modemConfig_cursor_table [] = {40, 56, 88, 120, 156};
#define NUM_MODEMCONFIG_CMDS	5

char	modemConfig_dialing;
char	modemConfig_clear [16];
char	modemConfig_init [32];
char	modemConfig_hangup [16];

void M_Menu_ModemConfig_f (void)
{
	key_dest = key_menu;
	m_state = m_modemconfig;
	m_entersound = true;
	(*GetModemConfig) (0, &modemConfig_dialing, modemConfig_clear, modemConfig_init, modemConfig_hangup);
}


void M_ModemConfig_Draw (void)
{
	qpic_t	*p;
	int		basex;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	basex = (320-p->width)/2;
	M_DrawPic (basex, 4, p);
	basex += 8;

	if (modemConfig_dialing == 'P')
		M_Print (basex, modemConfig_cursor_table[0], "Pulse Dialing");
	else
		M_Print (basex, modemConfig_cursor_table[0], "Touch Tone Dialing");

	M_Print (basex, modemConfig_cursor_table[1], "Clear");
	M_DrawTextBox (basex, modemConfig_cursor_table[1]+4, 16, 1);
	M_Print (basex+8, modemConfig_cursor_table[1]+12, modemConfig_clear);
	if (modemConfig_cursor == 1)
		M_DrawCharacter (basex+8 + 8*strlen(modemConfig_clear), modemConfig_cursor_table[1]+12, 10+((int)(realtime*4)&1));

	M_Print (basex, modemConfig_cursor_table[2], "Init");
	M_DrawTextBox (basex, modemConfig_cursor_table[2]+4, 30, 1);
	M_Print (basex+8, modemConfig_cursor_table[2]+12, modemConfig_init);
	if (modemConfig_cursor == 2)
		M_DrawCharacter (basex+8 + 8*strlen(modemConfig_init), modemConfig_cursor_table[2]+12, 10+((int)(realtime*4)&1));

	M_Print (basex, modemConfig_cursor_table[3], "Hangup");
	M_DrawTextBox (basex, modemConfig_cursor_table[3]+4, 16, 1);
	M_Print (basex+8, modemConfig_cursor_table[3]+12, modemConfig_hangup);
	if (modemConfig_cursor == 3)
		M_DrawCharacter (basex+8 + 8*strlen(modemConfig_hangup), modemConfig_cursor_table[3]+12, 10+((int)(realtime*4)&1));

	M_DrawTextBox (basex, modemConfig_cursor_table[4]-8, 2, 1);
	M_Print (basex+8, modemConfig_cursor_table[4], "OK");

	M_DrawCharacter (basex-8, modemConfig_cursor_table [modemConfig_cursor], 12+((int)(realtime*4)&1));
}


void M_ModemConfig_Key (int key)
{
	int		l;

	switch (key)
	{
	case K_GC_BACK:
		M_Menu_SerialConfig_f ();
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		modemConfig_cursor--;
		if (modemConfig_cursor < 0)
			modemConfig_cursor = NUM_MODEMCONFIG_CMDS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		modemConfig_cursor++;
		if (modemConfig_cursor >= NUM_MODEMCONFIG_CMDS)
			modemConfig_cursor = 0;
		break;

	case K_GC_DPAD_LEFT:
	case K_GC_DPAD_RIGHT:
		if (modemConfig_cursor == 0)
		{
			if (modemConfig_dialing == 'P')
				modemConfig_dialing = 'T';
			else
				modemConfig_dialing = 'P';
			S_LocalSound ("misc/menu1.wav");
		}
		break;

	case K_GC_START:
		if (modemConfig_cursor == 0)
		{
			if (modemConfig_dialing == 'P')
				modemConfig_dialing = 'T';
			else
				modemConfig_dialing = 'P';
			m_entersound = true;
		}

		if (modemConfig_cursor == 4)
		{
			(*SetModemConfig) (0, va ("%c", modemConfig_dialing), modemConfig_clear, modemConfig_init, modemConfig_hangup);
			m_entersound = true;
			M_Menu_SerialConfig_f ();
		}
		break;

	case K_BACKSPACE:
		if (modemConfig_cursor == 1)
		{
			if (strlen(modemConfig_clear))
				modemConfig_clear[strlen(modemConfig_clear)-1] = 0;
		}

		if (modemConfig_cursor == 2)
		{
			if (strlen(modemConfig_init))
				modemConfig_init[strlen(modemConfig_init)-1] = 0;
		}

		if (modemConfig_cursor == 3)
		{
			if (strlen(modemConfig_hangup))
				modemConfig_hangup[strlen(modemConfig_hangup)-1] = 0;
		}
		break;

	default:
		if (key < 32 || key > 127)
			break;

		if (modemConfig_cursor == 1)
		{
			l = strlen(modemConfig_clear);
			if (l < 15)
			{
				modemConfig_clear[l+1] = 0;
				modemConfig_clear[l] = (char)key;
			}
		}

		if (modemConfig_cursor == 2)
		{
			l = strlen(modemConfig_init);
			if (l < 29)
			{
				modemConfig_init[l+1] = 0;
				modemConfig_init[l] = (char)key;
			}
		}

		if (modemConfig_cursor == 3)
		{
			l = strlen(modemConfig_hangup);
			if (l < 15)
			{
				modemConfig_hangup[l+1] = 0;
				modemConfig_hangup[l] = (char)key;
			}
		}
	}
}

//=============================================================================
/* LAN CONFIG MENU */

int		lanConfig_cursor = -1;
int		lanConfig_cursor_table [] = {72, 92, 124};
#define NUM_LANCONFIG_CMDS	3

int 	lanConfig_port;
char	lanConfig_portname[6];
char	lanConfig_joinname[22];

void M_Menu_LanConfig_f (void)
{
	key_dest = key_menu;
	m_state = m_lanconfig;
	m_entersound = true;
	if (lanConfig_cursor == -1)
	{
		if (JoiningGame && TCPIPConfig)
			lanConfig_cursor = 2;
		else
			lanConfig_cursor = 1;
	}
	if (StartingGame && lanConfig_cursor == 2)
		lanConfig_cursor = 1;
	lanConfig_port = DEFAULTnet_hostport;
	sprintf(lanConfig_portname, "%u", lanConfig_port);

	m_return_onerror = false;
	m_return_reason[0] = 0;
}


void M_LanConfig_Draw (void)
{
	qpic_t	*p;
	int		basex;
	char	*startJoin;
	char	*protocol;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	basex = (320-p->width)/2;
	M_DrawPic (basex, 4, p);

	if (StartingGame)
		startJoin = "New Game";
	else
		startJoin = "Join Game";
	if (IPXConfig)
		protocol = "IPX";
	else
		protocol = "TCP/IP";
	M_Print (basex, 32, va ("%s - %s", startJoin, protocol));
	basex += 8;

	M_Print (basex, 52, "Address:");
	if (IPXConfig)
		M_Print (basex+9*8, 52, my_ipx_address);
	else
		M_Print (basex+9*8, 52, my_tcpip_address);

	M_Print (basex, lanConfig_cursor_table[0], "Port");
	M_DrawTextBox (basex+8*8, lanConfig_cursor_table[0]-8, 6, 1);
	M_Print (basex+9*8, lanConfig_cursor_table[0], lanConfig_portname);

	if (JoiningGame)
	{
		M_Print (basex, lanConfig_cursor_table[1], "Search for local games...");
		M_Print (basex, 108, "Join game at:");
		M_DrawTextBox (basex+8, lanConfig_cursor_table[2]-8, 22, 1);
		M_Print (basex+16, lanConfig_cursor_table[2], lanConfig_joinname);
	}
	else
	{
		M_DrawTextBox (basex, lanConfig_cursor_table[1]-8, 2, 1);
		M_Print (basex+8, lanConfig_cursor_table[1], "OK");
	}

	M_DrawCharacter (basex-8, lanConfig_cursor_table [lanConfig_cursor], 12+((int)(realtime*4)&1));

	if (lanConfig_cursor == 0)
		M_DrawCharacter (basex+9*8 + 8*strlen(lanConfig_portname), lanConfig_cursor_table [0], 10+((int)(realtime*4)&1));

	if (lanConfig_cursor == 2)
		M_DrawCharacter (basex+16 + 8*strlen(lanConfig_joinname), lanConfig_cursor_table [2], 10+((int)(realtime*4)&1));

	if (*m_return_reason)
		M_PrintWhite (basex, 148, m_return_reason);
}


void M_LanConfig_Key (int key)
{
	int		l;

	switch (key)
	{
	case K_GC_BACK:
		M_Menu_Net_f ();
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		lanConfig_cursor--;
		if (lanConfig_cursor < 0)
			lanConfig_cursor = NUM_LANCONFIG_CMDS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		lanConfig_cursor++;
		if (lanConfig_cursor >= NUM_LANCONFIG_CMDS)
			lanConfig_cursor = 0;
		break;

	case K_GC_START:
		if (lanConfig_cursor == 0)
			break;

		m_entersound = true;

		M_ConfigureNetSubsystem ();

		if (lanConfig_cursor == 1)
		{
			if (StartingGame)
			{
				M_Menu_GameOptions_f ();
				break;
			}
			M_Menu_Search_f();
			break;
		}

		if (lanConfig_cursor == 2)
		{
			m_return_state = m_state;
			m_return_onerror = true;
			key_dest = key_game;
			m_state = m_none;
			Cbuf_AddText ( va ("connect \"%s\"\n", lanConfig_joinname) );
			break;
		}

		break;

	case K_BACKSPACE:
		if (lanConfig_cursor == 0)
		{
			if (strlen(lanConfig_portname))
				lanConfig_portname[strlen(lanConfig_portname)-1] = 0;
		}

		if (lanConfig_cursor == 2)
		{
			if (strlen(lanConfig_joinname))
				lanConfig_joinname[strlen(lanConfig_joinname)-1] = 0;
		}
		break;

	default:
		if (key < 32 || key > 127)
			break;

		if (lanConfig_cursor == 2)
		{
			l = strlen(lanConfig_joinname);
			if (l < 21)
			{
				lanConfig_joinname[l+1] = 0;
				lanConfig_joinname[l] = (char)key;
			}
		}

		if (key < '0' || key > '9')
			break;
		if (lanConfig_cursor == 0)
		{
			l = strlen(lanConfig_portname);
			if (l < 5)
			{
				lanConfig_portname[l+1] = 0;
				lanConfig_portname[l] = (char)key;
			}
		}
	}

	if (StartingGame && lanConfig_cursor == 2)
		if (key == K_GC_DPAD_UP)
			lanConfig_cursor = 1;
		else
			lanConfig_cursor = 0;

	l =  Q_atoi(lanConfig_portname);
	if (l > 65535)
		l = lanConfig_port;
	else
		lanConfig_port = l;
	sprintf(lanConfig_portname, "%u", lanConfig_port);
}

//=============================================================================
/* GAME OPTIONS MENU */

typedef struct
{
	char	*name;
	char	*description;
} level_t;

level_t		levels[] =
{
	{"start", "Entrance"},	// 0

	{"e1m1", "Slipgate Complex"},				// 1
	{"e1m2", "Castle of the Damned"},
	{"e1m3", "The Necropolis"},
	{"e1m4", "The Grisly Grotto"},
	{"e1m5", "Gloom Keep"},
	{"e1m6", "The Door To Chthon"},
	{"e1m7", "The House of Chthon"},
	{"e1m8", "Ziggurat Vertigo"},

	{"e2m1", "The Installation"},				// 9
	{"e2m2", "Ogre Citadel"},
	{"e2m3", "Crypt of Decay"},
	{"e2m4", "The Ebon Fortress"},
	{"e2m5", "The Wizard's Manse"},
	{"e2m6", "The Dismal Oubliette"},
	{"e2m7", "Underearth"},

	{"e3m1", "Termination Central"},			// 16
	{"e3m2", "The Vaults of Zin"},
	{"e3m3", "The Tomb of Terror"},
	{"e3m4", "Satan's Dark Delight"},
	{"e3m5", "Wind Tunnels"},
	{"e3m6", "Chambers of Torment"},
	{"e3m7", "The Haunted Halls"},

	{"e4m1", "The Sewage System"},				// 23
	{"e4m2", "The Tower of Despair"},
	{"e4m3", "The Elder God Shrine"},
	{"e4m4", "The Palace of Hate"},
	{"e4m5", "Hell's Atrium"},
	{"e4m6", "The Pain Maze"},
	{"e4m7", "Azure Agony"},
	{"e4m8", "The Nameless City"},

	{"end", "Shub-Niggurath's Pit"},			// 31

	{"dm1", "Place of Two Deaths"},				// 32
	{"dm2", "Claustrophobopolis"},
	{"dm3", "The Abandoned Base"},
	{"dm4", "The Bad Place"},
	{"dm5", "The Cistern"},
	{"dm6", "The Dark Zone"}
};

//MED 01/06/97 added hipnotic levels
level_t     hipnoticlevels[] =
{
   {"start", "Command HQ"},  // 0

   {"hip1m1", "The Pumping Station"},          // 1
   {"hip1m2", "Storage Facility"},
   {"hip1m3", "The Lost Mine"},
   {"hip1m4", "Research Facility"},
   {"hip1m5", "Military Complex"},

   {"hip2m1", "Ancient Realms"},          // 6
   {"hip2m2", "The Black Cathedral"},
   {"hip2m3", "The Catacombs"},
   {"hip2m4", "The Crypt"},
   {"hip2m5", "Mortum's Keep"},
   {"hip2m6", "The Gremlin's Domain"},

   {"hip3m1", "Tur Torment"},       // 12
   {"hip3m2", "Pandemonium"},
   {"hip3m3", "Limbo"},
   {"hip3m4", "The Gauntlet"},

   {"hipend", "Armagon's Lair"},       // 16

   {"hipdm1", "The Edge of Oblivion"}           // 17
};

//PGM 01/07/97 added rogue levels
//PGM 03/02/97 added dmatch level
level_t		roguelevels[] =
{
	{"start",	"Split Decision"},
	{"r1m1",	"Deviant's Domain"},
	{"r1m2",	"Dread Portal"},
	{"r1m3",	"Judgement Call"},
	{"r1m4",	"Cave of Death"},
	{"r1m5",	"Towers of Wrath"},
	{"r1m6",	"Temple of Pain"},
	{"r1m7",	"Tomb of the Overlord"},
	{"r2m1",	"Tempus Fugit"},
	{"r2m2",	"Elemental Fury I"},
	{"r2m3",	"Elemental Fury II"},
	{"r2m4",	"Curse of Osiris"},
	{"r2m5",	"Wizard's Keep"},
	{"r2m6",	"Blood Sacrifice"},
	{"r2m7",	"Last Bastion"},
	{"r2m8",	"Source of Evil"},
	{"ctf1",    "Division of Change"}
};

typedef struct
{
	char	*description;
	int		firstLevel;
	int		levels;
} episode_t;

episode_t	episodes[] =
{
	{"Welcome to Quake", 0, 1},
	{"Doomed Dimension", 1, 8},
	{"Realm of Black Magic", 9, 7},
	{"Netherworld", 16, 7},
	{"The Elder World", 23, 8},
	{"Final Level", 31, 1},
	{"Deathmatch Arena", 32, 6}
};

//MED 01/06/97  added hipnotic episodes
episode_t   hipnoticepisodes[] =
{
   {"Scourge of Armagon", 0, 1},
   {"Fortress of the Dead", 1, 5},
   {"Dominion of Darkness", 6, 6},
   {"The Rift", 12, 4},
   {"Final Level", 16, 1},
   {"Deathmatch Arena", 17, 1}
};

//PGM 01/07/97 added rogue episodes
//PGM 03/02/97 added dmatch episode
episode_t	rogueepisodes[] =
{
	{"Introduction", 0, 1},
	{"Hell's Fortress", 1, 7},
	{"Corridors of Time", 8, 8},
	{"Deathmatch Arena", 16, 1}
};

int	startepisode;
int	startlevel;
int maxplayers;
qboolean m_serverInfoMessage = false;
double m_serverInfoMessageTime;

void M_Menu_GameOptions_f (void)
{
	key_dest = key_menu;
	m_state = m_gameoptions;
	m_entersound = true;
	if (maxplayers == 0)
		maxplayers = svs.maxclients;
	if (maxplayers < 2)
		maxplayers = svs.maxclientslimit;
}


int gameoptions_cursor_table[] = {40, 56, 64, 72, 80, 88, 96, 112, 120};
#define	NUM_GAMEOPTIONS	9
int		gameoptions_cursor;

void M_GameOptions_Draw (void)
{
	qpic_t	*p;
	int		x;

	M_DrawTransPic (16, 4, Draw_CachePic ("gfx/qplaque.lmp") );
	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);

	M_DrawTextBox (152, 32, 10, 1);
	M_Print (160, 40, "begin game");

	M_Print (0, 56, "      Max players");
	M_Print (160, 56, va("%i", maxplayers) );

	M_Print (0, 64, "        Game Type");
	if (coop.value)
		M_Print (160, 64, "Cooperative");
	else
		M_Print (160, 64, "Deathmatch");

	M_Print (0, 72, "        Teamplay");
	if (rogue)
	{
		char *msg;

		switch((int)teamplay.value)
		{
			case 1: msg = "No Friendly Fire"; break;
			case 2: msg = "Friendly Fire"; break;
			case 3: msg = "Tag"; break;
			case 4: msg = "Capture the Flag"; break;
			case 5: msg = "One Flag CTF"; break;
			case 6: msg = "Three Team CTF"; break;
			default: msg = "Off"; break;
		}
		M_Print (160, 72, msg);
	}
	else
	{
		char *msg;

		switch((int)teamplay.value)
		{
			case 1: msg = "No Friendly Fire"; break;
			case 2: msg = "Friendly Fire"; break;
			default: msg = "Off"; break;
		}
		M_Print (160, 72, msg);
	}

	M_Print (0, 80, "            Skill");
	if (skill.value == 0)
		M_Print (160, 80, "Easy difficulty");
	else if (skill.value == 1)
		M_Print (160, 80, "Normal difficulty");
	else if (skill.value == 2)
		M_Print (160, 80, "Hard difficulty");
	else
		M_Print (160, 80, "Nightmare difficulty");

	M_Print (0, 88, "       Frag Limit");
	if (fraglimit.value == 0)
		M_Print (160, 88, "none");
	else
		M_Print (160, 88, va("%i frags", (int)fraglimit.value));

	M_Print (0, 96, "       Time Limit");
	if (timelimit.value == 0)
		M_Print (160, 96, "none");
	else
		M_Print (160, 96, va("%i minutes", (int)timelimit.value));

	M_Print (0, 112, "         Episode");
   //MED 01/06/97 added hipnotic episodes
   if (hipnotic)
      M_Print (160, 112, hipnoticepisodes[startepisode].description);
   //PGM 01/07/97 added rogue episodes
   else if (rogue)
      M_Print (160, 112, rogueepisodes[startepisode].description);
   else
      M_Print (160, 112, episodes[startepisode].description);

	M_Print (0, 120, "           Level");
   //MED 01/06/97 added hipnotic episodes
   if (hipnotic)
   {
      M_Print (160, 120, hipnoticlevels[hipnoticepisodes[startepisode].firstLevel + startlevel].description);
      M_Print (160, 128, hipnoticlevels[hipnoticepisodes[startepisode].firstLevel + startlevel].name);
   }
   //PGM 01/07/97 added rogue episodes
   else if (rogue)
   {
      M_Print (160, 120, roguelevels[rogueepisodes[startepisode].firstLevel + startlevel].description);
      M_Print (160, 128, roguelevels[rogueepisodes[startepisode].firstLevel + startlevel].name);
   }
   else
   {
      M_Print (160, 120, levels[episodes[startepisode].firstLevel + startlevel].description);
      M_Print (160, 128, levels[episodes[startepisode].firstLevel + startlevel].name);
   }

// line cursor
	M_DrawCharacter (144, gameoptions_cursor_table[gameoptions_cursor], 12+((int)(realtime*4)&1));

	if (m_serverInfoMessage)
	{
		if ((realtime - m_serverInfoMessageTime) < 5.0)
		{
			x = (320-26*8)/2;
			M_DrawTextBox (x, 138, 24, 4);
			x += 8;
			M_Print (x, 146, "  More than 4 players   ");
			M_Print (x, 154, " requires using command ");
			M_Print (x, 162, "line parameters; please ");
			M_Print (x, 170, "   see techinfo.txt.    ");
		}
		else
		{
			m_serverInfoMessage = false;
		}
	}
}


void M_NetStart_Change (int dir)
{
	int count;

	switch (gameoptions_cursor)
	{
	case 1:
		maxplayers += dir;
		if (maxplayers > svs.maxclientslimit)
		{
			maxplayers = svs.maxclientslimit;
			m_serverInfoMessage = true;
			m_serverInfoMessageTime = realtime;
		}
		if (maxplayers < 2)
			maxplayers = 2;
		break;

	case 2:
		Cvar_SetValue ("coop", coop.value ? 0 : 1);
		break;

	case 3:
		if (rogue)
			count = 6;
		else
			count = 2;

		Cvar_SetValue ("teamplay", teamplay.value + dir);
		if (teamplay.value > count)
			Cvar_SetValue ("teamplay", 0);
		else if (teamplay.value < 0)
			Cvar_SetValue ("teamplay", count);
		break;

	case 4:
		Cvar_SetValue ("skill", skill.value + dir);
		if (skill.value > 3)
			Cvar_SetValue ("skill", 0);
		if (skill.value < 0)
			Cvar_SetValue ("skill", 3);
		break;

	case 5:
		Cvar_SetValue ("fraglimit", fraglimit.value + dir*10);
		if (fraglimit.value > 100)
			Cvar_SetValue ("fraglimit", 0);
		if (fraglimit.value < 0)
			Cvar_SetValue ("fraglimit", 100);
		break;

	case 6:
		Cvar_SetValue ("timelimit", timelimit.value + dir*5);
		if (timelimit.value > 60)
			Cvar_SetValue ("timelimit", 0);
		if (timelimit.value < 0)
			Cvar_SetValue ("timelimit", 60);
		break;

	case 7:
		startepisode += dir;
	//MED 01/06/97 added hipnotic count
		if (hipnotic)
			count = 6;
	//PGM 01/07/97 added rogue count
	//PGM 03/02/97 added 1 for dmatch episode
		else if (rogue)
			count = 4;
		else if (registered.value)
			count = 7;
		else
			count = 2;

		if (startepisode < 0)
			startepisode = count - 1;

		if (startepisode >= count)
			startepisode = 0;

		startlevel = 0;
		break;

	case 8:
		startlevel += dir;
    //MED 01/06/97 added hipnotic episodes
		if (hipnotic)
			count = hipnoticepisodes[startepisode].levels;
	//PGM 01/06/97 added hipnotic episodes
		else if (rogue)
			count = rogueepisodes[startepisode].levels;
		else
			count = episodes[startepisode].levels;

		if (startlevel < 0)
			startlevel = count - 1;

		if (startlevel >= count)
			startlevel = 0;
		break;
	}
}

void M_GameOptions_Key (int key)
{
	switch (key)
	{
	case K_GC_BACK:
		M_Menu_Net_f ();
		break;

	case K_GC_DPAD_UP:
		S_LocalSound ("misc/menu1.wav");
		gameoptions_cursor--;
		if (gameoptions_cursor < 0)
			gameoptions_cursor = NUM_GAMEOPTIONS-1;
		break;

	case K_GC_DPAD_DOWN:
		S_LocalSound ("misc/menu1.wav");
		gameoptions_cursor++;
		if (gameoptions_cursor >= NUM_GAMEOPTIONS)
			gameoptions_cursor = 0;
		break;

	case K_GC_DPAD_LEFT:
		if (gameoptions_cursor == 0)
			break;
		S_LocalSound ("misc/menu3.wav");
		M_NetStart_Change (-1);
		break;

	case K_GC_DPAD_RIGHT:
		if (gameoptions_cursor == 0)
			break;
		S_LocalSound ("misc/menu3.wav");
		M_NetStart_Change (1);
		break;

	case K_GC_START:
		S_LocalSound ("misc/menu2.wav");
		if (gameoptions_cursor == 0)
		{
			if (sv.active)
				Cbuf_AddText ("disconnect\n");
			Cbuf_AddText ("listen 0\n");	// so host_netport will be re-examined
			Cbuf_AddText ( va ("maxplayers %u\n", maxplayers) );
			SCR_BeginLoadingPlaque ();

			if (hipnotic)
				Cbuf_AddText ( va ("map %s\n", hipnoticlevels[hipnoticepisodes[startepisode].firstLevel + startlevel].name) );
			else if (rogue)
				Cbuf_AddText ( va ("map %s\n", roguelevels[rogueepisodes[startepisode].firstLevel + startlevel].name) );
			else
				Cbuf_AddText ( va ("map %s\n", levels[episodes[startepisode].firstLevel + startlevel].name) );

			return;
		}

		M_NetStart_Change (1);
		break;
	}
}

//=============================================================================
/* SEARCH MENU */

qboolean	searchComplete = false;
double		searchCompleteTime;

void M_Menu_Search_f (void)
{
	key_dest = key_menu;
	m_state = m_search;
	m_entersound = false;
	slistSilent = true;
	slistLocal = false;
	searchComplete = false;
	NET_Slist_f();

}


void M_Search_Draw (void)
{
	qpic_t	*p;
	int x;

	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);
	x = (320/2) - ((12*8)/2) + 4;
	M_DrawTextBox (x-8, 32, 12, 1);
	M_Print (x, 40, "Searching...");

	if(slistInProgress)
	{
		NET_Poll();
		return;
	}

	if (! searchComplete)
	{
		searchComplete = true;
		searchCompleteTime = realtime;
	}

	if (hostCacheCount)
	{
		M_Menu_ServerList_f ();
		return;
	}

	M_PrintWhite ((320/2) - ((22*8)/2), 64, "No Quake servers found");
	if ((realtime - searchCompleteTime) < 3.0)
		return;

	M_Menu_LanConfig_f ();
}


void M_Search_Key (int key)
{
}

//=============================================================================
/* SLIST MENU */

int		slist_cursor;
qboolean slist_sorted;

void M_Menu_ServerList_f (void)
{
	key_dest = key_menu;
	m_state = m_slist;
	m_entersound = true;
	slist_cursor = 0;
	m_return_onerror = false;
	m_return_reason[0] = 0;
	slist_sorted = false;
}


void M_ServerList_Draw (void)
{
	int		n;
	char	string [64];
	qpic_t	*p;

	if (!slist_sorted)
	{
		if (hostCacheCount > 1)
		{
			int	i,j;
			hostcache_t temp;
			for (i = 0; i < hostCacheCount; i++)
				for (j = i+1; j < hostCacheCount; j++)
					if (strcmp(hostcache[j].name, hostcache[i].name) < 0)
					{
						Q_memcpy(&temp, &hostcache[j], sizeof(hostcache_t));
						Q_memcpy(&hostcache[j], &hostcache[i], sizeof(hostcache_t));
						Q_memcpy(&hostcache[i], &temp, sizeof(hostcache_t));
					}
		}
		slist_sorted = true;
	}

	p = Draw_CachePic ("gfx/p_multi.lmp");
	M_DrawPic ( (320-p->width)/2, 4, p);
	for (n = 0; n < hostCacheCount; n++)
	{
		if (hostcache[n].maxusers)
			sprintf(string, "%-15.15s %-15.15s %2u/%2u\n", hostcache[n].name, hostcache[n].map, hostcache[n].users, hostcache[n].maxusers);
		else
			sprintf(string, "%-15.15s %-15.15s\n", hostcache[n].name, hostcache[n].map);
		M_Print (16, 32 + 8*n, string);
	}
	M_DrawCharacter (0, 32 + slist_cursor*8, 12+((int)(realtime*4)&1));

	if (*m_return_reason)
		M_PrintWhite (16, 148, m_return_reason);
}


void M_ServerList_Key (int k)
{
	switch (k)
	{
	case K_GC_BACK:
		M_Menu_LanConfig_f ();
		break;

	case K_GC_LEFT_TRIGGER:
		M_Menu_Search_f ();
		break;

	case K_GC_DPAD_UP:
	case K_GC_DPAD_LEFT:
		S_LocalSound ("misc/menu1.wav");
		slist_cursor--;
		if (slist_cursor < 0)
			slist_cursor = hostCacheCount - 1;
		break;

	case K_GC_DPAD_DOWN:
	case K_GC_DPAD_RIGHT:
		S_LocalSound ("misc/menu1.wav");
		slist_cursor++;
		if (slist_cursor >= hostCacheCount)
			slist_cursor = 0;
		break;

	case K_GC_START:
		S_LocalSound ("misc/menu2.wav");
		m_return_state = m_state;
		m_return_onerror = true;
		slist_sorted = false;
		key_dest = key_game;
		m_state = m_none;
		Cbuf_AddText ( va ("connect \"%s\"\n", hostcache[slist_cursor].cname) );
		break;

	default:
		break;
	}

}

//=============================================================================
/* Menu Subsystem */


void M_Init (void)
{
	Cmd_AddCommand ("togglemenu", M_ToggleMenu_f);

	Cmd_AddCommand ("menu_main", M_Menu_Main_f);
	Cmd_AddCommand ("menu_singleplayer", M_Menu_SinglePlayer_f);
	Cmd_AddCommand ("menu_load", M_Menu_Load_f);
	Cmd_AddCommand ("menu_save", M_Menu_Save_f);
	Cmd_AddCommand ("menu_multiplayer", M_Menu_MultiPlayer_f);
	Cmd_AddCommand ("menu_setup", M_Menu_Setup_f);
	Cmd_AddCommand ("menu_options", M_Menu_Options_f);
	Cmd_AddCommand ("menu_keys", M_Menu_Keys_f);
	Cmd_AddCommand ("menu_video", M_Menu_Video_f);
	Cmd_AddCommand ("help", M_Menu_Help_f);
	Cmd_AddCommand ("menu_quit", M_Menu_Quit_f);
}


void M_Draw (void)
{
	if (m_state == m_none || key_dest != key_menu)
		return;

	if (!m_recursiveDraw)
	{
		scr_copyeverything = 1;

		if (scr_con_current)
		{
			Draw_ConsoleBackground (vid.height);
			VID_UnlockBuffer ();
			S_ExtraUpdate ();
			VID_LockBuffer ();
		}
		else
			Draw_FadeScreen ();

		scr_fullupdate = 0;
	}
	else
	{
		m_recursiveDraw = false;
	}

	switch (m_state)
	{
	case m_none:
		break;

	case m_main:
		M_Main_Draw ();
		break;

	case m_singleplayer:
		M_SinglePlayer_Draw ();
		break;

	case m_load:
		M_Load_Draw ();
		break;

	case m_save:
		M_Save_Draw ();
		break;

	case m_multiplayer:
		M_MultiPlayer_Draw ();
		break;

	case m_setup:
		M_Setup_Draw ();
		break;

	case m_net:
		M_Net_Draw ();
		break;

	case m_options:
		M_Options_Draw ();
		break;

	case m_keys:
		M_Keys_Draw ();
		break;

	case m_video:
		M_Video_Draw ();
		break;

	case m_help:
		M_Help_Draw ();
		break;

	case m_quit:
		M_Quit_Draw ();
		break;

	case m_serialconfig:
		M_SerialConfig_Draw ();
		break;

	case m_modemconfig:
		M_ModemConfig_Draw ();
		break;

	case m_lanconfig:
		M_LanConfig_Draw ();
		break;

	case m_gameoptions:
		M_GameOptions_Draw ();
		break;

	case m_search:
		M_Search_Draw ();
		break;

	case m_slist:
		M_ServerList_Draw ();
		break;
	}

	if (m_entersound)
	{
		S_LocalSound ("misc/menu2.wav");
		m_entersound = false;
	}

	VID_UnlockBuffer ();
	S_ExtraUpdate ();
	VID_LockBuffer ();
}


void M_Keydown (int key)
{
	switch (m_state)
	{
	case m_none:
		return;

	case m_main:
		M_Main_Key (key);
		return;

	case m_singleplayer:
		M_SinglePlayer_Key (key);
		return;

	case m_load:
		M_Load_Key (key);
		return;

	case m_save:
		M_Save_Key (key);
		return;

	case m_multiplayer:
		M_MultiPlayer_Key (key);
		return;

	case m_setup:
		M_Setup_Key (key);
		return;

	case m_net:
		M_Net_Key (key);
		return;

	case m_options:
		M_Options_Key (key);
		return;

	case m_keys:
		M_Keys_Key (key);
		return;

	case m_video:
		M_Video_Key (key);
		return;

	case m_help:
		M_Help_Key (key);
		return;

	case m_quit:
		M_Quit_Key (key);
		return;

	case m_serialconfig:
		M_SerialConfig_Key (key);
		return;

	case m_modemconfig:
		M_ModemConfig_Key (key);
		return;

	case m_lanconfig:
		M_LanConfig_Key (key);
		return;

	case m_gameoptions:
		M_GameOptions_Key (key);
		return;

	case m_search:
		M_Search_Key (key);
		break;

	case m_slist:
		M_ServerList_Key (key);
		return;
	}
}


void M_ConfigureNetSubsystem(void)
{
// enable/disable net systems to match desired config

	Cbuf_AddText ("stopdemo\n");
	if (SerialConfig || DirectConfig)
	{
		Cbuf_AddText ("com1 enable\n");
	}

	if (IPXConfig || TCPIPConfig)
		net_hostport = lanConfig_port;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\keys.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "quakedef.h"

/*

key up events are sent even if in console mode

*/


#define		MAXCMDLINE	256
char	key_lines[32][MAXCMDLINE];
int		key_linepos;
int		shift_down=false;
int		key_lastpress;

int		edit_line=0;
int		history_line=0;

keydest_t	key_dest;

int		key_count;			// incremented every key event

char	*keybindings[256];
qboolean	consolekeys[256];	// if true, can't be rebound while in console
qboolean	menubound[256];	// if true, can't be rebound while in menu
int		keyshift[256];		// key to map to if shift held down in console
int		key_repeats[256];	// if > 1, it is autorepeating
qboolean	keydown[256];

typedef struct
{
	char	*name;
	int		keynum;
} keyname_t;

keyname_t keynames[] =
{
	{"TAB", K_TAB},
	{"ENTER", K_ENTER},
	{"ESCAPE", K_ESCAPE},
	{"SPACE", K_SPACE},
	{"BACKSPACE", K_BACKSPACE},
	{"UPARROW", K_UPARROW},
	{"DOWNARROW", K_DOWNARROW},
	{"LEFTARROW", K_LEFTARROW},
	{"RIGHTARROW", K_RIGHTARROW},

	{"ALT", K_ALT},
	{"CTRL", K_CTRL},
	{"SHIFT", K_SHIFT},
	
	{"F1", K_F1},
	{"F2", K_F2},
	{"F3", K_F3},
	{"F4", K_F4},
	{"F5", K_F5},
	{"F6", K_F6},
	{"F7", K_F7},
	{"F8", K_F8},
	{"F9", K_F9},
	{"F10", K_F10},
	{"F11", K_F11},
	{"F12", K_F12},

	{"INS", K_INS},
	{"DEL", K_DEL},
	{"PGDN", K_PGDN},
	{"PGUP", K_PGUP},
	{"HOME", K_HOME},
	{"END", K_END},

	{"MOUSE1", K_MOUSE1},
	{"MOUSE2", K_MOUSE2},
	{"MOUSE3", K_MOUSE3},

	{"JOY1", K_JOY1},
	{"JOY2", K_JOY2},
	{"JOY3", K_JOY3},
	{"JOY4", K_JOY4},

	{"AUX1", K_AUX1},
	{"AUX2", K_AUX2},
	{"AUX3", K_AUX3},

    {"DPADUP", K_GC_DPAD_UP},
    {"DPADDOWN", K_GC_DPAD_DOWN},
    {"DPADLEFT", K_GC_DPAD_LEFT},
    {"DPADRIGHT", K_GC_DPAD_RIGHT},
    {"START", K_GC_START},
    {"BACK", K_GC_BACK},
    {"LEFTTHUMB", K_GC_LEFT_THUMB},
    {"RIGHTTHUMB", K_GC_RIGHT_THUMB},
    {"GPA", K_GC_A},
    {"GPB", K_GC_B},
    {"GPX", K_GC_X},
    {"GPY", K_GC_Y},
    {"BLACK", K_GC_BLACK},
    {"WHITE", K_GC_WHITE},
    {"LEFTTRIGGER", K_GC_LEFT_TRIGGER},
    {"RIGHTTRIGGER", K_GC_RIGHT_TRIGGER},

    {"AUX20", K_AUX20},
	{"AUX21", K_AUX21},
	{"AUX22", K_AUX22},
	{"AUX23", K_AUX23},
	{"AUX24", K_AUX24},
	{"AUX25", K_AUX25},
	{"AUX26", K_AUX26},
	{"AUX27", K_AUX27},
	{"AUX28", K_AUX28},
	{"AUX29", K_AUX29},
	{"AUX30", K_AUX30},
	{"AUX31", K_AUX31},
	{"AUX32", K_AUX32},

	{"PAUSE", K_PAUSE},

	{"MWHEELUP", K_MWHEELUP},
	{"MWHEELDOWN", K_MWHEELDOWN},

	{"SEMICOLON", ';'},	// because a raw semicolon seperates commands

	{NULL,0}
};

int Key_StringToKeynum (char *str);

// Cheat codes
// Syntax of cheat codes:
// bind $GPA,GPB,GPX foo

#define MAXCHEATCODELENGTH 16
#define MAXCHEATCODES 20

// What the user has typed in so far
int CheatCodeBuffer[MAXCHEATCODELENGTH];
int CheatCodeBufferLength;

typedef struct {
	int code[MAXCHEATCODELENGTH];
	int codeLength;
	char* binding;
} CheatCode;

CheatCode CheatCodeBindings[MAXCHEATCODES];
int CheatCodeNumCodes;

void CheatCode_StringToCheatCode(const char* s, CheatCode* code){
	char tmp[1024];
	int i,len;
	char* token;
	Q_strncpy(tmp, (char*) s, sizeof(tmp));
	tmp[sizeof(tmp)-1] = 0; // Always zero terminate
	len = strlen(tmp);
	for(i = 0; i < len; i++){
		if(tmp[i] == ','){
			tmp[i] = '\0';
		}
	}
	code->codeLength = 0;
	// Now run through tokens, turning them into key codes
	token = tmp;
	for(i = 1; i <= len; i++){
		if(tmp[i] == '\0'){
			int b = Key_StringToKeynum (token);
			if ( b == -1 ) {
				Con_Printf ("Code key %d, \"%s\" isn't a valid key\n", code->codeLength, token);
				return;
			}
			if ( code->codeLength >= MAXCHEATCODELENGTH ) {
				Con_Printf ("Code too long. %d keys max: \"%s\"\n", s, MAXCHEATCODELENGTH);
				return;
			}
			code->code[code->codeLength++] = b;
			token = &tmp[i+1];
		}
	}
}

void CheatCode_ToString(const CheatCode* pCheat, char* string, int count){
	int i;
	int codeLen = pCheat->codeLength;
	int stringLen = 0;

	string[0] = 0;

	for(i = 0; i < codeLen; i++){
		char* keyString = Key_KeynumToString(pCheat->code[i]);
		int keyLength = Q_strlen(keyString);
		if ( i > 0 ) {
			keyLength++;
		}
		if (stringLen + keyLength + 1 > count) {
			break; // Out of buffer space
		}
		if ( i > 0 ) {
			Q_strcat(string, ",");
		}
		Q_strcat(string, keyString);
		stringLen += keyLength;
	}
	string[stringLen] = 0;
}

void CheatCode_SetBinding (CheatCode* code, const char *binding)
{
	char	*new;
	int		l;
			
// free old bindings
	if (code->binding)
	{
		Z_Free (code->binding);
		code->binding = NULL;
	}
			
// allocate memory for new binding
	l = Q_strlen ((char*) binding);	
	new = Z_Malloc (l+1);
	Q_strcpy (new, (char*) binding);
	new[l] = 0;
	code->binding = new;	
}

int CheatCode_Equal(const CheatCode* a, const CheatCode* b){
	int length;
	int i;
	if ( a->codeLength != b->codeLength ) {
		return 0;
	}
	length = a->codeLength;
	for(i = 0; i < length; i++){
		if ( a->code[i] != b->code[i] ) {
			return 0;
		}
	}
	return 1;
}

CheatCode* CheatCode_Find(const char* cheatCodeDecl){
	CheatCode tempCode;
	int i;
	CheatCode_StringToCheatCode(cheatCodeDecl, &tempCode);
	for(i = 0; i < CheatCodeNumCodes; i++){
		if ( CheatCode_Equal(&CheatCodeBindings[i], &tempCode)) {
			return &CheatCodeBindings[i];
		}
	}
	return (CheatCode*) 0;
}

void CheatCode_Bind(void){
	char* cheatCodeDecl;
	CheatCode* pCode;
	int c = Cmd_Argc();

	if ( c < 2 || c > 3 ) {
		Con_Printf ("bind $cheat-code command\n" );
		return;
	}

	// Skip leading '$'
	cheatCodeDecl = &Cmd_Argv(1)[1];

	// Look up the code
	pCode = CheatCode_Find(cheatCodeDecl);

	if (c == 2)
	{
		if ( pCode ) {
			Con_Printf ("\"%s\" = \"%s\"\n", cheatCodeDecl, pCode->binding );
		}
		else
			Con_Printf ("\"%s\" is not bound\n", cheatCodeDecl );
		return;
	}

	// Is this a new code?

	if ( !pCode ) {
		if ( CheatCodeNumCodes >= MAXCHEATCODES ) {
			Con_Printf("Only room for %d cheat codes.\n", MAXCHEATCODES);
			return;
		}
		pCode = &CheatCodeBindings[CheatCodeNumCodes++];
	}

	{
		char cmd[1024];
		int i;
		CheatCode_StringToCheatCode(cheatCodeDecl, pCode);
		// copy the rest of the command line
		cmd[0] = 0;		// start out with a null string
		for (i=2 ; i< c ; i++)
		{
			if (i > 2)
				strcat (cmd, " ");
			strcat (cmd, Cmd_Argv(i));
		}
		CheatCode_SetBinding( pCode, cmd);
	}
}

void CheatCode_UnbindAll(){
	// To be implemented
}


void CheatCode_Event(int key){
	// Update cheat code buffer
	if ( CheatCodeBufferLength == MAXCHEATCODELENGTH) {
		// throw out oldest event
		int i;
		for(i = 1; i < CheatCodeBufferLength; i++){
			CheatCodeBuffer[i-1] = CheatCodeBuffer[i];
		}
		CheatCodeBufferLength--;
	}

	// Add latest event
	CheatCodeBuffer[CheatCodeBufferLength++] = key;

	// Does this match any cheat codes?
	{
		int i;
		for(i = 0; i < CheatCodeNumCodes; i++){
			const CheatCode* code = &CheatCodeBindings[i];
			int j;
			int codeLength = code->codeLength;
			if ( codeLength > CheatCodeBufferLength ){
				continue;
			}
			for(j = 0; j < codeLength; j++){
				if ( code->code[j] != CheatCodeBuffer[CheatCodeBufferLength - codeLength + j] ) {
					goto tryNextCode;
				}
			}
			// We have a match
			{
				char temp[1024];
				CheatCode_ToString(code, temp, sizeof(temp));
				Con_Printf("Cheat code \"%s\"\n", temp);
				Con_Printf("  executing \"%s\"\n", code->binding);
			}
			Cbuf_AddText (code->binding);
			Cbuf_AddText ("\n");
			// Clear cheat buffer
			CheatCodeBufferLength = 0;
			break;
tryNextCode: ;
		}
	}
}

void CheatCode_WriteBindings (FILE *f)
{
	int		i;

	for (i=0 ; i<CheatCodeNumCodes ; i++) {
		char temp[1024];
		const CheatCode* pCheat = &CheatCodeBindings[i];
		CheatCode_ToString(pCheat, temp, sizeof(temp));
		fprintf (f, "bind \"$%s\" \"%s\"\n", temp, pCheat->binding);
	}
}

/*
==============================================================================

			LINE TYPING INTO THE CONSOLE

==============================================================================
*/


/*
====================
Key_Console

Interactive line editing and console scrollback
====================
*/
void Key_Console (int key)
{
	char	*cmd;
	
	if (key == K_ENTER)
	{
		Cbuf_AddText (key_lines[edit_line]+1);	// skip the >
		Cbuf_AddText ("\n");
		Con_Printf ("%s\n",key_lines[edit_line]);
		edit_line = (edit_line + 1) & 31;
		history_line = edit_line;
		key_lines[edit_line][0] = ']';
		key_linepos = 1;
		if (cls.state == ca_disconnected)
			SCR_UpdateScreen ();	// force an update, because the command
									// may take some time
		return;
	}

	if (key == K_TAB)
	{	// command completion
		cmd = Cmd_CompleteCommand (key_lines[edit_line]+1);
		if (!cmd)
			cmd = Cvar_CompleteVariable (key_lines[edit_line]+1);
		if (cmd)
		{
			Q_strcpy (key_lines[edit_line]+1, cmd);
			key_linepos = Q_strlen(cmd)+1;
			key_lines[edit_line][key_linepos] = ' ';
			key_linepos++;
			key_lines[edit_line][key_linepos] = 0;
			return;
		}
	}
	
	if (key == K_GC_BACK || key == K_GC_DPAD_LEFT)
	{
		if (key_linepos > 1)
			key_linepos--;
		return;
	}

	if (key == K_GC_DPAD_UP)
	{
		do
		{
			history_line = (history_line - 1) & 31;
		} while (history_line != edit_line
				&& !key_lines[history_line][1]);
		if (history_line == edit_line)
			history_line = (edit_line+1)&31;
		Q_strcpy(key_lines[edit_line], key_lines[history_line]);
		key_linepos = Q_strlen(key_lines[edit_line]);
		return;
	}

	if (key == K_GC_DPAD_DOWN)
	{
		if (history_line == edit_line) return;
		do
		{
			history_line = (history_line + 1) & 31;
		}
		while (history_line != edit_line
			&& !key_lines[history_line][1]);
		if (history_line == edit_line)
		{
			key_lines[edit_line][0] = ']';
			key_linepos = 1;
		}
		else
		{
			Q_strcpy(key_lines[edit_line], key_lines[history_line]);
			key_linepos = Q_strlen(key_lines[edit_line]);
		}
		return;
	}

	if (key == K_PGUP || key==K_MWHEELUP)
	{
		con_backscroll += 2;
		if (con_backscroll > con_totallines - (vid.height>>3) - 1)
			con_backscroll = con_totallines - (vid.height>>3) - 1;
		return;
	}

	if (key == K_PGDN || key==K_MWHEELDOWN)
	{
		con_backscroll -= 2;
		if (con_backscroll < 0)
			con_backscroll = 0;
		return;
	}

	if (key == K_HOME)
	{
		con_backscroll = con_totallines - (vid.height>>3) - 1;
		return;
	}

	if (key == K_END)
	{
		con_backscroll = 0;
		return;
	}
	
	if (key < 32 || key > 127)
		return;	// non printable
		
	if (key_linepos < MAXCMDLINE-1)
	{
		key_lines[edit_line][key_linepos] = (char)key;
		key_linepos++;
		key_lines[edit_line][key_linepos] = 0;
	}

}

//============================================================================

char chat_buffer[32];
qboolean team_message = false;

void Key_Message (int key)
{
	static int chat_bufferlen = 0;

	if (key == K_ENTER)
	{
		if (team_message)
			Cbuf_AddText ("say_team \"");
		else
			Cbuf_AddText ("say \"");
		Cbuf_AddText(chat_buffer);
		Cbuf_AddText("\"\n");

		key_dest = key_game;
		chat_bufferlen = 0;
		chat_buffer[0] = 0;
		return;
	}

	if (key == K_ESCAPE)
	{
		key_dest = key_game;
		chat_bufferlen = 0;
		chat_buffer[0] = 0;
		return;
	}

	if (key < 32 || key > 127)
		return;	// non printable

	if (key == K_BACKSPACE)
	{
		if (chat_bufferlen)
		{
			chat_bufferlen--;
			chat_buffer[chat_bufferlen] = 0;
		}
		return;
	}

	if (chat_bufferlen == 31)
		return; // all full

	chat_buffer[chat_bufferlen++] = (char)key;
	chat_buffer[chat_bufferlen] = 0;
}

//============================================================================


/*
===================
Key_StringToKeynum

Returns a key number to be used to index keybindings[] by looking at
the given string.  Single ascii characters return themselves, while
the K_* names are matched up.
===================
*/
int Key_StringToKeynum (char *str)
{
	keyname_t	*kn;
	
	if (!str || !str[0])
		return -1;
	if (!str[1])
		return str[0];

	for (kn=keynames ; kn->name ; kn++)
	{
		if (!Q_strcasecmp(str,kn->name))
			return kn->keynum;
	}
	return -1;
}

/*
===================
Key_KeynumToString

Returns a string (either a single ascii char, or a K_* name) for the
given keynum.
FIXME: handle quote special (general escape sequence?)
===================
*/
char *Key_KeynumToString (int keynum)
{
	keyname_t	*kn;	
	static	char	tinystr[2];
	
	if (keynum == -1)
		return "<KEY NOT FOUND>";
	if (keynum > 32 && keynum < 127)
	{	// printable ascii
		tinystr[0] = (char)keynum;
		tinystr[1] = 0;
		return tinystr;
	}
	
	for (kn=keynames ; kn->name ; kn++)
		if (keynum == kn->keynum)
			return kn->name;

	return "<UNKNOWN KEYNUM>";
}


/*
===================
Key_SetBinding
===================
*/
void Key_SetBinding (int keynum, char *binding)
{
	char	*new;
	int		l;
			
	if (keynum == -1)
		return;

// free old bindings
	if (keybindings[keynum])
	{
		Z_Free (keybindings[keynum]);
		keybindings[keynum] = NULL;
	}
			
// allocate memory for new binding
	l = Q_strlen (binding);	
	new = Z_Malloc (l+1);
	Q_strcpy (new, binding);
	new[l] = 0;
	keybindings[keynum] = new;	
}

/*
===================
Key_Unbind_f
===================
*/
void Key_Unbind_f (void)
{
	int		b;

	if (Cmd_Argc() != 2)
	{
		Con_Printf ("unbind <key> : remove commands from a key\n");
		return;
	}
	
	b = Key_StringToKeynum (Cmd_Argv(1));
	if (b==-1)
	{
		Con_Printf ("\"%s\" isn't a valid key\n", Cmd_Argv(1));
		return;
	}

	Key_SetBinding (b, "");
}

void Key_Unbindall_f (void)
{
	int		i;
	
	for (i=0 ; i<256 ; i++)
		if (keybindings[i])
			Key_SetBinding (i, "");

	CheatCode_UnbindAll();
}


/*
===================
Key_Bind_f
===================
*/
void Key_Bind_f (void)
{
	int			i, c, b;
	char		cmd[1024];
	
	c = Cmd_Argc();

	if (c != 2 && c != 3)
	{
		Con_Printf ("bind <key> [command] : attach a command to a key\n");
		return;
	}
	if ( Cmd_Argv(1)[0] == '$' ) {
		CheatCode_Bind();
		return;
	}
	b = Key_StringToKeynum (Cmd_Argv(1));
	if (b==-1)
	{
		Con_Printf ("\"%s\" isn't a valid key\n", Cmd_Argv(1));
		return;
	}

	if (c == 2)
	{
		if (keybindings[b])
			Con_Printf ("\"%s\" = \"%s\"\n", Cmd_Argv(1), keybindings[b] );
		else
			Con_Printf ("\"%s\" is not bound\n", Cmd_Argv(1) );
		return;
	}
	
// copy the rest of the command line
	cmd[0] = 0;		// start out with a null string
	for (i=2 ; i< c ; i++)
	{
		if (i > 2)
			strcat (cmd, " ");
		strcat (cmd, Cmd_Argv(i));
	}

	Key_SetBinding (b, cmd);
}

/*
============
Key_WriteBindings

Writes lines containing "bind key value"
============
*/
void Key_WriteBindings (FILE *f)
{
	int		i;

	for (i=0 ; i<256 ; i++)
		if (keybindings[i])
			if (*keybindings[i])
				fprintf (f, "bind \"%s\" \"%s\"\n", Key_KeynumToString(i), keybindings[i]);
	CheatCode_WriteBindings(f);
}


/*
===================
Key_Init
===================
*/
void Key_Init (void)
{
	int		i;

	for (i=0 ; i<32 ; i++)
	{
		key_lines[i][0] = ']';
		key_lines[i][1] = 0;
	}
	key_linepos = 1;
	
//
// init ascii characters in console mode
//
	for (i=32 ; i<128 ; i++)
		consolekeys[i] = true;
	consolekeys[K_ENTER] = true;
	consolekeys[K_TAB] = true;
	consolekeys[K_GC_DPAD_LEFT] = true;
	consolekeys[K_GC_DPAD_RIGHT] = true;
	consolekeys[K_GC_DPAD_UP] = true;
	consolekeys[K_GC_DPAD_DOWN] = true;
	consolekeys[K_GC_BACK] = true;
	consolekeys[K_PGUP] = true;
	consolekeys[K_PGDN] = true;
	consolekeys[K_SHIFT] = true;
	consolekeys['`'] = false;
	consolekeys['~'] = false;

	for (i=0 ; i<256 ; i++)
		keyshift[i] = i;
	for (i='a' ; i<='z' ; i++)
		keyshift[i] = i - 'a' + 'A';
	keyshift['1'] = '!';
	keyshift['2'] = '@';
	keyshift['3'] = '#';
	keyshift['4'] = '$';
	keyshift['5'] = '%';
	keyshift['6'] = '^';
	keyshift['7'] = '&';
	keyshift['8'] = '*';
	keyshift['9'] = '(';
	keyshift['0'] = ')';
	keyshift['-'] = '_';
	keyshift['='] = '+';
	keyshift[','] = '<';
	keyshift['.'] = '>';
	keyshift['/'] = '?';
	keyshift[';'] = ':';
	keyshift['\''] = '"';
	keyshift['['] = '{';
	keyshift[']'] = '}';
	keyshift['`'] = '~';
	keyshift['\\'] = '|';

	menubound[K_ESCAPE] = true;
	for (i=0 ; i<12 ; i++)
		menubound[K_F1+i] = true;

//
// register our functions
//
	Cmd_AddCommand ("bind",Key_Bind_f);
	Cmd_AddCommand ("unbind",Key_Unbind_f);
	Cmd_AddCommand ("unbindall",Key_Unbindall_f);

}

/*
===================
Key_Event

Called by the system between frames for both key up and key down events
Should NOT be called during an interrupt!
===================
*/
void Key_Event (int key, qboolean down)
{
    char	*kb;
	char	cmd[1024];
    
	keydown[key] = down;

	if (!down)
		key_repeats[key] = 0;

	key_lastpress = key;
	key_count++;
	if (key_count <= 0)
	{
		return;		// just catching keys for Con_NotifyBox
	}

// update auto-repeat status
	if (down)
	{
		key_repeats[key]++;
		if (key != K_BACKSPACE && key != K_PAUSE && key_repeats[key] > 1)
		{
			return;	// ignore most autorepeats
		}
			
		if (key >= 200 && !keybindings[key])
			Con_Printf ("%s is unbound, hit F4 to set.\n", Key_KeynumToString (key) );
	}

	if (key == K_SHIFT)
		shift_down = down;

//
// handle escape specialy, so the user can never unbind it
//
	if (key == K_ESCAPE)
	{
		if (!down)
			return;
		switch (key_dest)
		{
		case key_message:
			Key_Message (key);
			break;
		case key_menu:
			M_Keydown (key);
			break;
		case key_game:
		case key_console:
			M_ToggleMenu_f ();
			break;
		default:
			Sys_Error ("Bad key_dest");
		}
		return;
	}

	// Holding down both BACK and START toggles the console
	if ( (key == K_GC_BACK || key == K_GC_START) && down
		&& keydown[K_GC_BACK] && keydown[K_GC_START]) {
		Con_ToggleConsole_f ();
		return;
	}

//
// key up events only generate commands if the game key binding is
// a button command (leading + sign).  These will occur even in console mode,
// to keep the character from continuing an action started before a console
// switch.  Button commands include the kenum as a parameter, so multiple
// downs can be matched with ups
//
	if (!down)
	{
		kb = keybindings[key];
		if (kb && kb[0] == '+')
		{
			sprintf (cmd, "-%s %i\n", kb+1, key);
			Cbuf_AddText (cmd);
		}
		if (keyshift[key] != key)
		{
			kb = keybindings[keyshift[key]];
			if (kb && kb[0] == '+')
			{
				sprintf (cmd, "-%s %i\n", kb+1, key);
				Cbuf_AddText (cmd);
			}
		}
		return;
	}

//
// during demo playback, most keys bring up the main menu
//
	if (cls.demoplayback && down && consolekeys[key] && key_dest == key_game)
	{
		M_ToggleMenu_f ();
		return;
	}

//
// if not a consolekey, send to the interpreter no matter what mode is
//
	if ( (key_dest == key_menu && menubound[key])
	|| (key_dest == key_console && !consolekeys[key])
	|| (key_dest == key_game && ( !con_forcedup || !consolekeys[key] ) ) )
	{
		kb = keybindings[key];
		if (kb)
		{
			if (kb[0] == '+')
			{	// button commands add keynum as a parm
				sprintf (cmd, "%s %i\n", kb, key);
				Cbuf_AddText (cmd);
			}
			else
			{
				Cbuf_AddText (kb);
				Cbuf_AddText ("\n");
			}
		}
		CheatCode_Event(key);
		return;
	}

	if (!down)
		return;		// other systems only care about key down events

	if (shift_down)
	{
		key = keyshift[key];
	}

	switch (key_dest)
	{
	case key_message:
		Key_Message (key);
		break;
	case key_menu:
		M_Keydown (key);
		break;

	case key_game:
	case key_console:
		Key_Console (key);
		break;
	default:
		Sys_Error ("Bad key_dest");
	}
}


/*
===================
Key_ClearStates
===================
*/
void Key_ClearStates (void)
{
	int		i;

	for (i=0 ; i<256 ; i++)
	{
		keydown[i] = false;
		key_repeats[i] = 0;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\mathlib.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// mathlib.h

typedef float vec_t;
typedef vec_t vec3_t[3];
typedef vec_t vec5_t[5];

typedef	int	fixed4_t;
typedef	int	fixed8_t;
typedef	int	fixed16_t;

#ifndef M_PI
#define M_PI		3.14159265358979323846	// matches value in gcc v2 math.h
#endif

struct mplane_s;

extern vec3_t vec3_origin;
extern	int nanmask;

#define	IS_NAN(x) (((*(int *)&x)&nanmask)==nanmask)

#define DotProduct(x,y) (x[0]*y[0]+x[1]*y[1]+x[2]*y[2])
#define VectorSubtract(a,b,c) {c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];}
#define VectorAdd(a,b,c) {c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];}
#define VectorCopy(a,b) {b[0]=a[0];b[1]=a[1];b[2]=a[2];}

void VectorMA (vec3_t veca, float scale, vec3_t vecb, vec3_t vecc);

vec_t _DotProduct (vec3_t v1, vec3_t v2);
void _VectorSubtract (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorAdd (vec3_t veca, vec3_t vecb, vec3_t out);
void _VectorCopy (vec3_t in, vec3_t out);

int VectorCompare (vec3_t v1, vec3_t v2);
vec_t Length (vec3_t v);
void CrossProduct (vec3_t v1, vec3_t v2, vec3_t cross);
float VectorNormalize (vec3_t v);		// returns vector length
void VectorInverse (vec3_t v);
void VectorScale (vec3_t in, vec_t scale, vec3_t out);
int Q_log2(int val);

void R_ConcatRotations (float in1[3][3], float in2[3][3], float out[3][3]);
void R_ConcatTransforms (float in1[3][4], float in2[3][4], float out[3][4]);

void FloorDivMod (double numer, double denom, int *quotient,
		int *rem);
fixed16_t Invert24To16(fixed16_t val);
int GreatestCommonDivisor (int i1, int i2);

void AngleVectors (vec3_t angles, vec3_t forward, vec3_t right, vec3_t up);
int BoxOnPlaneSide (vec3_t emins, vec3_t emaxs, struct mplane_s *plane);
float	anglemod(float a);

void RotatePointAroundVector( vec3_t dst, const vec3_t dir, const vec3_t point, float degrees );


#define BOX_ON_PLANE_SIDE(emins, emaxs, p)	\
	(((p)->type < 3)?						\
	(										\
		((p)->dist <= (emins)[(p)->type])?	\
			1								\
		:									\
		(									\
			((p)->dist >= (emaxs)[(p)->type])?\
				2							\
			:								\
				3							\
		)									\
	)										\
	:										\
		BoxOnPlaneSide( (emins), (emaxs), (p)))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_ipx.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_ipx.c

#include <stdio.h>
#include <stdlib.h>
#include <dpmi.h>

#include "quakedef.h"
#include "dosisms.h"
#include "net_ipx.h"

#define	EIO		 		5	/* I/O error */

#define AF_NETWARE 		64

#define IPX_OPEN					0
#define IPX_CLOSE					1
#define IPX_GETROUTE				2
#define IPX_SEND					3
#define IPX_LISTEN					4
#define IPX_SCHEDULEEVENT			5
#define IPX_CANCEL					6
#define IPX_SCHEDULESPECIALEVENT	7
#define IPX_GETINTERVALMARKER		8
#define IPX_GETADDRESS				9
#define IPX_RELINQUISH				10

#define PTYPE_UNKNOWN				0
#define PTYPE_RIP					1
#define PTYPE_ECHO					2
#define PTYPE_ERROR					3
#define PTYPE_IPX					4
#define PTYPE_SPX					5

#pragma pack(1)

typedef struct
{
	byte	network[4];
	byte	node[6];
	short	socket;
} IPXaddr;

struct sockaddr_ipx
{
    short			sipx_family;
	IPXaddr			sipx_addr;
    char			sipx_zero[2];
};
#define sipx_port sipx_addr.socket

typedef struct
{
	short			checkSum;
	short			length;
	byte			transportControl;
	byte			type;
	IPXaddr			destination;
	IPXaddr			source;
} IPXheader;

typedef struct ECBStructure
{
	struct ECBStructure *link;
	unsigned short	ESR_off;
	unsigned short	ESR_seg;
	byte	inUse;
	byte	completionCode;
	short	socket;
	byte	IPXWorkspace[4];
	byte	driverWorkspace[12];
	byte	immediateAddress[6];
	short	fragCount;
	short	fragOff;
	short	fragSeg;
	short	fragSize;
} ECB;

#pragma pack()

typedef struct
{
	ECB			ecb;
	IPXheader	header;
	int			sequence;
	char		data[NET_DATAGRAMSIZE];
} ipx_lowmem_buffer_t;

#define LOWMEMSIZE		(100 * 1024)
#define LOWMEMSAVE		256
#define IPXBUFFERS		((LOWMEMSIZE - LOWMEMSAVE)/ sizeof(ipx_lowmem_buffer_t))
#define IPXSOCKBUFFERS	5
#define IPXSOCKETS		(IPXBUFFERS / IPXSOCKBUFFERS)

// each socket's socketbuffer 0 is used for sending, the others for listening

typedef struct
{
	char				reserved[LOWMEMSAVE];
	ipx_lowmem_buffer_t	socketbuffer[IPXSOCKETS][IPXSOCKBUFFERS];
} ipx_lowmem_area_t;


static int ipxsocket[IPXSOCKETS];
static ECB *readlist[IPXSOCKETS];
static int sequence[IPXSOCKETS];
static int handlesInUse;
static ipx_lowmem_area_t *lma;
static char *lowmem_buffer;
static int lowmem_bufseg;
static int lowmem_bufoff;
static unsigned short ipx_cs;
static unsigned short ipx_ip;
static int net_acceptsocket = -1;
static int net_controlsocket;

static void IPX_PollProcedure(void);
static PollProcedure pollProcedure = {NULL, 0.0, IPX_PollProcedure};

//=============================================================================

static void IPX_GetLocalAddress(IPXaddr *addr)
{
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_GETADDRESS;
	regs.x.es = lowmem_bufseg;
	regs.x.si = lowmem_bufoff;
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);
	Q_memcpy(addr, lowmem_buffer, 10);
}

//=============================================================================

static int IPX_GetLocalTarget(IPXaddr *addr, byte *localTarget)
{
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_GETROUTE;
	regs.x.es = lowmem_bufseg;
	regs.x.si = lowmem_bufoff;
	regs.x.di = lowmem_bufoff + sizeof(IPXaddr);
	Q_memcpy(lowmem_buffer, addr, sizeof(IPXaddr));
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);
	if (regs.h.al)
		return -1;
	Q_memcpy(localTarget, lowmem_buffer + sizeof(IPXaddr), 6);
	return 0;
}

//=============================================================================

static void IPX_ListenForPacket(ECB *ecb)
{
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_LISTEN;
	regs.x.es = ptr2real(ecb) >> 4;
	regs.x.si = ptr2real(ecb) & 0xf;
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);
}

//=============================================================================

static void IPX_RelinquishControl(void)
{
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_RELINQUISH;
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);
}


void IPX_PollProcedure(void)
{
	IPX_RelinquishControl();
	SchedulePollProcedure(&pollProcedure, 0.01);
}

//=============================================================================

static void ProcessReadyList(int s)
{
	int n;
	ECB *ecb;
	ECB *prev;

	for (n = 1; n < IPXSOCKBUFFERS; n++)
	{
		if (lma->socketbuffer[s][n].ecb.inUse == 0)
		{
			for (ecb = readlist[s], prev = NULL; ecb; ecb = ecb->link)
			{
				if (lma->socketbuffer[s][n].sequence < ((ipx_lowmem_buffer_t *) ecb)->sequence)
					break;
				prev = ecb;
			}
			if (ecb)
				lma->socketbuffer[s][n].ecb.link = ecb;
			else
				lma->socketbuffer[s][n].ecb.link = NULL;
			if (prev)
				prev->link = &lma->socketbuffer[s][n].ecb;
			else
				readlist[s] = &lma->socketbuffer[s][n].ecb;
			lma->socketbuffer[s][n].ecb.inUse = 0xff;
		}
	}
}

//=============================================================================

int IPX_Init(void)
{
	int s;
	int n;
	struct qsockaddr addr;
	char *colon;

	if (COM_CheckParm ("-noipx"))
		return -1;

	// find the IPX far call entry point
	regs.x.ax = 0x7a00;
	__dpmi_simulate_real_mode_interrupt (0x2f, (__dpmi_regs *)&regs);
	if (regs.h.al != 0xff)
	{
		Con_Printf("IPX not detected\n");
		return -1;
	}
	ipx_cs = regs.x.es;
	ipx_ip = regs.x.di;

	// grab a chunk of memory down in DOS land
	lowmem_buffer = dos_getmemory(LOWMEMSIZE);
	if (!lowmem_buffer)
	{
		Con_Printf("IPX_Init: Not enough low memory\n");
		return -1;
	}
	lowmem_bufoff = ptr2real(lowmem_buffer) & 0xf;
	lowmem_bufseg = ptr2real(lowmem_buffer) >> 4;

	// init socket handles & buffers
	handlesInUse = 0;
	lma = (ipx_lowmem_area_t *)lowmem_buffer;
	for (s = 0; s < IPXSOCKETS; s++)
	{
		ipxsocket[s] = 0;
		for (n = 0; n < IPXSOCKBUFFERS; n++)
		{
			lma->socketbuffer[s][n].ecb.link = NULL;
			lma->socketbuffer[s][n].ecb.ESR_off = 0;
			lma->socketbuffer[s][n].ecb.ESR_seg = 0;
			lma->socketbuffer[s][n].ecb.socket = 0;
			lma->socketbuffer[s][n].ecb.inUse = 0xff;
			lma->socketbuffer[s][n].ecb.completionCode = 0;
			lma->socketbuffer[s][n].ecb.fragCount = 1;
			lma->socketbuffer[s][n].ecb.fragOff = ptr2real(&lma->socketbuffer[s][n].header) & 0xf;
			lma->socketbuffer[s][n].ecb.fragSeg = ptr2real(&lma->socketbuffer[s][n].header) >> 4;
			lma->socketbuffer[s][n].ecb.fragSize = sizeof(IPXheader) + sizeof(int) + NET_DATAGRAMSIZE;
		}
	}

	if ((net_controlsocket = IPX_OpenSocket (0)) == -1)
	{
		dos_freememory(lowmem_buffer);
		Con_DPrintf ("IPX_Init: Unable to open control socket\n");
		return -1;
	}

	SchedulePollProcedure(&pollProcedure, 0.01);

	IPX_GetSocketAddr (net_controlsocket, &addr);
	Q_strcpy(my_ipx_address,  IPX_AddrToString (&addr));
	colon = Q_strrchr (my_ipx_address, ':');
	if (colon)
		*colon = 0;

	Con_Printf("IPX initialized\n");
	ipxAvailable = true;
	return net_controlsocket;
}

//=============================================================================

void IPX_Shutdown(void)
{
	IPX_Listen (false);
	IPX_CloseSocket (net_controlsocket);
	dos_freememory(lowmem_buffer);
}

//=============================================================================

void IPX_Listen (qboolean state)
{
	// enable listening
	if (state)
	{
		if (net_acceptsocket != -1)
			return;
		if ((net_acceptsocket = IPX_OpenSocket (net_hostport)) == -1)
			Sys_Error ("IPX_Listen: Unable to open accept socket\n");
		return;
	}

	// disable listening
	if (net_acceptsocket == -1)
		return;
	IPX_CloseSocket (net_acceptsocket);
	net_acceptsocket = -1;
}

//=============================================================================

int IPX_OpenSocket(int port)
{
	int handle;
	int n;
	unsigned short socket;

	if (handlesInUse == IPXSOCKETS)
		return -1;

	// open the IPX socket
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_OPEN;
	regs.h.al = 0;
	regs.x.dx = htons(port);
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);
	if (regs.h.al == 0xfe)
	{
		Con_DPrintf("IPX_OpenSocket: all sockets in use\n");
		return -1;
	}
	if (regs.h.al == 0xff)
	{
		Con_DPrintf("IPX_OpenSocket: socket already open\n");
		return -1;
	}
	if (regs.h.al != 0)
	{
		Con_DPrintf("IPX_OpenSocket: error %02x\n", regs.h.al);
		return -1;
	}
	socket = regs.x.dx;

// grab a handle; fill in the ECBs, and get them listening
	for (handle = 0; handle < IPXSOCKETS; handle++)
	{
		if (ipxsocket[handle] == 0)
		{
			ipxsocket[handle] = socket;
			readlist[handle] = NULL;
			sequence[handle] = 0;
			for (n = 0; n < IPXSOCKBUFFERS; n ++)
			{
				lma->socketbuffer[handle][n].ecb.socket = socket;
				lma->socketbuffer[handle][n].ecb.inUse = 0;
				if (n)
					IPX_ListenForPacket(&lma->socketbuffer[handle][n].ecb);
			}
			handlesInUse++;
			return handle;
		}
	}

	// "this will NEVER happen"
	Sys_Error("IPX_OpenSocket: handle allocation failed\n");
	return -1;
}

//=============================================================================

int IPX_CloseSocket(int handle)
{
	// if there's a send in progress, give it one last chance
	if (lma->socketbuffer[handle][0].ecb.inUse != 0)
		IPX_RelinquishControl();

	// close the socket (all pending sends/received are cancelled)
	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_CLOSE;
	regs.x.dx = ipxsocket[handle];
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);

	ipxsocket[handle] = 0;
	handlesInUse--;

	return 0;
}

//=============================================================================

int IPX_Connect (int handle, struct qsockaddr *addr)
{
	IPXaddr ipxaddr;

	Q_memcpy(&ipxaddr, &((struct sockaddr_ipx *)addr)->sipx_addr, sizeof(IPXaddr));
	if (IPX_GetLocalTarget(&ipxaddr, lma->socketbuffer[handle][0].ecb.immediateAddress) != 0)
	{
		Con_Printf("Get Local Target failed\n");
		return -1;
	}

	return 0;
}

//=============================================================================

int IPX_CheckNewConnections (void)
{
	int n;

	if (net_acceptsocket == -1)
		return -1;

	for (n = 1; n < IPXSOCKBUFFERS; n ++)
		if (lma->socketbuffer[net_acceptsocket][n].ecb.inUse == 0)
			return net_acceptsocket;
	return -1;
}

//=============================================================================

int IPX_Read (int handle, byte *buf, int len, struct qsockaddr *addr)
{
	ECB		*ecb;
	ipx_lowmem_buffer_t *rcvbuf;
	int		copylen;

	ProcessReadyList(handle);
tryagain:
	if (readlist[handle] == NULL)
		return 0;
	ecb = readlist[handle];
	readlist[handle] = ecb->link;

	if (ecb->completionCode != 0)
	{
		Con_Printf("Warning: IPX_Read error %02x\n", ecb->completionCode);	
		ecb->fragSize = sizeof(IPXheader) + sizeof(int) + NET_DATAGRAMSIZE;
		IPX_ListenForPacket(ecb);
		goto tryagain;
	}

	rcvbuf = (ipx_lowmem_buffer_t *)ecb;

	// copy the data up to the buffer
	copylen = ntohs(rcvbuf->header.length) - (sizeof(int) + sizeof(IPXheader));
	if (len < copylen)
		Sys_Error("IPX_Read: buffer too small (%d vs %d)\n", len, copylen);
	Q_memcpy(buf, rcvbuf->data, copylen);

	// fill in the addr if they want it
	if (addr)
	{
		((struct sockaddr_ipx *)addr)->sipx_family = AF_NETWARE;
		Q_memcpy(&((struct sockaddr_ipx *)addr)->sipx_addr, rcvbuf->header.source.network, sizeof(IPXaddr));
		((struct sockaddr_ipx *)addr)->sipx_zero[0] = 0;
		((struct sockaddr_ipx *)addr)->sipx_zero[1] = 0;
	}

	// update the send ecb's immediate address
	Q_memcpy(lma->socketbuffer[handle][0].ecb.immediateAddress, rcvbuf->ecb.immediateAddress, 6);

	// get this ecb listening again
	rcvbuf->ecb.fragSize = sizeof(IPXheader) + sizeof(int) + NET_DATAGRAMSIZE;
	IPX_ListenForPacket(&rcvbuf->ecb);
	return copylen;
}

//=============================================================================

int IPX_Broadcast (int handle, byte *buf, int len)
{
	struct sockaddr_ipx addr;
	int ret;

	Q_memset(addr.sipx_addr.network, 0x00, 4);
	Q_memset(addr.sipx_addr.node, 0xff, 6);
	addr.sipx_port = htons(net_hostport);
	Q_memset(lma->socketbuffer[handle][0].ecb.immediateAddress, 0xff, 6);
	ret = IPX_Write (handle, buf, len, (struct qsockaddr *)&addr);
	return ret;
}

//=============================================================================

int IPX_Write (int handle, byte *buf, int len, struct qsockaddr *addr)
{
	// has the previous send completed?
	while (lma->socketbuffer[handle][0].ecb.inUse != 0)
		IPX_RelinquishControl();

	switch (lma->socketbuffer[handle][0].ecb.completionCode)
	{
		case 0x00: // success
		case 0xfc: // request cancelled
			break;

		case 0xfd: // malformed packet
		default:
			Con_Printf("IPX driver send failure: %02x\n", lma->socketbuffer[handle][0].ecb.completionCode);
			break;

		case 0xfe: // packet undeliverable
		case 0xff: // unable to send packet
			Con_Printf("IPX lost route, trying to re-establish\n");

			// look for a new route
			if (IPX_GetLocalTarget (&lma->socketbuffer[handle][0].header.destination, lma->socketbuffer[handle][0].ecb.immediateAddress) != 0)
				return -1;

			// re-send the one that failed
			regs.x.cs = ipx_cs;
			regs.x.ip = ipx_ip;
			regs.x.bx = IPX_SEND;
			regs.x.es = ptr2real(&lma->socketbuffer[handle][0].ecb) >> 4;
			regs.x.si = ptr2real(&lma->socketbuffer[handle][0].ecb) & 0xf;
			__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);

			// report that we did not send the current one
			return 0;
	}

	// ecb : length
	lma->socketbuffer[handle][0].ecb.fragSize = sizeof(IPXheader) + sizeof(int) + len;

	// ipx header : type
	lma->socketbuffer[handle][0].header.type = PTYPE_IPX;

	// ipx header : destination
	Q_memcpy(&lma->socketbuffer[handle][0].header.destination, &((struct sockaddr_ipx *)addr)->sipx_addr, sizeof(IPXaddr));

	// sequence number
	lma->socketbuffer[handle][0].sequence = sequence[handle];
	sequence[handle]++;

	// copy down the data
	Q_memcpy(lma->socketbuffer[handle][0].data, buf, len);

	regs.x.cs = ipx_cs;
	regs.x.ip = ipx_ip;
	regs.x.bx = IPX_SEND;
	regs.x.es = ptr2real(&lma->socketbuffer[handle][0].ecb) >> 4;
	regs.x.si = ptr2real(&lma->socketbuffer[handle][0].ecb) & 0xf;
	__dpmi_simulate_real_mode_procedure_retf((__dpmi_regs *)&regs);

	return len;
}

//=============================================================================

char *IPX_AddrToString (struct qsockaddr *addr)
{
	static char buf[28];

	sprintf(buf, "%02x%02x%02x%02x:%02x%02x%02x%02x%02x%02x:%u",
		((struct sockaddr_ipx *)addr)->sipx_addr.network[0],
		((struct sockaddr_ipx *)addr)->sipx_addr.network[1],
		((struct sockaddr_ipx *)addr)->sipx_addr.network[2],
		((struct sockaddr_ipx *)addr)->sipx_addr.network[3],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[0],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[1],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[2],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[3],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[4],
		((struct sockaddr_ipx *)addr)->sipx_addr.node[5],
		ntohs(((struct sockaddr_ipx *)addr)->sipx_port)
		);
	return buf;
}

//=============================================================================

int IPX_StringToAddr (char *string, struct qsockaddr *addr)
{
	int  val;
	char buf[3];

	buf[2] = 0;
	Q_memset(addr, 0, sizeof(struct qsockaddr));
	addr->sa_family = AF_NETWARE;

#define DO(src,dest)	\
	buf[0] = string[src];	\
	buf[1] = string[src + 1];	\
	if (sscanf (buf, "%x", &val) != 1)	\
		return -1;	\
	((struct sockaddr_ipx *)addr)->sipx_addr.dest = val

	DO(0, network[0]);
	DO(2, network[1]);
	DO(4, network[2]);
	DO(6, network[3]);
	DO(9, node[0]);
	DO(11, node[1]);
	DO(13, node[2]);
	DO(15, node[3]);
	DO(17, node[4]);
	DO(19, node[5]);
#undef DO

	sscanf (&string[22], "%u", &val);
	((struct sockaddr_ipx *)addr)->sipx_port = htons(val);

	return 0;
}

//=============================================================================

int IPX_GetSocketAddr (int handle, struct qsockaddr *addr)
{
	Q_memset(addr, 0, sizeof(struct qsockaddr));
	addr->sa_family = AF_NETWARE;
	IPX_GetLocalAddress(&((struct sockaddr_ipx *)addr)->sipx_addr);
	((struct sockaddr_ipx *)addr)->sipx_port = ipxsocket[handle];
	return 0;
}

//=============================================================================

int IPX_GetNameFromAddr (struct qsockaddr *addr, char *name)
{
	Q_strcpy(name, IPX_AddrToString(addr));
	return 0;
}

//=============================================================================

int IPX_GetAddrFromName (char *name, struct qsockaddr *addr)
{
	int n;
	char buf[32];

	n = Q_strlen(name);

	if (n == 12)
	{
		sprintf(buf, "00000000:%s:%u", name, net_hostport);
		return IPX_StringToAddr (buf, addr);
	}
	if (n == 21)
	{
		sprintf(buf, "%s:%u", name, net_hostport);
		return IPX_StringToAddr (buf, addr);
	}
	if (n > 21 && n <= 27)
		return IPX_StringToAddr (name, addr);

	return -1;
}

//=============================================================================

int IPX_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2)
{
	if (addr1->sa_family != addr2->sa_family)
		return -1;

	if(Q_memcmp(&((struct sockaddr_ipx *)addr1)->sipx_addr, &((struct sockaddr_ipx *)addr2)->sipx_addr, 10))
		return -1;

	if (((struct sockaddr_ipx *)addr1)->sipx_port != ((struct sockaddr_ipx *)addr2)->sipx_port)
		return 1;

	return 0;
}

//=============================================================================

int IPX_GetSocketPort (struct qsockaddr *addr)
{
	return ntohs(((struct sockaddr_ipx *)addr)->sipx_port);
}


int IPX_SetSocketPort (struct qsockaddr *addr, int port)
{
	((struct sockaddr_ipx *)addr)->sipx_port = htons(port);
	return 0;
}

//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_dgrm.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_dgrm.h


int			Datagram_Init (void);
void		Datagram_Listen (qboolean state);
void		Datagram_SearchForHosts (qboolean xmit);
qsocket_t	*Datagram_Connect (char *host);
qsocket_t 	*Datagram_CheckNewConnections (void);
int			Datagram_GetMessage (qsocket_t *sock);
int			Datagram_SendMessage (qsocket_t *sock, sizebuf_t *data);
int			Datagram_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data);
qboolean	Datagram_CanSendMessage (qsocket_t *sock);
qboolean	Datagram_CanSendUnreliableMessage (qsocket_t *sock);
void		Datagram_Close (qsocket_t *sock);
void		Datagram_Shutdown (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_dgrm.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_dgrm.c

// This is enables a simple IP banning mechanism
#define BAN_TEST

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif
#include "quakedef.h"
#include "net_dgrm.h"

// these two macros are to make the code more readable
#define sfunc	net_landrivers[sock->landriver]
#define dfunc	net_landrivers[net_landriverlevel]

static int net_landriverlevel;

/* statistic counters */
int	packetsSent = 0;
int	packetsReSent = 0;
int packetsReceived = 0;
int receivedDuplicateCount = 0;
int shortPacketCount = 0;
int droppedDatagrams;

static int myDriverLevel;

struct
{
	unsigned int	length;
	unsigned int	sequence;
	byte			data[MAX_DATAGRAM];
} packetBuffer;

extern int m_return_state;
extern int m_state;
extern qboolean m_return_onerror;
extern char m_return_reason[32];


#ifdef DEBUG
char *StrAddr (struct qsockaddr *addr)
{
	static char buf[34];
	byte *p = (byte *)addr;
	int n;

	for (n = 0; n < 16; n++)
		sprintf (buf + n * 2, "%02x", *p++);
	return buf;
}
#endif


#ifdef BAN_TEST
unsigned long banAddr = 0x00000000;
unsigned long banMask = 0xffffffff;

void NET_Ban_f (void)
{
	char	addrStr [32];
	char	maskStr [32];
	void	(*print) (char *fmt, ...);

	if (cmd_source == src_command)
	{
		if (!sv.active)
		{
			Cmd_ForwardToServer ();
			return;
		}
		print = Con_Printf;
	}
	else
	{
		if (pr_global_struct->deathmatch && !host_client->privileged)
			return;
		print = SV_ClientPrintf;
	}

	switch (Cmd_Argc ())
	{
		case 1:
			if (((struct in_addr *)&banAddr)->s_addr)
			{
                sprintf(addrStr, "%u.%u.%u.%u", ((struct in_addr *) &banAddr)->S_un.S_un_b.s_b1, ((struct in_addr *) &banAddr)->S_un.S_un_b.s_b2, ((struct in_addr *) &banAddr)->S_un.S_un_b.s_b3, ((struct in_addr *) &banAddr)->S_un.S_un_b.s_b4);
				//Q_strcpy(addrStr, inet_ntoa(*(struct in_addr *)&banAddr));
                sprintf(maskStr, "%u.%u.%u.%u", ((struct in_addr *) &banMask)->S_un.S_un_b.s_b1, ((struct in_addr *) &banMask)->S_un.S_un_b.s_b2, ((struct in_addr *) &banMask)->S_un.S_un_b.s_b3, ((struct in_addr *) &banMask)->S_un.S_un_b.s_b4);
				//Q_strcpy(maskStr, inet_ntoa(*(struct in_addr *)&banMask));
				print("Banning %s [%s]\n", addrStr, maskStr);
			}
			else
				print("Banning not active\n");
			break;

		case 2:
			if (Q_strcasecmp(Cmd_Argv(1), "off") == 0)
				banAddr = 0x00000000;
			else
				banAddr = inet_addr(Cmd_Argv(1));
			banMask = 0xffffffff;
			break;

		case 3:
			banAddr = inet_addr(Cmd_Argv(1));
			banMask = inet_addr(Cmd_Argv(2));
			break;

		default:
			print("BAN ip_address [mask]\n");
			break;
	}
}
#endif


int Datagram_SendMessage (qsocket_t *sock, sizebuf_t *data)
{
	unsigned int	packetLen;
	unsigned int	dataLen;
	unsigned int	eom;

#ifdef DEBUG
	if (data->cursize == 0)
		Sys_Error("Datagram_SendMessage: zero length message\n");

	if (data->cursize > NET_MAXMESSAGE)
		Sys_Error("Datagram_SendMessage: message too big %u\n", data->cursize);

	if (sock->canSend == false)
		Sys_Error("SendMessage: called with canSend == false\n");
#endif

	Q_memcpy(sock->sendMessage, data->data, data->cursize);
	sock->sendMessageLength = data->cursize;

	if (data->cursize <= MAX_DATAGRAM)
	{
		dataLen = data->cursize;
		eom = NETFLAG_EOM;
	}
	else
	{
		dataLen = MAX_DATAGRAM;
		eom = 0;
	}
	packetLen = NET_HEADERSIZE + dataLen;

	packetBuffer.length = BigLong(packetLen | (NETFLAG_DATA | eom));
	packetBuffer.sequence = BigLong(sock->sendSequence++);
	Q_memcpy (packetBuffer.data, sock->sendMessage, dataLen);

	sock->canSend = false;

	if (sfunc.Write (sock->socket, (byte *)&packetBuffer, packetLen, &sock->addr) == -1)
		return -1;

	sock->lastSendTime = net_time;
	packetsSent++;
	return 1;
}


int SendMessageNext (qsocket_t *sock)
{
	unsigned int	packetLen;
	unsigned int	dataLen;
	unsigned int	eom;

	if (sock->sendMessageLength <= MAX_DATAGRAM)
	{
		dataLen = sock->sendMessageLength;
		eom = NETFLAG_EOM;
	}
	else
	{
		dataLen = MAX_DATAGRAM;
		eom = 0;
	}
	packetLen = NET_HEADERSIZE + dataLen;

	packetBuffer.length = BigLong(packetLen | (NETFLAG_DATA | eom));
	packetBuffer.sequence = BigLong(sock->sendSequence++);
	Q_memcpy (packetBuffer.data, sock->sendMessage, dataLen);

	sock->sendNext = false;

	if (sfunc.Write (sock->socket, (byte *)&packetBuffer, packetLen, &sock->addr) == -1)
		return -1;

	sock->lastSendTime = net_time;
	packetsSent++;
	return 1;
}


int ReSendMessage (qsocket_t *sock)
{
	unsigned int	packetLen;
	unsigned int	dataLen;
	unsigned int	eom;

	if (sock->sendMessageLength <= MAX_DATAGRAM)
	{
		dataLen = sock->sendMessageLength;
		eom = NETFLAG_EOM;
	}
	else
	{
		dataLen = MAX_DATAGRAM;
		eom = 0;
	}
	packetLen = NET_HEADERSIZE + dataLen;

	packetBuffer.length = BigLong(packetLen | (NETFLAG_DATA | eom));
	packetBuffer.sequence = BigLong(sock->sendSequence - 1);
	Q_memcpy (packetBuffer.data, sock->sendMessage, dataLen);

	sock->sendNext = false;

	if (sfunc.Write (sock->socket, (byte *)&packetBuffer, packetLen, &sock->addr) == -1)
		return -1;

	sock->lastSendTime = net_time;
	packetsReSent++;
	return 1;
}


qboolean Datagram_CanSendMessage (qsocket_t *sock)
{
	if (sock->sendNext)
		SendMessageNext (sock);

	return sock->canSend;
}


qboolean Datagram_CanSendUnreliableMessage (qsocket_t *sock)
{
	return true;
}


int Datagram_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data)
{
	int 	packetLen;

#ifdef DEBUG
	if (data->cursize == 0)
		Sys_Error("Datagram_SendUnreliableMessage: zero length message\n");

	if (data->cursize > MAX_DATAGRAM)
		Sys_Error("Datagram_SendUnreliableMessage: message too big %u\n", data->cursize);
#endif

	packetLen = NET_HEADERSIZE + data->cursize;

	packetBuffer.length = BigLong(packetLen | NETFLAG_UNRELIABLE);
	packetBuffer.sequence = BigLong(sock->unreliableSendSequence++);
	Q_memcpy (packetBuffer.data, data->data, data->cursize);

	if (sfunc.Write (sock->socket, (byte *)&packetBuffer, packetLen, &sock->addr) == -1)
		return -1;

	packetsSent++;
	return 1;
}


int	Datagram_GetMessage (qsocket_t *sock)
{
	unsigned int	length;
	unsigned int	flags;
	int				ret = 0;
	struct qsockaddr readaddr;
	unsigned int	sequence;
	unsigned int	count;

	if (!sock->canSend)
		if ((net_time - sock->lastSendTime) > 1.0)
			ReSendMessage (sock);

	while(1)
	{	
		length = sfunc.Read (sock->socket, (byte *)&packetBuffer, NET_DATAGRAMSIZE, &readaddr);

//	if ((rand() & 255) > 220)
//		continue;

		if (length == 0)
			break;

		if (length == -1)
		{
			Con_Printf("Read error\n");
			return -1;
		}

		if (sfunc.AddrCompare(&readaddr, &sock->addr) != 0)
		{
#ifdef DEBUG
			Con_DPrintf("Forged packet received\n");
			Con_DPrintf("Expected: %s\n", StrAddr (&sock->addr));
			Con_DPrintf("Received: %s\n", StrAddr (&readaddr));
#endif
			continue;
		}

		if (length < NET_HEADERSIZE)
		{
			shortPacketCount++;
			continue;
		}

		length = BigLong(packetBuffer.length);
		flags = length & (~NETFLAG_LENGTH_MASK);
		length &= NETFLAG_LENGTH_MASK;

		if (flags & NETFLAG_CTL)
			continue;

		sequence = BigLong(packetBuffer.sequence);
		packetsReceived++;

		if (flags & NETFLAG_UNRELIABLE)
		{
			if (sequence < sock->unreliableReceiveSequence)
			{
				Con_DPrintf("Got a stale datagram\n");
				ret = 0;
				break;
			}
			if (sequence != sock->unreliableReceiveSequence)
			{
				count = sequence - sock->unreliableReceiveSequence;
				droppedDatagrams += count;
				Con_DPrintf("Dropped %u datagram(s)\n", count);
			}
			sock->unreliableReceiveSequence = sequence + 1;

			length -= NET_HEADERSIZE;

			SZ_Clear (&net_message);
			SZ_Write (&net_message, packetBuffer.data, length);

			ret = 2;
			break;
		}

		if (flags & NETFLAG_ACK)
		{
			if (sequence != (sock->sendSequence - 1))
			{
				Con_DPrintf("Stale ACK received\n");
				continue;
			}
			if (sequence == sock->ackSequence)
			{
				sock->ackSequence++;
				if (sock->ackSequence != sock->sendSequence)
					Con_DPrintf("ack sequencing error\n");
			}
			else
			{
				Con_DPrintf("Duplicate ACK received\n");
				continue;
			}
			sock->sendMessageLength -= MAX_DATAGRAM;
			if (sock->sendMessageLength > 0)
			{
				Q_memcpy(sock->sendMessage, sock->sendMessage+MAX_DATAGRAM, sock->sendMessageLength);
				sock->sendNext = true;
			}
			else
			{
				sock->sendMessageLength = 0;
				sock->canSend = true;
			}
			continue;
		}

		if (flags & NETFLAG_DATA)
		{
			packetBuffer.length = BigLong(NET_HEADERSIZE | NETFLAG_ACK);
			packetBuffer.sequence = BigLong(sequence);
			sfunc.Write (sock->socket, (byte *)&packetBuffer, NET_HEADERSIZE, &readaddr);

			if (sequence != sock->receiveSequence)
			{
				receivedDuplicateCount++;
				continue;
			}
			sock->receiveSequence++;

			length -= NET_HEADERSIZE;

			if (flags & NETFLAG_EOM)
			{
				SZ_Clear(&net_message);
				SZ_Write(&net_message, sock->receiveMessage, sock->receiveMessageLength);
				SZ_Write(&net_message, packetBuffer.data, length);
				sock->receiveMessageLength = 0;

				ret = 1;
				break;
			}

			Q_memcpy(sock->receiveMessage + sock->receiveMessageLength, packetBuffer.data, length);
			sock->receiveMessageLength += length;
			continue;
		}
	}

	if (sock->sendNext)
		SendMessageNext (sock);

	return ret;
}


void PrintStats(qsocket_t *s)
{
	Con_Printf("canSend = %4u   \n", s->canSend);
	Con_Printf("sendSeq = %4u   ", s->sendSequence);
	Con_Printf("recvSeq = %4u   \n", s->receiveSequence);
	Con_Printf("\n");
}

void NET_Stats_f (void)
{
	qsocket_t	*s;

	if (Cmd_Argc () == 1)
	{
		Con_Printf("unreliable messages sent   = %i\n", unreliableMessagesSent);
		Con_Printf("unreliable messages recv   = %i\n", unreliableMessagesReceived);
		Con_Printf("reliable messages sent     = %i\n", messagesSent);
		Con_Printf("reliable messages received = %i\n", messagesReceived);
		Con_Printf("packetsSent                = %i\n", packetsSent);
		Con_Printf("packetsReSent              = %i\n", packetsReSent);
		Con_Printf("packetsReceived            = %i\n", packetsReceived);
		Con_Printf("receivedDuplicateCount     = %i\n", receivedDuplicateCount);
		Con_Printf("shortPacketCount           = %i\n", shortPacketCount);
		Con_Printf("droppedDatagrams           = %i\n", droppedDatagrams);
	}
	else if (Q_strcmp(Cmd_Argv(1), "*") == 0)
	{
		for (s = net_activeSockets; s; s = s->next)
			PrintStats(s);
		for (s = net_freeSockets; s; s = s->next)
			PrintStats(s);
	}
	else
	{
		for (s = net_activeSockets; s; s = s->next)
			if (Q_strcasecmp(Cmd_Argv(1), s->address) == 0)
				break;
		if (s == NULL)
			for (s = net_freeSockets; s; s = s->next)
				if (Q_strcasecmp(Cmd_Argv(1), s->address) == 0)
					break;
		if (s == NULL)
			return;
		PrintStats(s);
	}
}


static qboolean testInProgress = false;
static int		testPollCount;
static int		testDriver;
static int		testSocket;

static void Test_Poll(void*);
PollProcedure	testPollProcedure = {NULL, 0.0, Test_Poll};

static void Test_Poll(void* dummy)
{
	struct qsockaddr clientaddr;
	int		control;
	int		len;
	char	name[32];
	char	address[64];
	int		colors;
	int		frags;
	int		connectTime;
	byte	playerNumber;

	net_landriverlevel = testDriver;

	while (1)
	{
		len = dfunc.Read (testSocket, net_message.data, net_message.maxsize, &clientaddr);
		if (len < sizeof(int))
			break;

		net_message.cursize = len;

		MSG_BeginReading ();
		control = BigLong(*((int *)net_message.data));
		MSG_ReadLong();
		if (control == -1)
			break;
		if ((control & (~NETFLAG_LENGTH_MASK)) !=  NETFLAG_CTL)
			break;
		if ((control & NETFLAG_LENGTH_MASK) != len)
			break;

		if (MSG_ReadByte() != CCREP_PLAYER_INFO)
			Sys_Error("Unexpected repsonse to Player Info request\n");

		playerNumber = (byte)MSG_ReadByte();
		Q_strcpy(name, MSG_ReadString());
		colors = MSG_ReadLong();
		frags = MSG_ReadLong();
		connectTime = MSG_ReadLong();
		Q_strcpy(address, MSG_ReadString());

		Con_Printf("%s\n  frags:%3i  colors:%u %u  time:%u\n  %s\n", name, frags, colors >> 4, colors & 0x0f, connectTime / 60, address);
	}

	testPollCount--;
	if (testPollCount)
	{
		SchedulePollProcedure(&testPollProcedure, 0.1);
	}
	else
	{
		dfunc.CloseSocket(testSocket);
		testInProgress = false;
	}
}

static void Test_f (void)
{
	char	*host;
	int		n;
	int		max = MAX_SCOREBOARD;
	struct qsockaddr sendaddr;

	if (testInProgress)
		return;

	host = Cmd_Argv (1);

	if (host && hostCacheCount)
	{
		for (n = 0; n < hostCacheCount; n++)
			if (Q_strcasecmp (host, hostcache[n].name) == 0)
			{
				if (hostcache[n].driver != myDriverLevel)
					continue;
				net_landriverlevel = hostcache[n].ldriver;
				max = hostcache[n].maxusers;
				Q_memcpy(&sendaddr, &hostcache[n].addr, sizeof(struct qsockaddr));
				break;
			}
		if (n < hostCacheCount)
			goto JustDoIt;
	}

	for (net_landriverlevel = 0; net_landriverlevel < net_numlandrivers; net_landriverlevel++)
	{
		if (!net_landrivers[net_landriverlevel].initialized)
			continue;

		// see if we can resolve the host name
		if (dfunc.GetAddrFromName(host, &sendaddr) != -1)
			break;
	}
	if (net_landriverlevel == net_numlandrivers)
		return;

JustDoIt:
	testSocket = dfunc.OpenSocket(0);
	if (testSocket == -1)
		return;

	testInProgress = true;
	testPollCount = 20;
	testDriver = net_landriverlevel;

	for (n = 0; n < max; n++)
	{
		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREQ_PLAYER_INFO);
		MSG_WriteByte(&net_message, n);
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | 	(net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (testSocket, net_message.data, net_message.cursize, &sendaddr);
	}
	SZ_Clear(&net_message);
	SchedulePollProcedure(&testPollProcedure, 0.1);
}


static qboolean test2InProgress = false;
static int		test2Driver;
static int		test2Socket;

static void Test2_Poll(void*);
PollProcedure	test2PollProcedure = {NULL, 0.0, Test2_Poll};

static void Test2_Poll(void* dummy)
{
	struct qsockaddr clientaddr;
	int		control;
	int		len;
	char	name[256];
	char	value[256];

	net_landriverlevel = test2Driver;
	name[0] = 0;

	len = dfunc.Read (test2Socket, net_message.data, net_message.maxsize, &clientaddr);
	if (len < sizeof(int))
		goto Reschedule;

	net_message.cursize = len;

	MSG_BeginReading ();
	control = BigLong(*((int *)net_message.data));
	MSG_ReadLong();
	if (control == -1)
		goto Error;
	if ((control & (~NETFLAG_LENGTH_MASK)) !=  NETFLAG_CTL)
		goto Error;
	if ((control & NETFLAG_LENGTH_MASK) != len)
		goto Error;

	if (MSG_ReadByte() != CCREP_RULE_INFO)
		goto Error;

	Q_strcpy(name, MSG_ReadString());
	if (name[0] == 0)
		goto Done;
	Q_strcpy(value, MSG_ReadString());

	Con_Printf("%-16.16s  %-16.16s\n", name, value);

	SZ_Clear(&net_message);
	// save space for the header, filled in later
	MSG_WriteLong(&net_message, 0);
	MSG_WriteByte(&net_message, CCREQ_RULE_INFO);
	MSG_WriteString(&net_message, name);
	*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
	dfunc.Write (test2Socket, net_message.data, net_message.cursize, &clientaddr);
	SZ_Clear(&net_message);

Reschedule:
	SchedulePollProcedure(&test2PollProcedure, 0.05);
	return;

Error:
	Con_Printf("Unexpected repsonse to Rule Info request\n");
Done:
	dfunc.CloseSocket(test2Socket);
	test2InProgress = false;
	return;
}

static void Test2_f (void)
{
	char	*host;
	int		n;
	struct qsockaddr sendaddr;

	if (test2InProgress)
		return;

	host = Cmd_Argv (1);

	if (host && hostCacheCount)
	{
		for (n = 0; n < hostCacheCount; n++)
			if (Q_strcasecmp (host, hostcache[n].name) == 0)
			{
				if (hostcache[n].driver != myDriverLevel)
					continue;
				net_landriverlevel = hostcache[n].ldriver;
				Q_memcpy(&sendaddr, &hostcache[n].addr, sizeof(struct qsockaddr));
				break;
			}
		if (n < hostCacheCount)
			goto JustDoIt;
	}

	for (net_landriverlevel = 0; net_landriverlevel < net_numlandrivers; net_landriverlevel++)
	{
		if (!net_landrivers[net_landriverlevel].initialized)
			continue;

		// see if we can resolve the host name
		if (dfunc.GetAddrFromName(host, &sendaddr) != -1)
			break;
	}
	if (net_landriverlevel == net_numlandrivers)
		return;

JustDoIt:
	test2Socket = dfunc.OpenSocket(0);
	if (test2Socket == -1)
		return;

	test2InProgress = true;
	test2Driver = net_landriverlevel;

	SZ_Clear(&net_message);
	// save space for the header, filled in later
	MSG_WriteLong(&net_message, 0);
	MSG_WriteByte(&net_message, CCREQ_RULE_INFO);
	MSG_WriteString(&net_message, "");
	*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
	dfunc.Write (test2Socket, net_message.data, net_message.cursize, &sendaddr);
	SZ_Clear(&net_message);
	SchedulePollProcedure(&test2PollProcedure, 0.05);
}


int Datagram_Init (void)
{
	int i;
	int csock;

	myDriverLevel = net_driverlevel;
	Cmd_AddCommand ("net_stats", NET_Stats_f);

	for (i = 0; i < net_numlandrivers; i++)
		{
		csock = net_landrivers[i].Init ();
		if (csock == -1)
			continue;
		net_landrivers[i].initialized = true;
		net_landrivers[i].controlSock = csock;
		}

#ifdef BAN_TEST
	Cmd_AddCommand ("ban", NET_Ban_f);
#endif
	Cmd_AddCommand ("test", Test_f);
	Cmd_AddCommand ("test2", Test2_f);

	return 0;
}


void Datagram_Shutdown (void)
{
	int i;

//
// shutdown the lan drivers
//
	for (i = 0; i < net_numlandrivers; i++)
	{
		if (net_landrivers[i].initialized)
		{
			net_landrivers[i].Shutdown ();
			net_landrivers[i].initialized = false;
		}
	}
}


void Datagram_Close (qsocket_t *sock)
{
	sfunc.CloseSocket(sock->socket);
}


void Datagram_Listen (qboolean state)
{
	int i;

	for (i = 0; i < net_numlandrivers; i++)
		if (net_landrivers[i].initialized)
			net_landrivers[i].Listen (state);
}


static qsocket_t *_Datagram_CheckNewConnections (void)
{
	struct qsockaddr clientaddr;
	struct qsockaddr newaddr;
	int			newsock;
	int			acceptsock;
	qsocket_t	*sock;
	qsocket_t	*s;
	int			len;
	int			command;
	int			control;
	int			ret;

	acceptsock = dfunc.CheckNewConnections();
	if (acceptsock == -1)
		return NULL;

	SZ_Clear(&net_message);

	len = dfunc.Read (acceptsock, net_message.data, net_message.maxsize, &clientaddr);
	if (len < sizeof(int))
		return NULL;
	net_message.cursize = len;

	MSG_BeginReading ();
	control = BigLong(*((int *)net_message.data));
	MSG_ReadLong();
	if (control == -1)
		return NULL;
	if ((control & (~NETFLAG_LENGTH_MASK)) !=  NETFLAG_CTL)
		return NULL;
	if ((control & NETFLAG_LENGTH_MASK) != len)
		return NULL;

	command = MSG_ReadByte();
	if (command == CCREQ_SERVER_INFO)
	{
		if (Q_strcmp(MSG_ReadString(), "QUAKE") != 0)
			return NULL;

		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREP_SERVER_INFO);
		dfunc.GetSocketAddr(acceptsock, &newaddr);
		MSG_WriteString(&net_message, dfunc.AddrToString(&newaddr));
		MSG_WriteString(&net_message, hostname.string);
		MSG_WriteString(&net_message, sv.name);
		MSG_WriteByte(&net_message, net_activeconnections);
		MSG_WriteByte(&net_message, svs.maxclients);
		MSG_WriteByte(&net_message, NET_PROTOCOL_VERSION);
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
		SZ_Clear(&net_message);
		return NULL;
	}

	if (command == CCREQ_PLAYER_INFO)
	{
		int			playerNumber;
		int			activeNumber;
		int			clientNumber;
		client_t	*client;
		
		playerNumber = MSG_ReadByte();
		activeNumber = -1;
		for (clientNumber = 0, client = svs.clients; clientNumber < svs.maxclients; clientNumber++, client++)
		{
			if (client->active)
			{
				activeNumber++;
				if (activeNumber == playerNumber)
					break;
			}
		}
		if (clientNumber == svs.maxclients)
			return NULL;

		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREP_PLAYER_INFO);
		MSG_WriteByte(&net_message, playerNumber);
		MSG_WriteString(&net_message, client->name);
		MSG_WriteLong(&net_message, client->colors);
		MSG_WriteLong(&net_message, (int)client->edict->v.frags);
		MSG_WriteLong(&net_message, (int)(net_time - client->netconnection->connecttime));
		MSG_WriteString(&net_message, client->netconnection->address);
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
		SZ_Clear(&net_message);

		return NULL;
	}

	if (command == CCREQ_RULE_INFO)
	{
		char	*prevCvarName;
		cvar_t	*var;

		// find the search start location
		prevCvarName = MSG_ReadString();
		if (*prevCvarName)
		{
			var = Cvar_FindVar (prevCvarName);
			if (!var)
				return NULL;
			var = var->next;
		}
		else
			var = cvar_vars;

		// search for the next server cvar
		while (var)
		{
			if (var->server)
				break;
			var = var->next;
		}

		// send the response

		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREP_RULE_INFO);
		if (var)
		{
			MSG_WriteString(&net_message, var->name);
			MSG_WriteString(&net_message, var->string);
		}
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
		SZ_Clear(&net_message);

		return NULL;
	}

	if (command != CCREQ_CONNECT)
		return NULL;

	if (Q_strcmp(MSG_ReadString(), "QUAKE") != 0)
		return NULL;

	if (MSG_ReadByte() != NET_PROTOCOL_VERSION)
	{
		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREP_REJECT);
		MSG_WriteString(&net_message, "Incompatible version.\n");
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
		SZ_Clear(&net_message);
		return NULL;
	}

#ifdef BAN_TEST
	// check for a ban
	if (clientaddr.sa_family == AF_INET)
	{
		unsigned long testAddr;
		testAddr = ((struct sockaddr_in *)&clientaddr)->sin_addr.s_addr;
		if ((testAddr & banMask) == banAddr)
		{
			SZ_Clear(&net_message);
			// save space for the header, filled in later
			MSG_WriteLong(&net_message, 0);
			MSG_WriteByte(&net_message, CCREP_REJECT);
			MSG_WriteString(&net_message, "You have been banned.\n");
			*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
			dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
			SZ_Clear(&net_message);
			return NULL;
		}
	}
#endif

	// see if this guy is already connected
	for (s = net_activeSockets; s; s = s->next)
	{
		if (s->driver != net_driverlevel)
			continue;
		ret = dfunc.AddrCompare(&clientaddr, &s->addr);
		if (ret >= 0)
		{
			// is this a duplicate connection reqeust?
			if (ret == 0 && net_time - s->connecttime < 2.0)
			{
				// yes, so send a duplicate reply
				SZ_Clear(&net_message);
				// save space for the header, filled in later
				MSG_WriteLong(&net_message, 0);
				MSG_WriteByte(&net_message, CCREP_ACCEPT);
				dfunc.GetSocketAddr(s->socket, &newaddr);
				MSG_WriteLong(&net_message, dfunc.GetSocketPort(&newaddr));
				*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
				dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
				SZ_Clear(&net_message);
				return NULL;
			}
			// it's somebody coming back in from a crash/disconnect
			// so close the old qsocket and let their retry get them back in
			NET_Close(s);
			return NULL;
		}
	}

	// allocate a QSocket
	sock = NET_NewQSocket ();
	if (sock == NULL)
	{
		// no room; try to let him know
		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREP_REJECT);
		MSG_WriteString(&net_message, "Server is full.\n");
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
		SZ_Clear(&net_message);
		return NULL;
	}

	// allocate a network socket
	newsock = dfunc.OpenSocket(0);
	if (newsock == -1)
	{
		NET_FreeQSocket(sock);
		return NULL;
	}

	// connect to the client
	if (dfunc.Connect (newsock, &clientaddr) == -1)
	{
		dfunc.CloseSocket(newsock);
		NET_FreeQSocket(sock);
		return NULL;
	}

	// everything is allocated, just fill in the details	
	sock->socket = newsock;
	sock->landriver = net_landriverlevel;
	sock->addr = clientaddr;
	Q_strcpy(sock->address, dfunc.AddrToString(&clientaddr));

	// send him back the info about the server connection he has been allocated
	SZ_Clear(&net_message);
	// save space for the header, filled in later
	MSG_WriteLong(&net_message, 0);
	MSG_WriteByte(&net_message, CCREP_ACCEPT);
	dfunc.GetSocketAddr(newsock, &newaddr);
	MSG_WriteLong(&net_message, dfunc.GetSocketPort(&newaddr));
//	MSG_WriteString(&net_message, dfunc.AddrToString(&newaddr));
	*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
	dfunc.Write (acceptsock, net_message.data, net_message.cursize, &clientaddr);
	SZ_Clear(&net_message);

	return sock;
}

qsocket_t *Datagram_CheckNewConnections (void)
{
	qsocket_t *ret = NULL;

	for (net_landriverlevel = 0; net_landriverlevel < net_numlandrivers; net_landriverlevel++)
		if (net_landrivers[net_landriverlevel].initialized)
			if ((ret = _Datagram_CheckNewConnections ()) != NULL)
				break;
	return ret;
}


static void _Datagram_SearchForHosts (qboolean xmit)
{
	int		ret;
	int		n;
	int		i;
	struct qsockaddr readaddr;
	struct qsockaddr myaddr;
	int		control;

	dfunc.GetSocketAddr (dfunc.controlSock, &myaddr);
	if (xmit)
	{
		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREQ_SERVER_INFO);
		MSG_WriteString(&net_message, "QUAKE");
		MSG_WriteByte(&net_message, NET_PROTOCOL_VERSION);
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Broadcast(dfunc.controlSock, net_message.data, net_message.cursize);
		SZ_Clear(&net_message);
	}

	while ((ret = dfunc.Read (dfunc.controlSock, net_message.data, net_message.maxsize, &readaddr)) > 0)
	{
		if (ret < sizeof(int))
			continue;
		net_message.cursize = ret;

		// don't answer our own query
		if (dfunc.AddrCompare(&readaddr, &myaddr) >= 0)
			continue;

		// is the cache full?
		if (hostCacheCount == HOSTCACHESIZE)
			continue;

		MSG_BeginReading ();
		control = BigLong(*((int *)net_message.data));
		MSG_ReadLong();
		if (control == -1)
			continue;
		if ((control & (~NETFLAG_LENGTH_MASK)) !=  NETFLAG_CTL)
			continue;
		if ((control & NETFLAG_LENGTH_MASK) != ret)
			continue;

		if (MSG_ReadByte() != CCREP_SERVER_INFO)
			continue;

		dfunc.GetAddrFromName(MSG_ReadString(), &readaddr);
		// search the cache for this server
		for (n = 0; n < hostCacheCount; n++)
			if (dfunc.AddrCompare(&readaddr, &hostcache[n].addr) == 0)
				break;

		// is it already there?
		if (n < hostCacheCount)
			continue;

		// add it
		hostCacheCount++;
		Q_strcpy(hostcache[n].name, MSG_ReadString());
		Q_strcpy(hostcache[n].map, MSG_ReadString());
		hostcache[n].users = MSG_ReadByte();
		hostcache[n].maxusers = MSG_ReadByte();
		if (MSG_ReadByte() != NET_PROTOCOL_VERSION)
		{
			Q_strcpy(hostcache[n].cname, hostcache[n].name);
			hostcache[n].cname[14] = 0;
			Q_strcpy(hostcache[n].name, "*");
			Q_strcat(hostcache[n].name, hostcache[n].cname);
		}
		Q_memcpy(&hostcache[n].addr, &readaddr, sizeof(struct qsockaddr));
		hostcache[n].driver = net_driverlevel;
		hostcache[n].ldriver = net_landriverlevel;
		Q_strcpy(hostcache[n].cname, dfunc.AddrToString(&readaddr));

		// check for a name conflict
		for (i = 0; i < hostCacheCount; i++)
		{
			if (i == n)
				continue;
			if (Q_strcasecmp (hostcache[n].name, hostcache[i].name) == 0)
			{
				i = Q_strlen(hostcache[n].name);
				if (i < 15 && hostcache[n].name[i-1] > '8')
				{
					hostcache[n].name[i] = '0';
					hostcache[n].name[i+1] = 0;
				}
				else
					hostcache[n].name[i-1]++;
				i = -1;
			}
		}
	}
}

void Datagram_SearchForHosts (qboolean xmit)
{
	for (net_landriverlevel = 0; net_landriverlevel < net_numlandrivers; net_landriverlevel++)
	{
		if (hostCacheCount == HOSTCACHESIZE)
			break;
		if (net_landrivers[net_landriverlevel].initialized)
			_Datagram_SearchForHosts (xmit);
	}
}


static qsocket_t *_Datagram_Connect (char *host)
{
	struct qsockaddr sendaddr;
	struct qsockaddr readaddr;
	qsocket_t	*sock;
	int			newsock;
	int			ret;
	int			reps;
	double		start_time;
	int			control;
	char		*reason;

	// see if we can resolve the host name
	if (dfunc.GetAddrFromName(host, &sendaddr) == -1)
		return NULL;

	newsock = dfunc.OpenSocket (0);
	if (newsock == -1)
		return NULL;

	sock = NET_NewQSocket ();
	if (sock == NULL)
		goto ErrorReturn2;
	sock->socket = newsock;
	sock->landriver = net_landriverlevel;

	// connect to the host
	if (dfunc.Connect (newsock, &sendaddr) == -1)
		goto ErrorReturn;

	// send the connection request
	Con_Printf("trying...\n"); SCR_UpdateScreen ();
	start_time = net_time;

	for (reps = 0; reps < 3; reps++)
	{
		SZ_Clear(&net_message);
		// save space for the header, filled in later
		MSG_WriteLong(&net_message, 0);
		MSG_WriteByte(&net_message, CCREQ_CONNECT);
		MSG_WriteString(&net_message, "QUAKE");
		MSG_WriteByte(&net_message, NET_PROTOCOL_VERSION);
		*((int *)net_message.data) = BigLong(NETFLAG_CTL | (net_message.cursize & NETFLAG_LENGTH_MASK));
		dfunc.Write (newsock, net_message.data, net_message.cursize, &sendaddr);
		SZ_Clear(&net_message);
		do
		{
			ret = dfunc.Read (newsock, net_message.data, net_message.maxsize, &readaddr);
			// if we got something, validate it
			if (ret > 0)
			{
				// is it from the right place?
				if (sfunc.AddrCompare(&readaddr, &sendaddr) != 0)
				{
#ifdef DEBUG
					Con_Printf("wrong reply address\n");
					Con_Printf("Expected: %s\n", StrAddr (&sendaddr));
					Con_Printf("Received: %s\n", StrAddr (&readaddr));
					SCR_UpdateScreen ();
#endif
					ret = 0;
					continue;
				}

				if (ret < sizeof(int))
				{
					ret = 0;
					continue;
				}

				net_message.cursize = ret;
				MSG_BeginReading ();

				control = BigLong(*((int *)net_message.data));
				MSG_ReadLong();
				if (control == -1)
				{
					ret = 0;
					continue;
				}
				if ((control & (~NETFLAG_LENGTH_MASK)) !=  NETFLAG_CTL)
				{
					ret = 0;
					continue;
				}
				if ((control & NETFLAG_LENGTH_MASK) != ret)
				{
					ret = 0;
					continue;
				}
			}
		}
		while (ret == 0 && (SetNetTime() - start_time) < 2.5);
		if (ret)
			break;
		Con_Printf("still trying...\n"); SCR_UpdateScreen ();
		start_time = SetNetTime();
	}

	if (ret == 0)
	{
		reason = "No Response";
		Con_Printf("%s\n", reason);
		Q_strcpy(m_return_reason, reason);
		goto ErrorReturn;
	}

	if (ret == -1)
	{
		reason = "Network Error";
		Con_Printf("%s\n", reason);
		Q_strcpy(m_return_reason, reason);
		goto ErrorReturn;
	}

	ret = MSG_ReadByte();
	if (ret == CCREP_REJECT)
	{
		reason = MSG_ReadString();
		Con_Printf(reason);
		Q_strncpy(m_return_reason, reason, 31);
		goto ErrorReturn;
	}

	if (ret == CCREP_ACCEPT)
	{
		Q_memcpy(&sock->addr, &sendaddr, sizeof(struct qsockaddr));
		dfunc.SetSocketPort (&sock->addr, MSG_ReadLong());
	}
	else
	{
		reason = "Bad Response";
		Con_Printf("%s\n", reason);
		Q_strcpy(m_return_reason, reason);
		goto ErrorReturn;
	}

	dfunc.GetNameFromAddr (&sendaddr, sock->address);

	Con_Printf ("Connection accepted\n");
	sock->lastMessageTime = SetNetTime();

	// switch the connection to the specified address
	if (dfunc.Connect (newsock, &sock->addr) == -1)
	{
		reason = "Connect to Game failed";
		Con_Printf("%s\n", reason);
		Q_strcpy(m_return_reason, reason);
		goto ErrorReturn;
	}

	m_return_onerror = false;
	return sock;

ErrorReturn:
	NET_FreeQSocket(sock);
ErrorReturn2:
	dfunc.CloseSocket(newsock);
	if (m_return_onerror)
	{
		key_dest = key_menu;
		m_state = m_return_state;
		m_return_onerror = false;
	}
	return NULL;
}

qsocket_t *Datagram_Connect (char *host)
{
	qsocket_t *ret = NULL;

	for (net_landriverlevel = 0; net_landriverlevel < net_numlandrivers; net_landriverlevel++)
		if (net_landrivers[net_landriverlevel].initialized)
			if ((ret = _Datagram_Connect (host)) != NULL)
				break;
	return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\modelgen.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// modelgen.h: header file for model generation program
//

// *********************************************************
// * This file must be identical in the modelgen directory *
// * and in the Quake directory, because it's used to      *
// * pass data from one to the other via model files.      *
// *********************************************************

#ifdef INCLUDELIBS

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "cmdlib.h"
#include "scriplib.h"
#include "trilib.h"
#include "lbmlib.h"
#include "mathlib.h"

#endif

#define ALIAS_VERSION	6

#define ALIAS_ONSEAM				0x0020

// must match definition in spritegn.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T
typedef enum {ST_SYNC=0, ST_RAND } synctype_t;
#endif

typedef enum { ALIAS_SINGLE=0, ALIAS_GROUP } aliasframetype_t;

typedef enum { ALIAS_SKIN_SINGLE=0, ALIAS_SKIN_GROUP } aliasskintype_t;

typedef struct {
	int			ident;
	int			version;
	vec3_t		scale;
	vec3_t		scale_origin;
	float		boundingradius;
	vec3_t		eyeposition;
	int			numskins;
	int			skinwidth;
	int			skinheight;
	int			numverts;
	int			numtris;
	int			numframes;
	synctype_t	synctype;
	int			flags;
	float		size;
} mdl_t;

// TODO: could be shorts

typedef struct {
	int		onseam;
	int		s;
	int		t;
} stvert_t;

typedef struct dtriangle_s {
	int					facesfront;
	int					vertindex[3];
} dtriangle_t;

#define DT_FACES_FRONT				0x0010

// This mirrors trivert_t in trilib.h, is present so Quake knows how to
// load this data

typedef struct {
	byte	v[3];
	byte	lightnormalindex;
} trivertx_t;

typedef struct {
	trivertx_t	bboxmin;	// lightnormal isn't used
	trivertx_t	bboxmax;	// lightnormal isn't used
	char		name[16];	// frame name from grabbing
} daliasframe_t;

typedef struct {
	int			numframes;
	trivertx_t	bboxmin;	// lightnormal isn't used
	trivertx_t	bboxmax;	// lightnormal isn't used
} daliasgroup_t;

typedef struct {
	int			numskins;
} daliasskingroup_t;

typedef struct {
	float	interval;
} daliasinterval_t;

typedef struct {
	float	interval;
} daliasskininterval_t;

typedef struct {
	aliasframetype_t	type;
} daliasframetype_t;

typedef struct {
	aliasskintype_t	type;
} daliasskintype_t;

#define IDPOLYHEADER	(('O'<<24)+('P'<<16)+('D'<<8)+'I')
														// little-endian "IDPO"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_loop.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_loop.c

#include "quakedef.h"
#include "net_loop.h"

qboolean	localconnectpending = false;
qsocket_t	*loop_client = NULL;
qsocket_t	*loop_server = NULL;

int Loop_Init (void)
{
	if (cls.state == ca_dedicated)
		return -1;
	return 0;
}


void Loop_Shutdown (void)
{
}


void Loop_Listen (qboolean state)
{
}


void Loop_SearchForHosts (qboolean xmit)
{
	if (!sv.active)
		return;

	hostCacheCount = 1;
	if (Q_strcmp(hostname.string, "UNNAMED") == 0)
		Q_strcpy(hostcache[0].name, "local");
	else
		Q_strcpy(hostcache[0].name, hostname.string);
	Q_strcpy(hostcache[0].map, sv.name);
	hostcache[0].users = net_activeconnections;
	hostcache[0].maxusers = svs.maxclients;
	hostcache[0].driver = net_driverlevel;
	Q_strcpy(hostcache[0].cname, "local");
}


qsocket_t *Loop_Connect (char *host)
{
	if (Q_strcmp(host,"local") != 0)
		return NULL;
	
	localconnectpending = true;

	if (!loop_client)
	{
		if ((loop_client = NET_NewQSocket ()) == NULL)
		{
			Con_Printf("Loop_Connect: no qsocket available\n");
			return NULL;
		}
		Q_strcpy (loop_client->address, "localhost");
	}
	loop_client->receiveMessageLength = 0;
	loop_client->sendMessageLength = 0;
	loop_client->canSend = true;

	if (!loop_server)
	{
		if ((loop_server = NET_NewQSocket ()) == NULL)
		{
			Con_Printf("Loop_Connect: no qsocket available\n");
			return NULL;
		}
		Q_strcpy (loop_server->address, "LOCAL");
	}
	loop_server->receiveMessageLength = 0;
	loop_server->sendMessageLength = 0;
	loop_server->canSend = true;

	loop_client->driverdata = (void *)loop_server;
	loop_server->driverdata = (void *)loop_client;
	
	return loop_client;	
}


qsocket_t *Loop_CheckNewConnections (void)
{
	if (!localconnectpending)
		return NULL;

	localconnectpending = false;
	loop_server->sendMessageLength = 0;
	loop_server->receiveMessageLength = 0;
	loop_server->canSend = true;
	loop_client->sendMessageLength = 0;
	loop_client->receiveMessageLength = 0;
	loop_client->canSend = true;
	return loop_server;
}


static int IntAlign(int value)
{
	return (value + (sizeof(int) - 1)) & (~(sizeof(int) - 1));
}


int Loop_GetMessage (qsocket_t *sock)
{
	int		ret;
	int		length;

	if (sock->receiveMessageLength == 0)
		return 0;

	ret = sock->receiveMessage[0];
	length = sock->receiveMessage[1] + (sock->receiveMessage[2] << 8);
	// alignment byte skipped here
	SZ_Clear (&net_message);
	SZ_Write (&net_message, &sock->receiveMessage[4], length);

	length = IntAlign(length + 4);
	sock->receiveMessageLength -= length;

	if (sock->receiveMessageLength)
		Q_memcpy(sock->receiveMessage, &sock->receiveMessage[length], sock->receiveMessageLength);

	if (sock->driverdata && ret == 1)
		((qsocket_t *)sock->driverdata)->canSend = true;

	return ret;
}


int Loop_SendMessage (qsocket_t *sock, sizebuf_t *data)
{
	byte *buffer;
	int  *bufferLength;

	if (!sock->driverdata)
		return -1;

	bufferLength = &((qsocket_t *)sock->driverdata)->receiveMessageLength;

	if ((*bufferLength + data->cursize + 4) > NET_MAXMESSAGE)
		Sys_Error("Loop_SendMessage: overflow\n");

	buffer = ((qsocket_t *)sock->driverdata)->receiveMessage + *bufferLength;

	// message type
	*buffer++ = 1;

	// length
	*buffer++ = data->cursize & 0xff;
	*buffer++ = data->cursize >> 8;

	// align
	buffer++;

	// message
	Q_memcpy(buffer, data->data, data->cursize);
	*bufferLength = IntAlign(*bufferLength + data->cursize + 4);

	sock->canSend = false;
	return 1;
}


int Loop_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data)
{
	byte *buffer;
	int  *bufferLength;

	if (!sock->driverdata)
		return -1;

	bufferLength = &((qsocket_t *)sock->driverdata)->receiveMessageLength;

	if ((*bufferLength + data->cursize + sizeof(byte) + sizeof(short)) > NET_MAXMESSAGE)
		return 0;

	buffer = ((qsocket_t *)sock->driverdata)->receiveMessage + *bufferLength;

	// message type
	*buffer++ = 2;

	// length
	*buffer++ = data->cursize & 0xff;
	*buffer++ = data->cursize >> 8;

	// align
	buffer++;

	// message
	Q_memcpy(buffer, data->data, data->cursize);
	*bufferLength = IntAlign(*bufferLength + data->cursize + 4);
	return 1;
}


qboolean Loop_CanSendMessage (qsocket_t *sock)
{
	if (!sock->driverdata)
		return false;
	return sock->canSend;
}


qboolean Loop_CanSendUnreliableMessage (qsocket_t *sock)
{
	return true;
}


void Loop_Close (qsocket_t *sock)
{
	if (sock->driverdata)
		((qsocket_t *)sock->driverdata)->driverdata = NULL;
	sock->receiveMessageLength = 0;
	sock->sendMessageLength = 0;
	sock->canSend = true;
	if (sock == loop_client)
		loop_client = NULL;
	else
		loop_server = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_loop.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_loop.h

int			Loop_Init (void);
void		Loop_Listen (qboolean state);
void		Loop_SearchForHosts (qboolean xmit);
qsocket_t 	*Loop_Connect (char *host);
qsocket_t 	*Loop_CheckNewConnections (void);
int			Loop_GetMessage (qsocket_t *sock);
int			Loop_SendMessage (qsocket_t *sock, sizebuf_t *data);
int			Loop_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data);
qboolean	Loop_CanSendMessage (qsocket_t *sock);
qboolean	Loop_CanSendUnreliableMessage (qsocket_t *sock);
void		Loop_Close (qsocket_t *sock);
void		Loop_Shutdown (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net.h -- quake's interface to the networking layer

struct qsockaddr
{
	short sa_family;
	unsigned char sa_data[14];
};


#define	NET_NAMELEN			64

#define NET_MAXMESSAGE		8192
#define NET_HEADERSIZE		(2 * sizeof(unsigned int))
#define NET_DATAGRAMSIZE	(MAX_DATAGRAM + NET_HEADERSIZE)

// NetHeader flags
#define NETFLAG_LENGTH_MASK	0x0000ffff
#define NETFLAG_DATA		0x00010000
#define NETFLAG_ACK			0x00020000
#define NETFLAG_NAK			0x00040000
#define NETFLAG_EOM			0x00080000
#define NETFLAG_UNRELIABLE	0x00100000
#define NETFLAG_CTL			0x80000000


#define NET_PROTOCOL_VERSION	3

// This is the network info/connection protocol.  It is used to find Quake
// servers, get info about them, and connect to them.  Once connected, the
// Quake game protocol (documented elsewhere) is used.
//
//
// General notes:
//	game_name is currently always "QUAKE", but is there so this same protocol
//		can be used for future games as well; can you say Quake2?
//
// CCREQ_CONNECT
//		string	game_name				"QUAKE"
//		byte	net_protocol_version	NET_PROTOCOL_VERSION
//
// CCREQ_SERVER_INFO
//		string	game_name				"QUAKE"
//		byte	net_protocol_version	NET_PROTOCOL_VERSION
//
// CCREQ_PLAYER_INFO
//		byte	player_number
//
// CCREQ_RULE_INFO
//		string	rule
//
//
//
// CCREP_ACCEPT
//		long	port
//
// CCREP_REJECT
//		string	reason
//
// CCREP_SERVER_INFO
//		string	server_address
//		string	host_name
//		string	level_name
//		byte	current_players
//		byte	max_players
//		byte	protocol_version	NET_PROTOCOL_VERSION
//
// CCREP_PLAYER_INFO
//		byte	player_number
//		string	name
//		long	colors
//		long	frags
//		long	connect_time
//		string	address
//
// CCREP_RULE_INFO
//		string	rule
//		string	value

//	note:
//		There are two address forms used above.  The short form is just a
//		port number.  The address that goes along with the port is defined as
//		"whatever address you receive this reponse from".  This lets us use
//		the host OS to solve the problem of multiple host addresses (possibly
//		with no routing between them); the host will use the right address
//		when we reply to the inbound connection request.  The long from is
//		a full address and port in a string.  It is used for returning the
//		address of a server that is not running locally.

#define CCREQ_CONNECT		0x01
#define CCREQ_SERVER_INFO	0x02
#define CCREQ_PLAYER_INFO	0x03
#define CCREQ_RULE_INFO		0x04

#define CCREP_ACCEPT		0x81
#define CCREP_REJECT		0x82
#define CCREP_SERVER_INFO	0x83
#define CCREP_PLAYER_INFO	0x84
#define CCREP_RULE_INFO		0x85

typedef struct qsocket_s
{
	struct qsocket_s	*next;
	double			connecttime;
	double			lastMessageTime;
	double			lastSendTime;

	qboolean		disconnected;
	qboolean		canSend;
	qboolean		sendNext;
	
	int				driver;
	int				landriver;
	int				socket;
	void			*driverdata;

	unsigned int	ackSequence;
	unsigned int	sendSequence;
	unsigned int	unreliableSendSequence;
	int				sendMessageLength;
	byte			sendMessage [NET_MAXMESSAGE];

	unsigned int	receiveSequence;
	unsigned int	unreliableReceiveSequence;
	int				receiveMessageLength;
	byte			receiveMessage [NET_MAXMESSAGE];

	struct qsockaddr	addr;
	char				address[NET_NAMELEN];

} qsocket_t;

extern qsocket_t	*net_activeSockets;
extern qsocket_t	*net_freeSockets;
extern int			net_numsockets;

typedef struct
{
	char		*name;
	qboolean	initialized;
	int			controlSock;
	int			(*Init) (void);
	void		(*Shutdown) (void);
	void		(*Listen) (qboolean state);
	int 		(*OpenSocket) (int port);
	int 		(*CloseSocket) (int socket);
	int 		(*Connect) (int socket, struct qsockaddr *addr);
	int 		(*CheckNewConnections) (void);
	int 		(*Read) (int socket, byte *buf, int len, struct qsockaddr *addr);
	int 		(*Write) (int socket, byte *buf, int len, struct qsockaddr *addr);
	int 		(*Broadcast) (int socket, byte *buf, int len);
	char *		(*AddrToString) (struct qsockaddr *addr);
	int 		(*StringToAddr) (char *string, struct qsockaddr *addr);
	int 		(*GetSocketAddr) (int socket, struct qsockaddr *addr);
	int 		(*GetNameFromAddr) (struct qsockaddr *addr, char *name);
	int 		(*GetAddrFromName) (char *name, struct qsockaddr *addr);
	int			(*AddrCompare) (struct qsockaddr *addr1, struct qsockaddr *addr2);
	int			(*GetSocketPort) (struct qsockaddr *addr);
	int			(*SetSocketPort) (struct qsockaddr *addr, int port);
} net_landriver_t;

#define	MAX_NET_DRIVERS		8
extern int 				net_numlandrivers;
extern net_landriver_t	net_landrivers[MAX_NET_DRIVERS];

typedef struct
{
	char		*name;
	qboolean	initialized;
	int			(*Init) (void);
	void		(*Listen) (qboolean state);
	void		(*SearchForHosts) (qboolean xmit);
	qsocket_t	*(*Connect) (char *host);
	qsocket_t 	*(*CheckNewConnections) (void);
	int			(*QGetMessage) (qsocket_t *sock);
	int			(*QSendMessage) (qsocket_t *sock, sizebuf_t *data);
	int			(*SendUnreliableMessage) (qsocket_t *sock, sizebuf_t *data);
	qboolean	(*CanSendMessage) (qsocket_t *sock);
	qboolean	(*CanSendUnreliableMessage) (qsocket_t *sock);
	void		(*Close) (qsocket_t *sock);
	void		(*Shutdown) (void);
	int			controlSock;
} net_driver_t;

extern int			net_numdrivers;
extern net_driver_t	net_drivers[MAX_NET_DRIVERS];

extern int			DEFAULTnet_hostport;
extern int			net_hostport;

extern int net_driverlevel;
extern cvar_t		hostname;
extern char			playername[];
extern int			playercolor;

extern int		messagesSent;
extern int		messagesReceived;
extern int		unreliableMessagesSent;
extern int		unreliableMessagesReceived;

qsocket_t *NET_NewQSocket (void);
void NET_FreeQSocket(qsocket_t *);
double SetNetTime(void);


#define HOSTCACHESIZE	8

typedef struct
{
	char	name[16];
	char	map[16];
	char	cname[32];
	int		users;
	int		maxusers;
	int		driver;
	int		ldriver;
	struct qsockaddr addr;
} hostcache_t;

extern int hostCacheCount;
extern hostcache_t hostcache[HOSTCACHESIZE];

#if !defined(_WIN32 ) && !defined (__linux__) && !defined (__sun__)
#ifndef htonl
extern unsigned long htonl (unsigned long hostlong);
#endif
#ifndef htons
extern unsigned short htons (unsigned short hostshort);
#endif
#ifndef ntohl
extern unsigned long ntohl (unsigned long netlong);
#endif
#ifndef ntohs
extern unsigned short ntohs (unsigned short netshort);
#endif
#endif

#ifdef IDGODS
qboolean IsID(struct qsockaddr *addr);
#endif

//============================================================================
//
// public network functions
//
//============================================================================

extern	double		net_time;
extern	sizebuf_t	net_message;
extern	int			net_activeconnections;

void		NET_Init (void);
void		NET_Shutdown (void);

struct qsocket_s	*NET_CheckNewConnections (void);
// returns a new connection number if there is one pending, else -1

struct qsocket_s	*NET_Connect (char *host);
// called by client to connect to a host.  Returns -1 if not able to

qboolean NET_CanSendMessage (qsocket_t *sock);
// Returns true or false if the given qsocket can currently accept a
// message to be transmitted.

int			NET_GetMessage (struct qsocket_s *sock);
// returns data in net_message sizebuf
// returns 0 if no data is waiting
// returns 1 if a message was received
// returns 2 if an unreliable message was received
// returns -1 if the connection died

int			NET_SendMessage (struct qsocket_s *sock, sizebuf_t *data);
int			NET_SendUnreliableMessage (struct qsocket_s *sock, sizebuf_t *data);
// returns 0 if the message connot be delivered reliably, but the connection
//		is still considered valid
// returns 1 if the message was sent properly
// returns -1 if the connection died

int			NET_SendToAll(sizebuf_t *data, int blocktime);
// This is a reliable *blocking* send to all attached clients.


void		NET_Close (struct qsocket_s *sock);
// if a dead connection is returned by a get or send function, this function
// should be called when it is convenient

// Server calls when a client is kicked off for a game related misbehavior
// like an illegal protocal conversation.  Client calls when disconnecting
// from a server.
// A netcon_t number will not be reused until this function is called for it

void NET_Poll(void);


typedef struct _PollProcedure
{
	struct _PollProcedure	*next;
	double					nextTime;
	void					(*procedure)(void*);
	void					*arg;
} PollProcedure;

void SchedulePollProcedure(PollProcedure *pp, double timeOffset);

extern	qboolean	serialAvailable;
extern	qboolean	ipxAvailable;
extern	qboolean	tcpipAvailable;
extern	char		my_ipx_address[NET_NAMELEN];
extern	char		my_tcpip_address[NET_NAMELEN];
extern void (*GetComPortConfig) (int portNumber, int *port, int *irq, int *baud, qboolean *useModem);
extern void (*SetComPortConfig) (int portNumber, int port, int irq, int baud, qboolean useModem);
extern void (*GetModemConfig) (int portNumber, char *dialType, char *clear, char *init, char *hangup);
extern void (*SetModemConfig) (int portNumber, char *dialType, char *clear, char *init, char *hangup);

extern	qboolean	slistInProgress;
extern	qboolean	slistSilent;
extern	qboolean	slistLocal;

void NET_Slist_f (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_main.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_main.c

#include "quakedef.h"

#include "net_vcr.h"

qsocket_t	*net_activeSockets = NULL;
qsocket_t	*net_freeSockets = NULL;
int			net_numsockets = 0;

qboolean	serialAvailable = false;
qboolean	ipxAvailable = false;
qboolean	tcpipAvailable = false;

int			net_hostport;
int			DEFAULTnet_hostport = 26000;

char		my_ipx_address[NET_NAMELEN];
char		my_tcpip_address[NET_NAMELEN];

void (*GetComPortConfig) (int portNumber, int *port, int *irq, int *baud, qboolean *useModem);
void (*SetComPortConfig) (int portNumber, int port, int irq, int baud, qboolean useModem);
void (*GetModemConfig) (int portNumber, char *dialType, char *clear, char *init, char *hangup);
void (*SetModemConfig) (int portNumber, char *dialType, char *clear, char *init, char *hangup);

static qboolean	listening = false;

qboolean	slistInProgress = false;
qboolean	slistSilent = false;
qboolean	slistLocal = true;
static double	slistStartTime;
static int		slistLastShown;

static void Slist_Send(void*);
static void Slist_Poll(void*);
PollProcedure	slistSendProcedure = {NULL, 0.0, Slist_Send};
PollProcedure	slistPollProcedure = {NULL, 0.0, Slist_Poll};


sizebuf_t		net_message;
int				net_activeconnections = 0;

int messagesSent = 0;
int messagesReceived = 0;
int unreliableMessagesSent = 0;
int unreliableMessagesReceived = 0;

cvar_t	net_messagetimeout = {"net_messagetimeout","300"};
cvar_t	hostname = {"hostname", "UNNAMED"};

qboolean	configRestored = false;
cvar_t	config_com_port = {"_config_com_port", "0x3f8", true};
cvar_t	config_com_irq = {"_config_com_irq", "4", true};
cvar_t	config_com_baud = {"_config_com_baud", "57600", true};
cvar_t	config_com_modem = {"_config_com_modem", "1", true};
cvar_t	config_modem_dialtype = {"_config_modem_dialtype", "T", true};
cvar_t	config_modem_clear = {"_config_modem_clear", "ATZ", true};
cvar_t	config_modem_init = {"_config_modem_init", "", true};
cvar_t	config_modem_hangup = {"_config_modem_hangup", "AT H", true};

#ifdef IDGODS
cvar_t	idgods = {"idgods", "0"};
#endif

int	vcrFile = -1;
qboolean recording = false;

// these two macros are to make the code more readable
#define sfunc	net_drivers[sock->driver]
#define dfunc	net_drivers[net_driverlevel]

int	net_driverlevel;


double			net_time;

double SetNetTime(void)
{
	net_time = Sys_FloatTime();
	return net_time;
}


/*
===================
NET_NewQSocket

Called by drivers when a new communications endpoint is required
The sequence and buffer fields will be filled in properly
===================
*/
qsocket_t *NET_NewQSocket (void)
{
	qsocket_t	*sock;

	if (net_freeSockets == NULL)
		return NULL;

	if (net_activeconnections >= svs.maxclients)
		return NULL;

	// get one from free list
	sock = net_freeSockets;
	net_freeSockets = sock->next;

	// add it to active list
	sock->next = net_activeSockets;
	net_activeSockets = sock;

	sock->disconnected = false;
	sock->connecttime = net_time;
	Q_strcpy (sock->address,"UNSET ADDRESS");
	sock->driver = net_driverlevel;
	sock->socket = 0;
	sock->driverdata = NULL;
	sock->canSend = true;
	sock->sendNext = false;
	sock->lastMessageTime = net_time;
	sock->ackSequence = 0;
	sock->sendSequence = 0;
	sock->unreliableSendSequence = 0;
	sock->sendMessageLength = 0;
	sock->receiveSequence = 0;
	sock->unreliableReceiveSequence = 0;
	sock->receiveMessageLength = 0;

	return sock;
}


void NET_FreeQSocket(qsocket_t *sock)
{
	qsocket_t	*s;

	// remove it from active list
	if (sock == net_activeSockets)
		net_activeSockets = net_activeSockets->next;
	else
	{
		for (s = net_activeSockets; s; s = s->next)
			if (s->next == sock)
			{
				s->next = sock->next;
				break;
			}
		if (!s)
			Sys_Error ("NET_FreeQSocket: not active\n");
	}

	// add it to free list
	sock->next = net_freeSockets;
	net_freeSockets = sock;
	sock->disconnected = true;
}


static void NET_Listen_f (void)
{
	if (Cmd_Argc () != 2)
	{
		Con_Printf ("\"listen\" is \"%u\"\n", listening ? 1 : 0);
		return;
	}

	listening = Q_atoi(Cmd_Argv(1)) ? true : false;

	for (net_driverlevel=0 ; net_driverlevel<net_numdrivers; net_driverlevel++)
	{
		if (net_drivers[net_driverlevel].initialized == false)
			continue;
		dfunc.Listen (listening);
	}
}


static void MaxPlayers_f (void)
{
	int 	n;

	if (Cmd_Argc () != 2)
	{
		Con_Printf ("\"maxplayers\" is \"%u\"\n", svs.maxclients);
		return;
	}

	if (sv.active)
	{
		Con_Printf ("maxplayers can not be changed while a server is running.\n");
		return;
	}

	n = Q_atoi(Cmd_Argv(1));
	if (n < 1)
		n = 1;
	if (n > svs.maxclientslimit)
	{
		n = svs.maxclientslimit;
		Con_Printf ("\"maxplayers\" set to \"%u\"\n", n);
	}

	if ((n == 1) && listening)
		Cbuf_AddText ("listen 0\n");

	if ((n > 1) && (!listening))
		Cbuf_AddText ("listen 1\n");

	svs.maxclients = n;
	if (n == 1)
		Cvar_Set ("deathmatch", "0");
	else
		Cvar_Set ("deathmatch", "1");
}


static void NET_Port_f (void)
{
	int 	n;

	if (Cmd_Argc () != 2)
	{
		Con_Printf ("\"port\" is \"%u\"\n", net_hostport);
		return;
	}

	n = Q_atoi(Cmd_Argv(1));
	if (n < 1 || n > 65534)
	{
		Con_Printf ("Bad value, must be between 1 and 65534\n");
		return;
	}

	DEFAULTnet_hostport = n;
	net_hostport = n;

	if (listening)
	{
		// force a change to the new port
		Cbuf_AddText ("listen 0\n");
		Cbuf_AddText ("listen 1\n");
	}
}


static void PrintSlistHeader(void)
{
	Con_Printf("Server          Map             Users\n");
	Con_Printf("--------------- --------------- -----\n");
	slistLastShown = 0;
}


static void PrintSlist(void)
{
	int n;

	for (n = slistLastShown; n < hostCacheCount; n++)
	{
		if (hostcache[n].maxusers)
			Con_Printf("%-15.15s %-15.15s %2u/%2u\n", hostcache[n].name, hostcache[n].map, hostcache[n].users, hostcache[n].maxusers);
		else
			Con_Printf("%-15.15s %-15.15s\n", hostcache[n].name, hostcache[n].map);
	}
	slistLastShown = n;
}


static void PrintSlistTrailer(void)
{
	if (hostCacheCount)
		Con_Printf("== end list ==\n\n");
	else
		Con_Printf("No Quake servers found.\n\n");
}


void NET_Slist_f (void)
{
	if (slistInProgress)
		return;

	if (! slistSilent)
	{
		Con_Printf("Looking for Quake servers...\n");
		PrintSlistHeader();
	}

	slistInProgress = true;
	slistStartTime = Sys_FloatTime();

	SchedulePollProcedure(&slistSendProcedure, 0.0);
	SchedulePollProcedure(&slistPollProcedure, 0.1);

	hostCacheCount = 0;
}


static void Slist_Send(void* dummy)
{
	for (net_driverlevel=0; net_driverlevel < net_numdrivers; net_driverlevel++)
	{
		if (!slistLocal && net_driverlevel == 0)
			continue;
		if (net_drivers[net_driverlevel].initialized == false)
			continue;
		dfunc.SearchForHosts (true);
	}

	if ((Sys_FloatTime() - slistStartTime) < 0.5)
		SchedulePollProcedure(&slistSendProcedure, 0.75);
}


static void Slist_Poll(void* dummy)
{
	for (net_driverlevel=0; net_driverlevel < net_numdrivers; net_driverlevel++)
	{
		if (!slistLocal && net_driverlevel == 0)
			continue;
		if (net_drivers[net_driverlevel].initialized == false)
			continue;
		dfunc.SearchForHosts (false);
	}

	if (! slistSilent)
		PrintSlist();

	if ((Sys_FloatTime() - slistStartTime) < 1.5)
	{
		SchedulePollProcedure(&slistPollProcedure, 0.1);
		return;
	}

	if (! slistSilent)
		PrintSlistTrailer();
	slistInProgress = false;
	slistSilent = false;
	slistLocal = true;
}


/*
===================
NET_Connect
===================
*/

int hostCacheCount = 0;
hostcache_t hostcache[HOSTCACHESIZE];

qsocket_t *NET_Connect (char *host)
{
	qsocket_t		*ret;
	int				n;
	int				numdrivers = net_numdrivers;

	SetNetTime();

	if (host && *host == 0)
		host = NULL;

	if (host)
	{
		if (Q_strcasecmp (host, "local") == 0)
		{
			numdrivers = 1;
			goto JustDoIt;
		}

		if (hostCacheCount)
		{
			for (n = 0; n < hostCacheCount; n++)
				if (Q_strcasecmp (host, hostcache[n].name) == 0)
				{
					host = hostcache[n].cname;
					break;
				}
			if (n < hostCacheCount)
				goto JustDoIt;
		}
	}

	slistSilent = host ? true : false;
	NET_Slist_f ();

	while(slistInProgress)
		NET_Poll();

	if (host == NULL)
	{
		if (hostCacheCount != 1)
			return NULL;
		host = hostcache[0].cname;
		Con_Printf("Connecting to...\n%s @ %s\n\n", hostcache[0].name, host);
	}

	if (hostCacheCount)
		for (n = 0; n < hostCacheCount; n++)
			if (Q_strcasecmp (host, hostcache[n].name) == 0)
			{
				host = hostcache[n].cname;
				break;
			}

JustDoIt:
	for (net_driverlevel=0 ; net_driverlevel<numdrivers; net_driverlevel++)
	{
		if (net_drivers[net_driverlevel].initialized == false)
			continue;
		ret = dfunc.Connect (host);
		if (ret)
			return ret;
	}

	if (host)
	{
		Con_Printf("\n");
		PrintSlistHeader();
		PrintSlist();
		PrintSlistTrailer();
	}
	
	return NULL;
}


/*
===================
NET_CheckNewConnections
===================
*/

struct
{
	double	time;
	int		op;
	long	session;
} vcrConnect;

qsocket_t *NET_CheckNewConnections (void)
{
	qsocket_t	*ret;

	SetNetTime();

	for (net_driverlevel=0 ; net_driverlevel<net_numdrivers; net_driverlevel++)
	{
		if (net_drivers[net_driverlevel].initialized == false)
			continue;
		if (net_driverlevel && listening == false)
			continue;
		ret = dfunc.CheckNewConnections ();
		if (ret)
		{
			if (recording)
			{
				vcrConnect.time = host_time;
				vcrConnect.op = VCR_OP_CONNECT;
				vcrConnect.session = (long)ret;
				Sys_FileWrite (vcrFile, &vcrConnect, sizeof(vcrConnect));
				Sys_FileWrite (vcrFile, ret->address, NET_NAMELEN);
			}
			return ret;
		}
	}
	
	if (recording)
	{
		vcrConnect.time = host_time;
		vcrConnect.op = VCR_OP_CONNECT;
		vcrConnect.session = 0;
		Sys_FileWrite (vcrFile, &vcrConnect, sizeof(vcrConnect));
	}

	return NULL;
}

/*
===================
NET_Close
===================
*/
void NET_Close (qsocket_t *sock)
{
	if (!sock)
		return;

	if (sock->disconnected)
		return;

	SetNetTime();

	// call the driver_Close function
	sfunc.Close (sock);

	NET_FreeQSocket(sock);
}


/*
=================
NET_GetMessage

If there is a complete message, return it in net_message

returns 0 if no data is waiting
returns 1 if a message was received
returns -1 if connection is invalid
=================
*/

struct
{
	double	time;
	int		op;
	long	session;
	int		ret;
	int		len;
} vcrGetMessage;

extern void PrintStats(qsocket_t *s);

int	NET_GetMessage (qsocket_t *sock)
{
	int ret;

	if (!sock)
		return -1;

	if (sock->disconnected)
	{
		Con_Printf("NET_GetMessage: disconnected socket\n");
		return -1;
	}

	SetNetTime();

	ret = sfunc.QGetMessage(sock);

	// see if this connection has timed out
	if (ret == 0 && sock->driver)
	{
		if (net_time - sock->lastMessageTime > net_messagetimeout.value)
		{
			NET_Close(sock);
			return -1;
		}
	}


	if (ret > 0)
	{
		if (sock->driver)
		{
			sock->lastMessageTime = net_time;
			if (ret == 1)
				messagesReceived++;
			else if (ret == 2)
				unreliableMessagesReceived++;
		}

		if (recording)
		{
			vcrGetMessage.time = host_time;
			vcrGetMessage.op = VCR_OP_GETMESSAGE;
			vcrGetMessage.session = (long)sock;
			vcrGetMessage.ret = ret;
			vcrGetMessage.len = net_message.cursize;
			Sys_FileWrite (vcrFile, &vcrGetMessage, 24);
			Sys_FileWrite (vcrFile, net_message.data, net_message.cursize);
		}
	}
	else
	{
		if (recording)
		{
			vcrGetMessage.time = host_time;
			vcrGetMessage.op = VCR_OP_GETMESSAGE;
			vcrGetMessage.session = (long)sock;
			vcrGetMessage.ret = ret;
			Sys_FileWrite (vcrFile, &vcrGetMessage, 20);
		}
	}

	return ret;
}


/*
==================
NET_SendMessage

Try to send a complete length+message unit over the reliable stream.
returns 0 if the message cannot be delivered reliably, but the connection
		is still considered valid
returns 1 if the message was sent properly
returns -1 if the connection died
==================
*/
struct
{
	double	time;
	int		op;
	long	session;
	int		r;
} vcrSendMessage;

int NET_SendMessage (qsocket_t *sock, sizebuf_t *data)
{
	int		r;
	
	if (!sock)
		return -1;

	if (sock->disconnected)
	{
		Con_Printf("NET_SendMessage: disconnected socket\n");
		return -1;
	}

	SetNetTime();
	r = sfunc.QSendMessage(sock, data);
	if (r == 1 && sock->driver)
		messagesSent++;

	if (recording)
	{
		vcrSendMessage.time = host_time;
		vcrSendMessage.op = VCR_OP_SENDMESSAGE;
		vcrSendMessage.session = (long)sock;
		vcrSendMessage.r = r;
		Sys_FileWrite (vcrFile, &vcrSendMessage, 20);
	}
	
	return r;
}


int NET_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data)
{
	int		r;
	
	if (!sock)
		return -1;

	if (sock->disconnected)
	{
		Con_Printf("NET_SendMessage: disconnected socket\n");
		return -1;
	}

	SetNetTime();
	r = sfunc.SendUnreliableMessage(sock, data);
	if (r == 1 && sock->driver)
		unreliableMessagesSent++;

	if (recording)
	{
		vcrSendMessage.time = host_time;
		vcrSendMessage.op = VCR_OP_SENDMESSAGE;
		vcrSendMessage.session = (long)sock;
		vcrSendMessage.r = r;
		Sys_FileWrite (vcrFile, &vcrSendMessage, 20);
	}
	
	return r;
}


/*
==================
NET_CanSendMessage

Returns true or false if the given qsocket can currently accept a
message to be transmitted.
==================
*/
qboolean NET_CanSendMessage (qsocket_t *sock)
{
	int		r;
	
	if (!sock)
		return false;

	if (sock->disconnected)
		return false;

	SetNetTime();

	r = sfunc.CanSendMessage(sock);
	
	if (recording)
	{
		vcrSendMessage.time = host_time;
		vcrSendMessage.op = VCR_OP_CANSENDMESSAGE;
		vcrSendMessage.session = (long)sock;
		vcrSendMessage.r = r;
		Sys_FileWrite (vcrFile, &vcrSendMessage, 20);
	}
	
	return r;
}


int NET_SendToAll(sizebuf_t *data, int blocktime)
{
	double		start;
	int			i;
	int			count = 0;
	qboolean	state1 [MAX_SCOREBOARD];
	qboolean	state2 [MAX_SCOREBOARD];

	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
	{
		if (!host_client->netconnection)
			continue;
		if (host_client->active)
		{
			if (host_client->netconnection->driver == 0)
			{
				NET_SendMessage(host_client->netconnection, data);
				state1[i] = true;
				state2[i] = true;
				continue;
			}
			count++;
			state1[i] = false;
			state2[i] = false;
		}
		else
		{
			state1[i] = true;
			state2[i] = true;
		}
	}

	start = Sys_FloatTime();
	while (count)
	{
		count = 0;
		for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
		{
			if (! state1[i])
			{
				if (NET_CanSendMessage (host_client->netconnection))
				{
					state1[i] = true;
					NET_SendMessage(host_client->netconnection, data);
				}
				else
				{
					NET_GetMessage (host_client->netconnection);
				}
				count++;
				continue;
			}

			if (! state2[i])
			{
				if (NET_CanSendMessage (host_client->netconnection))
				{
					state2[i] = true;
				}
				else
				{
					NET_GetMessage (host_client->netconnection);
				}
				count++;
				continue;
			}
		}
		if ((Sys_FloatTime() - start) > blocktime)
			break;
	}
	return count;
}


//=============================================================================

/*
====================
NET_Init
====================
*/

void NET_Init (void)
{
	int			i;
	int			controlSocket;
	qsocket_t	*s;

	net_hostport = DEFAULTnet_hostport;

	if (cls.state == ca_dedicated)
		listening = true;
	net_numsockets = svs.maxclientslimit;
	if (cls.state != ca_dedicated)
		net_numsockets++;

	SetNetTime();

	for (i = 0; i < net_numsockets; i++)
	{
		s = (qsocket_t *)Hunk_AllocName(sizeof(qsocket_t), "qsocket");
		s->next = net_freeSockets;
		net_freeSockets = s;
		s->disconnected = true;
	}

	// allocate space for network message buffer
	SZ_Alloc (&net_message, NET_MAXMESSAGE);

	Cvar_RegisterVariable (&net_messagetimeout);
	Cvar_RegisterVariable (&hostname);
	Cvar_RegisterVariable (&config_com_port);
	Cvar_RegisterVariable (&config_com_irq);
	Cvar_RegisterVariable (&config_com_baud);
	Cvar_RegisterVariable (&config_com_modem);
	Cvar_RegisterVariable (&config_modem_dialtype);
	Cvar_RegisterVariable (&config_modem_clear);
	Cvar_RegisterVariable (&config_modem_init);
	Cvar_RegisterVariable (&config_modem_hangup);
#ifdef IDGODS
	Cvar_RegisterVariable (&idgods);
#endif

	Cmd_AddCommand ("slist", NET_Slist_f);
	Cmd_AddCommand ("listen", NET_Listen_f);
	Cmd_AddCommand ("maxplayers", MaxPlayers_f);
	Cmd_AddCommand ("port", NET_Port_f);

	// initialize all the drivers
	for (net_driverlevel=0 ; net_driverlevel<net_numdrivers ; net_driverlevel++)
		{
		controlSocket = net_drivers[net_driverlevel].Init();
		if (controlSocket == -1)
			continue;
		net_drivers[net_driverlevel].initialized = true;
		net_drivers[net_driverlevel].controlSock = controlSocket;
		if (listening)
			net_drivers[net_driverlevel].Listen (true);
		}

	if (*my_ipx_address)
		Con_DPrintf("IPX address %s\n", my_ipx_address);
	if (*my_tcpip_address)
		Con_DPrintf("TCP/IP address %s\n", my_tcpip_address);
}

/*
====================
NET_Shutdown
====================
*/

void		NET_Shutdown (void)
{
	qsocket_t	*sock;

	SetNetTime();

	for (sock = net_activeSockets; sock; sock = sock->next)
		NET_Close(sock);

//
// shutdown the drivers
//
	for (net_driverlevel = 0; net_driverlevel < net_numdrivers; net_driverlevel++)
	{
		if (net_drivers[net_driverlevel].initialized == true)
		{
			net_drivers[net_driverlevel].Shutdown ();
			net_drivers[net_driverlevel].initialized = false;
		}
	}

	if (vcrFile != -1)
	{
		Con_Printf ("Closing vcrfile.\n");
		Sys_FileClose(vcrFile);
	}
}


static PollProcedure *pollProcedureList = NULL;

void NET_Poll(void)
{
	PollProcedure *pp;
	qboolean	useModem;

	if (!configRestored)
	{
		if (serialAvailable)
		{
			if (config_com_modem.value == 1.0)
				useModem = true;
			else
				useModem = false;
			SetComPortConfig (0, (int)config_com_port.value, (int)config_com_irq.value, (int)config_com_baud.value, useModem);
			SetModemConfig (0, config_modem_dialtype.string, config_modem_clear.string, config_modem_init.string, config_modem_hangup.string);
		}
		configRestored = true;
	}

	SetNetTime();

	for (pp = pollProcedureList; pp; pp = pp->next)
	{
		if (pp->nextTime > net_time)
			break;
		pollProcedureList = pp->next;
		pp->procedure(pp->arg);
	}
}


void SchedulePollProcedure(PollProcedure *proc, double timeOffset)
{
	PollProcedure *pp, *prev;

	proc->nextTime = Sys_FloatTime() + timeOffset;
	for (pp = pollProcedureList, prev = NULL; pp; pp = pp->next)
	{
		if (pp->nextTime >= proc->nextTime)
			break;
		prev = pp;
	}

	if (prev == NULL)
	{
		proc->next = pollProcedureList;
		pollProcedureList = proc;
		return;
	}

	proc->next = pp;
	prev->next = proc;
}


#ifdef IDGODS
#define IDNET	0xc0f62800

qboolean IsID(struct qsockaddr *addr)
{
	if (idgods.value == 0.0)
		return false;

	if (addr->sa_family != 2)
		return false;

	if ((BigLong(*(int *)&addr->sa_data[2]) & 0xffffff00) == IDNET)
		return true;
	return false;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_wins.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_wins.h

int  WINS_Init (void);
void WINS_Shutdown (void);
void WINS_Listen (qboolean state);
int  WINS_OpenSocket (int port);
int  WINS_CloseSocket (int socket);
int  WINS_Connect (int socket, struct qsockaddr *addr);
int  WINS_CheckNewConnections (void);
int  WINS_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  WINS_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  WINS_Broadcast (int socket, byte *buf, int len);
char *WINS_AddrToString (struct qsockaddr *addr);
int  WINS_StringToAddr (char *string, struct qsockaddr *addr);
int  WINS_GetSocketAddr (int socket, struct qsockaddr *addr);
int  WINS_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  WINS_GetAddrFromName (char *name, struct qsockaddr *addr);
int  WINS_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  WINS_GetSocketPort (struct qsockaddr *addr);
int  WINS_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_vcr.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_vcr.h

#define VCR_OP_CONNECT					1
#define VCR_OP_GETMESSAGE				2
#define VCR_OP_SENDMESSAGE				3
#define VCR_OP_CANSENDMESSAGE			4
#define VCR_MAX_MESSAGE					4

int			VCR_Init (void);
void		VCR_Listen (qboolean state);
void		VCR_SearchForHosts (qboolean xmit);
qsocket_t 	*VCR_Connect (char *host);
qsocket_t 	*VCR_CheckNewConnections (void);
int			VCR_GetMessage (qsocket_t *sock);
int			VCR_SendMessage (qsocket_t *sock, sizebuf_t *data);
qboolean	VCR_CanSendMessage (qsocket_t *sock);
void		VCR_Close (qsocket_t *sock);
void		VCR_Shutdown (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_ser.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_ser.h

int			Serial_Init (void);
void		Serial_Listen (qboolean state);
void		Serial_SearchForHosts (qboolean xmit);
qsocket_t	*Serial_Connect (char *host);
qsocket_t 	*Serial_CheckNewConnections (void);
int			Serial_GetMessage (qsocket_t *sock);
int			Serial_SendMessage (qsocket_t *sock, sizebuf_t *data);
int			Serial_SendUnreliableMessage (qsocket_t *sock, sizebuf_t *data);
qboolean	Serial_CanSendMessage (qsocket_t *sock);
qboolean	Serial_CanSendUnreliableMessage (qsocket_t *sock);
void		Serial_Close (qsocket_t *sock);
void		Serial_Shutdown (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\progdefs.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#ifdef QUAKE2
#include "progdefs.q2"
#else
#include "progdefs.q1"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_wins.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_wins.c

#include "quakedef.h"
#include "xquake.h"

extern cvar_t hostname;

#define MAXHOSTNAMELEN      256

static int net_acceptsocket = -1;       // socket for fielding new connections
static int net_controlsocket;
static int net_broadcastsocket = 0;
static struct qsockaddr broadcastaddr;

static unsigned long myAddr;

qboolean    winsock_lib_initialized;

int (PASCAL FAR *pWSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
int (PASCAL FAR *pWSACleanup)(void);
int (PASCAL FAR *pWSAGetLastError)(void);
SOCKET (PASCAL FAR *psocket)(int af, int type, int protocol);
int (PASCAL FAR *pioctlsocket)(SOCKET s, long cmd, u_long FAR *argp);
int (PASCAL FAR *psetsockopt)(SOCKET s, int level, int optname,
                              const char FAR * optval, int optlen);
int (PASCAL FAR *precvfrom)(SOCKET s, char FAR * buf, int len, int flags,
                            struct sockaddr FAR *from, int FAR * fromlen);
int (PASCAL FAR *psendto)(SOCKET s, const char FAR * buf, int len, int flags,
                          const struct sockaddr FAR *to, int tolen);
int (PASCAL FAR *pclosesocket)(SOCKET s);

#ifndef _XBOX

int (PASCAL FAR *pgethostname)(char FAR * name, int namelen);
struct hostent FAR * (PASCAL FAR *pgethostbyname)(const char FAR * name);
struct hostent FAR * (PASCAL FAR *pgethostbyaddr)(const char FAR * addr, int len, int type);

#endif

int (PASCAL FAR *pgetsockname)(SOCKET s, struct sockaddr FAR *name,
                               int FAR * namelen);

#include "net_wins.h"

#ifdef _XBOX
PVOID xnet_section = NULL;
struct hostent* WSAAPI gethostbyname(const char* name) { return NULL; }
struct hostent* WSAAPI gethostbyaddr(const char* addr, int len, int type) { return NULL; }
#endif

int winsock_initialized = 0;
WSADATA     winsockdata;

//=============================================================================

static double   blocktime;

BOOL PASCAL FAR BlockingHook(void)  
{ 
#if defined(XBOX)
    return TRUE;
#else
    MSG     msg;
    BOOL    ret;
 
    if ((Sys_FloatTime() - blocktime) > 2.0)
    {
        WSACancelBlockingCall();
        return FALSE;
    }

    /* get the next message, if any */ 
    ret = (BOOL) PeekMessage(&msg, NULL, 0, 0, PM_REMOVE); 
 
    /* if we got one, process it */ 
    if (ret) { 
        TranslateMessage(&msg); 
        DispatchMessage(&msg); 
    } 
 
    /* TRUE if we got a message */ 
    return ret; 
#endif
} 


void WINS_GetLocalAddress()
{
    struct hostent  *local = NULL;
    char            buff[MAXHOSTNAMELEN];
    unsigned long   addr;
#ifdef _XBOX
    XNADDR          XnAddr;
#else
    struct in_addr  inaddr;
#endif

    if (myAddr != INADDR_ANY)
        return;

#ifdef _XBOX

    if (0 == XNetGetTitleXnAddr(&XnAddr)) return;
    myAddr = XnAddr.ina.s_addr;

#else

    if (pgethostname(buff, MAXHOSTNAMELEN) == SOCKET_ERROR)
        return;

    blocktime = Sys_FloatTime();

    WSASetBlockingHook(BlockingHook);

    local = pgethostbyname(buff);

    WSAUnhookBlockingHook();

    if (local == NULL)
        return;

    myAddr = *(int *)local->h_addr_list[0];

#endif

    addr = ntohl(myAddr);
    sprintf(my_tcpip_address, "%d.%d.%d.%d", (addr >> 24) & 0xff, (addr >> 16) & 0xff, (addr >> 8) & 0xff, addr & 0xff);
}


int WINS_Init (void)
{
    int     i;
#ifdef _XBOX
    XNADDR  XnAddr;
#endif
    char    buff[MAXHOSTNAMELEN];
    char    *p;
    int     r;
    WORD    wVersionRequested;

    winsock_lib_initialized = true;

#ifdef _XBOX
    xnet_section = XLoadSection("XNET");
    if (xnet_section == NULL) return -1;

    if (XNetStartup(NULL) != NO_ERROR) {
        XFreeSection("XNET");
        xnet_section = NULL;
        return -1;
    }
#endif

    pWSAStartup = (void *)WSAStartup;
    pWSACleanup = (void *)WSACleanup;
    pWSAGetLastError = (void *)WSAGetLastError;
    psocket = (void *)socket;
    pioctlsocket = (void *)ioctlsocket;
    psetsockopt = (void *)setsockopt;
    precvfrom = (void *)recvfrom;
    psendto = (void *)sendto;
    pclosesocket = (void *)closesocket;
#ifndef _XBOX
    pgethostname = (void *)gethostname;
    pgethostbyname = (void *)gethostbyname;
    pgethostbyaddr = (void *)gethostbyaddr;
#endif
    pgetsockname = (void *)getsockname;

    if (winsock_initialized == 0)
    {
        wVersionRequested = MAKEWORD(1, 1); 

        r = pWSAStartup (MAKEWORD(1, 1), &winsockdata);

        if (r)
        {
            Con_SafePrintf ("Winsock initialization failed.\n");
            return -1;
        }
    }
    winsock_initialized++;

#ifdef _XBOX
    // determine my name
    if (XNetGetTitleXnAddr(&XnAddr) == 0)
    {
        Con_DPrintf ("Winsock TCP/IP Initialization failed.\n");
        if (--winsock_initialized == 0)
            pWSACleanup ();
        return -1;
    }

    sprintf(buff, "%02x-%02x-%02x-%02x-%02x-%02x", XnAddr.abEnet[0], XnAddr.abEnet[1], XnAddr.abEnet[2], XnAddr.abEnet[3], XnAddr.abEnet[4], XnAddr.abEnet[5]);
#else
    // determine my name
    if (pgethostname(buff, MAXHOSTNAMELEN) == SOCKET_ERROR)
    {
        Con_DPrintf ("Winsock TCP/IP Initialization failed.\n");
        if (--winsock_initialized == 0)
            pWSACleanup ();
        return -1;
    }
#endif

    // if the quake hostname isn't set, set it to the machine name
    if (Q_strcmp(hostname.string, "UNNAMED") == 0)
    {
        // see if it's a text IP address (well, close enough)
        for (p = buff; *p; p++)
            if ((*p < '0' || *p > '9') && *p != '.')
                break;

        // if it is a real name, strip off the domain; we only want the host
        if (*p)
        {
            for (i = 0; i < 15; i++)
                if (buff[i] == '.')
                    break;
            buff[i] = 0;
        }
        Cvar_Set ("hostname", buff);
    }

    myAddr = INADDR_ANY;
    strcpy(my_tcpip_address, "INADDR_ANY");

    if ((net_controlsocket = WINS_OpenSocket (0)) == -1)
    {
        Con_Printf("WINS_Init: Unable to open control socket\n");
        if (--winsock_initialized == 0)
            pWSACleanup ();
        return -1;
    }

    ((struct sockaddr_in *)&broadcastaddr)->sin_family = AF_INET;
    ((struct sockaddr_in *)&broadcastaddr)->sin_addr.s_addr = INADDR_BROADCAST;
    ((struct sockaddr_in *)&broadcastaddr)->sin_port = htons((unsigned short)net_hostport);

    Con_Printf("Winsock TCP/IP Initialized\n");
    tcpipAvailable = true;

    return net_controlsocket;
}

//=============================================================================

void WINS_Shutdown (void)
{
    WINS_Listen (false);
    WINS_CloseSocket (net_controlsocket);
    if (--winsock_initialized == 0) {
        pWSACleanup ();

        #ifdef _XBOX
        if (xnet_section) {
            XNetCleanup();
            XFreeSection("XNET");
            xnet_section = NULL;
        }
        #endif
    }
}

//=============================================================================

void WINS_Listen (qboolean state)
{
    // enable listening
    if (state)
    {
        if (net_acceptsocket != -1)
            return;
        WINS_GetLocalAddress();
        if ((net_acceptsocket = WINS_OpenSocket (net_hostport)) == -1)
            Sys_Error ("WINS_Listen: Unable to open accept socket\n");
        return;
    }

    // disable listening
    if (net_acceptsocket == -1)
        return;
    WINS_CloseSocket (net_acceptsocket);
    net_acceptsocket = -1;
}

//=============================================================================

int WINS_OpenSocket (int port)
{
    int newsocket;
    struct sockaddr_in address;
    u_long _true = 1;

    if ((newsocket = psocket (PF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
        return -1;

    if (pioctlsocket (newsocket, FIONBIO, &_true) == -1)
        goto ErrorReturn;

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = myAddr;
    address.sin_port = htons((unsigned short)port);
    if( bind (newsocket, (void *)&address, sizeof(address)) == 0)
        return newsocket;

    Sys_Error ("Unable to bind to %s", WINS_AddrToString((struct qsockaddr *)&address));
ErrorReturn:
    pclosesocket (newsocket);
    return -1;
}

//=============================================================================

int WINS_CloseSocket (int socket)
{
    if (socket == net_broadcastsocket)
        net_broadcastsocket = 0;
    return pclosesocket (socket);
}


//=============================================================================
/*
============
PartialIPAddress

this lets you type only as much of the net address as required, using
the local network components to fill in the rest
============
*/
static int PartialIPAddress (char *in, struct qsockaddr *hostaddr)
{
    char buff[256];
    char *b;
    int addr;
    int num;
    int mask;
    int run;
    int port;
    
    buff[0] = '.';
    b = buff;
    strcpy(buff+1, in);
    if (buff[1] == '.')
        b++;

    addr = 0;
    mask=-1;
    while (*b == '.')
    {
        b++;
        num = 0;
        run = 0;
        while (!( *b < '0' || *b > '9'))
        {
          num = num*10 + *b++ - '0';
          if (++run > 3)
            return -1;
        }
        if ((*b < '0' || *b > '9') && *b != '.' && *b != ':' && *b != 0)
            return -1;
        if (num < 0 || num > 255)
            return -1;
        mask<<=8;
        addr = (addr<<8) + num;
    }
    
    if (*b++ == ':')
        port = Q_atoi(b);
    else
        port = net_hostport;

    hostaddr->sa_family = AF_INET;
    ((struct sockaddr_in *)hostaddr)->sin_port = htons((short)port);    
    ((struct sockaddr_in *)hostaddr)->sin_addr.s_addr = (myAddr & htonl(mask)) | htonl(addr);
    
    return 0;
}
//=============================================================================

int WINS_Connect (int socket, struct qsockaddr *addr)
{
    return 0;
}

//=============================================================================

int WINS_CheckNewConnections (void)
{
#if 0
    // Original way, used MSG_PEEK, which is inefficient.
    char buf[4096];

    if (net_acceptsocket == -1)
        return -1;

    if (precvfrom (net_acceptsocket, buf, sizeof(buf), MSG_PEEK, NULL, NULL) > 0)
    {
        return net_acceptsocket;
    }
    return -1;
#else
    u_long readcnt = 0;

    if (net_acceptsocket == -1)
        return -1;

    if (ioctlsocket(net_acceptsocket, FIONREAD, &readcnt) == 0 && readcnt > 0)
        return net_acceptsocket;

    return -1;
#endif
}

//=============================================================================

int WINS_Read (int socket, byte *buf, int len, struct qsockaddr *addr)
{
    int addrlen = sizeof (struct qsockaddr);
    int ret;

    ret = precvfrom (socket, buf, len, 0, (struct sockaddr *)addr, &addrlen);
    if (ret == -1)
    {
        int err = pWSAGetLastError();

        if (err == WSAEWOULDBLOCK || err == WSAECONNREFUSED)
            return 0;

    }
    return ret;
}

//=============================================================================

int WINS_MakeSocketBroadcastCapable (int socket)
{
    int i = 1;

    // make this socket broadcast capable
    if (psetsockopt(socket, SOL_SOCKET, SO_BROADCAST, (char *)&i, sizeof(i)) < 0)
        return -1;
    net_broadcastsocket = socket;

    return 0;
}

//=============================================================================

int WINS_Broadcast (int socket, byte *buf, int len)
{
    int ret;

    if (socket != net_broadcastsocket)
    {
        if (net_broadcastsocket != 0)
            Sys_Error("Attempted to use multiple broadcasts sockets\n");
        WINS_GetLocalAddress();
        ret = WINS_MakeSocketBroadcastCapable (socket);
        if (ret == -1)
        {
            Con_Printf("Unable to make socket broadcast capable\n");
            return ret;
        }
    }

    return WINS_Write (socket, buf, len, &broadcastaddr);
}

//=============================================================================

int WINS_Write (int socket, byte *buf, int len, struct qsockaddr *addr)
{
    int ret;

    ret = psendto (socket, buf, len, 0, (struct sockaddr *)addr, sizeof(struct qsockaddr));
    if (ret == -1)
        if (pWSAGetLastError() == WSAEWOULDBLOCK)
            return 0;

    return ret;
}

//=============================================================================

char *WINS_AddrToString (struct qsockaddr *addr)
{
    static char buffer[22];
    int haddr;

    haddr = ntohl(((struct sockaddr_in *)addr)->sin_addr.s_addr);
    sprintf(buffer, "%d.%d.%d.%d:%d", (haddr >> 24) & 0xff, (haddr >> 16) & 0xff, (haddr >> 8) & 0xff, haddr & 0xff, ntohs(((struct sockaddr_in *)addr)->sin_port));
    return buffer;
}

//=============================================================================

int WINS_StringToAddr (char *string, struct qsockaddr *addr)
{
    int ha1, ha2, ha3, ha4, hp;
    int ipaddr;

    sscanf(string, "%d.%d.%d.%d:%d", &ha1, &ha2, &ha3, &ha4, &hp);
    ipaddr = (ha1 << 24) | (ha2 << 16) | (ha3 << 8) | ha4;

    addr->sa_family = AF_INET;
    ((struct sockaddr_in *)addr)->sin_addr.s_addr = htonl(ipaddr);
    ((struct sockaddr_in *)addr)->sin_port = htons((unsigned short)hp);
    return 0;
}

//=============================================================================

int WINS_GetSocketAddr (int socket, struct qsockaddr *addr)
{
    int addrlen = sizeof(struct qsockaddr);
    unsigned int a;

    Q_memset(addr, 0, sizeof(struct qsockaddr));
    pgetsockname(socket, (struct sockaddr *)addr, &addrlen);
    a = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
    if (a == 0 || a == inet_addr("127.0.0.1"))
        ((struct sockaddr_in *)addr)->sin_addr.s_addr = myAddr;

    return 0;
}

//=============================================================================

int WINS_GetNameFromAddr (struct qsockaddr *addr, char *name)
{
#ifndef _XBOX
    struct hostent *hostentry;

    hostentry = pgethostbyaddr ((char *)&((struct sockaddr_in *)addr)->sin_addr, sizeof(struct in_addr), AF_INET);
    if (hostentry)
    {
        Q_strncpy (name, (char *)hostentry->h_name, NET_NAMELEN - 1);
        return 0;
    }
#endif

    Q_strcpy (name, WINS_AddrToString (addr));
    return 0;
}

//=============================================================================

int WINS_GetAddrFromName(char *name, struct qsockaddr *addr)
{
#ifndef _XBOX
    struct hostent *hostentry;

    if (name[0] >= '0' && name[0] <= '9')
        return PartialIPAddress (name, addr);
    
    hostentry = pgethostbyname (name);
    if (!hostentry)
        return -1;
#endif

    addr->sa_family = AF_INET;
    ((struct sockaddr_in *)addr)->sin_port = htons((unsigned short)net_hostport);   
#ifndef _XBOX
    ((struct sockaddr_in *)addr)->sin_addr.s_addr = *(int *)hostentry->h_addr_list[0];
#else
    ((struct sockaddr_in *)addr)->sin_addr.s_addr = inet_addr(name);;
#endif

    return 0;
}

//=============================================================================

int WINS_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2)
{
    if (addr1->sa_family != addr2->sa_family)
        return -1;

    if (((struct sockaddr_in *)addr1)->sin_addr.s_addr != ((struct sockaddr_in *)addr2)->sin_addr.s_addr)
        return -1;

    if (((struct sockaddr_in *)addr1)->sin_port != ((struct sockaddr_in *)addr2)->sin_port)
        return 1;

    return 0;
}

//=============================================================================

int WINS_GetSocketPort (struct qsockaddr *addr)
{
    return ntohs(((struct sockaddr_in *)addr)->sin_port);
}


int WINS_SetSocketPort (struct qsockaddr *addr, int port)
{
    ((struct sockaddr_in *)addr)->sin_port = htons((unsigned short)port);
    return 0;
}

//=============================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_wipx.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_wipx.h

int  WIPX_Init (void);
void WIPX_Shutdown (void);
void WIPX_Listen (qboolean state);
int  WIPX_OpenSocket (int port);
int  WIPX_CloseSocket (int socket);
int  WIPX_Connect (int socket, struct qsockaddr *addr);
int  WIPX_CheckNewConnections (void);
int  WIPX_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  WIPX_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  WIPX_Broadcast (int socket, byte *buf, int len);
char *WIPX_AddrToString (struct qsockaddr *addr);
int  WIPX_StringToAddr (char *string, struct qsockaddr *addr);
int  WIPX_GetSocketAddr (int socket, struct qsockaddr *addr);
int  WIPX_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  WIPX_GetAddrFromName (char *name, struct qsockaddr *addr);
int  WIPX_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  WIPX_GetSocketPort (struct qsockaddr *addr);
int  WIPX_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_vcr.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_vcr.c

#include "quakedef.h"

#include "net_vcr.h"

extern int vcrFile;

// This is the playback portion of the VCR.  It reads the file produced
// by the recorder and plays it back to the host.  The recording contains
// everything necessary (events, timestamps, and data) to duplicate the game
// from the viewpoint of everything above the network layer.

static struct
{
	double	time;
	int		op;
	long	session;
}	next;

int VCR_Init (void)
{
	net_drivers[0].Init = VCR_Init;

	net_drivers[0].SearchForHosts = VCR_SearchForHosts;
	net_drivers[0].Connect = VCR_Connect;
	net_drivers[0].CheckNewConnections = VCR_CheckNewConnections;
	net_drivers[0].QGetMessage = VCR_GetMessage;
	net_drivers[0].QSendMessage = VCR_SendMessage;
	net_drivers[0].CanSendMessage = VCR_CanSendMessage;
	net_drivers[0].Close = VCR_Close;
	net_drivers[0].Shutdown = VCR_Shutdown;

	Sys_FileRead(vcrFile, &next, sizeof(next));
	return 0;
}

void VCR_ReadNext (void)
{
	if (Sys_FileRead(vcrFile, &next, sizeof(next)) == 0)
	{
		next.op = 255;
		Sys_Error ("=== END OF PLAYBACK===\n");
	}
	if (next.op < 1 || next.op > VCR_MAX_MESSAGE)
		Sys_Error ("VCR_ReadNext: bad op");
}


void VCR_Listen (qboolean state)
{
}


void VCR_Shutdown (void)
{
}


int VCR_GetMessage (qsocket_t *sock)
{
	int	ret;
	
	if (host_time != next.time || next.op != VCR_OP_GETMESSAGE || next.session != *(long *)(&sock->driverdata))
		Sys_Error ("VCR missmatch");

	Sys_FileRead(vcrFile, &ret, sizeof(int));
	if (ret != 1)
	{
		VCR_ReadNext ();
		return ret;
	}

	Sys_FileRead(vcrFile, &net_message.cursize, sizeof(int));
	Sys_FileRead(vcrFile, net_message.data, net_message.cursize);

	VCR_ReadNext ();

	return 1;
}


int VCR_SendMessage (qsocket_t *sock, sizebuf_t *data)
{
	int	ret;

	if (host_time != next.time || next.op != VCR_OP_SENDMESSAGE || next.session != *(long *)(&sock->driverdata))
		Sys_Error ("VCR missmatch");

	Sys_FileRead(vcrFile, &ret, sizeof(int));

	VCR_ReadNext ();

	return ret;
}


qboolean VCR_CanSendMessage (qsocket_t *sock)
{
	qboolean	ret;

	if (host_time != next.time || next.op != VCR_OP_CANSENDMESSAGE || next.session != *(long *)(&sock->driverdata))
		Sys_Error ("VCR missmatch");

	Sys_FileRead(vcrFile, &ret, sizeof(int));

	VCR_ReadNext ();

	return ret;
}


void VCR_Close (qsocket_t *sock)
{
}


void VCR_SearchForHosts (qboolean xmit)
{
}


qsocket_t *VCR_Connect (char *host)
{
	return NULL;
}


qsocket_t *VCR_CheckNewConnections (void)
{
	qsocket_t	*sock;

	if (host_time != next.time || next.op != VCR_OP_CONNECT)
		Sys_Error ("VCR missmatch");

	if (!next.session)
	{
		VCR_ReadNext ();
		return NULL;
	}

	sock = NET_NewQSocket ();
	*(long *)(&sock->driverdata) = next.session;

	Sys_FileRead (vcrFile, sock->address, NET_NAMELEN);
	VCR_ReadNext ();

	return sock;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\net_win.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "quakedef.h"

#include "net_loop.h"
#include "net_dgrm.h"
#include "net_ser.h"

net_driver_t net_drivers[MAX_NET_DRIVERS] =
{
	{
	"Loopback",
	false,
	Loop_Init,
	Loop_Listen,
	Loop_SearchForHosts,
	Loop_Connect,
	Loop_CheckNewConnections,
	Loop_GetMessage,
	Loop_SendMessage,
	Loop_SendUnreliableMessage,
	Loop_CanSendMessage,
	Loop_CanSendUnreliableMessage,
	Loop_Close,
	Loop_Shutdown
	}
	,
	{
	"Datagram",
	false,
	Datagram_Init,
	Datagram_Listen,
	Datagram_SearchForHosts,
	Datagram_Connect,
	Datagram_CheckNewConnections,
	Datagram_GetMessage,
	Datagram_SendMessage,
	Datagram_SendUnreliableMessage,
	Datagram_CanSendMessage,
	Datagram_CanSendUnreliableMessage,
	Datagram_Close,
	Datagram_Shutdown
	}
};

int net_numdrivers = 2;


#include "net_wins.h"
#include "net_wipx.h"

net_landriver_t	net_landrivers[MAX_NET_DRIVERS] =
{
	{
	"Winsock TCPIP",
	false,
	0,
	WINS_Init,
	WINS_Shutdown,
	WINS_Listen,
	WINS_OpenSocket,
	WINS_CloseSocket,
	WINS_Connect,
	WINS_CheckNewConnections,
	WINS_Read,
	WINS_Write,
	WINS_Broadcast,
	WINS_AddrToString,
	WINS_StringToAddr,
	WINS_GetSocketAddr,
	WINS_GetNameFromAddr,
	WINS_GetAddrFromName,
	WINS_AddrCompare,
	WINS_GetSocketPort,
	WINS_SetSocketPort
	},

	{
	"Winsock IPX",
	false,
	0,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
	}

};

int net_numlandrivers = 1;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\pr_cmds.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"

#define	RETURN_EDICT(e) (((int *)pr_globals)[OFS_RETURN] = EDICT_TO_PROG(e))

/*
===============================================================================

						BUILT-IN FUNCTIONS

===============================================================================
*/

char *PF_VarString (int	first)
{
	int		i;
	static char out[256];
	
	out[0] = 0;
	for (i=first ; i<pr_argc ; i++)
	{
		strcat (out, G_STRING((OFS_PARM0+i*3)));
	}
	return out;
}


/*
=================
PF_errror

This is a TERMINAL error, which will kill off the entire server.
Dumps self.

error(value)
=================
*/
void PF_error (void)
{
	char	*s;
	edict_t	*ed;
	
	s = PF_VarString(0);
	Con_Printf ("======SERVER ERROR in %s:\n%s\n"
	,pr_strings + pr_xfunction->s_name,s);
	ed = PROG_TO_EDICT(pr_global_struct->self);
	ED_Print (ed);

	Host_Error ("Program error");
}

/*
=================
PF_objerror

Dumps out self, then an error message.  The program is aborted and self is
removed, but the level can continue.

objerror(value)
=================
*/
void PF_objerror (void)
{
	char	*s;
	edict_t	*ed;
	
	s = PF_VarString(0);
	Con_Printf ("======OBJECT ERROR in %s:\n%s\n"
	,pr_strings + pr_xfunction->s_name,s);
	ed = PROG_TO_EDICT(pr_global_struct->self);
	ED_Print (ed);
	ED_Free (ed);
	
	Host_Error ("Program error");
}



/*
==============
PF_makevectors

Writes new values for v_forward, v_up, and v_right based on angles
makevectors(vector)
==============
*/
void PF_makevectors (void)
{
	AngleVectors (G_VECTOR(OFS_PARM0), pr_global_struct->v_forward, pr_global_struct->v_right, pr_global_struct->v_up);
}

/*
=================
PF_setorigin

This is the only valid way to move an object without using the physics of the world (setting velocity and waiting).  Directly changing origin will not set internal links correctly, so clipping would be messed up.  This should be called when an object is spawned, and then only if it is teleported.

setorigin (entity, origin)
=================
*/
void PF_setorigin (void)
{
	edict_t	*e;
	float	*org;
	
	e = G_EDICT(OFS_PARM0);
	org = G_VECTOR(OFS_PARM1);
	VectorCopy (org, e->v.origin);
	SV_LinkEdict (e, false);
}


void SetMinMaxSize (edict_t *e, float *min, float *max, qboolean rotate)
{
	float	*angles;
	vec3_t	rmin, rmax;
	float	bounds[2][3];
	float	xvector[2], yvector[2];
	float	a;
	vec3_t	base, transformed;
	int		i, j, k, l;
	
	for (i=0 ; i<3 ; i++)
		if (min[i] > max[i])
			PR_RunError ("backwards mins/maxs");

	rotate = false;		// FIXME: implement rotation properly again

	if (!rotate)
	{
		VectorCopy (min, rmin);
		VectorCopy (max, rmax);
	}
	else
	{
	// find min / max for rotations
		angles = e->v.angles;
		
		a = angles[1]/180 * M_PI;
		
		xvector[0] = cos(a);
		xvector[1] = sin(a);
		yvector[0] = -sin(a);
		yvector[1] = cos(a);
		
		VectorCopy (min, bounds[0]);
		VectorCopy (max, bounds[1]);
		
		rmin[0] = rmin[1] = rmin[2] = 9999;
		rmax[0] = rmax[1] = rmax[2] = -9999;
		
		for (i=0 ; i<= 1 ; i++)
		{
			base[0] = bounds[i][0];
			for (j=0 ; j<= 1 ; j++)
			{
				base[1] = bounds[j][1];
				for (k=0 ; k<= 1 ; k++)
				{
					base[2] = bounds[k][2];
					
				// transform the point
					transformed[0] = xvector[0]*base[0] + yvector[0]*base[1];
					transformed[1] = xvector[1]*base[0] + yvector[1]*base[1];
					transformed[2] = base[2];
					
					for (l=0 ; l<3 ; l++)
					{
						if (transformed[l] < rmin[l])
							rmin[l] = transformed[l];
						if (transformed[l] > rmax[l])
							rmax[l] = transformed[l];
					}
				}
			}
		}
	}
	
// set derived values
	VectorCopy (rmin, e->v.mins);
	VectorCopy (rmax, e->v.maxs);
	VectorSubtract (max, min, e->v.size);
	
	SV_LinkEdict (e, false);
}

/*
=================
PF_setsize

the size box is rotated by the current angle

setsize (entity, minvector, maxvector)
=================
*/
void PF_setsize (void)
{
	edict_t	*e;
	float	*min, *max;
	
	e = G_EDICT(OFS_PARM0);
	min = G_VECTOR(OFS_PARM1);
	max = G_VECTOR(OFS_PARM2);
	SetMinMaxSize (e, min, max, false);
}


/*
=================
PF_setmodel

setmodel(entity, model)
=================
*/
void PF_setmodel (void)
{
	edict_t	*e;
	char	*m, **check;
	model_t	*mod;
	int		i;

	e = G_EDICT(OFS_PARM0);
	m = G_STRING(OFS_PARM1);

// check to see if model was properly precached
	for (i=0, check = sv.model_precache ; *check ; i++, check++)
		if (!strcmp(*check, m))
			break;
			
	if (!*check)
		PR_RunError ("no precache: %s\n", m);
		

	e->v.model = m - pr_strings;
	e->v.modelindex = i; //SV_ModelIndex (m);

	mod = sv.models[ (int)e->v.modelindex];  // Mod_ForName (m, true);
	
	if (mod)
		SetMinMaxSize (e, mod->mins, mod->maxs, true);
	else
		SetMinMaxSize (e, vec3_origin, vec3_origin, true);
}

/*
=================
PF_bprint

broadcast print to everyone on server

bprint(value)
=================
*/
void PF_bprint (void)
{
	char		*s;

	s = PF_VarString(0);
	SV_BroadcastPrintf ("%s", s);
}

/*
=================
PF_sprint

single print to a specific client

sprint(clientent, value)
=================
*/
void PF_sprint (void)
{
	char		*s;
	client_t	*client;
	int			entnum;
	
	entnum = G_EDICTNUM(OFS_PARM0);
	s = PF_VarString(1);
	
	if (entnum < 1 || entnum > svs.maxclients)
	{
		Con_Printf ("tried to sprint to a non-client\n");
		return;
	}
		
	client = &svs.clients[entnum-1];
		
	MSG_WriteChar (&client->message,svc_print);
	MSG_WriteString (&client->message, s );
}


/*
=================
PF_centerprint

single print to a specific client

centerprint(clientent, value)
=================
*/
void PF_centerprint (void)
{
	char		*s;
	client_t	*client;
	int			entnum;
	
	entnum = G_EDICTNUM(OFS_PARM0);
	s = PF_VarString(1);
	
	if (entnum < 1 || entnum > svs.maxclients)
	{
		Con_Printf ("tried to sprint to a non-client\n");
		return;
	}
		
	client = &svs.clients[entnum-1];
		
	MSG_WriteChar (&client->message,svc_centerprint);
	MSG_WriteString (&client->message, s );
}


/*
=================
PF_normalize

vector normalize(vector)
=================
*/
void PF_normalize (void)
{
	float	*value1;
	vec3_t	newvalue;
	float	new;
	
	value1 = G_VECTOR(OFS_PARM0);

	new = value1[0] * value1[0] + value1[1] * value1[1] + value1[2]*value1[2];
	new = sqrt(new);
	
	if (new == 0)
		newvalue[0] = newvalue[1] = newvalue[2] = 0;
	else
	{
		new = 1/new;
		newvalue[0] = value1[0] * new;
		newvalue[1] = value1[1] * new;
		newvalue[2] = value1[2] * new;
	}
	
	VectorCopy (newvalue, G_VECTOR(OFS_RETURN));	
}

/*
=================
PF_vlen

scalar vlen(vector)
=================
*/
void PF_vlen (void)
{
	float	*value1;
	float	new;
	
	value1 = G_VECTOR(OFS_PARM0);

	new = value1[0] * value1[0] + value1[1] * value1[1] + value1[2]*value1[2];
	new = sqrt(new);
	
	G_FLOAT(OFS_RETURN) = new;
}

/*
=================
PF_vectoyaw

float vectoyaw(vector)
=================
*/
void PF_vectoyaw (void)
{
	float	*value1;
	float	yaw;
	
	value1 = G_VECTOR(OFS_PARM0);

	if (value1[1] == 0 && value1[0] == 0)
		yaw = 0;
	else
	{
		yaw = (int) (atan2(value1[1], value1[0]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;
	}

	G_FLOAT(OFS_RETURN) = yaw;
}


/*
=================
PF_vectoangles

vector vectoangles(vector)
=================
*/
void PF_vectoangles (void)
{
	float	*value1;
	float	forward;
	float	yaw, pitch;
	
	value1 = G_VECTOR(OFS_PARM0);

	if (value1[1] == 0 && value1[0] == 0)
	{
		yaw = 0;
		if (value1[2] > 0)
			pitch = 90;
		else
			pitch = 270;
	}
	else
	{
		yaw = (int) (atan2(value1[1], value1[0]) * 180 / M_PI);
		if (yaw < 0)
			yaw += 360;

		forward = sqrt (value1[0]*value1[0] + value1[1]*value1[1]);
		pitch = (int) (atan2(value1[2], forward) * 180 / M_PI);
		if (pitch < 0)
			pitch += 360;
	}

	G_FLOAT(OFS_RETURN+0) = pitch;
	G_FLOAT(OFS_RETURN+1) = yaw;
	G_FLOAT(OFS_RETURN+2) = 0;
}

/*
=================
PF_Random

Returns a number from 0<= num < 1

random()
=================
*/
void PF_random (void)
{
	float		num;
		
	num = (rand ()&0x7fff) / ((float)0x7fff);
	
	G_FLOAT(OFS_RETURN) = num;
}

/*
=================
PF_particle

particle(origin, color, count)
=================
*/
void PF_particle (void)
{
	float		*org, *dir;
	float		color;
	float		count;
			
	org = G_VECTOR(OFS_PARM0);
	dir = G_VECTOR(OFS_PARM1);
	color = G_FLOAT(OFS_PARM2);
	count = G_FLOAT(OFS_PARM3);
	SV_StartParticle (org, dir, color, count);
}


/*
=================
PF_ambientsound

=================
*/
void PF_ambientsound (void)
{
	char		**check;
	char		*samp;
	float		*pos;
	float 		vol, attenuation;
	int			i, soundnum;

	pos = G_VECTOR (OFS_PARM0);			
	samp = G_STRING(OFS_PARM1);
	vol = G_FLOAT(OFS_PARM2);
	attenuation = G_FLOAT(OFS_PARM3);
	
// check to see if samp was properly precached
	for (soundnum=0, check = sv.sound_precache ; *check ; check++, soundnum++)
		if (!strcmp(*check,samp))
			break;
			
	if (!*check)
	{
		Con_Printf ("no precache: %s\n", samp);
		return;
	}

// add an svc_spawnambient command to the level signon packet

	MSG_WriteByte (&sv.signon,svc_spawnstaticsound);
	for (i=0 ; i<3 ; i++)
		MSG_WriteCoord(&sv.signon, pos[i]);

	MSG_WriteByte (&sv.signon, soundnum);

	MSG_WriteByte (&sv.signon, vol*255);
	MSG_WriteByte (&sv.signon, attenuation*64);

}

/*
=================
PF_sound

Each entity can have eight independant sound sources, like voice,
weapon, feet, etc.

Channel 0 is an auto-allocate channel, the others override anything
allready running on that entity/channel pair.

An attenuation of 0 will play full volume everywhere in the level.
Larger attenuations will drop off.

=================
*/
void PF_sound (void)
{
	char		*sample;
	int			channel;
	edict_t		*entity;
	int 		volume;
	float attenuation;
		
	entity = G_EDICT(OFS_PARM0);
	channel = G_FLOAT(OFS_PARM1);
	sample = G_STRING(OFS_PARM2);
	volume = G_FLOAT(OFS_PARM3) * 255;
	attenuation = G_FLOAT(OFS_PARM4);
	
	if (volume < 0 || volume > 255)
		Sys_Error ("SV_StartSound: volume = %i", volume);

	if (attenuation < 0 || attenuation > 4)
		Sys_Error ("SV_StartSound: attenuation = %f", attenuation);

	if (channel < 0 || channel > 7)
		Sys_Error ("SV_StartSound: channel = %i", channel);

	SV_StartSound (entity, channel, sample, volume, attenuation);
}

/*
=================
PF_break

break()
=================
*/
void PF_break (void)
{
Con_Printf ("break statement\n");
*(int *)-4 = 0;	// dump to debugger
//	PR_RunError ("break statement");
}

/*
=================
PF_traceline

Used for use tracing and shot targeting
Traces are blocked by bbox and exact bsp entityes, and also slide box entities
if the tryents flag is set.

traceline (vector1, vector2, tryents)
=================
*/
void PF_traceline (void)
{
	float	*v1, *v2;
	trace_t	trace;
	int		nomonsters;
	edict_t	*ent;

	v1 = G_VECTOR(OFS_PARM0);
	v2 = G_VECTOR(OFS_PARM1);
	nomonsters = G_FLOAT(OFS_PARM2);
	ent = G_EDICT(OFS_PARM3);

	trace = SV_Move (v1, vec3_origin, vec3_origin, v2, nomonsters, ent);

	pr_global_struct->trace_allsolid = trace.allsolid;
	pr_global_struct->trace_startsolid = trace.startsolid;
	pr_global_struct->trace_fraction = trace.fraction;
	pr_global_struct->trace_inwater = trace.inwater;
	pr_global_struct->trace_inopen = trace.inopen;
	VectorCopy (trace.endpos, pr_global_struct->trace_endpos);
	VectorCopy (trace.plane.normal, pr_global_struct->trace_plane_normal);
	pr_global_struct->trace_plane_dist =  trace.plane.dist;	
	if (trace.ent)
		pr_global_struct->trace_ent = EDICT_TO_PROG(trace.ent);
	else
		pr_global_struct->trace_ent = EDICT_TO_PROG(sv.edicts);
}


#ifdef QUAKE2
extern trace_t SV_Trace_Toss (edict_t *ent, edict_t *ignore);

void PF_TraceToss (void)
{
	trace_t	trace;
	edict_t	*ent;
	edict_t	*ignore;

	ent = G_EDICT(OFS_PARM0);
	ignore = G_EDICT(OFS_PARM1);

	trace = SV_Trace_Toss (ent, ignore);

	pr_global_struct->trace_allsolid = trace.allsolid;
	pr_global_struct->trace_startsolid = trace.startsolid;
	pr_global_struct->trace_fraction = trace.fraction;
	pr_global_struct->trace_inwater = trace.inwater;
	pr_global_struct->trace_inopen = trace.inopen;
	VectorCopy (trace.endpos, pr_global_struct->trace_endpos);
	VectorCopy (trace.plane.normal, pr_global_struct->trace_plane_normal);
	pr_global_struct->trace_plane_dist =  trace.plane.dist;	
	if (trace.ent)
		pr_global_struct->trace_ent = EDICT_TO_PROG(trace.ent);
	else
		pr_global_struct->trace_ent = EDICT_TO_PROG(sv.edicts);
}
#endif


/*
=================
PF_checkpos

Returns true if the given entity can move to the given position from it's
current position by walking or rolling.
FIXME: make work...
scalar checkpos (entity, vector)
=================
*/
void PF_checkpos (void)
{
}

//============================================================================

byte	checkpvs[MAX_MAP_LEAFS/8];

int PF_newcheckclient (int check)
{
	int		i;
	byte	*pvs;
	edict_t	*ent;
	mleaf_t	*leaf;
	vec3_t	org;

// cycle to the next one

	if (check < 1)
		check = 1;
	if (check > svs.maxclients)
		check = svs.maxclients;

	if (check == svs.maxclients)
		i = 1;
	else
		i = check + 1;

	for ( ;  ; i++)
	{
		if (i == svs.maxclients+1)
			i = 1;

		ent = EDICT_NUM(i);

		if (i == check)
			break;	// didn't find anything else

		if (ent->free)
			continue;
		if (ent->v.health <= 0)
			continue;
		if ((int)ent->v.flags & FL_NOTARGET)
			continue;

	// anything that is a client, or has a client as an enemy
		break;
	}

// get the PVS for the entity
	VectorAdd (ent->v.origin, ent->v.view_ofs, org);
	leaf = Mod_PointInLeaf (org, sv.worldmodel);
	pvs = Mod_LeafPVS (leaf, sv.worldmodel);
	memcpy (checkpvs, pvs, (sv.worldmodel->numleafs+7)>>3 );

	return i;
}

/*
=================
PF_checkclient

Returns a client (or object that has a client enemy) that would be a
valid target.

If there are more than one valid options, they are cycled each frame

If (self.origin + self.viewofs) is not in the PVS of the current target,
it is not returned at all.

name checkclient ()
=================
*/
#define	MAX_CHECK	16
int c_invis, c_notvis;
void PF_checkclient (void)
{
	edict_t	*ent, *self;
	mleaf_t	*leaf;
	int		l;
	vec3_t	view;
	
// find a new check if on a new frame
	if (sv.time - sv.lastchecktime >= 0.1)
	{
		sv.lastcheck = PF_newcheckclient (sv.lastcheck);
		sv.lastchecktime = sv.time;
	}

// return check if it might be visible	
	ent = EDICT_NUM(sv.lastcheck);
	if (ent->free || ent->v.health <= 0)
	{
		RETURN_EDICT(sv.edicts);
		return;
	}

// if current entity can't possibly see the check entity, return 0
	self = PROG_TO_EDICT(pr_global_struct->self);
	VectorAdd (self->v.origin, self->v.view_ofs, view);
	leaf = Mod_PointInLeaf (view, sv.worldmodel);
	l = (leaf - sv.worldmodel->leafs) - 1;
	if ( (l<0) || !(checkpvs[l>>3] & (1<<(l&7)) ) )
	{
c_notvis++;
		RETURN_EDICT(sv.edicts);
		return;
	}

// might be able to see it
c_invis++;
	RETURN_EDICT(ent);
}

//============================================================================


/*
=================
PF_stuffcmd

Sends text over to the client's execution buffer

stuffcmd (clientent, value)
=================
*/
void PF_stuffcmd (void)
{
	int		entnum;
	char	*str;
	client_t	*old;
	
	entnum = G_EDICTNUM(OFS_PARM0);
	if (entnum < 1 || entnum > svs.maxclients)
		PR_RunError ("Parm 0 not a client");
	str = G_STRING(OFS_PARM1);	
	
	old = host_client;
	host_client = &svs.clients[entnum-1];
	Host_ClientCommands ("%s", str);
	host_client = old;
}

/*
=================
PF_localcmd

Sends text over to the client's execution buffer

localcmd (string)
=================
*/
void PF_localcmd (void)
{
	char	*str;
	
	str = G_STRING(OFS_PARM0);	
	Cbuf_AddText (str);
}

/*
=================
PF_cvar

float cvar (string)
=================
*/
void PF_cvar (void)
{
	char	*str;
	
	str = G_STRING(OFS_PARM0);
	
	G_FLOAT(OFS_RETURN) = Cvar_VariableValue (str);
}

/*
=================
PF_cvar_set

float cvar (string)
=================
*/
void PF_cvar_set (void)
{
	char	*var, *val;
	
	var = G_STRING(OFS_PARM0);
	val = G_STRING(OFS_PARM1);
	
	Cvar_Set (var, val);
}

/*
=================
PF_findradius

Returns a chain of entities that have origins within a spherical area

findradius (origin, radius)
=================
*/
void PF_findradius (void)
{
	edict_t	*ent, *chain;
	float	rad;
	float	*org;
	vec3_t	eorg;
	int		i, j;

	chain = (edict_t *)sv.edicts;
	
	org = G_VECTOR(OFS_PARM0);
	rad = G_FLOAT(OFS_PARM1);

	ent = NEXT_EDICT(sv.edicts);
	for (i=1 ; i<sv.num_edicts ; i++, ent = NEXT_EDICT(ent))
	{
		if (ent->free)
			continue;
		if (ent->v.solid == SOLID_NOT)
			continue;
		for (j=0 ; j<3 ; j++)
			eorg[j] = org[j] - (ent->v.origin[j] + (ent->v.mins[j] + ent->v.maxs[j])*0.5);			
		if (Length(eorg) > rad)
			continue;
			
		ent->v.chain = EDICT_TO_PROG(chain);
		chain = ent;
	}

	RETURN_EDICT(chain);
}


/*
=========
PF_dprint
=========
*/
void PF_dprint (void)
{
	Con_DPrintf ("%s",PF_VarString(0));
}

char	pr_string_temp[128];

void PF_ftos (void)
{
	float	v;
	v = G_FLOAT(OFS_PARM0);
	
	if (v == (int)v)
		sprintf (pr_string_temp, "%d",(int)v);
	else
		sprintf (pr_string_temp, "%5.1f",v);
	G_INT(OFS_RETURN) = pr_string_temp - pr_strings;
}

void PF_fabs (void)
{
	float	v;
	v = G_FLOAT(OFS_PARM0);
	G_FLOAT(OFS_RETURN) = fabs(v);
}

void PF_vtos (void)
{
	sprintf (pr_string_temp, "'%5.1f %5.1f %5.1f'", G_VECTOR(OFS_PARM0)[0], G_VECTOR(OFS_PARM0)[1], G_VECTOR(OFS_PARM0)[2]);
	G_INT(OFS_RETURN) = pr_string_temp - pr_strings;
}

#ifdef QUAKE2
void PF_etos (void)
{
	sprintf (pr_string_temp, "entity %i", G_EDICTNUM(OFS_PARM0));
	G_INT(OFS_RETURN) = pr_string_temp - pr_strings;
}
#endif

void PF_Spawn (void)
{
	edict_t	*ed;
	ed = ED_Alloc();
	RETURN_EDICT(ed);
}

void PF_Remove (void)
{
	edict_t	*ed;
	
	ed = G_EDICT(OFS_PARM0);
	ED_Free (ed);
}


// entity (entity start, .string field, string match) find = #5;
void PF_Find (void)
#ifdef QUAKE2
{
	int		e;	
	int		f;
	char	*s, *t;
	edict_t	*ed;
	edict_t	*first;
	edict_t	*second;
	edict_t	*last;

	first = second = last = (edict_t *)sv.edicts;
	e = G_EDICTNUM(OFS_PARM0);
	f = G_INT(OFS_PARM1);
	s = G_STRING(OFS_PARM2);
	if (!s)
		PR_RunError ("PF_Find: bad search string");
		
	for (e++ ; e < sv.num_edicts ; e++)
	{
		ed = EDICT_NUM(e);
		if (ed->free)
			continue;
		t = E_STRING(ed,f);
		if (!t)
			continue;
		if (!strcmp(t,s))
		{
			if (first == (edict_t *)sv.edicts)
				first = ed;
			else if (second == (edict_t *)sv.edicts)
				second = ed;
			ed->v.chain = EDICT_TO_PROG(last);
			last = ed;
		}
	}

	if (first != last)
	{
		if (last != second)
			first->v.chain = last->v.chain;
		else
			first->v.chain = EDICT_TO_PROG(last);
		last->v.chain = EDICT_TO_PROG((edict_t *)sv.edicts);
		if (second && second != last)
			second->v.chain = EDICT_TO_PROG(last);
	}
	RETURN_EDICT(first);
}
#else
{
	int		e;	
	int		f;
	char	*s, *t;
	edict_t	*ed;

	e = G_EDICTNUM(OFS_PARM0);
	f = G_INT(OFS_PARM1);
	s = G_STRING(OFS_PARM2);
	if (!s)
		PR_RunError ("PF_Find: bad search string");
		
	for (e++ ; e < sv.num_edicts ; e++)
	{
		ed = EDICT_NUM(e);
		if (ed->free)
			continue;
		t = E_STRING(ed,f);
		if (!t)
			continue;
		if (!strcmp(t,s))
		{
			RETURN_EDICT(ed);
			return;
		}
	}

	RETURN_EDICT(sv.edicts);
}
#endif

void PR_CheckEmptyString (char *s)
{
	if (s[0] <= ' ')
		PR_RunError ("Bad string");
}

void PF_precache_file (void)
{	// precache_file is only used to copy files with qcc, it does nothing
	G_INT(OFS_RETURN) = G_INT(OFS_PARM0);
}

void PF_precache_sound (void)
{
	char	*s;
	int		i;
	
	if (sv.state != ss_loading)
		PR_RunError ("PF_Precache_*: Precache can only be done in spawn functions");
		
	s = G_STRING(OFS_PARM0);
	G_INT(OFS_RETURN) = G_INT(OFS_PARM0);
	PR_CheckEmptyString (s);
	
	for (i=0 ; i<MAX_SOUNDS ; i++)
	{
		if (!sv.sound_precache[i])
		{
			sv.sound_precache[i] = s;
			return;
		}
		if (!strcmp(sv.sound_precache[i], s))
			return;
	}
	PR_RunError ("PF_precache_sound: overflow");
}

void PF_precache_model (void)
{
	char	*s;
	int		i;
	
	if (sv.state != ss_loading)
		PR_RunError ("PF_Precache_*: Precache can only be done in spawn functions");
		
	s = G_STRING(OFS_PARM0);
	G_INT(OFS_RETURN) = G_INT(OFS_PARM0);
	PR_CheckEmptyString (s);

	for (i=0 ; i<MAX_MODELS ; i++)
	{
		if (!sv.model_precache[i])
		{
			sv.model_precache[i] = s;
			sv.models[i] = Mod_ForName (s, true);
			return;
		}
		if (!strcmp(sv.model_precache[i], s))
			return;
	}
	PR_RunError ("PF_precache_model: overflow");
}


void PF_coredump (void)
{
	ED_PrintEdicts ();
}

void PF_traceon (void)
{
	pr_trace = true;
}

void PF_traceoff (void)
{
	pr_trace = false;
}

void PF_eprint (void)
{
	ED_PrintNum (G_EDICTNUM(OFS_PARM0));
}

/*
===============
PF_walkmove

float(float yaw, float dist) walkmove
===============
*/
void PF_walkmove (void)
{
	edict_t	*ent;
	float	yaw, dist;
	vec3_t	move;
	dfunction_t	*oldf;
	int 	oldself;
	
	ent = PROG_TO_EDICT(pr_global_struct->self);
	yaw = G_FLOAT(OFS_PARM0);
	dist = G_FLOAT(OFS_PARM1);
	
	if ( !( (int)ent->v.flags & (FL_ONGROUND|FL_FLY|FL_SWIM) ) )
	{
		G_FLOAT(OFS_RETURN) = 0;
		return;
	}

	yaw = yaw*M_PI*2 / 360;
	
	move[0] = cos(yaw)*dist;
	move[1] = sin(yaw)*dist;
	move[2] = 0;

// save program state, because SV_movestep may call other progs
	oldf = pr_xfunction;
	oldself = pr_global_struct->self;
	
	G_FLOAT(OFS_RETURN) = SV_movestep(ent, move, true);
	
	
// restore program state
	pr_xfunction = oldf;
	pr_global_struct->self = oldself;
}

/*
===============
PF_droptofloor

void() droptofloor
===============
*/
void PF_droptofloor (void)
{
	edict_t		*ent;
	vec3_t		end;
	trace_t		trace;
	
	ent = PROG_TO_EDICT(pr_global_struct->self);

	VectorCopy (ent->v.origin, end);
	end[2] -= 256;
	
	trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, end, false, ent);

	if (trace.fraction == 1 || trace.allsolid)
		G_FLOAT(OFS_RETURN) = 0;
	else
	{
		VectorCopy (trace.endpos, ent->v.origin);
		SV_LinkEdict (ent, false);
		ent->v.flags = (int)ent->v.flags | FL_ONGROUND;
		ent->v.groundentity = EDICT_TO_PROG(trace.ent);
		G_FLOAT(OFS_RETURN) = 1;
	}
}

/*
===============
PF_lightstyle

void(float style, string value) lightstyle
===============
*/
void PF_lightstyle (void)
{
	int		style;
	char	*val;
	client_t	*client;
	int			j;
	
	style = G_FLOAT(OFS_PARM0);
	val = G_STRING(OFS_PARM1);

// change the string in sv
	sv.lightstyles[style] = val;
	
// send message to all clients on this server
	if (sv.state != ss_active)
		return;
	
	for (j=0, client = svs.clients ; j<svs.maxclients ; j++, client++)
		if (client->active || client->spawned)
		{
			MSG_WriteChar (&client->message, svc_lightstyle);
			MSG_WriteChar (&client->message,style);
			MSG_WriteString (&client->message, val);
		}
}

void PF_rint (void)
{
	float	f;
	f = G_FLOAT(OFS_PARM0);
	if (f > 0)
		G_FLOAT(OFS_RETURN) = (int)(f + 0.5);
	else
		G_FLOAT(OFS_RETURN) = (int)(f - 0.5);
}
void PF_floor (void)
{
	G_FLOAT(OFS_RETURN) = floor(G_FLOAT(OFS_PARM0));
}
void PF_ceil (void)
{
	G_FLOAT(OFS_RETURN) = ceil(G_FLOAT(OFS_PARM0));
}


/*
=============
PF_checkbottom
=============
*/
void PF_checkbottom (void)
{
	edict_t	*ent;
	
	ent = G_EDICT(OFS_PARM0);

	G_FLOAT(OFS_RETURN) = SV_CheckBottom (ent);
}

/*
=============
PF_pointcontents
=============
*/
void PF_pointcontents (void)
{
	float	*v;
	
	v = G_VECTOR(OFS_PARM0);

	G_FLOAT(OFS_RETURN) = SV_PointContents (v);	
}

/*
=============
PF_nextent

entity nextent(entity)
=============
*/
void PF_nextent (void)
{
	int		i;
	edict_t	*ent;
	
	i = G_EDICTNUM(OFS_PARM0);
	while (1)
	{
		i++;
		if (i == sv.num_edicts)
		{
			RETURN_EDICT(sv.edicts);
			return;
		}
		ent = EDICT_NUM(i);
		if (!ent->free)
		{
			RETURN_EDICT(ent);
			return;
		}
	}
}

/*
=============
PF_aim

Pick a vector for the player to shoot along
vector aim(entity, missilespeed)
=============
*/
cvar_t	sv_aim = {"sv_aim", "0.93"};
void PF_aim (void)
{
	edict_t	*ent, *check, *bestent;
	vec3_t	start, dir, end, bestdir;
	int		i, j;
	trace_t	tr;
	float	dist, bestdist;
	float	speed;
	
	ent = G_EDICT(OFS_PARM0);
	speed = G_FLOAT(OFS_PARM1);

	VectorCopy (ent->v.origin, start);
	start[2] += 20;

// try sending a trace straight
	VectorCopy (pr_global_struct->v_forward, dir);
	VectorMA (start, 2048, dir, end);
	tr = SV_Move (start, vec3_origin, vec3_origin, end, false, ent);
	if (tr.ent && tr.ent->v.takedamage == DAMAGE_AIM
	&& (!teamplay.value || ent->v.team <=0 || ent->v.team != tr.ent->v.team) )
	{
		VectorCopy (pr_global_struct->v_forward, G_VECTOR(OFS_RETURN));
		return;
	}


// try all possible entities
	VectorCopy (dir, bestdir);
	bestdist = sv_aim.value;
	bestent = NULL;
	
	check = NEXT_EDICT(sv.edicts);
	for (i=1 ; i<sv.num_edicts ; i++, check = NEXT_EDICT(check) )
	{
		if (check->v.takedamage != DAMAGE_AIM)
			continue;
		if (check == ent)
			continue;
		if (teamplay.value && ent->v.team > 0 && ent->v.team == check->v.team)
			continue;	// don't aim at teammate
		for (j=0 ; j<3 ; j++)
			end[j] = check->v.origin[j]
			+ 0.5*(check->v.mins[j] + check->v.maxs[j]);
		VectorSubtract (end, start, dir);
		VectorNormalize (dir);
		dist = DotProduct (dir, pr_global_struct->v_forward);
		if (dist < bestdist)
			continue;	// to far to turn
		tr = SV_Move (start, vec3_origin, vec3_origin, end, false, ent);
		if (tr.ent == check)
		{	// can shoot at this one
			bestdist = dist;
			bestent = check;
		}
	}
	
	if (bestent)
	{
		VectorSubtract (bestent->v.origin, ent->v.origin, dir);
		dist = DotProduct (dir, pr_global_struct->v_forward);
		VectorScale (pr_global_struct->v_forward, dist, end);
		end[2] = dir[2];
		VectorNormalize (end);
		VectorCopy (end, G_VECTOR(OFS_RETURN));	
	}
	else
	{
		VectorCopy (bestdir, G_VECTOR(OFS_RETURN));
	}
}

/*
==============
PF_changeyaw

This was a major timewaster in progs, so it was converted to C
==============
*/
void PF_changeyaw (void)
{
	edict_t		*ent;
	float		ideal, current, move, speed;
	
	ent = PROG_TO_EDICT(pr_global_struct->self);
	current = anglemod( ent->v.angles[1] );
	ideal = ent->v.ideal_yaw;
	speed = ent->v.yaw_speed;
	
	if (current == ideal)
		return;
	move = ideal - current;
	if (ideal > current)
	{
		if (move >= 180)
			move = move - 360;
	}
	else
	{
		if (move <= -180)
			move = move + 360;
	}
	if (move > 0)
	{
		if (move > speed)
			move = speed;
	}
	else
	{
		if (move < -speed)
			move = -speed;
	}
	
	ent->v.angles[1] = anglemod (current + move);
}

#ifdef QUAKE2
/*
==============
PF_changepitch
==============
*/
void PF_changepitch (void)
{
	edict_t		*ent;
	float		ideal, current, move, speed;
	
	ent = G_EDICT(OFS_PARM0);
	current = anglemod( ent->v.angles[0] );
	ideal = ent->v.idealpitch;
	speed = ent->v.pitch_speed;
	
	if (current == ideal)
		return;
	move = ideal - current;
	if (ideal > current)
	{
		if (move >= 180)
			move = move - 360;
	}
	else
	{
		if (move <= -180)
			move = move + 360;
	}
	if (move > 0)
	{
		if (move > speed)
			move = speed;
	}
	else
	{
		if (move < -speed)
			move = -speed;
	}
	
	ent->v.angles[0] = anglemod (current + move);
}
#endif

/*
===============================================================================

MESSAGE WRITING

===============================================================================
*/

#define	MSG_BROADCAST	0		// unreliable to all
#define	MSG_ONE			1		// reliable to one (msg_entity)
#define	MSG_ALL			2		// reliable to all
#define	MSG_INIT		3		// write to the init string

sizebuf_t *WriteDest (void)
{
	int		entnum;
	int		dest;
	edict_t	*ent;

	dest = G_FLOAT(OFS_PARM0);
	switch (dest)
	{
	case MSG_BROADCAST:
		return &sv.datagram;
	
	case MSG_ONE:
		ent = PROG_TO_EDICT(pr_global_struct->msg_entity);
		entnum = NUM_FOR_EDICT(ent);
		if (entnum < 1 || entnum > svs.maxclients)
			PR_RunError ("WriteDest: not a client");
		return &svs.clients[entnum-1].message;
		
	case MSG_ALL:
		return &sv.reliable_datagram;
	
	case MSG_INIT:
		return &sv.signon;

	default:
		PR_RunError ("WriteDest: bad destination");
		break;
	}
	
	return NULL;
}

void PF_WriteByte (void)
{
	MSG_WriteByte (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteChar (void)
{
	MSG_WriteChar (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteShort (void)
{
	MSG_WriteShort (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteLong (void)
{
	MSG_WriteLong (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteAngle (void)
{
	MSG_WriteAngle (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteCoord (void)
{
	MSG_WriteCoord (WriteDest(), G_FLOAT(OFS_PARM1));
}

void PF_WriteString (void)
{
	MSG_WriteString (WriteDest(), G_STRING(OFS_PARM1));
}


void PF_WriteEntity (void)
{
	MSG_WriteShort (WriteDest(), G_EDICTNUM(OFS_PARM1));
}

//=============================================================================

int SV_ModelIndex (char *name);

void PF_makestatic (void)
{
	edict_t	*ent;
	int		i;
	
	ent = G_EDICT(OFS_PARM0);

	MSG_WriteByte (&sv.signon,svc_spawnstatic);

	MSG_WriteByte (&sv.signon, SV_ModelIndex(pr_strings + ent->v.model));

	MSG_WriteByte (&sv.signon, ent->v.frame);
	MSG_WriteByte (&sv.signon, ent->v.colormap);
	MSG_WriteByte (&sv.signon, ent->v.skin);
	for (i=0 ; i<3 ; i++)
	{
		MSG_WriteCoord(&sv.signon, ent->v.origin[i]);
		MSG_WriteAngle(&sv.signon, ent->v.angles[i]);
	}

// throw the entity away now
	ED_Free (ent);
}

//=============================================================================

/*
==============
PF_setspawnparms
==============
*/
void PF_setspawnparms (void)
{
	edict_t	*ent;
	int		i;
	client_t	*client;

	ent = G_EDICT(OFS_PARM0);
	i = NUM_FOR_EDICT(ent);
	if (i < 1 || i > svs.maxclients)
		PR_RunError ("Entity is not a client");

	// copy spawn parms out of the client_t
	client = svs.clients + (i-1);

	for (i=0 ; i< NUM_SPAWN_PARMS ; i++)
		(&pr_global_struct->parm1)[i] = client->spawn_parms[i];
}

/*
==============
PF_changelevel
==============
*/
void PF_changelevel (void)
{
#ifdef QUAKE2
	char	*s1, *s2;

	if (svs.changelevel_issued)
		return;
	svs.changelevel_issued = true;

	s1 = G_STRING(OFS_PARM0);
	s2 = G_STRING(OFS_PARM1);

	if ((int)pr_global_struct->serverflags & (SFL_NEW_UNIT | SFL_NEW_EPISODE))
		Cbuf_AddText (va("changelevel %s %s\n",s1, s2));
	else
		Cbuf_AddText (va("changelevel2 %s %s\n",s1, s2));
#else
	char	*s;

// make sure we don't issue two changelevels
	if (svs.changelevel_issued)
		return;
	svs.changelevel_issued = true;
	
	s = G_STRING(OFS_PARM0);
	Cbuf_AddText (va("changelevel %s\n",s));
#endif
}


#ifdef QUAKE2

#define	CONTENT_WATER	-3
#define CONTENT_SLIME	-4
#define CONTENT_LAVA	-5

#define FL_IMMUNE_WATER	131072
#define	FL_IMMUNE_SLIME	262144
#define FL_IMMUNE_LAVA	524288

#define	CHAN_VOICE	2
#define	CHAN_BODY	4

#define	ATTN_NORM	1

void PF_WaterMove (void)
{
	edict_t		*self;
	int			flags;
	int			waterlevel;
	int			watertype;
	float		drownlevel;
	float		damage = 0.0;

	self = PROG_TO_EDICT(pr_global_struct->self);

	if (self->v.movetype == MOVETYPE_NOCLIP)
	{
		self->v.air_finished = sv.time + 12;
		G_FLOAT(OFS_RETURN) = damage;
		return;
	}

	if (self->v.health < 0)
	{
		G_FLOAT(OFS_RETURN) = damage;
		return;
	}

	if (self->v.deadflag == DEAD_NO)
		drownlevel = 3;
	else
		drownlevel = 1;

	flags = (int)self->v.flags;
	waterlevel = (int)self->v.waterlevel;
	watertype = (int)self->v.watertype;

	if (!(flags & (FL_IMMUNE_WATER + FL_GODMODE)))
		if (((flags & FL_SWIM) && (waterlevel < drownlevel)) || (waterlevel >= drownlevel))
		{
			if (self->v.air_finished < sv.time)
				if (self->v.pain_finished < sv.time)
				{
					self->v.dmg = self->v.dmg + 2;
					if (self->v.dmg > 15)
						self->v.dmg = 10;
//					T_Damage (self, world, world, self.dmg, 0, FALSE);
					damage = self->v.dmg;
					self->v.pain_finished = sv.time + 1.0;
				}
		}
		else
		{
			if (self->v.air_finished < sv.time)
//				sound (self, CHAN_VOICE, "player/gasp2.wav", 1, ATTN_NORM);
				SV_StartSound (self, CHAN_VOICE, "player/gasp2.wav", 255, ATTN_NORM);
			else if (self->v.air_finished < sv.time + 9)
//				sound (self, CHAN_VOICE, "player/gasp1.wav", 1, ATTN_NORM);
				SV_StartSound (self, CHAN_VOICE, "player/gasp1.wav", 255, ATTN_NORM);
			self->v.air_finished = sv.time + 12.0;
			self->v.dmg = 2;
		}
	
	if (!waterlevel)
	{
		if (flags & FL_INWATER)
		{	
			// play leave water sound
//			sound (self, CHAN_BODY, "misc/outwater.wav", 1, ATTN_NORM);
			SV_StartSound (self, CHAN_BODY, "misc/outwater.wav", 255, ATTN_NORM);
			self->v.flags = (float)(flags &~FL_INWATER);
		}
		self->v.air_finished = sv.time + 12.0;
		G_FLOAT(OFS_RETURN) = damage;
		return;
	}

	if (watertype == CONTENT_LAVA)
	{	// do damage
		if (!(flags & (FL_IMMUNE_LAVA + FL_GODMODE)))
			if (self->v.dmgtime < sv.time)
			{
				if (self->v.radsuit_finished < sv.time)
					self->v.dmgtime = sv.time + 0.2;
				else
					self->v.dmgtime = sv.time + 1.0;
//				T_Damage (self, world, world, 10*self.waterlevel, 0, TRUE);
				damage = (float)(10*waterlevel);
			}
	}
	else if (watertype == CONTENT_SLIME)
	{	// do damage
		if (!(flags & (FL_IMMUNE_SLIME + FL_GODMODE)))
			if (self->v.dmgtime < sv.time && self->v.radsuit_finished < sv.time)
			{
				self->v.dmgtime = sv.time + 1.0;
//				T_Damage (self, world, world, 4*self.waterlevel, 0, TRUE);
				damage = (float)(4*waterlevel);
			}
	}
	
	if ( !(flags & FL_INWATER) )
	{	

// player enter water sound
		if (watertype == CONTENT_LAVA)
//			sound (self, CHAN_BODY, "player/inlava.wav", 1, ATTN_NORM);
			SV_StartSound (self, CHAN_BODY, "player/inlava.wav", 255, ATTN_NORM);
		if (watertype == CONTENT_WATER)
//			sound (self, CHAN_BODY, "player/inh2o.wav", 1, ATTN_NORM);
			SV_StartSound (self, CHAN_BODY, "player/inh2o.wav", 255, ATTN_NORM);
		if (watertype == CONTENT_SLIME)
//			sound (self, CHAN_BODY, "player/slimbrn2.wav", 1, ATTN_NORM);
			SV_StartSound (self, CHAN_BODY, "player/slimbrn2.wav", 255, ATTN_NORM);

		self->v.flags = (float)(flags | FL_INWATER);
		self->v.dmgtime = 0;
	}
	
	if (! (flags & FL_WATERJUMP) )
	{
//		self.velocity = self.velocity - 0.8*self.waterlevel*frametime*self.velocity;
		VectorMA (self->v.velocity, -0.8 * self->v.waterlevel * host_frametime, self->v.velocity, self->v.velocity);
	}

	G_FLOAT(OFS_RETURN) = damage;
}


void PF_sin (void)
{
	G_FLOAT(OFS_RETURN) = sin(G_FLOAT(OFS_PARM0));
}

void PF_cos (void)
{
	G_FLOAT(OFS_RETURN) = cos(G_FLOAT(OFS_PARM0));
}

void PF_sqrt (void)
{
	G_FLOAT(OFS_RETURN) = sqrt(G_FLOAT(OFS_PARM0));
}
#endif

void PF_Fixme (void)
{
	PR_RunError ("unimplemented bulitin");
}



builtin_t pr_builtin[] =
{
PF_Fixme,
PF_makevectors,	// void(entity e)	makevectors 		= #1;
PF_setorigin,	// void(entity e, vector o) setorigin	= #2;
PF_setmodel,	// void(entity e, string m) setmodel	= #3;
PF_setsize,	// void(entity e, vector min, vector max) setsize = #4;
PF_Fixme,	// void(entity e, vector min, vector max) setabssize = #5;
PF_break,	// void() break						= #6;
PF_random,	// float() random						= #7;
PF_sound,	// void(entity e, float chan, string samp) sound = #8;
PF_normalize,	// vector(vector v) normalize			= #9;
PF_error,	// void(string e) error				= #10;
PF_objerror,	// void(string e) objerror				= #11;
PF_vlen,	// float(vector v) vlen				= #12;
PF_vectoyaw,	// float(vector v) vectoyaw		= #13;
PF_Spawn,	// entity() spawn						= #14;
PF_Remove,	// void(entity e) remove				= #15;
PF_traceline,	// float(vector v1, vector v2, float tryents) traceline = #16;
PF_checkclient,	// entity() clientlist					= #17;
PF_Find,	// entity(entity start, .string fld, string match) find = #18;
PF_precache_sound,	// void(string s) precache_sound		= #19;
PF_precache_model,	// void(string s) precache_model		= #20;
PF_stuffcmd,	// void(entity client, string s)stuffcmd = #21;
PF_findradius,	// entity(vector org, float rad) findradius = #22;
PF_bprint,	// void(string s) bprint				= #23;
PF_sprint,	// void(entity client, string s) sprint = #24;
PF_dprint,	// void(string s) dprint				= #25;
PF_ftos,	// void(string s) ftos				= #26;
PF_vtos,	// void(string s) vtos				= #27;
PF_coredump,
PF_traceon,
PF_traceoff,
PF_eprint,	// void(entity e) debug print an entire entity
PF_walkmove, // float(float yaw, float dist) walkmove
PF_Fixme, // float(float yaw, float dist) walkmove
PF_droptofloor,
PF_lightstyle,
PF_rint,
PF_floor,
PF_ceil,
PF_Fixme,
PF_checkbottom,
PF_pointcontents,
PF_Fixme,
PF_fabs,
PF_aim,
PF_cvar,
PF_localcmd,
PF_nextent,
PF_particle,
PF_changeyaw,
PF_Fixme,
PF_vectoangles,

PF_WriteByte,
PF_WriteChar,
PF_WriteShort,
PF_WriteLong,
PF_WriteCoord,
PF_WriteAngle,
PF_WriteString,
PF_WriteEntity,

#ifdef QUAKE2
PF_sin,
PF_cos,
PF_sqrt,
PF_changepitch,
PF_TraceToss,
PF_etos,
PF_WaterMove,
#else
PF_Fixme,
PF_Fixme,
PF_Fixme,
PF_Fixme,
PF_Fixme,
PF_Fixme,
PF_Fixme,
#endif

SV_MoveToGoal,
PF_precache_file,
PF_makestatic,

PF_changelevel,
PF_Fixme,

PF_cvar_set,
PF_centerprint,

PF_ambientsound,

PF_precache_model,
PF_precache_sound,		// precache_sound2 is different only for qcc
PF_precache_file,

PF_setspawnparms
};

builtin_t *pr_builtins = pr_builtin;
int pr_numbuiltins = sizeof(pr_builtin)/sizeof(pr_builtin[0]);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\protocol.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// protocol.h -- communications protocols

#define	PROTOCOL_VERSION	15

// if the high bit of the servercmd is set, the low bits are fast update flags:
#define	U_MOREBITS	(1<<0)
#define	U_ORIGIN1	(1<<1)
#define	U_ORIGIN2	(1<<2)
#define	U_ORIGIN3	(1<<3)
#define	U_ANGLE2	(1<<4)
#define	U_NOLERP	(1<<5)		// don't interpolate movement
#define	U_FRAME		(1<<6)
#define U_SIGNAL	(1<<7)		// just differentiates from other updates

// svc_update can pass all of the fast update bits, plus more
#define	U_ANGLE1	(1<<8)
#define	U_ANGLE3	(1<<9)
#define	U_MODEL		(1<<10)
#define	U_COLORMAP	(1<<11)
#define	U_SKIN		(1<<12)
#define	U_EFFECTS	(1<<13)
#define	U_LONGENTITY	(1<<14)


#define	SU_VIEWHEIGHT	(1<<0)
#define	SU_IDEALPITCH	(1<<1)
#define	SU_PUNCH1		(1<<2)
#define	SU_PUNCH2		(1<<3)
#define	SU_PUNCH3		(1<<4)
#define	SU_VELOCITY1	(1<<5)
#define	SU_VELOCITY2	(1<<6)
#define	SU_VELOCITY3	(1<<7)
//define	SU_AIMENT		(1<<8)  AVAILABLE BIT
#define	SU_ITEMS		(1<<9)
#define	SU_ONGROUND		(1<<10)		// no data follows, the bit is it
#define	SU_INWATER		(1<<11)		// no data follows, the bit is it
#define	SU_WEAPONFRAME	(1<<12)
#define	SU_ARMOR		(1<<13)
#define	SU_WEAPON		(1<<14)

// a sound with no channel is a local only sound
#define	SND_VOLUME		(1<<0)		// a byte
#define	SND_ATTENUATION	(1<<1)		// a byte
#define	SND_LOOPING		(1<<2)		// a long


// defaults for clientinfo messages
#define	DEFAULT_VIEWHEIGHT	22


// game types sent by serverinfo
// these determine which intermission screen plays
#define	GAME_COOP			0
#define	GAME_DEATHMATCH		1

//==================
// note that there are some defs.qc that mirror to these numbers
// also related to svc_strings[] in cl_parse
//==================

//
// server to client
//
#define	svc_bad				0
#define	svc_nop				1
#define	svc_disconnect		2
#define	svc_updatestat		3	// [byte] [long]
#define	svc_version			4	// [long] server version
#define	svc_setview			5	// [short] entity number
#define	svc_sound			6	// <see code>
#define	svc_time			7	// [float] server time
#define	svc_print			8	// [string] null terminated string
#define	svc_stufftext		9	// [string] stuffed into client's console buffer
								// the string should be \n terminated
#define	svc_setangle		10	// [angle3] set the view angle to this absolute value
	
#define	svc_serverinfo		11	// [long] version
						// [string] signon string
						// [string]..[0]model cache
						// [string]...[0]sounds cache
#define	svc_lightstyle		12	// [byte] [string]
#define	svc_updatename		13	// [byte] [string]
#define	svc_updatefrags		14	// [byte] [short]
#define	svc_clientdata		15	// <shortbits + data>
#define	svc_stopsound		16	// <see code>
#define	svc_updatecolors	17	// [byte] [byte]
#define	svc_particle		18	// [vec3] <variable>
#define	svc_damage			19
	
#define	svc_spawnstatic		20
//	svc_spawnbinary		21
#define	svc_spawnbaseline	22
	
#define	svc_temp_entity		23

#define	svc_setpause		24	// [byte] on / off
#define	svc_signonnum		25	// [byte]  used for the signon sequence

#define	svc_centerprint		26	// [string] to put in center of the screen

#define	svc_killedmonster	27
#define	svc_foundsecret		28

#define	svc_spawnstaticsound	29	// [coord3] [byte] samp [byte] vol [byte] aten

#define	svc_intermission	30		// [string] music
#define	svc_finale			31		// [string] music [string] text

#define	svc_cdtrack			32		// [byte] track [byte] looptrack
#define svc_sellscreen		33

#define svc_cutscene		34

//
// client to server
//
#define	clc_bad			0
#define	clc_nop 		1
#define	clc_disconnect	2
#define	clc_move		3			// [usercmd_t]
#define	clc_stringcmd	4		// [string] message


//
// temp entity events
//
#define	TE_SPIKE			0
#define	TE_SUPERSPIKE		1
#define	TE_GUNSHOT			2
#define	TE_EXPLOSION		3
#define	TE_TAREXPLOSION		4
#define	TE_LIGHTNING1		5
#define	TE_LIGHTNING2		6
#define	TE_WIZSPIKE			7
#define	TE_KNIGHTSPIKE		8
#define	TE_LIGHTNING3		9
#define	TE_LAVASPLASH		10
#define	TE_TELEPORT			11
#define TE_EXPLOSION2		12

// PGM 01/21/97 
#define TE_BEAM				13
// PGM 01/21/97 

#ifdef QUAKE2
#define TE_IMPLOSION		14
#define TE_RAILTRAIL		15
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\progs.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "pr_comp.h"			// defs shared with qcc
#include "progdefs.h"			// generated by program cdefs

typedef union eval_s
{
	string_t		string;
	float			_float;
	float			vector[3];
	func_t			function;
	int				_int;
	int				edict;
} eval_t;	

#define	MAX_ENT_LEAFS	16
typedef struct edict_s
{
	qboolean	free;
	link_t		area;				// linked to a division node or leaf
	
	int			num_leafs;
	short		leafnums[MAX_ENT_LEAFS];

	entity_state_t	baseline;
	
	float		freetime;			// sv.time when the object was freed
	entvars_t	v;					// C exported fields from progs
// other fields from progs come immediately after
} edict_t;
#define	EDICT_FROM_AREA(l) STRUCT_FROM_LINK(l,edict_t,area)

//============================================================================

extern	dprograms_t		*progs;
extern	dfunction_t		*pr_functions;
extern	char			*pr_strings;
extern	ddef_t			*pr_globaldefs;
extern	ddef_t			*pr_fielddefs;
extern	dstatement_t	*pr_statements;
extern	globalvars_t	*pr_global_struct;
extern	float			*pr_globals;			// same as pr_global_struct

extern	int				pr_edict_size;	// in bytes

//============================================================================

void PR_Init (void);

void PR_ExecuteProgram (func_t fnum);
void PR_LoadProgs (void);

void PR_Profile_f (void);

edict_t *ED_Alloc (void);
void ED_Free (edict_t *ed);

char	*ED_NewString (char *string);
// returns a copy of the string allocated from the server's string heap

void ED_Print (edict_t *ed);
void ED_Write (FILE *f, edict_t *ed);
char *ED_ParseEdict (char *data, edict_t *ent);

void ED_WriteGlobals (FILE *f);
void ED_ParseGlobals (char *data);

void ED_LoadFromFile (char *data);

//define EDICT_NUM(n) ((edict_t *)(sv.edicts+ (n)*pr_edict_size))
//define NUM_FOR_EDICT(e) (((byte *)(e) - sv.edicts)/pr_edict_size)

edict_t *EDICT_NUM(int n);
int NUM_FOR_EDICT(edict_t *e);

#define	NEXT_EDICT(e) ((edict_t *)( (byte *)e + pr_edict_size))

#define	EDICT_TO_PROG(e) ((byte *)e - (byte *)sv.edicts)
#define PROG_TO_EDICT(e) ((edict_t *)((byte *)sv.edicts + e))

//============================================================================

#define	G_FLOAT(o) (pr_globals[o])
#define	G_INT(o) (*(int *)&pr_globals[o])
#define	G_EDICT(o) ((edict_t *)((byte *)sv.edicts+ *(int *)&pr_globals[o]))
#define G_EDICTNUM(o) NUM_FOR_EDICT(G_EDICT(o))
#define	G_VECTOR(o) (&pr_globals[o])
#define	G_STRING(o) (pr_strings + *(string_t *)&pr_globals[o])
#define	G_FUNCTION(o) (*(func_t *)&pr_globals[o])

#define	E_FLOAT(e,o) (((float*)&e->v)[o])
#define	E_INT(e,o) (*(int *)&((float*)&e->v)[o])
#define	E_VECTOR(e,o) (&((float*)&e->v)[o])
#define	E_STRING(e,o) (pr_strings + *(string_t *)&((float*)&e->v)[o])

extern	int		type_size[8];

typedef void (*builtin_t) (void);
extern	builtin_t *pr_builtins;
extern int pr_numbuiltins;

extern int		pr_argc;

extern	qboolean	pr_trace;
extern	dfunction_t	*pr_xfunction;
extern	int			pr_xstatement;

extern	unsigned short		pr_crc;

void PR_RunError (char *error, ...);

void ED_PrintEdicts (void);
void ED_PrintNum (int ent);

eval_t *GetEdictFieldValue(edict_t *ed, char *field);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\pr_edict.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sv_edict.c -- entity dictionary

#include "quakedef.h"

dprograms_t		*progs;
dfunction_t		*pr_functions;
char			*pr_strings;
ddef_t			*pr_fielddefs;
ddef_t			*pr_globaldefs;
dstatement_t	*pr_statements;
globalvars_t	*pr_global_struct;
float			*pr_globals;			// same as pr_global_struct
int				pr_edict_size;	// in bytes

unsigned short		pr_crc;

int		type_size[8] = {1,sizeof(string_t)/4,1,3,1,1,sizeof(func_t)/4,sizeof(void *)/4};

ddef_t *ED_FieldAtOfs (int ofs);
qboolean	ED_ParseEpair (void *base, ddef_t *key, char *s);

cvar_t	nomonsters = {"nomonsters", "0"};
cvar_t	gamecfg = {"gamecfg", "0"};
cvar_t	scratch1 = {"scratch1", "0"};
cvar_t	scratch2 = {"scratch2", "0"};
cvar_t	scratch3 = {"scratch3", "0"};
cvar_t	scratch4 = {"scratch4", "0"};
cvar_t	savedgamecfg = {"savedgamecfg", "0", true};
cvar_t	saved1 = {"saved1", "0", true};
cvar_t	saved2 = {"saved2", "0", true};
cvar_t	saved3 = {"saved3", "0", true};
cvar_t	saved4 = {"saved4", "0", true};

#define	MAX_FIELD_LEN	64
#define GEFV_CACHESIZE	2

typedef struct {
	ddef_t	*pcache;
	char	field[MAX_FIELD_LEN];
} gefv_cache;

static gefv_cache	gefvCache[GEFV_CACHESIZE] = {{NULL, ""}, {NULL, ""}};

/*
=================
ED_ClearEdict

Sets everything to NULL
=================
*/
void ED_ClearEdict (edict_t *e)
{
	memset (&e->v, 0, progs->entityfields * 4);
	e->free = false;
}

/*
=================
ED_Alloc

Either finds a free edict, or allocates a new one.
Try to avoid reusing an entity that was recently freed, because it
can cause the client to think the entity morphed into something else
instead of being removed and recreated, which can cause interpolated
angles and bad trails.
=================
*/
edict_t *ED_Alloc (void)
{
	int			i;
	edict_t		*e;

	for ( i=svs.maxclients+1 ; i<sv.num_edicts ; i++)
	{
		e = EDICT_NUM(i);
		// the first couple seconds of server time can involve a lot of
		// freeing and allocating, so relax the replacement policy
		if (e->free && ( e->freetime < 2 || sv.time - e->freetime > 0.5 ) )
		{
			ED_ClearEdict (e);
			return e;
		}
	}
	
	if (i == MAX_EDICTS)
		Sys_Error ("ED_Alloc: no free edicts");
		
	sv.num_edicts++;
	e = EDICT_NUM(i);
	ED_ClearEdict (e);

	return e;
}

/*
=================
ED_Free

Marks the edict as free
FIXME: walk all entities and NULL out references to this entity
=================
*/
void ED_Free (edict_t *ed)
{
	SV_UnlinkEdict (ed);		// unlink from world bsp

	ed->free = true;
	ed->v.model = 0;
	ed->v.takedamage = 0;
	ed->v.modelindex = 0;
	ed->v.colormap = 0;
	ed->v.skin = 0;
	ed->v.frame = 0;
	VectorCopy (vec3_origin, ed->v.origin);
	VectorCopy (vec3_origin, ed->v.angles);
	ed->v.nextthink = -1;
	ed->v.solid = 0;
	
	ed->freetime = sv.time;
}

//===========================================================================

/*
============
ED_GlobalAtOfs
============
*/
ddef_t *ED_GlobalAtOfs (int ofs)
{
	ddef_t		*def;
	int			i;
	
	for (i=0 ; i<progs->numglobaldefs ; i++)
	{
		def = &pr_globaldefs[i];
		if (def->ofs == ofs)
			return def;
	}
	return NULL;
}

/*
============
ED_FieldAtOfs
============
*/
ddef_t *ED_FieldAtOfs (int ofs)
{
	ddef_t		*def;
	int			i;
	
	for (i=0 ; i<progs->numfielddefs ; i++)
	{
		def = &pr_fielddefs[i];
		if (def->ofs == ofs)
			return def;
	}
	return NULL;
}

/*
============
ED_FindField
============
*/
ddef_t *ED_FindField (char *name)
{
	ddef_t		*def;
	int			i;
	
	for (i=0 ; i<progs->numfielddefs ; i++)
	{
		def = &pr_fielddefs[i];
		if (!strcmp(pr_strings + def->s_name,name) )
			return def;
	}
	return NULL;
}


/*
============
ED_FindGlobal
============
*/
ddef_t *ED_FindGlobal (char *name)
{
	ddef_t		*def;
	int			i;
	
	for (i=0 ; i<progs->numglobaldefs ; i++)
	{
		def = &pr_globaldefs[i];
		if (!strcmp(pr_strings + def->s_name,name) )
			return def;
	}
	return NULL;
}


/*
============
ED_FindFunction
============
*/
dfunction_t *ED_FindFunction (char *name)
{
	dfunction_t		*func;
	int				i;
	
	for (i=0 ; i<progs->numfunctions ; i++)
	{
		func = &pr_functions[i];
		if (!strcmp(pr_strings + func->s_name,name) )
			return func;
	}
	return NULL;
}


eval_t *GetEdictFieldValue(edict_t *ed, char *field)
{
	ddef_t			*def = NULL;
	int				i;
	static int		rep = 0;

	for (i=0 ; i<GEFV_CACHESIZE ; i++)
	{
		if (!strcmp(field, gefvCache[i].field))
		{
			def = gefvCache[i].pcache;
			goto Done;
		}
	}

	def = ED_FindField (field);

	if (strlen(field) < MAX_FIELD_LEN)
	{
		gefvCache[rep].pcache = def;
		strcpy (gefvCache[rep].field, field);
		rep ^= 1;
	}

Done:
	if (!def)
		return NULL;

	return (eval_t *)((char *)&ed->v + def->ofs*4);
}


/*
============
PR_ValueString

Returns a string describing *data in a type specific manner
=============
*/
char *PR_ValueString (etype_t type, eval_t *val)
{
	static char	line[256];
	ddef_t		*def;
	dfunction_t	*f;
	
	type &= ~DEF_SAVEGLOBAL;

	switch (type)
	{
	case ev_string:
		sprintf (line, "%s", pr_strings + val->string);
		break;
	case ev_entity:	
		sprintf (line, "entity %i", NUM_FOR_EDICT(PROG_TO_EDICT(val->edict)) );
		break;
	case ev_function:
		f = pr_functions + val->function;
		sprintf (line, "%s()", pr_strings + f->s_name);
		break;
	case ev_field:
		def = ED_FieldAtOfs ( val->_int );
		sprintf (line, ".%s", pr_strings + def->s_name);
		break;
	case ev_void:
		sprintf (line, "void");
		break;
	case ev_float:
		sprintf (line, "%5.1f", val->_float);
		break;
	case ev_vector:
		sprintf (line, "'%5.1f %5.1f %5.1f'", val->vector[0], val->vector[1], val->vector[2]);
		break;
	case ev_pointer:
		sprintf (line, "pointer");
		break;
	default:
		sprintf (line, "bad type %i", type);
		break;
	}
	
	return line;
}

/*
============
PR_UglyValueString

Returns a string describing *data in a type specific manner
Easier to parse than PR_ValueString
=============
*/
char *PR_UglyValueString (etype_t type, eval_t *val)
{
	static char	line[256];
	ddef_t		*def;
	dfunction_t	*f;
	
	type &= ~DEF_SAVEGLOBAL;

	switch (type)
	{
	case ev_string:
		sprintf (line, "%s", pr_strings + val->string);
		break;
	case ev_entity:	
		sprintf (line, "%i", NUM_FOR_EDICT(PROG_TO_EDICT(val->edict)));
		break;
	case ev_function:
		f = pr_functions + val->function;
		sprintf (line, "%s", pr_strings + f->s_name);
		break;
	case ev_field:
		def = ED_FieldAtOfs ( val->_int );
		sprintf (line, "%s", pr_strings + def->s_name);
		break;
	case ev_void:
		sprintf (line, "void");
		break;
	case ev_float:
		sprintf (line, "%f", val->_float);
		break;
	case ev_vector:
		sprintf (line, "%f %f %f", val->vector[0], val->vector[1], val->vector[2]);
		break;
	default:
		sprintf (line, "bad type %i", type);
		break;
	}
	
	return line;
}

/*
============
PR_GlobalString

Returns a string with a description and the contents of a global,
padded to 20 field width
============
*/
char *PR_GlobalString (int ofs)
{
	char	*s;
	int		i;
	ddef_t	*def;
	void	*val;
	static char	line[128];
	
	val = (void *)&pr_globals[ofs];
	def = ED_GlobalAtOfs(ofs);
	if (!def)
		sprintf (line,"%i(???)", ofs);
	else
	{
		s = PR_ValueString (def->type, val);
		sprintf (line,"%i(%s)%s", ofs, pr_strings + def->s_name, s);
	}
	
	i = strlen(line);
	for ( ; i<20 ; i++)
		strcat (line," ");
	strcat (line," ");
		
	return line;
}

char *PR_GlobalStringNoContents (int ofs)
{
	int		i;
	ddef_t	*def;
	static char	line[128];
	
	def = ED_GlobalAtOfs(ofs);
	if (!def)
		sprintf (line,"%i(???)", ofs);
	else
		sprintf (line,"%i(%s)", ofs, pr_strings + def->s_name);
	
	i = strlen(line);
	for ( ; i<20 ; i++)
		strcat (line," ");
	strcat (line," ");
		
	return line;
}


/*
=============
ED_Print

For debugging
=============
*/
void ED_Print (edict_t *ed)
{
	int		l;
	ddef_t	*d;
	int		*v;
	int		i, j;
	char	*name;
	int		type;

	if (ed->free)
	{
		Con_Printf ("FREE\n");
		return;
	}

	Con_Printf("\nEDICT %i:\n", NUM_FOR_EDICT(ed));
	for (i=1 ; i<progs->numfielddefs ; i++)
	{
		d = &pr_fielddefs[i];
		name = pr_strings + d->s_name;
		if (name[strlen(name)-2] == '_')
			continue;	// skip _x, _y, _z vars
			
		v = (int *)((char *)&ed->v + d->ofs*4);

	// if the value is still all 0, skip the field
		type = d->type & ~DEF_SAVEGLOBAL;
		
		for (j=0 ; j<type_size[type] ; j++)
			if (v[j])
				break;
		if (j == type_size[type])
			continue;
	
		Con_Printf ("%s",name);
		l = strlen (name);
		while (l++ < 15)
			Con_Printf (" ");

		Con_Printf ("%s\n", PR_ValueString(d->type, (eval_t *)v));		
	}
}

/*
=============
ED_Write

For savegames
=============
*/
void ED_Write (FILE *f, edict_t *ed)
{
	ddef_t	*d;
	int		*v;
	int		i, j;
	char	*name;
	int		type;

	fprintf (f, "{\n");

	if (ed->free)
	{
		fprintf (f, "}\n");
		return;
	}
	
	for (i=1 ; i<progs->numfielddefs ; i++)
	{
		d = &pr_fielddefs[i];
		name = pr_strings + d->s_name;
		if (name[strlen(name)-2] == '_')
			continue;	// skip _x, _y, _z vars
			
		v = (int *)((char *)&ed->v + d->ofs*4);

	// if the value is still all 0, skip the field
		type = d->type & ~DEF_SAVEGLOBAL;
		for (j=0 ; j<type_size[type] ; j++)
			if (v[j])
				break;
		if (j == type_size[type])
			continue;
	
		fprintf (f,"\"%s\" ",name);
		fprintf (f,"\"%s\"\n", PR_UglyValueString(d->type, (eval_t *)v));		
	}

	fprintf (f, "}\n");
}

void ED_PrintNum (int ent)
{
	ED_Print (EDICT_NUM(ent));
}

/*
=============
ED_PrintEdicts

For debugging, prints all the entities in the current server
=============
*/
void ED_PrintEdicts (void)
{
	int		i;
	
	Con_Printf ("%i entities\n", sv.num_edicts);
	for (i=0 ; i<sv.num_edicts ; i++)
		ED_PrintNum (i);
}

/*
=============
ED_PrintEdict_f

For debugging, prints a single edicy
=============
*/
void ED_PrintEdict_f (void)
{
	int		i;
	
	i = Q_atoi (Cmd_Argv(1));
	if (i >= sv.num_edicts)
	{
		Con_Printf("Bad edict number\n");
		return;
	}
	ED_PrintNum (i);
}

/*
=============
ED_Count

For debugging
=============
*/
void ED_Count (void)
{
	int		i;
	edict_t	*ent;
	int		active, models, solid, step;

	active = models = solid = step = 0;
	for (i=0 ; i<sv.num_edicts ; i++)
	{
		ent = EDICT_NUM(i);
		if (ent->free)
			continue;
		active++;
		if (ent->v.solid)
			solid++;
		if (ent->v.model)
			models++;
		if (ent->v.movetype == MOVETYPE_STEP)
			step++;
	}

	Con_Printf ("num_edicts:%3i\n", sv.num_edicts);
	Con_Printf ("active    :%3i\n", active);
	Con_Printf ("view      :%3i\n", models);
	Con_Printf ("touch     :%3i\n", solid);
	Con_Printf ("step      :%3i\n", step);

}

/*
==============================================================================

					ARCHIVING GLOBALS

FIXME: need to tag constants, doesn't really work
==============================================================================
*/

/*
=============
ED_WriteGlobals
=============
*/
void ED_WriteGlobals (FILE *f)
{
	ddef_t		*def;
	int			i;
	char		*name;
	int			type;

	fprintf (f,"{\n");
	for (i=0 ; i<progs->numglobaldefs ; i++)
	{
		def = &pr_globaldefs[i];
		type = def->type;
		if ( !(def->type & DEF_SAVEGLOBAL) )
			continue;
		type &= ~DEF_SAVEGLOBAL;

		if (type != ev_string
		&& type != ev_float
		&& type != ev_entity)
			continue;

		name = pr_strings + def->s_name;		
		fprintf (f,"\"%s\" ", name);
		fprintf (f,"\"%s\"\n", PR_UglyValueString(type, (eval_t *)&pr_globals[def->ofs]));		
	}
	fprintf (f,"}\n");
}

/*
=============
ED_ParseGlobals
=============
*/
void ED_ParseGlobals (char *data)
{
	char	keyname[64];
	ddef_t	*key;

	while (1)
	{	
	// parse key
		data = COM_Parse (data);
		if (com_token[0] == '}')
			break;
		if (!data)
			Sys_Error ("ED_ParseEntity: EOF without closing brace");

		strcpy (keyname, com_token);

	// parse value	
		data = COM_Parse (data);
		if (!data)
			Sys_Error ("ED_ParseEntity: EOF without closing brace");

		if (com_token[0] == '}')
			Sys_Error ("ED_ParseEntity: closing brace without data");

		key = ED_FindGlobal (keyname);
		if (!key)
		{
			Con_Printf ("'%s' is not a global\n", keyname);
			continue;
		}

		if (!ED_ParseEpair ((void *)pr_globals, key, com_token))
			Host_Error ("ED_ParseGlobals: parse error");
	}
}

//============================================================================


/*
=============
ED_NewString
=============
*/
char *ED_NewString (char *string)
{
	char	*new, *new_p;
	int		i,l;
	
	l = strlen(string) + 1;
	new = Hunk_Alloc (l);
	new_p = new;

	for (i=0 ; i< l ; i++)
	{
		if (string[i] == '\\' && i < l-1)
		{
			i++;
			if (string[i] == 'n')
				*new_p++ = '\n';
			else
				*new_p++ = '\\';
		}
		else
			*new_p++ = string[i];
	}
	
	return new;
}


/*
=============
ED_ParseEval

Can parse either fields or globals
returns false if error
=============
*/
qboolean	ED_ParseEpair (void *base, ddef_t *key, char *s)
{
	int		i;
	char	string[128];
	ddef_t	*def;
	char	*v, *w;
	void	*d;
	dfunction_t	*func;
	
	d = (void *)((int *)base + key->ofs);
	
	switch (key->type & ~DEF_SAVEGLOBAL)
	{
	case ev_string:
		*(string_t *)d = ED_NewString (s) - pr_strings;
		break;
		
	case ev_float:
		*(float *)d = atof (s);
		break;
		
	case ev_vector:
		strcpy (string, s);
		v = string;
		w = string;
		for (i=0 ; i<3 ; i++)
		{
			while (*v && *v != ' ')
				v++;
			*v = 0;
			((float *)d)[i] = atof (w);
			w = v = v+1;
		}
		break;
		
	case ev_entity:
		*(int *)d = EDICT_TO_PROG(EDICT_NUM(atoi (s)));
		break;
		
	case ev_field:
		def = ED_FindField (s);
		if (!def)
		{
			Con_Printf ("Can't find field %s\n", s);
			return false;
		}
		*(int *)d = G_INT(def->ofs);
		break;
	
	case ev_function:
		func = ED_FindFunction (s);
		if (!func)
		{
			Con_Printf ("Can't find function %s\n", s);
			return false;
		}
		*(func_t *)d = func - pr_functions;
		break;
		
	default:
		break;
	}
	return true;
}

/*
====================
ED_ParseEdict

Parses an edict out of the given string, returning the new position
ed should be a properly initialized empty edict.
Used for initial level load and for savegames.
====================
*/
char *ED_ParseEdict (char *data, edict_t *ent)
{
	ddef_t		*key;
	qboolean	anglehack;
	qboolean	init;
	char		keyname[256];
	int			n;

	init = false;

// clear it
	if (ent != sv.edicts)	// hack
		memset (&ent->v, 0, progs->entityfields * 4);

// go through all the dictionary pairs
	while (1)
	{	
	// parse key
		data = COM_Parse (data);
		if (com_token[0] == '}')
			break;
		if (!data)
			Sys_Error ("ED_ParseEntity: EOF without closing brace");
		
// anglehack is to allow QuakeEd to write single scalar angles
// and allow them to be turned into vectors. (FIXME...)
if (!strcmp(com_token, "angle"))
{
	strcpy (com_token, "angles");
	anglehack = true;
}
else
	anglehack = false;

// FIXME: change light to _light to get rid of this hack
if (!strcmp(com_token, "light"))
	strcpy (com_token, "light_lev");	// hack for single light def

		strcpy (keyname, com_token);

		// another hack to fix heynames with trailing spaces
		n = strlen(keyname);
		while (n && keyname[n-1] == ' ')
		{
			keyname[n-1] = 0;
			n--;
		}

	// parse value	
		data = COM_Parse (data);
		if (!data)
			Sys_Error ("ED_ParseEntity: EOF without closing brace");

		if (com_token[0] == '}')
			Sys_Error ("ED_ParseEntity: closing brace without data");

		init = true;	

// keynames with a leading underscore are used for utility comments,
// and are immediately discarded by quake
		if (keyname[0] == '_')
			continue;
		
		key = ED_FindField (keyname);
		if (!key)
		{
			Con_Printf ("'%s' is not a field\n", keyname);
			continue;
		}

if (anglehack)
{
char	temp[32];
strcpy (temp, com_token);
sprintf (com_token, "0 %s 0", temp);
}

		if (!ED_ParseEpair ((void *)&ent->v, key, com_token))
			Host_Error ("ED_ParseEdict: parse error");
	}

	if (!init)
		ent->free = true;

	return data;
}


/*
================
ED_LoadFromFile

The entities are directly placed in the array, rather than allocated with
ED_Alloc, because otherwise an error loading the map would have entity
number references out of order.

Creates a server's entity / program execution context by
parsing textual entity definitions out of an ent file.

Used for both fresh maps and savegame loads.  A fresh map would also need
to call ED_CallSpawnFunctions () to let the objects initialize themselves.
================
*/
void ED_LoadFromFile (char *data)
{	
	edict_t		*ent;
	int			inhibit;
	dfunction_t	*func;
	
	ent = NULL;
	inhibit = 0;
	pr_global_struct->time = sv.time;
	
// parse ents
	while (1)
	{
// parse the opening brace	
		data = COM_Parse (data);
		if (!data)
			break;
		if (com_token[0] != '{')
			Sys_Error ("ED_LoadFromFile: found %s when expecting {",com_token);

		if (!ent)
			ent = EDICT_NUM(0);
		else
			ent = ED_Alloc ();
		data = ED_ParseEdict (data, ent);

// remove things from different skill levels or deathmatch
		if (deathmatch.value)
		{
			if (((int)ent->v.spawnflags & SPAWNFLAG_NOT_DEATHMATCH))
			{
				ED_Free (ent);	
				inhibit++;
				continue;
			}
		}
		else if ((current_skill == 0 && ((int)ent->v.spawnflags & SPAWNFLAG_NOT_EASY))
				|| (current_skill == 1 && ((int)ent->v.spawnflags & SPAWNFLAG_NOT_MEDIUM))
				|| (current_skill >= 2 && ((int)ent->v.spawnflags & SPAWNFLAG_NOT_HARD)) )
		{
			ED_Free (ent);	
			inhibit++;
			continue;
		}

//
// immediately call spawn function
//
		if (!ent->v.classname)
		{
			Con_Printf ("No classname for:\n");
			ED_Print (ent);
			ED_Free (ent);
			continue;
		}

	// look for the spawn function
		func = ED_FindFunction ( pr_strings + ent->v.classname );

		if (!func)
		{
			Con_Printf ("No spawn function for:\n");
			ED_Print (ent);
			ED_Free (ent);
			continue;
		}

		pr_global_struct->self = EDICT_TO_PROG(ent);
		PR_ExecuteProgram (func - pr_functions);
	}	

	Con_DPrintf ("%i entities inhibited\n", inhibit);
}


/*
===============
PR_LoadProgs
===============
*/
void PR_LoadProgs (void)
{
	int		i;

// flush the non-C variable lookup cache
	for (i=0 ; i<GEFV_CACHESIZE ; i++)
		gefvCache[i].field[0] = 0;

	CRC_Init (&pr_crc);

	progs = (dprograms_t *)COM_LoadHunkFile ("progs.dat");
	if (!progs)
		Sys_Error ("PR_LoadProgs: couldn't load progs.dat");
	Con_DPrintf ("Programs occupy %iK.\n", com_filesize/1024);

	for (i=0 ; i<com_filesize ; i++)
		CRC_ProcessByte (&pr_crc, ((byte *)progs)[i]);

// byte swap the header
	for (i=0 ; i<sizeof(*progs)/4 ; i++)
		((int *)progs)[i] = LittleLong ( ((int *)progs)[i] );		

	if (progs->version != PROG_VERSION)
		Sys_Error ("progs.dat has wrong version number (%i should be %i)", progs->version, PROG_VERSION);
	if (progs->crc != PROGHEADER_CRC)
		Sys_Error ("progs.dat system vars have been modified, progdefs.h is out of date");

	pr_functions = (dfunction_t *)((byte *)progs + progs->ofs_functions);
	pr_strings = (char *)progs + progs->ofs_strings;
	pr_globaldefs = (ddef_t *)((byte *)progs + progs->ofs_globaldefs);
	pr_fielddefs = (ddef_t *)((byte *)progs + progs->ofs_fielddefs);
	pr_statements = (dstatement_t *)((byte *)progs + progs->ofs_statements);

	pr_global_struct = (globalvars_t *)((byte *)progs + progs->ofs_globals);
	pr_globals = (float *)pr_global_struct;
	
	pr_edict_size = progs->entityfields * 4 + sizeof (edict_t) - sizeof(entvars_t);
	
// byte swap the lumps
	for (i=0 ; i<progs->numstatements ; i++)
	{
		pr_statements[i].op = LittleShort(pr_statements[i].op);
		pr_statements[i].a = LittleShort(pr_statements[i].a);
		pr_statements[i].b = LittleShort(pr_statements[i].b);
		pr_statements[i].c = LittleShort(pr_statements[i].c);
	}

	for (i=0 ; i<progs->numfunctions; i++)
	{
	pr_functions[i].first_statement = LittleLong (pr_functions[i].first_statement);
	pr_functions[i].parm_start = LittleLong (pr_functions[i].parm_start);
	pr_functions[i].s_name = LittleLong (pr_functions[i].s_name);
	pr_functions[i].s_file = LittleLong (pr_functions[i].s_file);
	pr_functions[i].numparms = LittleLong (pr_functions[i].numparms);
	pr_functions[i].locals = LittleLong (pr_functions[i].locals);
	}	

	for (i=0 ; i<progs->numglobaldefs ; i++)
	{
		pr_globaldefs[i].type = LittleShort (pr_globaldefs[i].type);
		pr_globaldefs[i].ofs = LittleShort (pr_globaldefs[i].ofs);
		pr_globaldefs[i].s_name = LittleLong (pr_globaldefs[i].s_name);
	}

	for (i=0 ; i<progs->numfielddefs ; i++)
	{
		pr_fielddefs[i].type = LittleShort (pr_fielddefs[i].type);
		if (pr_fielddefs[i].type & DEF_SAVEGLOBAL)
			Sys_Error ("PR_LoadProgs: pr_fielddefs[i].type & DEF_SAVEGLOBAL");
		pr_fielddefs[i].ofs = LittleShort (pr_fielddefs[i].ofs);
		pr_fielddefs[i].s_name = LittleLong (pr_fielddefs[i].s_name);
	}

	for (i=0 ; i<progs->numglobals ; i++)
		((int *)pr_globals)[i] = LittleLong (((int *)pr_globals)[i]);
}


/*
===============
PR_Init
===============
*/
void PR_Init (void)
{
	Cmd_AddCommand ("edict", ED_PrintEdict_f);
	Cmd_AddCommand ("edicts", ED_PrintEdicts);
	Cmd_AddCommand ("edictcount", ED_Count);
	Cmd_AddCommand ("profile", PR_Profile_f);
	Cvar_RegisterVariable (&nomonsters);
	Cvar_RegisterVariable (&gamecfg);
	Cvar_RegisterVariable (&scratch1);
	Cvar_RegisterVariable (&scratch2);
	Cvar_RegisterVariable (&scratch3);
	Cvar_RegisterVariable (&scratch4);
	Cvar_RegisterVariable (&savedgamecfg);
	Cvar_RegisterVariable (&saved1);
	Cvar_RegisterVariable (&saved2);
	Cvar_RegisterVariable (&saved3);
	Cvar_RegisterVariable (&saved4);
}



edict_t *EDICT_NUM(int n)
{
	if (n < 0 || n >= sv.max_edicts)
		Sys_Error ("EDICT_NUM: bad number %i", n);
	return (edict_t *)((byte *)sv.edicts+ (n)*pr_edict_size);
}

int NUM_FOR_EDICT(edict_t *e)
{
	int		b;
	
	b = (byte *)e - (byte *)sv.edicts;
	b = b / pr_edict_size;
	
	if (b < 0 || b >= sv.num_edicts)
		Sys_Error ("NUM_FOR_EDICT: bad pointer");
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\quakedef.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// quakedef.h -- primary header for client

//#define	GLTEST			// experimental stuff

#define	QUAKE_GAME			// as opposed to utilities

#define	VERSION				1.09
#define	GLQUAKE_VERSION		1.00
#define	D3DQUAKE_VERSION	0.01
#define	WINQUAKE_VERSION	0.996
#define	LINUX_VERSION		1.30
#define	X11_VERSION			1.10

//define	PARANOID			// speed sapping error checking

#ifdef QUAKE2
#define	GAMENAME	"id1"		// directory to look in by default
#else
#define	GAMENAME	"id1"
#endif

#include <math.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_WIN32) && !defined(WINDED)

#if defined(_M_IX86)
#define __i386__	1
#endif

void	VID_LockBuffer (void);
void	VID_UnlockBuffer (void);

#else

#define	VID_LockBuffer()
#define	VID_UnlockBuffer()

#endif

#ifdef NO_ASSEMBLY
#define id386 0
#else
#if defined __i386__ // && !defined __sun__
#define id386	1
#else
#define id386	0
#endif
#endif

#if id386
#define UNALIGNED_OK	1	// set to 0 if unaligned accesses are not supported
#else
#define UNALIGNED_OK	0
#endif

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
#define CACHE_SIZE	32		// used to align key data structures

#define UNUSED(x)	(x = x)	// for pesky compiler / lint warnings

#define	MINIMUM_MEMORY			0x550000
#define	MINIMUM_MEMORY_LEVELPAK	(MINIMUM_MEMORY + 0x100000)

#define MAX_NUM_ARGVS	50

// up / down
#define	PITCH	0

// left / right
#define	YAW		1

// fall over
#define	ROLL	2


#define	MAX_QPATH		64			// max length of a quake game pathname
#define	MAX_OSPATH		128			// max length of a filesystem pathname

#define	ON_EPSILON		0.1			// point on plane side epsilon

#define	MAX_MSGLEN		8000		// max length of a reliable message
#define	MAX_DATAGRAM	1024		// max length of unreliable message

//
// per-level limits
//
#define	MAX_EDICTS		600			// FIXME: ouch! ouch! ouch!
#define	MAX_LIGHTSTYLES	64
#define	MAX_MODELS		256			// these are sent over the net as bytes
#define	MAX_SOUNDS		256			// so they cannot be blindly increased

#define	SAVEGAME_COMMENT_LENGTH	39

#define	MAX_STYLESTRING	64

//
// stats are integers communicated to the client by the server
//
#define	MAX_CL_STATS		32
#define	STAT_HEALTH			0
#define	STAT_FRAGS			1
#define	STAT_WEAPON			2
#define	STAT_AMMO			3
#define	STAT_ARMOR			4
#define	STAT_WEAPONFRAME	5
#define	STAT_SHELLS			6
#define	STAT_NAILS			7
#define	STAT_ROCKETS		8
#define	STAT_CELLS			9
#define	STAT_ACTIVEWEAPON	10
#define	STAT_TOTALSECRETS	11
#define	STAT_TOTALMONSTERS	12
#define	STAT_SECRETS		13		// bumped on client side by svc_foundsecret
#define	STAT_MONSTERS		14		// bumped by svc_killedmonster

// stock defines

#define	IT_SHOTGUN				1
#define	IT_SUPER_SHOTGUN		2
#define	IT_NAILGUN				4
#define	IT_SUPER_NAILGUN		8
#define	IT_GRENADE_LAUNCHER		16
#define	IT_ROCKET_LAUNCHER		32
#define	IT_LIGHTNING			64
#define IT_SUPER_LIGHTNING      128
#define IT_SHELLS               256
#define IT_NAILS                512
#define IT_ROCKETS              1024
#define IT_CELLS                2048
#define IT_AXE                  4096
#define IT_ARMOR1               8192
#define IT_ARMOR2               16384
#define IT_ARMOR3               32768
#define IT_SUPERHEALTH          65536
#define IT_KEY1                 131072
#define IT_KEY2                 262144
#define	IT_INVISIBILITY			524288
#define	IT_INVULNERABILITY		1048576
#define	IT_SUIT					2097152
#define	IT_QUAD					4194304
#define IT_SIGIL1               (1<<28)
#define IT_SIGIL2               (1<<29)
#define IT_SIGIL3               (1<<30)
#define IT_SIGIL4               (1<<31)

//===========================================
//rogue changed and added defines

#define RIT_SHELLS              128
#define RIT_NAILS               256
#define RIT_ROCKETS             512
#define RIT_CELLS               1024
#define RIT_AXE                 2048
#define RIT_LAVA_NAILGUN        4096
#define RIT_LAVA_SUPER_NAILGUN  8192
#define RIT_MULTI_GRENADE       16384
#define RIT_MULTI_ROCKET        32768
#define RIT_PLASMA_GUN          65536
#define RIT_ARMOR1              8388608
#define RIT_ARMOR2              16777216
#define RIT_ARMOR3              33554432
#define RIT_LAVA_NAILS          67108864
#define RIT_PLASMA_AMMO         134217728
#define RIT_MULTI_ROCKETS       268435456
#define RIT_SHIELD              536870912
#define RIT_ANTIGRAV            1073741824
#define RIT_SUPERHEALTH         2147483648

//MED 01/04/97 added hipnotic defines
//===========================================
//hipnotic added defines
#define HIT_PROXIMITY_GUN_BIT 16
#define HIT_MJOLNIR_BIT       7
#define HIT_LASER_CANNON_BIT  23
#define HIT_PROXIMITY_GUN   (1<<HIT_PROXIMITY_GUN_BIT)
#define HIT_MJOLNIR         (1<<HIT_MJOLNIR_BIT)
#define HIT_LASER_CANNON    (1<<HIT_LASER_CANNON_BIT)
#define HIT_WETSUIT         (1<<(23+2))
#define HIT_EMPATHY_SHIELDS (1<<(23+3))

//===========================================

#define	MAX_SCOREBOARD		16
#define	MAX_SCOREBOARDNAME	32

#define	SOUND_CHANNELS		8

// This makes anyone on id's net privileged
// Use for multiplayer testing only - VERY dangerous!!!
// #define IDGODS

#include "common.h"
#include "bspfile.h"
#include "vid.h"
#include "sys.h"
#include "zone.h"
#include "mathlib.h"

typedef struct
{
	vec3_t	origin;
	vec3_t	angles;
	int		modelindex;
	int		frame;
	int		colormap;
	int		skin;
	int		effects;
} entity_state_t;


#include "wad.h"
#include "draw.h"
#include "cvar.h"
#include "screen.h"
#include "net.h"
#include "protocol.h"
#include "cmd.h"
#include "sbar.h"
#include "sound.h"
#include "render.h"
#include "client.h"
#include "progs.h"
#include "server.h"

#ifdef GLQUAKE
#include "gl_model.h"
#else
#include "model.h"
#include "d_iface.h"
#endif

#include "input.h"
#include "world.h"
#include "keys.h"
#include "console.h"
#include "view.h"
#include "menu.h"
#include "crc.h"
#include "cdaudio.h"

#ifdef GLQUAKE
#include "glquake.h"
#endif

//=============================================================================

// the host system specifies the base of the directory tree, the
// command line parms passed to the program, and the amount of memory
// available for the program to use

typedef struct
{
	char	*basedir;
	char	*cachedir;		// for development over ISDN lines
	int		argc;
	char	**argv;
	void	*membase;
	int		memsize;
} quakeparms_t;


//=============================================================================



extern qboolean noclip_anglehack;


//
// host
//
extern	quakeparms_t host_parms;

extern	cvar_t		sys_ticrate;
extern	cvar_t		sys_nostdout;
extern	cvar_t		developer;

extern	qboolean	host_initialized;		// true if into command execution
extern	double		host_frametime;
extern	byte		*host_basepal;
extern	byte		*host_colormap;
extern	int			host_framecount;	// incremented every frame, never reset
extern	double		realtime;			// not bounded in any way, changed at
										// start of every frame, never reset

void Host_ClearMemory (void);
void Host_ServerFrame (void);
void Host_InitCommands (void);
void Host_Init (quakeparms_t *parms);
void Host_Shutdown(void);
void Host_Error (char *error, ...);
void Host_EndGame (char *message, ...);
void Host_Frame (float time);
void Host_Quit_f (void);
void Host_ClientCommands (char *fmt, ...);
void Host_ShutdownServer (qboolean crash);

extern qboolean		msg_suppress_1;		// suppresses resolution and cache size console output
										//  an fullscreen DIB focus gain/loss
extern int			current_skill;		// skill level for currently loaded level (in case
										//  the user changes the cvar while the level is
										//  running, this reflects the level actually in use)

extern qboolean		isDedicated;

extern int			minimum_memory;

//
// chase
//
extern	cvar_t	chase_active;

void Chase_Init (void);
void Chase_Reset (void);
void Chase_Update (void);

int R_LightPoint (vec3_t p);
void R_DrawBrushModel (entity_t *e);
void R_AnimateLight (void);
void R_DrawWorld (void);
void R_RenderDlights (void);
void R_DrawParticles (void);
void R_DrawWaterSurfaces (void);
void R_RenderBrushPoly(msurface_t *fa);
void R_InitParticles (void);
void R_ClearParticles (void);
void R_DrawSkyChain (msurface_t *s);
qboolean R_CullBox (vec3_t mins, vec3_t maxs);
void R_MarkLights (dlight_t *light, int bit, mnode_t *node);
void R_RotateForEntity (entity_t *e);
void R_StoreEfrags (efrag_t **ppefrag);

qboolean VID_Is8bit();
void GL_Upload8_EXT (byte *data, int width, int height,  qboolean mipmap, qboolean alpha);
void GL_BuildLightmaps (void);
void GL_Set2D (void);

void EmitWaterPolys (msurface_t *fa);
void EmitSkyPolys (msurface_t *fa);
void EmitBothSkyLayers (msurface_t *fa);

#pragma warning(disable : 4244) /* MIPS conversion to float, possible loss of data */
#pragma warning(disable : 4305) /* MIPS truncation from const double to float */
#pragma warning(disable : 4018) /* MIPS signed/unsigned mismatch */
#pragma warning(disable : 4101) /* MIPS unreferenced local variable */

#ifdef __cplusplus
}// end of extern "C"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\pr_exec.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"


/*

*/

typedef struct
{
	int				s;
	dfunction_t		*f;
} prstack_t;

#define	MAX_STACK_DEPTH		32
prstack_t	pr_stack[MAX_STACK_DEPTH];
int			pr_depth;

#define	LOCALSTACK_SIZE		2048
int			localstack[LOCALSTACK_SIZE];
int			localstack_used;


qboolean	pr_trace;
dfunction_t	*pr_xfunction;
int			pr_xstatement;


int		pr_argc;

char *pr_opnames[] =
{
"DONE",

"MUL_F",
"MUL_V", 
"MUL_FV",
"MUL_VF",
 
"DIV",

"ADD_F",
"ADD_V", 
  
"SUB_F",
"SUB_V",

"EQ_F",
"EQ_V",
"EQ_S", 
"EQ_E",
"EQ_FNC",
 
"NE_F",
"NE_V", 
"NE_S",
"NE_E", 
"NE_FNC",
 
"LE",
"GE",
"LT",
"GT", 

"INDIRECT",
"INDIRECT",
"INDIRECT", 
"INDIRECT", 
"INDIRECT",
"INDIRECT", 

"ADDRESS", 

"STORE_F",
"STORE_V",
"STORE_S",
"STORE_ENT",
"STORE_FLD",
"STORE_FNC",

"STOREP_F",
"STOREP_V",
"STOREP_S",
"STOREP_ENT",
"STOREP_FLD",
"STOREP_FNC",

"RETURN",
  
"NOT_F",
"NOT_V",
"NOT_S", 
"NOT_ENT", 
"NOT_FNC", 
  
"IF",
"IFNOT",
  
"CALL0",
"CALL1",
"CALL2",
"CALL3",
"CALL4",
"CALL5",
"CALL6",
"CALL7",
"CALL8",
  
"STATE",
  
"GOTO", 
  
"AND",
"OR", 

"BITAND",
"BITOR"
};

char *PR_GlobalString (int ofs);
char *PR_GlobalStringNoContents (int ofs);


//=============================================================================

/*
=================
PR_PrintStatement
=================
*/
void PR_PrintStatement (dstatement_t *s)
{
	int		i;
	
	if ( (unsigned)s->op < sizeof(pr_opnames)/sizeof(pr_opnames[0]))
	{
		Con_Printf ("%s ",  pr_opnames[s->op]);
		i = strlen(pr_opnames[s->op]);
		for ( ; i<10 ; i++)
			Con_Printf (" ");
	}
		
	if (s->op == OP_IF || s->op == OP_IFNOT)
		Con_Printf ("%sbranch %i",PR_GlobalString(s->a),s->b);
	else if (s->op == OP_GOTO)
	{
		Con_Printf ("branch %i",s->a);
	}
	else if ( (unsigned)(s->op - OP_STORE_F) < 6)
	{
		Con_Printf ("%s",PR_GlobalString(s->a));
		Con_Printf ("%s", PR_GlobalStringNoContents(s->b));
	}
	else
	{
		if (s->a)
			Con_Printf ("%s",PR_GlobalString(s->a));
		if (s->b)
			Con_Printf ("%s",PR_GlobalString(s->b));
		if (s->c)
			Con_Printf ("%s", PR_GlobalStringNoContents(s->c));
	}
	Con_Printf ("\n");
}

/*
============
PR_StackTrace
============
*/
void PR_StackTrace (void)
{
	dfunction_t	*f;
	int			i;
	
	if (pr_depth == 0)
	{
		Con_Printf ("<NO STACK>\n");
		return;
	}
	
	pr_stack[pr_depth].f = pr_xfunction;
	for (i=pr_depth ; i>=0 ; i--)
	{
		f = pr_stack[i].f;
		
		if (!f)
		{
			Con_Printf ("<NO FUNCTION>\n");
		}
		else
			Con_Printf ("%12s : %s\n", pr_strings + f->s_file, pr_strings + f->s_name);		
	}
}


/*
============
PR_Profile_f

============
*/
void PR_Profile_f (void)
{
	dfunction_t	*f, *best;
	int			max;
	int			num;
	int			i;
	
	num = 0;	
	do
	{
		max = 0;
		best = NULL;
		for (i=0 ; i<progs->numfunctions ; i++)
		{
			f = &pr_functions[i];
			if (f->profile > max)
			{
				max = f->profile;
				best = f;
			}
		}
		if (best)
		{
			if (num < 10)
				Con_Printf ("%7i %s\n", best->profile, pr_strings+best->s_name);
			num++;
			best->profile = 0;
		}
	} while (best);
}


/*
============
PR_RunError

Aborts the currently executing function
============
*/
void PR_RunError (char *error, ...)
{
	va_list		argptr;
	char		string[1024];

	va_start (argptr,error);
	vsprintf (string,error,argptr);
	va_end (argptr);

	PR_PrintStatement (pr_statements + pr_xstatement);
	PR_StackTrace ();
	Con_Printf ("%s\n", string);
	
	pr_depth = 0;		// dump the stack so host_error can shutdown functions

	Host_Error ("Program error");
}

/*
============================================================================
PR_ExecuteProgram

The interpretation main loop
============================================================================
*/

/*
====================
PR_EnterFunction

Returns the new program statement counter
====================
*/
int PR_EnterFunction (dfunction_t *f)
{
	int		i, j, c, o;

	pr_stack[pr_depth].s = pr_xstatement;
	pr_stack[pr_depth].f = pr_xfunction;	
	pr_depth++;
	if (pr_depth >= MAX_STACK_DEPTH)
		PR_RunError ("stack overflow");

// save off any locals that the new function steps on
	c = f->locals;
	if (localstack_used + c > LOCALSTACK_SIZE)
		PR_RunError ("PR_ExecuteProgram: locals stack overflow\n");

	for (i=0 ; i < c ; i++)
		localstack[localstack_used+i] = ((int *)pr_globals)[f->parm_start + i];
	localstack_used += c;

// copy parameters
	o = f->parm_start;
	for (i=0 ; i<f->numparms ; i++)
	{
		for (j=0 ; j<f->parm_size[i] ; j++)
		{
			((int *)pr_globals)[o] = ((int *)pr_globals)[OFS_PARM0+i*3+j];
			o++;
		}
	}

	pr_xfunction = f;
	return f->first_statement - 1;	// offset the s++
}

/*
====================
PR_LeaveFunction
====================
*/
int PR_LeaveFunction (void)
{
	int		i, c;

	if (pr_depth <= 0)
		Sys_Error ("prog stack underflow");

// restore locals from the stack
	c = pr_xfunction->locals;
	localstack_used -= c;
	if (localstack_used < 0)
		PR_RunError ("PR_ExecuteProgram: locals stack underflow\n");

	for (i=0 ; i < c ; i++)
		((int *)pr_globals)[pr_xfunction->parm_start + i] = localstack[localstack_used+i];

// up stack
	pr_depth--;
	pr_xfunction = pr_stack[pr_depth].f;
	return pr_stack[pr_depth].s;
}


/*
====================
PR_ExecuteProgram
====================
*/
void PR_ExecuteProgram (func_t fnum)
{
	eval_t	*a, *b, *c;
	int			s;
	dstatement_t	*st;
	dfunction_t	*f, *newf;
	int		runaway;
	int		i;
	edict_t	*ed;
	int		exitdepth;
	eval_t	*ptr;

	if (!fnum || fnum >= progs->numfunctions)
	{
		if (pr_global_struct->self)
			ED_Print (PROG_TO_EDICT(pr_global_struct->self));
		Host_Error ("PR_ExecuteProgram: NULL function");
	}
	
	f = &pr_functions[fnum];

	runaway = 100000;
	pr_trace = false;

// make a stack frame
	exitdepth = pr_depth;

	s = PR_EnterFunction (f);
	
while (1)
{
	s++;	// next statement

	st = &pr_statements[s];
	a = (eval_t *)&pr_globals[st->a];
	b = (eval_t *)&pr_globals[st->b];
	c = (eval_t *)&pr_globals[st->c];
	
	if (!--runaway)
		PR_RunError ("runaway loop error");
		
	pr_xfunction->profile++;
	pr_xstatement = s;
	
	if (pr_trace)
		PR_PrintStatement (st);
		
	switch (st->op)
	{
	case OP_ADD_F:
		c->_float = a->_float + b->_float;
		break;
	case OP_ADD_V:
		c->vector[0] = a->vector[0] + b->vector[0];
		c->vector[1] = a->vector[1] + b->vector[1];
		c->vector[2] = a->vector[2] + b->vector[2];
		break;
		
	case OP_SUB_F:
		c->_float = a->_float - b->_float;
		break;
	case OP_SUB_V:
		c->vector[0] = a->vector[0] - b->vector[0];
		c->vector[1] = a->vector[1] - b->vector[1];
		c->vector[2] = a->vector[2] - b->vector[2];
		break;

	case OP_MUL_F:
		c->_float = a->_float * b->_float;
		break;
	case OP_MUL_V:
		c->_float = a->vector[0]*b->vector[0]
				+ a->vector[1]*b->vector[1]
				+ a->vector[2]*b->vector[2];
		break;
	case OP_MUL_FV:
		c->vector[0] = a->_float * b->vector[0];
		c->vector[1] = a->_float * b->vector[1];
		c->vector[2] = a->_float * b->vector[2];
		break;
	case OP_MUL_VF:
		c->vector[0] = b->_float * a->vector[0];
		c->vector[1] = b->_float * a->vector[1];
		c->vector[2] = b->_float * a->vector[2];
		break;

	case OP_DIV_F:
		c->_float = a->_float / b->_float;
		break;
	
	case OP_BITAND:
		c->_float = (int)a->_float & (int)b->_float;
		break;
	
	case OP_BITOR:
		c->_float = (int)a->_float | (int)b->_float;
		break;
	
		
	case OP_GE:
		c->_float = a->_float >= b->_float;
		break;
	case OP_LE:
		c->_float = a->_float <= b->_float;
		break;
	case OP_GT:
		c->_float = a->_float > b->_float;
		break;
	case OP_LT:
		c->_float = a->_float < b->_float;
		break;
	case OP_AND:
		c->_float = a->_float && b->_float;
		break;
	case OP_OR:
		c->_float = a->_float || b->_float;
		break;
		
	case OP_NOT_F:
		c->_float = !a->_float;
		break;
	case OP_NOT_V:
		c->_float = !a->vector[0] && !a->vector[1] && !a->vector[2];
		break;
	case OP_NOT_S:
		c->_float = !a->string || !pr_strings[a->string];
		break;
	case OP_NOT_FNC:
		c->_float = !a->function;
		break;
	case OP_NOT_ENT:
		c->_float = (PROG_TO_EDICT(a->edict) == sv.edicts);
		break;

	case OP_EQ_F:
		c->_float = a->_float == b->_float;
		break;
	case OP_EQ_V:
		c->_float = (a->vector[0] == b->vector[0]) &&
					(a->vector[1] == b->vector[1]) &&
					(a->vector[2] == b->vector[2]);
		break;
	case OP_EQ_S:
		c->_float = !strcmp(pr_strings+a->string,pr_strings+b->string);
		break;
	case OP_EQ_E:
		c->_float = a->_int == b->_int;
		break;
	case OP_EQ_FNC:
		c->_float = a->function == b->function;
		break;


	case OP_NE_F:
		c->_float = a->_float != b->_float;
		break;
	case OP_NE_V:
		c->_float = (a->vector[0] != b->vector[0]) ||
					(a->vector[1] != b->vector[1]) ||
					(a->vector[2] != b->vector[2]);
		break;
	case OP_NE_S:
		c->_float = strcmp(pr_strings+a->string,pr_strings+b->string);
		break;
	case OP_NE_E:
		c->_float = a->_int != b->_int;
		break;
	case OP_NE_FNC:
		c->_float = a->function != b->function;
		break;

//==================
	case OP_STORE_F:
	case OP_STORE_ENT:
	case OP_STORE_FLD:		// integers
	case OP_STORE_S:
	case OP_STORE_FNC:		// pointers
		b->_int = a->_int;
		break;
	case OP_STORE_V:
		b->vector[0] = a->vector[0];
		b->vector[1] = a->vector[1];
		b->vector[2] = a->vector[2];
		break;
		
	case OP_STOREP_F:
	case OP_STOREP_ENT:
	case OP_STOREP_FLD:		// integers
	case OP_STOREP_S:
	case OP_STOREP_FNC:		// pointers
		ptr = (eval_t *)((byte *)sv.edicts + b->_int);
		ptr->_int = a->_int;
		break;
	case OP_STOREP_V:
		ptr = (eval_t *)((byte *)sv.edicts + b->_int);
		ptr->vector[0] = a->vector[0];
		ptr->vector[1] = a->vector[1];
		ptr->vector[2] = a->vector[2];
		break;
		
	case OP_ADDRESS:
		ed = PROG_TO_EDICT(a->edict);
#ifdef PARANOID
		NUM_FOR_EDICT(ed);		// make sure it's in range
#endif
		if (ed == (edict_t *)sv.edicts && sv.state == ss_active)
			PR_RunError ("assignment to world entity");
		c->_int = (byte *)((int *)&ed->v + b->_int) - (byte *)sv.edicts;
		break;
		
	case OP_LOAD_F:
	case OP_LOAD_FLD:
	case OP_LOAD_ENT:
	case OP_LOAD_S:
	case OP_LOAD_FNC:
		ed = PROG_TO_EDICT(a->edict);
#ifdef PARANOID
		NUM_FOR_EDICT(ed);		// make sure it's in range
#endif
		a = (eval_t *)((int *)&ed->v + b->_int);
		c->_int = a->_int;
		break;

	case OP_LOAD_V:
		ed = PROG_TO_EDICT(a->edict);
#ifdef PARANOID
		NUM_FOR_EDICT(ed);		// make sure it's in range
#endif
		a = (eval_t *)((int *)&ed->v + b->_int);
		c->vector[0] = a->vector[0];
		c->vector[1] = a->vector[1];
		c->vector[2] = a->vector[2];
		break;
		
//==================

	case OP_IFNOT:
		if (!a->_int)
			s += st->b - 1;	// offset the s++
		break;
		
	case OP_IF:
		if (a->_int)
			s += st->b - 1;	// offset the s++
		break;
		
	case OP_GOTO:
		s += st->a - 1;	// offset the s++
		break;
		
	case OP_CALL0:
	case OP_CALL1:
	case OP_CALL2:
	case OP_CALL3:
	case OP_CALL4:
	case OP_CALL5:
	case OP_CALL6:
	case OP_CALL7:
	case OP_CALL8:
		pr_argc = st->op - OP_CALL0;
		if (!a->function)
			PR_RunError ("NULL function");

		newf = &pr_functions[a->function];

		if (newf->first_statement < 0)
		{	// negative statements are built in functions
			i = -newf->first_statement;
			if (i >= pr_numbuiltins)
				PR_RunError ("Bad builtin call number");
			pr_builtins[i] ();
			break;
		}

		s = PR_EnterFunction (newf);
		break;

	case OP_DONE:
	case OP_RETURN:
		pr_globals[OFS_RETURN] = pr_globals[st->a];
		pr_globals[OFS_RETURN+1] = pr_globals[st->a+1];
		pr_globals[OFS_RETURN+2] = pr_globals[st->a+2];
	
		s = PR_LeaveFunction ();
		if (pr_depth == exitdepth)
			return;		// all done
		break;
		
	case OP_STATE:
		ed = PROG_TO_EDICT(pr_global_struct->self);
#ifdef FPS_20
		ed->v.nextthink = pr_global_struct->time + 0.05;
#else
		ed->v.nextthink = pr_global_struct->time + 0.1;
#endif
		if (a->_float != ed->v.frame)
		{
			ed->v.frame = a->_float;
		}
		ed->v.think = b->function;
		break;
		
	default:
		PR_RunError ("Bad opcode %i", st->op);
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\render.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// refresh.h -- public interface to refresh functions

#define	MAXCLIPPLANES	11

#define	TOP_RANGE		16			// soldier uniform colors
#define	BOTTOM_RANGE	96

//=============================================================================

typedef struct efrag_s
{
	struct mleaf_s		*leaf;
	struct efrag_s		*leafnext;
	struct entity_s		*entity;
	struct efrag_s		*entnext;
} efrag_t;


typedef struct entity_s
{
	qboolean				forcelink;		// model changed

	int						update_type;

	entity_state_t			baseline;		// to fill in defaults in updates

	double					msgtime;		// time of last update
	vec3_t					msg_origins[2];	// last two updates (0 is newest)	
	vec3_t					origin;
	vec3_t					msg_angles[2];	// last two updates (0 is newest)
	vec3_t					angles;	
	struct model_s			*model;			// NULL = no model
	struct efrag_s			*efrag;			// linked list of efrags
	int						frame;
	float					syncbase;		// for client-side animations
	byte					*colormap;
	int						effects;		// light, particals, etc
	int						skinnum;		// for Alias models
	int						visframe;		// last frame this entity was
											//  found in an active leaf
											
	int						dlightframe;	// dynamic lighting
	int						dlightbits;
	
// FIXME: could turn these into a union
	int						trivial_accept;
	struct mnode_s			*topnode;		// for bmodels, first world node
											//  that splits bmodel, or NULL if
											//  not split
} entity_t;

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct
{
	vrect_t		vrect;				// subwindow in video for refresh
									// FIXME: not need vrect next field here?
	vrect_t		aliasvrect;			// scaled Alias version
	int			vrectright, vrectbottom;	// right & bottom screen coords
	int			aliasvrectright, aliasvrectbottom;	// scaled Alias versions
	float		vrectrightedge;			// rightmost right edge we care about,
										//  for use in edge list
	float		fvrectx, fvrecty;		// for floating-point compares
	float		fvrectx_adj, fvrecty_adj; // left and top edges, for clamping
	int			vrect_x_adj_shift20;	// (vrect.x + 0.5 - epsilon) << 20
	int			vrectright_adj_shift20;	// (vrectright + 0.5 - epsilon) << 20
	float		fvrectright_adj, fvrectbottom_adj;
										// right and bottom edges, for clamping
	float		fvrectright;			// rightmost edge, for Alias clamping
	float		fvrectbottom;			// bottommost edge, for Alias clamping
	float		horizontalFieldOfView;	// at Z = 1.0, this many X is visible 
										// 2.0 = 90 degrees
	float		xOrigin;			// should probably allways be 0.5
	float		yOrigin;			// between be around 0.3 to 0.5

	vec3_t		vieworg;
	vec3_t		viewangles;
	
	float		fov_x, fov_y;

	int			ambientlight;
} refdef_t;


//
// refresh
//
extern	int		reinit_surfcache;


extern	refdef_t	r_refdef;
extern vec3_t	r_origin, vpn, vright, vup;

extern	struct texture_s	*r_notexture_mip;


void R_Init (void);
void R_InitTextures (void);
void R_InitEfrags (void);
void R_RenderView (void);		// must set r_refdef first
void R_ViewChanged (vrect_t *pvrect, int lineadj, float aspect);
								// called whenever r_refdef or vid change
void R_InitSky (struct texture_s *mt);	// called at level load

void R_AddEfrags (entity_t *ent);
void R_RemoveEfrags (entity_t *ent);

void R_NewMap (void);


void R_ParseParticleEffect (void);
void R_RunParticleEffect (vec3_t org, vec3_t dir, int color, int count);
void R_RocketTrail (vec3_t start, vec3_t end, int type);

#ifdef QUAKE2
void R_DarkFieldParticles (entity_t *ent);
#endif
void R_EntityParticles (entity_t *ent);
void R_BlobExplosion (vec3_t org);
void R_ParticleExplosion (vec3_t org);
void R_ParticleExplosion2 (vec3_t org, int colorStart, int colorLength);
void R_LavaSplash (vec3_t org);
void R_TeleportSplash (vec3_t org);

void R_PushDlights (void);


//
// surface cache related
//
extern	int		reinit_surfcache;	// if 1, surface cache is currently empty and
extern qboolean	r_cache_thrash;	// set if thrashing the surface cache

int	D_SurfaceCacheForRes (int width, int height);
void D_FlushCaches (void);
void D_DeleteSurfaceCache (void);
void D_InitCaches (void *buffer, int size);
void R_SetVrect (vrect_t *pvrect, vrect_t *pvrectin, int lineadj);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\pr_comp.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// this file is shared by quake and qcc

typedef int	func_t;
typedef int	string_t;

typedef enum {ev_void, ev_string, ev_float, ev_vector, ev_entity, ev_field, ev_function, ev_pointer} etype_t;


#define	OFS_NULL		0
#define	OFS_RETURN		1
#define	OFS_PARM0		4		// leave 3 ofs for each parm to hold vectors
#define	OFS_PARM1		7
#define	OFS_PARM2		10
#define	OFS_PARM3		13
#define	OFS_PARM4		16
#define	OFS_PARM5		19
#define	OFS_PARM6		22
#define	OFS_PARM7		25
#define	RESERVED_OFS	28


enum {
	OP_DONE,
	OP_MUL_F,
	OP_MUL_V,
	OP_MUL_FV,
	OP_MUL_VF,
	OP_DIV_F,
	OP_ADD_F,
	OP_ADD_V,
	OP_SUB_F,
	OP_SUB_V,
	
	OP_EQ_F,
	OP_EQ_V,
	OP_EQ_S,
	OP_EQ_E,
	OP_EQ_FNC,
	
	OP_NE_F,
	OP_NE_V,
	OP_NE_S,
	OP_NE_E,
	OP_NE_FNC,
	
	OP_LE,
	OP_GE,
	OP_LT,
	OP_GT,

	OP_LOAD_F,
	OP_LOAD_V,
	OP_LOAD_S,
	OP_LOAD_ENT,
	OP_LOAD_FLD,
	OP_LOAD_FNC,

	OP_ADDRESS,

	OP_STORE_F,
	OP_STORE_V,
	OP_STORE_S,
	OP_STORE_ENT,
	OP_STORE_FLD,
	OP_STORE_FNC,

	OP_STOREP_F,
	OP_STOREP_V,
	OP_STOREP_S,
	OP_STOREP_ENT,
	OP_STOREP_FLD,
	OP_STOREP_FNC,

	OP_RETURN,
	OP_NOT_F,
	OP_NOT_V,
	OP_NOT_S,
	OP_NOT_ENT,
	OP_NOT_FNC,
	OP_IF,
	OP_IFNOT,
	OP_CALL0,
	OP_CALL1,
	OP_CALL2,
	OP_CALL3,
	OP_CALL4,
	OP_CALL5,
	OP_CALL6,
	OP_CALL7,
	OP_CALL8,
	OP_STATE,
	OP_GOTO,
	OP_AND,
	OP_OR,
	
	OP_BITAND,
	OP_BITOR
};


typedef struct statement_s
{
	unsigned short	op;
	short	a,b,c;
} dstatement_t;

typedef struct
{
	unsigned short	type;		// if DEF_SAVEGLOBGAL bit is set
								// the variable needs to be saved in savegames
	unsigned short	ofs;
	int			s_name;
} ddef_t;
#define	DEF_SAVEGLOBAL	(1<<15)

#define	MAX_PARMS	8

typedef struct
{
	int		first_statement;	// negative numbers are builtins
	int		parm_start;
	int		locals;				// total ints of parms + locals
	
	int		profile;		// runtime
	
	int		s_name;
	int		s_file;			// source file defined in
	
	int		numparms;
	byte	parm_size[MAX_PARMS];
} dfunction_t;


#define	PROG_VERSION	6
typedef struct
{
	int		version;
	int		crc;			// check of header file
	
	int		ofs_statements;
	int		numstatements;	// statement 0 is an error

	int		ofs_globaldefs;
	int		numglobaldefs;
	
	int		ofs_fielddefs;
	int		numfielddefs;
	
	int		ofs_functions;
	int		numfunctions;	// function 0 is an empty
	
	int		ofs_strings;
	int		numstrings;		// first string is a null string

	int		ofs_globals;
	int		numglobals;
	
	int		entityfields;
} dprograms_t;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sbar.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

// the status bar is only redrawn if something has changed, but if anything
// does, the entire thing will be redrawn for the next vid.numpages frames.

#define	SBAR_HEIGHT		24

extern	int			sb_lines;			// scan lines to draw

void Sbar_Init (void);

void Sbar_Changed (void);
// call whenever any of the client stats represented on the sbar changes

void Sbar_Draw (void);
// called every frame by screen

void Sbar_IntermissionOverlay (void);
// called each frame after the level has been completed

void Sbar_FinaleOverlay (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winquake.rc
//
#define IDS_STRING1                     1
#define IDI_ICON2                       1
#define IDD_DIALOG1                     108
#define IDD_PROGRESS                    109
#define IDC_PROGRESS                    1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\server.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// server.h

typedef struct
{
	int			maxclients;
	int			maxclientslimit;
	struct client_s	*clients;		// [maxclients]
	int			serverflags;		// episode completion information
	qboolean	changelevel_issued;	// cleared when at SV_SpawnServer
} server_static_t;

//=============================================================================

typedef enum {ss_loading, ss_active} server_state_t;

typedef struct
{
	qboolean	active;				// false if only a net client

	qboolean	paused;
	qboolean	loadgame;			// handle connections specially

	double		time;
	
	int			lastcheck;			// used by PF_checkclient
	double		lastchecktime;
	
	char		name[64];			// map name
#ifdef QUAKE2
	char		startspot[64];
#endif
	char		modelname[64];		// maps/<name>.bsp, for model_precache[0]
	struct model_s 	*worldmodel;
	char		*model_precache[MAX_MODELS];	// NULL terminated
	struct model_s	*models[MAX_MODELS];
	char		*sound_precache[MAX_SOUNDS];	// NULL terminated
	char		*lightstyles[MAX_LIGHTSTYLES];
	int			num_edicts;
	int			max_edicts;
	edict_t		*edicts;			// can NOT be array indexed, because
									// edict_t is variable sized, but can
									// be used to reference the world ent
	server_state_t	state;			// some actions are only valid during load

	sizebuf_t	datagram;
	byte		datagram_buf[MAX_DATAGRAM];

	sizebuf_t	reliable_datagram;	// copied to all clients at end of frame
	byte		reliable_datagram_buf[MAX_DATAGRAM];

	sizebuf_t	signon;
	byte		signon_buf[8192];
} server_t;


#define	NUM_PING_TIMES		16
#define	NUM_SPAWN_PARMS		16

typedef struct client_s
{
	qboolean		active;				// false = client is free
	qboolean		spawned;			// false = don't send datagrams
	qboolean		dropasap;			// has been told to go to another level
	qboolean		privileged;			// can execute any host command
	qboolean		sendsignon;			// only valid before spawned

	double			last_message;		// reliable messages must be sent
										// periodically

	struct qsocket_s *netconnection;	// communications handle

	usercmd_t		cmd;				// movement
	vec3_t			wishdir;			// intended motion calced from cmd

	sizebuf_t		message;			// can be added to at any time,
										// copied and clear once per frame
	byte			msgbuf[MAX_MSGLEN];
	edict_t			*edict;				// EDICT_NUM(clientnum+1)
	char			name[32];			// for printing to other people
	int				colors;
		
	float			ping_times[NUM_PING_TIMES];
	int				num_pings;			// ping_times[num_pings%NUM_PING_TIMES]

// spawn parms are carried from level to level
	float			spawn_parms[NUM_SPAWN_PARMS];

// client known data for deltas	
	int				old_frags;
} client_t;


//=============================================================================

// edict->movetype values
#define	MOVETYPE_NONE			0		// never moves
#define	MOVETYPE_ANGLENOCLIP	1
#define	MOVETYPE_ANGLECLIP		2
#define	MOVETYPE_WALK			3		// gravity
#define	MOVETYPE_STEP			4		// gravity, special edge handling
#define	MOVETYPE_FLY			5
#define	MOVETYPE_TOSS			6		// gravity
#define	MOVETYPE_PUSH			7		// no clip to world, push and crush
#define	MOVETYPE_NOCLIP			8
#define	MOVETYPE_FLYMISSILE		9		// extra size to monsters
#define	MOVETYPE_BOUNCE			10
#ifdef QUAKE2
#define MOVETYPE_BOUNCEMISSILE	11		// bounce w/o gravity
#define MOVETYPE_FOLLOW			12		// track movement of aiment
#endif

// edict->solid values
#define	SOLID_NOT				0		// no interaction with other objects
#define	SOLID_TRIGGER			1		// touch on edge, but not blocking
#define	SOLID_BBOX				2		// touch on edge, block
#define	SOLID_SLIDEBOX			3		// touch on edge, but not an onground
#define	SOLID_BSP				4		// bsp clip, touch on edge, block

// edict->deadflag values
#define	DEAD_NO					0
#define	DEAD_DYING				1
#define	DEAD_DEAD				2

#define	DAMAGE_NO				0
#define	DAMAGE_YES				1
#define	DAMAGE_AIM				2

// edict->flags
#define	FL_FLY					1
#define	FL_SWIM					2
//#define	FL_GLIMPSE				4
#define	FL_CONVEYOR				4
#define	FL_CLIENT				8
#define	FL_INWATER				16
#define	FL_MONSTER				32
#define	FL_GODMODE				64
#define	FL_NOTARGET				128
#define	FL_ITEM					256
#define	FL_ONGROUND				512
#define	FL_PARTIALGROUND		1024	// not all corners are valid
#define	FL_WATERJUMP			2048	// player jumping out of water
#define	FL_JUMPRELEASED			4096	// for jump debouncing
#ifdef QUAKE2
#define FL_FLASHLIGHT			8192
#define FL_ARCHIVE_OVERRIDE		1048576
#endif

// entity effects

#define	EF_BRIGHTFIELD			1
#define	EF_MUZZLEFLASH 			2
#define	EF_BRIGHTLIGHT 			4
#define	EF_DIMLIGHT 			8
#ifdef QUAKE2
#define EF_DARKLIGHT			16
#define EF_DARKFIELD			32
#define EF_LIGHT				64
#define EF_NODRAW				128
#endif

#define	SPAWNFLAG_NOT_EASY			256
#define	SPAWNFLAG_NOT_MEDIUM		512
#define	SPAWNFLAG_NOT_HARD			1024
#define	SPAWNFLAG_NOT_DEATHMATCH	2048

#ifdef QUAKE2
// server flags
#define	SFL_EPISODE_1		1
#define	SFL_EPISODE_2		2
#define	SFL_EPISODE_3		4
#define	SFL_EPISODE_4		8
#define	SFL_NEW_UNIT		16
#define	SFL_NEW_EPISODE		32
#define	SFL_CROSS_TRIGGERS	65280
#endif

//============================================================================

extern	cvar_t	teamplay;
extern	cvar_t	skill;
extern	cvar_t	deathmatch;
extern	cvar_t	coop;
extern	cvar_t	fraglimit;
extern	cvar_t	timelimit;

extern	server_static_t	svs;				// persistant server info
extern	server_t		sv;					// local server

extern	client_t	*host_client;

extern	jmp_buf 	host_abortserver;

extern	double		host_time;

extern	edict_t		*sv_player;

//===========================================================

void SV_Init (void);

void SV_StartParticle (vec3_t org, vec3_t dir, int color, int count);
void SV_StartSound (edict_t *entity, int channel, char *sample, int volume,
    float attenuation);

void SV_DropClient (qboolean crash);

void SV_SendClientMessages (void);
void SV_ClearDatagram (void);

int SV_ModelIndex (char *name);

void SV_SetIdealPitch (void);

void SV_AddUpdates (void);

void SV_ClientThink (void);
void SV_AddClientToServer (struct qsocket_s	*ret);

void SV_ClientPrintf (char *fmt, ...);
void SV_BroadcastPrintf (char *fmt, ...);

void SV_Physics (void);

qboolean SV_CheckBottom (edict_t *ent);
qboolean SV_movestep (edict_t *ent, vec3_t move, qboolean relink);

void SV_WriteClientdataToMessage (edict_t *ent, sizebuf_t *msg);

void SV_MoveToGoal (void);

void SV_CheckForNewClients (void);
void SV_RunClients (void);
void SV_SaveSpawnparms ();
#ifdef QUAKE2
void SV_SpawnServer (char *server, char *startspot);
#else
void SV_SpawnServer (char *server);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\r_local.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// r_local.h -- private refresh defs

//#include "r_shared.h"

#define ALIAS_BASE_SIZE_RATIO		(1.0 / 11.0)
					// normalizing factor so player model works out to about
					//  1 pixel per triangle

#define BMODEL_FULLY_CLIPPED	0x10 // value returned by R_BmodelCheckBBox ()
									 //  if bbox is trivially rejected

//===========================================================================
// viewmodel lighting

typedef struct {
	int			ambientlight;
	int			shadelight;
	float		*plightvec;
} alight_t;

//===========================================================================
// clipped bmodel edges

typedef struct bedge_s
{
	mvertex_t		*v[2];
	struct bedge_s	*pnext;
} bedge_t;

typedef struct {
	float	fv[3];		// viewspace x, y
} auxvert_t;

//===========================================================================

extern cvar_t	r_draworder;
extern cvar_t	r_speeds;
extern cvar_t	r_timegraph;
extern cvar_t	r_graphheight;
extern cvar_t	r_clearcolor;
extern cvar_t	r_waterwarp;
extern cvar_t	r_fullbright;
extern cvar_t	r_drawentities;
extern cvar_t	r_aliasstats;
extern cvar_t	r_dspeeds;
extern cvar_t	r_drawflat;
extern cvar_t	r_ambient;
extern cvar_t	r_reportsurfout;
extern cvar_t	r_maxsurfs;
extern cvar_t	r_numsurfs;
extern cvar_t	r_reportedgeout;
extern cvar_t	r_maxedges;
extern cvar_t	r_numedges;

#define XCENTERING	(1.0 / 2.0)
#define YCENTERING	(1.0 / 2.0)

#define CLIP_EPSILON		0.001

#define BACKFACE_EPSILON	0.01

//===========================================================================

#define	DIST_NOT_SET	98765

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct clipplane_s
{
	vec3_t		normal;
	float		dist;
	struct		clipplane_s	*next;
	byte		leftedge;
	byte		rightedge;
	byte		reserved[2];
} clipplane_t;

extern	clipplane_t	view_clipplanes[4];

//=============================================================================

void R_RenderWorld (void);

//=============================================================================

extern	mplane_t	screenedge[4];

extern	vec3_t	r_origin;

extern	vec3_t	r_entorigin;

extern	float	screenAspect;
extern	float	verticalFieldOfView;
extern	float	xOrigin, yOrigin;

extern	int		r_visframecount;

//=============================================================================

extern int	vstartscan;


void R_ClearPolyList (void);
void R_DrawPolyList (void);

//
// current entity info
//
extern	qboolean		insubmodel;
extern	vec3_t			r_worldmodelorg;


void R_DrawSprite (void);
void R_RenderFace (msurface_t *fa, int clipflags);
void R_RenderPoly (msurface_t *fa, int clipflags);
void R_RenderBmodelFace (bedge_t *pedges, msurface_t *psurf);
void R_TransformPlane (mplane_t *p, float *normal, float *dist);
void R_TransformFrustum (void);
void R_SetSkyFrame (void);
void R_DrawSurfaceBlock16 (void);
void R_DrawSurfaceBlock8 (void);
texture_t *R_TextureAnimation (texture_t *base);

#if	id386

void R_DrawSurfaceBlock8_mip0 (void);
void R_DrawSurfaceBlock8_mip1 (void);
void R_DrawSurfaceBlock8_mip2 (void);
void R_DrawSurfaceBlock8_mip3 (void);

#endif

void R_GenSkyTile (void *pdest);
void R_GenSkyTile16 (void *pdest);
void R_Surf8Patch (void);
void R_Surf16Patch (void);
void R_DrawSubmodelPolygons (model_t *pmodel, int clipflags);
void R_DrawSolidClippedSubmodelPolygons (model_t *pmodel);

void R_AddPolygonEdges (emitpoint_t *pverts, int numverts, int miplevel);
surf_t *R_GetSurf (void);
void R_AliasDrawModel (alight_t *plighting);
void R_BeginEdgeFrame (void);
void R_ScanEdges (void);
void D_DrawSurfaces (void);
void R_InsertNewEdges (edge_t *edgestoadd, edge_t *edgelist);
void R_StepActiveU (edge_t *pedge);
void R_RemoveEdges (edge_t *pedge);

extern void R_Surf8Start (void);
extern void R_Surf8End (void);
extern void R_Surf16Start (void);
extern void R_Surf16End (void);
extern void R_EdgeCodeStart (void);
extern void R_EdgeCodeEnd (void);

extern void R_RotateBmodel (void);

extern int	c_faceclip;
extern int	r_polycount;
extern int	r_wholepolycount;

extern	model_t		*cl_worldmodel;

extern int		*pfrustum_indexes[4];

// !!! if this is changed, it must be changed in asm_draw.h too !!!
#define	NEAR_CLIP	0.01

extern int			ubasestep, errorterm, erroradjustup, erroradjustdown;
extern int			vstartscan;

extern fixed16_t	sadjust, tadjust;
extern fixed16_t	bbextents, bbextentt;

#define MAXBVERTINDEXES	1000	// new clipped vertices when clipping bmodels
								//  to the world BSP
extern mvertex_t	*r_ptverts, *r_ptvertsmax;

extern vec3_t			sbaseaxis[3], tbaseaxis[3];
extern float			entity_rotation[3][3];

extern int		reinit_surfcache;

extern int		r_currentkey;
extern int		r_currentbkey;

typedef struct btofpoly_s {
	int			clipflags;
	msurface_t	*psurf;
} btofpoly_t;

#define MAX_BTOFPOLYS	5000	// FIXME: tune this

extern int			numbtofpolys;
extern btofpoly_t	*pbtofpolys;

void	R_InitTurb (void);
void	R_ZDrawSubmodelPolys (model_t *clmodel);

//=========================================================
// Alias models
//=========================================================

#define MAXALIASVERTS		2000	// TODO: tune this
#define ALIAS_Z_CLIP_PLANE	5

extern int				numverts;
extern int				a_skinwidth;
extern mtriangle_t		*ptriangles;
extern int				numtriangles;
extern aliashdr_t		*paliashdr;
extern mdl_t			*pmdl;
extern float			leftclip, topclip, rightclip, bottomclip;
extern int				r_acliptype;
extern finalvert_t		*pfinalverts;
extern auxvert_t		*pauxverts;

qboolean R_AliasCheckBBox (void);

//=========================================================
// turbulence stuff

#define	AMP		8*0x10000
#define	AMP2	3
#define	SPEED	20

//=========================================================
// particle stuff

void R_DrawParticles (void);
void R_InitParticles (void);
void R_ClearParticles (void);
void R_ReadPointFile_f (void);
void R_SurfacePatch (void);

extern int		r_amodels_drawn;
extern edge_t	*auxedges;
extern int		r_numallocatededges;
extern edge_t	*r_edges, *edge_p, *edge_max;

extern	edge_t	*newedges[MAXHEIGHT];
extern	edge_t	*removeedges[MAXHEIGHT];

extern	int	screenwidth;

// FIXME: make stack vars when debugging done
extern	edge_t	edge_head;
extern	edge_t	edge_tail;
extern	edge_t	edge_aftertail;
extern int		r_bmodelactive;
extern vrect_t	*pconupdate;

extern float		aliasxscale, aliasyscale, aliasxcenter, aliasycenter;
extern float		r_aliastransition, r_resfudge;

extern int		r_outofsurfaces;
extern int		r_outofedges;

extern mvertex_t	*r_pcurrentvertbase;
extern int			r_maxvalidedgeoffset;

void R_AliasClipTriangle (mtriangle_t *ptri);

extern float	r_time1;
extern float	dp_time1, dp_time2, db_time1, db_time2, rw_time1, rw_time2;
extern float	se_time1, se_time2, de_time1, de_time2, dv_time1, dv_time2;
extern int		r_frustum_indexes[4*6];
extern int		r_maxsurfsseen, r_maxedgesseen, r_cnumsurfs;
extern qboolean	r_surfsonstack;
extern cshift_t	cshift_water;
extern qboolean	r_dowarpold, r_viewchanged;

extern mleaf_t	*r_viewleaf, *r_oldviewleaf;

extern vec3_t	r_emins, r_emaxs;
extern mnode_t	*r_pefragtopnode;
extern int		r_clipflags;
extern int		r_dlightframecount;
extern qboolean	r_fov_greater_than_90;

void R_StoreEfrags (efrag_t **ppefrag);
void R_TimeRefresh_f (void);
void R_TimeGraph (void);
void R_PrintAliasStats (void);
void R_PrintTimes (void);
void R_PrintDSpeeds (void);
void R_AnimateLight (void);
int R_LightPoint (vec3_t p);
void R_SetupFrame (void);
void R_cshift_f (void);
void R_EmitEdge (mvertex_t *pv0, mvertex_t *pv1);
void R_ClipEdge (mvertex_t *pv0, mvertex_t *pv1, clipplane_t *clip);
void R_SplitEntityOnNode2 (mnode_t *node);
void R_MarkLights (dlight_t *light, int bit, mnode_t *node);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sbar.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sbar.c -- status bar code

#include "quakedef.h"


int			sb_updates;		// if >= vid.numpages, no update needed

#define STAT_MINUS		10	// num frame for '-' stats digit
qpic_t		*sb_nums[2][11];
qpic_t		*sb_colon, *sb_slash;
qpic_t		*sb_ibar;
qpic_t		*sb_sbar;
qpic_t		*sb_scorebar;

qpic_t      *sb_weapons[7][8];   // 0 is active, 1 is owned, 2-5 are flashes
qpic_t      *sb_ammo[4];
qpic_t		*sb_sigil[4];
qpic_t		*sb_armor[3];
qpic_t		*sb_items[32];

qpic_t	*sb_faces[7][2];		// 0 is gibbed, 1 is dead, 2-6 are alive
							// 0 is static, 1 is temporary animation
qpic_t	*sb_face_invis;
qpic_t	*sb_face_quad;
qpic_t	*sb_face_invuln;
qpic_t	*sb_face_invis_invuln;

qboolean	sb_showscores;

int			sb_lines;			// scan lines to draw

qpic_t      *rsb_invbar[2];
qpic_t      *rsb_weapons[5];
qpic_t      *rsb_items[2];
qpic_t      *rsb_ammo[3];
qpic_t      *rsb_teambord;		// PGM 01/19/97 - team color border

//MED 01/04/97 added two more weapons + 3 alternates for grenade launcher
qpic_t      *hsb_weapons[7][5];   // 0 is active, 1 is owned, 2-5 are flashes
//MED 01/04/97 added array to simplify weapon parsing
int         hipweapons[4] = {HIT_LASER_CANNON_BIT,HIT_MJOLNIR_BIT,4,HIT_PROXIMITY_GUN_BIT};
//MED 01/04/97 added hipnotic items array
qpic_t      *hsb_items[2];

void Sbar_MiniDeathmatchOverlay (void);
void Sbar_DeathmatchOverlay (void);
void M_DrawPic (int x, int y, qpic_t *pic);

/*
===============
Sbar_ShowScores

Tab key down
===============
*/
void Sbar_ShowScores (void)
{
	if (sb_showscores)
		return;
	sb_showscores = true;
	sb_updates = 0;
}

/*
===============
Sbar_DontShowScores

Tab key up
===============
*/
void Sbar_DontShowScores (void)
{
	sb_showscores = false;
	sb_updates = 0;
}

/*
===============
Sbar_Changed
===============
*/
void Sbar_Changed (void)
{
	sb_updates = 0;	// update next frame
}

/*
===============
Sbar_Init
===============
*/
void Sbar_Init (void)
{
	int		i;

	for (i=0 ; i<10 ; i++)
	{
		sb_nums[0][i] = Draw_PicFromWad (va("num_%i",i));
		sb_nums[1][i] = Draw_PicFromWad (va("anum_%i",i));
	}

	sb_nums[0][10] = Draw_PicFromWad ("num_minus");
	sb_nums[1][10] = Draw_PicFromWad ("anum_minus");

	sb_colon = Draw_PicFromWad ("num_colon");
	sb_slash = Draw_PicFromWad ("num_slash");

	sb_weapons[0][0] = Draw_PicFromWad ("inv_shotgun");
	sb_weapons[0][1] = Draw_PicFromWad ("inv_sshotgun");
	sb_weapons[0][2] = Draw_PicFromWad ("inv_nailgun");
	sb_weapons[0][3] = Draw_PicFromWad ("inv_snailgun");
	sb_weapons[0][4] = Draw_PicFromWad ("inv_rlaunch");
	sb_weapons[0][5] = Draw_PicFromWad ("inv_srlaunch");
	sb_weapons[0][6] = Draw_PicFromWad ("inv_lightng");

	sb_weapons[1][0] = Draw_PicFromWad ("inv2_shotgun");
	sb_weapons[1][1] = Draw_PicFromWad ("inv2_sshotgun");
	sb_weapons[1][2] = Draw_PicFromWad ("inv2_nailgun");
	sb_weapons[1][3] = Draw_PicFromWad ("inv2_snailgun");
	sb_weapons[1][4] = Draw_PicFromWad ("inv2_rlaunch");
	sb_weapons[1][5] = Draw_PicFromWad ("inv2_srlaunch");
	sb_weapons[1][6] = Draw_PicFromWad ("inv2_lightng");

	for (i=0 ; i<5 ; i++)
	{
		sb_weapons[2+i][0] = Draw_PicFromWad (va("inva%i_shotgun",i+1));
		sb_weapons[2+i][1] = Draw_PicFromWad (va("inva%i_sshotgun",i+1));
		sb_weapons[2+i][2] = Draw_PicFromWad (va("inva%i_nailgun",i+1));
		sb_weapons[2+i][3] = Draw_PicFromWad (va("inva%i_snailgun",i+1));
		sb_weapons[2+i][4] = Draw_PicFromWad (va("inva%i_rlaunch",i+1));
		sb_weapons[2+i][5] = Draw_PicFromWad (va("inva%i_srlaunch",i+1));
		sb_weapons[2+i][6] = Draw_PicFromWad (va("inva%i_lightng",i+1));
	}

	sb_ammo[0] = Draw_PicFromWad ("sb_shells");
	sb_ammo[1] = Draw_PicFromWad ("sb_nails");
	sb_ammo[2] = Draw_PicFromWad ("sb_rocket");
	sb_ammo[3] = Draw_PicFromWad ("sb_cells");

	sb_armor[0] = Draw_PicFromWad ("sb_armor1");
	sb_armor[1] = Draw_PicFromWad ("sb_armor2");
	sb_armor[2] = Draw_PicFromWad ("sb_armor3");

	sb_items[0] = Draw_PicFromWad ("sb_key1");
	sb_items[1] = Draw_PicFromWad ("sb_key2");
	sb_items[2] = Draw_PicFromWad ("sb_invis");
	sb_items[3] = Draw_PicFromWad ("sb_invuln");
	sb_items[4] = Draw_PicFromWad ("sb_suit");
	sb_items[5] = Draw_PicFromWad ("sb_quad");

	sb_sigil[0] = Draw_PicFromWad ("sb_sigil1");
	sb_sigil[1] = Draw_PicFromWad ("sb_sigil2");
	sb_sigil[2] = Draw_PicFromWad ("sb_sigil3");
	sb_sigil[3] = Draw_PicFromWad ("sb_sigil4");

	sb_faces[4][0] = Draw_PicFromWad ("face1");
	sb_faces[4][1] = Draw_PicFromWad ("face_p1");
	sb_faces[3][0] = Draw_PicFromWad ("face2");
	sb_faces[3][1] = Draw_PicFromWad ("face_p2");
	sb_faces[2][0] = Draw_PicFromWad ("face3");
	sb_faces[2][1] = Draw_PicFromWad ("face_p3");
	sb_faces[1][0] = Draw_PicFromWad ("face4");
	sb_faces[1][1] = Draw_PicFromWad ("face_p4");
	sb_faces[0][0] = Draw_PicFromWad ("face5");
	sb_faces[0][1] = Draw_PicFromWad ("face_p5");

	sb_face_invis = Draw_PicFromWad ("face_invis");
	sb_face_invuln = Draw_PicFromWad ("face_invul2");
	sb_face_invis_invuln = Draw_PicFromWad ("face_inv2");
	sb_face_quad = Draw_PicFromWad ("face_quad");

	Cmd_AddCommand ("+showscores", Sbar_ShowScores);
	Cmd_AddCommand ("-showscores", Sbar_DontShowScores);

	sb_sbar = Draw_PicFromWad ("sbar");
	sb_ibar = Draw_PicFromWad ("ibar");
	sb_scorebar = Draw_PicFromWad ("scorebar");

//MED 01/04/97 added new hipnotic weapons
	if (hipnotic)
	{
	  hsb_weapons[0][0] = Draw_PicFromWad ("inv_laser");
	  hsb_weapons[0][1] = Draw_PicFromWad ("inv_mjolnir");
	  hsb_weapons[0][2] = Draw_PicFromWad ("inv_gren_prox");
	  hsb_weapons[0][3] = Draw_PicFromWad ("inv_prox_gren");
	  hsb_weapons[0][4] = Draw_PicFromWad ("inv_prox");

	  hsb_weapons[1][0] = Draw_PicFromWad ("inv2_laser");
	  hsb_weapons[1][1] = Draw_PicFromWad ("inv2_mjolnir");
	  hsb_weapons[1][2] = Draw_PicFromWad ("inv2_gren_prox");
	  hsb_weapons[1][3] = Draw_PicFromWad ("inv2_prox_gren");
	  hsb_weapons[1][4] = Draw_PicFromWad ("inv2_prox");

	  for (i=0 ; i<5 ; i++)
	  {
		 hsb_weapons[2+i][0] = Draw_PicFromWad (va("inva%i_laser",i+1));
		 hsb_weapons[2+i][1] = Draw_PicFromWad (va("inva%i_mjolnir",i+1));
		 hsb_weapons[2+i][2] = Draw_PicFromWad (va("inva%i_gren_prox",i+1));
		 hsb_weapons[2+i][3] = Draw_PicFromWad (va("inva%i_prox_gren",i+1));
		 hsb_weapons[2+i][4] = Draw_PicFromWad (va("inva%i_prox",i+1));
	  }

	  hsb_items[0] = Draw_PicFromWad ("sb_wsuit");
	  hsb_items[1] = Draw_PicFromWad ("sb_eshld");
	}

	if (rogue)
	{
		rsb_invbar[0] = Draw_PicFromWad ("r_invbar1");
		rsb_invbar[1] = Draw_PicFromWad ("r_invbar2");

		rsb_weapons[0] = Draw_PicFromWad ("r_lava");
		rsb_weapons[1] = Draw_PicFromWad ("r_superlava");
		rsb_weapons[2] = Draw_PicFromWad ("r_gren");
		rsb_weapons[3] = Draw_PicFromWad ("r_multirock");
		rsb_weapons[4] = Draw_PicFromWad ("r_plasma");

		rsb_items[0] = Draw_PicFromWad ("r_shield1");
        rsb_items[1] = Draw_PicFromWad ("r_agrav1");

// PGM 01/19/97 - team color border
        rsb_teambord = Draw_PicFromWad ("r_teambord");
// PGM 01/19/97 - team color border

		rsb_ammo[0] = Draw_PicFromWad ("r_ammolava");
		rsb_ammo[1] = Draw_PicFromWad ("r_ammomulti");
		rsb_ammo[2] = Draw_PicFromWad ("r_ammoplasma");
	}
}


//=============================================================================

// drawing routines are relative to the status bar location

/*
=============
Sbar_DrawPic
=============
*/
void Sbar_DrawPic (int x, int y, qpic_t *pic)
{
	if (cl.gametype == GAME_DEATHMATCH)
		Draw_Pic (x /* + ((vid.width - 320)>>1)*/, y + (vid.height-SBAR_HEIGHT), pic);
	else
		Draw_Pic (x + ((vid.width - 320)>>1), y + (vid.height-SBAR_HEIGHT), pic);
}

/*
=============
Sbar_DrawTransPic
=============
*/
void Sbar_DrawTransPic (int x, int y, qpic_t *pic)
{
	if (cl.gametype == GAME_DEATHMATCH)
		Draw_TransPic (x /*+ ((vid.width - 320)>>1)*/, y + (vid.height-SBAR_HEIGHT), pic);
	else
		Draw_TransPic (x + ((vid.width - 320)>>1), y + (vid.height-SBAR_HEIGHT), pic);
}

/*
================
Sbar_DrawCharacter

Draws one solid graphics character
================
*/
void Sbar_DrawCharacter (int x, int y, int num)
{
	if (cl.gametype == GAME_DEATHMATCH)
		Draw_Character ( x /*+ ((vid.width - 320)>>1) */ + 4 , y + vid.height-SBAR_HEIGHT, num);
	else
		Draw_Character ( x + ((vid.width - 320)>>1) + 4 , y + vid.height-SBAR_HEIGHT, num);
}

/*
================
Sbar_DrawString
================
*/
void Sbar_DrawString (int x, int y, char *str)
{
	if (cl.gametype == GAME_DEATHMATCH)
		Draw_String (x /*+ ((vid.width - 320)>>1)*/, y+ vid.height-SBAR_HEIGHT, str);
	else
		Draw_String (x + ((vid.width - 320)>>1), y+ vid.height-SBAR_HEIGHT, str);
}

/*
=============
Sbar_itoa
=============
*/
int Sbar_itoa (int num, char *buf)
{
	char	*str;
	int		pow10;
	int		dig;

	str = buf;

	if (num < 0)
	{
		*str++ = '-';
		num = -num;
	}

	for (pow10 = 10 ; num >= pow10 ; pow10 *= 10)
	;

	do
	{
		pow10 /= 10;
		dig = num/pow10;
		*str++ = '0'+dig;
		num -= dig*pow10;
	} while (pow10 != 1);

	*str = 0;

	return str-buf;
}


/*
=============
Sbar_DrawNum
=============
*/
void Sbar_DrawNum (int x, int y, int num, int digits, int color)
{
	char			str[12];
	char			*ptr;
	int				l, frame;

	l = Sbar_itoa (num, str);
	ptr = str;
	if (l > digits)
		ptr += (l-digits);
	if (l < digits)
		x += (digits-l)*24;

	while (*ptr)
	{
		if (*ptr == '-')
			frame = STAT_MINUS;
		else
			frame = *ptr -'0';

		Sbar_DrawTransPic (x,y,sb_nums[color][frame]);
		x += 24;
		ptr++;
	}
}

//=============================================================================

int		fragsort[MAX_SCOREBOARD];

char	scoreboardtext[MAX_SCOREBOARD][20];
int		scoreboardtop[MAX_SCOREBOARD];
int		scoreboardbottom[MAX_SCOREBOARD];
int		scoreboardcount[MAX_SCOREBOARD];
int		scoreboardlines;

/*
===============
Sbar_SortFrags
===============
*/
void Sbar_SortFrags (void)
{
	int		i, j, k;

// sort by frags
	scoreboardlines = 0;
	for (i=0 ; i<cl.maxclients ; i++)
	{
		if (cl.scores[i].name[0])
		{
			fragsort[scoreboardlines] = i;
			scoreboardlines++;
		}
	}

	for (i=0 ; i<scoreboardlines ; i++)
		for (j=0 ; j<scoreboardlines-1-i ; j++)
			if (cl.scores[fragsort[j]].frags < cl.scores[fragsort[j+1]].frags)
			{
				k = fragsort[j];
				fragsort[j] = fragsort[j+1];
				fragsort[j+1] = k;
			}
}

int	Sbar_ColorForMap (int m)
{
	return m < 128 ? m + 8 : m + 8;
}

/*
===============
Sbar_UpdateScoreboard
===============
*/
void Sbar_UpdateScoreboard (void)
{
	int		i, k;
	int		top, bottom;
	scoreboard_t	*s;

	Sbar_SortFrags ();

// draw the text
	memset (scoreboardtext, 0, sizeof(scoreboardtext));

	for (i=0 ; i<scoreboardlines; i++)
	{
		k = fragsort[i];
		s = &cl.scores[k];
		sprintf (&scoreboardtext[i][1], "%3i %s", s->frags, s->name);

		top = s->colors & 0xf0;
		bottom = (s->colors & 15) <<4;
		scoreboardtop[i] = Sbar_ColorForMap (top);
		scoreboardbottom[i] = Sbar_ColorForMap (bottom);
	}
}



/*
===============
Sbar_SoloScoreboard
===============
*/
void Sbar_SoloScoreboard (void)
{
	char	str[80];
	int		minutes, seconds, tens, units;
	int		l;

	sprintf (str,"Monsters:%3i /%3i", cl.stats[STAT_MONSTERS], cl.stats[STAT_TOTALMONSTERS]);
	Sbar_DrawString (8, 4, str);

	sprintf (str,"Secrets :%3i /%3i", cl.stats[STAT_SECRETS], cl.stats[STAT_TOTALSECRETS]);
	Sbar_DrawString (8, 12, str);

// time
	minutes = cl.time / 60;
	seconds = cl.time - 60*minutes;
	tens = seconds / 10;
	units = seconds - 10*tens;
	sprintf (str,"Time :%3i:%i%i", minutes, tens, units);
	Sbar_DrawString (184, 4, str);

// draw level name
	l = strlen (cl.levelname);
	Sbar_DrawString (232 - l*4, 12, cl.levelname);
}

/*
===============
Sbar_DrawScoreboard
===============
*/
void Sbar_DrawScoreboard (void)
{
	Sbar_SoloScoreboard ();
	if (cl.gametype == GAME_DEATHMATCH)
		Sbar_DeathmatchOverlay ();
#if 0
	int		i, j, c;
	int		x, y;
	int		l;
	int		top, bottom;
	scoreboard_t	*s;

	if (cl.gametype != GAME_DEATHMATCH)
	{
		Sbar_SoloScoreboard ();
		return;
	}

	Sbar_UpdateScoreboard ();

	l = scoreboardlines <= 6 ? scoreboardlines : 6;

	for (i=0 ; i<l ; i++)
	{
		x = 20*(i&1);
		y = i/2 * 8;

		s = &cl.scores[fragsort[i]];
		if (!s->name[0])
			continue;

	// draw background
		top = s->colors & 0xf0;
		bottom = (s->colors & 15)<<4;
		top = Sbar_ColorForMap (top);
		bottom = Sbar_ColorForMap (bottom);

		Draw_Fill ( x*8+10 + ((vid.width - 320)>>1), y + vid.height - SBAR_HEIGHT, 28, 4, top);
		Draw_Fill ( x*8+10 + ((vid.width - 320)>>1), y+4 + vid.height - SBAR_HEIGHT, 28, 4, bottom);

	// draw text
		for (j=0 ; j<20 ; j++)
		{
			c = scoreboardtext[i][j];
			if (c == 0 || c == ' ')
				continue;
			Sbar_DrawCharacter ( (x+j)*8, y, c);
		}
	}
#endif
}

//=============================================================================

/*
===============
Sbar_DrawInventory
===============
*/
void Sbar_DrawInventory (void)
{
	int		i;
	char	num[6];
	float	time;
	int		flashon;

	if (rogue)
	{
		if ( cl.stats[STAT_ACTIVEWEAPON] >= RIT_LAVA_NAILGUN )
			Sbar_DrawPic (0, -24, rsb_invbar[0]);
		else
			Sbar_DrawPic (0, -24, rsb_invbar[1]);
	}
	else
	{
		Sbar_DrawPic (0, -24, sb_ibar);
	}

// weapons
	for (i=0 ; i<7 ; i++)
	{
		if (cl.items & (IT_SHOTGUN<<i) )
		{
			time = cl.item_gettime[i];
			flashon = (int)((cl.time - time)*10);
			if (flashon >= 10)
			{
				if ( cl.stats[STAT_ACTIVEWEAPON] == (IT_SHOTGUN<<i)  )
					flashon = 1;
				else
					flashon = 0;
			}
			else
				flashon = (flashon%5) + 2;

         Sbar_DrawPic (i*24, -16, sb_weapons[flashon][i]);

			if (flashon > 1)
				sb_updates = 0;		// force update to remove flash
		}
	}

// MED 01/04/97
// hipnotic weapons
    if (hipnotic)
    {
      int grenadeflashing=0;
      for (i=0 ; i<4 ; i++)
      {
         if (cl.items & (1<<hipweapons[i]) )
         {
            time = cl.item_gettime[hipweapons[i]];
            flashon = (int)((cl.time - time)*10);
            if (flashon >= 10)
            {
               if ( cl.stats[STAT_ACTIVEWEAPON] == (1<<hipweapons[i])  )
                  flashon = 1;
               else
                  flashon = 0;
            }
            else
               flashon = (flashon%5) + 2;

            // check grenade launcher
            if (i==2)
            {
               if (cl.items & HIT_PROXIMITY_GUN)
               {
                  if (flashon)
                  {
                     grenadeflashing = 1;
                     Sbar_DrawPic (96, -16, hsb_weapons[flashon][2]);
                  }
               }
            }
            else if (i==3)
            {
               if (cl.items & (IT_SHOTGUN<<4))
               {
                  if (flashon && !grenadeflashing)
                  {
                     Sbar_DrawPic (96, -16, hsb_weapons[flashon][3]);
                  }
                  else if (!grenadeflashing)
                  {
                     Sbar_DrawPic (96, -16, hsb_weapons[0][3]);
                  }
               }
               else
                  Sbar_DrawPic (96, -16, hsb_weapons[flashon][4]);
            }
            else
               Sbar_DrawPic (176 + (i*24), -16, hsb_weapons[flashon][i]);
            if (flashon > 1)
               sb_updates = 0;      // force update to remove flash
         }
      }
    }

	if (rogue)
	{
    // check for powered up weapon.
		if ( cl.stats[STAT_ACTIVEWEAPON] >= RIT_LAVA_NAILGUN )
		{
			for (i=0;i<5;i++)
			{
				if (cl.stats[STAT_ACTIVEWEAPON] == (RIT_LAVA_NAILGUN << i))
				{
					Sbar_DrawPic ((i+2)*24, -16, rsb_weapons[i]);
				}
			}
		}
	}

// ammo counts
	for (i=0 ; i<4 ; i++)
	{
		sprintf (num, "%3i",cl.stats[STAT_SHELLS+i] );
		if (num[0] != ' ')
			Sbar_DrawCharacter ( (6*i+1)*8 - 2, -24, 18 + num[0] - '0');
		if (num[1] != ' ')
			Sbar_DrawCharacter ( (6*i+2)*8 - 2, -24, 18 + num[1] - '0');
		if (num[2] != ' ')
			Sbar_DrawCharacter ( (6*i+3)*8 - 2, -24, 18 + num[2] - '0');
	}

	flashon = 0;
   // items
   for (i=0 ; i<6 ; i++)
      if (cl.items & (1<<(17+i)))
      {
         time = cl.item_gettime[17+i];
         if (time && time > cl.time - 2 && flashon )
         {  // flash frame
            sb_updates = 0;
         }
         else
         {
         //MED 01/04/97 changed keys
            if (!hipnotic || (i>1))
            {
               Sbar_DrawPic (192 + i*16, -16, sb_items[i]);
            }
         }
         if (time && time > cl.time - 2)
            sb_updates = 0;
      }
   //MED 01/04/97 added hipnotic items
   // hipnotic items
   if (hipnotic)
   {
      for (i=0 ; i<2 ; i++)
         if (cl.items & (1<<(24+i)))
         {
            time = cl.item_gettime[24+i];
            if (time && time > cl.time - 2 && flashon )
            {  // flash frame
               sb_updates = 0;
            }
            else
            {
               Sbar_DrawPic (288 + i*16, -16, hsb_items[i]);
            }
            if (time && time > cl.time - 2)
               sb_updates = 0;
         }
   }

	if (rogue)
	{
	// new rogue items
		for (i=0 ; i<2 ; i++)
		{
			if (cl.items & (1<<(29+i)))
			{
				time = cl.item_gettime[29+i];

				if (time &&	time > cl.time - 2 && flashon )
				{	// flash frame
					sb_updates = 0;
				}
				else
				{
					Sbar_DrawPic (288 + i*16, -16, rsb_items[i]);
				}

				if (time &&	time > cl.time - 2)
					sb_updates = 0;
			}
		}
	}
	else
	{
	// sigils
		for (i=0 ; i<4 ; i++)
		{
			if (cl.items & (1<<(28+i)))
			{
				time = cl.item_gettime[28+i];
				if (time &&	time > cl.time - 2 && flashon )
				{	// flash frame
					sb_updates = 0;
				}
				else
					Sbar_DrawPic (320-32 + i*8, -16, sb_sigil[i]);
				if (time &&	time > cl.time - 2)
					sb_updates = 0;
			}
		}
	}
}

//=============================================================================

/*
===============
Sbar_DrawFrags
===============
*/
void Sbar_DrawFrags (void)
{
	int				i, k, l;
	int				top, bottom;
	int				x, y, f;
	int				xofs;
	char			num[12];
	scoreboard_t	*s;

	Sbar_SortFrags ();

// draw the text
	l = scoreboardlines <= 4 ? scoreboardlines : 4;

	x = 23;
	if (cl.gametype == GAME_DEATHMATCH)
		xofs = 0;
	else
		xofs = (vid.width - 320)>>1;
	y = vid.height - SBAR_HEIGHT - 23;

	for (i=0 ; i<l ; i++)
	{
		k = fragsort[i];
		s = &cl.scores[k];
		if (!s->name[0])
			continue;

	// draw background
		top = s->colors & 0xf0;
		bottom = (s->colors & 15)<<4;
		top = Sbar_ColorForMap (top);
		bottom = Sbar_ColorForMap (bottom);

		Draw_Fill (xofs + x*8 + 10, y, 28, 4, top);
		Draw_Fill (xofs + x*8 + 10, y+4, 28, 3, bottom);

	// draw number
		f = s->frags;
		sprintf (num, "%3i",f);

		Sbar_DrawCharacter ( (x+1)*8 , -24, num[0]);
		Sbar_DrawCharacter ( (x+2)*8 , -24, num[1]);
		Sbar_DrawCharacter ( (x+3)*8 , -24, num[2]);

		if (k == cl.viewentity - 1)
		{
			Sbar_DrawCharacter (x*8+2, -24, 16);
			Sbar_DrawCharacter ( (x+4)*8-4, -24, 17);
		}
		x+=4;
	}
}

//=============================================================================


/*
===============
Sbar_DrawFace
===============
*/
void Sbar_DrawFace (void)
{
	int		f, anim;

// PGM 01/19/97 - team color drawing
// PGM 03/02/97 - fixed so color swatch only appears in CTF modes
	if (rogue &&
        (cl.maxclients != 1) &&
        (teamplay.value>3) &&
        (teamplay.value<7))
	{
		int				top, bottom;
		int				xofs;
		char			num[12];
		scoreboard_t	*s;
		
		s = &cl.scores[cl.viewentity - 1];
		// draw background
		top = s->colors & 0xf0;
		bottom = (s->colors & 15)<<4;
		top = Sbar_ColorForMap (top);
		bottom = Sbar_ColorForMap (bottom);

		if (cl.gametype == GAME_DEATHMATCH)
			xofs = 113;
		else
			xofs = ((vid.width - 320)>>1) + 113;

		Sbar_DrawPic (112, 0, rsb_teambord);
		Draw_Fill (xofs, vid.height-SBAR_HEIGHT+3, 22, 9, top);
		Draw_Fill (xofs, vid.height-SBAR_HEIGHT+12, 22, 9, bottom);

		// draw number
		f = s->frags;
		sprintf (num, "%3i",f);

		if (top==8)
		{
			if (num[0] != ' ')
				Sbar_DrawCharacter(109, 3, 18 + num[0] - '0');
			if (num[1] != ' ')
				Sbar_DrawCharacter(116, 3, 18 + num[1] - '0');
			if (num[2] != ' ')
				Sbar_DrawCharacter(123, 3, 18 + num[2] - '0');
		}
		else
		{
			Sbar_DrawCharacter ( 109, 3, num[0]);
			Sbar_DrawCharacter ( 116, 3, num[1]);
			Sbar_DrawCharacter ( 123, 3, num[2]);
		}
		
		return;
	}
// PGM 01/19/97 - team color drawing

	if ( (cl.items & (IT_INVISIBILITY | IT_INVULNERABILITY) )
	== (IT_INVISIBILITY | IT_INVULNERABILITY) )
	{
		Sbar_DrawPic (112, 0, sb_face_invis_invuln);
		return;
	}
	if (cl.items & IT_QUAD)
	{
		Sbar_DrawPic (112, 0, sb_face_quad );
		return;
	}
	if (cl.items & IT_INVISIBILITY)
	{
		Sbar_DrawPic (112, 0, sb_face_invis );
		return;
	}
	if (cl.items & IT_INVULNERABILITY)
	{
		Sbar_DrawPic (112, 0, sb_face_invuln);
		return;
	}

	if (cl.stats[STAT_HEALTH] >= 100)
		f = 4;
	else
		f = cl.stats[STAT_HEALTH] / 20;

	if (cl.time <= cl.faceanimtime)
	{
		anim = 1;
		sb_updates = 0;		// make sure the anim gets drawn over
	}
	else
		anim = 0;
	Sbar_DrawPic (112, 0, sb_faces[f][anim]);
}

// Begin D3DQuake
int gNoStatusBar;
// End D3DQuake

/*
===============
Sbar_Draw
===============
*/

void Sbar_Draw (void)
{
// Begin D3DQuake
	if ( gNoStatusBar ) return;
// End D3DQuake
	if (scr_con_current == vid.height)
		return;		// console is full screen

	if (sb_updates >= vid.numpages)
		return;

	scr_copyeverything = 1;

	sb_updates++;

	if (sb_lines && vid.width > 320) 
		Draw_TileClear (0, vid.height - sb_lines, vid.width, sb_lines);

	if (sb_lines > 24)
	{
		Sbar_DrawInventory ();
		if (cl.maxclients != 1)
			Sbar_DrawFrags ();
	}

	if (sb_showscores || cl.stats[STAT_HEALTH] <= 0)
	{
		Sbar_DrawPic (0, 0, sb_scorebar);
		Sbar_DrawScoreboard ();
		sb_updates = 0;
	}
	else if (sb_lines)
	{
		Sbar_DrawPic (0, 0, sb_sbar);

   // keys (hipnotic only)
      //MED 01/04/97 moved keys here so they would not be overwritten
      if (hipnotic)
      {
         if (cl.items & IT_KEY1)
            Sbar_DrawPic (209, 3, sb_items[0]);
         if (cl.items & IT_KEY2)
            Sbar_DrawPic (209, 12, sb_items[1]);
      }
   // armor
		if (cl.items & IT_INVULNERABILITY)
		{
			Sbar_DrawNum (24, 0, 666, 3, 1);
			Sbar_DrawPic (0, 0, draw_disc);
		}
		else
		{
			if (rogue)
			{
				Sbar_DrawNum (24, 0, cl.stats[STAT_ARMOR], 3,
								cl.stats[STAT_ARMOR] <= 25);
				if (cl.items & RIT_ARMOR3)
					Sbar_DrawPic (0, 0, sb_armor[2]);
				else if (cl.items & RIT_ARMOR2)
					Sbar_DrawPic (0, 0, sb_armor[1]);
				else if (cl.items & RIT_ARMOR1)
					Sbar_DrawPic (0, 0, sb_armor[0]);
			}
			else
			{
				Sbar_DrawNum (24, 0, cl.stats[STAT_ARMOR], 3
				, cl.stats[STAT_ARMOR] <= 25);
				if (cl.items & IT_ARMOR3)
					Sbar_DrawPic (0, 0, sb_armor[2]);
				else if (cl.items & IT_ARMOR2)
					Sbar_DrawPic (0, 0, sb_armor[1]);
				else if (cl.items & IT_ARMOR1)
					Sbar_DrawPic (0, 0, sb_armor[0]);
			}
		}

	// face
		Sbar_DrawFace ();

	// health
		Sbar_DrawNum (136, 0, cl.stats[STAT_HEALTH], 3
		, cl.stats[STAT_HEALTH] <= 25);

	// ammo icon
		if (rogue)
		{
			if (cl.items & RIT_SHELLS)
				Sbar_DrawPic (224, 0, sb_ammo[0]);
			else if (cl.items & RIT_NAILS)
				Sbar_DrawPic (224, 0, sb_ammo[1]);
			else if (cl.items & RIT_ROCKETS)
				Sbar_DrawPic (224, 0, sb_ammo[2]);
			else if (cl.items & RIT_CELLS)
				Sbar_DrawPic (224, 0, sb_ammo[3]);
			else if (cl.items & RIT_LAVA_NAILS)
				Sbar_DrawPic (224, 0, rsb_ammo[0]);
			else if (cl.items & RIT_PLASMA_AMMO)
				Sbar_DrawPic (224, 0, rsb_ammo[1]);
			else if (cl.items & RIT_MULTI_ROCKETS)
				Sbar_DrawPic (224, 0, rsb_ammo[2]);
		}
		else
		{
			if (cl.items & IT_SHELLS)
				Sbar_DrawPic (224, 0, sb_ammo[0]);
			else if (cl.items & IT_NAILS)
				Sbar_DrawPic (224, 0, sb_ammo[1]);
			else if (cl.items & IT_ROCKETS)
				Sbar_DrawPic (224, 0, sb_ammo[2]);
			else if (cl.items & IT_CELLS)
				Sbar_DrawPic (224, 0, sb_ammo[3]);
		}

		Sbar_DrawNum (248, 0, cl.stats[STAT_AMMO], 3,
					  cl.stats[STAT_AMMO] <= 10);
	}

	if (vid.width > 320) {
		if (cl.gametype == GAME_DEATHMATCH)
			Sbar_MiniDeathmatchOverlay ();
	}
}

//=============================================================================

/*
==================
Sbar_IntermissionNumber

==================
*/
void Sbar_IntermissionNumber (int x, int y, int num, int digits, int color)
{
	char			str[12];
	char			*ptr;
	int				l, frame;

	l = Sbar_itoa (num, str);
	ptr = str;
	if (l > digits)
		ptr += (l-digits);
	if (l < digits)
		x += (digits-l)*24;

	while (*ptr)
	{
		if (*ptr == '-')
			frame = STAT_MINUS;
		else
			frame = *ptr -'0';

		Draw_TransPic (x,y,sb_nums[color][frame]);
		x += 24;
		ptr++;
	}
}

/*
==================
Sbar_DeathmatchOverlay

==================
*/
void Sbar_DeathmatchOverlay (void)
{
	qpic_t			*pic;
	int				i, k, l;
	int				top, bottom;
	int				x, y, f;
	char			num[12];
	scoreboard_t	*s;

	scr_copyeverything = 1;
	scr_fullupdate = 0;

	pic = Draw_CachePic ("gfx/ranking.lmp");
	M_DrawPic ((320-pic->width)/2, 8, pic);

// scores
	Sbar_SortFrags ();

// draw the text
	l = scoreboardlines;

	x = 80 + ((vid.width - 320)>>1);
	y = 40;
	for (i=0 ; i<l ; i++)
	{
		k = fragsort[i];
		s = &cl.scores[k];
		if (!s->name[0])
			continue;

	// draw background
		top = s->colors & 0xf0;
		bottom = (s->colors & 15)<<4;
		top = Sbar_ColorForMap (top);
		bottom = Sbar_ColorForMap (bottom);

		Draw_Fill ( x, y, 40, 4, top);
		Draw_Fill ( x, y+4, 40, 4, bottom);

	// draw number
		f = s->frags;
		sprintf (num, "%3i",f);

		Draw_Character ( x+8 , y, num[0]);
		Draw_Character ( x+16 , y, num[1]);
		Draw_Character ( x+24 , y, num[2]);

		if (k == cl.viewentity - 1)
			Draw_Character ( x - 8, y, 12);

#if 0
{
	int				total;
	int				n, minutes, tens, units;

	// draw time
		total = cl.completed_time - s->entertime;
		minutes = (int)total/60;
		n = total - minutes*60;
		tens = n/10;
		units = n%10;

		sprintf (num, "%3i:%i%i", minutes, tens, units);

		Draw_String ( x+48 , y, num);
}
#endif

	// draw name
		Draw_String (x+64, y, s->name);

		y += 10;
	}
}

/*
==================
Sbar_DeathmatchOverlay

==================
*/
void Sbar_MiniDeathmatchOverlay (void)
{
	qpic_t			*pic;
	int				i, k, l;
	int				top, bottom;
	int				x, y, f;
	char			num[12];
	scoreboard_t	*s;
	int				numlines;

	if (vid.width < 512 || !sb_lines)
		return;

	scr_copyeverything = 1;
	scr_fullupdate = 0;

// scores
	Sbar_SortFrags ();

// draw the text
	l = scoreboardlines;
	y = vid.height - sb_lines;
	numlines = sb_lines/8;
	if (numlines < 3)
		return;

	//find us
	for (i = 0; i < scoreboardlines; i++)
		if (fragsort[i] == cl.viewentity - 1)
			break;

    if (i == scoreboardlines) // we're not there
            i = 0;
    else // figure out start
            i = i - numlines/2;

    if (i > scoreboardlines - numlines)
            i = scoreboardlines - numlines;
    if (i < 0)
            i = 0;

	x = 324;
	for (/* */; i < scoreboardlines && y < vid.height - 8 ; i++)
	{
		k = fragsort[i];
		s = &cl.scores[k];
		if (!s->name[0])
			continue;

	// draw background
		top = s->colors & 0xf0;
		bottom = (s->colors & 15)<<4;
		top = Sbar_ColorForMap (top);
		bottom = Sbar_ColorForMap (bottom);

		Draw_Fill ( x, y+1, 40, 3, top);
		Draw_Fill ( x, y+4, 40, 4, bottom);

	// draw number
		f = s->frags;
		sprintf (num, "%3i",f);

		Draw_Character ( x+8 , y, num[0]);
		Draw_Character ( x+16 , y, num[1]);
		Draw_Character ( x+24 , y, num[2]);

		if (k == cl.viewentity - 1) {
			Draw_Character ( x, y, 16);
			Draw_Character ( x + 32, y, 17);
		}

#if 0
{
	int				total;
	int				n, minutes, tens, units;

	// draw time
		total = cl.completed_time - s->entertime;
		minutes = (int)total/60;
		n = total - minutes*60;
		tens = n/10;
		units = n%10;

		sprintf (num, "%3i:%i%i", minutes, tens, units);

		Draw_String ( x+48 , y, num);
}
#endif

	// draw name
		Draw_String (x+48, y, s->name);

		y += 8;
	}
}

/*
==================
Sbar_IntermissionOverlay

==================
*/
void Sbar_IntermissionOverlay (void)
{
	qpic_t	*pic;
	int		dig;
	int		num;

	scr_copyeverything = 1;
	scr_fullupdate = 0;

	if (cl.gametype == GAME_DEATHMATCH)
	{
		Sbar_DeathmatchOverlay ();
		return;
	}

	pic = Draw_CachePic ("gfx/complete.lmp");
	Draw_Pic (64, 24, pic);

	pic = Draw_CachePic ("gfx/inter.lmp");
	Draw_TransPic (0, 56, pic);

// time
	dig = cl.completed_time/60;
	Sbar_IntermissionNumber (160, 64, dig, 3, 0);
	num = cl.completed_time - dig*60;
	Draw_TransPic (234,64,sb_colon);
	Draw_TransPic (246,64,sb_nums[0][num/10]);
	Draw_TransPic (266,64,sb_nums[0][num%10]);

	Sbar_IntermissionNumber (160, 104, cl.stats[STAT_SECRETS], 3, 0);
	Draw_TransPic (232,104,sb_slash);
	Sbar_IntermissionNumber (240, 104, cl.stats[STAT_TOTALSECRETS], 3, 0);

	Sbar_IntermissionNumber (160, 144, cl.stats[STAT_MONSTERS], 3, 0);
	Draw_TransPic (232,144,sb_slash);
	Sbar_IntermissionNumber (240, 144, cl.stats[STAT_TOTALMONSTERS], 3, 0);

}


/*
==================
Sbar_FinaleOverlay

==================
*/
void Sbar_FinaleOverlay (void)
{
	qpic_t	*pic;

	scr_copyeverything = 1;

	pic = Draw_CachePic ("gfx/finale.lmp");
	Draw_TransPic ( (vid.width-pic->width)/2, 16, pic);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\snd_dma.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// snd_dma.c -- main control for any streaming sound output device

#include "quakedef.h"
#include "xquake.h"

void S_Play(void);
void S_PlayVol(void);
void S_SoundList(void);
void S_Update_();
void S_StopAllSounds(qboolean clear);
void S_StopAllSoundsC(void);

// =======================================================================
// Internal sound data & structures
// =======================================================================

channel_t   channels[MAX_CHANNELS];
int			total_channels;

int				snd_blocked = 0;
static qboolean	snd_ambient = 1;
qboolean		snd_initialized = false;

// pointer should go away
volatile dma_t  *shm = 0;
volatile dma_t sn;

vec3_t		listener_origin;
vec3_t		listener_forward;
vec3_t		listener_right;
vec3_t		listener_up;
vec_t		sound_nominal_clip_dist=1000.0;

int			soundtime;		// sample PAIRS
int   		paintedtime; 	// sample PAIRS


#define	MAX_SFX		512
sfx_t		*known_sfx;		// hunk allocated [MAX_SFX]
int			num_sfx;

sfx_t		*ambient_sfx[NUM_AMBIENTS];

int 		desired_speed = 11025;
int 		desired_bits = 16;

int sound_started=0;

cvar_t bgmvolume = {"bgmvolume", "1", true};
cvar_t volume = {"volume", "0.7", true};

cvar_t nosound = {"nosound", "0"};
cvar_t precache = {"precache", "1"};
cvar_t loadas8bit = {"loadas8bit", "0"};
cvar_t bgmbuffer = {"bgmbuffer", "4096"};
cvar_t ambient_level = {"ambient_level", "0.3"};
cvar_t ambient_fade = {"ambient_fade", "100"};
cvar_t snd_noextraupdate = {"snd_noextraupdate", "0"};
cvar_t snd_show = {"snd_show", "0"};
cvar_t _snd_mixahead = {"_snd_mixahead", "0.1", true};


// ====================================================================
// User-setable variables
// ====================================================================


//
// Fake dma is a synchronous faking of the DMA progress used for
// isolating performance in the renderer.  The fakedma_updates is
// number of times S_Update() is called per second.
//

qboolean fakedma = false;
int fakedma_updates = 15;


void S_AmbientOff (void)
{
	snd_ambient = false;
}


void S_AmbientOn (void)
{
	snd_ambient = true;
}


void S_SoundInfo_f(void)
{
	if (!sound_started || !shm)
	{
		Con_Printf ("sound system not started\n");
		return;
	}
	
    Con_Printf("%5d stereo\n", shm->channels - 1);
    Con_Printf("%5d samples\n", shm->samples);
    Con_Printf("%5d samplepos\n", shm->samplepos);
    Con_Printf("%5d samplebits\n", shm->samplebits);
    Con_Printf("%5d submission_chunk\n", shm->submission_chunk);
    Con_Printf("%5d speed\n", shm->speed);
    Con_Printf("0x%x dma buffer\n", shm->buffer);
	Con_Printf("%5d total_channels\n", total_channels);
}


/*
================
S_Startup
================
*/

void S_Startup (void)
{
	int		rc;

	if (!snd_initialized)
		return;

	if (!fakedma)
	{
		rc = SNDDMA_Init();

		if (!rc)
		{
#ifndef	_WIN32
			Con_Printf("S_Startup: SNDDMA_Init failed.\n");
#endif
			sound_started = 0;
			return;
		}
	}

	sound_started = 1;
}


/*
================
S_Init
================
*/
void S_Init (void)
{

	Con_Printf("\nSound Initialization\n");

	Cmd_AddCommand("play", S_Play);
	Cmd_AddCommand("playvol", S_PlayVol);
	Cmd_AddCommand("stopsound", S_StopAllSoundsC);
	Cmd_AddCommand("soundlist", S_SoundList);
	Cmd_AddCommand("soundinfo", S_SoundInfo_f);

	Cvar_RegisterVariable(&nosound);
	Cvar_RegisterVariable(&volume);
	Cvar_RegisterVariable(&precache);
	Cvar_RegisterVariable(&loadas8bit);
	Cvar_RegisterVariable(&bgmvolume);
	Cvar_RegisterVariable(&bgmbuffer);
	Cvar_RegisterVariable(&ambient_level);
	Cvar_RegisterVariable(&ambient_fade);
	Cvar_RegisterVariable(&snd_noextraupdate);
	Cvar_RegisterVariable(&snd_show);
	Cvar_RegisterVariable(&_snd_mixahead);

	if (host_parms.memsize < 0x800000)
	{
		Cvar_Set ("loadas8bit", "1");
		Con_Printf ("loading all sounds as 8bit\n");
	}



	snd_initialized = true;

	S_Startup ();

	SND_InitScaletable ();

	known_sfx = Hunk_AllocName (MAX_SFX*sizeof(sfx_t), "sfx_t");
	num_sfx = 0;

// create a piece of DMA memory

	if (fakedma)
	{
		shm = (void *) Hunk_AllocName(sizeof(*shm), "shm");
		shm->splitbuffer = 0;
		shm->samplebits = 16;
		shm->speed = 22050;
		shm->channels = 2;
		shm->samples = 32768;
		shm->samplepos = 0;
		shm->soundalive = true;
		shm->gamealive = true;
		shm->submission_chunk = 1;
		shm->buffer = Hunk_AllocName(1<<16, "shmbuf");
	}

	if ( shm ) {
		Con_Printf ("Sound sampling rate: %i\n", shm->speed);
	}

	// provides a tick sound until washed clean

//	if (shm->buffer)
//		shm->buffer[4] = shm->buffer[5] = 0x7f;	// force a pop for debugging

	ambient_sfx[AMBIENT_WATER] = S_PrecacheSound ("ambience/water1.wav");
	ambient_sfx[AMBIENT_SKY] = S_PrecacheSound ("ambience/wind2.wav");

	S_StopAllSounds (true);

    // init wma filter graph


#ifdef _XBOX
#ifdef XQUAKE_WMA
    SND_InitWmaPlayback();
#endif
#ifdef XQUAKE_DMUSIC
    SND_DMusicInit();
#endif
#endif
    
    


}


// =======================================================================
// Shutdown sound engine
// =======================================================================

void S_Shutdown(void)
{

	if (!sound_started)
		return;

	if (shm)
		shm->gamealive = 0;

	shm = 0;
	sound_started = 0;

	if (!fakedma)
	{
		SNDDMA_Shutdown();
	}
}


// =======================================================================
// Load a sound
// =======================================================================

/*
==================
S_FindName

==================
*/
sfx_t *S_FindName (char *name)
{
	int		i;
	sfx_t	*sfx;

	if (!name)
		Sys_Error ("S_FindName: NULL\n");

	if (Q_strlen(name) >= MAX_QPATH)
		Sys_Error ("Sound name too long: %s", name);

// see if already loaded
	for (i=0 ; i < num_sfx ; i++)
		if (!Q_strcmp(known_sfx[i].name, name))
		{
			return &known_sfx[i];
		}

	if (num_sfx == MAX_SFX)
		Sys_Error ("S_FindName: out of sfx_t");
	
	sfx = &known_sfx[i];
	strcpy (sfx->name, name);

	num_sfx++;
	
	return sfx;
}


/*
==================
S_TouchSound

==================
*/
void S_TouchSound (char *name)
{
	sfx_t	*sfx;
	
	if (!sound_started)
		return;

	sfx = S_FindName (name);
	Cache_Check (&sfx->cache);
}

/*
==================
S_PrecacheSound

==================
*/
sfx_t *S_PrecacheSound (char *name)
{
	sfx_t	*sfx;

	if (!sound_started || nosound.value)
		return NULL;

	sfx = S_FindName (name);
	
// cache it in
	if (precache.value)
		S_LoadSound (sfx);
	
	return sfx;
}


//=============================================================================

/*
=================
SND_PickChannel
=================
*/
channel_t *SND_PickChannel(int entnum, int entchannel)
{
    int ch_idx;
    int first_to_die;
    int life_left;

// Check for replacement sound, or find the best one to replace
    first_to_die = -1;
    life_left = 0x7fffffff;
    for (ch_idx=NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx++)
    {
		if (entchannel != 0		// channel 0 never overrides
		&& channels[ch_idx].entnum == entnum
		&& (channels[ch_idx].entchannel == entchannel || entchannel == -1) )
		{	// allways override sound from same entity
			first_to_die = ch_idx;
			break;
		}

		// don't let monster sounds override player sounds
		if (channels[ch_idx].entnum == cl.viewentity && entnum != cl.viewentity && channels[ch_idx].sfx)
			continue;

		if (channels[ch_idx].end - paintedtime < life_left)
		{
			life_left = channels[ch_idx].end - paintedtime;
			first_to_die = ch_idx;
		}
   }

	if (first_to_die == -1)
		return NULL;

	if (channels[first_to_die].sfx)
		channels[first_to_die].sfx = NULL;

    return &channels[first_to_die];    
}       

/*
=================
SND_Spatialize
=================
*/
void SND_Spatialize(channel_t *ch)
{
    vec_t dot;
    vec_t ldist, rdist, dist;
    vec_t lscale, rscale, scale;
    vec3_t source_vec;
	sfx_t *snd;

// anything coming from the view entity will allways be full volume
	if (ch->entnum == cl.viewentity)
	{
		ch->leftvol = ch->master_vol;
		ch->rightvol = ch->master_vol;
		return;
	}

// calculate stereo seperation and distance attenuation

	snd = ch->sfx;
	VectorSubtract(ch->origin, listener_origin, source_vec);
	
	dist = VectorNormalize(source_vec) * ch->dist_mult;
	
	dot = DotProduct(listener_right, source_vec);

	if (shm->channels == 1)
	{
		rscale = 1.0;
		lscale = 1.0;
	}
	else
	{
		rscale = 1.0 + dot;
		lscale = 1.0 - dot;
	}

// add in distance effect
	scale = (1.0 - dist) * rscale;
	ch->rightvol = (int) (ch->master_vol * scale);
	if (ch->rightvol < 0)
		ch->rightvol = 0;

	scale = (1.0 - dist) * lscale;
	ch->leftvol = (int) (ch->master_vol * scale);
	if (ch->leftvol < 0)
		ch->leftvol = 0;
}           


// =======================================================================
// Start a sound effect
// =======================================================================

void S_StartSound(int entnum, int entchannel, sfx_t *sfx, vec3_t origin, float fvol, float attenuation)
{
	channel_t *target_chan, *check;
	sfxcache_t	*sc;
	int		vol;
	int		ch_idx;
	int		skip;

	if (!sound_started)
		return;

	if (!sfx)
		return;

	if (nosound.value)
		return;

	vol = fvol*255;

// pick a channel to play on
	target_chan = SND_PickChannel(entnum, entchannel);
	if (!target_chan)
		return;
		
// spatialize
	memset (target_chan, 0, sizeof(*target_chan));
	VectorCopy(origin, target_chan->origin);
	target_chan->dist_mult = attenuation / sound_nominal_clip_dist;
	target_chan->master_vol = vol;
	target_chan->entnum = entnum;
	target_chan->entchannel = entchannel;
	SND_Spatialize(target_chan);

	if (!target_chan->leftvol && !target_chan->rightvol)
		return;		// not audible at all

// new channel
	sc = S_LoadSound (sfx);
	if (!sc)
	{
		target_chan->sfx = NULL;
		return;		// couldn't load the sound's data
	}

	target_chan->sfx = sfx;
	target_chan->pos = 0.0;
    target_chan->end = paintedtime + sc->length;	

// if an identical sound has also been started this frame, offset the pos
// a bit to keep it from just making the first one louder
	check = &channels[NUM_AMBIENTS];
    for (ch_idx=NUM_AMBIENTS ; ch_idx < NUM_AMBIENTS + MAX_DYNAMIC_CHANNELS ; ch_idx++, check++)
    {
		if (check == target_chan)
			continue;
		if (check->sfx == sfx && !check->pos)
		{
			skip = rand () % (int)(0.1*shm->speed);
			if (skip >= target_chan->end)
				skip = target_chan->end - 1;
			target_chan->pos += skip;
			target_chan->end -= skip;
			break;
		}
		
	}
}

void S_StopSound(int entnum, int entchannel)
{
	int i;

	for (i=0 ; i<MAX_DYNAMIC_CHANNELS ; i++)
	{
		if (channels[i].entnum == entnum
			&& channels[i].entchannel == entchannel)
		{
			channels[i].end = 0;
			channels[i].sfx = NULL;
			return;
		}
	}
}

void S_StopAllSounds(qboolean clear)
{
	int		i;

	if (!sound_started)
		return;

	total_channels = MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS;	// no statics

	for (i=0 ; i<MAX_CHANNELS ; i++)
		if (channels[i].sfx)
			channels[i].sfx = NULL;

	Q_memset(channels, 0, MAX_CHANNELS * sizeof(channel_t));

	if (clear)
		S_ClearBuffer ();
}

void S_StopAllSoundsC (void)
{
	S_StopAllSounds (true);
}

void S_ClearBuffer (void)
{
	int		clear;
		
	if (!sound_started || !shm || (!shm->buffer && !pDSBuf))
		return;

	if (shm->samplebits == 8)
		clear = 0x80;
	else
		clear = 0;

	if (pDSBuf)
	{
		DWORD	dwSize;
		DWORD	*pData;
		int		reps;
		HRESULT	hresult;

		reps = 0;

		while ((hresult = IDirectSoundBuffer_Lock(pDSBuf, 0, gSndBufSize, &pData, &dwSize, NULL, NULL, 0)) != DS_OK)
		{
			Con_Printf ("S_ClearBuffer: DS::Lock Sound Buffer Failed\n");
			S_Shutdown ();
			return;
		}

		Q_memset(pData, clear, shm->samples * shm->samplebits/8);

//		IDirectSoundBuffer_Unlock(pDSBuf, pData, dwSize, NULL, 0);
	
	}
	else
	{
		Q_memset(shm->buffer, clear, shm->samples * shm->samplebits/8);
	}
}


/*
=================
S_StaticSound
=================
*/
void S_StaticSound (sfx_t *sfx, vec3_t origin, float vol, float attenuation)
{
	channel_t	*ss;
	sfxcache_t		*sc;

	if (!sfx)
		return;

	if (total_channels == MAX_CHANNELS)
	{
		Con_Printf ("total_channels == MAX_CHANNELS\n");
		return;
	}

	ss = &channels[total_channels];
	total_channels++;

	sc = S_LoadSound (sfx);
	if (!sc)
		return;

	if (sc->loopstart == -1)
	{
		Con_Printf ("Sound %s not looped\n", sfx->name);
		return;
	}
	
	ss->sfx = sfx;
	VectorCopy (origin, ss->origin);
	ss->master_vol = vol;
	ss->dist_mult = (attenuation/64) / sound_nominal_clip_dist;
    ss->end = paintedtime + sc->length;	
	
	SND_Spatialize (ss);
}


//=============================================================================

/*
===================
S_UpdateAmbientSounds
===================
*/
void S_UpdateAmbientSounds (void)
{
	mleaf_t		*l;
	float		vol;
	int			ambient_channel;
	channel_t	*chan;

	if (!snd_ambient)
		return;

// calc ambient sound levels
	if (!cl.worldmodel)
		return;

	l = Mod_PointInLeaf (listener_origin, cl.worldmodel);
	if (!l || !ambient_level.value)
	{
		for (ambient_channel = 0 ; ambient_channel< NUM_AMBIENTS ; ambient_channel++)
			channels[ambient_channel].sfx = NULL;
		return;
	}

	for (ambient_channel = 0 ; ambient_channel< NUM_AMBIENTS ; ambient_channel++)
	{
		chan = &channels[ambient_channel];	
		chan->sfx = ambient_sfx[ambient_channel];
	
		vol = ambient_level.value * l->ambient_sound_level[ambient_channel];
		if (vol < 8)
			vol = 0;

	// don't adjust volume too fast
		if (chan->master_vol < vol)
		{
			chan->master_vol += host_frametime * ambient_fade.value;
			if (chan->master_vol > vol)
				chan->master_vol = vol;
		}
		else if (chan->master_vol > vol)
		{
			chan->master_vol -= host_frametime * ambient_fade.value;
			if (chan->master_vol < vol)
				chan->master_vol = vol;
		}
		
		chan->leftvol = chan->rightvol = chan->master_vol;
	}
}


/*
============
S_Update

Called once each time through the main loop
============
*/
void S_Update(vec3_t origin, vec3_t forward, vec3_t right, vec3_t up)
{
	int			i, j;
	int			total;
	channel_t	*ch;
	channel_t	*combine;

	if (!sound_started || (snd_blocked > 0))
		return;

	VectorCopy(origin, listener_origin);
	VectorCopy(forward, listener_forward);
	VectorCopy(right, listener_right);
	VectorCopy(up, listener_up);
	
// update general area ambient sound sources
	S_UpdateAmbientSounds ();

	combine = NULL;

// update spatialization for static and dynamic sounds	
	ch = channels+NUM_AMBIENTS;
	for (i=NUM_AMBIENTS ; i<total_channels; i++, ch++)
	{
		if (!ch->sfx)
			continue;
		SND_Spatialize(ch);         // respatialize channel
		if (!ch->leftvol && !ch->rightvol)
			continue;

	// try to combine static sounds with a previous channel of the same
	// sound effect so we don't mix five torches every frame
	
		if (i >= MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS)
		{
		// see if it can just use the last one
			if (combine && combine->sfx == ch->sfx)
			{
				combine->leftvol += ch->leftvol;
				combine->rightvol += ch->rightvol;
				ch->leftvol = ch->rightvol = 0;
				continue;
			}
		// search for one
			combine = channels+MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS;
			for (j=MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS ; j<i; j++, combine++)
				if (combine->sfx == ch->sfx)
					break;
					
			if (j == total_channels)
			{
				combine = NULL;
			}
			else
			{
				if (combine != ch)
				{
					combine->leftvol += ch->leftvol;
					combine->rightvol += ch->rightvol;
					ch->leftvol = ch->rightvol = 0;
				}
				continue;
			}
		}
		
		
	}

//
// debugging output
//
	if (snd_show.value)
	{
		total = 0;
		ch = channels;
		for (i=0 ; i<total_channels; i++, ch++)
			if (ch->sfx && (ch->leftvol || ch->rightvol) )
			{
				//Con_Printf ("%3i %3i %s\n", ch->leftvol, ch->rightvol, ch->sfx->name);
				total++;
			}
		
		Con_Printf ("----(%i)----\n", total);
	}

// mix some sound
	S_Update_();
}

void GetSoundtime(void)
{
	int		samplepos;
	static	int		buffers;
	static	int		oldsamplepos;
	int		fullsamples;
	
	fullsamples = shm->samples / shm->channels;

// it is possible to miscount buffers if it has wrapped twice between
// calls to S_Update.  Oh well.
#ifdef __sun__
	soundtime = SNDDMA_GetSamples();
#else
	samplepos = SNDDMA_GetDMAPos();


	if (samplepos < oldsamplepos)
	{
		buffers++;					// buffer wrapped
		
		if (paintedtime > 0x40000000)
		{	// time to chop things off to avoid 32 bit limits
			buffers = 0;
			paintedtime = fullsamples;
			S_StopAllSounds (true);
		}
	}
	oldsamplepos = samplepos;

	soundtime = buffers*fullsamples + samplepos/shm->channels;
#endif
}

void S_ExtraUpdate (void)
{

#if !defined(XBOX)
	IN_Accumulate ();
#endif

	if (snd_noextraupdate.value)
		return;		// don't pollute timings
	S_Update_();
}

void S_Update_(void)
{
	unsigned        endtime;
	int				samps;
	
	if (!sound_started || (snd_blocked > 0))
		return;

// Updates DMA time
	GetSoundtime();

// check to make sure that we haven't overshot
	if (paintedtime < soundtime)
	{
		//Con_Printf ("S_Update_ : overflow\n");
		paintedtime = soundtime;
	}

// mix ahead of current position
	endtime = soundtime + _snd_mixahead.value * shm->speed;
	samps = shm->samples >> (shm->channels-1);
	if (endtime - soundtime > samps)
		endtime = soundtime + samps;

	S_PaintChannels (endtime);

	SNDDMA_Submit ();
}

/*
===============================================================================

console functions

===============================================================================
*/

void S_Play(void)
{
	static int hash=345;
	int 	i;
	char name[256];
	sfx_t	*sfx;
	
	i = 1;
	while (i<Cmd_Argc())
	{
		if (!Q_strrchr(Cmd_Argv(i), '.'))
		{
			Q_strcpy(name, Cmd_Argv(i));
			Q_strcat(name, ".wav");
		}
		else
			Q_strcpy(name, Cmd_Argv(i));
		sfx = S_PrecacheSound(name);
		S_StartSound(hash++, 0, sfx, listener_origin, 1.0, 1.0);
		i++;
	}
}

void S_PlayVol(void)
{
	static int hash=543;
	int i;
	float vol;
	char name[256];
	sfx_t	*sfx;
	
	i = 1;
	while (i<Cmd_Argc())
	{
		if (!Q_strrchr(Cmd_Argv(i), '.'))
		{
			Q_strcpy(name, Cmd_Argv(i));
			Q_strcat(name, ".wav");
		}
		else
			Q_strcpy(name, Cmd_Argv(i));
		sfx = S_PrecacheSound(name);
		vol = Q_atof(Cmd_Argv(i+1));
		S_StartSound(hash++, 0, sfx, listener_origin, vol, 1.0);
		i+=2;
	}
}

void S_SoundList(void)
{
	int		i;
	sfx_t	*sfx;
	sfxcache_t	*sc;
	int		size, total;

	total = 0;
	for (sfx=known_sfx, i=0 ; i<num_sfx ; i++, sfx++)
	{
		sc = Cache_Check (&sfx->cache);
		if (!sc)
			continue;
		size = sc->length*sc->width*(sc->stereo+1);
		total += size;
		if (sc->loopstart >= 0)
			Con_Printf ("L");
		else
			Con_Printf (" ");
		Con_Printf("(%2db) %6i : %s\n",sc->width*8,  size, sfx->name);
	}
	Con_Printf ("Total resident: %i\n", total);
}


void S_LocalSound (char *sound)
{
	sfx_t	*sfx;

	if (nosound.value)
		return;
	if (!sound_started)
		return;
		
	sfx = S_PrecacheSound (sound);
	if (!sfx)
	{
		Con_Printf ("S_LocalSound: can't cache %s\n", sound);
		return;
	}
	S_StartSound (cl.viewentity, -1, sfx, vec3_origin, 1, 1);
}


void S_ClearPrecache (void)
{
}


void S_BeginPrecaching (void)
{
}


void S_EndPrecaching (void)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\r_part.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#include "quakedef.h"
//#include "r_local.h"

#define MAX_PARTICLES			2048	// default max # of particles at one
										//  time
#define ABSOLUTE_MIN_PARTICLES	512		// no fewer than this no matter what's
										//  on the command line

int		ramp1[8] = {0x6f, 0x6d, 0x6b, 0x69, 0x67, 0x65, 0x63, 0x61};
int		ramp2[8] = {0x6f, 0x6e, 0x6d, 0x6c, 0x6b, 0x6a, 0x68, 0x66};
int		ramp3[8] = {0x6d, 0x6b, 6, 5, 4, 3};

particle_t	*active_particles, *free_particles;

particle_t	*particles;
int			r_numparticles;

vec3_t			r_pright, r_pup, r_ppn;


/*
===============
R_InitParticles
===============
*/
void R_InitParticles (void)
{
	int		i;

    r_numparticles = MAX_PARTICLES;

	particles = (particle_t *)
			Hunk_AllocName (r_numparticles * sizeof(particle_t), "particles");
}

#ifdef QUAKE2
void R_DarkFieldParticles (entity_t *ent)
{
	int			i, j, k;
	particle_t	*p;
	float		vel;
	vec3_t		dir;
	vec3_t		org;

	org[0] = ent->origin[0];
	org[1] = ent->origin[1];
	org[2] = ent->origin[2];
	for (i=-16 ; i<16 ; i+=8)
		for (j=-16 ; j<16 ; j+=8)
			for (k=0 ; k<32 ; k+=8)
			{
				if (!free_particles)
					return;
				p = free_particles;
				free_particles = p->next;
				p->next = active_particles;
				active_particles = p;
		
				p->die = cl.time + 0.2 + (rand()&7) * 0.02;
				p->color = 150 + rand()%6;
				p->type = pt_slowgrav;
				
				dir[0] = j*8;
				dir[1] = i*8;
				dir[2] = k*8;
	
				p->org[0] = org[0] + i + (rand()&3);
				p->org[1] = org[1] + j + (rand()&3);
				p->org[2] = org[2] + k + (rand()&3);
	
				VectorNormalize (dir);						
				vel = 50 + (rand()&63);
				VectorScale (dir, vel, p->vel);
			}
}
#endif


/*
===============
R_EntityParticles
===============
*/

#define NUMVERTEXNORMALS	162
extern	float	r_avertexnormals[NUMVERTEXNORMALS][3];
vec3_t	avelocities[NUMVERTEXNORMALS];
float	beamlength = 16;
vec3_t	avelocity = {23, 7, 3};
float	partstep = 0.01;
float	timescale = 0.01;

void R_EntityParticles (entity_t *ent)
{
	int			count;
	int			i;
	particle_t	*p;
	float		angle;
	float		sr, sp, sy, cr, cp, cy;
	vec3_t		forward;
	float		dist;
	
	dist = 64;
	count = 50;

if (!avelocities[0][0])
{
for (i=0 ; i<NUMVERTEXNORMALS*3 ; i++)
avelocities[0][i] = (rand()&255) * 0.01;
}


	for (i=0 ; i<NUMVERTEXNORMALS ; i++)
	{
		angle = cl.time * avelocities[i][0];
		sy = sin(angle);
		cy = cos(angle);
		angle = cl.time * avelocities[i][1];
		sp = sin(angle);
		cp = cos(angle);
		angle = cl.time * avelocities[i][2];
		sr = sin(angle);
		cr = cos(angle);
	
		forward[0] = cp*cy;
		forward[1] = cp*sy;
		forward[2] = -sp;

		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;

		p->die = cl.time + 0.01;
		p->color = 0x6f;
		p->type = pt_explode;
		
		p->org[0] = ent->origin[0] + r_avertexnormals[i][0]*dist + forward[0]*beamlength;			
		p->org[1] = ent->origin[1] + r_avertexnormals[i][1]*dist + forward[1]*beamlength;			
		p->org[2] = ent->origin[2] + r_avertexnormals[i][2]*dist + forward[2]*beamlength;			
	}
}


/*
===============
R_ClearParticles
===============
*/
void R_ClearParticles (void)
{
	int		i;
	
	free_particles = &particles[0];
	active_particles = NULL;

	for (i=0 ;i<r_numparticles ; i++)
		particles[i].next = &particles[i+1];
	particles[r_numparticles-1].next = NULL;
}


void R_ReadPointFile_f (void)
{
	FILE	*f;
	vec3_t	org;
	int		r;
	int		c;
	particle_t	*p;
	char	name[MAX_OSPATH];
	
	sprintf (name,"maps/%s.pts", sv.name);

	COM_FOpenFile (name, &f);
	if (!f)
	{
		Con_Printf ("couldn't open %s\n", name);
		return;
	}
	
	Con_Printf ("Reading %s...\n", name);
	c = 0;
	for ( ;; )
	{
		r = fscanf (f,"%f %f %f\n", &org[0], &org[1], &org[2]);
		if (r != 3)
			break;
		c++;
		
		if (!free_particles)
		{
			Con_Printf ("Not enough free particles\n");
			break;
		}
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;
		
		p->die = 99999;
		p->color = (-c)&15;
		p->type = pt_static;
		VectorCopy (vec3_origin, p->vel);
		VectorCopy (org, p->org);
	}

	fclose (f);
	Con_Printf ("%i points read\n", c);
}

/*
===============
R_ParseParticleEffect

Parse an effect out of the server message
===============
*/
void R_ParseParticleEffect (void)
{
	vec3_t		org, dir;
	int			i, count, msgcount, color;
	
	for (i=0 ; i<3 ; i++)
		org[i] = MSG_ReadCoord ();
	for (i=0 ; i<3 ; i++)
		dir[i] = MSG_ReadChar () * (1.0/16);
	msgcount = MSG_ReadByte ();
	color = MSG_ReadByte ();

if (msgcount == 255)
	count = 1024;
else
	count = msgcount;
	
	R_RunParticleEffect (org, dir, color, count);
}
	
/*
===============
R_ParticleExplosion

===============
*/
void R_ParticleExplosion (vec3_t org)
{
	int			i, j;
	particle_t	*p;
	
	for (i=0 ; i<1024 ; i++)
	{
		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;

		p->die = cl.time + 5;
		p->color = ramp1[0];
		p->ramp = rand()&3;
		if (i & 1)
		{
			p->type = pt_explode;
			for (j=0 ; j<3 ; j++)
			{
				p->org[j] = org[j] + ((rand()%32)-16);
				p->vel[j] = (rand()%512)-256;
			}
		}
		else
		{
			p->type = pt_explode2;
			for (j=0 ; j<3 ; j++)
			{
				p->org[j] = org[j] + ((rand()%32)-16);
				p->vel[j] = (rand()%512)-256;
			}
		}
	}
}

/*
===============
R_ParticleExplosion2

===============
*/
void R_ParticleExplosion2 (vec3_t org, int colorStart, int colorLength)
{
	int			i, j;
	particle_t	*p;
	int			colorMod = 0;

	for (i=0; i<512; i++)
	{
		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;

		p->die = cl.time + 0.3;
		p->color = colorStart + (colorMod % colorLength);
		colorMod++;

		p->type = pt_blob;
		for (j=0 ; j<3 ; j++)
		{
			p->org[j] = org[j] + ((rand()%32)-16);
			p->vel[j] = (rand()%512)-256;
		}
	}
}

/*
===============
R_BlobExplosion

===============
*/
void R_BlobExplosion (vec3_t org)
{
	int			i, j;
	particle_t	*p;
	
	for (i=0 ; i<1024 ; i++)
	{
		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;

		p->die = cl.time + 1 + (rand()&8)*0.05;

		if (i & 1)
		{
			p->type = pt_blob;
			p->color = 66 + rand()%6;
			for (j=0 ; j<3 ; j++)
			{
				p->org[j] = org[j] + ((rand()%32)-16);
				p->vel[j] = (rand()%512)-256;
			}
		}
		else
		{
			p->type = pt_blob2;
			p->color = 150 + rand()%6;
			for (j=0 ; j<3 ; j++)
			{
				p->org[j] = org[j] + ((rand()%32)-16);
				p->vel[j] = (rand()%512)-256;
			}
		}
	}
}

/*
===============
R_RunParticleEffect

===============
*/
void R_RunParticleEffect (vec3_t org, vec3_t dir, int color, int count)
{
	int			i, j;
	particle_t	*p;
	
	for (i=0 ; i<count ; i++)
	{
		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;

		if (count == 1024)
		{	// rocket explosion
			p->die = cl.time + 5;
			p->color = ramp1[0];
			p->ramp = rand()&3;
			if (i & 1)
			{
				p->type = pt_explode;
				for (j=0 ; j<3 ; j++)
				{
					p->org[j] = org[j] + ((rand()%32)-16);
					p->vel[j] = (rand()%512)-256;
				}
			}
			else
			{
				p->type = pt_explode2;
				for (j=0 ; j<3 ; j++)
				{
					p->org[j] = org[j] + ((rand()%32)-16);
					p->vel[j] = (rand()%512)-256;
				}
			}
		}
		else
		{
			p->die = cl.time + 0.1*(rand()%5);
			p->color = (color&~7) + (rand()&7);
			p->type = pt_slowgrav;
			for (j=0 ; j<3 ; j++)
			{
				p->org[j] = org[j] + ((rand()&15)-8);
				p->vel[j] = dir[j]*15;// + (rand()%300)-150;
			}
		}
	}
}


/*
===============
R_LavaSplash

===============
*/
void R_LavaSplash (vec3_t org)
{
	int			i, j, k;
	particle_t	*p;
	float		vel;
	vec3_t		dir;

	for (i=-16 ; i<16 ; i++)
		for (j=-16 ; j<16 ; j++)
			for (k=0 ; k<1 ; k++)
			{
				if (!free_particles)
					return;
				p = free_particles;
				free_particles = p->next;
				p->next = active_particles;
				active_particles = p;
		
				p->die = cl.time + 2 + (rand()&31) * 0.02;
				p->color = 224 + (rand()&7);
				p->type = pt_slowgrav;
				
				dir[0] = j*8 + (rand()&7);
				dir[1] = i*8 + (rand()&7);
				dir[2] = 256;
	
				p->org[0] = org[0] + dir[0];
				p->org[1] = org[1] + dir[1];
				p->org[2] = org[2] + (rand()&63);
	
				VectorNormalize (dir);						
				vel = 50 + (rand()&63);
				VectorScale (dir, vel, p->vel);
			}
}

/*
===============
R_TeleportSplash

===============
*/
void R_TeleportSplash (vec3_t org)
{
	int			i, j, k;
	particle_t	*p;
	float		vel;
	vec3_t		dir;

	for (i=-16 ; i<16 ; i+=4)
		for (j=-16 ; j<16 ; j+=4)
			for (k=-24 ; k<32 ; k+=4)
			{
				if (!free_particles)
					return;
				p = free_particles;
				free_particles = p->next;
				p->next = active_particles;
				active_particles = p;
		
				p->die = cl.time + 0.2 + (rand()&7) * 0.02;
				p->color = 7 + (rand()&7);
				p->type = pt_slowgrav;
				
				dir[0] = j*8;
				dir[1] = i*8;
				dir[2] = k*8;
	
				p->org[0] = org[0] + i + (rand()&3);
				p->org[1] = org[1] + j + (rand()&3);
				p->org[2] = org[2] + k + (rand()&3);
	
				VectorNormalize (dir);						
				vel = 50 + (rand()&63);
				VectorScale (dir, vel, p->vel);
			}
}

void R_RocketTrail (vec3_t start, vec3_t end, int type)
{
	vec3_t		vec;
	float		len;
	int			j;
	particle_t	*p;
	int			dec;
	static int	tracercount;

	VectorSubtract (end, start, vec);
	len = VectorNormalize (vec);
	if (type < 128)
		dec = 3;
	else
	{
		dec = 1;
		type -= 128;
	}

	while (len > 0)
	{
		len -= dec;

		if (!free_particles)
			return;
		p = free_particles;
		free_particles = p->next;
		p->next = active_particles;
		active_particles = p;
		
		VectorCopy (vec3_origin, p->vel);
		p->die = cl.time + 2;

		switch (type)
		{
			case 0:	// rocket trail
				p->ramp = (rand()&3);
				p->color = ramp3[(int)p->ramp];
				p->type = pt_fire;
				for (j=0 ; j<3 ; j++)
					p->org[j] = start[j] + ((rand()%6)-3);
				break;

			case 1:	// smoke smoke
				p->ramp = (rand()&3) + 2;
				p->color = ramp3[(int)p->ramp];
				p->type = pt_fire;
				for (j=0 ; j<3 ; j++)
					p->org[j] = start[j] + ((rand()%6)-3);
				break;

			case 2:	// blood
				p->type = pt_grav;
				p->color = 67 + (rand()&3);
				for (j=0 ; j<3 ; j++)
					p->org[j] = start[j] + ((rand()%6)-3);
				break;

			case 3:
			case 5:	// tracer
				p->die = cl.time + 0.5;
				p->type = pt_static;
				if (type == 3)
					p->color = 52 + ((tracercount&4)<<1);
				else
					p->color = 230 + ((tracercount&4)<<1);
			
				tracercount++;

				VectorCopy (start, p->org);
				if (tracercount & 1)
				{
					p->vel[0] = 30*vec[1];
					p->vel[1] = 30*-vec[0];
				}
				else
				{
					p->vel[0] = 30*-vec[1];
					p->vel[1] = 30*vec[0];
				}
				break;

			case 4:	// slight blood
				p->type = pt_grav;
				p->color = 67 + (rand()&3);
				for (j=0 ; j<3 ; j++)
					p->org[j] = start[j] + ((rand()%6)-3);
				len -= 3;
				break;

			case 6:	// voor trail
				p->color = 9*16 + 8 + (rand()&3);
				p->type = pt_static;
				p->die = cl.time + 0.3;
				for (j=0 ; j<3 ; j++)
					p->org[j] = start[j] + ((rand()&15)-8);
				break;
		}
		

		VectorAdd (start, vec, start);
	}
}


/*
===============
R_DrawParticles
===============
*/
extern	cvar_t	sv_gravity;

#ifdef _XBOX
// BUGBUG - early versions of XBOX graphics couldn't handle long chains of triangles.
#define ONE_PARTICLE_AT_A_TIME
#endif

void R_DrawParticles (void)
{
	particle_t		*p, *kill;
	float			grav;
	int				i;
	float			time2, time3;
	float			time1;
	float			dvel;
	float			frametime;
	
#ifdef GLQUAKE
	vec3_t			up, right;
	float			scale;

    GL_Bind(particletexture);
	glEnable (GL_BLEND);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
#ifndef ONE_PARTICLE_AT_A_TIME
	glBegin (GL_TRIANGLES);
#endif

	VectorScale (vup, 1.5, up);
	VectorScale (vright, 1.5, right);
#else
	D_StartParticles ();

	VectorScale (vright, xscaleshrink, r_pright);
	VectorScale (vup, yscaleshrink, r_pup);
	VectorCopy (vpn, r_ppn);
#endif
	frametime = cl.time - cl.oldtime;
	time3 = frametime * 15;
	time2 = frametime * 10; // 15;
	time1 = frametime * 5;
	grav = frametime * sv_gravity.value * 0.05;
	dvel = 4*frametime;
	
	for ( ;; ) 
	{
		kill = active_particles;
		if (kill && kill->die < cl.time)
		{
			active_particles = kill->next;
			kill->next = free_particles;
			free_particles = kill;
			continue;
		}
		break;
	}

	for (p=active_particles ; p ; p=p->next)
	{
		for ( ;; )
		{
			kill = p->next;
			if (kill && kill->die < cl.time)
			{
				p->next = kill->next;
				kill->next = free_particles;
				free_particles = kill;
				continue;
			}
			break;
		}

#ifdef GLQUAKE
		// hack a scale up to keep particles from disapearing
		scale = (p->org[0] - r_origin[0])*vpn[0] + (p->org[1] - r_origin[1])*vpn[1]
			+ (p->org[2] - r_origin[2])*vpn[2];
		if (scale < 20)
			scale = 1;
		else
			scale = 1 + scale * 0.004;
#ifdef ONE_PARTICLE_AT_A_TIME
	    glBegin (GL_TRIANGLES);
#endif
		glColor3ubv ((byte *)&d_8to24table[(int)p->color]);
		glTexCoord2f (0,0);
		glVertex3fv (p->org);
		glTexCoord2f (1,0);
		glVertex3f (p->org[0] + up[0]*scale, p->org[1] + up[1]*scale, p->org[2] + up[2]*scale);
		glTexCoord2f (0,1);
		glVertex3f (p->org[0] + right[0]*scale, p->org[1] + right[1]*scale, p->org[2] + right[2]*scale);
#ifdef ONE_PARTICLE_AT_A_TIME
		glEnd();
		glFinish();
#endif
#else
		D_DrawParticle (p);
#endif
		p->org[0] += p->vel[0]*frametime;
		p->org[1] += p->vel[1]*frametime;
		p->org[2] += p->vel[2]*frametime;
		
		switch (p->type)
		{
		case pt_static:
			break;
		case pt_fire:
			p->ramp += time1;
			if (p->ramp >= 6)
				p->die = -1;
			else
				p->color = ramp3[(int)p->ramp];
			p->vel[2] += grav;
			break;

		case pt_explode:
			p->ramp += time2;
			if (p->ramp >=8)
				p->die = -1;
			else
				p->color = ramp1[(int)p->ramp];
			for (i=0 ; i<3 ; i++)
				p->vel[i] += p->vel[i]*dvel;
			p->vel[2] -= grav;
			break;

		case pt_explode2:
			p->ramp += time3;
			if (p->ramp >=8)
				p->die = -1;
			else
				p->color = ramp2[(int)p->ramp];
			for (i=0 ; i<3 ; i++)
				p->vel[i] -= p->vel[i]*frametime;
			p->vel[2] -= grav;
			break;

		case pt_blob:
			for (i=0 ; i<3 ; i++)
				p->vel[i] += p->vel[i]*dvel;
			p->vel[2] -= grav;
			break;

		case pt_blob2:
			for (i=0 ; i<2 ; i++)
				p->vel[i] -= p->vel[i]*dvel;
			p->vel[2] -= grav;
			break;

		case pt_grav:
#ifdef QUAKE2
			p->vel[2] -= grav * 20;
			break;
#endif
		case pt_slowgrav:
			p->vel[2] -= grav;
			break;
		}
	}

#ifdef GLQUAKE
#ifndef ONE_PARTICLE_AT_A_TIME
	glEnd ();
#endif
	glDisable (GL_BLEND);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
#else
	D_EndParticles ();
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\screen.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// screen.h

void SCR_Init (void);

void SCR_UpdateScreen (void);


void SCR_SizeUp (void);
void SCR_SizeDown (void);
void SCR_BringDownConsole (void);
void SCR_CenterPrint (char *str);

void SCR_BeginLoadingPlaque (void);
void SCR_EndLoadingPlaque (void);

int SCR_ModalMessage (char *text);

extern	float		scr_con_current;
extern	float		scr_conlines;		// lines of console to display

extern	int			scr_fullupdate;	// set to 0 to force full redraw
extern	int			sb_lines;

extern	int			clearnotify;	// set to 0 whenever notify text is drawn
extern	qboolean	scr_disabled_for_loading;
extern	qboolean	scr_skipupdate;

extern	cvar_t		scr_viewsize;

extern cvar_t scr_viewsize;

// only the refresh window will be updated unless these variables are flagged 
extern	int			scr_copytop;
extern	int			scr_copyeverything;

extern qboolean		block_drawing;

void SCR_UpdateWholeScreen (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\snd_mix.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// snd_mix.c -- portable code to mix sounds for snd_dma.c

#include "quakedef.h"
#include "xquake.h"

#define	PAINTBUFFER_SIZE	512
portable_samplepair_t paintbuffer[PAINTBUFFER_SIZE];
int		snd_scaletable[32][256];
int 	*snd_p, snd_linear_count, snd_vol;
short	*snd_out;

void Snd_WriteLinearBlastStereo16 (void);

#if	!id386
void Snd_WriteLinearBlastStereo16 (void)
{
	int		i;
	int		val;

	for (i=0 ; i<snd_linear_count ; i+=2)
	{
		val = (snd_p[i]*snd_vol)>>8;
		if (val > 0x7fff)
			snd_out[i] = 0x7fff;
		else if (val < (short)0x8000)
			snd_out[i] = (short)0x8000;
		else
			snd_out[i] = (short)val;

		val = (snd_p[i+1]*snd_vol)>>8;
		if (val > 0x7fff)
			snd_out[i+1] = 0x7fff;
		else if (val < (short)0x8000)
			snd_out[i+1] = (short)0x8000;
		else
			snd_out[i+1] = (short)val;
	}
}
#endif

void S_TransferStereo16 (int endtime)
{
	int		lpos;
	int		lpaintedtime;
	DWORD	*pbuf;
#ifdef _WIN32
	int		reps;
	DWORD	dwSize,dwSize2;
	DWORD	*pbuf2;
	HRESULT	hresult;
#endif
	
	snd_vol = volume.value*256;

	snd_p = (int *) paintbuffer;
	lpaintedtime = paintedtime;

#ifdef _WIN32
	if (pDSBuf)
	{
		reps = 0;

		while ((hresult = IDirectSoundBuffer_Lock(pDSBuf, 0, gSndBufSize, &pbuf, &dwSize, 
									   &pbuf2, &dwSize2, 0)) != DS_OK)
		{
			Con_Printf ("S_TransferStereo16: DS::Lock Sound Buffer Failed\n");
			S_Shutdown ();
			S_Startup ();
		}
	}
	else
#endif
	{
		pbuf = (DWORD *)shm->buffer;
	}

	while (lpaintedtime < endtime)
	{
	// handle recirculating buffer issues
		lpos = lpaintedtime & ((shm->samples>>1)-1);

		snd_out = (short *) pbuf + (lpos<<1);

		snd_linear_count = (shm->samples>>1) - lpos;
		if (lpaintedtime + snd_linear_count > endtime)
			snd_linear_count = endtime - lpaintedtime;

		snd_linear_count <<= 1;

	// write a linear blast of samples
		Snd_WriteLinearBlastStereo16 ();

		snd_p += snd_linear_count;
		lpaintedtime += (snd_linear_count>>1);
	}

#ifdef _WIN32
//	if (pDSBuf)
//		IDirectSoundBuffer_Unlock(pDSBuf, pbuf, dwSize, NULL, 0);
#endif
}

void S_TransferPaintBuffer(int endtime)
{
	int 	out_idx;
	int 	count;
	int 	out_mask;
	int 	*p;
	int 	step;
	int		val;
	int		snd_vol;
	DWORD	*pbuf;
#ifdef _WIN32
	int		reps;
	DWORD	dwSize,dwSize2;
	DWORD	*pbuf2;
	HRESULT	hresult;
#endif

	if (shm->samplebits == 16 && shm->channels == 2)
	{
		S_TransferStereo16 (endtime);
		return;
	}
	
	p = (int *) paintbuffer;
	count = (endtime - paintedtime) * shm->channels;
	out_mask = shm->samples - 1; 
	out_idx = paintedtime * shm->channels & out_mask;
	step = 3 - shm->channels;
	snd_vol = volume.value*256;

#ifdef _WIN32
	if (pDSBuf)
	{
		reps = 0;

		while ((hresult = IDirectSoundBuffer_Lock(pDSBuf, 0, gSndBufSize, &pbuf, &dwSize, 
									   &pbuf2,&dwSize2, 0)) != DS_OK)
		{
			if (++reps > 10000)
			{
				Con_Printf ("S_TransferPaintBuffer: DS: couldn't restore buffer\n");
				S_Shutdown ();
				S_Startup ();
				return;
			}
		}
	}
	else
#endif
	{
		pbuf = (DWORD *)shm->buffer;
	}

	if (shm->samplebits == 16)
	{
		short *out = (short *) pbuf;
		while (count--)
		{
			val = (*p * snd_vol) >> 8;
			p+= step;
			if (val > 0x7fff)
				val = 0x7fff;
			else if (val < (short)0x8000)
				val = (short)0x8000;
			out[out_idx] = (short)val;
			out_idx = (out_idx + 1) & out_mask;
		}
	}
	else if (shm->samplebits == 8)
	{
		unsigned char *out = (unsigned char *) pbuf;
		while (count--)
		{
			val = (*p * snd_vol) >> 8;
			p+= step;
			if (val > 0x7fff)
				val = 0x7fff;
			else if (val < (short)0x8000)
				val = (short)0x8000;
			out[out_idx] = (val>>8) + 128;
			out_idx = (out_idx + 1) & out_mask;
		}
	}

#ifdef _WIN32
	if (pDSBuf) {
		DWORD dwNewpos, dwWrite;
		int il = paintedtime;
		int ir = endtime - paintedtime;
		
		ir += il;

//		IDirectSoundBuffer_Unlock(pDSBuf, pbuf, dwSize, NULL, 0);
	}
#endif
}


/*
===============================================================================

CHANNEL MIXING

===============================================================================
*/

void SND_PaintChannelFrom8 (channel_t *ch, sfxcache_t *sc, int endtime);
void SND_PaintChannelFrom16 (channel_t *ch, sfxcache_t *sc, int endtime);

void S_PaintChannels(int endtime)
{
	int 	i;
	int 	end;
	channel_t *ch;
	sfxcache_t	*sc;
	int		ltime, count;

    while (paintedtime < endtime)
	{
	// if paintbuffer is smaller than DMA buffer
		end = endtime;
		if (endtime - paintedtime > PAINTBUFFER_SIZE)
			end = paintedtime + PAINTBUFFER_SIZE;

	// clear the paint buffer
		Q_memset(paintbuffer, 0, (end - paintedtime) * sizeof(portable_samplepair_t));

	// paint in the channels.
		ch = channels;
		for (i=0; i<total_channels ; i++, ch++)
		{
			if (!ch->sfx)
				continue;
			if (!ch->leftvol && !ch->rightvol)
				continue;
			sc = S_LoadSound (ch->sfx);
			if (!sc)
				continue;

			ltime = paintedtime;

			while (ltime < end)
			{	// paint up to end
				if (ch->end < end)
					count = ch->end - ltime;
				else
					count = end - ltime;

				if (count > 0)
				{	
					if (sc->width == 1)
						SND_PaintChannelFrom8(ch, sc, count);
					else
						SND_PaintChannelFrom16(ch, sc, count);
	
					ltime += count;
				}

			// if at end of loop, restart
				if (ltime >= ch->end)
				{
					if (sc->loopstart >= 0)
					{
						ch->pos = sc->loopstart;
						ch->end = ltime + sc->length - ch->pos;
					}
					else				
					{	// channel just stopped
						ch->sfx = NULL;
						break;
					}
				}
			}
															  
		}

	// transfer out according to DMA format
		S_TransferPaintBuffer(end);
		paintedtime = end;
	}
}

void SND_InitScaletable (void)
{
	int		i, j;
	
	for (i=0 ; i<32 ; i++)
		for (j=0 ; j<256 ; j++)
			snd_scaletable[i][j] = ((signed char)j) * i * 8;
}


#if	!id386

void SND_PaintChannelFrom8 (channel_t *ch, sfxcache_t *sc, int count)
{
	int 	data;
	int		*lscale, *rscale;
	unsigned char *sfx;
	int		i;

	if (ch->leftvol > 255)
		ch->leftvol = 255;
	if (ch->rightvol > 255)
		ch->rightvol = 255;
		
	lscale = snd_scaletable[ch->leftvol >> 3];
	rscale = snd_scaletable[ch->rightvol >> 3];
	sfx = (signed char *)sc->data + ch->pos;

	for (i=0 ; i<count ; i++)
	{
		data = sfx[i];
		paintbuffer[i].left += lscale[data];
		paintbuffer[i].right += rscale[data];
	}
	
	ch->pos += count;
}

#endif	// !id386


void SND_PaintChannelFrom16 (channel_t *ch, sfxcache_t *sc, int count)
{
	int data;
	int left, right;
	int leftvol, rightvol;
	signed short *sfx;
	int	i;

	leftvol = ch->leftvol;
	rightvol = ch->rightvol;
	sfx = (signed short *)sc->data + ch->pos;

	for (i=0 ; i<count ; i++)
	{
		data = sfx[i];
		left = (data * leftvol) >> 8;
		right = (data * rightvol) >> 8;
		paintbuffer[i].left += left;
		paintbuffer[i].right += right;
	}

	ch->pos += count;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\spritegn.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// spritegn.h: header file for sprite generation program
//

// **********************************************************
// * This file must be identical in the spritegen directory *
// * and in the Quake directory, because it's used to       *
// * pass data from one to the other via .spr files.        *
// **********************************************************

//-------------------------------------------------------
// This program generates .spr sprite package files.
// The format of the files is as follows:
//
// dsprite_t file header structure
// <repeat dsprite_t.numframes times>
//   <if spritegroup, repeat dspritegroup_t.numframes times>
//     dspriteframe_t frame header structure
//     sprite bitmap
//   <else (single sprite frame)>
//     dspriteframe_t frame header structure
//     sprite bitmap
// <endrepeat>
//-------------------------------------------------------

#ifdef INCLUDELIBS

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include "cmdlib.h"
#include "scriplib.h"
#include "dictlib.h"
#include "trilib.h"
#include "lbmlib.h"
#include "mathlib.h"

#endif

#define SPRITE_VERSION	1

// must match definition in modelgen.h
#ifndef SYNCTYPE_T
#define SYNCTYPE_T
typedef enum {ST_SYNC=0, ST_RAND } synctype_t;
#endif

// TODO: shorten these?
typedef struct {
	int			ident;
	int			version;
	int			type;
	float		boundingradius;
	int			width;
	int			height;
	int			numframes;
	float		beamlength;
	synctype_t	synctype;
} dsprite_t;

#define SPR_VP_PARALLEL_UPRIGHT		0
#define SPR_FACING_UPRIGHT			1
#define SPR_VP_PARALLEL				2
#define SPR_ORIENTED				3
#define SPR_VP_PARALLEL_ORIENTED	4

typedef struct {
	int			origin[2];
	int			width;
	int			height;
} dspriteframe_t;

typedef struct {
	int			numframes;
} dspritegroup_t;

typedef struct {
	float	interval;
} dspriteinterval_t;

typedef enum { SPR_SINGLE=0, SPR_GROUP } spriteframetype_t;

typedef struct {
	spriteframetype_t	type;
} dspriteframetype_t;

#define IDSPRITEHEADER	(('P'<<24)+('S'<<16)+('D'<<8)+'I')
														// little-endian "IDSP"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sound.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sound.h -- client sound i/o functions

#ifndef __SOUND__
#define __SOUND__

#define DEFAULT_SOUND_PACKET_VOLUME 255
#define DEFAULT_SOUND_PACKET_ATTENUATION 1.0

// !!! if this is changed, it much be changed in asm_i386.h too !!!
typedef struct
{
	int left;
	int right;
} portable_samplepair_t;

typedef struct sfx_s
{
	char 	name[MAX_QPATH];
	cache_user_t	cache;
} sfx_t;

// !!! if this is changed, it much be changed in asm_i386.h too !!!
typedef struct
{
	int 	length;
	int 	loopstart;
	int 	speed;
	int 	width;
	int 	stereo;
	byte	data[1];		// variable sized
} sfxcache_t;

typedef struct
{
	qboolean		gamealive;
	qboolean		soundalive;
	qboolean		splitbuffer;
	int				channels;
	int				samples;				// mono samples in buffer
	int				submission_chunk;		// don't mix less than this #
	int				samplepos;				// in mono samples
	int				samplebits;
	int				speed;
	unsigned char	*buffer;
} dma_t;

// !!! if this is changed, it much be changed in asm_i386.h too !!!
typedef struct
{
	sfx_t	*sfx;			// sfx number
	int		leftvol;		// 0-255 volume
	int		rightvol;		// 0-255 volume
	int		end;			// end time in global paintsamples
	int 	pos;			// sample position in sfx
	int		looping;		// where to loop, -1 = no looping
	int		entnum;			// to allow overriding a specific sound
	int		entchannel;		//
	vec3_t	origin;			// origin of sound effect
	vec_t	dist_mult;		// distance multiplier (attenuation/clipK)
	int		master_vol;		// 0-255 master volume
} channel_t;

typedef struct
{
	int		rate;
	int		width;
	int		channels;
	int		loopstart;
	int		samples;
	int		dataofs;		// chunk starts this many bytes from file start
} wavinfo_t;

void S_Init (void);
void S_Startup (void);
void S_Shutdown (void);
void S_StartSound (int entnum, int entchannel, sfx_t *sfx, vec3_t origin, float fvol,  float attenuation);
void S_StaticSound (sfx_t *sfx, vec3_t origin, float vol, float attenuation);
void S_StopSound (int entnum, int entchannel);
void S_StopAllSounds(qboolean clear);
void S_ClearBuffer (void);
void S_Update (vec3_t origin, vec3_t v_forward, vec3_t v_right, vec3_t v_up);
void S_ExtraUpdate (void);

sfx_t *S_PrecacheSound (char *sample);
void S_TouchSound (char *sample);
void S_ClearPrecache (void);
void S_BeginPrecaching (void);
void S_EndPrecaching (void);
void S_PaintChannels(int endtime);
void S_InitPaintChannels (void);

// picks a channel based on priorities, empty slots, number of channels
channel_t *SND_PickChannel(int entnum, int entchannel);

// spatializes a channel
void SND_Spatialize(channel_t *ch);

// initializes cycling through a DMA buffer and returns information on it
qboolean SNDDMA_Init(void);

// gets the current DMA position
int SNDDMA_GetDMAPos(void);

// shutdown the DMA xfer.
void SNDDMA_Shutdown(void);

// ====================================================================
// User-setable variables
// ====================================================================

#define	MAX_CHANNELS			128
#define	MAX_DYNAMIC_CHANNELS	8


extern	channel_t   channels[MAX_CHANNELS];
// 0 to MAX_DYNAMIC_CHANNELS-1	= normal entity sounds
// MAX_DYNAMIC_CHANNELS to MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS -1 = water, etc
// MAX_DYNAMIC_CHANNELS + NUM_AMBIENTS to total_channels = static sounds

extern	int			total_channels;

//
// Fake dma is a synchronous faking of the DMA progress used for
// isolating performance in the renderer.  The fakedma_updates is
// number of times S_Update() is called per second.
//

extern qboolean 		fakedma;
extern int 			fakedma_updates;
extern int		paintedtime;
extern vec3_t listener_origin;
extern vec3_t listener_forward;
extern vec3_t listener_right;
extern vec3_t listener_up;
extern volatile dma_t *shm;
extern volatile dma_t sn;
extern vec_t sound_nominal_clip_dist;

extern	cvar_t loadas8bit;
extern	cvar_t bgmvolume;
extern	cvar_t volume;

extern qboolean	snd_initialized;

extern int		snd_blocked;

void S_LocalSound (char *s);
sfxcache_t *S_LoadSound (sfx_t *s);

wavinfo_t GetWavinfo (char *name, byte *wav, int wavlength);

void SND_InitScaletable (void);
void SNDDMA_Submit(void);

void S_AmbientOff (void);
void S_AmbientOn (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sv_main.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sv_main.c -- server main program

#include "quakedef.h"

server_t		sv;
server_static_t	svs;

char	localmodels[MAX_MODELS][5];			// inline model names for precache

//============================================================================

/*
===============
SV_Init
===============
*/
void SV_Init (void)
{
	int		i;
	extern	cvar_t	sv_maxvelocity;
	extern	cvar_t	sv_gravity;
	extern	cvar_t	sv_nostep;
	extern	cvar_t	sv_friction;
	extern	cvar_t	sv_edgefriction;
	extern	cvar_t	sv_stopspeed;
	extern	cvar_t	sv_maxspeed;
	extern	cvar_t	sv_accelerate;
	extern	cvar_t	sv_idealpitchscale;
	extern	cvar_t	sv_aim;

	Cvar_RegisterVariable (&sv_maxvelocity);
	Cvar_RegisterVariable (&sv_gravity);
	Cvar_RegisterVariable (&sv_friction);
	Cvar_RegisterVariable (&sv_edgefriction);
	Cvar_RegisterVariable (&sv_stopspeed);
	Cvar_RegisterVariable (&sv_maxspeed);
	Cvar_RegisterVariable (&sv_accelerate);
	Cvar_RegisterVariable (&sv_idealpitchscale);
	Cvar_RegisterVariable (&sv_aim);
	Cvar_RegisterVariable (&sv_nostep);

	for (i=0 ; i<MAX_MODELS ; i++)
		sprintf (localmodels[i], "*%i", i);
}

/*
=============================================================================

EVENT MESSAGES

=============================================================================
*/

/*  
==================
SV_StartParticle

Make sure the event gets sent to all clients
==================
*/
void SV_StartParticle (vec3_t org, vec3_t dir, int color, int count)
{
	int		i, v;

	if (sv.datagram.cursize > MAX_DATAGRAM-16)
		return;	
	MSG_WriteByte (&sv.datagram, svc_particle);
	MSG_WriteCoord (&sv.datagram, org[0]);
	MSG_WriteCoord (&sv.datagram, org[1]);
	MSG_WriteCoord (&sv.datagram, org[2]);
	for (i=0 ; i<3 ; i++)
	{
		v = dir[i]*16;
		if (v > 127)
			v = 127;
		else if (v < -128)
			v = -128;
		MSG_WriteChar (&sv.datagram, v);
	}
	MSG_WriteByte (&sv.datagram, count);
	MSG_WriteByte (&sv.datagram, color);
}           

/*  
==================
SV_StartSound

Each entity can have eight independant sound sources, like voice,
weapon, feet, etc.

Channel 0 is an auto-allocate channel, the others override anything
allready running on that entity/channel pair.

An attenuation of 0 will play full volume everywhere in the level.
Larger attenuations will drop off.  (max 4 attenuation)

==================
*/  
void SV_StartSound (edict_t *entity, int channel, char *sample, int volume,
    float attenuation)
{       
    int         sound_num;
    int field_mask;
    int			i;
	int			ent;
	
	if (volume < 0 || volume > 255)
		Sys_Error ("SV_StartSound: volume = %i", volume);

	if (attenuation < 0 || attenuation > 4)
		Sys_Error ("SV_StartSound: attenuation = %f", attenuation);

	if (channel < 0 || channel > 7)
		Sys_Error ("SV_StartSound: channel = %i", channel);

	if (sv.datagram.cursize > MAX_DATAGRAM-16)
		return;	

// find precache number for sound
    for (sound_num=1 ; sound_num<MAX_SOUNDS
        && sv.sound_precache[sound_num] ; sound_num++)
        if (!strcmp(sample, sv.sound_precache[sound_num]))
            break;
    
    if ( sound_num == MAX_SOUNDS || !sv.sound_precache[sound_num] )
    {
        Con_Printf ("SV_StartSound: %s not precacheed\n", sample);
        return;
    }
    
	ent = NUM_FOR_EDICT(entity);

	channel = (ent<<3) | channel;

	field_mask = 0;
	if (volume != DEFAULT_SOUND_PACKET_VOLUME)
		field_mask |= SND_VOLUME;
	if (attenuation != DEFAULT_SOUND_PACKET_ATTENUATION)
		field_mask |= SND_ATTENUATION;

// directed messages go only to the entity the are targeted on
	MSG_WriteByte (&sv.datagram, svc_sound);
	MSG_WriteByte (&sv.datagram, field_mask);
	if (field_mask & SND_VOLUME)
		MSG_WriteByte (&sv.datagram, volume);
	if (field_mask & SND_ATTENUATION)
		MSG_WriteByte (&sv.datagram, attenuation*64);
	MSG_WriteShort (&sv.datagram, channel);
	MSG_WriteByte (&sv.datagram, sound_num);
	for (i=0 ; i<3 ; i++)
		MSG_WriteCoord (&sv.datagram, entity->v.origin[i]+0.5*(entity->v.mins[i]+entity->v.maxs[i]));
}           

/*
==============================================================================

CLIENT SPAWNING

==============================================================================
*/

/*
================
SV_SendServerinfo

Sends the first message from the server to a connected client.
This will be sent on the initial connection and upon each server load.
================
*/
void SV_SendServerinfo (client_t *client)
{
	char			**s;
	char			message[2048];

	MSG_WriteByte (&client->message, svc_print);
	sprintf (message, "%c\nVERSION %4.2f SERVER (%i CRC)", 2, VERSION, pr_crc);
	MSG_WriteString (&client->message,message);

	MSG_WriteByte (&client->message, svc_serverinfo);
	MSG_WriteLong (&client->message, PROTOCOL_VERSION);
	MSG_WriteByte (&client->message, svs.maxclients);

	if (!coop.value && deathmatch.value)
		MSG_WriteByte (&client->message, GAME_DEATHMATCH);
	else
		MSG_WriteByte (&client->message, GAME_COOP);

	sprintf (message, pr_strings+sv.edicts->v.message);

	MSG_WriteString (&client->message,message);

	for (s = sv.model_precache+1 ; *s ; s++)
		MSG_WriteString (&client->message, *s);
	MSG_WriteByte (&client->message, 0);

	for (s = sv.sound_precache+1 ; *s ; s++)
		MSG_WriteString (&client->message, *s);
	MSG_WriteByte (&client->message, 0);

// send music
	MSG_WriteByte (&client->message, svc_cdtrack);
	MSG_WriteByte (&client->message, sv.edicts->v.sounds);
	MSG_WriteByte (&client->message, sv.edicts->v.sounds);

// set view	
	MSG_WriteByte (&client->message, svc_setview);
	MSG_WriteShort (&client->message, NUM_FOR_EDICT(client->edict));

	MSG_WriteByte (&client->message, svc_signonnum);
	MSG_WriteByte (&client->message, 1);

	client->sendsignon = true;
	client->spawned = false;		// need prespawn, spawn, etc
}

/*
================
SV_ConnectClient

Initializes a client_t for a new net connection.  This will only be called
once for a player each game, not once for each level change.
================
*/
void SV_ConnectClient (int clientnum)
{
	edict_t			*ent;
	client_t		*client;
	int				edictnum;
	struct qsocket_s *netconnection;
	int				i;
	float			spawn_parms[NUM_SPAWN_PARMS];

	client = svs.clients + clientnum;

	Con_DPrintf ("Client %s connected\n", client->netconnection->address);

	edictnum = clientnum+1;

	ent = EDICT_NUM(edictnum);
	
// set up the client_t
	netconnection = client->netconnection;
	
	if (sv.loadgame)
		memcpy (spawn_parms, client->spawn_parms, sizeof(spawn_parms));
	memset (client, 0, sizeof(*client));
	client->netconnection = netconnection;

	strcpy (client->name, "unconnected");
	client->active = true;
	client->spawned = false;
	client->edict = ent;
	client->message.data = client->msgbuf;
	client->message.maxsize = sizeof(client->msgbuf);
	client->message.allowoverflow = true;		// we can catch it

#ifdef IDGODS
	client->privileged = IsID(&client->netconnection->addr);
#else	
	client->privileged = false;				
#endif

	if (sv.loadgame)
		memcpy (client->spawn_parms, spawn_parms, sizeof(spawn_parms));
	else
	{
	// call the progs to get default spawn parms for the new client
		PR_ExecuteProgram (pr_global_struct->SetNewParms);
		for (i=0 ; i<NUM_SPAWN_PARMS ; i++)
			client->spawn_parms[i] = (&pr_global_struct->parm1)[i];
	}

	SV_SendServerinfo (client);
}


/*
===================
SV_CheckForNewClients

===================
*/
void SV_CheckForNewClients (void)
{
	struct qsocket_s	*ret;
	int				i;
		
//
// check for new connections
//
	while (1)
	{
		ret = NET_CheckNewConnections ();
		if (!ret)
			break;

	// 
	// init a new client structure
	//	
		for (i=0 ; i<svs.maxclients ; i++)
			if (!svs.clients[i].active)
				break;
		if (i == svs.maxclients)
			Sys_Error ("Host_CheckForNewClients: no free clients");
		
		svs.clients[i].netconnection = ret;
		SV_ConnectClient (i);	
	
		net_activeconnections++;
	}
}



/*
===============================================================================

FRAME UPDATES

===============================================================================
*/

/*
==================
SV_ClearDatagram

==================
*/
void SV_ClearDatagram (void)
{
	SZ_Clear (&sv.datagram);
}

/*
=============================================================================

The PVS must include a small area around the client to allow head bobbing
or other small motion on the client side.  Otherwise, a bob might cause an
entity that should be visible to not show up, especially when the bob
crosses a waterline.

=============================================================================
*/

int		fatbytes;
byte	fatpvs[MAX_MAP_LEAFS/8];

void SV_AddToFatPVS (vec3_t org, mnode_t *node)
{
	int		i;
	byte	*pvs;
	mplane_t	*plane;
	float	d;

	while (1)
	{
	// if this is a leaf, accumulate the pvs bits
		if (node->contents < 0)
		{
			if (node->contents != CONTENTS_SOLID)
			{
				pvs = Mod_LeafPVS ( (mleaf_t *)node, sv.worldmodel);
				for (i=0 ; i<fatbytes ; i++)
					fatpvs[i] |= pvs[i];
			}
			return;
		}
	
		plane = node->plane;
		d = DotProduct (org, plane->normal) - plane->dist;
		if (d > 8)
			node = node->children[0];
		else if (d < -8)
			node = node->children[1];
		else
		{	// go down both
			SV_AddToFatPVS (org, node->children[0]);
			node = node->children[1];
		}
	}
}

/*
=============
SV_FatPVS

Calculates a PVS that is the inclusive or of all leafs within 8 pixels of the
given point.
=============
*/
byte *SV_FatPVS (vec3_t org)
{
	fatbytes = (sv.worldmodel->numleafs+31)>>3;
	Q_memset (fatpvs, 0, fatbytes);
	SV_AddToFatPVS (org, sv.worldmodel->nodes);
	return fatpvs;
}

//=============================================================================


/*
=============
SV_WriteEntitiesToClient

=============
*/
void SV_WriteEntitiesToClient (edict_t	*clent, sizebuf_t *msg)
{
	int		e, i;
	int		bits;
	byte	*pvs;
	vec3_t	org;
	float	miss;
	edict_t	*ent;

// find the client's PVS
	VectorAdd (clent->v.origin, clent->v.view_ofs, org);
	pvs = SV_FatPVS (org);

// send over all entities (excpet the client) that touch the pvs
	ent = NEXT_EDICT(sv.edicts);
	for (e=1 ; e<sv.num_edicts ; e++, ent = NEXT_EDICT(ent))
	{
#ifdef QUAKE2
		// don't send if flagged for NODRAW and there are no lighting effects
		if (ent->v.effects == EF_NODRAW)
			continue;
#endif

// ignore if not touching a PV leaf
		if (ent != clent)	// clent is ALLWAYS sent
		{
// ignore ents without visible models
			if (!ent->v.modelindex || !pr_strings[ent->v.model])
				continue;

			for (i=0 ; i < ent->num_leafs ; i++)
				if (pvs[ent->leafnums[i] >> 3] & (1 << (ent->leafnums[i]&7) ))
					break;
				
			if (i == ent->num_leafs)
				continue;		// not visible
		}

		if (msg->maxsize - msg->cursize < 16)
		{
			Con_Printf ("packet overflow\n");
			return;
		}

// send an update
		bits = 0;
		
		for (i=0 ; i<3 ; i++)
		{
			miss = ent->v.origin[i] - ent->baseline.origin[i];
			if ( miss < -0.1 || miss > 0.1 )
				bits |= U_ORIGIN1<<i;
		}

		if ( ent->v.angles[0] != ent->baseline.angles[0] )
			bits |= U_ANGLE1;
			
		if ( ent->v.angles[1] != ent->baseline.angles[1] )
			bits |= U_ANGLE2;
			
		if ( ent->v.angles[2] != ent->baseline.angles[2] )
			bits |= U_ANGLE3;
			
		if (ent->v.movetype == MOVETYPE_STEP)
			bits |= U_NOLERP;	// don't mess up the step animation
	
		if (ent->baseline.colormap != ent->v.colormap)
			bits |= U_COLORMAP;
			
		if (ent->baseline.skin != ent->v.skin)
			bits |= U_SKIN;
			
		if (ent->baseline.frame != ent->v.frame)
			bits |= U_FRAME;
		
		if (ent->baseline.effects != ent->v.effects)
			bits |= U_EFFECTS;
		
		if (ent->baseline.modelindex != ent->v.modelindex)
			bits |= U_MODEL;

		if (e >= 256)
			bits |= U_LONGENTITY;
			
		if (bits >= 256)
			bits |= U_MOREBITS;

	//
	// write the message
	//
		MSG_WriteByte (msg,bits | U_SIGNAL);
		
		if (bits & U_MOREBITS)
			MSG_WriteByte (msg, bits>>8);
		if (bits & U_LONGENTITY)
			MSG_WriteShort (msg,e);
		else
			MSG_WriteByte (msg,e);

		if (bits & U_MODEL)
			MSG_WriteByte (msg,	ent->v.modelindex);
		if (bits & U_FRAME)
			MSG_WriteByte (msg, ent->v.frame);
		if (bits & U_COLORMAP)
			MSG_WriteByte (msg, ent->v.colormap);
		if (bits & U_SKIN)
			MSG_WriteByte (msg, ent->v.skin);
		if (bits & U_EFFECTS)
			MSG_WriteByte (msg, ent->v.effects);
		if (bits & U_ORIGIN1)
			MSG_WriteCoord (msg, ent->v.origin[0]);		
		if (bits & U_ANGLE1)
			MSG_WriteAngle(msg, ent->v.angles[0]);
		if (bits & U_ORIGIN2)
			MSG_WriteCoord (msg, ent->v.origin[1]);
		if (bits & U_ANGLE2)
			MSG_WriteAngle(msg, ent->v.angles[1]);
		if (bits & U_ORIGIN3)
			MSG_WriteCoord (msg, ent->v.origin[2]);
		if (bits & U_ANGLE3)
			MSG_WriteAngle(msg, ent->v.angles[2]);
	}
}

/*
=============
SV_CleanupEnts

=============
*/
void SV_CleanupEnts (void)
{
	int		e;
	edict_t	*ent;
	
	ent = NEXT_EDICT(sv.edicts);
	for (e=1 ; e<sv.num_edicts ; e++, ent = NEXT_EDICT(ent))
	{
		ent->v.effects = (int)ent->v.effects & ~EF_MUZZLEFLASH;
	}

}

/*
==================
SV_WriteClientdataToMessage

==================
*/
void SV_WriteClientdataToMessage (edict_t *ent, sizebuf_t *msg)
{
	int		bits;
	int		i;
	edict_t	*other;
	int		items;
#ifndef QUAKE2
	eval_t	*val;
#endif

//
// send a damage message
//
	if (ent->v.dmg_take || ent->v.dmg_save)
	{
		other = PROG_TO_EDICT(ent->v.dmg_inflictor);
		MSG_WriteByte (msg, svc_damage);
		MSG_WriteByte (msg, ent->v.dmg_save);
		MSG_WriteByte (msg, ent->v.dmg_take);
		for (i=0 ; i<3 ; i++)
			MSG_WriteCoord (msg, other->v.origin[i] + 0.5*(other->v.mins[i] + other->v.maxs[i]));
	
		ent->v.dmg_take = 0;
		ent->v.dmg_save = 0;
	}

//
// send the current viewpos offset from the view entity
//
	SV_SetIdealPitch ();		// how much to look up / down ideally

// a fixangle might get lost in a dropped packet.  Oh well.
	if ( ent->v.fixangle )
	{
		MSG_WriteByte (msg, svc_setangle);
		for (i=0 ; i < 3 ; i++)
			MSG_WriteAngle (msg, ent->v.angles[i] );
		ent->v.fixangle = 0;
	}

	bits = 0;
	
	if (ent->v.view_ofs[2] != DEFAULT_VIEWHEIGHT)
		bits |= SU_VIEWHEIGHT;
		
	if (ent->v.idealpitch)
		bits |= SU_IDEALPITCH;

// stuff the sigil bits into the high bits of items for sbar, or else
// mix in items2
#ifdef QUAKE2
	items = (int)ent->v.items | ((int)ent->v.items2 << 23);
#else
	val = GetEdictFieldValue(ent, "items2");

	if (val)
		items = (int)ent->v.items | ((int)val->_float << 23);
	else
		items = (int)ent->v.items | ((int)pr_global_struct->serverflags << 28);
#endif

	bits |= SU_ITEMS;
	
	if ( (int)ent->v.flags & FL_ONGROUND)
		bits |= SU_ONGROUND;
	
	if ( ent->v.waterlevel >= 2)
		bits |= SU_INWATER;
	
	for (i=0 ; i<3 ; i++)
	{
		if (ent->v.punchangle[i])
			bits |= (SU_PUNCH1<<i);
		if (ent->v.velocity[i])
			bits |= (SU_VELOCITY1<<i);
	}
	
	if (ent->v.weaponframe)
		bits |= SU_WEAPONFRAME;

	if (ent->v.armorvalue)
		bits |= SU_ARMOR;

//	if (ent->v.weapon)
		bits |= SU_WEAPON;

// send the data

	MSG_WriteByte (msg, svc_clientdata);
	MSG_WriteShort (msg, bits);

	if (bits & SU_VIEWHEIGHT)
		MSG_WriteChar (msg, ent->v.view_ofs[2]);

	if (bits & SU_IDEALPITCH)
		MSG_WriteChar (msg, ent->v.idealpitch);

	for (i=0 ; i<3 ; i++)
	{
		if (bits & (SU_PUNCH1<<i))
			MSG_WriteChar (msg, ent->v.punchangle[i]);
		if (bits & (SU_VELOCITY1<<i))
			MSG_WriteChar (msg, ent->v.velocity[i]/16);
	}

// [always sent]	if (bits & SU_ITEMS)
	MSG_WriteLong (msg, items);

	if (bits & SU_WEAPONFRAME)
		MSG_WriteByte (msg, ent->v.weaponframe);
	if (bits & SU_ARMOR)
		MSG_WriteByte (msg, ent->v.armorvalue);
	if (bits & SU_WEAPON)
		MSG_WriteByte (msg, SV_ModelIndex(pr_strings+ent->v.weaponmodel));
	
	MSG_WriteShort (msg, ent->v.health);
	MSG_WriteByte (msg, ent->v.currentammo);
	MSG_WriteByte (msg, ent->v.ammo_shells);
	MSG_WriteByte (msg, ent->v.ammo_nails);
	MSG_WriteByte (msg, ent->v.ammo_rockets);
	MSG_WriteByte (msg, ent->v.ammo_cells);

	if (standard_quake)
	{
		MSG_WriteByte (msg, ent->v.weapon);
	}
	else
	{
		for(i=0;i<32;i++)
		{
			if ( ((int)ent->v.weapon) & (1<<i) )
			{
				MSG_WriteByte (msg, i);
				break;
			}
		}
	}
}

/*
=======================
SV_SendClientDatagram
=======================
*/
qboolean SV_SendClientDatagram (client_t *client)
{
	byte		buf[MAX_DATAGRAM];
	sizebuf_t	msg;
	
	msg.data = buf;
	msg.maxsize = sizeof(buf);
	msg.cursize = 0;

	MSG_WriteByte (&msg, svc_time);
	MSG_WriteFloat (&msg, sv.time);

// add the client specific data to the datagram
	SV_WriteClientdataToMessage (client->edict, &msg);

	SV_WriteEntitiesToClient (client->edict, &msg);

// copy the server datagram if there is space
	if (msg.cursize + sv.datagram.cursize < msg.maxsize)
		SZ_Write (&msg, sv.datagram.data, sv.datagram.cursize);

// send the datagram
	if (NET_SendUnreliableMessage (client->netconnection, &msg) == -1)
	{
		SV_DropClient (true);// if the message couldn't send, kick off
		return false;
	}
	
	return true;
}

/*
=======================
SV_UpdateToReliableMessages
=======================
*/
void SV_UpdateToReliableMessages (void)
{
	int			i, j;
	client_t *client;

// check for changes to be sent over the reliable streams
	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
	{
		if (host_client->old_frags != host_client->edict->v.frags)
		{
			for (j=0, client = svs.clients ; j<svs.maxclients ; j++, client++)
			{
				if (!client->active)
					continue;
				MSG_WriteByte (&client->message, svc_updatefrags);
				MSG_WriteByte (&client->message, i);
				MSG_WriteShort (&client->message, host_client->edict->v.frags);
			}

			host_client->old_frags = host_client->edict->v.frags;
		}
	}
	
	for (j=0, client = svs.clients ; j<svs.maxclients ; j++, client++)
	{
		if (!client->active)
			continue;
		SZ_Write (&client->message, sv.reliable_datagram.data, sv.reliable_datagram.cursize);
	}

	SZ_Clear (&sv.reliable_datagram);
}


/*
=======================
SV_SendNop

Send a nop message without trashing or sending the accumulated client
message buffer
=======================
*/
void SV_SendNop (client_t *client)
{
	sizebuf_t	msg;
	byte		buf[4];
	
	msg.data = buf;
	msg.maxsize = sizeof(buf);
	msg.cursize = 0;

	MSG_WriteChar (&msg, svc_nop);

	if (NET_SendUnreliableMessage (client->netconnection, &msg) == -1)
		SV_DropClient (true);	// if the message couldn't send, kick off
	client->last_message = realtime;
}

/*
=======================
SV_SendClientMessages
=======================
*/
void SV_SendClientMessages (void)
{
	int			i;
	
// update frags, names, etc
	SV_UpdateToReliableMessages ();

// build individual updates
	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
	{
		if (!host_client->active)
			continue;

		if (host_client->spawned)
		{
			if (!SV_SendClientDatagram (host_client))
				continue;
		}
		else
		{
		// the player isn't totally in the game yet
		// send small keepalive messages if too much time has passed
		// send a full message when the next signon stage has been requested
		// some other message data (name changes, etc) may accumulate 
		// between signon stages
			if (!host_client->sendsignon)
			{
				if (realtime - host_client->last_message > 5)
					SV_SendNop (host_client);
				continue;	// don't send out non-signon messages
			}
		}

		// check for an overflowed message.  Should only happen
		// on a very fucked up connection that backs up a lot, then
		// changes level
		if (host_client->message.overflowed)
		{
			SV_DropClient (true);
			host_client->message.overflowed = false;
			continue;
		}
			
		if (host_client->message.cursize || host_client->dropasap)
		{
			if (!NET_CanSendMessage (host_client->netconnection))
			{
//				I_Printf ("can't write\n");
				continue;
			}

			if (host_client->dropasap)
				SV_DropClient (false);	// went to another level
			else
			{
				if (NET_SendMessage (host_client->netconnection
				, &host_client->message) == -1)
					SV_DropClient (true);	// if the message couldn't send, kick off
				SZ_Clear (&host_client->message);
				host_client->last_message = realtime;
				host_client->sendsignon = false;
			}
		}
	}
	
	
// clear muzzle flashes
	SV_CleanupEnts ();
}


/*
==============================================================================

SERVER SPAWNING

==============================================================================
*/

/*
================
SV_ModelIndex

================
*/
int SV_ModelIndex (char *name)
{
	int		i;
	
	if (!name || !name[0])
		return 0;

	for (i=0 ; i<MAX_MODELS && sv.model_precache[i] ; i++)
		if (!strcmp(sv.model_precache[i], name))
			return i;
	if (i==MAX_MODELS || !sv.model_precache[i])
		Sys_Error ("SV_ModelIndex: model %s not precached", name);
	return i;
}

/*
================
SV_CreateBaseline

================
*/
void SV_CreateBaseline (void)
{
	int			i;
	edict_t			*svent;
	int				entnum;	
		
	for (entnum = 0; entnum < sv.num_edicts ; entnum++)
	{
	// get the current server version
		svent = EDICT_NUM(entnum);
		if (svent->free)
			continue;
		if (entnum > svs.maxclients && !svent->v.modelindex)
			continue;

	//
	// create entity baseline
	//
		VectorCopy (svent->v.origin, svent->baseline.origin);
		VectorCopy (svent->v.angles, svent->baseline.angles);
		svent->baseline.frame = svent->v.frame;
		svent->baseline.skin = svent->v.skin;
		if (entnum > 0 && entnum <= svs.maxclients)
		{
			svent->baseline.colormap = entnum;
			svent->baseline.modelindex = SV_ModelIndex("progs/player.mdl");
		}
		else
		{
			svent->baseline.colormap = 0;
			svent->baseline.modelindex =
				SV_ModelIndex(pr_strings + svent->v.model);
		}
		
	//
	// add to the message
	//
		MSG_WriteByte (&sv.signon,svc_spawnbaseline);		
		MSG_WriteShort (&sv.signon,entnum);

		MSG_WriteByte (&sv.signon, svent->baseline.modelindex);
		MSG_WriteByte (&sv.signon, svent->baseline.frame);
		MSG_WriteByte (&sv.signon, svent->baseline.colormap);
		MSG_WriteByte (&sv.signon, svent->baseline.skin);
		for (i=0 ; i<3 ; i++)
		{
			MSG_WriteCoord(&sv.signon, svent->baseline.origin[i]);
			MSG_WriteAngle(&sv.signon, svent->baseline.angles[i]);
		}
	}
}


/*
================
SV_SendReconnect

Tell all the clients that the server is changing levels
================
*/
void SV_SendReconnect (void)
{
	char	data[128];
	sizebuf_t	msg;

	msg.data = data;
	msg.cursize = 0;
	msg.maxsize = sizeof(data);

	MSG_WriteChar (&msg, svc_stufftext);
	MSG_WriteString (&msg, "reconnect\n");
	NET_SendToAll (&msg, 5);
	
	if (cls.state != ca_dedicated)
#ifdef QUAKE2
		Cbuf_InsertText ("reconnect\n");
#else
		Cmd_ExecuteString ("reconnect\n", src_command);
#endif
}


/*
================
SV_SaveSpawnparms

Grabs the current state of each client for saving across the
transition to another level
================
*/
void SV_SaveSpawnparms (void)
{
	int		i, j;

	svs.serverflags = pr_global_struct->serverflags;

	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
	{
		if (!host_client->active)
			continue;

	// call the progs to get default spawn parms for the new client
		pr_global_struct->self = EDICT_TO_PROG(host_client->edict);
		PR_ExecuteProgram (pr_global_struct->SetChangeParms);
		for (j=0 ; j<NUM_SPAWN_PARMS ; j++)
			host_client->spawn_parms[j] = (&pr_global_struct->parm1)[j];
	}
}


/*
================
SV_SpawnServer

This is called at the start of each level
================
*/
extern float		scr_centertime_off;

#ifdef QUAKE2
void SV_SpawnServer (char *server, char *startspot)
#else
void SV_SpawnServer (char *server)
#endif
{
	edict_t		*ent;
	int			i;

	// let's not have any servers with no name
	if (hostname.string[0] == 0)
		Cvar_Set ("hostname", "UNNAMED");
	scr_centertime_off = 0;

	Con_DPrintf ("SpawnServer: %s\n",server);
	svs.changelevel_issued = false;		// now safe to issue another

//
// tell all connected clients that we are going to a new level
//
	if (sv.active)
	{
		SV_SendReconnect ();
	}

//
// make cvars consistant
//
	if (coop.value)
		Cvar_SetValue ("deathmatch", 0);
	current_skill = (int)(skill.value + 0.5);
	if (current_skill < 0)
		current_skill = 0;
	if (current_skill > 3)
		current_skill = 3;

	Cvar_SetValue ("skill", (float)current_skill);
	
//
// set up the new server
//
	Host_ClearMemory ();

	memset (&sv, 0, sizeof(sv));

	strcpy (sv.name, server);
#ifdef QUAKE2
	if (startspot)
		strcpy(sv.startspot, startspot);
#endif

// load progs to get entity field count
	PR_LoadProgs ();

// allocate server memory
	sv.max_edicts = MAX_EDICTS;
	
	sv.edicts = Hunk_AllocName (sv.max_edicts*pr_edict_size, "edicts");

	sv.datagram.maxsize = sizeof(sv.datagram_buf);
	sv.datagram.cursize = 0;
	sv.datagram.data = sv.datagram_buf;
	
	sv.reliable_datagram.maxsize = sizeof(sv.reliable_datagram_buf);
	sv.reliable_datagram.cursize = 0;
	sv.reliable_datagram.data = sv.reliable_datagram_buf;
	
	sv.signon.maxsize = sizeof(sv.signon_buf);
	sv.signon.cursize = 0;
	sv.signon.data = sv.signon_buf;
	
// leave slots at start for clients only
	sv.num_edicts = svs.maxclients+1;
	for (i=0 ; i<svs.maxclients ; i++)
	{
		ent = EDICT_NUM(i+1);
		svs.clients[i].edict = ent;
	}
	
	sv.state = ss_loading;
	sv.paused = false;

	sv.time = 1.0;
	
	strcpy (sv.name, server);
	sprintf (sv.modelname,"maps/%s.bsp", server);
	sv.worldmodel = Mod_ForName (sv.modelname, false);
	if (!sv.worldmodel)
	{
		Con_Printf ("Couldn't spawn server %s\n", sv.modelname);
		sv.active = false;
		return;
	}
	sv.models[1] = sv.worldmodel;
	
//
// clear world interaction links
//
	SV_ClearWorld ();
	
	sv.sound_precache[0] = pr_strings;

	sv.model_precache[0] = pr_strings;
	sv.model_precache[1] = sv.modelname;
	for (i=1 ; i<sv.worldmodel->numsubmodels ; i++)
	{
		sv.model_precache[1+i] = localmodels[i];
		sv.models[i+1] = Mod_ForName (localmodels[i], false);
	}

//
// load the rest of the entities
//	
	ent = EDICT_NUM(0);
	memset (&ent->v, 0, progs->entityfields * 4);
	ent->free = false;
	ent->v.model = sv.worldmodel->name - pr_strings;
	ent->v.modelindex = 1;		// world model
	ent->v.solid = SOLID_BSP;
	ent->v.movetype = MOVETYPE_PUSH;

	if (coop.value)
		pr_global_struct->coop = coop.value;
	else
		pr_global_struct->deathmatch = deathmatch.value;

	pr_global_struct->mapname = sv.name - pr_strings;
#ifdef QUAKE2
	pr_global_struct->startspot = sv.startspot - pr_strings;
#endif

// serverflags are for cross level information (sigils)
	pr_global_struct->serverflags = svs.serverflags;
	
	ED_LoadFromFile (sv.worldmodel->entities);

	sv.active = true;

// all setup is completed, any further precache statements are errors
	sv.state = ss_active;
	
// run two frames to allow everything to settle
	host_frametime = 0.1;
	SV_Physics ();
	SV_Physics ();

// create a baseline for more efficient communications
	SV_CreateBaseline ();

// send serverinfo to all connected clients
	for (i=0,host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
		if (host_client->active)
			SV_SendServerinfo (host_client);
	
	Con_DPrintf ("Server spawned.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\snd_win.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#include "quakedef.h"
#include "xquake.h"

typedef enum {SIS_SUCCESS, SIS_FAILURE, SIS_NOTAVAIL} sndinitstat;

static qboolean	dsound_init;
static qboolean	snd_firsttime = true, snd_isdirect;
static qboolean	primary_format_set;

static int	sample16;
static int	snd_sent, snd_completed;


/* 
 * Global variables. Must be visible to window-procedure function 
 *  so it can unlock and free the data block after it has been played. 
 */ 

DWORD	gSndBufSize;

LPDIRECTSOUND pDS;
LPDIRECTSOUNDBUFFER pDSBuf;

qboolean SNDDMA_InitDirect (void);


/*
==================
S_BlockSound
==================
*/
void S_BlockSound (void)
{
}


/*
==================
S_UnblockSound
==================
*/
void S_UnblockSound (void)
{
}


/*
==================
FreeSound
==================
*/
void FreeSound (void)
{
	int		i;

	if (pDSBuf)
	{
		IDirectSoundBuffer_Release(pDSBuf);
	}

	if (pDS)
	{
		IDirectSound_Release(pDS);
	}

	pDS = NULL;
	pDSBuf = NULL;
	dsound_init = false;
}


/*
==================
SNDDMA_InitDirect

Direct-Sound support
==================
*/
sndinitstat SNDDMA_InitDirect (void)
{
	DSBUFFERDESC	dsbuf;
	WAVEFORMATEX	format, pformat; 
	HRESULT			hresult;
	int				reps;

	memset ((void *)&sn, 0, sizeof (sn));

	shm = &sn;

	shm->channels = 2;
	shm->samplebits = 16;
	shm->speed = 11025;

	memset (&format, 0, sizeof(format));
	format.wFormatTag = WAVE_FORMAT_PCM;
    format.nChannels = (unsigned short)shm->channels;
    format.wBitsPerSample = (unsigned short)shm->samplebits;
    format.nSamplesPerSec = shm->speed;
    format.nBlockAlign = format.nChannels
		*format.wBitsPerSample / 8;
    format.cbSize = 0;
    format.nAvgBytesPerSec = format.nSamplesPerSec
		*format.nBlockAlign; 

    Con_SafePrintf("Initializing DirectSound\n");

	while ((hresult = DirectSoundCreate(0, &pDS, NULL)) != DS_OK)
	{
    	Con_SafePrintf("DirectSound creation failure");

		return SIS_FAILURE;
	}

#ifndef _XBOX
	if (DS_OK != IDirectSound_SetCooperativeLevel (pDS, mainwindow, DSSCL_EXCLUSIVE))
	{
		Con_SafePrintf ("Set coop level failed\n");
		FreeSound ();
		return SIS_FAILURE;
	}

#endif
	// create the secondary buffer we'll actually work with
	memset (&dsbuf, 0, sizeof(dsbuf));
	dsbuf.dwSize = sizeof(DSBUFFERDESC);
	dsbuf.dwBufferBytes = 0x8000;
	dsbuf.lpwfxFormat = &format;

	if (DS_OK != IDirectSound_CreateSoundBuffer(pDS, &dsbuf, &pDSBuf, NULL))
	{
		Con_SafePrintf ("DS:CreateSoundBuffer Failed");
		FreeSound ();
		return SIS_FAILURE;
	}

	shm->channels = format.nChannels;
	shm->samplebits = format.wBitsPerSample;
	shm->speed = format.nSamplesPerSec;

	if (snd_firsttime)
		Con_SafePrintf ("Using secondary sound buffer\n");

	// Make sure mixer is active
	if (snd_firsttime)
		Con_SafePrintf("   %d channel(s)\n"
		               "   %d bits/sample\n"
					   "   %d bytes/sec\n",
					   shm->channels, shm->samplebits, shm->speed);

    
	gSndBufSize = dsbuf.dwBufferBytes;

	IDirectSoundBuffer_Play(pDSBuf, 0, 0, DSBPLAY_LOOPING);

	shm->soundalive = true;
	shm->splitbuffer = false;
	shm->samples = gSndBufSize/(shm->samplebits/8);
	shm->samplepos = 0;
	shm->submission_chunk = 1;
	shm->buffer = NULL;
	sample16 = (shm->samplebits/8) - 1;

	dsound_init = true;

	return SIS_SUCCESS;
}


/*
==================
SNDDMA_Init

Try to find a sound device to mix for.
Returns false if nothing is found.
==================
*/

// #define DISABLE_SOUND

int SNDDMA_Init(void)
{
#ifdef DISABLE_SOUND
	dsound_init = 0;
	snd_firsttime = false;
	Con_SafePrintf ("Sound disabled.\n");

	return 0;
#else

	sndinitstat	stat;

	dsound_init = 0;

	stat = SIS_FAILURE;	// assume DirectSound won't initialize

	/* Init DirectSound */
	if (snd_firsttime || snd_isdirect)
	{
		stat = SNDDMA_InitDirect ();;

		if (stat == SIS_SUCCESS)
		{
			snd_isdirect = true;

			if (snd_firsttime)
				Con_SafePrintf ("DirectSound initialized\n");
		}
		else
		{
			snd_isdirect = false;
			Con_SafePrintf ("DirectSound failed to init\n");
		}
	}

	if (!dsound_init)
	{
		if (snd_firsttime)
			Con_SafePrintf ("No sound device initialized\n");

		return 0;
	}

	return 1;
#endif
}

/*
==============
SNDDMA_GetDMAPos

return the current sample position (in mono samples read)
inside the recirculating dma buffer, so the mixing code will know
how many sample are required to fill it up.
===============
*/
int SNDDMA_GetDMAPos(void)
{
    int s = 0;

	if (dsound_init) 
	{
		IDirectSoundBuffer_GetCurrentPosition(pDSBuf, &s, NULL);
	}

	s >>= sample16;

	s &= (shm->samples-1);

	return s;
}

/*
==============
SNDDMA_Submit

Send sound to device if buffer isn't really the dma buffer
===============
*/
void SNDDMA_Submit(void)
{
}

/*
==============
SNDDMA_Shutdown

Reset the sound device for exiting
===============
*/
void SNDDMA_Shutdown(void)
{
	FreeSound ();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sv_move.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sv_move.c -- monster movement

#include "quakedef.h"

#define	STEPSIZE	18

/*
=============
SV_CheckBottom

Returns false if any part of the bottom of the entity is off an edge that
is not a staircase.

=============
*/
int c_yes, c_no;

qboolean SV_CheckBottom (edict_t *ent)
{
	vec3_t	mins, maxs, start, stop;
	trace_t	trace;
	int		x, y;
	float	mid, bottom;
	
	VectorAdd (ent->v.origin, ent->v.mins, mins);
	VectorAdd (ent->v.origin, ent->v.maxs, maxs);

// if all of the points under the corners are solid world, don't bother
// with the tougher checks
// the corners must be within 16 of the midpoint
	start[2] = mins[2] - 1;
	for	(x=0 ; x<=1 ; x++)
		for	(y=0 ; y<=1 ; y++)
		{
			start[0] = x ? maxs[0] : mins[0];
			start[1] = y ? maxs[1] : mins[1];
			if (SV_PointContents (start) != CONTENTS_SOLID)
				goto realcheck;
		}

	c_yes++;
	return true;		// we got out easy

realcheck:
	c_no++;
//
// check it for real...
//
	start[2] = mins[2];
	
// the midpoint must be within 16 of the bottom
	start[0] = stop[0] = (mins[0] + maxs[0])*0.5;
	start[1] = stop[1] = (mins[1] + maxs[1])*0.5;
	stop[2] = start[2] - 2*STEPSIZE;
	trace = SV_Move (start, vec3_origin, vec3_origin, stop, true, ent);

	if (trace.fraction == 1.0)
		return false;
	mid = bottom = trace.endpos[2];
	
// the corners must be within 16 of the midpoint	
	for	(x=0 ; x<=1 ; x++)
		for	(y=0 ; y<=1 ; y++)
		{
			start[0] = stop[0] = x ? maxs[0] : mins[0];
			start[1] = stop[1] = y ? maxs[1] : mins[1];
			
			trace = SV_Move (start, vec3_origin, vec3_origin, stop, true, ent);
			
			if (trace.fraction != 1.0 && trace.endpos[2] > bottom)
				bottom = trace.endpos[2];
			if (trace.fraction == 1.0 || mid - trace.endpos[2] > STEPSIZE)
				return false;
		}

	c_yes++;
	return true;
}


/*
=============
SV_movestep

Called by monster program code.
The move will be adjusted for slopes and stairs, but if the move isn't
possible, no move is done, false is returned, and
pr_global_struct->trace_normal is set to the normal of the blocking wall
=============
*/
qboolean SV_movestep (edict_t *ent, vec3_t move, qboolean relink)
{
	float		dz;
	vec3_t		oldorg, neworg, end;
	trace_t		trace;
	int			i;
	edict_t		*enemy;

// try the move	
	VectorCopy (ent->v.origin, oldorg);
	VectorAdd (ent->v.origin, move, neworg);

// flying monsters don't step up
	if ( (int)ent->v.flags & (FL_SWIM | FL_FLY) )
	{
	// try one move with vertical motion, then one without
		for (i=0 ; i<2 ; i++)
		{
			VectorAdd (ent->v.origin, move, neworg);
			enemy = PROG_TO_EDICT(ent->v.enemy);
			if (i == 0 && enemy != sv.edicts)
			{
				dz = ent->v.origin[2] - PROG_TO_EDICT(ent->v.enemy)->v.origin[2];
				if (dz > 40)
					neworg[2] -= 8;
				if (dz < 30)
					neworg[2] += 8;
			}
			trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, neworg, false, ent);
	
			if (trace.fraction == 1)
			{
				if ( ((int)ent->v.flags & FL_SWIM) && SV_PointContents(trace.endpos) == CONTENTS_EMPTY )
					return false;	// swim monster left water
	
				VectorCopy (trace.endpos, ent->v.origin);
				if (relink)
					SV_LinkEdict (ent, true);
				return true;
			}
			
			if (enemy == sv.edicts)
				break;
		}
		
		return false;
	}

// push down from a step height above the wished position
	neworg[2] += STEPSIZE;
	VectorCopy (neworg, end);
	end[2] -= STEPSIZE*2;

	trace = SV_Move (neworg, ent->v.mins, ent->v.maxs, end, false, ent);

	if (trace.allsolid)
		return false;

	if (trace.startsolid)
	{
		neworg[2] -= STEPSIZE;
		trace = SV_Move (neworg, ent->v.mins, ent->v.maxs, end, false, ent);
		if (trace.allsolid || trace.startsolid)
			return false;
	}
	if (trace.fraction == 1)
	{
	// if monster had the ground pulled out, go ahead and fall
		if ( (int)ent->v.flags & FL_PARTIALGROUND )
		{
			VectorAdd (ent->v.origin, move, ent->v.origin);
			if (relink)
				SV_LinkEdict (ent, true);
			ent->v.flags = (int)ent->v.flags & ~FL_ONGROUND;
//	Con_Printf ("fall down\n"); 
			return true;
		}
	
		return false;		// walked off an edge
	}

// check point traces down for dangling corners
	VectorCopy (trace.endpos, ent->v.origin);
	
	if (!SV_CheckBottom (ent))
	{
		if ( (int)ent->v.flags & FL_PARTIALGROUND )
		{	// entity had floor mostly pulled out from underneath it
			// and is trying to correct
			if (relink)
				SV_LinkEdict (ent, true);
			return true;
		}
		VectorCopy (oldorg, ent->v.origin);
		return false;
	}

	if ( (int)ent->v.flags & FL_PARTIALGROUND )
	{
//		Con_Printf ("back on ground\n"); 
		ent->v.flags = (int)ent->v.flags & ~FL_PARTIALGROUND;
	}
	ent->v.groundentity = EDICT_TO_PROG(trace.ent);

// the move is ok
	if (relink)
		SV_LinkEdict (ent, true);
	return true;
}


//============================================================================

/*
======================
SV_StepDirection

Turns to the movement direction, and walks the current distance if
facing it.

======================
*/
void PF_changeyaw (void);
qboolean SV_StepDirection (edict_t *ent, float yaw, float dist)
{
	vec3_t		move, oldorigin;
	float		delta;
	
	ent->v.ideal_yaw = yaw;
	PF_changeyaw();
	
	yaw = yaw*M_PI*2 / 360;
	move[0] = cos(yaw)*dist;
	move[1] = sin(yaw)*dist;
	move[2] = 0;

	VectorCopy (ent->v.origin, oldorigin);
	if (SV_movestep (ent, move, false))
	{
		delta = ent->v.angles[YAW] - ent->v.ideal_yaw;
		if (delta > 45 && delta < 315)
		{		// not turned far enough, so don't take the step
			VectorCopy (oldorigin, ent->v.origin);
		}
		SV_LinkEdict (ent, true);
		return true;
	}
	SV_LinkEdict (ent, true);
		
	return false;
}

/*
======================
SV_FixCheckBottom

======================
*/
void SV_FixCheckBottom (edict_t *ent)
{
//	Con_Printf ("SV_FixCheckBottom\n");
	
	ent->v.flags = (int)ent->v.flags | FL_PARTIALGROUND;
}



/*
================
SV_NewChaseDir

================
*/
#define	DI_NODIR	-1
void SV_NewChaseDir (edict_t *actor, edict_t *enemy, float dist)
{
	float		deltax,deltay;
	float			d[3];
	float		tdir, olddir, turnaround;

	olddir = anglemod( (int)(actor->v.ideal_yaw/45)*45 );
	turnaround = anglemod(olddir - 180);

	deltax = enemy->v.origin[0] - actor->v.origin[0];
	deltay = enemy->v.origin[1] - actor->v.origin[1];
	if (deltax>10)
		d[1]= 0;
	else if (deltax<-10)
		d[1]= 180;
	else
		d[1]= DI_NODIR;
	if (deltay<-10)
		d[2]= 270;
	else if (deltay>10)
		d[2]= 90;
	else
		d[2]= DI_NODIR;

// try direct route
	if (d[1] != DI_NODIR && d[2] != DI_NODIR)
	{
		if (d[1] == 0)
			tdir = d[2] == 90 ? 45 : 315;
		else
			tdir = d[2] == 90 ? 135 : 215;
			
		if (tdir != turnaround && SV_StepDirection(actor, tdir, dist))
			return;
	}

// try other directions
	if ( ((rand()&3) & 1) ||  abs(deltay)>abs(deltax))
	{
		tdir=d[1];
		d[1]=d[2];
		d[2]=tdir;
	}

	if (d[1]!=DI_NODIR && d[1]!=turnaround 
	&& SV_StepDirection(actor, d[1], dist))
			return;

	if (d[2]!=DI_NODIR && d[2]!=turnaround
	&& SV_StepDirection(actor, d[2], dist))
			return;

/* there is no direct path to the player, so pick another direction */

	if (olddir!=DI_NODIR && SV_StepDirection(actor, olddir, dist))
			return;

	if (rand()&1) 	/*randomly determine direction of search*/
	{
		for (tdir=0 ; tdir<=315 ; tdir += 45)
			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
					return;
	}
	else
	{
		for (tdir=315 ; tdir >=0 ; tdir -= 45)
			if (tdir!=turnaround && SV_StepDirection(actor, tdir, dist) )
					return;
	}

	if (turnaround != DI_NODIR && SV_StepDirection(actor, turnaround, dist) )
			return;

	actor->v.ideal_yaw = olddir;		// can't move

// if a bridge was pulled out from underneath a monster, it may not have
// a valid standing position at all

	if (!SV_CheckBottom (actor))
		SV_FixCheckBottom (actor);

}

/*
======================
SV_CloseEnough

======================
*/
qboolean SV_CloseEnough (edict_t *ent, edict_t *goal, float dist)
{
	int		i;
	
	for (i=0 ; i<3 ; i++)
	{
		if (goal->v.absmin[i] > ent->v.absmax[i] + dist)
			return false;
		if (goal->v.absmax[i] < ent->v.absmin[i] - dist)
			return false;
	}
	return true;
}

/*
======================
SV_MoveToGoal

======================
*/
void SV_MoveToGoal (void)
{
	edict_t		*ent, *goal;
	float		dist;
#ifdef QUAKE2
	edict_t		*enemy;
#endif

	ent = PROG_TO_EDICT(pr_global_struct->self);
	goal = PROG_TO_EDICT(ent->v.goalentity);
	dist = G_FLOAT(OFS_PARM0);

	if ( !( (int)ent->v.flags & (FL_ONGROUND|FL_FLY|FL_SWIM) ) )
	{
		G_FLOAT(OFS_RETURN) = 0;
		return;
	}

// if the next step hits the enemy, return immediately
#ifdef QUAKE2
	enemy = PROG_TO_EDICT(ent->v.enemy);
	if (enemy != sv.edicts &&  SV_CloseEnough (ent, enemy, dist) )
#else
	if ( PROG_TO_EDICT(ent->v.enemy) != sv.edicts &&  SV_CloseEnough (ent, goal, dist) )
#endif
		return;

// bump around...
	if ( (rand()&3)==1 ||
	!SV_StepDirection (ent, ent->v.ideal_yaw, dist))
	{
		SV_NewChaseDir (ent, goal, dist);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\snd_mem.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// snd_mem.c: sound caching

#include "quakedef.h"

int			cache_full_cycle;

byte *S_Alloc (int size);

/*
================
ResampleSfx
================
*/
void ResampleSfx (sfx_t *sfx, int inrate, int inwidth, byte *data)
{
	int		outcount;
	int		srcsample;
	float	stepscale;
	int		i;
	int		sample, samplefrac, fracstep;
	sfxcache_t	*sc;
	
	sc = Cache_Check (&sfx->cache);
	if (!sc)
		return;

	stepscale = (float)inrate / shm->speed;	// this is usually 0.5, 1, or 2

	outcount = sc->length / stepscale;
	sc->length = outcount;
	if (sc->loopstart != -1)
		sc->loopstart = sc->loopstart / stepscale;

	sc->speed = shm->speed;
	if (loadas8bit.value)
		sc->width = 1;
	else
		sc->width = inwidth;
	sc->stereo = 0;

// resample / decimate to the current source rate

	if (stepscale == 1 && inwidth == 1 && sc->width == 1)
	{
// fast special case
		for (i=0 ; i<outcount ; i++)
			((signed char *)sc->data)[i]
			= (int)( (unsigned char)(data[i]) - 128);
	}
	else
	{
// general case
		samplefrac = 0;
		fracstep = stepscale*256;
		for (i=0 ; i<outcount ; i++)
		{
			srcsample = samplefrac >> 8;
			samplefrac += fracstep;
			if (inwidth == 2)
				sample = LittleShort ( ((short *)data)[srcsample] );
			else
				sample = (int)( (unsigned char)(data[srcsample]) - 128) << 8;
			if (sc->width == 2)
				((short *)sc->data)[i] = (short)sample;
			else
				((signed char *)sc->data)[i] = sample >> 8;
		}
	}
}

//=============================================================================

/*
==============
S_LoadSound
==============
*/
sfxcache_t *S_LoadSound (sfx_t *s)
{
    char	namebuffer[256];
	byte	*data;
	wavinfo_t	info;
	int		len;
	float	stepscale;
	sfxcache_t	*sc;
	byte	stackbuf[1*1024];		// avoid dirtying the cache heap

// see if still in memory
	sc = Cache_Check (&s->cache);
	if (sc)
		return sc;

//Con_Printf ("S_LoadSound: %x\n", (int)stackbuf);
// load it in
    Q_strcpy(namebuffer, "sound/");
    Q_strcat(namebuffer, s->name);

//	Con_Printf ("loading %s\n",namebuffer);

	data = COM_LoadStackFile(namebuffer, stackbuf, sizeof(stackbuf));

	if (!data)
	{
		Con_Printf ("Couldn't load %s\n", namebuffer);
		return NULL;
	}

	info = GetWavinfo (s->name, data, com_filesize);
	if (info.channels != 1)
	{
		Con_Printf ("%s is a stereo sample\n",s->name);
		return NULL;
	}

	stepscale = (float)info.rate / shm->speed;	
	len = info.samples / stepscale;

	len = len * info.width * info.channels;

	sc = Cache_Alloc ( &s->cache, len + sizeof(sfxcache_t), s->name);
	if (!sc)
		return NULL;
	
	sc->length = info.samples;
	sc->loopstart = info.loopstart;
	sc->speed = info.rate;
	sc->width = info.width;
	sc->stereo = info.channels;

	ResampleSfx (s, sc->speed, sc->width, data + info.dataofs);

	return sc;
}



/*
===============================================================================

WAV loading

===============================================================================
*/


byte	*data_p;
byte 	*iff_end;
byte 	*last_chunk;
byte 	*iff_data;
int 	iff_chunk_len;


short GetLittleShort(void)
{
	short val = 0;
	val = *data_p;
	val = val + (*(data_p+1)<<8);
	data_p += 2;
	return val;
}

int GetLittleLong(void)
{
	int val = 0;
	val = *data_p;
	val = val + (*(data_p+1)<<8);
	val = val + (*(data_p+2)<<16);
	val = val + (*(data_p+3)<<24);
	data_p += 4;
	return val;
}

void FindNextChunk(char *name)
{
	while (1)
	{
		data_p=last_chunk;

		if (data_p >= iff_end)
		{	// didn't find the chunk
			data_p = NULL;
			return;
		}
		
		data_p += 4;
		iff_chunk_len = GetLittleLong();
		if (iff_chunk_len < 0)
		{
			data_p = NULL;
			return;
		}
//		if (iff_chunk_len > 1024*1024)
//			Sys_Error ("FindNextChunk: %i length is past the 1 meg sanity limit", iff_chunk_len);
		data_p -= 8;
		last_chunk = data_p + 8 + ( (iff_chunk_len + 1) & ~1 );
		if (!Q_strncmp(data_p, name, 4))
			return;
	}
}

void FindChunk(char *name)
{
	last_chunk = iff_data;
	FindNextChunk (name);
}


void DumpChunks(void)
{
	char	str[5];
	
	str[4] = 0;
	data_p=iff_data;
	do
	{
		memcpy (str, data_p, 4);
		data_p += 4;
		iff_chunk_len = GetLittleLong();
		Con_Printf ("0x%x : %s (%d)\n", (int)(data_p - 4), str, iff_chunk_len);
		data_p += (iff_chunk_len + 1) & ~1;
	} while (data_p < iff_end);
}

/*
============
GetWavinfo
============
*/
wavinfo_t GetWavinfo (char *name, byte *wav, int wavlength)
{
	wavinfo_t	info;
	int     i;
	int     format;
	int		samples;

	memset (&info, 0, sizeof(info));

	if (!wav)
		return info;
		
	iff_data = wav;
	iff_end = wav + wavlength;

// find "RIFF" chunk
	FindChunk("RIFF");
	if (!(data_p && !Q_strncmp(data_p+8, "WAVE", 4)))
	{
		Con_Printf("Missing RIFF/WAVE chunks\n");
		return info;
	}

// get "fmt " chunk
	iff_data = data_p + 12;
// DumpChunks ();

	FindChunk("fmt ");
	if (!data_p)
	{
		Con_Printf("Missing fmt chunk\n");
		return info;
	}
	data_p += 8;
	format = GetLittleShort();
	if (format != 1)
	{
		Con_Printf("Microsoft PCM format only\n");
		return info;
	}

	info.channels = GetLittleShort();
	info.rate = GetLittleLong();
	data_p += 4+2;
	info.width = GetLittleShort() / 8;

// get cue chunk
	FindChunk("cue ");
	if (data_p)
	{
		data_p += 32;
		info.loopstart = GetLittleLong();
//		Con_Printf("loopstart=%d\n", sfx->loopstart);

	// if the next chunk is a LIST chunk, look for a cue length marker
		FindNextChunk ("LIST");
		if (data_p)
		{
			if (!strncmp (data_p + 28, "mark", 4))
			{	// this is not a proper parse, but it works with cooledit...
				data_p += 24;
				i = GetLittleLong ();	// samples in loop
				info.samples = info.loopstart + i;
//				Con_Printf("looped length: %i\n", i);
			}
		}
	}
	else
		info.loopstart = -1;

// find data chunk
	FindChunk("data");
	if (!data_p)
	{
		Con_Printf("Missing data chunk\n");
		return info;
	}

	data_p += 4;
	samples = GetLittleLong () / info.width;

	if (info.samples)
	{
		if (samples < info.samples)
			Sys_Error ("Sound %s has a bad loop length", name);
	}
	else
		info.samples = samples;

	info.dataofs = data_p - wav;
	
	return info;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sources.inc ===
TARGETNAME=XQuake$(LIBEXT)
TARGETTYPE=PROGRAM
TARGETPATH=obj

# PERFFLAGS=/fastcap

# Optimize for speed

!if "$(MSC_OPTIMIZATION)"==""
MSC_OPTIMIZATION=/Ox
!endif

INCLUDES=$(INCLUDES);..

SOURCES = \
	cd_win.c \
	chase.c \
	cl_demo.c \
	cl_input.c \
	cl_main.c \
	cl_parse.c \
	cl_tent.c \
	cmd.c \
	common.c \
	console.c \
	crc.c \
	cvar.c \
	gl_draw.c \
	gl_fakegl.cpp \
	gl_mesh.c \
	gl_model.c \
	gl_refrag.c \
	gl_rlight.c \
	gl_rmain.c \
	gl_rmisc.c \
	gl_rsurf.c \
	gl_screen.c \
	gl_test.c \
	gl_vidnt.c \
	gl_warp.c \
	host.c \
	host_cmd.c \
	in_win.c \
	in_xbox.cpp \
	keys.c \
	mathlib.c \
	menu.c \
	net_dgrm.c \
	net_loop.c \
	net_main.c \
	net_vcr.c \
	net_win.c \
	net_wins.c \
	pr_cmds.c \
	pr_edict.c \
	pr_exec.c \
	r_part.c \
	sbar.c \
	snd_dma.c \
	snd_mem.c \
	snd_mix.c \
	snd_win.c \
	sv_main.c \
	sv_move.c \
	sv_phys.c \
	sv_user.c \
	sys_win.c \
	view.c \
	wad.c \
	world.c \
	xgc.cpp \
	zone.c \
    dmusic.cpp \

C_DEFINES= $(C_DEFINES) -DNO_ASSEMBLY -DNO_MGRAPH -DGLQUAKE -DD3DQUAKE

UMTYPE=xboxapp

USE_LIBCMT=1

INCLUDES=$(INCLUDES);$(BASEDIR)\private\inc

LINKER_FLAGS=$(LINKER_FLAGS) -map
XE_FLAGS=$(XE_FLAGS) -NOPRELOAD:XNET

LINKLIBS=\
    $(LIBRARY_PATH)\d3d8$(LIBEXT).lib \
    $(LIBRARY_PATH)\d3dx8$(D).lib \
    $(LIBRARY_PATH)\dsound$(D).lib \
    $(LIBRARY_PATH)\xnet$(D).lib \
    $(LIBRARY_PATH)\xgraphics$(D).lib \
    $(XDK_LIB_PATH)\xbdm.lib \

# Allow Debug Keyboard support

C_DEFINES=$(C_DEFINES) -DDEBUG_KEYBOARD

LINKLIBS=$(LINKLIBS) \
    $(LIBRARY_PATH)\xkbd$(D).lib \

# XQUAKE_DMUSIC tests DMUSIC overhead

!if defined(XQUAKE_DMUSIC)

C_DEFINES=$(C_DEFINES) -DXQUAKE_DMUSIC

LINKLIBS=$(LINKLIBS) \
	$(LIBRARY_PATH)\dmusic$(LIBEXT).lib \

!endif

# XQUAKE_WMA tests WMA overhead

!if defined(XQUAKE_WMA)

C_DEFINES=$(C_DEFINES) -DXQUAKE_WMA

SOURCES=\
	$(SOURCES) \
    wma.cpp \

!endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sys_win.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sys_win.c -- Win32 system interface code

#include "quakedef.h"
#include "xquake.h"
#include "errno.h"

#define MINIMUM_WIN_MEMORY		0x0880000
#define MAXIMUM_WIN_MEMORY		0x1000000

#define CONSOLE_ERROR_TIMEOUT	60.0	// # of seconds to wait on Sys_Error running
										//  dedicated before exiting
#define PAUSE_SLEEP		50				// sleep time on pause or minimization
#define NOT_FOCUS_SLEEP	20				// sleep time when not focus

int			starttime;
qboolean	ActiveApp, Minimized;
qboolean	WinNT;

static double		pfreq;
static double		curtime = 0.0;
static double		lastcurtime = 0.0;
static int			lowshift;
qboolean			isDedicated;
static qboolean		sc_return_on_enter = false;
HANDLE				hinput, houtput;

static char			*tracking_tag = "Clams & Mooses";

static HANDLE	tevent;
static HANDLE	hFile;
static HANDLE	heventParent;
static HANDLE	heventChild;

void MaskExceptions (void);
void Sys_InitFloatTime (void);
void Sys_PushFPCW_SetHigh (void);
void Sys_PopFPCW (void);

volatile int					sys_checksum;

// #undef _USE_PERFCOUNTER
#ifdef _USE_PERFCOUNTER

#define _QueryPerformanceFrequency QueryPerformanceFrequency
#define _QueryPerformanceCounter QueryPerformanceCounter

#else

__inline BOOL _QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency) {
    lpFrequency->QuadPart = 733000000;
    return TRUE;
}

__inline VOID __fastcall _QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount) {
    __asm {
        rdtsc
        mov DWORD PTR [ecx], eax
        mov DWORD PTR [ecx+4], edx
    }
}

#endif // !_USE_PERFCOUNTER

/*
================
Sys_PageIn
================
*/
void Sys_PageIn (void *ptr, int size)
{
#ifdef XBOX
    // No need to page in.
#else
	byte	*x;
	int		j, m, n;

// touch all the memory to make sure it's there. The 16-page skip is to
// keep Win 95 from thinking we're trying to page ourselves in (we are
// doing that, of course, but there's no reason we shouldn't)
	x = (byte *)ptr;

	for (n=0 ; n<4 ; n++)
	{
		for (m=0 ; m<(size - 16 * 0x1000) ; m += 4)
		{
			sys_checksum += *(int *)&x[m];
			sys_checksum += *(int *)&x[m + 16 * 0x1000];
		}
	}
#endif // XBOX
}


/*
===============================================================================

FILE IO

===============================================================================
*/

#define	MAX_HANDLES		10
FILE	*sys_handles[MAX_HANDLES];

int		findhandle (void)
{
	int		i;
	
	for (i=1 ; i<MAX_HANDLES ; i++)
		if (!sys_handles[i])
			return i;
	Sys_Error ("out of handles");
	return -1;
}

/*
================
filelength
================
*/
int filelength (FILE *f)
{
	int		pos;
	int		end;
	int		t;

	t = VID_ForceUnlockedAndReturnState ();

	pos = ftell (f);
	fseek (f, 0, SEEK_END);
	end = ftell (f);
	fseek (f, pos, SEEK_SET);

	VID_ForceLockState (t);

	return end;
}

int Sys_FileOpenRead (char *path, int *hndl)
{
	FILE	*f;
	int		i, retval;
	int		t;

	t = VID_ForceUnlockedAndReturnState ();

	i = findhandle ();

	f = fopen(path, "rb");

	if (!f)
	{
		*hndl = -1;
		retval = -1;
	}
	else
	{
		sys_handles[i] = f;
		*hndl = i;
		retval = filelength(f);
	}

	VID_ForceLockState (t);

	return retval;
}

int Sys_FileOpenWrite (char *path)
{
	FILE	*f;
	int		i;
	int		t;

	t = VID_ForceUnlockedAndReturnState ();
	
	i = findhandle ();

	f = fopen(path, "wb");
	if (!f)
//		Sys_Error ("Error opening %s: %s", path,strerror(errno));
		Sys_Error ("Error opening %s: %s", path,strerror(0));

	sys_handles[i] = f;
	
	VID_ForceLockState (t);

	return i;
}

void Sys_FileClose (int handle)
{
	int		t;

	t = VID_ForceUnlockedAndReturnState ();
	fclose (sys_handles[handle]);
	sys_handles[handle] = NULL;
	VID_ForceLockState (t);
}

void Sys_FileSeek (int handle, int position)
{
	int		t;

	t = VID_ForceUnlockedAndReturnState ();
	fseek (sys_handles[handle], position, SEEK_SET);
	VID_ForceLockState (t);
}

int Sys_FileRead (int handle, void *dest, int count)
{
	int		t, x;

	t = VID_ForceUnlockedAndReturnState ();
	x = fread (dest, 1, count, sys_handles[handle]);
	VID_ForceLockState (t);
	return x;
}

int Sys_FileWrite (int handle, void *data, int count)
{
	int		t, x;

	t = VID_ForceUnlockedAndReturnState ();
	x = fwrite (data, 1, count, sys_handles[handle]);
	VID_ForceLockState (t);
	return x;
}

int	Sys_FileTime (char *path)
{
	FILE	*f;
	int		t, retval;

	t = VID_ForceUnlockedAndReturnState ();
	
	f = fopen(path, "rb");

	if (f)
	{
		fclose(f);
		retval = 1;
	}
	else
	{
		retval = -1;
	}
	
	VID_ForceLockState (t);
	return retval;
}


/*
===============================================================================

SYSTEM IO

===============================================================================
*/

/*
================
Sys_MakeCodeWriteable
================
*/
void Sys_MakeCodeWriteable (unsigned long startaddr, unsigned long length)
{
	DWORD  flOldProtect;

	if (!VirtualProtect((LPVOID)startaddr, length, PAGE_READWRITE, &flOldProtect))
   		Sys_Error("Protection change failed\n");
}


#ifndef _M_IX86

void Sys_SetFPCW (void)
{
}

void Sys_PushFPCW_SetHigh (void)
{
}

void Sys_PopFPCW (void)
{
}

void MaskExceptions (void)
{
}

#endif

/*
================
Sys_Init
================
*/
void Sys_Init (void)
{
	LARGE_INTEGER	PerformanceFreq;
	unsigned int	lowpart, highpart;

	MaskExceptions ();
	Sys_SetFPCW ();

	if (!_QueryPerformanceFrequency (&PerformanceFreq))
		Sys_Error ("No hardware timer available");

// get 32 out of the 64 time bits such that we have around
// 1 microsecond resolution
	lowpart = (unsigned int)PerformanceFreq.LowPart;
	highpart = (unsigned int)PerformanceFreq.HighPart;
	lowshift = 0;

	while (highpart || (lowpart > 2000000.0))
	{
		lowshift++;
		lowpart >>= 1;
		lowpart |= (highpart & 1) << 31;
		highpart >>= 1;
	}

	pfreq = 1.0 / (double)lowpart;

	Sys_InitFloatTime ();
	WinNT = true;
}

#ifdef _XBOX
ULONG DebugPrint(PCHAR Format, ...);
#endif

void Sys_Error (char *error, ...)
{
	va_list		argptr;
	char		text[1024];

	va_start (argptr, error);
	vsprintf (text, error, argptr);
	va_end (argptr);

#ifdef _XBOX
    DebugPrint("%s", text);
#else
	OutputDebugStr(text);
#endif

    _asm int 3;
}

void Sys_Printf (char *fmt, ...)
{
	va_list		argptr;
	char		text[1024];

	va_start (argptr, fmt);
	vsprintf (text, fmt, argptr);
	va_end (argptr);
#ifdef _XBOX
    DebugPrint("%s", text);
#else
	OutputDebugStr(text);
#endif
}

#ifndef _XBOX

void Sys_Quit (void)
{

	VID_ForceUnlockedAndReturnState ();

	Host_Shutdown();

	if (tevent)
		CloseHandle (tevent);

	if (isDedicated)
		FreeConsole ();

#if 0
// shut down QHOST hooks if necessary
	DeinitConProc ();
#endif
	exit (0);
}

#endif

/*
================
Sys_FloatTime
================
*/
double Sys_FloatTime (void)
{
	static int			sametimecount;
	static unsigned int	oldtime;
	static int			first = 1;
	LARGE_INTEGER		PerformanceCount;
	unsigned int		temp, t2;
	double				time;

	Sys_PushFPCW_SetHigh ();

	_QueryPerformanceCounter (&PerformanceCount);

	temp = ((unsigned int)PerformanceCount.LowPart >> lowshift) |
		   ((unsigned int)PerformanceCount.HighPart << (32 - lowshift));

	if (first)
	{
		oldtime = temp;
		first = 0;
	}
	else
	{
	// check for turnover or backward time
		if ((temp <= oldtime) && ((oldtime - temp) < 0x10000000))
		{
			oldtime = temp;	// so we can't get stuck
		}
		else
		{
			t2 = temp - oldtime;

			time = (double)t2 * pfreq;
			oldtime = temp;

			curtime += time;

			if (curtime == lastcurtime)
			{
				sametimecount++;

				if (sametimecount > 100000)
				{
					curtime += 1.0;
					sametimecount = 0;
				}
			}
			else
			{
				sametimecount = 0;
			}

			lastcurtime = curtime;
		}
	}

	Sys_PopFPCW ();

    return curtime;
}


/*
================
Sys_InitFloatTime
================
*/
void Sys_InitFloatTime (void)
{
	int		j;

	Sys_FloatTime ();

	curtime = 0.0;

	lastcurtime = curtime;
}


void Sys_Sleep (void)
{
	Sleep (1);
}

#ifndef _XBOX

void Sys_SendKeyEvents (void)
{
    MSG        msg;

	while (PeekMessage (&msg, NULL, 0, 0, PM_NOREMOVE))
	{
	// we always update if there are any event, even if we're paused
		scr_skipupdate = 0;

		if (!GetMessage (&msg, NULL, 0, 0))
			Sys_Quit ();

      	TranslateMessage (&msg);
      	DispatchMessage (&msg);
	}
}

#endif

/*
==============================================================================

 WINDOWS CRAP

==============================================================================
*/


/*
==================
WinMain
==================
*/
#if !id386
void Sys_HighFPPrecision (void)
{
}

void Sys_LowFPPrecision (void)
{
}

void Sys_SetFPCW (void)
{
}

void MaskExceptions (void)
{
}

void Sys_PopFPCW (void)
{
}

void Sys_PushFPCW_SetHigh (void)
{
}

#endif

/*
==================
WinMain
==================
*/
HINSTANCE	global_hInstance;
int			global_nCmdShow;
char		*argv[MAX_NUM_ARGVS];
static char	*empty_string = "";
HWND		hwnd_dialog;

void __cdecl main()
{
	quakeparms_t	parms;
	double			time, oldtime, newtime;
	MEMORYSTATUS	lpBuffer;

	lpBuffer.dwLength = sizeof(MEMORYSTATUS);
	GlobalMemoryStatus (&lpBuffer);

    memset(&parms, 0, sizeof(parms));

// take the greater of all the available memory or half the total memory,
// but at least 8 Mb and no more than 16 Mb, unless they explicitly
// request otherwise
	parms.memsize = MAXIMUM_WIN_MEMORY;
	parms.membase = malloc (parms.memsize);

	if (!parms.membase)
		Sys_Error ("Not enough memory free; check disk space\n");

	Sys_PageIn (parms.membase, parms.memsize);

	tevent = CreateEvent(NULL, FALSE, FALSE, NULL);

	if (!tevent)
		Sys_Error ("Couldn't create event");

	Sys_Init ();

// because sound is off until we become active
	S_BlockSound ();

	Sys_Printf ("Host_Init\n");
	Host_Init (&parms);

	oldtime = Sys_FloatTime ();

    /* main window message loop */
	while (1)
	{
		newtime = Sys_FloatTime ();
		time = newtime - oldtime;

		Host_Frame (time);
		oldtime = newtime;
	}
}

#ifndef _XBOX

#include "resource.h"

// Poor man's window interface

RECT		WindowRect;
DWORD		WindowStyle, ExWindowStyle;

HWND		mainwindow;
static HICON	hIcon;
int			window_center_x, window_center_y, window_x, window_y, window_width, window_height;
RECT		window_rect;

LONG CDAudio_MessageHandler(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern int MapKey (int key);
static qboolean in_mode_set;

extern void ClearAllStates (void);

void AppActivate(BOOL fActive, BOOL minimize)
/****************************************************************************
*
* Function:     AppActivate
* Parameters:   fActive - True if app is activating
*
* Description:  If the application is activating, then swap the system
*               into SYSPAL_NOSTATIC mode so that our palettes will display
*               correctly.
*
****************************************************************************/
{
	MSG msg;
    HDC			hdc;
    int			i, t;
	static BOOL	sound_active;

	ActiveApp = fActive;
	Minimized = minimize;

// enable/disable sound on focus gain/loss
	if (!ActiveApp && sound_active)
	{
		S_BlockSound ();
		sound_active = false;
	}
	else if (ActiveApp && !sound_active)
	{
		S_UnblockSound ();
		sound_active = true;
	}

	if (fActive)
	{
		if (modestate == MS_FULLDIB)
		{
			IN_ActivateMouse ();
			IN_HideMouse ();
#if 0
			if (vid_canalttab && vid_wassuspended) {
				vid_wassuspended = false;
				ChangeDisplaySettings (&gdevmode, CDS_FULLSCREEN);
				ShowWindow(mainwindow, SW_SHOWNORMAL);
			}
#endif
		}
		else if ((modestate == MS_WINDOWED) && key_dest == key_game)
		{
			IN_ActivateMouse ();
			IN_HideMouse ();
		}
	}

	if (!fActive)
	{
		if (modestate == MS_FULLDIB)
		{
			IN_DeactivateMouse ();
			IN_ShowMouse ();
#if 0
			if (vid_canalttab) { 
				ChangeDisplaySettings (NULL, 0);
				vid_wassuspended = true;
			}
#endif
		}
		else if ((modestate == MS_WINDOWED))
		{
			IN_DeactivateMouse ();
			IN_ShowMouse ();
		}
	}
}
/* main window procedure */
LONG WINAPI MainWndProc (
    HWND    hWnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
	LONG			lRet = 0;
	int				fwKeys, xPos, yPos, fActive, fMinimized, temp;
	HDC				hdc;
	PAINTSTRUCT		ps;
	static int		recursiveflag;

	switch (uMsg)
	{
		case WM_CREATE:
			break;

		case WM_SYSCHAR:
		// keep Alt-Space from happening
			break;

		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
#if 0
			if ( host_initialized)
				SCR_UpdateWholeScreen ();
#endif
			EndPaint(hWnd, &ps);
			break;

		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			if (!in_mode_set)
				Key_Event (MapKey(lParam), true);
			break;

		case WM_KEYUP:
		case WM_SYSKEYUP:
			if (!in_mode_set)
				Key_Event (MapKey(lParam), false);
			break;

	// this is complicated because Win32 seems to pack multiple mouse events into
	// one update sometimes, so we always check all states and look for events
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONUP:
		case WM_MOUSEMOVE:
			if (!in_mode_set)
			{
				temp = 0;

				if (wParam & MK_LBUTTON)
					temp |= 1;

				if (wParam & MK_RBUTTON)
					temp |= 2;

				if (wParam & MK_MBUTTON)
					temp |= 4;

				IN_MouseEvent (temp);
			}
			break;

   	    case WM_CLOSE:
		// this causes Close in the right-click task bar menu not to work, but right
		// now bad things happen if Close is handled in that case (garbage and a
		// crash on Win95)
			if (!in_mode_set)
			{
				if (MessageBox (mainwindow, TEXT("Are you sure you want to quit?"), TEXT("Confirm Exit"),
							MB_YESNO | MB_SETFOREGROUND | MB_ICONQUESTION) == IDYES)
				{
					Sys_Quit ();
				}
			}
			break;

		case WM_ACTIVATE:
			fActive = LOWORD(wParam);
			fMinimized = (BOOL) HIWORD(wParam);
			AppActivate(!(fActive == WA_INACTIVE), fMinimized);

		// fix the leftover Alt from any Alt-Tab or the like that switched us away
			ClearAllStates ();

			break;
		case MM_MCINOTIFY:
            lRet = CDAudio_MessageHandler (hWnd, uMsg, wParam, lParam);
			break;

		default:
            /* pass all unhandled messages to DefWindowProc */
            lRet = DefWindowProc (hWnd, uMsg, wParam, lParam);
	        break;
    }

    /* return 0 if handled message, 1 if not */
    return lRet;
}


int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG				msg;
    /* previous instances do not exist in Win32 */
    if (hPrevInstance)
        return 0;

	global_hInstance = hInstance;
	global_nCmdShow = nCmdShow;

	{
		WNDCLASS		wc;
		HDC				hdc;
		int				i;

		hIcon = LoadIcon (hInstance, MAKEINTRESOURCE (IDI_ICON2));

		/* Register the frame class */
		wc.style         = 0;
		wc.lpfnWndProc   = (WNDPROC)MainWndProc;
		wc.cbClsExtra    = 0;
		wc.cbWndExtra    = 0;
		wc.hInstance     = hInstance;
		wc.hIcon         = 0;
		wc.hCursor       = LoadCursor (NULL,IDC_ARROW);
		wc.hbrBackground = NULL;
		wc.lpszMenuName  = 0;
		wc.lpszClassName = TEXT("WinQuake");

		if (!RegisterClass (&wc) )
			Sys_Error ("Couldn't register window class");

	}
	{
		HDC hdc;

		WindowRect.top = 100;
		WindowRect.left = 100;
		WindowRect.bottom = WindowRect.top + 480;
		WindowRect.right = WindowRect.left + 640;

		WindowStyle = WS_OVERLAPPED | WS_BORDER | WS_CAPTION | WS_SYSMENU |
					  WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPSIBLINGS |
					  WS_CLIPCHILDREN;
		ExWindowStyle = 0;
		AdjustWindowRectEx(&WindowRect, WindowStyle, FALSE, 0);

		mainwindow = CreateWindowEx (
			 ExWindowStyle,
			 TEXT("WinQuake"),
			 TEXT("WinQuake"),
			 WindowStyle,
			 0, 0,
			 WindowRect.right - WindowRect.left,
			 WindowRect.bottom - WindowRect.top,
			 NULL,
			 NULL,
			 global_hInstance,
			 NULL);

		ShowWindow (mainwindow, SW_SHOWDEFAULT);
		UpdateWindow (mainwindow);

		// Because we have set the background brush for the window to NULL
		// (to avoid flickering when re-sizing the window on the desktop), we
		// clear the window to black when created, otherwise it will be
		// empty while Quake starts up.
		hdc = GetDC(mainwindow);
		PatBlt(hdc,0,0,WindowRect.right,WindowRect.bottom,BLACKNESS);
		ReleaseDC(mainwindow, hdc);	}

	main();
	return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\vid.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// vid.h -- video driver defs

#define VID_CBITS	6
#define VID_GRADES	(1 << VID_CBITS)

// a pixel can be one, two, or four bytes
typedef byte pixel_t;

typedef struct vrect_s
{
	int				x,y,width,height;
	struct vrect_s	*pnext;
} vrect_t;

typedef struct
{
	pixel_t			*buffer;		// invisible buffer
	pixel_t			*colormap;		// 256 * VID_GRADES size
	unsigned short	*colormap16;	// 256 * VID_GRADES size
	int				fullbright;		// index of first fullbright color
	unsigned		rowbytes;	// may be > width if displayed in a window
	unsigned		width;		
	unsigned		height;
	float			aspect;		// width / height -- < 0 is taller than wide
	int				numpages;
	int				recalc_refdef;	// if true, recalc vid-based stuff
	pixel_t			*conbuffer;
	int				conrowbytes;
	unsigned		conwidth;
	unsigned		conheight;
	int				maxwarpwidth;
	int				maxwarpheight;
	pixel_t			*direct;		// direct drawing to framebuffer, if not
									//  NULL
} viddef_t;

extern	viddef_t	vid;				// global video state
extern	unsigned short	d_8to16table[256];
extern	unsigned	d_8to24table[256];
extern void (*vid_menudrawfn)(void);
extern void (*vid_menukeyfn)(int key);

void	VID_SetPalette (unsigned char *palette);
// called at startup and after any gamma correction

void	VID_ShiftPalette (unsigned char *palette);
// called for bonus and pain flashes, and for underwater color changes

void	VID_Init (unsigned char *palette);
// Called at startup to set up translation tables, takes 256 8 bit RGB values
// the palette data will go away after the call, so it must be copied off if
// the video driver will need it again

void	VID_Shutdown (void);
// Called at shutdown

void	VID_Update (vrect_t *rects);
// flushes the given rectangles from the view buffer to the screen

int VID_SetMode (int modenum, unsigned char *palette);
// sets the mode; only used by the Quake engine for resetting to mode 0 (the
// base mode) on memory allocation failures

void VID_HandlePause (qboolean pause);
// called only on Win32, when pause happens, so the mouse can be released
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\view.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// view.h

extern	cvar_t		v_gamma;

extern	byte		gammatable[256];	// palette is sent through this
extern	byte		ramps[3][256];
extern float v_blend[4];

extern cvar_t lcd_x;


void V_Init (void);
void V_RenderView (void);
float V_CalcRoll (vec3_t angles, vec3_t velocity);
void V_UpdatePalette (void);
void V_CalcBlend (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\view.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// view.c -- player eye positioning

#include "quakedef.h"
//#include "r_local.h"

/*

The view is allowed to move slightly from it's true position for bobbing,
but if it exceeds 8 pixels linear distance (spherical, not box), the list of
entities sent from the server may not include everything in the pvs, especially
when crossing a water boudnary.

*/

cvar_t		lcd_x = {"lcd_x","0"};
cvar_t		lcd_yaw = {"lcd_yaw","0"};

cvar_t	scr_ofsx = {"scr_ofsx","0", false};
cvar_t	scr_ofsy = {"scr_ofsy","0", false};
cvar_t	scr_ofsz = {"scr_ofsz","0", false};

cvar_t	cl_rollspeed = {"cl_rollspeed", "200"};
cvar_t	cl_rollangle = {"cl_rollangle", "2.0"};

cvar_t	cl_bob = {"cl_bob","0.02", false};
cvar_t	cl_bobcycle = {"cl_bobcycle","0.6", false};
cvar_t	cl_bobup = {"cl_bobup","0.5", false};

cvar_t	v_kicktime = {"v_kicktime", "0.5", false};
cvar_t	v_kickroll = {"v_kickroll", "0.6", false};
cvar_t	v_kickpitch = {"v_kickpitch", "0.6", false};

cvar_t	v_iyaw_cycle = {"v_iyaw_cycle", "2", false};
cvar_t	v_iroll_cycle = {"v_iroll_cycle", "0.5", false};
cvar_t	v_ipitch_cycle = {"v_ipitch_cycle", "1", false};
cvar_t	v_iyaw_level = {"v_iyaw_level", "0.3", false};
cvar_t	v_iroll_level = {"v_iroll_level", "0.1", false};
cvar_t	v_ipitch_level = {"v_ipitch_level", "0.3", false};

cvar_t	v_idlescale = {"v_idlescale", "0", false};

cvar_t	crosshair = {"crosshair", "0", true};
cvar_t	cl_crossx = {"cl_crossx", "0", false};
cvar_t	cl_crossy = {"cl_crossy", "0", false};

cvar_t	gl_cshiftpercent = {"gl_cshiftpercent", "100", false};

float	v_dmg_time, v_dmg_roll, v_dmg_pitch;

extern	int			in_forward, in_forward2, in_back;


/*
===============
V_CalcRoll

Used by view and sv_user
===============
*/
vec3_t	forward, right, up;

float V_CalcRoll (vec3_t angles, vec3_t velocity)
{
	float	sign;
	float	side;
	float	value;
	
	AngleVectors (angles, forward, right, up);
	side = DotProduct (velocity, right);
	sign = side < 0 ? -1 : 1;
	side = fabs(side);
	
	value = cl_rollangle.value;
//	if (cl.inwater)
//		value *= 6;

	if (side < cl_rollspeed.value)
		side = side * value / cl_rollspeed.value;
	else
		side = value;
	
	return side*sign;
	
}


/*
===============
V_CalcBob

===============
*/
float V_CalcBob (void)
{
	float	bob;
	float	cycle;
	
	cycle = cl.time - (int)(cl.time/cl_bobcycle.value)*cl_bobcycle.value;
	cycle /= cl_bobcycle.value;
	if (cycle < cl_bobup.value)
		cycle = M_PI * cycle / cl_bobup.value;
	else
		cycle = M_PI + M_PI*(cycle-cl_bobup.value)/(1.0 - cl_bobup.value);

// bob is proportional to velocity in the xy plane
// (don't count Z, or jumping messes it up)

	bob = sqrt(cl.velocity[0]*cl.velocity[0] + cl.velocity[1]*cl.velocity[1]) * cl_bob.value;
//Con_Printf ("speed: %5.1f\n", Length(cl.velocity));
	bob = bob*0.3 + bob*0.7*sin(cycle);
	if (bob > 4)
		bob = 4;
	else if (bob < -7)
		bob = -7;
	return bob;
	
}


//=============================================================================


cvar_t	v_centermove = {"v_centermove", "0.15", false};
cvar_t	v_centerspeed = {"v_centerspeed","500"};


void V_StartPitchDrift (void)
{
#if 1
	if (cl.laststop == cl.time)
	{
		return;		// something else is keeping it from drifting
	}
#endif
	if (cl.nodrift || !cl.pitchvel)
	{
		cl.pitchvel = v_centerspeed.value;
		cl.nodrift = false;
		cl.driftmove = 0;
	}
}

void V_StopPitchDrift (void)
{
	cl.laststop = cl.time;
	cl.nodrift = true;
	cl.pitchvel = 0;
}

/*
===============
V_DriftPitch

Moves the client pitch angle towards cl.idealpitch sent by the server.

If the user is adjusting pitch manually, either with lookup/lookdown,
mlook and mouse, or klook and keyboard, pitch drifting is constantly stopped.

Drifting is enabled when the center view key is hit, mlook is released and
lookspring is non 0, or when 
===============
*/
void V_DriftPitch (void)
{
	float		delta, move;

	if (noclip_anglehack || !cl.onground || cls.demoplayback )
	{
		cl.driftmove = 0;
		cl.pitchvel = 0;
		return;
	}

// don't count small mouse motion
	if (cl.nodrift)
	{
		if ( fabs(cl.cmd.forwardmove) < cl_forwardspeed.value)
			cl.driftmove = 0;
		else
			cl.driftmove += host_frametime;
	
		if ( cl.driftmove > v_centermove.value)
		{
			V_StartPitchDrift ();
		}
		return;
	}
	
	delta = cl.idealpitch - cl.viewangles[PITCH];

	if (!delta)
	{
		cl.pitchvel = 0;
		return;
	}

	move = host_frametime * cl.pitchvel;
	cl.pitchvel += host_frametime * v_centerspeed.value;
	
//Con_Printf ("move: %f (%f)\n", move, host_frametime);

	if (delta > 0)
	{
		if (move > delta)
		{
			cl.pitchvel = 0;
			move = delta;
		}
		cl.viewangles[PITCH] += move;
	}
	else if (delta < 0)
	{
		if (move > -delta)
		{
			cl.pitchvel = 0;
			move = -delta;
		}
		cl.viewangles[PITCH] -= move;
	}
}





/*
============================================================================== 
 
						PALETTE FLASHES 
 
============================================================================== 
*/ 
 
 
cshift_t	cshift_empty = { {130,80,50}, 0 };
cshift_t	cshift_water = { {130,80,50}, 128 };
cshift_t	cshift_slime = { {0,25,5}, 150 };
cshift_t	cshift_lava = { {255,80,0}, 150 };

cvar_t		v_gamma = {"gamma", "1", true};

byte		gammatable[256];	// palette is sent through this

#ifdef	GLQUAKE
byte		ramps[3][256];
float		v_blend[4];		// rgba 0.0 - 1.0
#endif	// GLQUAKE

void BuildGammaTable (float g)
{
	int		i, inf;
	
	if (g == 1.0)
	{
		for (i=0 ; i<256 ; i++)
			gammatable[i] = (byte)i;
		return;
	}
	
	for (i=0 ; i<256 ; i++)
	{
		inf = 255 * pow ( (i+0.5)/255.5 , g ) + 0.5;
		if (inf < 0)
			inf = 0;
		if (inf > 255)
			inf = 255;
		gammatable[i] = (byte)inf;
	}
}

/*
=================
V_CheckGamma
=================
*/
#ifdef D3DQUAKE
void d3dSetGammaRamp(const unsigned char* gammaTable);
#endif

qboolean V_CheckGamma (void)
{
	static float oldgammavalue;
	
	if (v_gamma.value == oldgammavalue)
		return false;
	oldgammavalue = v_gamma.value;
	
	BuildGammaTable (v_gamma.value);
	vid.recalc_refdef = 1;				// force a surface cache flush

#ifdef D3DQUAKE
	d3dSetGammaRamp(gammatable);
#endif

	return true;
}



/*
===============
V_ParseDamage
===============
*/
void V_ParseDamage (void)
{
	int		armor, blood;
	vec3_t	from;
	int		i;
	vec3_t	forward, right, up;
	entity_t	*ent;
	float	side;
	float	count;
	
	armor = MSG_ReadByte ();
	blood = MSG_ReadByte ();
	for (i=0 ; i<3 ; i++)
		from[i] = MSG_ReadCoord ();

	count = blood*0.5 + armor*0.5;
	if (count < 10)
		count = 10;

	cl.faceanimtime = cl.time + 0.2;		// but sbar face into pain frame

	cl.cshifts[CSHIFT_DAMAGE].percent += 3*count;
	if (cl.cshifts[CSHIFT_DAMAGE].percent < 0)
		cl.cshifts[CSHIFT_DAMAGE].percent = 0;
	if (cl.cshifts[CSHIFT_DAMAGE].percent > 150)
		cl.cshifts[CSHIFT_DAMAGE].percent = 150;

	if (armor > blood)		
	{
		cl.cshifts[CSHIFT_DAMAGE].destcolor[0] = 200;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[1] = 100;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[2] = 100;
	}
	else if (armor)
	{
		cl.cshifts[CSHIFT_DAMAGE].destcolor[0] = 220;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[1] = 50;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[2] = 50;
	}
	else
	{
		cl.cshifts[CSHIFT_DAMAGE].destcolor[0] = 255;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[1] = 0;
		cl.cshifts[CSHIFT_DAMAGE].destcolor[2] = 0;
	}

//
// calculate view angle kicks
//
	ent = &cl_entities[cl.viewentity];
	
	VectorSubtract (from, ent->origin, from);
	VectorNormalize (from);
	
	AngleVectors (ent->angles, forward, right, up);

	side = DotProduct (from, right);
	v_dmg_roll = count*side*v_kickroll.value;
	
	side = DotProduct (from, forward);
	v_dmg_pitch = count*side*v_kickpitch.value;

	v_dmg_time = v_kicktime.value;
}


/*
==================
V_cshift_f
==================
*/
void V_cshift_f (void)
{
	cshift_empty.destcolor[0] = atoi(Cmd_Argv(1));
	cshift_empty.destcolor[1] = atoi(Cmd_Argv(2));
	cshift_empty.destcolor[2] = atoi(Cmd_Argv(3));
	cshift_empty.percent = atoi(Cmd_Argv(4));
}


/*
==================
V_BonusFlash_f

When you run over an item, the server sends this command
==================
*/
void V_BonusFlash_f (void)
{
	cl.cshifts[CSHIFT_BONUS].destcolor[0] = 215;
	cl.cshifts[CSHIFT_BONUS].destcolor[1] = 186;
	cl.cshifts[CSHIFT_BONUS].destcolor[2] = 69;
	cl.cshifts[CSHIFT_BONUS].percent = 50;
}

/*
=============
V_SetContentsColor

Underwater, lava, etc each has a color shift
=============
*/
void V_SetContentsColor (int contents)
{
	switch (contents)
	{
	case CONTENTS_EMPTY:
	case CONTENTS_SOLID:
		cl.cshifts[CSHIFT_CONTENTS] = cshift_empty;
		break;
	case CONTENTS_LAVA:
		cl.cshifts[CSHIFT_CONTENTS] = cshift_lava;
		break;
	case CONTENTS_SLIME:
		cl.cshifts[CSHIFT_CONTENTS] = cshift_slime;
		break;
	default:
		cl.cshifts[CSHIFT_CONTENTS] = cshift_water;
	}
}

/*
=============
V_CalcPowerupCshift
=============
*/
void V_CalcPowerupCshift (void)
{
	if (cl.items & IT_QUAD)
	{
		cl.cshifts[CSHIFT_POWERUP].destcolor[0] = 0;
		cl.cshifts[CSHIFT_POWERUP].destcolor[1] = 0;
		cl.cshifts[CSHIFT_POWERUP].destcolor[2] = 255;
		cl.cshifts[CSHIFT_POWERUP].percent = 30;
	}
	else if (cl.items & IT_SUIT)
	{
		cl.cshifts[CSHIFT_POWERUP].destcolor[0] = 0;
		cl.cshifts[CSHIFT_POWERUP].destcolor[1] = 255;
		cl.cshifts[CSHIFT_POWERUP].destcolor[2] = 0;
		cl.cshifts[CSHIFT_POWERUP].percent = 20;
	}
	else if (cl.items & IT_INVISIBILITY)
	{
		cl.cshifts[CSHIFT_POWERUP].destcolor[0] = 100;
		cl.cshifts[CSHIFT_POWERUP].destcolor[1] = 100;
		cl.cshifts[CSHIFT_POWERUP].destcolor[2] = 100;
		cl.cshifts[CSHIFT_POWERUP].percent = 100;
	}
	else if (cl.items & IT_INVULNERABILITY)
	{
		cl.cshifts[CSHIFT_POWERUP].destcolor[0] = 255;
		cl.cshifts[CSHIFT_POWERUP].destcolor[1] = 255;
		cl.cshifts[CSHIFT_POWERUP].destcolor[2] = 0;
		cl.cshifts[CSHIFT_POWERUP].percent = 30;
	}
	else
		cl.cshifts[CSHIFT_POWERUP].percent = 0;
}

/*
=============
V_CalcBlend
=============
*/
#ifdef	GLQUAKE
void V_CalcBlend (void)
{
	float	r, g, b, a, a2;
	int		j;

	r = 0;
	g = 0;
	b = 0;
	a = 0;

	for (j=0 ; j<NUM_CSHIFTS ; j++)	
	{
		if (!gl_cshiftpercent.value)
			continue;

		a2 = ((cl.cshifts[j].percent * gl_cshiftpercent.value) / 100.0) / 255.0;

//		a2 = cl.cshifts[j].percent/255.0;
		if (!a2)
			continue;
		a = a + a2*(1-a);
//Con_Printf ("j:%i a:%f\n", j, a);
		a2 = a2/a;
		r = r*(1-a2) + cl.cshifts[j].destcolor[0]*a2;
		g = g*(1-a2) + cl.cshifts[j].destcolor[1]*a2;
		b = b*(1-a2) + cl.cshifts[j].destcolor[2]*a2;
	}

	v_blend[0] = r/255.0;
	v_blend[1] = g/255.0;
	v_blend[2] = b/255.0;
	v_blend[3] = a;
	if (v_blend[3] > 1)
		v_blend[3] = 1;
	if (v_blend[3] < 0)
		v_blend[3] = 0;
}
#endif

/*
=============
V_UpdatePalette
=============
*/
#ifdef	GLQUAKE
void V_UpdatePalette (void)
{
	int		i, j;
	qboolean	new;
	byte	*basepal, *newpal;
	byte	pal[768];
	float	r,g,b,a;
	int		ir, ig, ib;
	qboolean force;

	V_CalcPowerupCshift ();
	
	new = false;
	
	for (i=0 ; i<NUM_CSHIFTS ; i++)
	{
		if (cl.cshifts[i].percent != cl.prev_cshifts[i].percent)
		{
			new = true;
			cl.prev_cshifts[i].percent = cl.cshifts[i].percent;
		}
		for (j=0 ; j<3 ; j++)
			if (cl.cshifts[i].destcolor[j] != cl.prev_cshifts[i].destcolor[j])
			{
				new = true;
				cl.prev_cshifts[i].destcolor[j] = cl.cshifts[i].destcolor[j];
			}
	}
	
// drop the damage value
	cl.cshifts[CSHIFT_DAMAGE].percent -= host_frametime*150;
	if (cl.cshifts[CSHIFT_DAMAGE].percent <= 0)
		cl.cshifts[CSHIFT_DAMAGE].percent = 0;

// drop the bonus value
	cl.cshifts[CSHIFT_BONUS].percent -= host_frametime*100;
	if (cl.cshifts[CSHIFT_BONUS].percent <= 0)
		cl.cshifts[CSHIFT_BONUS].percent = 0;

	force = V_CheckGamma ();
	if (!new && !force)
		return;

	V_CalcBlend ();

	a = v_blend[3];
	r = 255*v_blend[0]*a;
	g = 255*v_blend[1]*a;
	b = 255*v_blend[2]*a;

	a = 1-a;
	for (i=0 ; i<256 ; i++)
	{
		ir = i*a + r;
		ig = i*a + g;
		ib = i*a + b;
		if (ir > 255)
			ir = 255;
		if (ig > 255)
			ig = 255;
		if (ib > 255)
			ib = 255;

		ramps[0][i] = gammatable[ir];
		ramps[1][i] = gammatable[ig];
		ramps[2][i] = gammatable[ib];
	}

	basepal = host_basepal;
	newpal = pal;
	
	for (i=0 ; i<256 ; i++)
	{
		ir = basepal[0];
		ig = basepal[1];
		ib = basepal[2];
		basepal += 3;
		
		newpal[0] = ramps[0][ir];
		newpal[1] = ramps[1][ig];
		newpal[2] = ramps[2][ib];
		newpal += 3;
	}

	VID_ShiftPalette (pal);	
}
#else	// !GLQUAKE
void V_UpdatePalette (void)
{
	int		i, j;
	qboolean	new;
	byte	*basepal, *newpal;
	byte	pal[768];
	int		r,g,b;
	qboolean force;

	V_CalcPowerupCshift ();
	
	new = false;
	
	for (i=0 ; i<NUM_CSHIFTS ; i++)
	{
		if (cl.cshifts[i].percent != cl.prev_cshifts[i].percent)
		{
			new = true;
			cl.prev_cshifts[i].percent = cl.cshifts[i].percent;
		}
		for (j=0 ; j<3 ; j++)
			if (cl.cshifts[i].destcolor[j] != cl.prev_cshifts[i].destcolor[j])
			{
				new = true;
				cl.prev_cshifts[i].destcolor[j] = cl.cshifts[i].destcolor[j];
			}
	}
	
// drop the damage value
	cl.cshifts[CSHIFT_DAMAGE].percent -= host_frametime*150;
	if (cl.cshifts[CSHIFT_DAMAGE].percent <= 0)
		cl.cshifts[CSHIFT_DAMAGE].percent = 0;

// drop the bonus value
	cl.cshifts[CSHIFT_BONUS].percent -= host_frametime*100;
	if (cl.cshifts[CSHIFT_BONUS].percent <= 0)
		cl.cshifts[CSHIFT_BONUS].percent = 0;

	force = V_CheckGamma ();
	if (!new && !force)
		return;
			
	basepal = host_basepal;
	newpal = pal;
	
	for (i=0 ; i<256 ; i++)
	{
		r = basepal[0];
		g = basepal[1];
		b = basepal[2];
		basepal += 3;
	
		for (j=0 ; j<NUM_CSHIFTS ; j++)	
		{
			r += (cl.cshifts[j].percent*(cl.cshifts[j].destcolor[0]-r))>>8;
			g += (cl.cshifts[j].percent*(cl.cshifts[j].destcolor[1]-g))>>8;
			b += (cl.cshifts[j].percent*(cl.cshifts[j].destcolor[2]-b))>>8;
		}
		
		newpal[0] = gammatable[r];
		newpal[1] = gammatable[g];
		newpal[2] = gammatable[b];
		newpal += 3;
	}

	VID_ShiftPalette (pal);	
}
#endif	// !GLQUAKE


/* 
============================================================================== 
 
						VIEW RENDERING 
 
============================================================================== 
*/ 

float angledelta (float a)
{
	a = anglemod(a);
	if (a > 180)
		a -= 360;
	return a;
}

/*
==================
CalcGunAngle
==================
*/
void CalcGunAngle (void)
{	
	float	yaw, pitch, move;
	static float oldyaw = 0;
	static float oldpitch = 0;
	
	yaw = r_refdef.viewangles[YAW];
	pitch = -r_refdef.viewangles[PITCH];

	yaw = angledelta(yaw - r_refdef.viewangles[YAW]) * 0.4;
	if (yaw > 10)
		yaw = 10;
	if (yaw < -10)
		yaw = -10;
	pitch = angledelta(-pitch - r_refdef.viewangles[PITCH]) * 0.4;
	if (pitch > 10)
		pitch = 10;
	if (pitch < -10)
		pitch = -10;
	move = host_frametime*20;
	if (yaw > oldyaw)
	{
		if (oldyaw + move < yaw)
			yaw = oldyaw + move;
	}
	else
	{
		if (oldyaw - move > yaw)
			yaw = oldyaw - move;
	}
	
	if (pitch > oldpitch)
	{
		if (oldpitch + move < pitch)
			pitch = oldpitch + move;
	}
	else
	{
		if (oldpitch - move > pitch)
			pitch = oldpitch - move;
	}
	
	oldyaw = yaw;
	oldpitch = pitch;

	cl.viewent.angles[YAW] = r_refdef.viewangles[YAW] + yaw;
	cl.viewent.angles[PITCH] = - (r_refdef.viewangles[PITCH] + pitch);

	cl.viewent.angles[ROLL] -= v_idlescale.value * sin(cl.time*v_iroll_cycle.value) * v_iroll_level.value;
	cl.viewent.angles[PITCH] -= v_idlescale.value * sin(cl.time*v_ipitch_cycle.value) * v_ipitch_level.value;
	cl.viewent.angles[YAW] -= v_idlescale.value * sin(cl.time*v_iyaw_cycle.value) * v_iyaw_level.value;
}

/*
==============
V_BoundOffsets
==============
*/
void V_BoundOffsets (void)
{
	entity_t	*ent;
	
	ent = &cl_entities[cl.viewentity];

// absolutely bound refresh reletive to entity clipping hull
// so the view can never be inside a solid wall

	if (r_refdef.vieworg[0] < ent->origin[0] - 14)
		r_refdef.vieworg[0] = ent->origin[0] - 14;
	else if (r_refdef.vieworg[0] > ent->origin[0] + 14)
		r_refdef.vieworg[0] = ent->origin[0] + 14;
	if (r_refdef.vieworg[1] < ent->origin[1] - 14)
		r_refdef.vieworg[1] = ent->origin[1] - 14;
	else if (r_refdef.vieworg[1] > ent->origin[1] + 14)
		r_refdef.vieworg[1] = ent->origin[1] + 14;
	if (r_refdef.vieworg[2] < ent->origin[2] - 22)
		r_refdef.vieworg[2] = ent->origin[2] - 22;
	else if (r_refdef.vieworg[2] > ent->origin[2] + 30)
		r_refdef.vieworg[2] = ent->origin[2] + 30;
}

/*
==============
V_AddIdle

Idle swaying
==============
*/
void V_AddIdle (void)
{
	r_refdef.viewangles[ROLL] += v_idlescale.value * sin(cl.time*v_iroll_cycle.value) * v_iroll_level.value;
	r_refdef.viewangles[PITCH] += v_idlescale.value * sin(cl.time*v_ipitch_cycle.value) * v_ipitch_level.value;
	r_refdef.viewangles[YAW] += v_idlescale.value * sin(cl.time*v_iyaw_cycle.value) * v_iyaw_level.value;
}


/*
==============
V_CalcViewRoll

Roll is induced by movement and damage
==============
*/
void V_CalcViewRoll (void)
{
	float		side;
		
	side = V_CalcRoll (cl_entities[cl.viewentity].angles, cl.velocity);
	r_refdef.viewangles[ROLL] += side;

	if (v_dmg_time > 0)
	{
		r_refdef.viewangles[ROLL] += v_dmg_time/v_kicktime.value*v_dmg_roll;
		r_refdef.viewangles[PITCH] += v_dmg_time/v_kicktime.value*v_dmg_pitch;
		v_dmg_time -= host_frametime;
	}

	if (cl.stats[STAT_HEALTH] <= 0)
	{
		r_refdef.viewangles[ROLL] = 80;	// dead view angle
		return;
	}

}


/*
==================
V_CalcIntermissionRefdef

==================
*/
void V_CalcIntermissionRefdef (void)
{
	entity_t	*ent, *view;
	float		old;

// ent is the player model (visible when out of body)
	ent = &cl_entities[cl.viewentity];
// view is the weapon model (only visible from inside body)
	view = &cl.viewent;

	VectorCopy (ent->origin, r_refdef.vieworg);
	VectorCopy (ent->angles, r_refdef.viewangles);
	view->model = NULL;

// allways idle in intermission
	old = v_idlescale.value;
	v_idlescale.value = 1;
	V_AddIdle ();
	v_idlescale.value = old;
}

/*
==================
V_CalcRefdef

==================
*/
void V_CalcRefdef (void)
{
	entity_t	*ent, *view;
	int			i;
	vec3_t		forward, right, up;
	vec3_t		angles;
	float		bob;
	static float oldz = 0;

	V_DriftPitch ();

// ent is the player model (visible when out of body)
	ent = &cl_entities[cl.viewentity];
// view is the weapon model (only visible from inside body)
	view = &cl.viewent;
	

// transform the view offset by the model's matrix to get the offset from
// model origin for the view
	ent->angles[YAW] = cl.viewangles[YAW];	// the model should face
										// the view dir
	ent->angles[PITCH] = -cl.viewangles[PITCH];	// the model should face
										// the view dir
										
	
	bob = V_CalcBob ();
	
// refresh position
	VectorCopy (ent->origin, r_refdef.vieworg);
	r_refdef.vieworg[2] += cl.viewheight + bob;

// never let it sit exactly on a node line, because a water plane can
// dissapear when viewed with the eye exactly on it.
// the server protocol only specifies to 1/16 pixel, so add 1/32 in each axis
	r_refdef.vieworg[0] += 1.0/32;
	r_refdef.vieworg[1] += 1.0/32;
	r_refdef.vieworg[2] += 1.0/32;

	VectorCopy (cl.viewangles, r_refdef.viewangles);
	V_CalcViewRoll ();
	V_AddIdle ();

// offsets
	angles[PITCH] = -ent->angles[PITCH];	// because entity pitches are
											//  actually backward
	angles[YAW] = ent->angles[YAW];
	angles[ROLL] = ent->angles[ROLL];

	AngleVectors (angles, forward, right, up);

	for (i=0 ; i<3 ; i++)
		r_refdef.vieworg[i] += scr_ofsx.value*forward[i]
			+ scr_ofsy.value*right[i]
			+ scr_ofsz.value*up[i];
	
	
	V_BoundOffsets ();
		
// set up gun position
	VectorCopy (cl.viewangles, view->angles);
	
	CalcGunAngle ();

	VectorCopy (ent->origin, view->origin);
	view->origin[2] += cl.viewheight;

	for (i=0 ; i<3 ; i++)
	{
		view->origin[i] += forward[i]*bob*0.4;
//		view->origin[i] += right[i]*bob*0.4;
//		view->origin[i] += up[i]*bob*0.8;
	}
	view->origin[2] += bob;

// fudge position around to keep amount of weapon visible
// roughly equal with different FOV

#if 0
	if (cl.model_precache[cl.stats[STAT_WEAPON]] && strcmp (cl.model_precache[cl.stats[STAT_WEAPON]]->name,  "progs/v_shot2.mdl"))
#endif
	if (scr_viewsize.value == 110)
		view->origin[2] += 1;
	else if (scr_viewsize.value == 100)
		view->origin[2] += 2;
	else if (scr_viewsize.value == 90)
		view->origin[2] += 1;
	else if (scr_viewsize.value == 80)
		view->origin[2] += 0.5;

	view->model = cl.model_precache[cl.stats[STAT_WEAPON]];
	view->frame = cl.stats[STAT_WEAPONFRAME];
	view->colormap = vid.colormap;

// set up the refresh position
	VectorAdd (r_refdef.viewangles, cl.punchangle, r_refdef.viewangles);

// smooth out stair step ups
if (cl.onground && ent->origin[2] - oldz > 0)
{
	float steptime;
	
	steptime = cl.time - cl.oldtime;
	if (steptime < 0)
//FIXME		I_Error ("steptime < 0");
		steptime = 0;

	oldz += steptime * 80;
	if (oldz > ent->origin[2])
		oldz = ent->origin[2];
	if (ent->origin[2] - oldz > 12)
		oldz = ent->origin[2] - 12;
	r_refdef.vieworg[2] += oldz - ent->origin[2];
	view->origin[2] += oldz - ent->origin[2];
}
else
	oldz = ent->origin[2];

	if (chase_active.value)
		Chase_Update ();
}

/*
==================
V_RenderView

The player's clipping box goes from (-16 -16 -24) to (16 16 32) from
the entity origin, so any view position inside that will be valid
==================
*/
extern vrect_t	scr_vrect;

void V_RenderView (void)
{
	if (con_forcedup)
		return;

// don't allow cheats in multiplayer
	if (cl.maxclients > 1)
	{
		Cvar_Set ("scr_ofsx", "0");
		Cvar_Set ("scr_ofsy", "0");
		Cvar_Set ("scr_ofsz", "0");
	}

	if (cl.intermission)
	{	// intermission / finale rendering
		V_CalcIntermissionRefdef ();	
	}
	else
	{
		if (!cl.paused /* && (sv.maxclients > 1 || key_dest == key_game) */ )
			V_CalcRefdef ();
	}

	R_PushDlights ();

	if (lcd_x.value)
	{
		//
		// render two interleaved views
		//
		int		i;

		vid.rowbytes <<= 1;
		vid.aspect *= 0.5;

		r_refdef.viewangles[YAW] -= lcd_yaw.value;
		for (i=0 ; i<3 ; i++)
			r_refdef.vieworg[i] -= right[i]*lcd_x.value;
		R_RenderView ();

		vid.buffer += vid.rowbytes>>1;

		R_PushDlights ();

		r_refdef.viewangles[YAW] += lcd_yaw.value*2;
		for (i=0 ; i<3 ; i++)
			r_refdef.vieworg[i] += 2*right[i]*lcd_x.value;
		R_RenderView ();

		vid.buffer -= vid.rowbytes>>1;

		r_refdef.vrect.height <<= 1;

		vid.rowbytes >>= 1;
		vid.aspect *= 2;
	}
	else
	{
		R_RenderView ();
	}

#ifndef GLQUAKE
	if (crosshair.value)
		Draw_Character (scr_vrect.x + scr_vrect.width/2 + cl_crossx.value, 
			scr_vrect.y + scr_vrect.height/2 + cl_crossy.value, '+');
#endif
		
}

//============================================================================

/*
=============
V_Init
=============
*/
void V_Init (void)
{
	Cmd_AddCommand ("v_cshift", V_cshift_f);	
	Cmd_AddCommand ("bf", V_BonusFlash_f);
	Cmd_AddCommand ("centerview", V_StartPitchDrift);

	Cvar_RegisterVariable (&lcd_x);
	Cvar_RegisterVariable (&lcd_yaw);

	Cvar_RegisterVariable (&v_centermove);
	Cvar_RegisterVariable (&v_centerspeed);

	Cvar_RegisterVariable (&v_iyaw_cycle);
	Cvar_RegisterVariable (&v_iroll_cycle);
	Cvar_RegisterVariable (&v_ipitch_cycle);
	Cvar_RegisterVariable (&v_iyaw_level);
	Cvar_RegisterVariable (&v_iroll_level);
	Cvar_RegisterVariable (&v_ipitch_level);

	Cvar_RegisterVariable (&v_idlescale);
	Cvar_RegisterVariable (&crosshair);
	Cvar_RegisterVariable (&cl_crossx);
	Cvar_RegisterVariable (&cl_crossy);
	Cvar_RegisterVariable (&gl_cshiftpercent);

	Cvar_RegisterVariable (&scr_ofsx);
	Cvar_RegisterVariable (&scr_ofsy);
	Cvar_RegisterVariable (&scr_ofsz);
	Cvar_RegisterVariable (&cl_rollspeed);
	Cvar_RegisterVariable (&cl_rollangle);
	Cvar_RegisterVariable (&cl_bob);
	Cvar_RegisterVariable (&cl_bobcycle);
	Cvar_RegisterVariable (&cl_bobup);

	Cvar_RegisterVariable (&v_kicktime);
	Cvar_RegisterVariable (&v_kickroll);
	Cvar_RegisterVariable (&v_kickpitch);	
	
	BuildGammaTable (1.0);	// no gamma yet
	Cvar_RegisterVariable (&v_gamma);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sys.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sys.h -- non-portable functions

//
// file IO
//

// returns the file size
// return -1 if file is not present
// the file should be in BINARY mode for stupid OSs that care
int Sys_FileOpenRead (char *path, int *hndl);

int Sys_FileOpenWrite (char *path);
void Sys_FileClose (int handle);
void Sys_FileSeek (int handle, int position);
int Sys_FileRead (int handle, void *dest, int count);
int Sys_FileWrite (int handle, void *data, int count);
int	Sys_FileTime (char *path);

//
// memory protection
//
void Sys_MakeCodeWriteable (unsigned long startaddr, unsigned long length);

//
// system IO
//
void Sys_DebugLog(char *file, char *fmt, ...);

void Sys_Error (char *error, ...);
// an error will cause the entire program to exit

void Sys_Printf (char *fmt, ...);
// send text to the console

void Sys_Quit (void);

double Sys_FloatTime (void);

char *Sys_ConsoleInput (void);

void Sys_Sleep (void);
// called to yield for a little bit so as
// not to hog cpu when paused or debugging

void Sys_SendKeyEvents (void);
// Perform Key_Event () callbacks until the input que is empty

void Sys_LowFPPrecision (void);
void Sys_HighFPPrecision (void);
void Sys_SetFPCW (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\wad.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// wad.c

#include "quakedef.h"

int			wad_numlumps;
lumpinfo_t	*wad_lumps;
byte		*wad_base;

void SwapPic (qpic_t *pic);

/*
==================
W_CleanupName

Lowercases name and pads with spaces and a terminating 0 to the length of
lumpinfo_t->name.
Used so lumpname lookups can proceed rapidly by comparing 4 chars at a time
Space padding is so names can be printed nicely in tables.
Can safely be performed in place.
==================
*/
void W_CleanupName (char *in, char *out)
{
	int		i;
	int		c;
	
	for (i=0 ; i<16 ; i++ )
	{
		c = in[i];
		if (!c)
			break;
			
		if (c >= 'A' && c <= 'Z')
			c += ('a' - 'A');
		out[i] = (char) c;
	}
	
	for ( ; i< 16 ; i++ )
		out[i] = 0;
}



/*
====================
W_LoadWadFile
====================
*/
void W_LoadWadFile (char *filename)
{
	lumpinfo_t		*lump_p;
	wadinfo_t		*header;
	unsigned		i;
	int				infotableofs;
	
	wad_base = COM_LoadHunkFile (filename);
	if (!wad_base)
		Sys_Error ("W_LoadWadFile: couldn't load %s", filename);

	header = (wadinfo_t *)wad_base;
	
	if (header->identification[0] != 'W'
	|| header->identification[1] != 'A'
	|| header->identification[2] != 'D'
	|| header->identification[3] != '2')
		Sys_Error ("Wad file %s doesn't have WAD2 id\n",filename);
		
	wad_numlumps = LittleLong(header->numlumps);
	infotableofs = LittleLong(header->infotableofs);
	wad_lumps = (lumpinfo_t *)(wad_base + infotableofs);
	
	for (i=0, lump_p = wad_lumps ; i<wad_numlumps ; i++,lump_p++)
	{
		lump_p->filepos = LittleLong(lump_p->filepos);
		lump_p->size = LittleLong(lump_p->size);
		W_CleanupName (lump_p->name, lump_p->name);
		if (lump_p->type == TYP_QPIC)
			SwapPic ( (qpic_t *)(wad_base + lump_p->filepos));
	}
}


/*
=============
W_GetLumpinfo
=============
*/
lumpinfo_t	*W_GetLumpinfo (char *name)
{
	int		i;
	lumpinfo_t	*lump_p;
	char	clean[16];
	
	W_CleanupName (name, clean);
	
	for (lump_p=wad_lumps, i=0 ; i<wad_numlumps ; i++,lump_p++)
	{
		if (!strcmp(clean, lump_p->name))
			return lump_p;
	}
	
	Sys_Error ("W_GetLumpinfo: %s not found", name);
	return NULL;
}

void *W_GetLumpName (char *name)
{
	lumpinfo_t	*lump;
	
	lump = W_GetLumpinfo (name);
	
	return (void *)(wad_base + lump->filepos);
}

void *W_GetLumpNum (int num)
{
	lumpinfo_t	*lump;
	
	if (num < 0 || num > wad_numlumps)
		Sys_Error ("W_GetLumpNum: bad number: %i", num);
		
	lump = wad_lumps + num;
	
	return (void *)(wad_base + lump->filepos);
}

/*
=============================================================================

automatic byte swapping

=============================================================================
*/

void SwapPic (qpic_t *pic)
{
	pic->width = LittleLong(pic->width);
	pic->height = LittleLong(pic->height);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sv_phys.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sv_phys.c

#include "quakedef.h"

/*


pushmove objects do not obey gravity, and do not interact with each other or trigger fields, but block normal movement and push normal objects when they move.

onground is set for toss objects when they come to a complete rest.  it is set for steping or walking objects 

doors, plats, etc are SOLID_BSP, and MOVETYPE_PUSH
bonus items are SOLID_TRIGGER touch, and MOVETYPE_TOSS
corpses are SOLID_NOT and MOVETYPE_TOSS
crates are SOLID_BBOX and MOVETYPE_TOSS
walking monsters are SOLID_SLIDEBOX and MOVETYPE_STEP
flying/floating monsters are SOLID_SLIDEBOX and MOVETYPE_FLY

solid_edge items only clip against bsp models.

*/

cvar_t	sv_friction = {"sv_friction","4",false,true};
cvar_t	sv_stopspeed = {"sv_stopspeed","100"};
cvar_t	sv_gravity = {"sv_gravity","800",false,true};
cvar_t	sv_maxvelocity = {"sv_maxvelocity","2000"};
cvar_t	sv_nostep = {"sv_nostep","0"};

#ifdef QUAKE2
static	vec3_t	vec_origin = {0.0, 0.0, 0.0};
#endif

#define	MOVE_EPSILON	0.01

void SV_Physics_Toss (edict_t *ent);

/*
================
SV_CheckAllEnts
================
*/
void SV_CheckAllEnts (void)
{
	int			e;
	edict_t		*check;

// see if any solid entities are inside the final position
	check = NEXT_EDICT(sv.edicts);
	for (e=1 ; e<sv.num_edicts ; e++, check = NEXT_EDICT(check))
	{
		if (check->free)
			continue;
		if (check->v.movetype == MOVETYPE_PUSH
		|| check->v.movetype == MOVETYPE_NONE
#ifdef QUAKE2
		|| check->v.movetype == MOVETYPE_FOLLOW
#endif
		|| check->v.movetype == MOVETYPE_NOCLIP)
			continue;

		if (SV_TestEntityPosition (check))
			Con_Printf ("entity in invalid position\n");
	}
}

/*
================
SV_CheckVelocity
================
*/
void SV_CheckVelocity (edict_t *ent)
{
	int		i;

//
// bound velocity
//
	for (i=0 ; i<3 ; i++)
	{
		if (IS_NAN(ent->v.velocity[i]))
		{
			Con_Printf ("Got a NaN velocity on %s\n", pr_strings + ent->v.classname);
			ent->v.velocity[i] = 0;
		}
		if (IS_NAN(ent->v.origin[i]))
		{
			Con_Printf ("Got a NaN origin on %s\n", pr_strings + ent->v.classname);
			ent->v.origin[i] = 0;
		}
		if (ent->v.velocity[i] > sv_maxvelocity.value)
			ent->v.velocity[i] = sv_maxvelocity.value;
		else if (ent->v.velocity[i] < -sv_maxvelocity.value)
			ent->v.velocity[i] = -sv_maxvelocity.value;
	}
}

/*
=============
SV_RunThink

Runs thinking code if time.  There is some play in the exact time the think
function will be called, because it is called before any movement is done
in a frame.  Not used for pushmove objects, because they must be exact.
Returns false if the entity removed itself.
=============
*/
qboolean SV_RunThink (edict_t *ent)
{
	float	thinktime;

	thinktime = ent->v.nextthink;
	if (thinktime <= 0 || thinktime > sv.time + host_frametime)
		return true;
		
	if (thinktime < sv.time)
		thinktime = sv.time;	// don't let things stay in the past.
								// it is possible to start that way
								// by a trigger with a local time.
	ent->v.nextthink = 0;
	pr_global_struct->time = thinktime;
	pr_global_struct->self = EDICT_TO_PROG(ent);
	pr_global_struct->other = EDICT_TO_PROG(sv.edicts);
	PR_ExecuteProgram (ent->v.think);
	return !ent->free;
}

/*
==================
SV_Impact

Two entities have touched, so run their touch functions
==================
*/
void SV_Impact (edict_t *e1, edict_t *e2)
{
	int		old_self, old_other;
	
	old_self = pr_global_struct->self;
	old_other = pr_global_struct->other;
	
	pr_global_struct->time = sv.time;
	if (e1->v.touch && e1->v.solid != SOLID_NOT)
	{
		pr_global_struct->self = EDICT_TO_PROG(e1);
		pr_global_struct->other = EDICT_TO_PROG(e2);
		PR_ExecuteProgram (e1->v.touch);
	}
	
	if (e2->v.touch && e2->v.solid != SOLID_NOT)
	{
		pr_global_struct->self = EDICT_TO_PROG(e2);
		pr_global_struct->other = EDICT_TO_PROG(e1);
		PR_ExecuteProgram (e2->v.touch);
	}

	pr_global_struct->self = old_self;
	pr_global_struct->other = old_other;
}


/*
==================
ClipVelocity

Slide off of the impacting object
returns the blocked flags (1 = floor, 2 = step / wall)
==================
*/
#define	STOP_EPSILON	0.1

int ClipVelocity (vec3_t in, vec3_t normal, vec3_t out, float overbounce)
{
	float	backoff;
	float	change;
	int		i, blocked;
	
	blocked = 0;
	if (normal[2] > 0)
		blocked |= 1;		// floor
	if (!normal[2])
		blocked |= 2;		// step
	
	backoff = DotProduct (in, normal) * overbounce;

	for (i=0 ; i<3 ; i++)
	{
		change = normal[i]*backoff;
		out[i] = in[i] - change;
		if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			out[i] = 0;
	}
	
	return blocked;
}


/*
============
SV_FlyMove

The basic solid body movement clip that slides along multiple planes
Returns the clipflags if the velocity was modified (hit something solid)
1 = floor
2 = wall / step
4 = dead stop
If steptrace is not NULL, the trace of any vertical wall hit will be stored
============
*/
#define	MAX_CLIP_PLANES	5
int SV_FlyMove (edict_t *ent, float time, trace_t *steptrace)
{
	int			bumpcount, numbumps;
	vec3_t		dir;
	float		d;
	int			numplanes;
	vec3_t		planes[MAX_CLIP_PLANES];
	vec3_t		primal_velocity, original_velocity, new_velocity;
	int			i, j;
	trace_t		trace;
	vec3_t		end;
	float		time_left;
	int			blocked;
	
	numbumps = 4;
	
	blocked = 0;
	VectorCopy (ent->v.velocity, original_velocity);
	VectorCopy (ent->v.velocity, primal_velocity);
	numplanes = 0;
	
	time_left = time;

	for (bumpcount=0 ; bumpcount<numbumps ; bumpcount++)
	{
		if (!ent->v.velocity[0] && !ent->v.velocity[1] && !ent->v.velocity[2])
			break;

		for (i=0 ; i<3 ; i++)
			end[i] = ent->v.origin[i] + time_left * ent->v.velocity[i];

		trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, end, false, ent);

		if (trace.allsolid)
		{	// entity is trapped in another solid
			VectorCopy (vec3_origin, ent->v.velocity);
			return 3;
		}

		if (trace.fraction > 0)
		{	// actually covered some distance
			VectorCopy (trace.endpos, ent->v.origin);
			VectorCopy (ent->v.velocity, original_velocity);
			numplanes = 0;
		}

		if (trace.fraction == 1)
			 break;		// moved the entire distance

		if (!trace.ent)
			Sys_Error ("SV_FlyMove: !trace.ent");

		if (trace.plane.normal[2] > 0.7)
		{
			blocked |= 1;		// floor
			if (trace.ent->v.solid == SOLID_BSP)
			{
				ent->v.flags =	(int)ent->v.flags | FL_ONGROUND;
				ent->v.groundentity = EDICT_TO_PROG(trace.ent);
			}
		}
		if (!trace.plane.normal[2])
		{
			blocked |= 2;		// step
			if (steptrace)
				*steptrace = trace;	// save for player extrafriction
		}

//
// run the impact function
//
		SV_Impact (ent, trace.ent);
		if (ent->free)
			break;		// removed by the impact function

		
		time_left -= time_left * trace.fraction;
		
	// cliped to another plane
		if (numplanes >= MAX_CLIP_PLANES)
		{	// this shouldn't really happen
			VectorCopy (vec3_origin, ent->v.velocity);
			return 3;
		}

		VectorCopy (trace.plane.normal, planes[numplanes]);
		numplanes++;

//
// modify original_velocity so it parallels all of the clip planes
//
		for (i=0 ; i<numplanes ; i++)
		{
			ClipVelocity (original_velocity, planes[i], new_velocity, 1);
			for (j=0 ; j<numplanes ; j++)
				if (j != i)
				{
					if (DotProduct (new_velocity, planes[j]) < 0)
						break;	// not ok
				}
			if (j == numplanes)
				break;
		}
		
		if (i != numplanes)
		{	// go along this plane
			VectorCopy (new_velocity, ent->v.velocity);
		}
		else
		{	// go along the crease
			if (numplanes != 2)
			{
//				Con_Printf ("clip velocity, numplanes == %i\n",numplanes);
				VectorCopy (vec3_origin, ent->v.velocity);
				return 7;
			}
			CrossProduct (planes[0], planes[1], dir);
			d = DotProduct (dir, ent->v.velocity);
			VectorScale (dir, d, ent->v.velocity);
		}

//
// if original velocity is against the original velocity, stop dead
// to avoid tiny occilations in sloping corners
//
		if (DotProduct (ent->v.velocity, primal_velocity) <= 0)
		{
			VectorCopy (vec3_origin, ent->v.velocity);
			return blocked;
		}
	}

	return blocked;
}


/*
============
SV_AddGravity

============
*/
void SV_AddGravity (edict_t *ent)
{
	float	ent_gravity;

#ifdef QUAKE2
	if (ent->v.gravity)
		ent_gravity = ent->v.gravity;
	else
		ent_gravity = 1.0;
#else
	eval_t	*val;

	val = GetEdictFieldValue(ent, "gravity");
	if (val && val->_float)
		ent_gravity = val->_float;
	else
		ent_gravity = 1.0;
#endif
	ent->v.velocity[2] -= ent_gravity * sv_gravity.value * host_frametime;
}


/*
===============================================================================

PUSHMOVE

===============================================================================
*/

/*
============
SV_PushEntity

Does not change the entities velocity at all
============
*/
trace_t SV_PushEntity (edict_t *ent, vec3_t push)
{
	trace_t	trace;
	vec3_t	end;
		
	VectorAdd (ent->v.origin, push, end);

	if (ent->v.movetype == MOVETYPE_FLYMISSILE)
		trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, end, MOVE_MISSILE, ent);
	else if (ent->v.solid == SOLID_TRIGGER || ent->v.solid == SOLID_NOT)
	// only clip against bmodels
		trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, end, MOVE_NOMONSTERS, ent);
	else
		trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, end, MOVE_NORMAL, ent);	
	
	VectorCopy (trace.endpos, ent->v.origin);
	SV_LinkEdict (ent, true);

	if (trace.ent)
		SV_Impact (ent, trace.ent);		

	return trace;
}					


/*
============
SV_PushMove

============
*/
void SV_PushMove (edict_t *pusher, float movetime)
{
	int			i, e;
	edict_t		*check, *block;
	vec3_t		mins, maxs, move;
	vec3_t		entorig, pushorig;
	int			num_moved;
	edict_t		*moved_edict[MAX_EDICTS];
	vec3_t		moved_from[MAX_EDICTS];

	if (!pusher->v.velocity[0] && !pusher->v.velocity[1] && !pusher->v.velocity[2])
	{
		pusher->v.ltime += movetime;
		return;
	}

	for (i=0 ; i<3 ; i++)
	{
		move[i] = pusher->v.velocity[i] * movetime;
		mins[i] = pusher->v.absmin[i] + move[i];
		maxs[i] = pusher->v.absmax[i] + move[i];
	}

	VectorCopy (pusher->v.origin, pushorig);
	
// move the pusher to it's final position

	VectorAdd (pusher->v.origin, move, pusher->v.origin);
	pusher->v.ltime += movetime;
	SV_LinkEdict (pusher, false);


// see if any solid entities are inside the final position
	num_moved = 0;
	check = NEXT_EDICT(sv.edicts);
	for (e=1 ; e<sv.num_edicts ; e++, check = NEXT_EDICT(check))
	{
		if (check->free)
			continue;
		if (check->v.movetype == MOVETYPE_PUSH
		|| check->v.movetype == MOVETYPE_NONE
#ifdef QUAKE2
		|| check->v.movetype == MOVETYPE_FOLLOW
#endif
		|| check->v.movetype == MOVETYPE_NOCLIP)
			continue;

	// if the entity is standing on the pusher, it will definately be moved
		if ( ! ( ((int)check->v.flags & FL_ONGROUND)
		&& PROG_TO_EDICT(check->v.groundentity) == pusher) )
		{
			if ( check->v.absmin[0] >= maxs[0]
			|| check->v.absmin[1] >= maxs[1]
			|| check->v.absmin[2] >= maxs[2]
			|| check->v.absmax[0] <= mins[0]
			|| check->v.absmax[1] <= mins[1]
			|| check->v.absmax[2] <= mins[2] )
				continue;

		// see if the ent's bbox is inside the pusher's final position
			if (!SV_TestEntityPosition (check))
				continue;
		}

	// remove the onground flag for non-players
		if (check->v.movetype != MOVETYPE_WALK)
			check->v.flags = (int)check->v.flags & ~FL_ONGROUND;
		
		VectorCopy (check->v.origin, entorig);
		VectorCopy (check->v.origin, moved_from[num_moved]);
		moved_edict[num_moved] = check;
		num_moved++;

		// try moving the contacted entity 
		pusher->v.solid = SOLID_NOT;
		SV_PushEntity (check, move);
		pusher->v.solid = SOLID_BSP;

	// if it is still inside the pusher, block
		block = SV_TestEntityPosition (check);
		if (block)
		{	// fail the move
			if (check->v.mins[0] == check->v.maxs[0])
				continue;
			if (check->v.solid == SOLID_NOT || check->v.solid == SOLID_TRIGGER)
			{	// corpse
				check->v.mins[0] = check->v.mins[1] = 0;
				VectorCopy (check->v.mins, check->v.maxs);
				continue;
			}
			
			VectorCopy (entorig, check->v.origin);
			SV_LinkEdict (check, true);

			VectorCopy (pushorig, pusher->v.origin);
			SV_LinkEdict (pusher, false);
			pusher->v.ltime -= movetime;

			// if the pusher has a "blocked" function, call it
			// otherwise, just stay in place until the obstacle is gone
			if (pusher->v.blocked)
			{
				pr_global_struct->self = EDICT_TO_PROG(pusher);
				pr_global_struct->other = EDICT_TO_PROG(check);
				PR_ExecuteProgram (pusher->v.blocked);
			}
			
		// move back any entities we already moved
			for (i=0 ; i<num_moved ; i++)
			{
				VectorCopy (moved_from[i], moved_edict[i]->v.origin);
				SV_LinkEdict (moved_edict[i], false);
			}
			return;
		}	
	}

	
}

#ifdef QUAKE2
/*
============
SV_PushRotate

============
*/
void SV_PushRotate (edict_t *pusher, float movetime)
{
	int			i, e;
	edict_t		*check, *block;
	vec3_t		move, a, amove;
	vec3_t		entorig, pushorig;
	int			num_moved;
	edict_t		*moved_edict[MAX_EDICTS];
	vec3_t		moved_from[MAX_EDICTS];
	vec3_t		org, org2;
	vec3_t		forward, right, up;

	if (!pusher->v.avelocity[0] && !pusher->v.avelocity[1] && !pusher->v.avelocity[2])
	{
		pusher->v.ltime += movetime;
		return;
	}

	for (i=0 ; i<3 ; i++)
		amove[i] = pusher->v.avelocity[i] * movetime;

	VectorSubtract (vec3_origin, amove, a);
	AngleVectors (a, forward, right, up);

	VectorCopy (pusher->v.angles, pushorig);
	
// move the pusher to it's final position

	VectorAdd (pusher->v.angles, amove, pusher->v.angles);
	pusher->v.ltime += movetime;
	SV_LinkEdict (pusher, false);


// see if any solid entities are inside the final position
	num_moved = 0;
	check = NEXT_EDICT(sv.edicts);
	for (e=1 ; e<sv.num_edicts ; e++, check = NEXT_EDICT(check))
	{
		if (check->free)
			continue;
		if (check->v.movetype == MOVETYPE_PUSH
		|| check->v.movetype == MOVETYPE_NONE
		|| check->v.movetype == MOVETYPE_FOLLOW
		|| check->v.movetype == MOVETYPE_NOCLIP)
			continue;

	// if the entity is standing on the pusher, it will definately be moved
		if ( ! ( ((int)check->v.flags & FL_ONGROUND)
		&& PROG_TO_EDICT(check->v.groundentity) == pusher) )
		{
			if ( check->v.absmin[0] >= pusher->v.absmax[0]
			|| check->v.absmin[1] >= pusher->v.absmax[1]
			|| check->v.absmin[2] >= pusher->v.absmax[2]
			|| check->v.absmax[0] <= pusher->v.absmin[0]
			|| check->v.absmax[1] <= pusher->v.absmin[1]
			|| check->v.absmax[2] <= pusher->v.absmin[2] )
				continue;

		// see if the ent's bbox is inside the pusher's final position
			if (!SV_TestEntityPosition (check))
				continue;
		}

	// remove the onground flag for non-players
		if (check->v.movetype != MOVETYPE_WALK)
			check->v.flags = (int)check->v.flags & ~FL_ONGROUND;
		
		VectorCopy (check->v.origin, entorig);
		VectorCopy (check->v.origin, moved_from[num_moved]);
		moved_edict[num_moved] = check;
		num_moved++;

		// calculate destination position
		VectorSubtract (check->v.origin, pusher->v.origin, org);
		org2[0] = DotProduct (org, forward);
		org2[1] = -DotProduct (org, right);
		org2[2] = DotProduct (org, up);
		VectorSubtract (org2, org, move);

		// try moving the contacted entity 
		pusher->v.solid = SOLID_NOT;
		SV_PushEntity (check, move);
		pusher->v.solid = SOLID_BSP;

	// if it is still inside the pusher, block
		block = SV_TestEntityPosition (check);
		if (block)
		{	// fail the move
			if (check->v.mins[0] == check->v.maxs[0])
				continue;
			if (check->v.solid == SOLID_NOT || check->v.solid == SOLID_TRIGGER)
			{	// corpse
				check->v.mins[0] = check->v.mins[1] = 0;
				VectorCopy (check->v.mins, check->v.maxs);
				continue;
			}
			
			VectorCopy (entorig, check->v.origin);
			SV_LinkEdict (check, true);

			VectorCopy (pushorig, pusher->v.angles);
			SV_LinkEdict (pusher, false);
			pusher->v.ltime -= movetime;

			// if the pusher has a "blocked" function, call it
			// otherwise, just stay in place until the obstacle is gone
			if (pusher->v.blocked)
			{
				pr_global_struct->self = EDICT_TO_PROG(pusher);
				pr_global_struct->other = EDICT_TO_PROG(check);
				PR_ExecuteProgram (pusher->v.blocked);
			}
			
		// move back any entities we already moved
			for (i=0 ; i<num_moved ; i++)
			{
				VectorCopy (moved_from[i], moved_edict[i]->v.origin);
				VectorSubtract (moved_edict[i]->v.angles, amove, moved_edict[i]->v.angles);
				SV_LinkEdict (moved_edict[i], false);
			}
			return;
		}
		else
		{
			VectorAdd (check->v.angles, amove, check->v.angles);
		}
	}

	
}
#endif

/*
================
SV_Physics_Pusher

================
*/
void SV_Physics_Pusher (edict_t *ent)
{
	float	thinktime;
	float	oldltime;
	float	movetime;

	oldltime = ent->v.ltime;
	
	thinktime = ent->v.nextthink;
	if (thinktime < ent->v.ltime + host_frametime)
	{
		movetime = thinktime - ent->v.ltime;
		if (movetime < 0)
			movetime = 0;
	}
	else
		movetime = host_frametime;

	if (movetime)
	{
#ifdef QUAKE2
		if (ent->v.avelocity[0] || ent->v.avelocity[1] || ent->v.avelocity[2])
			SV_PushRotate (ent, movetime);
		else
#endif
			SV_PushMove (ent, movetime);	// advances ent->v.ltime if not blocked
	}
		
	if (thinktime > oldltime && thinktime <= ent->v.ltime)
	{
		ent->v.nextthink = 0;
		pr_global_struct->time = sv.time;
		pr_global_struct->self = EDICT_TO_PROG(ent);
		pr_global_struct->other = EDICT_TO_PROG(sv.edicts);
		PR_ExecuteProgram (ent->v.think);
		if (ent->free)
			return;
	}

}


/*
===============================================================================

CLIENT MOVEMENT

===============================================================================
*/

/*
=============
SV_CheckStuck

This is a big hack to try and fix the rare case of getting stuck in the world
clipping hull.
=============
*/
void SV_CheckStuck (edict_t *ent)
{
	int		i, j;
	int		z;
	vec3_t	org;

	if (!SV_TestEntityPosition(ent))
	{
		VectorCopy (ent->v.origin, ent->v.oldorigin);
		return;
	}

	VectorCopy (ent->v.origin, org);
	VectorCopy (ent->v.oldorigin, ent->v.origin);
	if (!SV_TestEntityPosition(ent))
	{
		Con_DPrintf ("Unstuck.\n");
		SV_LinkEdict (ent, true);
		return;
	}
	
	for (z=0 ; z< 18 ; z++)
		for (i=-1 ; i <= 1 ; i++)
			for (j=-1 ; j <= 1 ; j++)
			{
				ent->v.origin[0] = org[0] + i;
				ent->v.origin[1] = org[1] + j;
				ent->v.origin[2] = org[2] + z;
				if (!SV_TestEntityPosition(ent))
				{
					Con_DPrintf ("Unstuck.\n");
					SV_LinkEdict (ent, true);
					return;
				}
			}
			
	VectorCopy (org, ent->v.origin);
	Con_DPrintf ("player is stuck.\n");
}


/*
=============
SV_CheckWater
=============
*/
qboolean SV_CheckWater (edict_t *ent)
{
	vec3_t	point;
	int		cont;
#ifdef QUAKE2
	int		truecont;
#endif

	point[0] = ent->v.origin[0];
	point[1] = ent->v.origin[1];
	point[2] = ent->v.origin[2] + ent->v.mins[2] + 1;	
	
	ent->v.waterlevel = 0;
	ent->v.watertype = CONTENTS_EMPTY;
	cont = SV_PointContents (point);
	if (cont <= CONTENTS_WATER)
	{
#ifdef QUAKE2
		truecont = SV_TruePointContents (point);
#endif
		ent->v.watertype = cont;
		ent->v.waterlevel = 1;
		point[2] = ent->v.origin[2] + (ent->v.mins[2] + ent->v.maxs[2])*0.5;
		cont = SV_PointContents (point);
		if (cont <= CONTENTS_WATER)
		{
			ent->v.waterlevel = 2;
			point[2] = ent->v.origin[2] + ent->v.view_ofs[2];
			cont = SV_PointContents (point);
			if (cont <= CONTENTS_WATER)
				ent->v.waterlevel = 3;
		}
#ifdef QUAKE2
		if (truecont <= CONTENTS_CURRENT_0 && truecont >= CONTENTS_CURRENT_DOWN)
		{
			static vec3_t current_table[] =
			{
				{1, 0, 0},
				{0, 1, 0},
				{-1, 0, 0},
				{0, -1, 0},
				{0, 0, 1},
				{0, 0, -1}
			};

			VectorMA (ent->v.basevelocity, 150.0*ent->v.waterlevel/3.0, current_table[CONTENTS_CURRENT_0 - truecont], ent->v.basevelocity);
		}
#endif
	}
	
	return ent->v.waterlevel > 1;
}

/*
============
SV_WallFriction

============
*/
void SV_WallFriction (edict_t *ent, trace_t *trace)
{
	vec3_t		forward, right, up;
	float		d, i;
	vec3_t		into, side;
	
	AngleVectors (ent->v.v_angle, forward, right, up);
	d = DotProduct (trace->plane.normal, forward);
	
	d += 0.5;
	if (d >= 0)
		return;
		
// cut the tangential velocity
	i = DotProduct (trace->plane.normal, ent->v.velocity);
	VectorScale (trace->plane.normal, i, into);
	VectorSubtract (ent->v.velocity, into, side);
	
	ent->v.velocity[0] = side[0] * (1 + d);
	ent->v.velocity[1] = side[1] * (1 + d);
}

/*
=====================
SV_TryUnstick

Player has come to a dead stop, possibly due to the problem with limited
float precision at some angle joins in the BSP hull.

Try fixing by pushing one pixel in each direction.

This is a hack, but in the interest of good gameplay...
======================
*/
int SV_TryUnstick (edict_t *ent, vec3_t oldvel)
{
	int		i;
	vec3_t	oldorg;
	vec3_t	dir;
	int		clip;
	trace_t	steptrace;
	
	VectorCopy (ent->v.origin, oldorg);
	VectorCopy (vec3_origin, dir);

	for (i=0 ; i<8 ; i++)
	{
// try pushing a little in an axial direction
		switch (i)
		{
			case 0:	dir[0] = 2; dir[1] = 0; break;
			case 1:	dir[0] = 0; dir[1] = 2; break;
			case 2:	dir[0] = -2; dir[1] = 0; break;
			case 3:	dir[0] = 0; dir[1] = -2; break;
			case 4:	dir[0] = 2; dir[1] = 2; break;
			case 5:	dir[0] = -2; dir[1] = 2; break;
			case 6:	dir[0] = 2; dir[1] = -2; break;
			case 7:	dir[0] = -2; dir[1] = -2; break;
		}
		
		SV_PushEntity (ent, dir);

// retry the original move
		ent->v.velocity[0] = oldvel[0];
		ent->v. velocity[1] = oldvel[1];
		ent->v. velocity[2] = 0;
		clip = SV_FlyMove (ent, 0.1, &steptrace);

		if ( fabs(oldorg[1] - ent->v.origin[1]) > 4
		|| fabs(oldorg[0] - ent->v.origin[0]) > 4 )
		{
//Con_DPrintf ("unstuck!\n");
			return clip;
		}
			
// go back to the original pos and try again
		VectorCopy (oldorg, ent->v.origin);
	}
	
	VectorCopy (vec3_origin, ent->v.velocity);
	return 7;		// still not moving
}

/*
=====================
SV_WalkMove

Only used by players
======================
*/
#define	STEPSIZE	18
void SV_WalkMove (edict_t *ent)
{
	vec3_t		upmove, downmove;
	vec3_t		oldorg, oldvel;
	vec3_t		nosteporg, nostepvel;
	int			clip;
	int			oldonground;
	trace_t		steptrace, downtrace;
	
//
// do a regular slide move unless it looks like you ran into a step
//
	oldonground = (int)ent->v.flags & FL_ONGROUND;
	ent->v.flags = (int)ent->v.flags & ~FL_ONGROUND;
	
	VectorCopy (ent->v.origin, oldorg);
	VectorCopy (ent->v.velocity, oldvel);
	
	clip = SV_FlyMove (ent, host_frametime, &steptrace);

	if ( !(clip & 2) )
		return;		// move didn't block on a step

	if (!oldonground && ent->v.waterlevel == 0)
		return;		// don't stair up while jumping
	
	if (ent->v.movetype != MOVETYPE_WALK)
		return;		// gibbed by a trigger
	
	if (sv_nostep.value)
		return;
	
	if ( (int)sv_player->v.flags & FL_WATERJUMP )
		return;

	VectorCopy (ent->v.origin, nosteporg);
	VectorCopy (ent->v.velocity, nostepvel);

//
// try moving up and forward to go up a step
//
	VectorCopy (oldorg, ent->v.origin);	// back to start pos

	VectorCopy (vec3_origin, upmove);
	VectorCopy (vec3_origin, downmove);
	upmove[2] = STEPSIZE;
	downmove[2] = -STEPSIZE + oldvel[2]*host_frametime;

// move up
	SV_PushEntity (ent, upmove);	// FIXME: don't link?

// move forward
	ent->v.velocity[0] = oldvel[0];
	ent->v. velocity[1] = oldvel[1];
	ent->v. velocity[2] = 0;
	clip = SV_FlyMove (ent, host_frametime, &steptrace);

// check for stuckness, possibly due to the limited precision of floats
// in the clipping hulls
	if (clip)
	{
		if ( fabs(oldorg[1] - ent->v.origin[1]) < 0.03125
		&& fabs(oldorg[0] - ent->v.origin[0]) < 0.03125 )
		{	// stepping up didn't make any progress
			clip = SV_TryUnstick (ent, oldvel);
		}
	}
	
// extra friction based on view angle
	if ( clip & 2 )
		SV_WallFriction (ent, &steptrace);

// move down
	downtrace = SV_PushEntity (ent, downmove);	// FIXME: don't link?

	if (downtrace.plane.normal[2] > 0.7)
	{
		if (ent->v.solid == SOLID_BSP)
		{
			ent->v.flags =	(int)ent->v.flags | FL_ONGROUND;
			ent->v.groundentity = EDICT_TO_PROG(downtrace.ent);
		}
	}
	else
	{
// if the push down didn't end up on good ground, use the move without
// the step up.  This happens near wall / slope combinations, and can
// cause the player to hop up higher on a slope too steep to climb	
		VectorCopy (nosteporg, ent->v.origin);
		VectorCopy (nostepvel, ent->v.velocity);
	}
}


/*
================
SV_Physics_Client

Player character actions
================
*/
void SV_Physics_Client (edict_t	*ent, int num)
{
	if ( ! svs.clients[num-1].active )
		return;		// unconnected slot

//
// call standard client pre-think
//	
	pr_global_struct->time = sv.time;
	pr_global_struct->self = EDICT_TO_PROG(ent);
	PR_ExecuteProgram (pr_global_struct->PlayerPreThink);
	
//
// do a move
//
	SV_CheckVelocity (ent);

//
// decide which move function to call
//
	switch ((int)ent->v.movetype)
	{
	case MOVETYPE_NONE:
		if (!SV_RunThink (ent))
			return;
		break;

	case MOVETYPE_WALK:
		if (!SV_RunThink (ent))
			return;
		if (!SV_CheckWater (ent) && ! ((int)ent->v.flags & FL_WATERJUMP) )
			SV_AddGravity (ent);
		SV_CheckStuck (ent);
#ifdef QUAKE2
		VectorAdd (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);
#endif
		SV_WalkMove (ent);

#ifdef QUAKE2
		VectorSubtract (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);
#endif
		break;
		
	case MOVETYPE_TOSS:
	case MOVETYPE_BOUNCE:
		SV_Physics_Toss (ent);
		break;

	case MOVETYPE_FLY:
		if (!SV_RunThink (ent))
			return;
		SV_FlyMove (ent, host_frametime, NULL);
		break;
		
	case MOVETYPE_NOCLIP:
		if (!SV_RunThink (ent))
			return;
		VectorMA (ent->v.origin, host_frametime, ent->v.velocity, ent->v.origin);
		break;
		
	default:
		Sys_Error ("SV_Physics_client: bad movetype %i", (int)ent->v.movetype);
	}

//
// call standard player post-think
//		
	SV_LinkEdict (ent, true);

	pr_global_struct->time = sv.time;
	pr_global_struct->self = EDICT_TO_PROG(ent);
	PR_ExecuteProgram (pr_global_struct->PlayerPostThink);
}

//============================================================================

/*
=============
SV_Physics_None

Non moving objects can only think
=============
*/
void SV_Physics_None (edict_t *ent)
{
// regular thinking
	SV_RunThink (ent);
}

#ifdef QUAKE2
/*
=============
SV_Physics_Follow

Entities that are "stuck" to another entity
=============
*/
void SV_Physics_Follow (edict_t *ent)
{
// regular thinking
	SV_RunThink (ent);
	VectorAdd (PROG_TO_EDICT(ent->v.aiment)->v.origin, ent->v.v_angle, ent->v.origin);
	SV_LinkEdict (ent, true);
}
#endif

/*
=============
SV_Physics_Noclip

A moving object that doesn't obey physics
=============
*/
void SV_Physics_Noclip (edict_t *ent)
{
// regular thinking
	if (!SV_RunThink (ent))
		return;
	
	VectorMA (ent->v.angles, host_frametime, ent->v.avelocity, ent->v.angles);
	VectorMA (ent->v.origin, host_frametime, ent->v.velocity, ent->v.origin);

	SV_LinkEdict (ent, false);
}

/*
==============================================================================

TOSS / BOUNCE

==============================================================================
*/

/*
=============
SV_CheckWaterTransition

=============
*/
void SV_CheckWaterTransition (edict_t *ent)
{
	int		cont;
#ifdef QUAKE2
	vec3_t	point;
	
	point[0] = ent->v.origin[0];
	point[1] = ent->v.origin[1];
	point[2] = ent->v.origin[2] + ent->v.mins[2] + 1;	
	cont = SV_PointContents (point);
#else
	cont = SV_PointContents (ent->v.origin);
#endif
	if (!ent->v.watertype)
	{	// just spawned here
		ent->v.watertype = cont;
		ent->v.waterlevel = 1;
		return;
	}
	
	if (cont <= CONTENTS_WATER)
	{
		if (ent->v.watertype == CONTENTS_EMPTY)
		{	// just crossed into water
			SV_StartSound (ent, 0, "misc/h2ohit1.wav", 255, 1);
		}		
		ent->v.watertype = cont;
		ent->v.waterlevel = 1;
	}
	else
	{
		if (ent->v.watertype != CONTENTS_EMPTY)
		{	// just crossed into water
			SV_StartSound (ent, 0, "misc/h2ohit1.wav", 255, 1);
		}		
		ent->v.watertype = CONTENTS_EMPTY;
		ent->v.waterlevel = cont;
	}
}

/*
=============
SV_Physics_Toss

Toss, bounce, and fly movement.  When onground, do nothing.
=============
*/
void SV_Physics_Toss (edict_t *ent)
{
	trace_t	trace;
	vec3_t	move;
	float	backoff;
#ifdef QUAKE2
	edict_t	*groundentity;

	groundentity = PROG_TO_EDICT(ent->v.groundentity);
	if ((int)groundentity->v.flags & FL_CONVEYOR)
		VectorScale(groundentity->v.movedir, groundentity->v.speed, ent->v.basevelocity);
	else
		VectorCopy(vec_origin, ent->v.basevelocity);
	SV_CheckWater (ent);
#endif
	// regular thinking
	if (!SV_RunThink (ent))
		return;

#ifdef QUAKE2
	if (ent->v.velocity[2] > 0)
		ent->v.flags = (int)ent->v.flags & ~FL_ONGROUND;

	if ( ((int)ent->v.flags & FL_ONGROUND) )
//@@
		if (VectorCompare(ent->v.basevelocity, vec_origin))
			return;

	SV_CheckVelocity (ent);

// add gravity
	if (! ((int)ent->v.flags & FL_ONGROUND)
		&& ent->v.movetype != MOVETYPE_FLY
		&& ent->v.movetype != MOVETYPE_BOUNCEMISSILE
		&& ent->v.movetype != MOVETYPE_FLYMISSILE)
			SV_AddGravity (ent);

#else
// if onground, return without moving
	if ( ((int)ent->v.flags & FL_ONGROUND) )
		return;

	SV_CheckVelocity (ent);

// add gravity
	if (ent->v.movetype != MOVETYPE_FLY
	&& ent->v.movetype != MOVETYPE_FLYMISSILE)
		SV_AddGravity (ent);
#endif

// move angles
	VectorMA (ent->v.angles, host_frametime, ent->v.avelocity, ent->v.angles);

// move origin
#ifdef QUAKE2
	VectorAdd (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);
#endif
	VectorScale (ent->v.velocity, host_frametime, move);
	trace = SV_PushEntity (ent, move);
#ifdef QUAKE2
	VectorSubtract (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);
#endif
	if (trace.fraction == 1)
		return;
	if (ent->free)
		return;
	
	if (ent->v.movetype == MOVETYPE_BOUNCE)
		backoff = 1.5;
#ifdef QUAKE2
	else if (ent->v.movetype == MOVETYPE_BOUNCEMISSILE)
		backoff = 2.0;
#endif
	else
		backoff = 1;

	ClipVelocity (ent->v.velocity, trace.plane.normal, ent->v.velocity, backoff);

// stop if on ground
	if (trace.plane.normal[2] > 0.7)
	{		
#ifdef QUAKE2
		if (ent->v.velocity[2] < 60 || (ent->v.movetype != MOVETYPE_BOUNCE && ent->v.movetype != MOVETYPE_BOUNCEMISSILE))
#else
		if (ent->v.velocity[2] < 60 || ent->v.movetype != MOVETYPE_BOUNCE)
#endif
		{
			ent->v.flags = (int)ent->v.flags | FL_ONGROUND;
			ent->v.groundentity = EDICT_TO_PROG(trace.ent);
			VectorCopy (vec3_origin, ent->v.velocity);
			VectorCopy (vec3_origin, ent->v.avelocity);
		}
	}
	
// check for in water
	SV_CheckWaterTransition (ent);
}

/*
===============================================================================

STEPPING MOVEMENT

===============================================================================
*/

/*
=============
SV_Physics_Step

Monsters freefall when they don't have a ground entity, otherwise
all movement is done with discrete steps.

This is also used for objects that have become still on the ground, but
will fall if the floor is pulled out from under them.
=============
*/
#ifdef QUAKE2
void SV_Physics_Step (edict_t *ent)
{
	qboolean	wasonground;
	qboolean	inwater;
	qboolean	hitsound = false;
	float		*vel;
	float		speed, newspeed, control;
	float		friction;
	edict_t		*groundentity;

	groundentity = PROG_TO_EDICT(ent->v.groundentity);
	if ((int)groundentity->v.flags & FL_CONVEYOR)
		VectorScale(groundentity->v.movedir, groundentity->v.speed, ent->v.basevelocity);
	else
		VectorCopy(vec_origin, ent->v.basevelocity);
//@@
	pr_global_struct->time = sv.time;
	pr_global_struct->self = EDICT_TO_PROG(ent);
	PF_WaterMove();

	SV_CheckVelocity (ent);

	wasonground = (int)ent->v.flags & FL_ONGROUND;
//	ent->v.flags = (int)ent->v.flags & ~FL_ONGROUND;

	// add gravity except:
	//   flying monsters
	//   swimming monsters who are in the water
	inwater = SV_CheckWater(ent);
	if (! wasonground)
		if (!((int)ent->v.flags & FL_FLY))
			if (!(((int)ent->v.flags & FL_SWIM) && (ent->v.waterlevel > 0)))
			{
				if (ent->v.velocity[2] < sv_gravity.value*-0.1)
					hitsound = true;
				if (!inwater)
					SV_AddGravity (ent);
			}

	if (!VectorCompare(ent->v.velocity, vec_origin) || !VectorCompare(ent->v.basevelocity, vec_origin))
	{
		ent->v.flags = (int)ent->v.flags & ~FL_ONGROUND;
		// apply friction
		// let dead monsters who aren't completely onground slide
		if (wasonground)
			if (!(ent->v.health <= 0.0 && !SV_CheckBottom(ent)))
			{
				vel = ent->v.velocity;
				speed = sqrt(vel[0]*vel[0] +vel[1]*vel[1]);
				if (speed)
				{
					friction = sv_friction.value;

					control = speed < sv_stopspeed.value ? sv_stopspeed.value : speed;
					newspeed = speed - host_frametime*control*friction;

					if (newspeed < 0)
						newspeed = 0;
					newspeed /= speed;

					vel[0] = vel[0] * newspeed;
					vel[1] = vel[1] * newspeed;
				}
			}

		VectorAdd (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);
		SV_FlyMove (ent, host_frametime, NULL);
		VectorSubtract (ent->v.velocity, ent->v.basevelocity, ent->v.velocity);

		// determine if it's on solid ground at all
		{
			vec3_t	mins, maxs, point;
			int		x, y;
		
			VectorAdd (ent->v.origin, ent->v.mins, mins);
			VectorAdd (ent->v.origin, ent->v.maxs, maxs);

			point[2] = mins[2] - 1;
			for	(x=0 ; x<=1 ; x++)
				for	(y=0 ; y<=1 ; y++)
				{
					point[0] = x ? maxs[0] : mins[0];
					point[1] = y ? maxs[1] : mins[1];
					if (SV_PointContents (point) == CONTENTS_SOLID)
					{
						ent->v.flags = (int)ent->v.flags | FL_ONGROUND;
						break;
					}
				}

		}

		SV_LinkEdict (ent, true);

		if ((int)ent->v.flags & FL_ONGROUND)
			if (!wasonground)
				if (hitsound)
					SV_StartSound (ent, 0, "demon/dland2.wav", 255, 1);
	}

// regular thinking
	SV_RunThink (ent);
	SV_CheckWaterTransition (ent);
}
#else
void SV_Physics_Step (edict_t *ent)
{
	qboolean	hitsound;

// freefall if not onground
	if ( ! ((int)ent->v.flags & (FL_ONGROUND | FL_FLY | FL_SWIM) ) )
	{
		if (ent->v.velocity[2] < sv_gravity.value*-0.1)
			hitsound = true;
		else
			hitsound = false;

		SV_AddGravity (ent);
		SV_CheckVelocity (ent);
		SV_FlyMove (ent, host_frametime, NULL);
		SV_LinkEdict (ent, true);

		if ( (int)ent->v.flags & FL_ONGROUND )	// just hit ground
		{
			if (hitsound)
				SV_StartSound (ent, 0, "demon/dland2.wav", 255, 1);
		}
	}

// regular thinking
	SV_RunThink (ent);
	
	SV_CheckWaterTransition (ent);
}
#endif

//============================================================================

/*
================
SV_Physics

================
*/
void SV_Physics (void)
{
	int		i;
	edict_t	*ent;

// let the progs know that a new frame has started
	pr_global_struct->self = EDICT_TO_PROG(sv.edicts);
	pr_global_struct->other = EDICT_TO_PROG(sv.edicts);
	pr_global_struct->time = sv.time;
	PR_ExecuteProgram (pr_global_struct->StartFrame);

//SV_CheckAllEnts ();

//
// treat each object in turn
//
	ent = sv.edicts;
	for (i=0 ; i<sv.num_edicts ; i++, ent = NEXT_EDICT(ent))
	{
		if (ent->free)
			continue;

		if (pr_global_struct->force_retouch)
		{
			SV_LinkEdict (ent, true);	// force retouch even for stationary
		}

		if (i > 0 && i <= svs.maxclients)
			SV_Physics_Client (ent, i);
		else if (ent->v.movetype == MOVETYPE_PUSH)
			SV_Physics_Pusher (ent);
		else if (ent->v.movetype == MOVETYPE_NONE)
			SV_Physics_None (ent);
#ifdef QUAKE2
		else if (ent->v.movetype == MOVETYPE_FOLLOW)
			SV_Physics_Follow (ent);
#endif
		else if (ent->v.movetype == MOVETYPE_NOCLIP)
			SV_Physics_Noclip (ent);
		else if (ent->v.movetype == MOVETYPE_STEP)
			SV_Physics_Step (ent);
		else if (ent->v.movetype == MOVETYPE_TOSS 
		|| ent->v.movetype == MOVETYPE_BOUNCE
#ifdef QUAKE2
		|| ent->v.movetype == MOVETYPE_BOUNCEMISSILE
#endif
		|| ent->v.movetype == MOVETYPE_FLY
		|| ent->v.movetype == MOVETYPE_FLYMISSILE)
			SV_Physics_Toss (ent);
		else
			Sys_Error ("SV_Physics: bad movetype %i", (int)ent->v.movetype);			
	}
	
	if (pr_global_struct->force_retouch)
		pr_global_struct->force_retouch--;	

	sv.time += host_frametime;
}


#ifdef QUAKE2
trace_t SV_Trace_Toss (edict_t *ent, edict_t *ignore)
{
	edict_t	tempent, *tent;
	trace_t	trace;
	vec3_t	move;
	vec3_t	end;
	double	save_frametime;
//	extern particle_t	*active_particles, *free_particles;
//	particle_t	*p;


	save_frametime = host_frametime;
	host_frametime = 0.05;

	memcpy(&tempent, ent, sizeof(edict_t));
	tent = &tempent;

	while (1)
	{
		SV_CheckVelocity (tent);
		SV_AddGravity (tent);
		VectorMA (tent->v.angles, host_frametime, tent->v.avelocity, tent->v.angles);
		VectorScale (tent->v.velocity, host_frametime, move);
		VectorAdd (tent->v.origin, move, end);
		trace = SV_Move (tent->v.origin, tent->v.mins, tent->v.maxs, end, MOVE_NORMAL, tent);	
		VectorCopy (trace.endpos, tent->v.origin);

//		p = free_particles;
//		if (p)
//		{
//			free_particles = p->next;
//			p->next = active_particles;
//			active_particles = p;
//		
//			p->die = 256;
//			p->color = 15;
//			p->type = pt_static;
//			VectorCopy (vec3_origin, p->vel);
//			VectorCopy (tent->v.origin, p->org);
//		}

		if (trace.ent)
			if (trace.ent != ignore)
				break;
	}
//	p->color = 224;
	host_frametime = save_frametime;
	return trace;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\sv_user.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// sv_user.c -- server code for moving users

#include "quakedef.h"

edict_t	*sv_player;

extern	cvar_t	sv_friction;
cvar_t	sv_edgefriction = {"edgefriction", "2"};
extern	cvar_t	sv_stopspeed;

static	vec3_t		forward, right, up;

vec3_t	wishdir;
float	wishspeed;

// world
float	*angles;
float	*origin;
float	*velocity;

qboolean	onground;

usercmd_t	cmd;

cvar_t	sv_idealpitchscale = {"sv_idealpitchscale","0.8"};


/*
===============
SV_SetIdealPitch
===============
*/
#define	MAX_FORWARD	6
void SV_SetIdealPitch (void)
{
	float	angleval, sinval, cosval;
	trace_t	tr;
	vec3_t	top, bottom;
	float	z[MAX_FORWARD];
	int		i, j;
	int		step, dir, steps;

	if (!((int)sv_player->v.flags & FL_ONGROUND))
		return;
		
	angleval = sv_player->v.angles[YAW] * M_PI*2 / 360;
	sinval = sin(angleval);
	cosval = cos(angleval);

	for (i=0 ; i<MAX_FORWARD ; i++)
	{
		top[0] = sv_player->v.origin[0] + cosval*(i+3)*12;
		top[1] = sv_player->v.origin[1] + sinval*(i+3)*12;
		top[2] = sv_player->v.origin[2] + sv_player->v.view_ofs[2];
		
		bottom[0] = top[0];
		bottom[1] = top[1];
		bottom[2] = top[2] - 160;
		
		tr = SV_Move (top, vec3_origin, vec3_origin, bottom, 1, sv_player);
		if (tr.allsolid)
			return;	// looking at a wall, leave ideal the way is was

		if (tr.fraction == 1)
			return;	// near a dropoff
		
		z[i] = top[2] + tr.fraction*(bottom[2]-top[2]);
	}
	
	dir = 0;
	steps = 0;
	for (j=1 ; j<i ; j++)
	{
		step = z[j] - z[j-1];
		if (step > -ON_EPSILON && step < ON_EPSILON)
			continue;

		if (dir && ( step-dir > ON_EPSILON || step-dir < -ON_EPSILON ) )
			return;		// mixed changes

		steps++;	
		dir = step;
	}
	
	if (!dir)
	{
		sv_player->v.idealpitch = 0;
		return;
	}
	
	if (steps < 2)
		return;
	sv_player->v.idealpitch = -dir * sv_idealpitchscale.value;
}


/*
==================
SV_UserFriction

==================
*/
void SV_UserFriction (void)
{
	float	*vel;
	float	speed, newspeed, control;
	vec3_t	start, stop;
	float	friction;
	trace_t	trace;
	
	vel = velocity;
	
	speed = sqrt(vel[0]*vel[0] +vel[1]*vel[1]);
	if (!speed)
		return;

// if the leading edge is over a dropoff, increase friction
	start[0] = stop[0] = origin[0] + vel[0]/speed*16;
	start[1] = stop[1] = origin[1] + vel[1]/speed*16;
	start[2] = origin[2] + sv_player->v.mins[2];
	stop[2] = start[2] - 34;

	trace = SV_Move (start, vec3_origin, vec3_origin, stop, true, sv_player);

	if (trace.fraction == 1.0)
		friction = sv_friction.value*sv_edgefriction.value;
	else
		friction = sv_friction.value;

// apply friction	
	control = speed < sv_stopspeed.value ? sv_stopspeed.value : speed;
	newspeed = speed - host_frametime*control*friction;
	
	if (newspeed < 0)
		newspeed = 0;
	newspeed /= speed;

	vel[0] = vel[0] * newspeed;
	vel[1] = vel[1] * newspeed;
	vel[2] = vel[2] * newspeed;
}

/*
==============
SV_Accelerate
==============
*/
cvar_t	sv_maxspeed = {"sv_maxspeed", "320", false, true};
cvar_t	sv_accelerate = {"sv_accelerate", "10"};
#if 0
void SV_Accelerate (vec3_t wishvel)
{
	int			i;
	float		addspeed, accelspeed;
	vec3_t		pushvec;

	if (wishspeed == 0)
		return;

	VectorSubtract (wishvel, velocity, pushvec);
	addspeed = VectorNormalize (pushvec);

	accelspeed = sv_accelerate.value*host_frametime*addspeed;
	if (accelspeed > addspeed)
		accelspeed = addspeed;
	
	for (i=0 ; i<3 ; i++)
		velocity[i] += accelspeed*pushvec[i];	
}
#endif
void SV_Accelerate (void)
{
	int			i;
	float		addspeed, accelspeed, currentspeed;

	currentspeed = DotProduct (velocity, wishdir);
	addspeed = wishspeed - currentspeed;
	if (addspeed <= 0)
		return;
	accelspeed = sv_accelerate.value*host_frametime*wishspeed;
	if (accelspeed > addspeed)
		accelspeed = addspeed;
	
	for (i=0 ; i<3 ; i++)
		velocity[i] += accelspeed*wishdir[i];	
}

void SV_AirAccelerate (vec3_t wishveloc)
{
	int			i;
	float		addspeed, wishspd, accelspeed, currentspeed;
		
	wishspd = VectorNormalize (wishveloc);
	if (wishspd > 30)
		wishspd = 30;
	currentspeed = DotProduct (velocity, wishveloc);
	addspeed = wishspd - currentspeed;
	if (addspeed <= 0)
		return;
//	accelspeed = sv_accelerate.value * host_frametime;
	accelspeed = sv_accelerate.value*wishspeed * host_frametime;
	if (accelspeed > addspeed)
		accelspeed = addspeed;
	
	for (i=0 ; i<3 ; i++)
		velocity[i] += accelspeed*wishveloc[i];	
}


void DropPunchAngle (void)
{
	float	len;
	
	len = VectorNormalize (sv_player->v.punchangle);
	
	len -= 10*host_frametime;
	if (len < 0)
		len = 0;
	VectorScale (sv_player->v.punchangle, len, sv_player->v.punchangle);
}

/*
===================
SV_WaterMove

===================
*/
void SV_WaterMove (void)
{
	int		i;
	vec3_t	wishvel;
	float	speed, newspeed, wishspeed, addspeed, accelspeed;

//
// user intentions
//
	AngleVectors (sv_player->v.v_angle, forward, right, up);

	for (i=0 ; i<3 ; i++)
		wishvel[i] = forward[i]*cmd.forwardmove + right[i]*cmd.sidemove;

	if (!cmd.forwardmove && !cmd.sidemove && !cmd.upmove)
		wishvel[2] -= 60;		// drift towards bottom
	else
		wishvel[2] += cmd.upmove;

	wishspeed = Length(wishvel);
	if (wishspeed > sv_maxspeed.value)
	{
		VectorScale (wishvel, sv_maxspeed.value/wishspeed, wishvel);
		wishspeed = sv_maxspeed.value;
	}
	wishspeed *= 0.7;

//
// water friction
//
	speed = Length (velocity);
	if (speed)
	{
		newspeed = speed - host_frametime * speed * sv_friction.value;
		if (newspeed < 0)
			newspeed = 0;	
		VectorScale (velocity, newspeed/speed, velocity);
	}
	else
		newspeed = 0;
	
//
// water acceleration
//
	if (!wishspeed)
		return;

	addspeed = wishspeed - newspeed;
	if (addspeed <= 0)
		return;

	VectorNormalize (wishvel);
	accelspeed = sv_accelerate.value * wishspeed * host_frametime;
	if (accelspeed > addspeed)
		accelspeed = addspeed;

	for (i=0 ; i<3 ; i++)
		velocity[i] += accelspeed * wishvel[i];
}

void SV_WaterJump (void)
{
	if (sv.time > sv_player->v.teleport_time
	|| !sv_player->v.waterlevel)
	{
		sv_player->v.flags = (int)sv_player->v.flags & ~FL_WATERJUMP;
		sv_player->v.teleport_time = 0;
	}
	sv_player->v.velocity[0] = sv_player->v.movedir[0];
	sv_player->v.velocity[1] = sv_player->v.movedir[1];
}


/*
===================
SV_AirMove

===================
*/
void SV_AirMove (void)
{
	int			i;
	vec3_t		wishvel;
	float		fmove, smove;

	AngleVectors (sv_player->v.angles, forward, right, up);

	fmove = cmd.forwardmove;
	smove = cmd.sidemove;
	
// hack to not let you back into teleporter
	if (sv.time < sv_player->v.teleport_time && fmove < 0)
		fmove = 0;
		
	for (i=0 ; i<3 ; i++)
		wishvel[i] = forward[i]*fmove + right[i]*smove;

	if ( (int)sv_player->v.movetype != MOVETYPE_WALK)
		wishvel[2] = cmd.upmove;
	else
		wishvel[2] = 0;

	VectorCopy (wishvel, wishdir);
	wishspeed = VectorNormalize(wishdir);
	if (wishspeed > sv_maxspeed.value)
	{
		VectorScale (wishvel, sv_maxspeed.value/wishspeed, wishvel);
		wishspeed = sv_maxspeed.value;
	}
	
	if ( sv_player->v.movetype == MOVETYPE_NOCLIP)
	{	// noclip
		VectorCopy (wishvel, velocity);
	}
	else if ( onground )
	{
		SV_UserFriction ();
		SV_Accelerate ();
	}
	else
	{	// not on ground, so little effect on velocity
		SV_AirAccelerate (wishvel);
	}		
}

/*
===================
SV_ClientThink

the move fields specify an intended velocity in pix/sec
the angle fields specify an exact angular motion in degrees
===================
*/
void SV_ClientThink (void)
{
	vec3_t		v_angle;

	if (sv_player->v.movetype == MOVETYPE_NONE)
		return;
	
	onground = (int)sv_player->v.flags & FL_ONGROUND;

	origin = sv_player->v.origin;
	velocity = sv_player->v.velocity;

	DropPunchAngle ();
	
//
// if dead, behave differently
//
	if (sv_player->v.health <= 0)
		return;

//
// angles
// show 1/3 the pitch angle and all the roll angle
	cmd = host_client->cmd;
	angles = sv_player->v.angles;
	
	VectorAdd (sv_player->v.v_angle, sv_player->v.punchangle, v_angle);
	angles[ROLL] = V_CalcRoll (sv_player->v.angles, sv_player->v.velocity)*4;
	if (!sv_player->v.fixangle)
	{
		angles[PITCH] = -v_angle[PITCH]/3;
		angles[YAW] = v_angle[YAW];
	}

	if ( (int)sv_player->v.flags & FL_WATERJUMP )
	{
		SV_WaterJump ();
		return;
	}
//
// walk
//
	if ( (sv_player->v.waterlevel >= 2)
	&& (sv_player->v.movetype != MOVETYPE_NOCLIP) )
	{
		SV_WaterMove ();
		return;
	}

	SV_AirMove ();	
}


/*
===================
SV_ReadClientMove
===================
*/
void SV_ReadClientMove (usercmd_t *move)
{
	int		i;
	vec3_t	angle;
	int		bits;
	
// read ping time
	host_client->ping_times[host_client->num_pings%NUM_PING_TIMES]
		= sv.time - MSG_ReadFloat ();
	host_client->num_pings++;

// read current angles	
	for (i=0 ; i<3 ; i++)
		angle[i] = MSG_ReadAngle ();

	VectorCopy (angle, host_client->edict->v.v_angle);
		
// read movement
	move->forwardmove = MSG_ReadShort ();
	move->sidemove = MSG_ReadShort ();
	move->upmove = MSG_ReadShort ();
	
// read buttons
	bits = MSG_ReadByte ();
	host_client->edict->v.button0 = bits & 1;
	host_client->edict->v.button2 = (bits & 2)>>1;

	i = MSG_ReadByte ();
	if (i)
		host_client->edict->v.impulse = i;

#ifdef QUAKE2
// read light level
	host_client->edict->v.light_level = MSG_ReadByte ();
#endif
}

/*
===================
SV_ReadClientMessage

Returns false if the client should be killed
===================
*/
qboolean SV_ReadClientMessage (void)
{
	int		ret;
	int		cmd;
	char		*s;
	
	do
	{
nextmsg:
		ret = NET_GetMessage (host_client->netconnection);
		if (ret == -1)
		{
			Sys_Printf ("SV_ReadClientMessage: NET_GetMessage failed\n");
			return false;
		}
		if (!ret)
			return true;
					
		MSG_BeginReading ();
		
		while (1)
		{
			if (!host_client->active)
				return false;	// a command caused an error

			if (msg_badread)
			{
				Sys_Printf ("SV_ReadClientMessage: badread\n");
				return false;
			}	
	
			cmd = MSG_ReadChar ();
			
			switch (cmd)
			{
			case -1:
				goto nextmsg;		// end of message
				
			default:
				Sys_Printf ("SV_ReadClientMessage: unknown command char\n");
				return false;
							
			case clc_nop:
//				Sys_Printf ("clc_nop\n");
				break;
				
			case clc_stringcmd:	
				s = MSG_ReadString ();
				if (host_client->privileged)
					ret = 2;
				else
					ret = 0;
				if (Q_strncasecmp(s, "status", 6) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "god", 3) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "notarget", 8) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "fly", 3) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "name", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "noclip", 6) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "say", 3) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "say_team", 8) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "tell", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "color", 5) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "kill", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "pause", 5) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "spawn", 5) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "begin", 5) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "prespawn", 8) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "kick", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "ping", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "give", 4) == 0)
					ret = 1;
				else if (Q_strncasecmp(s, "ban", 3) == 0)
					ret = 1;
				if (ret == 2)
					Cbuf_InsertText (s);
				else if (ret == 1)
					Cmd_ExecuteString (s, src_client);
				else
					Con_DPrintf("%s tried to %s\n", host_client->name, s);
				break;
				
			case clc_disconnect:
//				Sys_Printf ("SV_ReadClientMessage: client disconnected\n");
				return false;
			
			case clc_move:
				SV_ReadClientMove (&host_client->cmd);
				break;
			}
		}
	} while (ret == 1);
	
	return true;
}


/*
==================
SV_RunClients
==================
*/
void SV_RunClients (void)
{
	int				i;
	
	for (i=0, host_client = svs.clients ; i<svs.maxclients ; i++, host_client++)
	{
		if (!host_client->active)
			continue;
	
		sv_player = host_client->edict;

		if (!SV_ReadClientMessage ())
		{
			SV_DropClient (false);	// client misbehaved...
			continue;
		}

		if (!host_client->spawned)
		{
		// clear client movement until a new packet is received
			memset (&host_client->cmd, 0, sizeof(host_client->cmd));
			continue;
		}

// always pause in single player if in console or menus
		if (!sv.paused && (svs.maxclients > 1 || key_dest == key_game) )
			SV_ClientThink ();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\xgc.h ===
class CGameControllers
{
    public:
        CGameControllers();
        ~CGameControllers();
        void SelectGameController();
        BOOL GetSelection(int *piControllerNumber);
        BOOL GetState(XINPUT_STATE *m_gpState);

    private:
        void DetectHotPlugs();
        BOOLEAN m_fIsSelected;
        int m_iControllerNumber;
        HANDLE m_hGameControllerArray[XGetPortCount()];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\wma.h ===
#ifdef XQUAKE_WMA

#ifndef QUAKEWMA_H
#define QUAKEWMA_H




// Define the maximum amount of packets we will ever submit to the renderer
#define FILESTRM_PACKET_COUNT 8

// Define the source packet size.  Because we have a transform filter that
// will expand the source data before sending it to the renderer, we have
// to maintain separate packet sizes: one for compressed and one for
// uncompressed.
//
// This value is hard-coded assuming a WMA file of stero, 16bit resolution.  If
// this Value can by dynamically set based on the wma format, keeping in mind
// that wma needs enough buffer for a minimum of 2048 samples worth of PCM data
// the packet is multiplied by 2 so we can have alarge amount of sound per EchoFx processing
// this increases the echo delay
//

#define FILESTRM_SOURCE_PACKET_BYTES ((2048*2*2)*2)

//-----------------------------------------------------------------------------
// Name: class CWmaFileStream
// Desc: Wave file streaming object
//-----------------------------------------------------------------------------
class CWmaFileStream
{
protected:
    XFileMediaObject*   m_pSourceFilter;                          // Source (wave file) filter
    XMediaObject*       m_pTransformFilter;                       // Transform (APDCM decompressor) filter
    IDirectSoundStream* m_pRenderFilter;                          // Render (DirectSoundStream) filter
    LPVOID              m_pvSourceBuffer;                         // Source filter data buffer
    LPVOID              m_pvRenderBuffer;                         // Render filter data buffer
    DWORD               m_adwPacketStatus[FILESTRM_PACKET_COUNT]; // Packet status array
    DWORD               m_dwFileLength;                           // File duration, in bytes
    DWORD               m_dwFileProgress;                         // File progress, in bytes
    DWORD               m_dwStartingDataOffset;                   // offset into wma file were data begins
    BOOLEAN             m_fUseIntermediateXmo;

    // Packet processing
    BOOL    FindFreePacket(DWORD* pdwPacketIndex );
    HRESULT ProcessSource(DWORD dwPacketIndex);
    HRESULT ProcessTransform( DWORD dwPacketIndex );
    HRESULT ProcessRenderer( DWORD dwPacketIndex );

public:
    // Processing
    HRESULT Process( DWORD* pdwPercentCompleted );

    // Initialization
    HRESULT Initialize( const CHAR* strFileName );
    
    CWmaFileStream();
    ~CWmaFileStream();
};




#endif // QUAKEWMA_H

#endif // XQUAKE_WMA
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\world.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// world.h

typedef struct
{
	vec3_t	normal;
	float	dist;
} plane_t;

typedef struct
{
	qboolean	allsolid;	// if true, plane is not valid
	qboolean	startsolid;	// if true, the initial point was in a solid area
	qboolean	inopen, inwater;
	float	fraction;		// time completed, 1.0 = didn't hit anything
	vec3_t	endpos;			// final position
	plane_t	plane;			// surface normal at impact
	edict_t	*ent;			// entity the surface is on
} trace_t;


#define	MOVE_NORMAL		0
#define	MOVE_NOMONSTERS	1
#define	MOVE_MISSILE	2


void SV_ClearWorld (void);
// called after the world model has been loaded, before linking any entities

void SV_UnlinkEdict (edict_t *ent);
// call before removing an entity, and before trying to move one,
// so it doesn't clip against itself
// flags ent->v.modified

void SV_LinkEdict (edict_t *ent, qboolean touch_triggers);
// Needs to be called any time an entity changes origin, mins, maxs, or solid
// flags ent->v.modified
// sets ent->v.absmin and ent->v.absmax
// if touchtriggers, calls prog functions for the intersected triggers

int SV_PointContents (vec3_t p);
int SV_TruePointContents (vec3_t p);
// returns the CONTENTS_* value from the world at the given point.
// does not check any entities at all
// the non-true version remaps the water current contents to content_water

edict_t	*SV_TestEntityPosition (edict_t *ent);

trace_t SV_Move (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int type, edict_t *passedict);
// mins and maxs are reletive

// if the entire move stays in a solid volume, trace.allsolid will be set

// if the starting point is in a solid, it will be allowed to move out
// to an open area

// nomonsters is used for line of sight or edge testing, where mosnters
// shouldn't be considered solid objects

// passedict is explicitly excluded from clipping checks (normally NULL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\xgc.cpp ===
#include <xtl.h>
#include "xgc.h"

CGameControllers::CGameControllers() : m_fIsSelected(FALSE), m_iControllerNumber(0)
{
    DWORD dwDevices = XGetDevices(XDEVICE_TYPE_GAMEPAD);
    for(int i =0; i < XGetPortCount(); i++)
    {
        if(dwDevices&(1<<i))
        {
            m_hGameControllerArray[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD,i,XDEVICE_NO_SLOT, NULL);
        } else
        {
            m_hGameControllerArray[i] = NULL;
        }
    }
}


CGameControllers::~CGameControllers()
{
    for(int i =0; i < XGetPortCount(); i++)
    {
        if(m_hGameControllerArray[i])
        {
            XInputClose(m_hGameControllerArray[i]);
            m_hGameControllerArray[i] = NULL;
        }
    }
}

void CGameControllers::SelectGameController()
{
    m_fIsSelected = FALSE;
}

BOOL CGameControllers::GetSelection(int *piControllerNumber)
{
    //
    //  Detect hot-plugs, finds new device and opens them.
    //  Closes expired ones.
    //

    DetectHotPlugs();

    //
    //  If there is no selection, try to get one.
    //
    if(!m_fIsSelected)
    {
        XINPUT_STATE InputState;
        for(int i =0; i < XGetPortCount(); i++)
        {
            if(m_hGameControllerArray[i])
            {
                if(ERROR_SUCCESS == XInputGetState(m_hGameControllerArray[i], &InputState))
                {
                    BOOL fAnalogButtonPressed = FALSE;
                    for(int j = 0; j < 8; j++)
                    {
                        if(InputState.Gamepad.bAnalogButtons[j] > 15)
                        {
                            fAnalogButtonPressed = TRUE;
                            break;
                        }
                    }
                    if(
                        fAnalogButtonPressed                ||
                        (InputState.Gamepad.wButtons)       ||
                        (InputState.Gamepad.sThumbLX > 15)  ||
                        (InputState.Gamepad.sThumbLX < -15) ||
                        (InputState.Gamepad.sThumbLY > 15)  ||
                        (InputState.Gamepad.sThumbLY < -15) ||
                        (InputState.Gamepad.sThumbRX > 15)  ||
                        (InputState.Gamepad.sThumbRX < -15) ||
                        (InputState.Gamepad.sThumbRY > 15)  ||
                        (InputState.Gamepad.sThumbRY < -15)
                    )
                    {
                        m_fIsSelected = TRUE;
                        m_iControllerNumber = i;
                        break;
                    }
                }
            }
        }
    }

    if(m_fIsSelected)
    {
        *piControllerNumber = m_iControllerNumber;
        return TRUE;
    } else
    {
        return FALSE;
    }
}

BOOL CGameControllers::GetState(XINPUT_STATE *pState)
{
    BOOL fRetVal = FALSE;
    
    DetectHotPlugs();

    if(!m_fIsSelected)
    {
        int iControllerNumber;
        GetSelection(&iControllerNumber);
    }
    if(m_fIsSelected)
    {
        if(ERROR_SUCCESS == XInputGetState(m_hGameControllerArray[m_iControllerNumber], pState))
        {
            fRetVal = TRUE;
        }
    }
    return fRetVal;
}

void CGameControllers::DetectHotPlugs()
{
    DWORD dwInsertions, dwRemovals;
    if(XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals))
    {
        for(int i =0; i < XGetPortCount(); i++)
        {
            if(dwRemovals&(1<<i))
            {
                if(i == m_iControllerNumber)
                {
                    m_fIsSelected = FALSE;
                }
                XInputClose(m_hGameControllerArray[i]);
                m_hGameControllerArray[i] = NULL;
            }

            if(dwInsertions&(1<<i))
            {
                m_hGameControllerArray[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD,i,XDEVICE_NO_SLOT, NULL);
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\wma.cpp ===
#ifdef XQUAKE_WMA

//-----------------------------------------------------------------------------
// File: wma.cpp
//
// Desc: Class for streaming wave file playback.
//
// Hist: 12.15.00 - New for December XDK release
//
// Copyright (c) 2000-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "wma.h"


//-----------------------------------------------------------------------------
// Debugging help
//-----------------------------------------------------------------------------
#define MY_ASSERT(x) if( !(x) ) _asm int 3;


CWmaFileStream *g_pWmaStream;



EXTERN_C void SND_InitWmaPlayback()
{
    HRESULT     hr;

    g_pWmaStream = new CWmaFileStream();
    MY_ASSERT(g_pWmaStream);

    hr = g_pWmaStream->Initialize("T:\\MEDIA\\AUDIO\\WMA\\STD\\test.wma");
    if( FAILED(hr) )
    {
        delete g_pWmaStream;
        g_pWmaStream = NULL;
    }
}

EXTERN_C void SND_WmaProcessStream()
{

    if( g_pWmaStream )
        g_pWmaStream->Process(NULL);

}


//-----------------------------------------------------------------------------
// Name: CWmaFileStream()
// Desc: Object constructor.
//-----------------------------------------------------------------------------
CWmaFileStream::CWmaFileStream()
{
    m_pSourceFilter    = NULL;
    m_pRenderFilter    = NULL;
    m_pvSourceBuffer   = NULL;
    
    for( DWORD i = 0; i < FILESTRM_PACKET_COUNT; i++ )
        m_adwPacketStatus[i] = XMEDIAPACKET_STATUS_SUCCESS;

    m_dwStartingDataOffset = 0;
    m_dwFileLength   = 0;
    m_dwFileProgress = 0;
}




//-----------------------------------------------------------------------------
// Name: ~CWmaFileStream()
// Desc: Object destructor.
//-----------------------------------------------------------------------------
CWmaFileStream::~CWmaFileStream()
{
    if( m_pSourceFilter )      m_pSourceFilter->Release();
    if( m_pRenderFilter )      m_pRenderFilter->Release();
    if( m_pvSourceBuffer )     delete m_pvSourceBuffer;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the wave file streaming subsystem.
//-----------------------------------------------------------------------------
HRESULT CWmaFileStream::Initialize( const CHAR* strFileName )
{
    WAVEFORMATEX   wfxSourceFormat;
    DSSTREAMDESC   dssd;

    HRESULT        hr;
    
    // Create the source (wma file) filter
    hr = WmaCreateDecoder(strFileName, NULL, FALSE, 16384, FILESTRM_PACKET_COUNT,2, &wfxSourceFormat, &m_pSourceFilter );
    if( FAILED(hr) )
        return hr;

    // Create the render (DirectSoundStream) filter
    ZeroMemory( &dssd, sizeof(dssd) );

#ifdef SILVER
    dssd.dwSize               = sizeof(dssd);
#endif // SILVER
    dssd.dwMaxAttachedPackets = FILESTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = &wfxSourceFormat;

#ifdef SILVER
    hr = DirectSoundCreateStream( 0, &dssd, &m_pRenderFilter, NULL );
#else // SILVER
	hr = DirectSoundCreateStream( &dssd, &m_pRenderFilter );
#endif // SILVER
    if( FAILED(hr) )
        return hr;

    XMEDIAINFO xmi;

    // We expect the source filter to be synchronous and read-only, the
    // transform filter to be synchronous and read/write and the render
    // filter to be asynchronous write-only.  Assert that all of this 
    // is true and check the packet sizes for compatibility.

    hr = m_pSourceFilter->GetInfo( &xmi );
    if( FAILED(hr) )
        return hr;
    MY_ASSERT( xmi.dwFlags & XMO_STREAMF_FIXED_SAMPLE_SIZE);

    MY_ASSERT( !xmi.dwMaxLookahead );
    MY_ASSERT( xmi.dwOutputSize );
    MY_ASSERT( !(FILESTRM_SOURCE_PACKET_BYTES % xmi.dwOutputSize) );

    hr = m_pRenderFilter->GetInfo( &xmi );
    if( FAILED(hr) )
        return hr;
    MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC) );
    MY_ASSERT( FILESTRM_SOURCE_PACKET_BYTES * FILESTRM_PACKET_COUNT >= xmi.dwMaxLookahead );
    MY_ASSERT( !(FILESTRM_SOURCE_PACKET_BYTES % xmi.dwInputSize) );
    MY_ASSERT( !xmi.dwOutputSize );

    // Allocate data buffers.  Since the source filter is synchronous, we only
    // have to allocate enough data to process a single packet.  The render
    // filter, however, is asynchronous, so we'll have to allocate enough
    // space to hold all the packets that could be submitted at any given time.

    m_pvSourceBuffer = new BYTE[FILESTRM_SOURCE_PACKET_BYTES*FILESTRM_PACKET_COUNT];
    if( NULL == m_pvSourceBuffer )
        return E_OUTOFMEMORY;

    // Get the total wave file size.  We'll use this to calculate how far
    // along in the file we are during processing.
    hr = m_pSourceFilter->GetLength( &m_dwFileLength );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT CWmaFileStream::Process( DWORD* pdwPercentCompleted )
{
    DWORD   dwPacketIndex;
    HRESULT hr;
    
    // Find a free packet.  If there's none free, we don't have anything
    // to do
    while( FindFreePacket( &dwPacketIndex ) )
    {
         // Read from the source filter
         hr = ProcessSource(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
         
         // Send the data to the renderer
         hr = ProcessRenderer(dwPacketIndex);
         if( FAILED(hr) )
             return hr;
    }

    // Calculate the completion percentage based on the total amount of
    // data we've read from the source.
    if( pdwPercentCompleted )
        (*pdwPercentCompleted) = m_dwFileProgress * 100 / m_dwFileLength;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing.
//-----------------------------------------------------------------------------
BOOL CWmaFileStream::FindFreePacket( DWORD* pdwPacketIndex )
{
    for( DWORD dwPacketIndex = 0; dwPacketIndex < FILESTRM_PACKET_COUNT; dwPacketIndex++ )
    {
        if( XMEDIAPACKET_STATUS_PENDING != m_adwPacketStatus[dwPacketIndex] )
        {
            if( pdwPacketIndex )
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter.
//-----------------------------------------------------------------------------
HRESULT CWmaFileStream::ProcessSource(DWORD dwPacketIndex)
{
    DWORD        dwTotalSourceUsed   = 0;
    DWORD        dwSourceUsed;
    XMEDIAPACKET xmp;
    HRESULT      hr;
    
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.

    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * FILESTRM_SOURCE_PACKET_BYTES);
    xmp.dwMaxSize        = FILESTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    while( dwTotalSourceUsed < FILESTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        hr = m_pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed += dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
            hr = m_pSourceFilter->Flush();
            if( FAILED(hr) )
                return hr;
        };
    }

    //
    // Update the file progress. We are playing of a compressed file
    // and the data we get back are decompressed audio. So on average the file has progressed
    // 1 byte for every N bytes we get.. N depends on the compression ratio of the file
    // Query directly the file position to figure out where we are
    //

    m_pSourceFilter->Seek(0,FILE_CURRENT,&m_dwFileProgress);
    m_dwFileProgress %= m_dwFileLength;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT CWmaFileStream::ProcessRenderer( DWORD dwPacketIndex )
{
    XMEDIAPACKET xmp;
    HRESULT      hr;

    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = (BYTE*)m_pvSourceBuffer + (dwPacketIndex * FILESTRM_SOURCE_PACKET_BYTES);
    xmp.dwMaxSize = FILESTRM_SOURCE_PACKET_BYTES;
    xmp.pdwStatus = &m_adwPacketStatus[dwPacketIndex];

    hr = m_pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\xquake.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// xquake.h: Xbox-specific Quake header file

#pragma warning( disable : 4229 )  // mgraph gets this

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <dsound.h>
#endif

extern	HINSTANCE	global_hInstance;
extern	int			global_nCmdShow;

#ifndef SERVERONLY

extern qboolean			DDActive;
extern LPDIRECTSOUND pDS;
extern LPDIRECTSOUNDBUFFER pDSBuf;

extern DWORD gSndBufSize;
//#define SNDBUFSIZE 65536

void	VID_LockBuffer (void);
void	VID_UnlockBuffer (void);

#endif

typedef enum {MS_WINDOWED, MS_FULLSCREEN, MS_FULLDIB, MS_UNINIT} modestate_t;

extern modestate_t	modestate;

extern HWND			mainwindow;
extern qboolean		ActiveApp, Minimized;

extern qboolean	WinNT;

int VID_ForceUnlockedAndReturnState (void);
void VID_ForceLockState (int lk);

void IN_ShowMouse (void);
void IN_DeactivateMouse (void);
void IN_HideMouse (void);
void IN_ActivateMouse (void);
void IN_RestoreOriginalMouseState (void);
void IN_SetQuakeMouseState (void);
void IN_MouseEvent (int mstate);

extern qboolean	winsock_lib_initialized;

extern cvar_t		_windowed_mouse;

extern int		window_center_x, window_center_y;
extern RECT		window_rect;

extern qboolean	mouseinitialized;
extern HWND		hwnd_dialog;

extern HANDLE	hinput, houtput;

void IN_UpdateClipCursor (void);
void CenterWindow(HWND hWndCenter, int width, int height, BOOL lefttopjustify);

void S_BlockSound (void);
void S_UnblockSound (void);
void SND_InitWmaPlayback(void);
void SND_WmaProcessStream(void);

#ifdef XQUAKE_DMUSIC
void SND_DMusicInit(void);
void SND_DMusicDoWork(void);
#endif

void VID_SetDefaultMode (void);

#ifndef UNDER_CE
int (PASCAL FAR *pWSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
int (PASCAL FAR *pWSACleanup)(void);
int (PASCAL FAR *pWSAGetLastError)(void);
SOCKET (PASCAL FAR *psocket)(int af, int type, int protocol);
int (PASCAL FAR *pioctlsocket)(SOCKET s, long cmd, u_long FAR *argp);
int (PASCAL FAR *psetsockopt)(SOCKET s, int level, int optname,
							  const char FAR * optval, int optlen);
int (PASCAL FAR *precvfrom)(SOCKET s, char FAR * buf, int len, int flags,
							struct sockaddr FAR *from, int FAR * fromlen);
int (PASCAL FAR *psendto)(SOCKET s, const char FAR * buf, int len, int flags,
						  const struct sockaddr FAR *to, int tolen);
int (PASCAL FAR *pclosesocket)(SOCKET s);
int (PASCAL FAR *pgethostname)(char FAR * name, int namelen);
struct hostent FAR * (PASCAL FAR *pgethostbyname)(const char FAR * name);
struct hostent FAR * (PASCAL FAR *pgethostbyaddr)(const char FAR * addr,
												  int len, int type);
int (PASCAL FAR *pgetsockname)(SOCKET s, struct sockaddr FAR *name,
							   int FAR * namelen);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\wad.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// wad.h

//===============
//   TYPES
//===============

#define	CMP_NONE		0
#define	CMP_LZSS		1

#define	TYP_NONE		0
#define	TYP_LABEL		1

#define	TYP_LUMPY		64				// 64 + grab command number
#define	TYP_PALETTE		64
#define	TYP_QTEX		65
#define	TYP_QPIC		66
#define	TYP_SOUND		67
#define	TYP_MIPTEX		68

typedef struct
{
	int			width, height;
	byte		data[4];			// variably sized
} qpic_t;



typedef struct
{
	char		identification[4];		// should be WAD2 or 2DAW
	int			numlumps;
	int			infotableofs;
} wadinfo_t;

typedef struct
{
	int			filepos;
	int			disksize;
	int			size;					// uncompressed
	char		type;
	char		compression;
	char		pad1, pad2;
	char		name[16];				// must be null terminated
} lumpinfo_t;

extern	int			wad_numlumps;
extern	lumpinfo_t	*wad_lumps;
extern	byte		*wad_base;

void	W_LoadWadFile (char *filename);
void	W_CleanupName (char *in, char *out);
lumpinfo_t	*W_GetLumpinfo (char *name);
void	*W_GetLumpName (char *name);
void	*W_GetLumpNum (int num);

void SwapPic (qpic_t *pic);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\world.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// world.c -- world query functions

#include "quakedef.h"

/*

entities never clip against themselves, or their owner

line of sight checks trace->crosscontent, but bullets don't

*/


typedef struct
{
	vec3_t		boxmins, boxmaxs;// enclose the test object along entire move
	float		*mins, *maxs;	// size of the moving object
	vec3_t		mins2, maxs2;	// size when clipping against mosnters
	float		*start, *end;
	trace_t		trace;
	int			type;
	edict_t		*passedict;
} moveclip_t;


int SV_HullPointContents (hull_t *hull, int num, vec3_t p);

/*
===============================================================================

HULL BOXES

===============================================================================
*/


static	hull_t		box_hull;
static	dclipnode_t	box_clipnodes[6];
static	mplane_t	box_planes[6];

/*
===================
SV_InitBoxHull

Set up the planes and clipnodes so that the six floats of a bounding box
can just be stored out and get a proper hull_t structure.
===================
*/
void SV_InitBoxHull (void)
{
	int		i;
	int		side;

	box_hull.clipnodes = box_clipnodes;
	box_hull.planes = box_planes;
	box_hull.firstclipnode = 0;
	box_hull.lastclipnode = 5;

	for (i=0 ; i<6 ; i++)
	{
		box_clipnodes[i].planenum = i;
		
		side = i&1;
		
		box_clipnodes[i].children[side] = CONTENTS_EMPTY;
		if (i != 5)
			box_clipnodes[i].children[side^1] = i + 1;
		else
			box_clipnodes[i].children[side^1] = CONTENTS_SOLID;
		
		box_planes[i].type = i>>1;
		box_planes[i].normal[i>>1] = 1;
	}
	
}


/*
===================
SV_HullForBox

To keep everything totally uniform, bounding boxes are turned into small
BSP trees instead of being compared directly.
===================
*/
hull_t	*SV_HullForBox (vec3_t mins, vec3_t maxs)
{
	box_planes[0].dist = maxs[0];
	box_planes[1].dist = mins[0];
	box_planes[2].dist = maxs[1];
	box_planes[3].dist = mins[1];
	box_planes[4].dist = maxs[2];
	box_planes[5].dist = mins[2];

	return &box_hull;
}



/*
================
SV_HullForEntity

Returns a hull that can be used for testing or clipping an object of mins/maxs
size.
Offset is filled in to contain the adjustment that must be added to the
testing object's origin to get a point to use with the returned hull.
================
*/
hull_t *SV_HullForEntity (edict_t *ent, vec3_t mins, vec3_t maxs, vec3_t offset)
{
	model_t		*model;
	vec3_t		size;
	vec3_t		hullmins, hullmaxs;
	hull_t		*hull;

// decide which clipping hull to use, based on the size
	if (ent->v.solid == SOLID_BSP)
	{	// explicit hulls in the BSP model
		if (ent->v.movetype != MOVETYPE_PUSH)
			Sys_Error ("SOLID_BSP without MOVETYPE_PUSH");

		model = sv.models[ (int)ent->v.modelindex ];

		if (!model || model->type != mod_brush)
			Sys_Error ("MOVETYPE_PUSH with a non bsp model");

		VectorSubtract (maxs, mins, size);
		if (size[0] < 3)
			hull = &model->hulls[0];
		else if (size[0] <= 32)
			hull = &model->hulls[1];
		else
			hull = &model->hulls[2];

// calculate an offset value to center the origin
		VectorSubtract (hull->clip_mins, mins, offset);
		VectorAdd (offset, ent->v.origin, offset);
	}
	else
	{	// create a temp hull from bounding box sizes

		VectorSubtract (ent->v.mins, maxs, hullmins);
		VectorSubtract (ent->v.maxs, mins, hullmaxs);
		hull = SV_HullForBox (hullmins, hullmaxs);
		
		VectorCopy (ent->v.origin, offset);
	}


	return hull;
}

/*
===============================================================================

ENTITY AREA CHECKING

===============================================================================
*/

typedef struct areanode_s
{
	int		axis;		// -1 = leaf node
	float	dist;
	struct areanode_s	*children[2];
	link_t	trigger_edicts;
	link_t	solid_edicts;
} areanode_t;

#define	AREA_DEPTH	4
#define	AREA_NODES	32

static	areanode_t	sv_areanodes[AREA_NODES];
static	int			sv_numareanodes;

/*
===============
SV_CreateAreaNode

===============
*/
areanode_t *SV_CreateAreaNode (int depth, vec3_t mins, vec3_t maxs)
{
	areanode_t	*anode;
	vec3_t		size;
	vec3_t		mins1, maxs1, mins2, maxs2;

	anode = &sv_areanodes[sv_numareanodes];
	sv_numareanodes++;

	ClearLink (&anode->trigger_edicts);
	ClearLink (&anode->solid_edicts);
	
	if (depth == AREA_DEPTH)
	{
		anode->axis = -1;
		anode->children[0] = anode->children[1] = NULL;
		return anode;
	}
	
	VectorSubtract (maxs, mins, size);
	if (size[0] > size[1])
		anode->axis = 0;
	else
		anode->axis = 1;
	
	anode->dist = 0.5 * (maxs[anode->axis] + mins[anode->axis]);
	VectorCopy (mins, mins1);	
	VectorCopy (mins, mins2);	
	VectorCopy (maxs, maxs1);	
	VectorCopy (maxs, maxs2);	
	
	maxs1[anode->axis] = mins2[anode->axis] = anode->dist;
	
	anode->children[0] = SV_CreateAreaNode (depth+1, mins2, maxs2);
	anode->children[1] = SV_CreateAreaNode (depth+1, mins1, maxs1);

	return anode;
}

/*
===============
SV_ClearWorld

===============
*/
void SV_ClearWorld (void)
{
	SV_InitBoxHull ();
	
	memset (sv_areanodes, 0, sizeof(sv_areanodes));
	sv_numareanodes = 0;
	SV_CreateAreaNode (0, sv.worldmodel->mins, sv.worldmodel->maxs);
}


/*
===============
SV_UnlinkEdict

===============
*/
void SV_UnlinkEdict (edict_t *ent)
{
	if (!ent->area.prev)
		return;		// not linked in anywhere
	RemoveLink (&ent->area);
	ent->area.prev = ent->area.next = NULL;
}


/*
====================
SV_TouchLinks
====================
*/
void SV_TouchLinks ( edict_t *ent, areanode_t *node )
{
	link_t		*l, *next;
	edict_t		*touch;
	int			old_self, old_other;

// touch linked edicts
	for (l = node->trigger_edicts.next ; l != &node->trigger_edicts ; l = next)
	{
		next = l->next;
		touch = EDICT_FROM_AREA(l);
		if (touch == ent)
			continue;
		if (!touch->v.touch || touch->v.solid != SOLID_TRIGGER)
			continue;
		if (ent->v.absmin[0] > touch->v.absmax[0]
		|| ent->v.absmin[1] > touch->v.absmax[1]
		|| ent->v.absmin[2] > touch->v.absmax[2]
		|| ent->v.absmax[0] < touch->v.absmin[0]
		|| ent->v.absmax[1] < touch->v.absmin[1]
		|| ent->v.absmax[2] < touch->v.absmin[2] )
			continue;
		old_self = pr_global_struct->self;
		old_other = pr_global_struct->other;

		pr_global_struct->self = EDICT_TO_PROG(touch);
		pr_global_struct->other = EDICT_TO_PROG(ent);
		pr_global_struct->time = sv.time;
		PR_ExecuteProgram (touch->v.touch);

		pr_global_struct->self = old_self;
		pr_global_struct->other = old_other;
	}
	
// recurse down both sides
	if (node->axis == -1)
		return;
	
	if ( ent->v.absmax[node->axis] > node->dist )
		SV_TouchLinks ( ent, node->children[0] );
	if ( ent->v.absmin[node->axis] < node->dist )
		SV_TouchLinks ( ent, node->children[1] );
}


/*
===============
SV_FindTouchedLeafs

===============
*/
void SV_FindTouchedLeafs (edict_t *ent, mnode_t *node)
{
	mplane_t	*splitplane;
	mleaf_t		*leaf;
	int			sides;
	int			leafnum;

	if (node->contents == CONTENTS_SOLID)
		return;
	
// add an efrag if the node is a leaf

	if ( node->contents < 0)
	{
		if (ent->num_leafs == MAX_ENT_LEAFS)
			return;

		leaf = (mleaf_t *)node;
		leafnum = leaf - sv.worldmodel->leafs - 1;

		ent->leafnums[ent->num_leafs] = (short)leafnum;
		ent->num_leafs++;			
		return;
	}
	
// NODE_MIXED

	splitplane = node->plane;
	sides = BOX_ON_PLANE_SIDE(ent->v.absmin, ent->v.absmax, splitplane);
	
// recurse down the contacted sides
	if (sides & 1)
		SV_FindTouchedLeafs (ent, node->children[0]);
		
	if (sides & 2)
		SV_FindTouchedLeafs (ent, node->children[1]);
}

/*
===============
SV_LinkEdict

===============
*/
void SV_LinkEdict (edict_t *ent, qboolean touch_triggers)
{
	areanode_t	*node;

	if (ent->area.prev)
		SV_UnlinkEdict (ent);	// unlink from old position
		
	if (ent == sv.edicts)
		return;		// don't add the world

	if (ent->free)
		return;

// set the abs box

#ifdef QUAKE2
	if (ent->v.solid == SOLID_BSP && 
	(ent->v.angles[0] || ent->v.angles[1] || ent->v.angles[2]) )
	{	// expand for rotation
		float		max, v;
		int			i;

		max = 0;
		for (i=0 ; i<3 ; i++)
		{
			v =fabs( ent->v.mins[i]);
			if (v > max)
				max = v;
			v =fabs( ent->v.maxs[i]);
			if (v > max)
				max = v;
		}
		for (i=0 ; i<3 ; i++)
		{
			ent->v.absmin[i] = ent->v.origin[i] - max;
			ent->v.absmax[i] = ent->v.origin[i] + max;
		}
	}
	else
#endif
	{
		VectorAdd (ent->v.origin, ent->v.mins, ent->v.absmin);	
		VectorAdd (ent->v.origin, ent->v.maxs, ent->v.absmax);
	}

//
// to make items easier to pick up and allow them to be grabbed off
// of shelves, the abs sizes are expanded
//
	if ((int)ent->v.flags & FL_ITEM)
	{
		ent->v.absmin[0] -= 15;
		ent->v.absmin[1] -= 15;
		ent->v.absmax[0] += 15;
		ent->v.absmax[1] += 15;
	}
	else
	{	// because movement is clipped an epsilon away from an actual edge,
		// we must fully check even when bounding boxes don't quite touch
		ent->v.absmin[0] -= 1;
		ent->v.absmin[1] -= 1;
		ent->v.absmin[2] -= 1;
		ent->v.absmax[0] += 1;
		ent->v.absmax[1] += 1;
		ent->v.absmax[2] += 1;
	}
	
// link to PVS leafs
	ent->num_leafs = 0;
	if (ent->v.modelindex)
		SV_FindTouchedLeafs (ent, sv.worldmodel->nodes);

	if (ent->v.solid == SOLID_NOT)
		return;

// find the first node that the ent's box crosses
	node = sv_areanodes;
	while (1)
	{
		if (node->axis == -1)
			break;
		if (ent->v.absmin[node->axis] > node->dist)
			node = node->children[0];
		else if (ent->v.absmax[node->axis] < node->dist)
			node = node->children[1];
		else
			break;		// crosses the node
	}
	
// link it in	

	if (ent->v.solid == SOLID_TRIGGER)
		InsertLinkBefore (&ent->area, &node->trigger_edicts);
	else
		InsertLinkBefore (&ent->area, &node->solid_edicts);
	
// if touch_triggers, touch all entities at this node and decend for more
	if (touch_triggers)
		SV_TouchLinks ( ent, sv_areanodes );
}



/*
===============================================================================

POINT TESTING IN HULLS

===============================================================================
*/

#if	!id386

/*
==================
SV_HullPointContents

==================
*/
int SV_HullPointContents (hull_t *hull, int num, vec3_t p)
{
	float		d;
	dclipnode_t	*node;
	mplane_t	*plane;

	while (num >= 0)
	{
		if (num < hull->firstclipnode || num > hull->lastclipnode)
			Sys_Error ("SV_HullPointContents: bad node number");
	
		node = hull->clipnodes + num;
		plane = hull->planes + node->planenum;
		
		if (plane->type < 3)
			d = p[plane->type] - plane->dist;
		else
			d = DotProduct (plane->normal, p) - plane->dist;
		if (d < 0)
			num = node->children[1];
		else
			num = node->children[0];
	}
	
	return num;
}

#endif	// !id386


/*
==================
SV_PointContents

==================
*/
int SV_PointContents (vec3_t p)
{
	int		cont;

	cont = SV_HullPointContents (&sv.worldmodel->hulls[0], 0, p);
	if (cont <= CONTENTS_CURRENT_0 && cont >= CONTENTS_CURRENT_DOWN)
		cont = CONTENTS_WATER;
	return cont;
}

int SV_TruePointContents (vec3_t p)
{
	return SV_HullPointContents (&sv.worldmodel->hulls[0], 0, p);
}

//===========================================================================

/*
============
SV_TestEntityPosition

This could be a lot more efficient...
============
*/
edict_t	*SV_TestEntityPosition (edict_t *ent)
{
	trace_t	trace;

	trace = SV_Move (ent->v.origin, ent->v.mins, ent->v.maxs, ent->v.origin, 0, ent);
	
	if (trace.startsolid)
		return sv.edicts;
		
	return NULL;
}


/*
===============================================================================

LINE TESTING IN HULLS

===============================================================================
*/

// 1/32 epsilon to keep floating point happy
#define	DIST_EPSILON	(0.03125)

/*
==================
SV_RecursiveHullCheck

==================
*/
qboolean SV_RecursiveHullCheck (hull_t *hull, int num, float p1f, float p2f, vec3_t p1, vec3_t p2, trace_t *trace)
{
	dclipnode_t	*node;
	mplane_t	*plane;
	float		t1, t2;
	float		frac;
	int			i;
	vec3_t		mid;
	int			side;
	float		midf;

// check for empty
	if (num < 0)
	{
		if (num != CONTENTS_SOLID)
		{
			trace->allsolid = false;
			if (num == CONTENTS_EMPTY)
				trace->inopen = true;
			else
				trace->inwater = true;
		}
		else
			trace->startsolid = true;
		return true;		// empty
	}

	if (num < hull->firstclipnode || num > hull->lastclipnode)
		Sys_Error ("SV_RecursiveHullCheck: bad node number");

//
// find the point distances
//
	node = hull->clipnodes + num;
	plane = hull->planes + node->planenum;

	if (plane->type < 3)
	{
		t1 = p1[plane->type] - plane->dist;
		t2 = p2[plane->type] - plane->dist;
	}
	else
	{
		t1 = DotProduct (plane->normal, p1) - plane->dist;
		t2 = DotProduct (plane->normal, p2) - plane->dist;
	}
	
#if 1
	if (t1 >= 0 && t2 >= 0)
		return SV_RecursiveHullCheck (hull, node->children[0], p1f, p2f, p1, p2, trace);
	if (t1 < 0 && t2 < 0)
		return SV_RecursiveHullCheck (hull, node->children[1], p1f, p2f, p1, p2, trace);
#else
	if ( (t1 >= DIST_EPSILON && t2 >= DIST_EPSILON) || (t2 > t1 && t1 >= 0) )
		return SV_RecursiveHullCheck (hull, node->children[0], p1f, p2f, p1, p2, trace);
	if ( (t1 <= -DIST_EPSILON && t2 <= -DIST_EPSILON) || (t2 < t1 && t1 <= 0) )
		return SV_RecursiveHullCheck (hull, node->children[1], p1f, p2f, p1, p2, trace);
#endif

// put the crosspoint DIST_EPSILON pixels on the near side
	if (t1 < 0)
		frac = (t1 + DIST_EPSILON)/(t1-t2);
	else
		frac = (t1 - DIST_EPSILON)/(t1-t2);
	if (frac < 0)
		frac = 0;
	if (frac > 1)
		frac = 1;
		
	midf = p1f + (p2f - p1f)*frac;
	for (i=0 ; i<3 ; i++)
		mid[i] = p1[i] + frac*(p2[i] - p1[i]);

	side = (t1 < 0);

// move up to the node
	if (!SV_RecursiveHullCheck (hull, node->children[side], p1f, midf, p1, mid, trace) )
		return false;

#ifdef PARANOID
	if (SV_HullPointContents (sv_hullmodel, mid, node->children[side])
	== CONTENTS_SOLID)
	{
		Con_Printf ("mid PointInHullSolid\n");
		return false;
	}
#endif
	
	if (SV_HullPointContents (hull, node->children[side^1], mid)
	!= CONTENTS_SOLID)
// go past the node
		return SV_RecursiveHullCheck (hull, node->children[side^1], midf, p2f, mid, p2, trace);
	
	if (trace->allsolid)
		return false;		// never got out of the solid area
		
//==================
// the other side of the node is solid, this is the impact point
//==================
	if (!side)
	{
		VectorCopy (plane->normal, trace->plane.normal);
		trace->plane.dist = plane->dist;
	}
	else
	{
		VectorSubtract (vec3_origin, plane->normal, trace->plane.normal);
		trace->plane.dist = -plane->dist;
	}

	while (SV_HullPointContents (hull, hull->firstclipnode, mid)
	== CONTENTS_SOLID)
	{ // shouldn't really happen, but does occasionally
		frac -= 0.1;
		if (frac < 0)
		{
			trace->fraction = midf;
			VectorCopy (mid, trace->endpos);
			Con_DPrintf ("backup past 0\n");
			return false;
		}
		midf = p1f + (p2f - p1f)*frac;
		for (i=0 ; i<3 ; i++)
			mid[i] = p1[i] + frac*(p2[i] - p1[i]);
	}

	trace->fraction = midf;
	VectorCopy (mid, trace->endpos);

	return false;
}


/*
==================
SV_ClipMoveToEntity

Handles selection or creation of a clipping hull, and offseting (and
eventually rotation) of the end points
==================
*/
trace_t SV_ClipMoveToEntity (edict_t *ent, vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end)
{
	trace_t		trace;
	vec3_t		offset;
	vec3_t		start_l, end_l;
	hull_t		*hull;

// fill in a default trace
	memset (&trace, 0, sizeof(trace_t));
	trace.fraction = 1;
	trace.allsolid = true;
	VectorCopy (end, trace.endpos);

// get the clipping hull
	hull = SV_HullForEntity (ent, mins, maxs, offset);

	VectorSubtract (start, offset, start_l);
	VectorSubtract (end, offset, end_l);

#ifdef QUAKE2
	// rotate start and end into the models frame of reference
	if (ent->v.solid == SOLID_BSP && 
	(ent->v.angles[0] || ent->v.angles[1] || ent->v.angles[2]) )
	{
		vec3_t	a;
		vec3_t	forward, right, up;
		vec3_t	temp;

		AngleVectors (ent->v.angles, forward, right, up);

		VectorCopy (start_l, temp);
		start_l[0] = DotProduct (temp, forward);
		start_l[1] = -DotProduct (temp, right);
		start_l[2] = DotProduct (temp, up);

		VectorCopy (end_l, temp);
		end_l[0] = DotProduct (temp, forward);
		end_l[1] = -DotProduct (temp, right);
		end_l[2] = DotProduct (temp, up);
	}
#endif

// trace a line through the apropriate clipping hull
	SV_RecursiveHullCheck (hull, hull->firstclipnode, 0, 1, start_l, end_l, &trace);

#ifdef QUAKE2
	// rotate endpos back to world frame of reference
	if (ent->v.solid == SOLID_BSP && 
	(ent->v.angles[0] || ent->v.angles[1] || ent->v.angles[2]) )
	{
		vec3_t	a;
		vec3_t	forward, right, up;
		vec3_t	temp;

		if (trace.fraction != 1)
		{
			VectorSubtract (vec3_origin, ent->v.angles, a);
			AngleVectors (a, forward, right, up);

			VectorCopy (trace.endpos, temp);
			trace.endpos[0] = DotProduct (temp, forward);
			trace.endpos[1] = -DotProduct (temp, right);
			trace.endpos[2] = DotProduct (temp, up);

			VectorCopy (trace.plane.normal, temp);
			trace.plane.normal[0] = DotProduct (temp, forward);
			trace.plane.normal[1] = -DotProduct (temp, right);
			trace.plane.normal[2] = DotProduct (temp, up);
		}
	}
#endif

// fix trace up by the offset
	if (trace.fraction != 1)
		VectorAdd (trace.endpos, offset, trace.endpos);

// did we clip the move?
	if (trace.fraction < 1 || trace.startsolid  )
		trace.ent = ent;

	return trace;
}

//===========================================================================

/*
====================
SV_ClipToLinks

Mins and maxs enclose the entire area swept by the move
====================
*/
void SV_ClipToLinks ( areanode_t *node, moveclip_t *clip )
{
	link_t		*l, *next;
	edict_t		*touch;
	trace_t		trace;

// touch linked edicts
	for (l = node->solid_edicts.next ; l != &node->solid_edicts ; l = next)
	{
		next = l->next;
		touch = EDICT_FROM_AREA(l);
		if (touch->v.solid == SOLID_NOT)
			continue;
		if (touch == clip->passedict)
			continue;
		if (touch->v.solid == SOLID_TRIGGER)
			Sys_Error ("Trigger in clipping list");

		if (clip->type == MOVE_NOMONSTERS && touch->v.solid != SOLID_BSP)
			continue;

		if (clip->boxmins[0] > touch->v.absmax[0]
		|| clip->boxmins[1] > touch->v.absmax[1]
		|| clip->boxmins[2] > touch->v.absmax[2]
		|| clip->boxmaxs[0] < touch->v.absmin[0]
		|| clip->boxmaxs[1] < touch->v.absmin[1]
		|| clip->boxmaxs[2] < touch->v.absmin[2] )
			continue;

		if (clip->passedict && clip->passedict->v.size[0] && !touch->v.size[0])
			continue;	// points never interact

	// might intersect, so do an exact clip
		if (clip->trace.allsolid)
			return;
		if (clip->passedict)
		{
		 	if (PROG_TO_EDICT(touch->v.owner) == clip->passedict)
				continue;	// don't clip against own missiles
			if (PROG_TO_EDICT(clip->passedict->v.owner) == touch)
				continue;	// don't clip against owner
		}

		if ((int)touch->v.flags & FL_MONSTER)
			trace = SV_ClipMoveToEntity (touch, clip->start, clip->mins2, clip->maxs2, clip->end);
		else
			trace = SV_ClipMoveToEntity (touch, clip->start, clip->mins, clip->maxs, clip->end);
		if (trace.allsolid || trace.startsolid ||
		trace.fraction < clip->trace.fraction)
		{
			trace.ent = touch;
		 	if (clip->trace.startsolid)
			{
				clip->trace = trace;
				clip->trace.startsolid = true;
			}
			else
				clip->trace = trace;
		}
		else if (trace.startsolid)
			clip->trace.startsolid = true;
	}
	
// recurse down both sides
	if (node->axis == -1)
		return;

	if ( clip->boxmaxs[node->axis] > node->dist )
		SV_ClipToLinks ( node->children[0], clip );
	if ( clip->boxmins[node->axis] < node->dist )
		SV_ClipToLinks ( node->children[1], clip );
}


/*
==================
SV_MoveBounds
==================
*/
void SV_MoveBounds (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, vec3_t boxmins, vec3_t boxmaxs)
{
#if 0
// debug to test against everything
boxmins[0] = boxmins[1] = boxmins[2] = -9999;
boxmaxs[0] = boxmaxs[1] = boxmaxs[2] = 9999;
#else
	int		i;
	
	for (i=0 ; i<3 ; i++)
	{
		if (end[i] > start[i])
		{
			boxmins[i] = start[i] + mins[i] - 1;
			boxmaxs[i] = end[i] + maxs[i] + 1;
		}
		else
		{
			boxmins[i] = end[i] + mins[i] - 1;
			boxmaxs[i] = start[i] + maxs[i] + 1;
		}
	}
#endif
}

/*
==================
SV_Move
==================
*/
trace_t SV_Move (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, int type, edict_t *passedict)
{
	moveclip_t	clip;
	int			i;

	memset ( &clip, 0, sizeof ( moveclip_t ) );

// clip to world
	clip.trace = SV_ClipMoveToEntity ( sv.edicts, start, mins, maxs, end );

	clip.start = start;
	clip.end = end;
	clip.mins = mins;
	clip.maxs = maxs;
	clip.type = type;
	clip.passedict = passedict;

	if (type == MOVE_MISSILE)
	{
		for (i=0 ; i<3 ; i++)
		{
			clip.mins2[i] = -15;
			clip.maxs2[i] = 15;
		}
	}
	else
	{
		VectorCopy (mins, clip.mins2);
		VectorCopy (maxs, clip.maxs2);
	}
	
// create the bounding box of the entire move
	SV_MoveBounds ( start, clip.mins2, clip.maxs2, end, clip.boxmins, clip.boxmaxs );

// clip to entities
	SV_ClipToLinks ( sv_areanodes, &clip );

	return clip.trace;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl\glu.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glu.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Utility Library.

--*/

#ifndef __glu_h__
#ifndef __GLU_H__

#define __glu_h__
#define __GLU_H__

#include <GL/gl.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** Return the error string associated with a particular error code.
** This will return 0 for an invalid error code.
**
** The generic function prototype that can be compiled for ANSI or Unicode
** is defined as follows:
**
** LPCTSTR APIENTRY gluErrorStringWIN (GLenum errCode);
*/
#ifdef UNICODE
#define gluErrorStringWIN(errCode) ((LPCSTR)  gluErrorUnicodeStringEXT(errCode))
#else
#define gluErrorStringWIN(errCode) ((LPCWSTR) gluErrorString(errCode))
#endif

const GLubyte* APIENTRY gluErrorString (
    GLenum   errCode);

const wchar_t* APIENTRY gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* APIENTRY gluGetString (
    GLenum   name);

void APIENTRY gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void APIENTRY gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void APIENTRY gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void APIENTRY gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int APIENTRY gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int APIENTRY gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int APIENTRY gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int APIENTRY gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int APIENTRY gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

#ifdef __cplusplus

class GLUnurbs;
class GLUquadric;
class GLUtesselator;

/* backwards compatibility: */
typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;

#else

typedef struct GLUnurbs GLUnurbs;
typedef struct GLUquadric GLUquadric;
typedef struct GLUtesselator GLUtesselator;

/* backwards compatibility: */
typedef struct GLUnurbs GLUnurbsObj;
typedef struct GLUquadric GLUquadricObj;
typedef struct GLUtesselator GLUtesselatorObj;
typedef struct GLUtesselator GLUtriangulatorObj;

#endif


GLUquadric* APIENTRY gluNewQuadric (void);
void APIENTRY gluDeleteQuadric (
    GLUquadric          *state);

void APIENTRY gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void APIENTRY gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void APIENTRY gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void APIENTRY gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void APIENTRY gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void APIENTRY gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void APIENTRY gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void APIENTRY gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (CALLBACK* fn)());

GLUtesselator* APIENTRY  gluNewTess(          
    void );

void APIENTRY  gluDeleteTess(       
    GLUtesselator       *tess );

void APIENTRY  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void APIENTRY  gluTessBeginContour( 
    GLUtesselator       *tess );

void APIENTRY  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void APIENTRY  gluTessEndContour(   
    GLUtesselator       *tess );

void APIENTRY  gluTessEndPolygon(   
    GLUtesselator       *tess );

void APIENTRY  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void APIENTRY  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void APIENTRY  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (CALLBACK *fn)());

void APIENTRY  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* APIENTRY gluNewNurbsRenderer (void);

void APIENTRY gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void APIENTRY gluBeginSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndCurve (
    GLUnurbs            *nobj);

void APIENTRY gluEndSurface (
    GLUnurbs            *nobj);

void APIENTRY gluBeginTrim (
    GLUnurbs            *nobj);

void APIENTRY gluEndTrim (
    GLUnurbs            *nobj);

void APIENTRY gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void APIENTRY gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void APIENTRY 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void APIENTRY 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void APIENTRY 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void APIENTRY 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void APIENTRY 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (CALLBACK* fn)() );


/****           Callback function prototypes    ****/

/* gluQuadricCallback */
typedef void (CALLBACK* GLUquadricErrorProc) (GLenum);

/* gluTessCallback */
typedef void (CALLBACK* GLUtessBeginProc)        (GLenum);
typedef void (CALLBACK* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (CALLBACK* GLUtessVertexProc)       (void *);
typedef void (CALLBACK* GLUtessEndProc)          (void);
typedef void (CALLBACK* GLUtessErrorProc)        (GLenum);
typedef void (CALLBACK* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (CALLBACK* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (CALLBACK* GLUtessVertexDataProc)   (void *, void *);
typedef void (CALLBACK* GLUtessEndDataProc)      (void *);
typedef void (CALLBACK* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (CALLBACK* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );

/* gluNurbsCallback */
typedef void (CALLBACK* GLUnurbsErrorProc)   (GLenum);


/****           Generic constants               ****/

/* Version */
#define GLU_VERSION_1_1                 1
#define GLU_VERSION_1_2                 1

/* Errors: (return value 0 = no error) */
#define GLU_INVALID_ENUM        100900
#define GLU_INVALID_VALUE       100901
#define GLU_OUT_OF_MEMORY       100902
#define GLU_INCOMPATIBLE_GL_VERSION     100903

/* StringName */
#define GLU_VERSION             100800
#define GLU_EXTENSIONS          100801

/* Boolean */
#define GLU_TRUE                GL_TRUE
#define GLU_FALSE               GL_FALSE


/****           Quadric constants               ****/

/* QuadricNormal */
#define GLU_SMOOTH              100000
#define GLU_FLAT                100001
#define GLU_NONE                100002

/* QuadricDrawStyle */
#define GLU_POINT               100010
#define GLU_LINE                100011
#define GLU_FILL                100012
#define GLU_SILHOUETTE          100013

/* QuadricOrientation */
#define GLU_OUTSIDE             100020
#define GLU_INSIDE              100021

/* Callback types: */
/*      GLU_ERROR               100103 */


/****           Tesselation constants           ****/

#define GLU_TESS_MAX_COORD              1.0e150

/* TessProperty */
#define GLU_TESS_WINDING_RULE           100140
#define GLU_TESS_BOUNDARY_ONLY          100141
#define GLU_TESS_TOLERANCE              100142

/* TessWinding */
#define GLU_TESS_WINDING_ODD            100130
#define GLU_TESS_WINDING_NONZERO        100131
#define GLU_TESS_WINDING_POSITIVE       100132
#define GLU_TESS_WINDING_NEGATIVE       100133
#define GLU_TESS_WINDING_ABS_GEQ_TWO    100134

/* TessCallback */
#define GLU_TESS_BEGIN          100100  /* void (CALLBACK*)(GLenum    type)  */
#define GLU_TESS_VERTEX         100101  /* void (CALLBACK*)(void      *data) */
#define GLU_TESS_END            100102  /* void (CALLBACK*)(void)            */
#define GLU_TESS_ERROR          100103  /* void (CALLBACK*)(GLenum    errno) */
#define GLU_TESS_EDGE_FLAG      100104  /* void (CALLBACK*)(GLboolean boundaryEdge)  */
#define GLU_TESS_COMBINE        100105  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut)     */
#define GLU_TESS_BEGIN_DATA     100106  /* void (CALLBACK*)(GLenum    type,  
                                                            void      *polygon_data) */
#define GLU_TESS_VERTEX_DATA    100107  /* void (CALLBACK*)(void      *data, 
                                                            void      *polygon_data) */
#define GLU_TESS_END_DATA       100108  /* void (CALLBACK*)(void      *polygon_data) */
#define GLU_TESS_ERROR_DATA     100109  /* void (CALLBACK*)(GLenum    errno, 
                                                            void      *polygon_data) */
#define GLU_TESS_EDGE_FLAG_DATA 100110  /* void (CALLBACK*)(GLboolean boundaryEdge,
                                                            void      *polygon_data) */
#define GLU_TESS_COMBINE_DATA   100111  /* void (CALLBACK*)(GLdouble  coords[3],
                                                            void      *data[4],
                                                            GLfloat   weight[4],
                                                            void      **dataOut,
                                                            void      *polygon_data) */

/* TessError */
#define GLU_TESS_ERROR1     100151
#define GLU_TESS_ERROR2     100152
#define GLU_TESS_ERROR3     100153
#define GLU_TESS_ERROR4     100154
#define GLU_TESS_ERROR5     100155
#define GLU_TESS_ERROR6     100156
#define GLU_TESS_ERROR7     100157
#define GLU_TESS_ERROR8     100158

#define GLU_TESS_MISSING_BEGIN_POLYGON  GLU_TESS_ERROR1
#define GLU_TESS_MISSING_BEGIN_CONTOUR  GLU_TESS_ERROR2
#define GLU_TESS_MISSING_END_POLYGON    GLU_TESS_ERROR3
#define GLU_TESS_MISSING_END_CONTOUR    GLU_TESS_ERROR4
#define GLU_TESS_COORD_TOO_LARGE        GLU_TESS_ERROR5
#define GLU_TESS_NEED_COMBINE_CALLBACK  GLU_TESS_ERROR6

/****           NURBS constants                 ****/

/* NurbsProperty */
#define GLU_AUTO_LOAD_MATRIX    100200
#define GLU_CULLING             100201
#define GLU_SAMPLING_TOLERANCE  100203
#define GLU_DISPLAY_MODE        100204
#define GLU_PARAMETRIC_TOLERANCE        100202
#define GLU_SAMPLING_METHOD             100205
#define GLU_U_STEP                      100206
#define GLU_V_STEP                      100207

/* NurbsSampling */
#define GLU_PATH_LENGTH                 100215
#define GLU_PARAMETRIC_ERROR            100216
#define GLU_DOMAIN_DISTANCE             100217


/* NurbsTrim */
#define GLU_MAP1_TRIM_2         100210
#define GLU_MAP1_TRIM_3         100211

/* NurbsDisplay */
/*      GLU_FILL                100012 */
#define GLU_OUTLINE_POLYGON     100240
#define GLU_OUTLINE_PATCH       100241

/* NurbsCallback */
/*      GLU_ERROR               100103 */

/* NurbsErrors */
#define GLU_NURBS_ERROR1        100251
#define GLU_NURBS_ERROR2        100252
#define GLU_NURBS_ERROR3        100253
#define GLU_NURBS_ERROR4        100254
#define GLU_NURBS_ERROR5        100255
#define GLU_NURBS_ERROR6        100256
#define GLU_NURBS_ERROR7        100257
#define GLU_NURBS_ERROR8        100258
#define GLU_NURBS_ERROR9        100259
#define GLU_NURBS_ERROR10       100260
#define GLU_NURBS_ERROR11       100261
#define GLU_NURBS_ERROR12       100262
#define GLU_NURBS_ERROR13       100263
#define GLU_NURBS_ERROR14       100264
#define GLU_NURBS_ERROR15       100265
#define GLU_NURBS_ERROR16       100266
#define GLU_NURBS_ERROR17       100267
#define GLU_NURBS_ERROR18       100268
#define GLU_NURBS_ERROR19       100269
#define GLU_NURBS_ERROR20       100270
#define GLU_NURBS_ERROR21       100271
#define GLU_NURBS_ERROR22       100272
#define GLU_NURBS_ERROR23       100273
#define GLU_NURBS_ERROR24       100274
#define GLU_NURBS_ERROR25       100275
#define GLU_NURBS_ERROR26       100276
#define GLU_NURBS_ERROR27       100277
#define GLU_NURBS_ERROR28       100278
#define GLU_NURBS_ERROR29       100279
#define GLU_NURBS_ERROR30       100280
#define GLU_NURBS_ERROR31       100281
#define GLU_NURBS_ERROR32       100282
#define GLU_NURBS_ERROR33       100283
#define GLU_NURBS_ERROR34       100284
#define GLU_NURBS_ERROR35       100285
#define GLU_NURBS_ERROR36       100286
#define GLU_NURBS_ERROR37       100287

/****           Backwards compatibility for old tesselator           ****/

void APIENTRY   gluBeginPolygon( GLUtesselator *tess );

void APIENTRY   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void APIENTRY   gluEndPolygon(   GLUtesselator *tess );

/* Contours types -- obsolete! */
#define GLU_CW          100120
#define GLU_CCW         100121
#define GLU_INTERIOR    100122
#define GLU_EXTERIOR    100123
#define GLU_UNKNOWN     100124

/* Names without "TESS_" prefix */
#define GLU_BEGIN       GLU_TESS_BEGIN
#define GLU_VERTEX      GLU_TESS_VERTEX
#define GLU_END         GLU_TESS_END
#define GLU_ERROR       GLU_TESS_ERROR
#define GLU_EDGE_FLAG   GLU_TESS_EDGE_FLAG

#ifdef __cplusplus
}
#endif

#endif /* __GLU_H__ */
#endif /* __glu_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl\glaux.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    glaux.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    Auxiliary Library.

--*/

#ifndef __GLAUX_H__
#define __GLAUX_H__

/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
** ToolKit Window Types
** In the future, AUX_RGBA may be a combination of both RGB and ALPHA
*/

#define AUX_RGB             0
#define AUX_RGBA            AUX_RGB
#define AUX_INDEX           1
#define AUX_SINGLE          0
#define AUX_DOUBLE          2
#define AUX_DIRECT          0
#define AUX_INDIRECT        4

#define AUX_ACCUM           8
#define AUX_ALPHA           16
#define AUX_DEPTH24         32      /* 24-bit depth buffer */
#define AUX_STENCIL         64
#define AUX_AUX             128
#define AUX_DEPTH16         256     /* 16-bit depth buffer */
#define AUX_FIXED_332_PAL   512
#define AUX_DEPTH           AUX_DEPTH16 /* default is 16-bit depth buffer */

/* 
** Window Masks
*/

#define AUX_WIND_IS_RGB(x)      (((x) & AUX_INDEX) == 0)
#define AUX_WIND_IS_INDEX(x)    (((x) & AUX_INDEX) != 0)
#define AUX_WIND_IS_SINGLE(x)   (((x) & AUX_DOUBLE) == 0)
#define AUX_WIND_IS_DOUBLE(x)   (((x) & AUX_DOUBLE) != 0)
#define AUX_WIND_IS_INDIRECT(x) (((x) & AUX_INDIRECT) != 0)
#define AUX_WIND_IS_DIRECT(x)   (((x) & AUX_INDIRECT) == 0)
#define AUX_WIND_HAS_ACCUM(x)   (((x) & AUX_ACCUM) != 0)
#define AUX_WIND_HAS_ALPHA(x)   (((x) & AUX_ALPHA) != 0)
#define AUX_WIND_HAS_DEPTH(x)   (((x) & (AUX_DEPTH24 | AUX_DEPTH16)) != 0)
#define AUX_WIND_HAS_STENCIL(x) (((x) & AUX_STENCIL) != 0)
#define AUX_WIND_USES_FIXED_332_PAL(x)  (((x) & AUX_FIXED_332_PAL) != 0)

/*
** ToolKit Event Structure
*/

typedef struct _AUX_EVENTREC {
    GLint event;
    GLint data[4];
} AUX_EVENTREC;

/* 
** ToolKit Event Types
*/
#define AUX_EXPOSE      1
#define AUX_CONFIG      2
#define AUX_DRAW        4
#define AUX_KEYEVENT    8
#define AUX_MOUSEDOWN   16
#define AUX_MOUSEUP     32
#define AUX_MOUSELOC    64

/*
** Toolkit Event Data Indices
*/
#define AUX_WINDOWX             0
#define AUX_WINDOWY             1
#define AUX_MOUSEX              0
#define AUX_MOUSEY              1
#define AUX_MOUSESTATUS         3
#define AUX_KEY                 0
#define AUX_KEYSTATUS           1

/*
** ToolKit Event Status Messages
*/
#define AUX_LEFTBUTTON          1
#define AUX_RIGHTBUTTON         2
#define AUX_MIDDLEBUTTON        4
#define AUX_SHIFT               1
#define AUX_CONTROL             2

/* 
** ToolKit Key Codes
*/
#define AUX_RETURN              0x0D
#define AUX_ESCAPE              0x1B
#define AUX_SPACE               0x20
#define AUX_LEFT                0x25
#define AUX_UP                  0x26
#define AUX_RIGHT               0x27
#define AUX_DOWN                0x28
#define AUX_A                   'A'
#define AUX_B                   'B'
#define AUX_C                   'C'
#define AUX_D                   'D'
#define AUX_E                   'E'
#define AUX_F                   'F'
#define AUX_G                   'G'
#define AUX_H                   'H'
#define AUX_I                   'I'
#define AUX_J                   'J'
#define AUX_K                   'K'
#define AUX_L                   'L'
#define AUX_M                   'M'
#define AUX_N                   'N'
#define AUX_O                   'O'
#define AUX_P                   'P'
#define AUX_Q                   'Q'
#define AUX_R                   'R'
#define AUX_S                   'S'
#define AUX_T                   'T'
#define AUX_U                   'U'
#define AUX_V                   'V'
#define AUX_W                   'W'
#define AUX_X                   'X'
#define AUX_Y                   'Y'
#define AUX_Z                   'Z'
#define AUX_a                   'a'
#define AUX_b                   'b'
#define AUX_c                   'c'
#define AUX_d                   'd'
#define AUX_e                   'e'
#define AUX_f                   'f'
#define AUX_g                   'g'
#define AUX_h                   'h'
#define AUX_i                   'i'
#define AUX_j                   'j'
#define AUX_k                   'k'
#define AUX_l                   'l'
#define AUX_m                   'm'
#define AUX_n                   'n'
#define AUX_o                   'o'
#define AUX_p                   'p'
#define AUX_q                   'q'
#define AUX_r                   'r'
#define AUX_s                   's'
#define AUX_t                   't'
#define AUX_u                   'u'
#define AUX_v                   'v'
#define AUX_w                   'w'
#define AUX_x                   'x'
#define AUX_y                   'y'
#define AUX_z                   'z'
#define AUX_0                   '0'
#define AUX_1                   '1'
#define AUX_2                   '2'
#define AUX_3                   '3'
#define AUX_4                   '4'
#define AUX_5                   '5'
#define AUX_6                   '6'
#define AUX_7                   '7'
#define AUX_8                   '8'
#define AUX_9                   '9'

/*
** ToolKit Gets and Sets
*/
#define AUX_FD                  1  /* return fd (long) */
#define AUX_COLORMAP            3  /* pass buf of r, g and b (unsigned char) */
#define AUX_GREYSCALEMAP        4
#define AUX_FOGMAP              5  /* pass fog and color bits (long) */
#define AUX_ONECOLOR            6  /* pass index, r, g, and b (long) */

/*
** Color Macros
*/

#define AUX_BLACK               0
#define AUX_RED                 13
#define AUX_GREEN               14
#define AUX_YELLOW              15
#define AUX_BLUE                16
#define AUX_MAGENTA             17
#define AUX_CYAN                18
#define AUX_WHITE               19

extern float auxRGBMap[20][3];

#define AUX_SETCOLOR(x, y) (AUX_WIND_IS_RGB((x)) ? \
                           glColor3fv(auxRGBMap[(y)]) : glIndexf((y)))

/*
** RGB Image Structure
*/

typedef struct _AUX_RGBImageRec {
    GLint sizeX, sizeY;
    unsigned char *data;
} AUX_RGBImageRec;

/*
** Prototypes
*/

void APIENTRY auxInitDisplayMode(GLenum);
void APIENTRY auxInitPosition(int, int, int, int);

/* GLenum APIENTRY auxInitWindow(LPCTSTR); */
#ifdef UNICODE
#define auxInitWindow auxInitWindowW
#else
#define auxInitWindow auxInitWindowA
#endif
GLenum APIENTRY auxInitWindowA(LPCSTR);
GLenum APIENTRY auxInitWindowW(LPCWSTR);

void APIENTRY auxCloseWindow(void);
void APIENTRY auxQuit(void);
void APIENTRY auxSwapBuffers(void);

typedef void (CALLBACK* AUXMAINPROC)(void);
void APIENTRY auxMainLoop(AUXMAINPROC);

typedef void (CALLBACK* AUXEXPOSEPROC)(int, int);
void APIENTRY auxExposeFunc(AUXEXPOSEPROC);

typedef void (CALLBACK* AUXRESHAPEPROC)(GLsizei, GLsizei);
void APIENTRY auxReshapeFunc(AUXRESHAPEPROC);

typedef void (CALLBACK* AUXIDLEPROC)(void);
void APIENTRY auxIdleFunc(AUXIDLEPROC);

typedef void (CALLBACK* AUXKEYPROC)(void);
void APIENTRY auxKeyFunc(int, AUXKEYPROC);

typedef void (CALLBACK* AUXMOUSEPROC)(AUX_EVENTREC *);
void APIENTRY auxMouseFunc(int, int, AUXMOUSEPROC);

int  APIENTRY auxGetColorMapSize(void);
void APIENTRY auxGetMouseLoc(int *, int *);
void APIENTRY auxSetOneColor(int, float, float, float);
void APIENTRY auxSetFogRamp(int, int);
void APIENTRY auxSetGreyRamp(void);
void APIENTRY auxSetRGBMap(int, float *);

/* AUX_RGBImageRec * APIENTRY auxRGBImageLoad(LPCTSTR); */
#ifdef UNICODE
#define auxRGBImageLoad auxRGBImageLoadW
#else
#define auxRGBImageLoad auxRGBImageLoadA
#endif
AUX_RGBImageRec * APIENTRY auxRGBImageLoadA(LPCSTR);
AUX_RGBImageRec * APIENTRY auxRGBImageLoadW(LPCWSTR);

#ifdef UNICODE
#define auxDIBImageLoad auxDIBImageLoadW
#else
#define auxDIBImageLoad auxDIBImageLoadA
#endif
AUX_RGBImageRec * APIENTRY auxDIBImageLoadA(LPCSTR);
AUX_RGBImageRec * APIENTRY auxDIBImageLoadW(LPCWSTR);

void APIENTRY auxCreateFont(void);
/* void APIENTRY auxDrawStr(LPCTSTR); */
#ifdef UNICODE
#define auxDrawStr auxDrawStrW
#else
#define auxDrawStr auxDrawStrA
#endif
void APIENTRY auxDrawStrA(LPCSTR);
void APIENTRY auxDrawStrW(LPCWSTR);

void APIENTRY auxWireSphere(GLdouble);
void APIENTRY auxSolidSphere(GLdouble);
void APIENTRY auxWireCube(GLdouble);
void APIENTRY auxSolidCube(GLdouble);
void APIENTRY auxWireBox(GLdouble, GLdouble, GLdouble);
void APIENTRY auxSolidBox(GLdouble, GLdouble, GLdouble);
void APIENTRY auxWireTorus(GLdouble, GLdouble);
void APIENTRY auxSolidTorus(GLdouble, GLdouble);
void APIENTRY auxWireCylinder(GLdouble, GLdouble);
void APIENTRY auxSolidCylinder(GLdouble, GLdouble);
void APIENTRY auxWireIcosahedron(GLdouble);
void APIENTRY auxSolidIcosahedron(GLdouble);
void APIENTRY auxWireOctahedron(GLdouble);
void APIENTRY auxSolidOctahedron(GLdouble);
void APIENTRY auxWireTetrahedron(GLdouble);
void APIENTRY auxSolidTetrahedron(GLdouble);
void APIENTRY auxWireDodecahedron(GLdouble);
void APIENTRY auxSolidDodecahedron(GLdouble);
void APIENTRY auxWireCone(GLdouble, GLdouble);
void APIENTRY auxSolidCone(GLdouble, GLdouble);
void APIENTRY auxWireTeapot(GLdouble);
void APIENTRY auxSolidTeapot(GLdouble);

/*
** Window specific functions
** hwnd, hdc, and hglrc valid after auxInitWindow()
*/
HWND  APIENTRY auxGetHWND(void);
HDC   APIENTRY auxGetHDC(void);
HGLRC APIENTRY auxGetHGLRC(void);

/*
** Viewperf support functions and constants
*/
/* Display Mode Selection Criteria */
enum {
    AUX_USE_ID = 1,
    AUX_EXACT_MATCH,
    AUX_MINIMUM_CRITERIA
};
void   APIENTRY auxInitDisplayModePolicy(GLenum);
GLenum APIENTRY auxInitDisplayModeID(GLint);
GLenum APIENTRY auxGetDisplayModePolicy(void);
GLint  APIENTRY auxGetDisplayModeID(void);
GLenum APIENTRY auxGetDisplayMode(void);

#ifdef __cplusplus
}
#endif

#endif /* __GLAUX_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\zone.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
/*
 memory allocation


H_??? The hunk manages the entire memory block given to quake.  It must be
contiguous.  Memory can be allocated from either the low or high end in a
stack fashion.  The only way memory is released is by resetting one of the
pointers.

Hunk allocations should be given a name, so the Hunk_Print () function
can display usage.

Hunk allocations are guaranteed to be 16 byte aligned.

The video buffers are allocated high to avoid leaving a hole underneath
server allocations when changing to a higher video mode.


Z_??? Zone memory functions used for small, dynamic allocations like text
strings from command input.  There is only about 48K for it, allocated at
the very bottom of the hunk.

Cache_??? Cache memory is for objects that can be dynamically loaded and
can usefully stay persistant between levels.  The size of the cache
fluctuates from level to level.

To allocate a cachable object


Temp_??? Temp memory is used for file loading and surface caching.  The size
of the cache memory is adjusted so that there is a minimum of 512k remaining
for temp memory.


------ Top of Memory -------

high hunk allocations

<--- high hunk reset point held by vid

video buffer

z buffer

surface cache

<--- high hunk used

cachable memory

<--- low hunk used

client and server low hunk allocations

<-- low hunk reset point held by host

startup hunk allocations

Zone block

----- Bottom of Memory -----



*/

void Memory_Init (void *buf, int size);

void Z_Free (void *ptr);
void *Z_Malloc (int size);			// returns 0 filled memory
void *Z_TagMalloc (int size, int tag);

void Z_DumpHeap (void);
void Z_CheckHeap (void);
int Z_FreeMemory (void);

void *Hunk_Alloc (int size);		// returns 0 filled memory
void *Hunk_AllocName (int size, char *name);

void *Hunk_HighAllocName (int size, char *name);

int	Hunk_LowMark (void);
void Hunk_FreeToLowMark (int mark);

int	Hunk_HighMark (void);
void Hunk_FreeToHighMark (int mark);

void *Hunk_TempAlloc (int size);

void Hunk_Check (void);

typedef struct cache_user_s
{
	void	*data;
} cache_user_t;

void Cache_Flush (void);

void *Cache_Check (cache_user_t *c);
// returns the cached data, and moves to the head of the LRU list
// if present, otherwise returns NULL

void Cache_Free (cache_user_t *c);

void *Cache_Alloc (cache_user_t *c, int size, char *name);
// Returns NULL if all purgable data was tossed and there still
// wasn't enough room.

void Cache_Report (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\zone.c ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// Z_zone.c

#include "quakedef.h"

#define	DYNAMIC_SIZE	0xc000

#define	ZONEID	0x1d4a11
#define MINFRAGMENT	64

typedef struct memblock_s
{
	int		size;           // including the header and possibly tiny fragments
	int     tag;            // a tag of 0 is a free block
	int     id;        		// should be ZONEID
	struct memblock_s       *next, *prev;
	int		pad;			// pad to 64 bit boundary
} memblock_t;

typedef struct
{
	int		size;		// total bytes malloced, including header
	memblock_t	blocklist;		// start / end cap for linked list
	memblock_t	*rover;
} memzone_t;

void Cache_FreeLow (int new_low_hunk);
void Cache_FreeHigh (int new_high_hunk);


/*
==============================================================================

						ZONE MEMORY ALLOCATION

There is never any space between memblocks, and there will never be two
contiguous free memblocks.

The rover can be left pointing at a non-empty block

The zone calls are pretty much only used for small strings and structures,
all big things are allocated on the hunk.
==============================================================================
*/

memzone_t	*mainzone;

void Z_ClearZone (memzone_t *zone, int size);


/*
========================
Z_ClearZone
========================
*/
void Z_ClearZone (memzone_t *zone, int size)
{
	memblock_t	*block;
	
// set the entire zone to one free block

	zone->blocklist.next = zone->blocklist.prev = block =
		(memblock_t *)( (byte *)zone + sizeof(memzone_t) );
	zone->blocklist.tag = 1;	// in use block
	zone->blocklist.id = 0;
	zone->blocklist.size = 0;
	zone->rover = block;
	
	block->prev = block->next = &zone->blocklist;
	block->tag = 0;			// free block
	block->id = ZONEID;
	block->size = size - sizeof(memzone_t);
}


/*
========================
Z_Free
========================
*/
void Z_Free (void *ptr)
{
	memblock_t	*block, *other;
	
	if (!ptr)
		Sys_Error ("Z_Free: NULL pointer");

	block = (memblock_t *) ( (byte *)ptr - sizeof(memblock_t));
	if (block->id != ZONEID)
		Sys_Error ("Z_Free: freed a pointer without ZONEID");
	if (block->tag == 0)
		Sys_Error ("Z_Free: freed a freed pointer");

	block->tag = 0;		// mark as free
	
	other = block->prev;
	if (!other->tag)
	{	// merge with previous free block
		other->size += block->size;
		other->next = block->next;
		other->next->prev = other;
		if (block == mainzone->rover)
			mainzone->rover = other;
		block = other;
	}
	
	other = block->next;
	if (!other->tag)
	{	// merge the next free block onto the end
		block->size += other->size;
		block->next = other->next;
		block->next->prev = block;
		if (other == mainzone->rover)
			mainzone->rover = block;
	}
}


/*
========================
Z_Malloc
========================
*/
void *Z_Malloc (int size)
{
	void	*buf;
	
Z_CheckHeap ();	// DEBUG
	buf = Z_TagMalloc (size, 1);
	if (!buf)
		Sys_Error ("Z_Malloc: failed on allocation of %i bytes",size);
	Q_memset (buf, 0, size);

	return buf;
}

void *Z_TagMalloc (int size, int tag)
{
	int		extra;
	memblock_t	*start, *rover, *new, *base;

	if (!tag)
		Sys_Error ("Z_TagMalloc: tried to use a 0 tag");

//
// scan through the block list looking for the first free block
// of sufficient size
//
	size += sizeof(memblock_t);	// account for size of block header
	size += 4;					// space for memory trash tester
	size = (size + 7) & ~7;		// align to 8-byte boundary
	
	base = rover = mainzone->rover;
	start = base->prev;
	
	do
	{
		if (rover == start)	// scaned all the way around the list
			return NULL;
		if (rover->tag)
			base = rover = rover->next;
		else
			rover = rover->next;
	} while (base->tag || base->size < size);
	
//
// found a block big enough
//
	extra = base->size - size;
	if (extra >  MINFRAGMENT)
	{	// there will be a free fragment after the allocated block
		new = (memblock_t *) ((byte *)base + size );
		new->size = extra;
		new->tag = 0;			// free block
		new->prev = base;
		new->id = ZONEID;
		new->next = base->next;
		new->next->prev = new;
		base->next = new;
		base->size = size;
	}
	
	base->tag = tag;				// no longer a free block
	
	mainzone->rover = base->next;	// next allocation will start looking here
	
	base->id = ZONEID;

// marker for memory trash testing
	*(int *)((byte *)base + base->size - 4) = ZONEID;

	return (void *) ((byte *)base + sizeof(memblock_t));
}


/*
========================
Z_Print
========================
*/
void Z_Print (memzone_t *zone)
{
	memblock_t	*block;
	
	Con_Printf ("zone size: %i  location: %p\n",mainzone->size,mainzone);
	
	for (block = zone->blocklist.next ; ; block = block->next)
	{
		Con_Printf ("block:%p    size:%7i    tag:%3i\n",
			block, block->size, block->tag);
		
		if (block->next == &zone->blocklist)
			break;			// all blocks have been hit	
		if ( (byte *)block + block->size != (byte *)block->next)
			Con_Printf ("ERROR: block size does not touch the next block\n");
		if ( block->next->prev != block)
			Con_Printf ("ERROR: next block doesn't have proper back link\n");
		if (!block->tag && !block->next->tag)
			Con_Printf ("ERROR: two consecutive free blocks\n");
	}
}


/*
========================
Z_CheckHeap
========================
*/
void Z_CheckHeap (void)
{
	memblock_t	*block;
	
	for (block = mainzone->blocklist.next ; ; block = block->next)
	{
		if (block->next == &mainzone->blocklist)
			break;			// all blocks have been hit	
		if ( (byte *)block + block->size != (byte *)block->next)
			Sys_Error ("Z_CheckHeap: block size does not touch the next block\n");
		if ( block->next->prev != block)
			Sys_Error ("Z_CheckHeap: next block doesn't have proper back link\n");
		if (!block->tag && !block->next->tag)
			Sys_Error ("Z_CheckHeap: two consecutive free blocks\n");
	}
}

//============================================================================

#define	HUNK_SENTINAL	0x1df001ed

typedef struct
{
	int		sentinal;
	int		size;		// including sizeof(hunk_t), -1 = not allocated
	char	name[8];
} hunk_t;

byte	*hunk_base;
int		hunk_size;

int		hunk_low_used;
int		hunk_high_used;

qboolean	hunk_tempactive;
int		hunk_tempmark;

void R_FreeTextures (void);

/*
==============
Hunk_Check

Run consistancy and sentinal trahing checks
==============
*/
void Hunk_Check (void)
{
	hunk_t	*h;
	
	for (h = (hunk_t *)hunk_base ; (byte *)h != hunk_base + hunk_low_used ; )
	{
		if (h->sentinal != HUNK_SENTINAL)
			Sys_Error ("Hunk_Check: trahsed sentinal");
		if (h->size < 16 || h->size + (byte *)h - hunk_base > hunk_size)
			Sys_Error ("Hunk_Check: bad size");
		h = (hunk_t *)((byte *)h+h->size);
	}
}

/*
==============
Hunk_Print

If "all" is specified, every single allocation is printed.
Otherwise, allocations with the same name will be totaled up before printing.
==============
*/
void Hunk_Print (qboolean all)
{
	hunk_t	*h, *next, *endlow, *starthigh, *endhigh;
	int		count, sum;
	int		totalblocks;
	char	name[9];

	name[8] = 0;
	count = 0;
	sum = 0;
	totalblocks = 0;
	
	h = (hunk_t *)hunk_base;
	endlow = (hunk_t *)(hunk_base + hunk_low_used);
	starthigh = (hunk_t *)(hunk_base + hunk_size - hunk_high_used);
	endhigh = (hunk_t *)(hunk_base + hunk_size);

	Con_Printf ("          :%8i total hunk size\n", hunk_size);
	Con_Printf ("-------------------------\n");

	while (1)
	{
	//
	// skip to the high hunk if done with low hunk
	//
		if ( h == endlow )
		{
			Con_Printf ("-------------------------\n");
			Con_Printf ("          :%8i REMAINING\n", hunk_size - hunk_low_used - hunk_high_used);
			Con_Printf ("-------------------------\n");
			h = starthigh;
		}
		
	//
	// if totally done, break
	//
		if ( h == endhigh )
			break;

	//
	// run consistancy checks
	//
		if (h->sentinal != HUNK_SENTINAL)
			Sys_Error ("Hunk_Check: trahsed sentinal");
		if (h->size < 16 || h->size + (byte *)h - hunk_base > hunk_size)
			Sys_Error ("Hunk_Check: bad size");
			
		next = (hunk_t *)((byte *)h+h->size);
		count++;
		totalblocks++;
		sum += h->size;

	//
	// print the single block
	//
		memcpy (name, h->name, 8);
		if (all)
			Con_Printf ("%8p :%8i %8s\n",h, h->size, name);
			
	//
	// print the total
	//
		if (next == endlow || next == endhigh || 
		strncmp (h->name, next->name, 8) )
		{
			if (!all)
				Con_Printf ("          :%8i %8s (TOTAL)\n",sum, name);
			count = 0;
			sum = 0;
		}

		h = next;
	}

	Con_Printf ("-------------------------\n");
	Con_Printf ("%8i total blocks\n", totalblocks);
	
}

/*
===================
Hunk_AllocName
===================
*/
void *Hunk_AllocName (int size, char *name)
{
	hunk_t	*h;
	
#ifdef PARANOID
	Hunk_Check ();
#endif

	if (size < 0)
		Sys_Error ("Hunk_Alloc: bad size: %i", size);
		
	size = sizeof(hunk_t) + ((size+15)&~15);
	
	if (hunk_size - hunk_low_used - hunk_high_used < size)
		Sys_Error ("Hunk_Alloc: failed on %i bytes",size);
	
	h = (hunk_t *)(hunk_base + hunk_low_used);
	hunk_low_used += size;

	Cache_FreeLow (hunk_low_used);

	memset (h, 0, size);
	
	h->size = size;
	h->sentinal = HUNK_SENTINAL;
	Q_strncpy (h->name, name, 8);
	
	return (void *)(h+1);
}

/*
===================
Hunk_Alloc
===================
*/
void *Hunk_Alloc (int size)
{
	return Hunk_AllocName (size, "unknown");
}

int	Hunk_LowMark (void)
{
	return hunk_low_used;
}

void Hunk_FreeToLowMark (int mark)
{
	if (mark < 0 || mark > hunk_low_used)
		Sys_Error ("Hunk_FreeToLowMark: bad mark %i", mark);
	memset (hunk_base + mark, 0, hunk_low_used - mark);
	hunk_low_used = mark;
}

int	Hunk_HighMark (void)
{
	if (hunk_tempactive)
	{
		hunk_tempactive = false;
		Hunk_FreeToHighMark (hunk_tempmark);
	}

	return hunk_high_used;
}

void Hunk_FreeToHighMark (int mark)
{
	if (hunk_tempactive)
	{
		hunk_tempactive = false;
		Hunk_FreeToHighMark (hunk_tempmark);
	}
	if (mark < 0 || mark > hunk_high_used)
		Sys_Error ("Hunk_FreeToHighMark: bad mark %i", mark);
	memset (hunk_base + hunk_size - hunk_high_used, 0, hunk_high_used - mark);
	hunk_high_used = mark;
}


/*
===================
Hunk_HighAllocName
===================
*/
void *Hunk_HighAllocName (int size, char *name)
{
	hunk_t	*h;

	if (size < 0)
		Sys_Error ("Hunk_HighAllocName: bad size: %i", size);

	if (hunk_tempactive)
	{
		Hunk_FreeToHighMark (hunk_tempmark);
		hunk_tempactive = false;
	}

#ifdef PARANOID
	Hunk_Check ();
#endif

	size = sizeof(hunk_t) + ((size+15)&~15);

	if (hunk_size - hunk_low_used - hunk_high_used < size)
	{
		Con_Printf ("Hunk_HighAlloc: failed on %i bytes\n",size);
		return NULL;
	}

	hunk_high_used += size;
	Cache_FreeHigh (hunk_high_used);

	h = (hunk_t *)(hunk_base + hunk_size - hunk_high_used);

	memset (h, 0, size);
	h->size = size;
	h->sentinal = HUNK_SENTINAL;
	Q_strncpy (h->name, name, 8);

	return (void *)(h+1);
}


/*
=================
Hunk_TempAlloc

Return space from the top of the hunk
=================
*/
void *Hunk_TempAlloc (int size)
{
	void	*buf;

	size = (size+15)&~15;
	
	if (hunk_tempactive)
	{
		Hunk_FreeToHighMark (hunk_tempmark);
		hunk_tempactive = false;
	}
	
	hunk_tempmark = Hunk_HighMark ();

	buf = Hunk_HighAllocName (size, "temp");

	hunk_tempactive = true;

	return buf;
}

/*
===============================================================================

CACHE MEMORY

===============================================================================
*/

typedef struct cache_system_s
{
	int						size;		// including this header
	cache_user_t			*user;
	char					name[16];
	struct cache_system_s	*prev, *next;
	struct cache_system_s	*lru_prev, *lru_next;	// for LRU flushing	
} cache_system_t;

cache_system_t *Cache_TryAlloc (int size, qboolean nobottom);

cache_system_t	cache_head;

/*
===========
Cache_Move
===========
*/
void Cache_Move ( cache_system_t *c)
{
	cache_system_t		*new;

// we are clearing up space at the bottom, so only allocate it late
	new = Cache_TryAlloc (c->size, true);
	if (new)
	{
//		Con_Printf ("cache_move ok\n");

		Q_memcpy ( new+1, c+1, c->size - sizeof(cache_system_t) );
		new->user = c->user;
		Q_memcpy (new->name, c->name, sizeof(new->name));
		Cache_Free (c->user);
		new->user->data = (void *)(new+1);
	}
	else
	{
//		Con_Printf ("cache_move failed\n");

		Cache_Free (c->user);		// tough luck...
	}
}

/*
============
Cache_FreeLow

Throw things out until the hunk can be expanded to the given point
============
*/
void Cache_FreeLow (int new_low_hunk)
{
	cache_system_t	*c;
	
	while (1)
	{
		c = cache_head.next;
		if (c == &cache_head)
			return;		// nothing in cache at all
		if ((byte *)c >= hunk_base + new_low_hunk)
			return;		// there is space to grow the hunk
		Cache_Move ( c );	// reclaim the space
	}
}

/*
============
Cache_FreeHigh

Throw things out until the hunk can be expanded to the given point
============
*/
void Cache_FreeHigh (int new_high_hunk)
{
	cache_system_t	*c, *prev;
	
	prev = NULL;
	while (1)
	{
		c = cache_head.prev;
		if (c == &cache_head)
			return;		// nothing in cache at all
		if ( (byte *)c + c->size <= hunk_base + hunk_size - new_high_hunk)
			return;		// there is space to grow the hunk
		if (c == prev)
			Cache_Free (c->user);	// didn't move out of the way
		else
		{
			Cache_Move (c);	// try to move it
			prev = c;
		}
	}
}

void Cache_UnlinkLRU (cache_system_t *cs)
{
	if (!cs->lru_next || !cs->lru_prev)
		Sys_Error ("Cache_UnlinkLRU: NULL link");

	cs->lru_next->lru_prev = cs->lru_prev;
	cs->lru_prev->lru_next = cs->lru_next;
	
	cs->lru_prev = cs->lru_next = NULL;
}

void Cache_MakeLRU (cache_system_t *cs)
{
	if (cs->lru_next || cs->lru_prev)
		Sys_Error ("Cache_MakeLRU: active link");

	cache_head.lru_next->lru_prev = cs;
	cs->lru_next = cache_head.lru_next;
	cs->lru_prev = &cache_head;
	cache_head.lru_next = cs;
}

/*
============
Cache_TryAlloc

Looks for a free block of memory between the high and low hunk marks
Size should already include the header and padding
============
*/
cache_system_t *Cache_TryAlloc (int size, qboolean nobottom)
{
	cache_system_t	*cs, *new;
	
// is the cache completely empty?

	if (!nobottom && cache_head.prev == &cache_head)
	{
		if (hunk_size - hunk_high_used - hunk_low_used < size)
			Sys_Error ("Cache_TryAlloc: %i is greater then free hunk", size);

		new = (cache_system_t *) (hunk_base + hunk_low_used);
		memset (new, 0, sizeof(*new));
		new->size = size;

		cache_head.prev = cache_head.next = new;
		new->prev = new->next = &cache_head;
		
		Cache_MakeLRU (new);
		return new;
	}
	
// search from the bottom up for space

	new = (cache_system_t *) (hunk_base + hunk_low_used);
	cs = cache_head.next;
	
	do
	{
		if (!nobottom || cs != cache_head.next)
		{
			if ( (byte *)cs - (byte *)new >= size)
			{	// found space
				memset (new, 0, sizeof(*new));
				new->size = size;
				
				new->next = cs;
				new->prev = cs->prev;
				cs->prev->next = new;
				cs->prev = new;
				
				Cache_MakeLRU (new);
	
				return new;
			}
		}

	// continue looking		
		new = (cache_system_t *)((byte *)cs + cs->size);
		cs = cs->next;

	} while (cs != &cache_head);
	
// try to allocate one at the very end
	if ( hunk_base + hunk_size - hunk_high_used - (byte *)new >= size)
	{
		memset (new, 0, sizeof(*new));
		new->size = size;
		
		new->next = &cache_head;
		new->prev = cache_head.prev;
		cache_head.prev->next = new;
		cache_head.prev = new;
		
		Cache_MakeLRU (new);

		return new;
	}
	
	return NULL;		// couldn't allocate
}

/*
============
Cache_Flush

Throw everything out, so new data will be demand cached
============
*/
void Cache_Flush (void)
{
	while (cache_head.next != &cache_head)
		Cache_Free ( cache_head.next->user );	// reclaim the space
}


/*
============
Cache_Print

============
*/
void Cache_Print (void)
{
	cache_system_t	*cd;

	for (cd = cache_head.next ; cd != &cache_head ; cd = cd->next)
	{
		Con_Printf ("%8i : %s\n", cd->size, cd->name);
	}
}

/*
============
Cache_Report

============
*/
void Cache_Report (void)
{
	Con_DPrintf ("%4.1f megabyte data cache\n", (hunk_size - hunk_high_used - hunk_low_used) / (float)(1024*1024) );
}

/*
============
Cache_Compact

============
*/
void Cache_Compact (void)
{
}

/*
============
Cache_Init

============
*/
void Cache_Init (void)
{
	cache_head.next = cache_head.prev = &cache_head;
	cache_head.lru_next = cache_head.lru_prev = &cache_head;

	Cmd_AddCommand ("flush", Cache_Flush);
}

/*
==============
Cache_Free

Frees the memory and removes it from the LRU list
==============
*/
void Cache_Free (cache_user_t *c)
{
	cache_system_t	*cs;

	if (!c->data)
		Sys_Error ("Cache_Free: not allocated");

	cs = ((cache_system_t *)c->data) - 1;

	cs->prev->next = cs->next;
	cs->next->prev = cs->prev;
	cs->next = cs->prev = NULL;

	c->data = NULL;

	Cache_UnlinkLRU (cs);
}



/*
==============
Cache_Check
==============
*/
void *Cache_Check (cache_user_t *c)
{
	cache_system_t	*cs;

	if (!c->data)
		return NULL;

	cs = ((cache_system_t *)c->data) - 1;

// move to head of LRU
	Cache_UnlinkLRU (cs);
	Cache_MakeLRU (cs);
	
	return c->data;
}


/*
==============
Cache_Alloc
==============
*/
void *Cache_Alloc (cache_user_t *c, int size, char *name)
{
	cache_system_t	*cs;

	if (c->data)
		Sys_Error ("Cache_Alloc: allready allocated");
	
	if (size <= 0)
		Sys_Error ("Cache_Alloc: size %i", size);

	size = (size + sizeof(cache_system_t) + 15) & ~15;

// find memory for it	
	while (1)
	{
		cs = Cache_TryAlloc (size, false);
		if (cs)
		{
			strncpy (cs->name, name, sizeof(cs->name)-1);
			c->data = (void *)(cs+1);
			cs->user = c;
			break;
		}
	
	// free the least recently used cahedat
		if (cache_head.lru_prev == &cache_head)
			Sys_Error ("Cache_Alloc: out of memory");
													// not enough memory at all
		Cache_Free ( cache_head.lru_prev->user );
	} 
	
	return Cache_Check (c);
}

//============================================================================


/*
========================
Memory_Init
========================
*/
void Memory_Init (void *buf, int size)
{
	int p;
	int zonesize = DYNAMIC_SIZE;

	hunk_base = buf;
	hunk_size = size;
	hunk_low_used = 0;
	hunk_high_used = 0;
	
	Cache_Init ();
	mainzone = Hunk_AllocName (zonesize, "zone" );
	Z_ClearZone (mainzone, zonesize);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\asm_i386.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#ifndef __ASM_I386__
#define __ASM_I386__

#ifdef ELF
#define C(label) label
#else
#define C(label) _##label
#endif

//
// !!! note that this file must match the corresponding C structures at all
// times !!!
//

// plane_t structure
// !!! if this is changed, it must be changed in model.h too !!!
// !!! if the size of this is changed, the array lookup in SV_HullPointContents
//     must be changed too !!!
#define pl_normal	0
#define pl_dist		12
#define pl_type		16
#define pl_signbits	17
#define pl_pad		18
#define pl_size		20

// hull_t structure
// !!! if this is changed, it must be changed in model.h too !!!
#define	hu_clipnodes		0
#define	hu_planes			4
#define	hu_firstclipnode	8
#define	hu_lastclipnode		12
#define	hu_clip_mins		16
#define	hu_clip_maxs		28
#define hu_size  			40

// dnode_t structure
// !!! if this is changed, it must be changed in bspfile.h too !!!
#define	nd_planenum		0
#define	nd_children		4
#define	nd_mins			8
#define	nd_maxs			20
#define	nd_firstface	32
#define	nd_numfaces		36
#define nd_size			40

// sfxcache_t structure
// !!! if this is changed, it much be changed in sound.h too !!!
#define sfxc_length		0
#define sfxc_loopstart	4
#define sfxc_speed		8
#define sfxc_width		12
#define sfxc_stereo		16
#define sfxc_data		20

// channel_t structure
// !!! if this is changed, it much be changed in sound.h too !!!
#define ch_sfx			0
#define ch_leftvol		4
#define ch_rightvol		8
#define ch_end			12
#define ch_pos			16
#define ch_looping		20
#define ch_entnum		24
#define ch_entchannel	28
#define ch_origin		32
#define ch_dist_mult	44
#define ch_master_vol	48
#define ch_size			52

// portable_samplepair_t structure
// !!! if this is changed, it much be changed in sound.h too !!!
#define psp_left		0
#define psp_right		4
#define psp_size		8

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\adivtab.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// table of quotients and remainders for [-15...16] / [-15...16]

// numerator = -15
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{1, -5},
{1, -6},
{1, -7},
{2, -1},
{2, -3},
{3, 0},
{3, -3},
{5, 0},
{7, -1},
{15, 0},
{0, 0},
{-15, 0},
{-8, 1},
{-5, 0},
{-4, 1},
{-3, 0},
{-3, 3},
{-3, 6},
{-2, 1},
{-2, 3},
{-2, 5},
{-2, 7},
{-2, 9},
{-2, 11},
{-2, 13},
{-1, 0},
{-1, 1},
// numerator = -14
{0, -14},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{1, -5},
{1, -6},
{2, 0},
{2, -2},
{2, -4},
{3, -2},
{4, -2},
{7, 0},
{14, 0},
{0, 0},
{-14, 0},
{-7, 0},
{-5, 1},
{-4, 2},
{-3, 1},
{-3, 4},
{-2, 0},
{-2, 2},
{-2, 4},
{-2, 6},
{-2, 8},
{-2, 10},
{-2, 12},
{-1, 0},
{-1, 1},
{-1, 2},
// numerator = -13
{0, -13},
{0, -13},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{1, -5},
{1, -6},
{2, -1},
{2, -3},
{3, -1},
{4, -1},
{6, -1},
{13, 0},
{0, 0},
{-13, 0},
{-7, 1},
{-5, 2},
{-4, 3},
{-3, 2},
{-3, 5},
{-2, 1},
{-2, 3},
{-2, 5},
{-2, 7},
{-2, 9},
{-2, 11},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
// numerator = -12
{0, -12},
{0, -12},
{0, -12},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{1, -5},
{2, 0},
{2, -2},
{3, 0},
{4, 0},
{6, 0},
{12, 0},
{0, 0},
{-12, 0},
{-6, 0},
{-4, 0},
{-3, 0},
{-3, 3},
{-2, 0},
{-2, 2},
{-2, 4},
{-2, 6},
{-2, 8},
{-2, 10},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
// numerator = -11
{0, -11},
{0, -11},
{0, -11},
{0, -11},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{1, -5},
{2, -1},
{2, -3},
{3, -2},
{5, -1},
{11, 0},
{0, 0},
{-11, 0},
{-6, 1},
{-4, 1},
{-3, 1},
{-3, 4},
{-2, 1},
{-2, 3},
{-2, 5},
{-2, 7},
{-2, 9},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
// numerator = -10
{0, -10},
{0, -10},
{0, -10},
{0, -10},
{0, -10},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{2, 0},
{2, -2},
{3, -1},
{5, 0},
{10, 0},
{0, 0},
{-10, 0},
{-5, 0},
{-4, 2},
{-3, 2},
{-2, 0},
{-2, 2},
{-2, 4},
{-2, 6},
{-2, 8},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
// numerator = -9
{0, -9},
{0, -9},
{0, -9},
{0, -9},
{0, -9},
{0, -9},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{1, -4},
{2, -1},
{3, 0},
{4, -1},
{9, 0},
{0, 0},
{-9, 0},
{-5, 1},
{-3, 0},
{-3, 3},
{-2, 1},
{-2, 3},
{-2, 5},
{-2, 7},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
// numerator = -8
{0, -8},
{0, -8},
{0, -8},
{0, -8},
{0, -8},
{0, -8},
{0, -8},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{2, 0},
{2, -2},
{4, 0},
{8, 0},
{0, 0},
{-8, 0},
{-4, 0},
{-3, 1},
{-2, 0},
{-2, 2},
{-2, 4},
{-2, 6},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
// numerator = -7
{0, -7},
{0, -7},
{0, -7},
{0, -7},
{0, -7},
{0, -7},
{0, -7},
{0, -7},
{1, 0},
{1, -1},
{1, -2},
{1, -3},
{2, -1},
{3, -1},
{7, 0},
{0, 0},
{-7, 0},
{-4, 1},
{-3, 2},
{-2, 1},
{-2, 3},
{-2, 5},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
// numerator = -6
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{0, -6},
{1, 0},
{1, -1},
{1, -2},
{2, 0},
{3, 0},
{6, 0},
{0, 0},
{-6, 0},
{-3, 0},
{-2, 0},
{-2, 2},
{-2, 4},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
// numerator = -5
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{0, -5},
{1, 0},
{1, -1},
{1, -2},
{2, -1},
{5, 0},
{0, 0},
{-5, 0},
{-3, 1},
{-2, 1},
{-2, 3},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
{-1, 11},
// numerator = -4
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{0, -4},
{1, 0},
{1, -1},
{2, 0},
{4, 0},
{0, 0},
{-4, 0},
{-2, 0},
{-2, 2},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
{-1, 11},
{-1, 12},
// numerator = -3
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{0, -3},
{1, 0},
{1, -1},
{3, 0},
{0, 0},
{-3, 0},
{-2, 1},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
{-1, 11},
{-1, 12},
{-1, 13},
// numerator = -2
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{0, -2},
{1, 0},
{2, 0},
{0, 0},
{-2, 0},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
{-1, 11},
{-1, 12},
{-1, 13},
{-1, 14},
// numerator = -1
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{0, -1},
{1, 0},
{0, 0},
{-1, 0},
{-1, 1},
{-1, 2},
{-1, 3},
{-1, 4},
{-1, 5},
{-1, 6},
{-1, 7},
{-1, 8},
{-1, 9},
{-1, 10},
{-1, 11},
{-1, 12},
{-1, 13},
{-1, 14},
{-1, 15},
// numerator = 0
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
{0, 0},
// numerator = 1
{-1, -14},
{-1, -13},
{-1, -12},
{-1, -11},
{-1, -10},
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{0, 0},
{1, 0},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
{0, 1},
// numerator = 2
{-1, -13},
{-1, -12},
{-1, -11},
{-1, -10},
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, 0},
{0, 0},
{2, 0},
{1, 0},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
{0, 2},
// numerator = 3
{-1, -12},
{-1, -11},
{-1, -10},
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -1},
{-3, 0},
{0, 0},
{3, 0},
{1, 1},
{1, 0},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
{0, 3},
// numerator = 4
{-1, -11},
{-1, -10},
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -2},
{-2, 0},
{-4, 0},
{0, 0},
{4, 0},
{2, 0},
{1, 1},
{1, 0},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
{0, 4},
// numerator = 5
{-1, -10},
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -3},
{-2, -1},
{-3, -1},
{-5, 0},
{0, 0},
{5, 0},
{2, 1},
{1, 2},
{1, 1},
{1, 0},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
{0, 5},
// numerator = 6
{-1, -9},
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, 0},
{-6, 0},
{0, 0},
{6, 0},
{3, 0},
{2, 0},
{1, 2},
{1, 1},
{1, 0},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
{0, 6},
// numerator = 7
{-1, -8},
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -5},
{-2, -3},
{-2, -1},
{-3, -2},
{-4, -1},
{-7, 0},
{0, 0},
{7, 0},
{3, 1},
{2, 1},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
{0, 7},
// numerator = 8
{-1, -7},
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -6},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, -1},
{-4, 0},
{-8, 0},
{0, 0},
{8, 0},
{4, 0},
{2, 2},
{2, 0},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 8},
{0, 8},
{0, 8},
{0, 8},
{0, 8},
{0, 8},
{0, 8},
{0, 8},
// numerator = 9
{-1, -6},
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -7},
{-2, -5},
{-2, -3},
{-2, -1},
{-3, -3},
{-3, 0},
{-5, -1},
{-9, 0},
{0, 0},
{9, 0},
{4, 1},
{3, 0},
{2, 1},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 9},
{0, 9},
{0, 9},
{0, 9},
{0, 9},
{0, 9},
{0, 9},
// numerator = 10
{-1, -5},
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -8},
{-2, -6},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, -2},
{-4, -2},
{-5, 0},
{-10, 0},
{0, 0},
{10, 0},
{5, 0},
{3, 1},
{2, 2},
{2, 0},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 10},
{0, 10},
{0, 10},
{0, 10},
{0, 10},
{0, 10},
// numerator = 11
{-1, -4},
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -9},
{-2, -7},
{-2, -5},
{-2, -3},
{-2, -1},
{-3, -4},
{-3, -1},
{-4, -1},
{-6, -1},
{-11, 0},
{0, 0},
{11, 0},
{5, 1},
{3, 2},
{2, 3},
{2, 1},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 11},
{0, 11},
{0, 11},
{0, 11},
{0, 11},
// numerator = 12
{-1, -3},
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -10},
{-2, -8},
{-2, -6},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, -3},
{-3, 0},
{-4, 0},
{-6, 0},
{-12, 0},
{0, 0},
{12, 0},
{6, 0},
{4, 0},
{3, 0},
{2, 2},
{2, 0},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 12},
{0, 12},
{0, 12},
{0, 12},
// numerator = 13
{-1, -2},
{-1, -1},
{-1, 0},
{-2, -11},
{-2, -9},
{-2, -7},
{-2, -5},
{-2, -3},
{-2, -1},
{-3, -5},
{-3, -2},
{-4, -3},
{-5, -2},
{-7, -1},
{-13, 0},
{0, 0},
{13, 0},
{6, 1},
{4, 1},
{3, 1},
{2, 3},
{2, 1},
{1, 6},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 13},
{0, 13},
{0, 13},
// numerator = 14
{-1, -1},
{-1, 0},
{-2, -12},
{-2, -10},
{-2, -8},
{-2, -6},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, -4},
{-3, -1},
{-4, -2},
{-5, -1},
{-7, 0},
{-14, 0},
{0, 0},
{14, 0},
{7, 0},
{4, 2},
{3, 2},
{2, 4},
{2, 2},
{2, 0},
{1, 6},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 14},
{0, 14},
// numerator = 15
{-1, 0},
{-2, -13},
{-2, -11},
{-2, -9},
{-2, -7},
{-2, -5},
{-2, -3},
{-2, -1},
{-3, -6},
{-3, -3},
{-3, 0},
{-4, -1},
{-5, 0},
{-8, -1},
{-15, 0},
{0, 0},
{15, 0},
{7, 1},
{5, 0},
{3, 3},
{3, 0},
{2, 3},
{2, 1},
{1, 7},
{1, 6},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
{0, 15},
// numerator = 16
{-2, -14},
{-2, -12},
{-2, -10},
{-2, -8},
{-2, -6},
{-2, -4},
{-2, -2},
{-2, 0},
{-3, -5},
{-3, -2},
{-4, -4},
{-4, 0},
{-6, -2},
{-8, 0},
{-16, 0},
{0, 0},
{16, 0},
{8, 0},
{5, 1},
{4, 0},
{3, 1},
{2, 4},
{2, 2},
{2, 0},
{1, 7},
{1, 6},
{1, 5},
{1, 4},
{1, 3},
{1, 2},
{1, 1},
{1, 0},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\asm_draw.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// asm_draw.h
//
// Include file for asm drawing routines.
//

//
// !!! note that this file must match the corresponding C structures at all
// times !!!
//

// !!! if this is changed, it must be changed in r_local.h too !!!
#define	NEAR_CLIP	0.01

// !!! if this is changed, it must be changed in r_local.h too !!!
#define	CYCLE	128

// espan_t structure
// !!! if this is changed, it must be changed in r_shared.h too !!!
#define espan_t_u    	0
#define espan_t_v	    4
#define espan_t_count   8
#define espan_t_pnext	12
#define espan_t_size    16

// sspan_t structure
// !!! if this is changed, it must be changed in d_local.h too !!!
#define sspan_t_u    	0
#define sspan_t_v	    4
#define sspan_t_count   8
#define sspan_t_size    12

// spanpackage_t structure
// !!! if this is changed, it must be changed in d_polyset.c too !!!
#define spanpackage_t_pdest				0
#define spanpackage_t_pz				4
#define spanpackage_t_count				8
#define spanpackage_t_ptex				12
#define spanpackage_t_sfrac				16
#define spanpackage_t_tfrac				20
#define spanpackage_t_light				24
#define spanpackage_t_zi				28
#define spanpackage_t_size				32 

// edge_t structure
// !!! if this is changed, it must be changed in r_shared.h too !!!
#define et_u			0
#define et_u_step		4
#define et_prev			8
#define et_next			12
#define et_surfs		16
#define et_nextremove	20
#define et_nearzi		24
#define et_owner		28
#define et_size			32

// surf_t structure
// !!! if this is changed, it must be changed in r_shared.h too !!!
#define SURF_T_SHIFT	6
#define st_next			0
#define st_prev			4
#define st_spans		8
#define st_key			12
#define st_last_u		16
#define st_spanstate	20
#define st_flags		24
#define st_data			28
#define st_entity		32
#define st_nearzi		36
#define st_insubmodel	40
#define st_d_ziorigin	44
#define st_d_zistepu	48
#define st_d_zistepv	52
#define st_pad			56
#define st_size			64

// clipplane_t structure
// !!! if this is changed, it must be changed in r_local.h too !!!
#define cp_normal		0
#define cp_dist			12
#define cp_next			16
#define cp_leftedge		20
#define cp_rightedge	21
#define cp_reserved		22
#define cp_size			24

// medge_t structure
// !!! if this is changed, it must be changed in model.h too !!!
#define me_v				0
#define me_cachededgeoffset	4
#define me_size				8

// mvertex_t structure
// !!! if this is changed, it must be changed in model.h too !!!
#define mv_position		0
#define mv_size			12

// refdef_t structure
// !!! if this is changed, it must be changed in render.h too !!!
#define rd_vrect					0
#define rd_aliasvrect				20
#define rd_vrectright				40
#define rd_vrectbottom				44
#define rd_aliasvrectright			48
#define rd_aliasvrectbottom			52
#define rd_vrectrightedge			56
#define rd_fvrectx					60
#define rd_fvrecty					64
#define rd_fvrectx_adj				68
#define rd_fvrecty_adj				72
#define rd_vrect_x_adj_shift20		76
#define rd_vrectright_adj_shift20	80
#define rd_fvrectright_adj			84
#define rd_fvrectbottom_adj			88
#define rd_fvrectright				92
#define rd_fvrectbottom				96
#define rd_horizontalFieldOfView	100
#define rd_xOrigin					104
#define rd_yOrigin					108
#define rd_vieworg					112
#define rd_viewangles				124
#define rd_ambientlight				136
#define rd_size						140

// mtriangle_t structure
// !!! if this is changed, it must be changed in model.h too !!!
#define mtri_facesfront		0
#define mtri_vertindex		4
#define mtri_size			16	// !!! if this changes, array indexing in !!!
								// !!! d_polysa.s must be changed to match !!!
#define mtri_shift			4
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\gl\gl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1985-96, Microsoft Corporation

Module Name:

    gl.h

Abstract:

    Procedure declarations, constant definitions and macros for the OpenGL
    component.

--*/

#ifndef __gl_h_
#ifndef __GL_H__

#define __gl_h_
#define __GL_H__

#ifdef __cplusplus
extern "C" {
#endif

/*
** Copyright 1996 Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef signed char GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;

/*************************************************************/

/* Version */
#define GL_VERSION_1_1                    1

/* AccumOp */
#define GL_ACCUM                          0x0100
#define GL_LOAD                           0x0101
#define GL_RETURN                         0x0102
#define GL_MULT                           0x0103
#define GL_ADD                            0x0104

/* AlphaFunction */
#define GL_NEVER                          0x0200
#define GL_LESS                           0x0201
#define GL_EQUAL                          0x0202
#define GL_LEQUAL                         0x0203
#define GL_GREATER                        0x0204
#define GL_NOTEQUAL                       0x0205
#define GL_GEQUAL                         0x0206
#define GL_ALWAYS                         0x0207

/* AttribMask */
#define GL_CURRENT_BIT                    0x00000001
#define GL_POINT_BIT                      0x00000002
#define GL_LINE_BIT                       0x00000004
#define GL_POLYGON_BIT                    0x00000008
#define GL_POLYGON_STIPPLE_BIT            0x00000010
#define GL_PIXEL_MODE_BIT                 0x00000020
#define GL_LIGHTING_BIT                   0x00000040
#define GL_FOG_BIT                        0x00000080
#define GL_DEPTH_BUFFER_BIT               0x00000100
#define GL_ACCUM_BUFFER_BIT               0x00000200
#define GL_STENCIL_BUFFER_BIT             0x00000400
#define GL_VIEWPORT_BIT                   0x00000800
#define GL_TRANSFORM_BIT                  0x00001000
#define GL_ENABLE_BIT                     0x00002000
#define GL_COLOR_BUFFER_BIT               0x00004000
#define GL_HINT_BIT                       0x00008000
#define GL_EVAL_BIT                       0x00010000
#define GL_LIST_BIT                       0x00020000
#define GL_TEXTURE_BIT                    0x00040000
#define GL_SCISSOR_BIT                    0x00080000
#define GL_ALL_ATTRIB_BITS                0x000fffff

/* BeginMode */
#define GL_POINTS                         0x0000
#define GL_LINES                          0x0001
#define GL_LINE_LOOP                      0x0002
#define GL_LINE_STRIP                     0x0003
#define GL_TRIANGLES                      0x0004
#define GL_TRIANGLE_STRIP                 0x0005
#define GL_TRIANGLE_FAN                   0x0006
#define GL_QUADS                          0x0007
#define GL_QUAD_STRIP                     0x0008
#define GL_POLYGON                        0x0009

/* BlendingFactorDest */
#define GL_ZERO                           0
#define GL_ONE                            1
#define GL_SRC_COLOR                      0x0300
#define GL_ONE_MINUS_SRC_COLOR            0x0301
#define GL_SRC_ALPHA                      0x0302
#define GL_ONE_MINUS_SRC_ALPHA            0x0303
#define GL_DST_ALPHA                      0x0304
#define GL_ONE_MINUS_DST_ALPHA            0x0305

/* BlendingFactorSrc */
/*      GL_ZERO */
/*      GL_ONE */
#define GL_DST_COLOR                      0x0306
#define GL_ONE_MINUS_DST_COLOR            0x0307
#define GL_SRC_ALPHA_SATURATE             0x0308
/*      GL_SRC_ALPHA */
/*      GL_ONE_MINUS_SRC_ALPHA */
/*      GL_DST_ALPHA */
/*      GL_ONE_MINUS_DST_ALPHA */

/* Boolean */
#define GL_TRUE                           1
#define GL_FALSE                          0

/* ClearBufferMask */
/*      GL_COLOR_BUFFER_BIT */
/*      GL_ACCUM_BUFFER_BIT */
/*      GL_STENCIL_BUFFER_BIT */
/*      GL_DEPTH_BUFFER_BIT */

/* ClientArrayType */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */

/* ClipPlaneName */
#define GL_CLIP_PLANE0                    0x3000
#define GL_CLIP_PLANE1                    0x3001
#define GL_CLIP_PLANE2                    0x3002
#define GL_CLIP_PLANE3                    0x3003
#define GL_CLIP_PLANE4                    0x3004
#define GL_CLIP_PLANE5                    0x3005

/* ColorMaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* ColorMaterialParameter */
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */
/*      GL_EMISSION */
/*      GL_AMBIENT_AND_DIFFUSE */

/* ColorPointerType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* CullFaceMode */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* DataType */
#define GL_BYTE                           0x1400
#define GL_UNSIGNED_BYTE                  0x1401
#define GL_SHORT                          0x1402
#define GL_UNSIGNED_SHORT                 0x1403
#define GL_INT                            0x1404
#define GL_UNSIGNED_INT                   0x1405
#define GL_FLOAT                          0x1406
#define GL_2_BYTES                        0x1407
#define GL_3_BYTES                        0x1408
#define GL_4_BYTES                        0x1409
#define GL_DOUBLE                         0x140A

/* DepthFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* DrawBufferMode */
#define GL_NONE                           0
#define GL_FRONT_LEFT                     0x0400
#define GL_FRONT_RIGHT                    0x0401
#define GL_BACK_LEFT                      0x0402
#define GL_BACK_RIGHT                     0x0403
#define GL_FRONT                          0x0404
#define GL_BACK                           0x0405
#define GL_LEFT                           0x0406
#define GL_RIGHT                          0x0407
#define GL_FRONT_AND_BACK                 0x0408
#define GL_AUX0                           0x0409
#define GL_AUX1                           0x040A
#define GL_AUX2                           0x040B
#define GL_AUX3                           0x040C

/* Enable */
/*      GL_FOG */
/*      GL_LIGHTING */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_LINE_STIPPLE */
/*      GL_POLYGON_STIPPLE */
/*      GL_CULL_FACE */
/*      GL_ALPHA_TEST */
/*      GL_BLEND */
/*      GL_INDEX_LOGIC_OP */
/*      GL_COLOR_LOGIC_OP */
/*      GL_DITHER */
/*      GL_STENCIL_TEST */
/*      GL_DEPTH_TEST */
/*      GL_CLIP_PLANE0 */
/*      GL_CLIP_PLANE1 */
/*      GL_CLIP_PLANE2 */
/*      GL_CLIP_PLANE3 */
/*      GL_CLIP_PLANE4 */
/*      GL_CLIP_PLANE5 */
/*      GL_LIGHT0 */
/*      GL_LIGHT1 */
/*      GL_LIGHT2 */
/*      GL_LIGHT3 */
/*      GL_LIGHT4 */
/*      GL_LIGHT5 */
/*      GL_LIGHT6 */
/*      GL_LIGHT7 */
/*      GL_TEXTURE_GEN_S */
/*      GL_TEXTURE_GEN_T */
/*      GL_TEXTURE_GEN_R */
/*      GL_TEXTURE_GEN_Q */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_POINT_SMOOTH */
/*      GL_LINE_SMOOTH */
/*      GL_POLYGON_SMOOTH */
/*      GL_SCISSOR_TEST */
/*      GL_COLOR_MATERIAL */
/*      GL_NORMALIZE */
/*      GL_AUTO_NORMAL */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_POLYGON_OFFSET_POINT */
/*      GL_POLYGON_OFFSET_LINE */
/*      GL_POLYGON_OFFSET_FILL */

/* ErrorCode */
#define GL_NO_ERROR                       0
#define GL_INVALID_ENUM                   0x0500
#define GL_INVALID_VALUE                  0x0501
#define GL_INVALID_OPERATION              0x0502
#define GL_STACK_OVERFLOW                 0x0503
#define GL_STACK_UNDERFLOW                0x0504
#define GL_OUT_OF_MEMORY                  0x0505

/* FeedBackMode */
#define GL_2D                             0x0600
#define GL_3D                             0x0601
#define GL_3D_COLOR                       0x0602
#define GL_3D_COLOR_TEXTURE               0x0603
#define GL_4D_COLOR_TEXTURE               0x0604

/* FeedBackToken */
#define GL_PASS_THROUGH_TOKEN             0x0700
#define GL_POINT_TOKEN                    0x0701
#define GL_LINE_TOKEN                     0x0702
#define GL_POLYGON_TOKEN                  0x0703
#define GL_BITMAP_TOKEN                   0x0704
#define GL_DRAW_PIXEL_TOKEN               0x0705
#define GL_COPY_PIXEL_TOKEN               0x0706
#define GL_LINE_RESET_TOKEN               0x0707

/* FogMode */
/*      GL_LINEAR */
#define GL_EXP                            0x0800
#define GL_EXP2                           0x0801


/* FogParameter */
/*      GL_FOG_COLOR */
/*      GL_FOG_DENSITY */
/*      GL_FOG_END */
/*      GL_FOG_INDEX */
/*      GL_FOG_MODE */
/*      GL_FOG_START */

/* FrontFaceDirection */
#define GL_CW                             0x0900
#define GL_CCW                            0x0901

/* GetMapTarget */
#define GL_COEFF                          0x0A00
#define GL_ORDER                          0x0A01
#define GL_DOMAIN                         0x0A02

/* GetPixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* GetPointerTarget */
/*      GL_VERTEX_ARRAY_POINTER */
/*      GL_NORMAL_ARRAY_POINTER */
/*      GL_COLOR_ARRAY_POINTER */
/*      GL_INDEX_ARRAY_POINTER */
/*      GL_TEXTURE_COORD_ARRAY_POINTER */
/*      GL_EDGE_FLAG_ARRAY_POINTER */

/* GetTarget */
#define GL_CURRENT_COLOR                  0x0B00
#define GL_CURRENT_INDEX                  0x0B01
#define GL_CURRENT_NORMAL                 0x0B02
#define GL_CURRENT_TEXTURE_COORDS         0x0B03
#define GL_CURRENT_RASTER_COLOR           0x0B04
#define GL_CURRENT_RASTER_INDEX           0x0B05
#define GL_CURRENT_RASTER_TEXTURE_COORDS  0x0B06
#define GL_CURRENT_RASTER_POSITION        0x0B07
#define GL_CURRENT_RASTER_POSITION_VALID  0x0B08
#define GL_CURRENT_RASTER_DISTANCE        0x0B09
#define GL_POINT_SMOOTH                   0x0B10
#define GL_POINT_SIZE                     0x0B11
#define GL_POINT_SIZE_RANGE               0x0B12
#define GL_POINT_SIZE_GRANULARITY         0x0B13
#define GL_LINE_SMOOTH                    0x0B20
#define GL_LINE_WIDTH                     0x0B21
#define GL_LINE_WIDTH_RANGE               0x0B22
#define GL_LINE_WIDTH_GRANULARITY         0x0B23
#define GL_LINE_STIPPLE                   0x0B24
#define GL_LINE_STIPPLE_PATTERN           0x0B25
#define GL_LINE_STIPPLE_REPEAT            0x0B26
#define GL_LIST_MODE                      0x0B30
#define GL_MAX_LIST_NESTING               0x0B31
#define GL_LIST_BASE                      0x0B32
#define GL_LIST_INDEX                     0x0B33
#define GL_POLYGON_MODE                   0x0B40
#define GL_POLYGON_SMOOTH                 0x0B41
#define GL_POLYGON_STIPPLE                0x0B42
#define GL_EDGE_FLAG                      0x0B43
#define GL_CULL_FACE                      0x0B44
#define GL_CULL_FACE_MODE                 0x0B45
#define GL_FRONT_FACE                     0x0B46
#define GL_LIGHTING                       0x0B50
#define GL_LIGHT_MODEL_LOCAL_VIEWER       0x0B51
#define GL_LIGHT_MODEL_TWO_SIDE           0x0B52
#define GL_LIGHT_MODEL_AMBIENT            0x0B53
#define GL_SHADE_MODEL                    0x0B54
#define GL_COLOR_MATERIAL_FACE            0x0B55
#define GL_COLOR_MATERIAL_PARAMETER       0x0B56
#define GL_COLOR_MATERIAL                 0x0B57
#define GL_FOG                            0x0B60
#define GL_FOG_INDEX                      0x0B61
#define GL_FOG_DENSITY                    0x0B62
#define GL_FOG_START                      0x0B63
#define GL_FOG_END                        0x0B64
#define GL_FOG_MODE                       0x0B65
#define GL_FOG_COLOR                      0x0B66
#define GL_DEPTH_RANGE                    0x0B70
#define GL_DEPTH_TEST                     0x0B71
#define GL_DEPTH_WRITEMASK                0x0B72
#define GL_DEPTH_CLEAR_VALUE              0x0B73
#define GL_DEPTH_FUNC                     0x0B74
#define GL_ACCUM_CLEAR_VALUE              0x0B80
#define GL_STENCIL_TEST                   0x0B90
#define GL_STENCIL_CLEAR_VALUE            0x0B91
#define GL_STENCIL_FUNC                   0x0B92
#define GL_STENCIL_VALUE_MASK             0x0B93
#define GL_STENCIL_FAIL                   0x0B94
#define GL_STENCIL_PASS_DEPTH_FAIL        0x0B95
#define GL_STENCIL_PASS_DEPTH_PASS        0x0B96
#define GL_STENCIL_REF                    0x0B97
#define GL_STENCIL_WRITEMASK              0x0B98
#define GL_MATRIX_MODE                    0x0BA0
#define GL_NORMALIZE                      0x0BA1
#define GL_VIEWPORT                       0x0BA2
#define GL_MODELVIEW_STACK_DEPTH          0x0BA3
#define GL_PROJECTION_STACK_DEPTH         0x0BA4
#define GL_TEXTURE_STACK_DEPTH            0x0BA5
#define GL_MODELVIEW_MATRIX               0x0BA6
#define GL_PROJECTION_MATRIX              0x0BA7
#define GL_TEXTURE_MATRIX                 0x0BA8
#define GL_ATTRIB_STACK_DEPTH             0x0BB0
#define GL_CLIENT_ATTRIB_STACK_DEPTH      0x0BB1
#define GL_ALPHA_TEST                     0x0BC0
#define GL_ALPHA_TEST_FUNC                0x0BC1
#define GL_ALPHA_TEST_REF                 0x0BC2
#define GL_DITHER                         0x0BD0
#define GL_BLEND_DST                      0x0BE0
#define GL_BLEND_SRC                      0x0BE1
#define GL_BLEND                          0x0BE2
#define GL_LOGIC_OP_MODE                  0x0BF0
#define GL_INDEX_LOGIC_OP                 0x0BF1
#define GL_COLOR_LOGIC_OP                 0x0BF2
#define GL_AUX_BUFFERS                    0x0C00
#define GL_DRAW_BUFFER                    0x0C01
#define GL_READ_BUFFER                    0x0C02
#define GL_SCISSOR_BOX                    0x0C10
#define GL_SCISSOR_TEST                   0x0C11
#define GL_INDEX_CLEAR_VALUE              0x0C20
#define GL_INDEX_WRITEMASK                0x0C21
#define GL_COLOR_CLEAR_VALUE              0x0C22
#define GL_COLOR_WRITEMASK                0x0C23
#define GL_INDEX_MODE                     0x0C30
#define GL_RGBA_MODE                      0x0C31
#define GL_DOUBLEBUFFER                   0x0C32
#define GL_STEREO                         0x0C33
#define GL_RENDER_MODE                    0x0C40
#define GL_PERSPECTIVE_CORRECTION_HINT    0x0C50
#define GL_POINT_SMOOTH_HINT              0x0C51
#define GL_LINE_SMOOTH_HINT               0x0C52
#define GL_POLYGON_SMOOTH_HINT            0x0C53
#define GL_FOG_HINT                       0x0C54
#define GL_TEXTURE_GEN_S                  0x0C60
#define GL_TEXTURE_GEN_T                  0x0C61
#define GL_TEXTURE_GEN_R                  0x0C62
#define GL_TEXTURE_GEN_Q                  0x0C63
#define GL_PIXEL_MAP_I_TO_I               0x0C70
#define GL_PIXEL_MAP_S_TO_S               0x0C71
#define GL_PIXEL_MAP_I_TO_R               0x0C72
#define GL_PIXEL_MAP_I_TO_G               0x0C73
#define GL_PIXEL_MAP_I_TO_B               0x0C74
#define GL_PIXEL_MAP_I_TO_A               0x0C75
#define GL_PIXEL_MAP_R_TO_R               0x0C76
#define GL_PIXEL_MAP_G_TO_G               0x0C77
#define GL_PIXEL_MAP_B_TO_B               0x0C78
#define GL_PIXEL_MAP_A_TO_A               0x0C79
#define GL_PIXEL_MAP_I_TO_I_SIZE          0x0CB0
#define GL_PIXEL_MAP_S_TO_S_SIZE          0x0CB1
#define GL_PIXEL_MAP_I_TO_R_SIZE          0x0CB2
#define GL_PIXEL_MAP_I_TO_G_SIZE          0x0CB3
#define GL_PIXEL_MAP_I_TO_B_SIZE          0x0CB4
#define GL_PIXEL_MAP_I_TO_A_SIZE          0x0CB5
#define GL_PIXEL_MAP_R_TO_R_SIZE          0x0CB6
#define GL_PIXEL_MAP_G_TO_G_SIZE          0x0CB7
#define GL_PIXEL_MAP_B_TO_B_SIZE          0x0CB8
#define GL_PIXEL_MAP_A_TO_A_SIZE          0x0CB9
#define GL_UNPACK_SWAP_BYTES              0x0CF0
#define GL_UNPACK_LSB_FIRST               0x0CF1
#define GL_UNPACK_ROW_LENGTH              0x0CF2
#define GL_UNPACK_SKIP_ROWS               0x0CF3
#define GL_UNPACK_SKIP_PIXELS             0x0CF4
#define GL_UNPACK_ALIGNMENT               0x0CF5
#define GL_PACK_SWAP_BYTES                0x0D00
#define GL_PACK_LSB_FIRST                 0x0D01
#define GL_PACK_ROW_LENGTH                0x0D02
#define GL_PACK_SKIP_ROWS                 0x0D03
#define GL_PACK_SKIP_PIXELS               0x0D04
#define GL_PACK_ALIGNMENT                 0x0D05
#define GL_MAP_COLOR                      0x0D10
#define GL_MAP_STENCIL                    0x0D11
#define GL_INDEX_SHIFT                    0x0D12
#define GL_INDEX_OFFSET                   0x0D13
#define GL_RED_SCALE                      0x0D14
#define GL_RED_BIAS                       0x0D15
#define GL_ZOOM_X                         0x0D16
#define GL_ZOOM_Y                         0x0D17
#define GL_GREEN_SCALE                    0x0D18
#define GL_GREEN_BIAS                     0x0D19
#define GL_BLUE_SCALE                     0x0D1A
#define GL_BLUE_BIAS                      0x0D1B
#define GL_ALPHA_SCALE                    0x0D1C
#define GL_ALPHA_BIAS                     0x0D1D
#define GL_DEPTH_SCALE                    0x0D1E
#define GL_DEPTH_BIAS                     0x0D1F
#define GL_MAX_EVAL_ORDER                 0x0D30
#define GL_MAX_LIGHTS                     0x0D31
#define GL_MAX_CLIP_PLANES                0x0D32
#define GL_MAX_TEXTURE_SIZE               0x0D33
#define GL_MAX_PIXEL_MAP_TABLE            0x0D34
#define GL_MAX_ATTRIB_STACK_DEPTH         0x0D35
#define GL_MAX_MODELVIEW_STACK_DEPTH      0x0D36
#define GL_MAX_NAME_STACK_DEPTH           0x0D37
#define GL_MAX_PROJECTION_STACK_DEPTH     0x0D38
#define GL_MAX_TEXTURE_STACK_DEPTH        0x0D39
#define GL_MAX_VIEWPORT_DIMS              0x0D3A
#define GL_MAX_CLIENT_ATTRIB_STACK_DEPTH  0x0D3B
#define GL_SUBPIXEL_BITS                  0x0D50
#define GL_INDEX_BITS                     0x0D51
#define GL_RED_BITS                       0x0D52
#define GL_GREEN_BITS                     0x0D53
#define GL_BLUE_BITS                      0x0D54
#define GL_ALPHA_BITS                     0x0D55
#define GL_DEPTH_BITS                     0x0D56
#define GL_STENCIL_BITS                   0x0D57
#define GL_ACCUM_RED_BITS                 0x0D58
#define GL_ACCUM_GREEN_BITS               0x0D59
#define GL_ACCUM_BLUE_BITS                0x0D5A
#define GL_ACCUM_ALPHA_BITS               0x0D5B
#define GL_NAME_STACK_DEPTH               0x0D70
#define GL_AUTO_NORMAL                    0x0D80
#define GL_MAP1_COLOR_4                   0x0D90
#define GL_MAP1_INDEX                     0x0D91
#define GL_MAP1_NORMAL                    0x0D92
#define GL_MAP1_TEXTURE_COORD_1           0x0D93
#define GL_MAP1_TEXTURE_COORD_2           0x0D94
#define GL_MAP1_TEXTURE_COORD_3           0x0D95
#define GL_MAP1_TEXTURE_COORD_4           0x0D96
#define GL_MAP1_VERTEX_3                  0x0D97
#define GL_MAP1_VERTEX_4                  0x0D98
#define GL_MAP2_COLOR_4                   0x0DB0
#define GL_MAP2_INDEX                     0x0DB1
#define GL_MAP2_NORMAL                    0x0DB2
#define GL_MAP2_TEXTURE_COORD_1           0x0DB3
#define GL_MAP2_TEXTURE_COORD_2           0x0DB4
#define GL_MAP2_TEXTURE_COORD_3           0x0DB5
#define GL_MAP2_TEXTURE_COORD_4           0x0DB6
#define GL_MAP2_VERTEX_3                  0x0DB7
#define GL_MAP2_VERTEX_4                  0x0DB8
#define GL_MAP1_GRID_DOMAIN               0x0DD0
#define GL_MAP1_GRID_SEGMENTS             0x0DD1
#define GL_MAP2_GRID_DOMAIN               0x0DD2
#define GL_MAP2_GRID_SEGMENTS             0x0DD3
#define GL_TEXTURE_1D                     0x0DE0
#define GL_TEXTURE_2D                     0x0DE1
#define GL_FEEDBACK_BUFFER_POINTER        0x0DF0
#define GL_FEEDBACK_BUFFER_SIZE           0x0DF1
#define GL_FEEDBACK_BUFFER_TYPE           0x0DF2
#define GL_SELECTION_BUFFER_POINTER       0x0DF3
#define GL_SELECTION_BUFFER_SIZE          0x0DF4
/*      GL_TEXTURE_BINDING_1D */
/*      GL_TEXTURE_BINDING_2D */
/*      GL_VERTEX_ARRAY */
/*      GL_NORMAL_ARRAY */
/*      GL_COLOR_ARRAY */
/*      GL_INDEX_ARRAY */
/*      GL_TEXTURE_COORD_ARRAY */
/*      GL_EDGE_FLAG_ARRAY */
/*      GL_VERTEX_ARRAY_SIZE */
/*      GL_VERTEX_ARRAY_TYPE */
/*      GL_VERTEX_ARRAY_STRIDE */
/*      GL_NORMAL_ARRAY_TYPE */
/*      GL_NORMAL_ARRAY_STRIDE */
/*      GL_COLOR_ARRAY_SIZE */
/*      GL_COLOR_ARRAY_TYPE */
/*      GL_COLOR_ARRAY_STRIDE */
/*      GL_INDEX_ARRAY_TYPE */
/*      GL_INDEX_ARRAY_STRIDE */
/*      GL_TEXTURE_COORD_ARRAY_SIZE */
/*      GL_TEXTURE_COORD_ARRAY_TYPE */
/*      GL_TEXTURE_COORD_ARRAY_STRIDE */
/*      GL_EDGE_FLAG_ARRAY_STRIDE */
/*      GL_POLYGON_OFFSET_FACTOR */
/*      GL_POLYGON_OFFSET_UNITS */

/* GetTextureParameter */
/*      GL_TEXTURE_MAG_FILTER */
/*      GL_TEXTURE_MIN_FILTER */
/*      GL_TEXTURE_WRAP_S */
/*      GL_TEXTURE_WRAP_T */
#define GL_TEXTURE_WIDTH                  0x1000
#define GL_TEXTURE_HEIGHT                 0x1001
#define GL_TEXTURE_INTERNAL_FORMAT        0x1003
#define GL_TEXTURE_BORDER_COLOR           0x1004
#define GL_TEXTURE_BORDER                 0x1005
/*      GL_TEXTURE_RED_SIZE */
/*      GL_TEXTURE_GREEN_SIZE */
/*      GL_TEXTURE_BLUE_SIZE */
/*      GL_TEXTURE_ALPHA_SIZE */
/*      GL_TEXTURE_LUMINANCE_SIZE */
/*      GL_TEXTURE_INTENSITY_SIZE */
/*      GL_TEXTURE_PRIORITY */
/*      GL_TEXTURE_RESIDENT */

/* HintMode */
#define GL_DONT_CARE                      0x1100
#define GL_FASTEST                        0x1101
#define GL_NICEST                         0x1102

/* HintTarget */
/*      GL_PERSPECTIVE_CORRECTION_HINT */
/*      GL_POINT_SMOOTH_HINT */
/*      GL_LINE_SMOOTH_HINT */
/*      GL_POLYGON_SMOOTH_HINT */
/*      GL_FOG_HINT */
/*      GL_PHONG_HINT */

/* IndexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* LightModelParameter */
/*      GL_LIGHT_MODEL_AMBIENT */
/*      GL_LIGHT_MODEL_LOCAL_VIEWER */
/*      GL_LIGHT_MODEL_TWO_SIDE */

/* LightName */
#define GL_LIGHT0                         0x4000
#define GL_LIGHT1                         0x4001
#define GL_LIGHT2                         0x4002
#define GL_LIGHT3                         0x4003
#define GL_LIGHT4                         0x4004
#define GL_LIGHT5                         0x4005
#define GL_LIGHT6                         0x4006
#define GL_LIGHT7                         0x4007

/* LightParameter */
#define GL_AMBIENT                        0x1200
#define GL_DIFFUSE                        0x1201
#define GL_SPECULAR                       0x1202
#define GL_POSITION                       0x1203
#define GL_SPOT_DIRECTION                 0x1204
#define GL_SPOT_EXPONENT                  0x1205
#define GL_SPOT_CUTOFF                    0x1206
#define GL_CONSTANT_ATTENUATION           0x1207
#define GL_LINEAR_ATTENUATION             0x1208
#define GL_QUADRATIC_ATTENUATION          0x1209

/* InterleavedArrays */
/*      GL_V2F */
/*      GL_V3F */
/*      GL_C4UB_V2F */
/*      GL_C4UB_V3F */
/*      GL_C3F_V3F */
/*      GL_N3F_V3F */
/*      GL_C4F_N3F_V3F */
/*      GL_T2F_V3F */
/*      GL_T4F_V4F */
/*      GL_T2F_C4UB_V3F */
/*      GL_T2F_C3F_V3F */
/*      GL_T2F_N3F_V3F */
/*      GL_T2F_C4F_N3F_V3F */
/*      GL_T4F_C4F_N3F_V4F */

/* ListMode */
#define GL_COMPILE                        0x1300
#define GL_COMPILE_AND_EXECUTE            0x1301

/* ListNameType */
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */
/*      GL_2_BYTES */
/*      GL_3_BYTES */
/*      GL_4_BYTES */

/* LogicOp */
#define GL_CLEAR                          0x1500
#define GL_AND                            0x1501
#define GL_AND_REVERSE                    0x1502
#define GL_COPY                           0x1503
#define GL_AND_INVERTED                   0x1504
#define GL_NOOP                           0x1505
#define GL_XOR                            0x1506
#define GL_OR                             0x1507
#define GL_NOR                            0x1508
#define GL_EQUIV                          0x1509
#define GL_INVERT                         0x150A
#define GL_OR_REVERSE                     0x150B
#define GL_COPY_INVERTED                  0x150C
#define GL_OR_INVERTED                    0x150D
#define GL_NAND                           0x150E
#define GL_SET                            0x150F

/* MapTarget */
/*      GL_MAP1_COLOR_4 */
/*      GL_MAP1_INDEX */
/*      GL_MAP1_NORMAL */
/*      GL_MAP1_TEXTURE_COORD_1 */
/*      GL_MAP1_TEXTURE_COORD_2 */
/*      GL_MAP1_TEXTURE_COORD_3 */
/*      GL_MAP1_TEXTURE_COORD_4 */
/*      GL_MAP1_VERTEX_3 */
/*      GL_MAP1_VERTEX_4 */
/*      GL_MAP2_COLOR_4 */
/*      GL_MAP2_INDEX */
/*      GL_MAP2_NORMAL */
/*      GL_MAP2_TEXTURE_COORD_1 */
/*      GL_MAP2_TEXTURE_COORD_2 */
/*      GL_MAP2_TEXTURE_COORD_3 */
/*      GL_MAP2_TEXTURE_COORD_4 */
/*      GL_MAP2_VERTEX_3 */
/*      GL_MAP2_VERTEX_4 */

/* MaterialFace */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_FRONT_AND_BACK */

/* MaterialParameter */
#define GL_EMISSION                       0x1600
#define GL_SHININESS                      0x1601
#define GL_AMBIENT_AND_DIFFUSE            0x1602
#define GL_COLOR_INDEXES                  0x1603
/*      GL_AMBIENT */
/*      GL_DIFFUSE */
/*      GL_SPECULAR */

/* MatrixMode */
#define GL_MODELVIEW                      0x1700
#define GL_PROJECTION                     0x1701
#define GL_TEXTURE                        0x1702

/* MeshMode1 */
/*      GL_POINT */
/*      GL_LINE */

/* MeshMode2 */
/*      GL_POINT */
/*      GL_LINE */
/*      GL_FILL */

/* NormalPointerType */
/*      GL_BYTE */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* PixelCopyType */
#define GL_COLOR                          0x1800
#define GL_DEPTH                          0x1801
#define GL_STENCIL                        0x1802

/* PixelFormat */
#define GL_COLOR_INDEX                    0x1900
#define GL_STENCIL_INDEX                  0x1901
#define GL_DEPTH_COMPONENT                0x1902
#define GL_RED                            0x1903
#define GL_GREEN                          0x1904
#define GL_BLUE                           0x1905
#define GL_ALPHA                          0x1906
#define GL_RGB                            0x1907
#define GL_RGBA                           0x1908
#define GL_LUMINANCE                      0x1909
#define GL_LUMINANCE_ALPHA                0x190A

/* PixelMap */
/*      GL_PIXEL_MAP_I_TO_I */
/*      GL_PIXEL_MAP_S_TO_S */
/*      GL_PIXEL_MAP_I_TO_R */
/*      GL_PIXEL_MAP_I_TO_G */
/*      GL_PIXEL_MAP_I_TO_B */
/*      GL_PIXEL_MAP_I_TO_A */
/*      GL_PIXEL_MAP_R_TO_R */
/*      GL_PIXEL_MAP_G_TO_G */
/*      GL_PIXEL_MAP_B_TO_B */
/*      GL_PIXEL_MAP_A_TO_A */

/* PixelStore */
/*      GL_UNPACK_SWAP_BYTES */
/*      GL_UNPACK_LSB_FIRST */
/*      GL_UNPACK_ROW_LENGTH */
/*      GL_UNPACK_SKIP_ROWS */
/*      GL_UNPACK_SKIP_PIXELS */
/*      GL_UNPACK_ALIGNMENT */
/*      GL_PACK_SWAP_BYTES */
/*      GL_PACK_LSB_FIRST */
/*      GL_PACK_ROW_LENGTH */
/*      GL_PACK_SKIP_ROWS */
/*      GL_PACK_SKIP_PIXELS */
/*      GL_PACK_ALIGNMENT */

/* PixelTransfer */
/*      GL_MAP_COLOR */
/*      GL_MAP_STENCIL */
/*      GL_INDEX_SHIFT */
/*      GL_INDEX_OFFSET */
/*      GL_RED_SCALE */
/*      GL_RED_BIAS */
/*      GL_GREEN_SCALE */
/*      GL_GREEN_BIAS */
/*      GL_BLUE_SCALE */
/*      GL_BLUE_BIAS */
/*      GL_ALPHA_SCALE */
/*      GL_ALPHA_BIAS */
/*      GL_DEPTH_SCALE */
/*      GL_DEPTH_BIAS */

/* PixelType */
#define GL_BITMAP                         0x1A00
/*      GL_BYTE */
/*      GL_UNSIGNED_BYTE */
/*      GL_SHORT */
/*      GL_UNSIGNED_SHORT */
/*      GL_INT */
/*      GL_UNSIGNED_INT */
/*      GL_FLOAT */

/* PolygonMode */
#define GL_POINT                          0x1B00
#define GL_LINE                           0x1B01
#define GL_FILL                           0x1B02

/* ReadBufferMode */
/*      GL_FRONT_LEFT */
/*      GL_FRONT_RIGHT */
/*      GL_BACK_LEFT */
/*      GL_BACK_RIGHT */
/*      GL_FRONT */
/*      GL_BACK */
/*      GL_LEFT */
/*      GL_RIGHT */
/*      GL_AUX0 */
/*      GL_AUX1 */
/*      GL_AUX2 */
/*      GL_AUX3 */

/* RenderingMode */
#define GL_RENDER                         0x1C00
#define GL_FEEDBACK                       0x1C01
#define GL_SELECT                         0x1C02

/* ShadingModel */
#define GL_FLAT                           0x1D00
#define GL_SMOOTH                         0x1D01


/* StencilFunction */
/*      GL_NEVER */
/*      GL_LESS */
/*      GL_EQUAL */
/*      GL_LEQUAL */
/*      GL_GREATER */
/*      GL_NOTEQUAL */
/*      GL_GEQUAL */
/*      GL_ALWAYS */

/* StencilOp */
/*      GL_ZERO */
#define GL_KEEP                           0x1E00
#define GL_REPLACE                        0x1E01
#define GL_INCR                           0x1E02
#define GL_DECR                           0x1E03
/*      GL_INVERT */

/* StringName */
#define GL_VENDOR                         0x1F00
#define GL_RENDERER                       0x1F01
#define GL_VERSION                        0x1F02
#define GL_EXTENSIONS                     0x1F03

/* TextureCoordName */
#define GL_S                              0x2000
#define GL_T                              0x2001
#define GL_R                              0x2002
#define GL_Q                              0x2003

/* TexCoordPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* TextureEnvMode */
#define GL_MODULATE                       0x2100
#define GL_DECAL                          0x2101
/*      GL_BLEND */
/*      GL_REPLACE */

/* TextureEnvParameter */
#define GL_TEXTURE_ENV_MODE               0x2200
#define GL_TEXTURE_ENV_COLOR              0x2201

/* TextureEnvTarget */
#define GL_TEXTURE_ENV                    0x2300

/* TextureGenMode */
#define GL_EYE_LINEAR                     0x2400
#define GL_OBJECT_LINEAR                  0x2401
#define GL_SPHERE_MAP                     0x2402

/* TextureGenParameter */
#define GL_TEXTURE_GEN_MODE               0x2500
#define GL_OBJECT_PLANE                   0x2501
#define GL_EYE_PLANE                      0x2502

/* TextureMagFilter */
#define GL_NEAREST                        0x2600
#define GL_LINEAR                         0x2601

/* TextureMinFilter */
/*      GL_NEAREST */
/*      GL_LINEAR */
#define GL_NEAREST_MIPMAP_NEAREST         0x2700
#define GL_LINEAR_MIPMAP_NEAREST          0x2701
#define GL_NEAREST_MIPMAP_LINEAR          0x2702
#define GL_LINEAR_MIPMAP_LINEAR           0x2703

/* TextureParameterName */
#define GL_TEXTURE_MAG_FILTER             0x2800
#define GL_TEXTURE_MIN_FILTER             0x2801
#define GL_TEXTURE_WRAP_S                 0x2802
#define GL_TEXTURE_WRAP_T                 0x2803
/*      GL_TEXTURE_BORDER_COLOR */
/*      GL_TEXTURE_PRIORITY */

/* TextureTarget */
/*      GL_TEXTURE_1D */
/*      GL_TEXTURE_2D */
/*      GL_PROXY_TEXTURE_1D */
/*      GL_PROXY_TEXTURE_2D */

/* TextureWrapMode */
#define GL_CLAMP                          0x2900
#define GL_REPEAT                         0x2901

/* VertexPointerType */
/*      GL_SHORT */
/*      GL_INT */
/*      GL_FLOAT */
/*      GL_DOUBLE */

/* ClientAttribMask */
#define GL_CLIENT_PIXEL_STORE_BIT         0x00000001
#define GL_CLIENT_VERTEX_ARRAY_BIT        0x00000002
#define GL_CLIENT_ALL_ATTRIB_BITS         0xffffffff

/* polygon_offset */
#define GL_POLYGON_OFFSET_FACTOR          0x8038
#define GL_POLYGON_OFFSET_UNITS           0x2A00
#define GL_POLYGON_OFFSET_POINT           0x2A01
#define GL_POLYGON_OFFSET_LINE            0x2A02
#define GL_POLYGON_OFFSET_FILL            0x8037

/* texture */
#define GL_ALPHA4                         0x803B
#define GL_ALPHA8                         0x803C
#define GL_ALPHA12                        0x803D
#define GL_ALPHA16                        0x803E
#define GL_LUMINANCE4                     0x803F
#define GL_LUMINANCE8                     0x8040
#define GL_LUMINANCE12                    0x8041
#define GL_LUMINANCE16                    0x8042
#define GL_LUMINANCE4_ALPHA4              0x8043
#define GL_LUMINANCE6_ALPHA2              0x8044
#define GL_LUMINANCE8_ALPHA8              0x8045
#define GL_LUMINANCE12_ALPHA4             0x8046
#define GL_LUMINANCE12_ALPHA12            0x8047
#define GL_LUMINANCE16_ALPHA16            0x8048
#define GL_INTENSITY                      0x8049
#define GL_INTENSITY4                     0x804A
#define GL_INTENSITY8                     0x804B
#define GL_INTENSITY12                    0x804C
#define GL_INTENSITY16                    0x804D
#define GL_R3_G3_B2                       0x2A10
#define GL_RGB4                           0x804F
#define GL_RGB5                           0x8050
#define GL_RGB8                           0x8051
#define GL_RGB10                          0x8052
#define GL_RGB12                          0x8053
#define GL_RGB16                          0x8054
#define GL_RGBA2                          0x8055
#define GL_RGBA4                          0x8056
#define GL_RGB5_A1                        0x8057
#define GL_RGBA8                          0x8058
#define GL_RGB10_A2                       0x8059
#define GL_RGBA12                         0x805A
#define GL_RGBA16                         0x805B
#define GL_TEXTURE_RED_SIZE               0x805C
#define GL_TEXTURE_GREEN_SIZE             0x805D
#define GL_TEXTURE_BLUE_SIZE              0x805E
#define GL_TEXTURE_ALPHA_SIZE             0x805F
#define GL_TEXTURE_LUMINANCE_SIZE         0x8060
#define GL_TEXTURE_INTENSITY_SIZE         0x8061
#define GL_PROXY_TEXTURE_1D               0x8063
#define GL_PROXY_TEXTURE_2D               0x8064

/* texture_object */
#define GL_TEXTURE_PRIORITY               0x8066
#define GL_TEXTURE_RESIDENT               0x8067
#define GL_TEXTURE_BINDING_1D             0x8068
#define GL_TEXTURE_BINDING_2D             0x8069

/* vertex_array */
#define GL_VERTEX_ARRAY                   0x8074
#define GL_NORMAL_ARRAY                   0x8075
#define GL_COLOR_ARRAY                    0x8076
#define GL_INDEX_ARRAY                    0x8077
#define GL_TEXTURE_COORD_ARRAY            0x8078
#define GL_EDGE_FLAG_ARRAY                0x8079
#define GL_VERTEX_ARRAY_SIZE              0x807A
#define GL_VERTEX_ARRAY_TYPE              0x807B
#define GL_VERTEX_ARRAY_STRIDE            0x807C
#define GL_NORMAL_ARRAY_TYPE              0x807E
#define GL_NORMAL_ARRAY_STRIDE            0x807F
#define GL_COLOR_ARRAY_SIZE               0x8081
#define GL_COLOR_ARRAY_TYPE               0x8082
#define GL_COLOR_ARRAY_STRIDE             0x8083
#define GL_INDEX_ARRAY_TYPE               0x8085
#define GL_INDEX_ARRAY_STRIDE             0x8086
#define GL_TEXTURE_COORD_ARRAY_SIZE       0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE       0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE     0x808A
#define GL_EDGE_FLAG_ARRAY_STRIDE         0x808C
#define GL_VERTEX_ARRAY_POINTER           0x808E
#define GL_NORMAL_ARRAY_POINTER           0x808F
#define GL_COLOR_ARRAY_POINTER            0x8090
#define GL_INDEX_ARRAY_POINTER            0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER    0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER        0x8093
#define GL_V2F                            0x2A20
#define GL_V3F                            0x2A21
#define GL_C4UB_V2F                       0x2A22
#define GL_C4UB_V3F                       0x2A23
#define GL_C3F_V3F                        0x2A24
#define GL_N3F_V3F                        0x2A25
#define GL_C4F_N3F_V3F                    0x2A26
#define GL_T2F_V3F                        0x2A27
#define GL_T4F_V4F                        0x2A28
#define GL_T2F_C4UB_V3F                   0x2A29
#define GL_T2F_C3F_V3F                    0x2A2A
#define GL_T2F_N3F_V3F                    0x2A2B
#define GL_T2F_C4F_N3F_V3F                0x2A2C
#define GL_T4F_C4F_N3F_V4F                0x2A2D

/* Extensions */
#define GL_EXT_vertex_array               1
#define GL_EXT_bgra                       1
#define GL_EXT_paletted_texture           1
#define GL_WIN_swap_hint                  1
#define GL_WIN_draw_range_elements        1
// #define GL_WIN_phong_shading              1
// #define GL_WIN_specular_fog               1

/* EXT_vertex_array */
#define GL_VERTEX_ARRAY_EXT               0x8074
#define GL_NORMAL_ARRAY_EXT               0x8075
#define GL_COLOR_ARRAY_EXT                0x8076
#define GL_INDEX_ARRAY_EXT                0x8077
#define GL_TEXTURE_COORD_ARRAY_EXT        0x8078
#define GL_EDGE_FLAG_ARRAY_EXT            0x8079
#define GL_VERTEX_ARRAY_SIZE_EXT          0x807A
#define GL_VERTEX_ARRAY_TYPE_EXT          0x807B
#define GL_VERTEX_ARRAY_STRIDE_EXT        0x807C
#define GL_VERTEX_ARRAY_COUNT_EXT         0x807D
#define GL_NORMAL_ARRAY_TYPE_EXT          0x807E
#define GL_NORMAL_ARRAY_STRIDE_EXT        0x807F
#define GL_NORMAL_ARRAY_COUNT_EXT         0x8080
#define GL_COLOR_ARRAY_SIZE_EXT           0x8081
#define GL_COLOR_ARRAY_TYPE_EXT           0x8082
#define GL_COLOR_ARRAY_STRIDE_EXT         0x8083
#define GL_COLOR_ARRAY_COUNT_EXT          0x8084
#define GL_INDEX_ARRAY_TYPE_EXT           0x8085
#define GL_INDEX_ARRAY_STRIDE_EXT         0x8086
#define GL_INDEX_ARRAY_COUNT_EXT          0x8087
#define GL_TEXTURE_COORD_ARRAY_SIZE_EXT   0x8088
#define GL_TEXTURE_COORD_ARRAY_TYPE_EXT   0x8089
#define GL_TEXTURE_COORD_ARRAY_STRIDE_EXT 0x808A
#define GL_TEXTURE_COORD_ARRAY_COUNT_EXT  0x808B
#define GL_EDGE_FLAG_ARRAY_STRIDE_EXT     0x808C
#define GL_EDGE_FLAG_ARRAY_COUNT_EXT      0x808D
#define GL_VERTEX_ARRAY_POINTER_EXT       0x808E
#define GL_NORMAL_ARRAY_POINTER_EXT       0x808F
#define GL_COLOR_ARRAY_POINTER_EXT        0x8090
#define GL_INDEX_ARRAY_POINTER_EXT        0x8091
#define GL_TEXTURE_COORD_ARRAY_POINTER_EXT 0x8092
#define GL_EDGE_FLAG_ARRAY_POINTER_EXT    0x8093
#define GL_DOUBLE_EXT                     GL_DOUBLE

/* EXT_bgra */
#define GL_BGR_EXT                        0x80E0
#define GL_BGRA_EXT                       0x80E1

/* EXT_paletted_texture */

/* These must match the GL_COLOR_TABLE_*_SGI enumerants */
#define GL_COLOR_TABLE_FORMAT_EXT         0x80D8
#define GL_COLOR_TABLE_WIDTH_EXT          0x80D9
#define GL_COLOR_TABLE_RED_SIZE_EXT       0x80DA
#define GL_COLOR_TABLE_GREEN_SIZE_EXT     0x80DB
#define GL_COLOR_TABLE_BLUE_SIZE_EXT      0x80DC
#define GL_COLOR_TABLE_ALPHA_SIZE_EXT     0x80DD
#define GL_COLOR_TABLE_LUMINANCE_SIZE_EXT 0x80DE
#define GL_COLOR_TABLE_INTENSITY_SIZE_EXT 0x80DF

#define GL_COLOR_INDEX1_EXT               0x80E2
#define GL_COLOR_INDEX2_EXT               0x80E3
#define GL_COLOR_INDEX4_EXT               0x80E4
#define GL_COLOR_INDEX8_EXT               0x80E5
#define GL_COLOR_INDEX12_EXT              0x80E6
#define GL_COLOR_INDEX16_EXT              0x80E7

/* WIN_draw_range_elements */
#define GL_MAX_ELEMENTS_VERTICES_WIN      0x80E8
#define GL_MAX_ELEMENTS_INDICES_WIN       0x80E9

/* WIN_phong_shading */
#define GL_PHONG_WIN                      0x80EA 
#define GL_PHONG_HINT_WIN                 0x80EB 

/* WIN_specular_fog */
#define GL_FOG_SPECULAR_TEXTURE_WIN       0x80EC

/* For compatibility with OpenGL v1.0 */
#define GL_LOGIC_OP GL_INDEX_LOGIC_OP
#define GL_TEXTURE_COMPONENTS GL_TEXTURE_INTERNAL_FORMAT

/*************************************************************/

#ifdef WINGDIAPI
#undef WINGDIAPI
#endif
#define WINGDIAPI

WINGDIAPI void APIENTRY glAccum (GLenum op, GLfloat value);
WINGDIAPI void APIENTRY glAlphaFunc (GLenum func, GLclampf ref);
WINGDIAPI GLboolean APIENTRY glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
WINGDIAPI void APIENTRY glArrayElement (GLint i);
WINGDIAPI void APIENTRY glBegin (GLenum mode);
WINGDIAPI void APIENTRY glBindTexture (GLenum target, GLuint texture);
WINGDIAPI void APIENTRY glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
WINGDIAPI void APIENTRY glBlendFunc (GLenum sfactor, GLenum dfactor);
WINGDIAPI void APIENTRY glCallList (GLuint list);
WINGDIAPI void APIENTRY glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
WINGDIAPI void APIENTRY glClear (GLbitfield mask);
WINGDIAPI void APIENTRY glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
WINGDIAPI void APIENTRY glClearDepth (GLclampd depth);
WINGDIAPI void APIENTRY glClearIndex (GLfloat c);
WINGDIAPI void APIENTRY glClearStencil (GLint s);
WINGDIAPI void APIENTRY glClipPlane (GLenum plane, const GLdouble *equation);
WINGDIAPI void APIENTRY glColor3b (GLbyte red, GLbyte green, GLbyte blue);
WINGDIAPI void APIENTRY glColor3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor3d (GLdouble red, GLdouble green, GLdouble blue);
WINGDIAPI void APIENTRY glColor3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor3f (GLfloat red, GLfloat green, GLfloat blue);
WINGDIAPI void APIENTRY glColor3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor3i (GLint red, GLint green, GLint blue);
WINGDIAPI void APIENTRY glColor3iv (const GLint *v);
WINGDIAPI void APIENTRY glColor3s (GLshort red, GLshort green, GLshort blue);
WINGDIAPI void APIENTRY glColor3sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
WINGDIAPI void APIENTRY glColor3ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor3ui (GLuint red, GLuint green, GLuint blue);
WINGDIAPI void APIENTRY glColor3uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor3us (GLushort red, GLushort green, GLushort blue);
WINGDIAPI void APIENTRY glColor3usv (const GLushort *v);
WINGDIAPI void APIENTRY glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
WINGDIAPI void APIENTRY glColor4bv (const GLbyte *v);
WINGDIAPI void APIENTRY glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
WINGDIAPI void APIENTRY glColor4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
WINGDIAPI void APIENTRY glColor4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
WINGDIAPI void APIENTRY glColor4iv (const GLint *v);
WINGDIAPI void APIENTRY glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
WINGDIAPI void APIENTRY glColor4sv (const GLshort *v);
WINGDIAPI void APIENTRY glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
WINGDIAPI void APIENTRY glColor4ubv (const GLubyte *v);
WINGDIAPI void APIENTRY glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
WINGDIAPI void APIENTRY glColor4uiv (const GLuint *v);
WINGDIAPI void APIENTRY glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
WINGDIAPI void APIENTRY glColor4usv (const GLushort *v);
WINGDIAPI void APIENTRY glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
WINGDIAPI void APIENTRY glColorMaterial (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
WINGDIAPI void APIENTRY glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
WINGDIAPI void APIENTRY glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
WINGDIAPI void APIENTRY glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
WINGDIAPI void APIENTRY glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glCullFace (GLenum mode);
WINGDIAPI void APIENTRY glDeleteLists (GLuint list, GLsizei range);
WINGDIAPI void APIENTRY glDeleteTextures (GLsizei n, const GLuint *textures);
WINGDIAPI void APIENTRY glDepthFunc (GLenum func);
WINGDIAPI void APIENTRY glDepthMask (GLboolean flag);
WINGDIAPI void APIENTRY glDepthRange (GLclampd zNear, GLclampd zFar);
WINGDIAPI void APIENTRY glDisable (GLenum cap);
WINGDIAPI void APIENTRY glDisableClientState (GLenum array);
WINGDIAPI void APIENTRY glDrawArrays (GLenum mode, GLint first, GLsizei count);
WINGDIAPI void APIENTRY glDrawBuffer (GLenum mode);
WINGDIAPI void APIENTRY glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
WINGDIAPI void APIENTRY glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glEdgeFlag (GLboolean flag);
WINGDIAPI void APIENTRY glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glEdgeFlagv (const GLboolean *flag);
WINGDIAPI void APIENTRY glEnable (GLenum cap);
WINGDIAPI void APIENTRY glEnableClientState (GLenum array);
WINGDIAPI void APIENTRY glEnd (void);
WINGDIAPI void APIENTRY glEndList (void);
WINGDIAPI void APIENTRY glEvalCoord1d (GLdouble u);
WINGDIAPI void APIENTRY glEvalCoord1dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord1f (GLfloat u);
WINGDIAPI void APIENTRY glEvalCoord1fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalCoord2d (GLdouble u, GLdouble v);
WINGDIAPI void APIENTRY glEvalCoord2dv (const GLdouble *u);
WINGDIAPI void APIENTRY glEvalCoord2f (GLfloat u, GLfloat v);
WINGDIAPI void APIENTRY glEvalCoord2fv (const GLfloat *u);
WINGDIAPI void APIENTRY glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
WINGDIAPI void APIENTRY glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
WINGDIAPI void APIENTRY glEvalPoint1 (GLint i);
WINGDIAPI void APIENTRY glEvalPoint2 (GLint i, GLint j);
WINGDIAPI void APIENTRY glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
WINGDIAPI void APIENTRY glFinish (void);
WINGDIAPI void APIENTRY glFlush (void);
WINGDIAPI void APIENTRY glFogf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glFogfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glFogi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glFogiv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glFrontFace (GLenum mode);
WINGDIAPI void APIENTRY glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI GLuint APIENTRY glGenLists (GLsizei range);
WINGDIAPI void APIENTRY glGenTextures (GLsizei n, GLuint *textures);
WINGDIAPI void APIENTRY glGetBooleanv (GLenum pname, GLboolean *params);
WINGDIAPI void APIENTRY glGetClipPlane (GLenum plane, GLdouble *equation);
WINGDIAPI void APIENTRY glGetDoublev (GLenum pname, GLdouble *params);
WINGDIAPI GLenum APIENTRY glGetError (void);
WINGDIAPI void APIENTRY glGetFloatv (GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetIntegerv (GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetLightiv (GLenum light, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetMapdv (GLenum target, GLenum query, GLdouble *v);
WINGDIAPI void APIENTRY glGetMapfv (GLenum target, GLenum query, GLfloat *v);
WINGDIAPI void APIENTRY glGetMapiv (GLenum target, GLenum query, GLint *v);
WINGDIAPI void APIENTRY glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetPixelMapfv (GLenum map, GLfloat *values);
WINGDIAPI void APIENTRY glGetPixelMapuiv (GLenum map, GLuint *values);
WINGDIAPI void APIENTRY glGetPixelMapusv (GLenum map, GLushort *values);
WINGDIAPI void APIENTRY glGetPointerv (GLenum pname, GLvoid* *params);
WINGDIAPI void APIENTRY glGetPolygonStipple (GLubyte *mask);
WINGDIAPI const GLubyte * APIENTRY glGetString (GLenum name);
WINGDIAPI void APIENTRY glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
WINGDIAPI void APIENTRY glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
WINGDIAPI void APIENTRY glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
WINGDIAPI void APIENTRY glHint (GLenum target, GLenum mode);
WINGDIAPI void APIENTRY glIndexMask (GLuint mask);
WINGDIAPI void APIENTRY glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glIndexd (GLdouble c);
WINGDIAPI void APIENTRY glIndexdv (const GLdouble *c);
WINGDIAPI void APIENTRY glIndexf (GLfloat c);
WINGDIAPI void APIENTRY glIndexfv (const GLfloat *c);
WINGDIAPI void APIENTRY glIndexi (GLint c);
WINGDIAPI void APIENTRY glIndexiv (const GLint *c);
WINGDIAPI void APIENTRY glIndexs (GLshort c);
WINGDIAPI void APIENTRY glIndexsv (const GLshort *c);
WINGDIAPI void APIENTRY glIndexub (GLubyte c);
WINGDIAPI void APIENTRY glIndexubv (const GLubyte *c);
WINGDIAPI void APIENTRY glInitNames (void);
WINGDIAPI void APIENTRY glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
WINGDIAPI GLboolean APIENTRY glIsEnabled (GLenum cap);
WINGDIAPI GLboolean APIENTRY glIsList (GLuint list);
WINGDIAPI GLboolean APIENTRY glIsTexture (GLuint texture);
WINGDIAPI void APIENTRY glLightModelf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightModelfv (GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLightModeli (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightModeliv (GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLightf (GLenum light, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glLightfv (GLenum light, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glLighti (GLenum light, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glLightiv (GLenum light, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glLineStipple (GLint factor, GLushort pattern);
WINGDIAPI void APIENTRY glLineWidth (GLfloat width);
WINGDIAPI void APIENTRY glListBase (GLuint base);
WINGDIAPI void APIENTRY glLoadIdentity (void);
WINGDIAPI void APIENTRY glLoadMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glLoadMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glLoadName (GLuint name);
WINGDIAPI void APIENTRY glLogicOp (GLenum opcode);
WINGDIAPI void APIENTRY glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
WINGDIAPI void APIENTRY glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
WINGDIAPI void APIENTRY glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
WINGDIAPI void APIENTRY glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
WINGDIAPI void APIENTRY glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
WINGDIAPI void APIENTRY glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
WINGDIAPI void APIENTRY glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
WINGDIAPI void APIENTRY glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
WINGDIAPI void APIENTRY glMaterialf (GLenum face, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glMateriali (GLenum face, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glMaterialiv (GLenum face, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glMatrixMode (GLenum mode);
WINGDIAPI void APIENTRY glMultMatrixd (const GLdouble *m);
WINGDIAPI void APIENTRY glMultMatrixf (const GLfloat *m);
WINGDIAPI void APIENTRY glNewList (GLuint list, GLenum mode);
WINGDIAPI void APIENTRY glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
WINGDIAPI void APIENTRY glNormal3bv (const GLbyte *v);
WINGDIAPI void APIENTRY glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
WINGDIAPI void APIENTRY glNormal3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
WINGDIAPI void APIENTRY glNormal3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glNormal3i (GLint nx, GLint ny, GLint nz);
WINGDIAPI void APIENTRY glNormal3iv (const GLint *v);
WINGDIAPI void APIENTRY glNormal3s (GLshort nx, GLshort ny, GLshort nz);
WINGDIAPI void APIENTRY glNormal3sv (const GLshort *v);
WINGDIAPI void APIENTRY glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
WINGDIAPI void APIENTRY glPassThrough (GLfloat token);
WINGDIAPI void APIENTRY glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
WINGDIAPI void APIENTRY glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
WINGDIAPI void APIENTRY glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
WINGDIAPI void APIENTRY glPixelStoref (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelStorei (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelTransferf (GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glPixelTransferi (GLenum pname, GLint param);
WINGDIAPI void APIENTRY glPixelZoom (GLfloat xfactor, GLfloat yfactor);
WINGDIAPI void APIENTRY glPointSize (GLfloat size);
WINGDIAPI void APIENTRY glPolygonMode (GLenum face, GLenum mode);
WINGDIAPI void APIENTRY glPolygonOffset (GLfloat factor, GLfloat units);
WINGDIAPI void APIENTRY glPolygonStipple (const GLubyte *mask);
WINGDIAPI void APIENTRY glPopAttrib (void);
WINGDIAPI void APIENTRY glPopClientAttrib (void);
WINGDIAPI void APIENTRY glPopMatrix (void);
WINGDIAPI void APIENTRY glPopName (void);
WINGDIAPI void APIENTRY glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
WINGDIAPI void APIENTRY glPushAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushClientAttrib (GLbitfield mask);
WINGDIAPI void APIENTRY glPushMatrix (void);
WINGDIAPI void APIENTRY glPushName (GLuint name);
WINGDIAPI void APIENTRY glRasterPos2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glRasterPos2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glRasterPos2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glRasterPos2iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glRasterPos2sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRasterPos3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glRasterPos3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glRasterPos3iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glRasterPos3sv (const GLshort *v);
WINGDIAPI void APIENTRY glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glRasterPos4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glRasterPos4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glRasterPos4iv (const GLint *v);
WINGDIAPI void APIENTRY glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glRasterPos4sv (const GLshort *v);
WINGDIAPI void APIENTRY glReadBuffer (GLenum mode);
WINGDIAPI void APIENTRY glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
WINGDIAPI void APIENTRY glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
WINGDIAPI void APIENTRY glRectdv (const GLdouble *v1, const GLdouble *v2);
WINGDIAPI void APIENTRY glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
WINGDIAPI void APIENTRY glRectfv (const GLfloat *v1, const GLfloat *v2);
WINGDIAPI void APIENTRY glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
WINGDIAPI void APIENTRY glRectiv (const GLint *v1, const GLint *v2);
WINGDIAPI void APIENTRY glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
WINGDIAPI void APIENTRY glRectsv (const GLshort *v1, const GLshort *v2);
WINGDIAPI GLint APIENTRY glRenderMode (GLenum mode);
WINGDIAPI void APIENTRY glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScaled (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glScalef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
WINGDIAPI void APIENTRY glSelectBuffer (GLsizei size, GLuint *buffer);
WINGDIAPI void APIENTRY glShadeModel (GLenum mode);
WINGDIAPI void APIENTRY glStencilFunc (GLenum func, GLint ref, GLuint mask);
WINGDIAPI void APIENTRY glStencilMask (GLuint mask);
WINGDIAPI void APIENTRY glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
WINGDIAPI void APIENTRY glTexCoord1d (GLdouble s);
WINGDIAPI void APIENTRY glTexCoord1dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord1f (GLfloat s);
WINGDIAPI void APIENTRY glTexCoord1fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord1i (GLint s);
WINGDIAPI void APIENTRY glTexCoord1iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord1s (GLshort s);
WINGDIAPI void APIENTRY glTexCoord1sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord2d (GLdouble s, GLdouble t);
WINGDIAPI void APIENTRY glTexCoord2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord2f (GLfloat s, GLfloat t);
WINGDIAPI void APIENTRY glTexCoord2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord2i (GLint s, GLint t);
WINGDIAPI void APIENTRY glTexCoord2iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord2s (GLshort s, GLshort t);
WINGDIAPI void APIENTRY glTexCoord2sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
WINGDIAPI void APIENTRY glTexCoord3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
WINGDIAPI void APIENTRY glTexCoord3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord3i (GLint s, GLint t, GLint r);
WINGDIAPI void APIENTRY glTexCoord3iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord3s (GLshort s, GLshort t, GLshort r);
WINGDIAPI void APIENTRY glTexCoord3sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
WINGDIAPI void APIENTRY glTexCoord4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
WINGDIAPI void APIENTRY glTexCoord4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
WINGDIAPI void APIENTRY glTexCoord4iv (const GLint *v);
WINGDIAPI void APIENTRY glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
WINGDIAPI void APIENTRY glTexCoord4sv (const GLshort *v);
WINGDIAPI void APIENTRY glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glTexEnvf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexEnvi (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexEnviv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexGend (GLenum coord, GLenum pname, GLdouble param);
WINGDIAPI void APIENTRY glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
WINGDIAPI void APIENTRY glTexGenf (GLenum coord, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexGeni (GLenum coord, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexParameterf (GLenum target, GLenum pname, GLfloat param);
WINGDIAPI void APIENTRY glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
WINGDIAPI void APIENTRY glTexParameteri (GLenum target, GLenum pname, GLint param);
WINGDIAPI void APIENTRY glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
WINGDIAPI void APIENTRY glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
WINGDIAPI void APIENTRY glTranslated (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glTranslatef (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex2d (GLdouble x, GLdouble y);
WINGDIAPI void APIENTRY glVertex2dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex2f (GLfloat x, GLfloat y);
WINGDIAPI void APIENTRY glVertex2fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex2i (GLint x, GLint y);
WINGDIAPI void APIENTRY glVertex2iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex2s (GLshort x, GLshort y);
WINGDIAPI void APIENTRY glVertex2sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex3d (GLdouble x, GLdouble y, GLdouble z);
WINGDIAPI void APIENTRY glVertex3dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex3f (GLfloat x, GLfloat y, GLfloat z);
WINGDIAPI void APIENTRY glVertex3fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex3i (GLint x, GLint y, GLint z);
WINGDIAPI void APIENTRY glVertex3iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex3s (GLshort x, GLshort y, GLshort z);
WINGDIAPI void APIENTRY glVertex3sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
WINGDIAPI void APIENTRY glVertex4dv (const GLdouble *v);
WINGDIAPI void APIENTRY glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
WINGDIAPI void APIENTRY glVertex4fv (const GLfloat *v);
WINGDIAPI void APIENTRY glVertex4i (GLint x, GLint y, GLint z, GLint w);
WINGDIAPI void APIENTRY glVertex4iv (const GLint *v);
WINGDIAPI void APIENTRY glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
WINGDIAPI void APIENTRY glVertex4sv (const GLshort *v);
WINGDIAPI void APIENTRY glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
WINGDIAPI void APIENTRY glViewport (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_vertex_array */
typedef void (APIENTRY * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (APIENTRY * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (APIENTRY * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean *pointer);
typedef void (APIENTRY * PFNGLGETPOINTERVEXTPROC) (GLenum pname, GLvoid* *params);
typedef void (APIENTRY * PFNGLARRAYELEMENTARRAYEXTPROC)(GLenum mode, GLsizei count, const GLvoid* pi);

/* WIN_draw_range_elements */
typedef void (APIENTRY * PFNGLDRAWRANGEELEMENTSWINPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);

/* WIN_swap_hint */
typedef void (APIENTRY * PFNGLADDSWAPHINTRECTWINPROC)  (GLint x, GLint y, GLsizei width, GLsizei height);

/* EXT_paletted_texture */
typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC)
    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC)
    (GLenum target, GLsizei start, GLsizei count, GLenum format,
     GLenum type, const GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEEXTPROC)
    (GLenum target, GLenum format, GLenum type, GLvoid *data);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC)
    (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC)
    (GLenum target, GLenum pname, GLfloat *params);

#ifdef __cplusplus
}
#endif

#endif /* __GL_H__ */
#endif /* __gl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\model.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/

#ifndef __MODEL__
#define __MODEL__

#include "modelgen.h"
#include "spritegn.h"

/*

d*_t structures are on-disk representations
m*_t structures are in-memory

*/

/*
==============================================================================

BRUSH MODELS

==============================================================================
*/


//
// in memory representation
//
// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct
{
	vec3_t		position;
} mvertex_t;

#define	SIDE_FRONT	0
#define	SIDE_BACK	1
#define	SIDE_ON		2


// plane_t structure
// !!! if this is changed, it must be changed in asm_i386.h too !!!
typedef struct mplane_s
{
	vec3_t	normal;
	float	dist;
	byte	type;			// for texture axis selection and fast side tests
	byte	signbits;		// signx + signy<<1 + signz<<1
	byte	pad[2];
} mplane_t;

typedef struct texture_s
{
	char		name[16];
	unsigned	width, height;
	int			anim_total;				// total tenths in sequence ( 0 = no)
	int			anim_min, anim_max;		// time for this frame min <=time< max
	struct texture_s *anim_next;		// in the animation sequence
	struct texture_s *alternate_anims;	// bmodels in frmae 1 use these
	unsigned	offsets[MIPLEVELS];		// four mip maps stored
} texture_t;


#define	SURF_PLANEBACK		2
#define	SURF_DRAWSKY		4
#define SURF_DRAWSPRITE		8
#define SURF_DRAWTURB		0x10
#define SURF_DRAWTILED		0x20
#define SURF_DRAWBACKGROUND	0x40

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct
{
	unsigned short	v[2];
	unsigned int	cachededgeoffset;
} medge_t;

typedef struct
{
	float		vecs[2][4];
	float		mipadjust;
	texture_t	*texture;
	int			flags;
} mtexinfo_t;

typedef struct msurface_s
{
	int			visframe;		// should be drawn when node is crossed

	int			dlightframe;
	int			dlightbits;

	mplane_t	*plane;
	int			flags;

	int			firstedge;	// look up in model->surfedges[], negative numbers
	int			numedges;	// are backwards edges
	
// surface generation data
	struct surfcache_s	*cachespots[MIPLEVELS];

	short		texturemins[2];
	short		extents[2];

	mtexinfo_t	*texinfo;
	
// lighting info
	byte		styles[MAXLIGHTMAPS];
	byte		*samples;		// [numstyles*surfsize]
} msurface_t;

typedef struct mnode_s
{
// common with leaf
	int			contents;		// 0, to differentiate from leafs
	int			visframe;		// node needs to be traversed if current
	
	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// node specific
	mplane_t	*plane;
	struct mnode_s	*children[2];	

	unsigned short		firstsurface;
	unsigned short		numsurfaces;
} mnode_t;



typedef struct mleaf_s
{
// common with node
	int			contents;		// wil be a negative contents number
	int			visframe;		// node needs to be traversed if current

	short		minmaxs[6];		// for bounding box culling

	struct mnode_s	*parent;

// leaf specific
	byte		*compressed_vis;
	efrag_t		*efrags;

	msurface_t	**firstmarksurface;
	int			nummarksurfaces;
	int			key;			// BSP sequence number for leaf's contents
	byte		ambient_sound_level[NUM_AMBIENTS];
} mleaf_t;

// !!! if this is changed, it must be changed in asm_i386.h too !!!
typedef struct
{
	dclipnode_t	*clipnodes;
	mplane_t	*planes;
	int			firstclipnode;
	int			lastclipnode;
	vec3_t		clip_mins;
	vec3_t		clip_maxs;
} hull_t;

/*
==============================================================================

SPRITE MODELS

==============================================================================
*/


// FIXME: shorten these?
typedef struct mspriteframe_s
{
	int		width;
	int		height;
	void	*pcachespot;			// remove?
	float	up, down, left, right;
	byte	pixels[4];
} mspriteframe_t;

typedef struct
{
	int				numframes;
	float			*intervals;
	mspriteframe_t	*frames[1];
} mspritegroup_t;

typedef struct
{
	spriteframetype_t	type;
	mspriteframe_t		*frameptr;
} mspriteframedesc_t;

typedef struct
{
	int					type;
	int					maxwidth;
	int					maxheight;
	int					numframes;
	float				beamlength;		// remove?
	void				*cachespot;		// remove?
	mspriteframedesc_t	frames[1];
} msprite_t;


/*
==============================================================================

ALIAS MODELS

Alias models are position independent, so the cache manager can move them.
==============================================================================
*/

typedef struct
{
	aliasframetype_t	type;
	trivertx_t			bboxmin;
	trivertx_t			bboxmax;
	int					frame;
	char				name[16];
} maliasframedesc_t;

typedef struct
{
	aliasskintype_t		type;
	void				*pcachespot;
	int					skin;
} maliasskindesc_t;

typedef struct
{
	trivertx_t			bboxmin;
	trivertx_t			bboxmax;
	int					frame;
} maliasgroupframedesc_t;

typedef struct
{
	int						numframes;
	int						intervals;
	maliasgroupframedesc_t	frames[1];
} maliasgroup_t;

typedef struct
{
	int					numskins;
	int					intervals;
	maliasskindesc_t	skindescs[1];
} maliasskingroup_t;

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct mtriangle_s {
	int					facesfront;
	int					vertindex[3];
} mtriangle_t;

typedef struct {
	int					model;
	int					stverts;
	int					skindesc;
	int					triangles;
	maliasframedesc_t	frames[1];
} aliashdr_t;

//===================================================================

//
// Whole model
//

typedef enum {mod_brush, mod_sprite, mod_alias} modtype_t;

#define	EF_ROCKET	1			// leave a trail
#define	EF_GRENADE	2			// leave a trail
#define	EF_GIB		4			// leave a trail
#define	EF_ROTATE	8			// rotate (bonus items)
#define	EF_TRACER	16			// green split trail
#define	EF_ZOMGIB	32			// small blood trail
#define	EF_TRACER2	64			// orange split trail + rotate
#define	EF_TRACER3	128			// purple trail

typedef struct model_s
{
	char		name[MAX_QPATH];
	qboolean	needload;		// bmodels and sprites don't cache normally

	modtype_t	type;
	int			numframes;
	synctype_t	synctype;
	
	int			flags;

//
// volume occupied by the model
//		
	vec3_t		mins, maxs;
	float		radius;

//
// brush model
//
	int			firstmodelsurface, nummodelsurfaces;

	int			numsubmodels;
	dmodel_t	*submodels;

	int			numplanes;
	mplane_t	*planes;

	int			numleafs;		// number of visible leafs, not counting 0
	mleaf_t		*leafs;

	int			numvertexes;
	mvertex_t	*vertexes;

	int			numedges;
	medge_t		*edges;

	int			numnodes;
	mnode_t		*nodes;

	int			numtexinfo;
	mtexinfo_t	*texinfo;

	int			numsurfaces;
	msurface_t	*surfaces;

	int			numsurfedges;
	int			*surfedges;

	int			numclipnodes;
	dclipnode_t	*clipnodes;

	int			nummarksurfaces;
	msurface_t	**marksurfaces;

	hull_t		hulls[MAX_MAP_HULLS];

	int			numtextures;
	texture_t	**textures;

	byte		*visdata;
	byte		*lightdata;
	char		*entities;

//
// additional model data
//
	cache_user_t	cache;		// only access through Mod_Extradata

} model_t;

//============================================================================

void	Mod_Init (void);
void	Mod_ClearAll (void);
model_t *Mod_ForName (char *name, qboolean crash);
void	*Mod_Extradata (model_t *mod);	// handles caching
void	Mod_TouchModel (char *name);

mleaf_t *Mod_PointInLeaf (float *p, model_t *model);
byte	*Mod_LeafPVS (mleaf_t *leaf, model_t *model);

#endif	// __MODEL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\net_bw.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_bw.h

int  BW_Init (void);
void BW_Shutdown (void);
void BW_Listen (qboolean state);
int  BW_OpenSocket (int port);
int  BW_CloseSocket (int socket);
int  BW_Connect (int socket, struct qsockaddr *addr);
int  BW_CheckNewConnections (void);
int  BW_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  BW_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  BW_Broadcast (int socket, byte *buf, int len);
char *BW_AddrToString (struct qsockaddr *addr);
int  BW_StringToAddr (char *string, struct qsockaddr *addr);
int  BW_GetSocketAddr (int socket, struct qsockaddr *addr);
int  BW_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  BW_GetAddrFromName (char *name, struct qsockaddr *addr);
int  BW_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  BW_GetSocketPort (struct qsockaddr *addr);
int  BW_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\block8.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
LEnter16_8:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch0:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch1:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch2:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch3:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch4:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch5:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch6:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch7:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

LEnter8_8:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch8:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch9:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch10:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch11:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

LEnter4_8:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch12:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch13:
	movb	%cl,1(%edi)
	addl	$0x2,%edi

LEnter2_8:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movb	0x12345678(%eax),%al
LBPatch14:
	addl	%ebp,%edx
	movb	%al,(%edi)
	movb	0x12345678(%ecx),%cl
LBPatch15:
	movb	%cl,1(%edi)
	addl	$0x2,%edi
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\block16.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
LEnter16_16:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch0:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch1:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch2:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch3:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch4:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch5:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch6:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch7:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

LEnter8_16:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch8:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch9:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch10:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch11:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

LEnter4_16:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch12:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch13:
	movw	%cx,2(%edi)
	addl	$0x4,%edi

LEnter2_16:
	movb	(%esi),%al
	movb	(%esi,%ebx,),%cl
	movb	%dh,%ah
	addl	%ebp,%edx
	movb	%dh,%ch
	leal	(%esi,%ebx,2),%esi
	movw	0x12345678(,%eax,2),%ax
LBPatch14:
	addl	%ebp,%edx
	movw	%ax,(%edi)
	movw	0x12345678(,%ecx,2),%cx
LBPatch15:
	movw	%cx,2(%edi)
	addl	$0x4,%edi
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\conproc.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// conproc.h

#define CCOM_WRITE_TEXT		0x2
// Param1 : Text

#define CCOM_GET_TEXT		0x3
// Param1 : Begin line
// Param2 : End line

#define CCOM_GET_SCR_LINES	0x4
// No params

#define CCOM_SET_SCR_LINES	0x5
// Param1 : Number of lines

void InitConProc (HANDLE hFile, HANDLE heventParent, HANDLE heventChild);
void DeinitConProc (void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\glquake2.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// disable data conversion warnings

#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4051)     // ALPHA
  
#include <xtl.h>

#include <gl\gl.h>
#include <gl\glu.h>

void GL_BeginRendering (int *x, int *y, int *width, int *height);
void GL_EndRendering (void);


// Function prototypes for the Texture Object Extension routines
typedef GLboolean (APIENTRY *ARETEXRESFUNCPTR)(GLsizei, const GLuint *,
                    const GLboolean *);
typedef void (APIENTRY *BINDTEXFUNCPTR)(GLenum, GLuint);
typedef void (APIENTRY *DELTEXFUNCPTR)(GLsizei, const GLuint *);
typedef void (APIENTRY *GENTEXFUNCPTR)(GLsizei, GLuint *);
typedef GLboolean (APIENTRY *ISTEXFUNCPTR)(GLuint);
typedef void (APIENTRY *PRIORTEXFUNCPTR)(GLsizei, const GLuint *,
                    const GLclampf *);
typedef void (APIENTRY *TEXSUBIMAGEPTR)(int, int, int, int, int, int, int, int, void *);

extern	BINDTEXFUNCPTR bindTexFunc;
extern	DELTEXFUNCPTR delTexFunc;
extern	TEXSUBIMAGEPTR TexSubImage2DFunc;

extern	int texture_extension_number;
extern	int		texture_mode;

extern	float	gldepthmin, gldepthmax;

void GL_Upload32 (unsigned *data, int width, int height,  qboolean mipmap, qboolean alpha, qboolean modulate);
void GL_Upload8 (byte *data, int width, int height,  qboolean mipmap, qboolean alpha, qboolean modulate);
int GL_LoadTexture (char *identifier, int width, int height, byte *data, int mipmap, int alpha, int modulate);
int GL_FindTexture (char *identifier);

typedef struct
{
	float	x, y, z;
	float	s, t;
	float	r, g, b;
} glvert_t;

extern glvert_t glv;

extern	int glx, gly, glwidth, glheight;

extern	PROC glArrayElementEXT;
extern	PROC glColorPointerEXT;
extern	PROC glTexturePointerEXT;
extern	PROC glVertexPointerEXT;


// r_local.h -- private refresh defs

#define MAXALIASVERTS		2000	// TODO: tune this

#define ALIAS_BASE_SIZE_RATIO		(1.0 / 11.0)
					// normalizing factor so player model works out to about
					//  1 pixel per triangle
#define	MAX_LBM_HEIGHT		480

#define TILE_SIZE		128		// size of textures generated by R_GenTiledSurf

#define SKYSHIFT		7
#define	SKYSIZE			(1 << SKYSHIFT)
#define SKYMASK			(SKYSIZE - 1)

#define BACKFACE_EPSILON	0.01


void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
texture_t *R_TextureAnimation (texture_t *base);

typedef struct surfcache_s
{
	struct surfcache_s	*next;
	struct surfcache_s 	**owner;		// NULL is an empty chunk of memory
	int					lightadj[MAXLIGHTMAPS]; // checked for strobe flush
	int					dlight;
	int					size;		// including header
	unsigned			width;
	unsigned			height;		// DEBUG only needed for debug
	float				mipscale;
	struct texture_s	*texture;	// checked for animating textures
	byte				data[4];	// width*height elements
} surfcache_t;


typedef struct
{
	pixel_t		*surfdat;	// destination for generated surface
	int			rowbytes;	// destination logical width in bytes
	msurface_t	*surf;		// description for surface to generate
	fixed8_t	lightadj[MAXLIGHTMAPS];
							// adjust for lightmap levels for dynamic lighting
	texture_t	*texture;	// corrected for animating textures
	int			surfmip;	// mipmapped ratio of surface texels / world pixels
	int			surfwidth;	// in mipmapped texels
	int			surfheight;	// in mipmapped texels
} drawsurf_t;


typedef enum {
	pt_static, pt_grav, pt_slowgrav, pt_fire, pt_explode, pt_explode2, pt_blob, pt_blob2
} ptype_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	float		color;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
	float		ramp;
	float		die;
	ptype_t		type;
} particle_t;


//====================================================


extern	entity_t	r_worldentity;
extern	qboolean	r_cache_thrash;		// compatability
extern	vec3_t		modelorg, r_entorigin;
extern	entity_t	*currententity;
extern	int			r_visframecount;	// ??? what difs?
extern	int			r_framecount;
extern	mplane_t	frustum[4];
extern	int		c_brush_polys, c_alias_polys;


//
// view origin
//
extern	vec3_t	vup;
extern	vec3_t	vpn;
extern	vec3_t	vright;
extern	vec3_t	r_origin;

//
// screen size info
//
extern	refdef_t	r_refdef;
extern	mleaf_t		*r_viewleaf, *r_oldviewleaf;
extern	texture_t	*r_notexture_mip;
extern	int		d_lightstylevalue[256];	// 8.8 fraction of base light value

extern	qboolean	envmap;
extern	int	currenttexture;
extern	int	particletexture;
extern	int	playertextures;

extern	int	skytexturenum;		// index in cl.loadmodel, not gl texture object

extern	cvar_t	r_drawentities;
extern	cvar_t	r_drawworld;
extern	cvar_t	r_drawviewmodel;
extern	cvar_t	r_speeds;
extern	cvar_t	r_waterwarp;
extern	cvar_t	r_fullbright;
extern	cvar_t	r_lightmap;
extern	cvar_t	r_shadows;
extern	cvar_t	r_dynamic;

extern	cvar_t	gl_clear;
extern	cvar_t	gl_cull;
extern	cvar_t	gl_poly;
extern	cvar_t	gl_texsort;
extern	cvar_t	gl_smoothmodels;
extern	cvar_t	gl_affinemodels;
extern	cvar_t	gl_fogblend;
extern	cvar_t	gl_polyblend;
extern	cvar_t	gl_keeptjunctions;
extern	cvar_t	gl_reporttjunctions;

extern	int		gl_lightmap_format;
extern	int		gl_solid_format;
extern	int		gl_alpha_format;

void R_TranslatePlayerSkin (int playernum);
void GL_Bind (int texnum);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\net_ipx.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_ipx.h

int  IPX_Init (void);
void IPX_Shutdown (void);
void IPX_Listen (qboolean state);
int  IPX_OpenSocket (int port);
int  IPX_CloseSocket (int socket);
int  IPX_Connect (int socket, struct qsockaddr *addr);
int  IPX_CheckNewConnections (void);
int  IPX_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  IPX_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  IPX_Broadcast (int socket, byte *buf, int len);
char *IPX_AddrToString (struct qsockaddr *addr);
int  IPX_StringToAddr (char *string, struct qsockaddr *addr);
int  IPX_GetSocketAddr (int socket, struct qsockaddr *addr);
int  IPX_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  IPX_GetAddrFromName (char *name, struct qsockaddr *addr);
int  IPX_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  IPX_GetSocketPort (struct qsockaddr *addr);
int  IPX_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\mpdosock.h ===
/* WINSOCK.H--definitions to be used with the WINSOCK.DLL
 * Copyright (c) 1993-1995, Microsoft Corp. All rights reserved.
 *
 * This header file corresponds to version 1.1 of the Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 */

#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_

#define FAR
#define PASCAL

/*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 */
typedef unsigned char   u_char;
typedef unsigned short  u_short;
typedef unsigned int    u_int;
typedef unsigned long   u_long;

/*
 * The new type to be used in all
 * instances which refer to sockets.
 */
typedef u_int           SOCKET;

// FIXME
#if 0
/*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 */
#ifndef FD_SETSIZE
#define FD_SETSIZE      64
#endif /* FD_SETSIZE */

typedef struct fd_set {
        u_int   fd_count;               /* how many are SET? */
        SOCKET  fd_array[FD_SETSIZE];   /* an array of SOCKETs */
} fd_set;

#ifdef __cplusplus
extern "C" {
#endif

extern int PASCAL FAR __WSAFDIsSet(SOCKET, fd_set FAR *);

#ifdef __cplusplus
}
#endif


#define FD_CLR(fd, set) do { \
    u_int __i; \
    for (__i = 0; __i < ((fd_set FAR *)(set))->fd_count ; __i++) { \
        if (((fd_set FAR *)(set))->fd_array[__i] == fd) { \
            while (__i < ((fd_set FAR *)(set))->fd_count-1) { \
                ((fd_set FAR *)(set))->fd_array[__i] = \
                    ((fd_set FAR *)(set))->fd_array[__i+1]; \
                __i++; \
            } \
            ((fd_set FAR *)(set))->fd_count--; \
            break; \
        } \
    } \
} while(0)

#define FD_SET(fd, set) do { \
    if (((fd_set FAR *)(set))->fd_count < FD_SETSIZE) \
        ((fd_set FAR *)(set))->fd_array[((fd_set FAR *)(set))->fd_count++]=(fd);\
} while(0)

#define FD_ZERO(set) (((fd_set FAR *)(set))->fd_count=0)

#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set FAR *)(set))

/*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 */
struct timeval {
        long    tv_sec;         /* seconds */
        long    tv_usec;        /* and microseconds */
};

/*
 * Operations on timevals.
 *
 * NB: timercmp does not work for >= or <=.
 */
#define timerisset(tvp)         ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp, uvp, cmp) \
        ((tvp)->tv_sec cmp (uvp)->tv_sec || \
         (tvp)->tv_sec == (uvp)->tv_sec && (tvp)->tv_usec cmp (uvp)->tv_usec)
#define timerclear(tvp)         (tvp)->tv_sec = (tvp)->tv_usec = 0
#endif

/*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 */
#define IOCPARM_MASK    0x7f            /* parameters must be < 128 bytes */
#define IOC_VOID        0x20000000      /* no parameters */
#define IOC_OUT         0x40000000      /* copy out parameters */
#define IOC_IN          0x80000000      /* copy in parameters */
#define IOC_INOUT       (IOC_IN|IOC_OUT)
                                        /* 0x20000000 distinguishes new &
                                           old ioctl's */
#define _IO(x,y)        (IOC_VOID|((x)<<8)|(y))

#define _IOR(x,y,t)     (IOC_OUT|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define _IOW(x,y,t)     (IOC_IN|(((long)sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|(y))

#define FIONREAD    _IOR('f', 127, u_long) /* get # bytes to read */
#define FIONBIO     _IOW('f', 126, u_long) /* set/clear non-blocking i/o */
#define FIOASYNC    _IOW('f', 125, u_long) /* set/clear async i/o */

/* Socket I/O Controls */
#define SIOCSHIWAT  _IOW('s',  0, u_long)  /* set high watermark */
#define SIOCGHIWAT  _IOR('s',  1, u_long)  /* get high watermark */
#define SIOCSLOWAT  _IOW('s',  2, u_long)  /* set low watermark */
#define SIOCGLOWAT  _IOR('s',  3, u_long)  /* get low watermark */
#define SIOCATMARK  _IOR('s',  7, u_long)  /* at oob mark? */

/*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 */

struct  hostent {
        char    FAR * h_name;           /* official name of host */
        char    FAR * FAR * h_aliases;  /* alias list */
        short   h_addrtype;             /* host address type */
        short   h_length;               /* length of address */
        char    FAR * FAR * h_addr_list; /* list of addresses */
#define h_addr  h_addr_list[0]          /* address, for backward compat */
};

/*
 * It is assumed here that a network number
 * fits in 32 bits.
 */
struct  netent {
        char    FAR * n_name;           /* official name of net */
        char    FAR * FAR * n_aliases;  /* alias list */
        short   n_addrtype;             /* net address type */
        u_long  n_net;                  /* network # */
};

struct  servent {
        char    FAR * s_name;           /* official service name */
        char    FAR * FAR * s_aliases;  /* alias list */
        short   s_port;                 /* port # */
        char    FAR * s_proto;          /* protocol to use */
};

struct  protoent {
        char    FAR * p_name;           /* official protocol name */
        char    FAR * FAR * p_aliases;  /* alias list */
        short   p_proto;                /* protocol # */
};

/*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 */

/*
 * Protocols
 */
#define IPPROTO_IP              0               /* dummy for IP */
#define IPPROTO_ICMP            1               /* control message protocol */
#define IPPROTO_GGP             2               /* gateway^2 (deprecated) */
#define IPPROTO_TCP             6               /* tcp */
#define IPPROTO_PUP             12              /* pup */
#define IPPROTO_UDP             17              /* user datagram protocol */
#define IPPROTO_IDP             22              /* xns idp */
#define IPPROTO_ND              77              /* UNOFFICIAL net disk proto */

#define IPPROTO_RAW             255             /* raw IP packet */
#define IPPROTO_MAX             256

/*
 * Port/socket numbers: network standard functions
 */
#define IPPORT_ECHO             7
#define IPPORT_DISCARD          9
#define IPPORT_SYSTAT           11
#define IPPORT_DAYTIME          13
#define IPPORT_NETSTAT          15
#define IPPORT_FTP              21
#define IPPORT_TELNET           23
#define IPPORT_SMTP             25
#define IPPORT_TIMESERVER       37
#define IPPORT_NAMESERVER       42
#define IPPORT_WHOIS            43
#define IPPORT_MTP              57

/*
 * Port/socket numbers: host specific functions
 */
#define IPPORT_TFTP             69
#define IPPORT_RJE              77
#define IPPORT_FINGER           79
#define IPPORT_TTYLINK          87
#define IPPORT_SUPDUP           95

/*
 * UNIX TCP sockets
 */
#define IPPORT_EXECSERVER       512
#define IPPORT_LOGINSERVER      513
#define IPPORT_CMDSERVER        514
#define IPPORT_EFSSERVER        520

/*
 * UNIX UDP sockets
 */
#define IPPORT_BIFFUDP          512
#define IPPORT_WHOSERVER        513
#define IPPORT_ROUTESERVER      520
                                        /* 520+1 also used */

/*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 */
#define IPPORT_RESERVED         1024

/*
 * Link numbers
 */
#define IMPLINK_IP              155
#define IMPLINK_LOWEXPER        156
#define IMPLINK_HIGHEXPER       158

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

#define WSADESCRIPTION_LEN      256
#define WSASYS_STATUS_LEN       128


/*
 * Options for use with [gs]etsockopt at the IP level.
 */
#define IP_OPTIONS          1           /* set/get IP per-packet options    */
#define IP_MULTICAST_IF     2           /* set/get IP multicast interface   */
#define IP_MULTICAST_TTL    3           /* set/get IP multicast timetolive  */
#define IP_MULTICAST_LOOP   4           /* set/get IP multicast loopback    */
#define IP_ADD_MEMBERSHIP   5           /* add  an IP group membership      */
#define IP_DROP_MEMBERSHIP  6           /* drop an IP group membership      */

#define IP_DEFAULT_MULTICAST_TTL   1    /* normally limit m'casts to 1 hop  */
#define IP_DEFAULT_MULTICAST_LOOP  1    /* normally hear sends if a member  */
#define IP_MAX_MEMBERSHIPS         20   /* per socket; must fit in one mbuf */

/*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 */
struct ip_mreq {
        struct in_addr  imr_multiaddr;  /* IP multicast address of group */
        struct in_addr  imr_interface;  /* local IP address of interface */
};

/*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 */

/*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 */
#define INVALID_SOCKET  (SOCKET)(~0)
#define SOCKET_ERROR            (-1)

/*
 * Types
 */
#define SOCK_STREAM     1               /* stream socket */
#define SOCK_DGRAM      2               /* datagram socket */
#define SOCK_RAW        3               /* raw-protocol interface */
#define SOCK_RDM        4               /* reliably-delivered message */
#define SOCK_SEQPACKET  5               /* sequenced packet stream */

/*
 * Option flags per-socket.
 */
#define SO_DEBUG        0x0001          /* turn on debugging info recording */
#define SO_ACCEPTCONN   0x0002          /* socket has had listen() */
#define SO_REUSEADDR    0x0004          /* allow local address reuse */
#define SO_KEEPALIVE    0x0008          /* keep connections alive */
#define SO_DONTROUTE    0x0010          /* just use interface addresses */
#define SO_BROADCAST    0x0020          /* permit sending of broadcast msgs */
#define SO_USELOOPBACK  0x0040          /* bypass hardware when possible */
#define SO_LINGER       0x0080          /* linger on close if data present */
#define SO_OOBINLINE    0x0100          /* leave received OOB data in line */

#define SO_DONTLINGER   (u_int)(~SO_LINGER)

/*
 * Additional options.
 */
#define SO_SNDBUF       0x1001          /* send buffer size */
#define SO_RCVBUF       0x1002          /* receive buffer size */
#define SO_SNDLOWAT     0x1003          /* send low-water mark */
#define SO_RCVLOWAT     0x1004          /* receive low-water mark */
#define SO_SNDTIMEO     0x1005          /* send timeout */
#define SO_RCVTIMEO     0x1006          /* receive timeout */
#define SO_ERROR        0x1007          /* get error status and clear */
#define SO_TYPE         0x1008          /* get socket type */

/*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 */
#define SO_CONNDATA     0x7000
#define SO_CONNOPT      0x7001
#define SO_DISCDATA     0x7002
#define SO_DISCOPT      0x7003
#define SO_CONNDATALEN  0x7004
#define SO_CONNOPTLEN   0x7005
#define SO_DISCDATALEN  0x7006
#define SO_DISCOPTLEN   0x7007

/*
 * Option for opening sockets for synchronous access.
 */
#define SO_OPENTYPE     0x7008

#define SO_SYNCHRONOUS_ALERT    0x10
#define SO_SYNCHRONOUS_NONALERT 0x20

/*
 * Other NT-specific options.
 */
#define SO_MAXDG        0x7009
#define SO_MAXPATHDG    0x700A

/*
 * TCP options.
 */
#define TCP_NODELAY     0x0001
#define TCP_BSDURGENT   0x7000

/*
 * Address families.
 */
#define AF_UNSPEC       0               /* unspecified */
#define AF_UNIX         1               /* local to host (pipes, portals) */
#define AF_INET         2               /* internetwork: UDP, TCP, etc. */
#define AF_IMPLINK      3               /* arpanet imp addresses */
#define AF_PUP          4               /* pup protocols: e.g. BSP */
#define AF_CHAOS        5               /* mit CHAOS protocols */
#define AF_IPX          6               /* IPX and SPX */
#define AF_NS           6               /* XEROX NS protocols */
#define AF_ISO          7               /* ISO protocols */
#define AF_OSI          AF_ISO          /* OSI is ISO */
#define AF_ECMA         8               /* european computer manufacturers */
#define AF_DATAKIT      9               /* datakit protocols */
#define AF_CCITT        10              /* CCITT protocols, X.25 etc */
#define AF_SNA          11              /* IBM SNA */
#define AF_DECnet       12              /* DECnet */
#define AF_DLI          13              /* Direct data link interface */
#define AF_LAT          14              /* LAT */
#define AF_HYLINK       15              /* NSC Hyperchannel */
#define AF_APPLETALK    16              /* AppleTalk */
#define AF_NETBIOS      17              /* NetBios-style addresses */
#define AF_VOICEVIEW    18              /* VoiceView */

#define AF_MAX          19

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
        u_short sa_family;              /* address family */
        char    sa_data[14];            /* up to 14 bytes of direct address */
};

/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
        u_short sp_family;              /* address family */
        u_short sp_protocol;            /* protocol */
};

/*
 * Protocol families, same as address families for now.
 */
#define PF_UNSPEC       AF_UNSPEC
#define PF_UNIX         AF_UNIX
#define PF_INET         AF_INET
#define PF_IMPLINK      AF_IMPLINK
#define PF_PUP          AF_PUP
#define PF_CHAOS        AF_CHAOS
#define PF_NS           AF_NS
#define PF_IPX          AF_IPX
#define PF_ISO          AF_ISO
#define PF_OSI          AF_OSI
#define PF_ECMA         AF_ECMA
#define PF_DATAKIT      AF_DATAKIT
#define PF_CCITT        AF_CCITT
#define PF_SNA          AF_SNA
#define PF_DECnet       AF_DECnet
#define PF_DLI          AF_DLI
#define PF_LAT          AF_LAT
#define PF_HYLINK       AF_HYLINK
#define PF_APPLETALK    AF_APPLETALK
#define PF_VOICEVIEW    AF_VOICEVIEW

#define PF_MAX          AF_MAX

/*
 * Structure used for manipulating linger option.
 */
struct  linger {
        u_short l_onoff;                /* option on/off */
        u_short l_linger;               /* linger time */
};

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define SOL_SOCKET      0xffff          /* options for socket level */

/*
 * Maximum queue length specifiable by listen.
 */
#define SOMAXCONN       5

#define MSG_OOB         0x1             /* process out-of-band data */
#define MSG_PEEK        0x2             /* peek at incoming message */
#define MSG_DONTROUTE   0x4             /* send without using routing tables */

#define MSG_MAXIOVLEN   16

#define MSG_PARTIAL     0x8000          /* partial send or recv for message xport */

/*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 */
#define MAXGETHOSTSTRUCT        1024

/*
 * Define flags to be used with the WSAAsyncSelect() call.
 */
#define FD_READ         0x01
#define FD_WRITE        0x02
#define FD_OOB          0x04
#define FD_ACCEPT       0x08
#define FD_CONNECT      0x10
#define FD_CLOSE        0x20

/*
 * All Windows Sockets error constants are biased by WSABASEERR from
 * the "normal"
 */
#define WSABASEERR              10000
/*
 * Windows Sockets definitions of regular Microsoft C error constants
 */
#define WSAEINTR                (WSABASEERR+4)
#define WSAEBADF                (WSABASEERR+9)
#define WSAEACCES               (WSABASEERR+13)
#define WSAEFAULT               (WSABASEERR+14)
#define WSAEINVAL               (WSABASEERR+22)
#define WSAEMFILE               (WSABASEERR+24)

/*
 * Windows Sockets definitions of regular Berkeley error constants
 */
#define WSAEWOULDBLOCK          (WSABASEERR+35)
#define WSAEINPROGRESS          (WSABASEERR+36)
#define WSAEALREADY             (WSABASEERR+37)
#define WSAENOTSOCK             (WSABASEERR+38)
#define WSAEDESTADDRREQ         (WSABASEERR+39)
#define WSAEMSGSIZE             (WSABASEERR+40)
#define WSAEPROTOTYPE           (WSABASEERR+41)
#define WSAENOPROTOOPT          (WSABASEERR+42)
#define WSAEPROTONOSUPPORT      (WSABASEERR+43)
#define WSAESOCKTNOSUPPORT      (WSABASEERR+44)
#define WSAEOPNOTSUPP           (WSABASEERR+45)
#define WSAEPFNOSUPPORT         (WSABASEERR+46)
#define WSAEAFNOSUPPORT         (WSABASEERR+47)
#define WSAEADDRINUSE           (WSABASEERR+48)
#define WSAEADDRNOTAVAIL        (WSABASEERR+49)
#define WSAENETDOWN             (WSABASEERR+50)
#define WSAENETUNREACH          (WSABASEERR+51)
#define WSAENETRESET            (WSABASEERR+52)
#define WSAECONNABORTED         (WSABASEERR+53)
#define WSAECONNRESET           (WSABASEERR+54)
#define WSAENOBUFS              (WSABASEERR+55)
#define WSAEISCONN              (WSABASEERR+56)
#define WSAENOTCONN             (WSABASEERR+57)
#define WSAESHUTDOWN            (WSABASEERR+58)
#define WSAETOOMANYREFS         (WSABASEERR+59)
#define WSAETIMEDOUT            (WSABASEERR+60)
#define WSAECONNREFUSED         (WSABASEERR+61)
#define WSAELOOP                (WSABASEERR+62)
#define WSAENAMETOOLONG         (WSABASEERR+63)
#define WSAEHOSTDOWN            (WSABASEERR+64)
#define WSAEHOSTUNREACH         (WSABASEERR+65)
#define WSAENOTEMPTY            (WSABASEERR+66)
#define WSAEPROCLIM             (WSABASEERR+67)
#define WSAEUSERS               (WSABASEERR+68)
#define WSAEDQUOT               (WSABASEERR+69)
#define WSAESTALE               (WSABASEERR+70)
#define WSAEREMOTE              (WSABASEERR+71)

#define WSAEDISCON              (WSABASEERR+101)

/*
 * Extended Windows Sockets error constant definitions
 */
#define WSASYSNOTREADY          (WSABASEERR+91)
#define WSAVERNOTSUPPORTED      (WSABASEERR+92)
#define WSANOTINITIALISED       (WSABASEERR+93)

/*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 */

#define h_errno         WSAGetLastError()

/* Authoritative Answer: Host not found */
#define WSAHOST_NOT_FOUND       (WSABASEERR+1001)
#define HOST_NOT_FOUND          WSAHOST_NOT_FOUND

/* Non-Authoritative: Host not found, or SERVERFAIL */
#define WSATRY_AGAIN            (WSABASEERR+1002)
#define TRY_AGAIN               WSATRY_AGAIN

/* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
#define WSANO_RECOVERY          (WSABASEERR+1003)
#define NO_RECOVERY             WSANO_RECOVERY

/* Valid name, no data record of requested type */
#define WSANO_DATA              (WSABASEERR+1004)
#define NO_DATA                 WSANO_DATA

/* no address, look for MX record */
#define WSANO_ADDRESS           WSANO_DATA
#define NO_ADDRESS              WSANO_ADDRESS

/*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These are commented out in Windows NT to avoid conflicts with errno.h.
 * Use the WSA constants instead.
 */
#if 0
#define EWOULDBLOCK             WSAEWOULDBLOCK
#define EINPROGRESS             WSAEINPROGRESS
#define EALREADY                WSAEALREADY
#define ENOTSOCK                WSAENOTSOCK
#define EDESTADDRREQ            WSAEDESTADDRREQ
#define EMSGSIZE                WSAEMSGSIZE
#define EPROTOTYPE              WSAEPROTOTYPE
#define ENOPROTOOPT             WSAENOPROTOOPT
#define EPROTONOSUPPORT         WSAEPROTONOSUPPORT
#define ESOCKTNOSUPPORT         WSAESOCKTNOSUPPORT
#define EOPNOTSUPP              WSAEOPNOTSUPP
#define EPFNOSUPPORT            WSAEPFNOSUPPORT
#define EAFNOSUPPORT            WSAEAFNOSUPPORT
#define EADDRINUSE              WSAEADDRINUSE
#define EADDRNOTAVAIL           WSAEADDRNOTAVAIL
#define ENETDOWN                WSAENETDOWN
#define ENETUNREACH             WSAENETUNREACH
#define ENETRESET               WSAENETRESET
#define ECONNABORTED            WSAECONNABORTED
#define ECONNRESET              WSAECONNRESET
#define ENOBUFS                 WSAENOBUFS
#define EISCONN                 WSAEISCONN
#define ENOTCONN                WSAENOTCONN
#define ESHUTDOWN               WSAESHUTDOWN
#define ETOOMANYREFS            WSAETOOMANYREFS
#define ETIMEDOUT               WSAETIMEDOUT
#define ECONNREFUSED            WSAECONNREFUSED
#define ELOOP                   WSAELOOP
#define ENAMETOOLONG            WSAENAMETOOLONG
#define EHOSTDOWN               WSAEHOSTDOWN
#define EHOSTUNREACH            WSAEHOSTUNREACH
#define ENOTEMPTY               WSAENOTEMPTY
#define EPROCLIM                WSAEPROCLIM
#define EUSERS                  WSAEUSERS
#define EDQUOT                  WSAEDQUOT
#define ESTALE                  WSAESTALE
#define EREMOTE                 WSAEREMOTE
#endif

/* Socket function prototypes */

#ifdef __cplusplus
extern "C" {
#endif

SOCKET PASCAL FAR accept (SOCKET s, struct sockaddr FAR *addr,
                          int FAR *addrlen);

int PASCAL FAR bind (SOCKET s, const struct sockaddr FAR *addr, int namelen);

int PASCAL FAR closesocket (SOCKET s);

int PASCAL FAR connect (SOCKET s, const struct sockaddr FAR *name, int namelen);

int PASCAL FAR ioctlsocket (SOCKET s, long cmd, u_long FAR *argp);

int PASCAL FAR getpeername (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockname (SOCKET s, struct sockaddr FAR *name,
                            int FAR * namelen);

int PASCAL FAR getsockopt (SOCKET s, int level, int optname,
                           char FAR * optval, int FAR *optlen);

u_long PASCAL FAR htonl (u_long hostlong);

u_short PASCAL FAR htons (u_short hostshort);

unsigned long PASCAL FAR inet_addr (const char FAR * cp);

char FAR * PASCAL FAR inet_ntoa (struct in_addr in);

int PASCAL FAR listen (SOCKET s, int backlog);

u_long PASCAL FAR ntohl (u_long netlong);

u_short PASCAL FAR ntohs (u_short netshort);

int PASCAL FAR recv (SOCKET s, char FAR * buf, int len, int flags);

int PASCAL FAR recvfrom (SOCKET s, char FAR * buf, int len, int flags,
                         struct sockaddr FAR *from, int FAR * fromlen);

#if 0
int PASCAL FAR select (int nfds, fd_set FAR *readfds, fd_set FAR *writefds,
                       fd_set FAR *exceptfds, const struct timeval FAR *timeout);
#endif

int PASCAL FAR send (SOCKET s, const char FAR * buf, int len, int flags);

int PASCAL FAR sendto (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

int PASCAL FAR setsockopt (SOCKET s, int level, int optname,
                           const char FAR * optval, int optlen);

int PASCAL FAR shutdown (SOCKET s, int how);

SOCKET PASCAL FAR socket (int af, int type, int protocol);

/* Database function prototypes */

struct hostent FAR * PASCAL FAR gethostbyaddr(const char FAR * addr,
                                              int len, int type);

struct hostent FAR * PASCAL FAR gethostbyname(const char FAR * name);

int PASCAL FAR gethostname (char FAR * name, int namelen);

struct servent FAR * PASCAL FAR getservbyport(int port, const char FAR * proto);

struct servent FAR * PASCAL FAR getservbyname(const char FAR * name,
                                              const char FAR * proto);

struct protoent FAR * PASCAL FAR getprotobynumber(int proto);

struct protoent FAR * PASCAL FAR getprotobyname(const char FAR * name);

#ifdef __cplusplus
}
#endif

/* Microsoft Windows Extended data types */
typedef struct sockaddr SOCKADDR;
typedef struct sockaddr *PSOCKADDR;
typedef struct sockaddr FAR *LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in *PSOCKADDR_IN;
typedef struct sockaddr_in FAR *LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger *PLINGER;
typedef struct linger FAR *LPLINGER;

typedef struct in_addr IN_ADDR;
typedef struct in_addr *PIN_ADDR;
typedef struct in_addr FAR *LPIN_ADDR;

typedef struct fd_set FD_SET;
typedef struct fd_set *PFD_SET;
typedef struct fd_set FAR *LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent *PHOSTENT;
typedef struct hostent FAR *LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent *PSERVENT;
typedef struct servent FAR *LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent *PPROTOENT;
typedef struct protoent FAR *LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval *PTIMEVAL;
typedef struct timeval FAR *LPTIMEVAL;

#endif  /* _WINSOCKAPI_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\vregset.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// vregset.h: header file for video register-setting interpreter
//

//
// registers & subregisters
//
#define MISC_OUTPUT	0x3C2

#define SC_INDEX		0x3C4
#define SC_DATA			0x3C5
#define SYNC_RESET		0
#define MAP_MASK		2
#define MEMORY_MODE		4

#define GC_INDEX		0x3CE
#define GC_DATA			0x3CF
#define READ_MAP		4
#define GRAPHICS_MODE	5
#define MISCELLANOUS	6

#define CRTC_INDEX		0x3D4
#define CRTC_DATA		0x3D5
#define MAX_SCAN_LINE	9
#define UNDERLINE		0x14
#define	MODE_CONTROL	0x17

//
// register-set commands
//
#define VRS_END			0
#define VRS_BYTE_OUT	1
#define VRS_BYTE_RMW	2
#define VRS_WORD_OUT	3

void VideoRegisterSet (int *pregset);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\net_mp.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_mpath.h

int  MPATH_Init (void);
void MPATH_Shutdown (void);
void MPATH_Listen (qboolean state);
int  MPATH_OpenSocket (int port);
int  MPATH_CloseSocket (int socket);
int  MPATH_Connect (int socket, struct qsockaddr *addr);
int  MPATH_CheckNewConnections (void);
int  MPATH_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  MPATH_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  MPATH_Broadcast (int socket, byte *buf, int len);
char *MPATH_AddrToString (struct qsockaddr *addr);
int  MPATH_StringToAddr (char *string, struct qsockaddr *addr);
int  MPATH_GetSocketAddr (int socket, struct qsockaddr *addr);
int  MPATH_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  MPATH_GetAddrFromName (char *name, struct qsockaddr *addr);
int  MPATH_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  MPATH_GetSocketPort (struct qsockaddr *addr);
int  MPATH_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\quakeasm.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// quakeasm.h: general asm header file
//

//#define GLQUAKE	1

#if defined(_WIN32) && !defined(WINDED)

#if defined(_M_IX86)
#define __i386__	1
#endif

#endif

#ifdef NO_ASSEMBLY
#define id386 0
#else
#ifdef __i386__
#define id386	1
#else
#define id386	0
#endif
#endif // NO_ASSEMBLY

// !!! must be kept the same as in d_iface.h !!!
#define TRANSPARENT_COLOR	255

#ifndef NeXT
#ifndef GLQUAKE
	.extern C(d_zistepu)
	.extern C(d_pzbuffer)
	.extern C(d_zistepv)
	.extern C(d_zrowbytes)
	.extern C(d_ziorigin)
	.extern C(r_turb_s)
	.extern C(r_turb_t)
	.extern C(r_turb_pdest)
	.extern C(r_turb_spancount)
	.extern C(r_turb_turb)
	.extern C(r_turb_pbase)
	.extern C(r_turb_sstep)
	.extern C(r_turb_tstep)
	.extern	C(r_bmodelactive)
	.extern	C(d_sdivzstepu)
	.extern	C(d_tdivzstepu)
	.extern	C(d_sdivzstepv)
	.extern	C(d_tdivzstepv)
	.extern	C(d_sdivzorigin)
	.extern	C(d_tdivzorigin)
	.extern	C(sadjust)
	.extern	C(tadjust)
	.extern	C(bbextents)
	.extern	C(bbextentt)
	.extern	C(cacheblock)
	.extern	C(d_viewbuffer)
	.extern	C(cachewidth)
	.extern	C(d_pzbuffer)
	.extern	C(d_zrowbytes)
	.extern	C(d_zwidth)
	.extern C(d_scantable)
	.extern C(r_lightptr)
	.extern C(r_numvblocks)
	.extern C(prowdestbase)
	.extern C(pbasesource)
	.extern C(r_lightwidth)
	.extern C(lightright)
	.extern C(lightrightstep)
	.extern C(lightdeltastep)
	.extern C(lightdelta)
	.extern C(lightright)
	.extern C(lightdelta)
	.extern C(sourcetstep)
	.extern C(surfrowbytes)
	.extern C(lightrightstep)
	.extern C(lightdeltastep)
	.extern C(r_sourcemax)
	.extern C(r_stepback)
	.extern C(colormap)
	.extern C(blocksize)
	.extern C(sourcesstep)
	.extern C(lightleft)
	.extern C(blockdivshift)
	.extern C(blockdivmask)
	.extern C(lightleftstep)
	.extern C(r_origin)
	.extern C(r_ppn)
	.extern C(r_pup)
	.extern C(r_pright)
	.extern C(ycenter)
	.extern C(xcenter)
	.extern C(d_vrectbottom_particle)
	.extern C(d_vrectright_particle)
	.extern C(d_vrecty)
	.extern C(d_vrectx)
	.extern C(d_pix_shift)
	.extern C(d_pix_min)
	.extern C(d_pix_max)
	.extern C(d_y_aspect_shift)
	.extern C(screenwidth)
	.extern C(r_leftclipped)
	.extern C(r_leftenter)
	.extern C(r_rightclipped)
	.extern C(r_rightenter)
	.extern C(modelorg)
	.extern C(xscale)
	.extern C(r_refdef)
	.extern C(yscale)
	.extern C(r_leftexit)
	.extern C(r_rightexit)
	.extern C(r_lastvertvalid)
	.extern C(cacheoffset)
	.extern C(newedges)
	.extern C(removeedges)
	.extern C(r_pedge)
	.extern C(r_framecount)
	.extern C(r_u1)
	.extern C(r_emitted)
	.extern C(edge_p)
	.extern C(surface_p)
	.extern C(surfaces)
	.extern C(r_lzi1)
	.extern C(r_v1)
	.extern C(r_ceilv1)
	.extern C(r_nearzi)
	.extern C(r_nearzionly)
	.extern C(edge_aftertail)
	.extern C(edge_tail)
	.extern C(current_iv)
	.extern C(edge_head_u_shift20)
	.extern C(span_p)
	.extern C(edge_head)
	.extern C(fv)
	.extern C(edge_tail_u_shift20)
	.extern C(r_apverts)
	.extern C(r_anumverts)
	.extern C(aliastransform)
	.extern C(r_avertexnormals)
	.extern C(r_plightvec)
	.extern C(r_ambientlight)
	.extern C(r_shadelight)
	.extern C(aliasxcenter)
	.extern C(aliasycenter)
	.extern C(a_sstepxfrac)
	.extern C(r_affinetridesc)
	.extern C(acolormap)
	.extern C(d_pcolormap)
	.extern C(r_affinetridesc)
	.extern C(d_sfrac)
	.extern C(d_ptex)
	.extern C(d_pedgespanpackage)
	.extern C(d_tfrac)
	.extern C(d_light)
	.extern C(d_zi)
	.extern C(d_pdest)
	.extern C(d_pz)
	.extern C(d_aspancount)
	.extern C(erroradjustup)
	.extern C(errorterm)
	.extern C(d_xdenom)
	.extern C(r_p0)
	.extern C(r_p1)
	.extern C(r_p2)
	.extern C(a_tstepxfrac)
	.extern C(r_sstepx)
	.extern C(r_tstepx)
	.extern C(a_ststepxwhole)
	.extern C(zspantable)
	.extern C(skintable)
	.extern C(r_zistepx)
	.extern C(erroradjustdown)
	.extern C(d_countextrastep)
	.extern C(ubasestep)
	.extern C(a_ststepxwhole)
	.extern C(a_tstepxfrac)
	.extern C(r_lstepx)
	.extern C(a_spans)
	.extern C(erroradjustdown)
	.extern C(d_pdestextrastep)
	.extern C(d_pzextrastep)
	.extern C(d_sfracextrastep)
	.extern C(d_ptexextrastep)
	.extern C(d_countextrastep)
	.extern C(d_tfracextrastep)
	.extern C(d_lightextrastep)
	.extern C(d_ziextrastep)
	.extern C(d_pdestbasestep)
	.extern C(d_pzbasestep)
	.extern C(d_sfracbasestep)
	.extern C(d_ptexbasestep)
	.extern C(ubasestep)
	.extern C(d_tfracbasestep)
	.extern C(d_lightbasestep)
	.extern C(d_zibasestep)
	.extern C(zspantable)
	.extern C(r_lstepy)
	.extern C(r_sstepy)
	.extern C(r_tstepy)
	.extern C(r_zistepy)
	.extern C(D_PolysetSetEdgeTable)
	.extern C(D_RasterizeAliasPolySmooth)

	.extern float_point5
	.extern Float2ToThe31nd
	.extern izistep
	.extern izi
	.extern FloatMinus2ToThe31nd
	.extern float_1
	.extern float_particle_z_clip
	.extern float_minus_1
	.extern float_0
	.extern fp_16
	.extern fp_64k
	.extern fp_1m
	.extern fp_1m_minus_1
	.extern fp_8 
	.extern entryvec_table
	.extern advancetable
	.extern sstep
	.extern tstep
	.extern pspantemp
	.extern counttemp
	.extern jumptemp
	.extern reciprocal_table
	.extern DP_Count
	.extern DP_u
	.extern DP_v
	.extern DP_32768
	.extern DP_Color
	.extern DP_Pix
	.extern DP_EntryTable
	.extern	pbase
	.extern s
	.extern t
	.extern sfracf
	.extern tfracf
	.extern snext
	.extern tnext
	.extern	spancountminus1
	.extern zi16stepu
	.extern sdivz16stepu
	.extern tdivz16stepu
	.extern	zi8stepu
	.extern sdivz8stepu
	.extern tdivz8stepu
	.extern reciprocal_table_16
	.extern entryvec_table_16
	.extern ceil_cw
	.extern single_cw
	.extern fp_64kx64k
	.extern pz
	.extern spr8entryvec_table
#endif

	.extern C(snd_scaletable)
	.extern C(paintbuffer)
	.extern C(snd_linear_count)
	.extern C(snd_p)
	.extern C(snd_vol)
	.extern C(snd_out)
	.extern C(vright)
	.extern C(vup)
	.extern C(vpn)
	.extern C(BOPS_Error)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\vgamodes.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
//
// vgamodes.h: VGA mode set tables
//

#include "vregset.h"

int		VGA_InitMode (viddef_t *vid, vmode_t *pcurrentmode);
void	VGA_SwapBuffers (viddef_t *vid, vmode_t *pcurrentmode, vrect_t *rects);
void	VGA_SetPalette (viddef_t *vid, vmode_t *pcurrentmode,
						unsigned char *pal);

///////////////////////////////////////////////////////////////////////////
// the following base mode descriptors plus extra data together provide all
// the data needed to do VGA mode sets
///////////////////////////////////////////////////////////////////////////

typedef struct {
	int		vidbuffer;
	int		*pregset;
} vextra_t;

int	vrsnull[] = {
	VRS_END,
};

int vrs320x200x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_BYTE_OUT, SC_INDEX, MEMORY_MODE,
	VRS_BYTE_RMW, SC_DATA, ~0x08, 0x04,
	VRS_BYTE_OUT, GC_INDEX, GRAPHICS_MODE,
	VRS_BYTE_RMW, GC_DATA, ~0x13, 0x00,
	VRS_BYTE_OUT, GC_INDEX, MISCELLANOUS,
	VRS_BYTE_RMW, GC_DATA, ~0x02, 0x00,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA, ~0x00, 0x40,

	VRS_END,
};

int vrs360x200x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_WORD_OUT, SC_INDEX, 0x0604,
	VRS_BYTE_OUT, MISC_OUTPUT, 0x67,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA,  ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA,  ~0x00, 0x40,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x6B00,
	VRS_WORD_OUT, CRTC_INDEX, 0x5901,
	VRS_WORD_OUT, CRTC_INDEX, 0x5A02,
	VRS_WORD_OUT, CRTC_INDEX, 0x8E03,
	VRS_WORD_OUT, CRTC_INDEX, 0x5E04,
	VRS_WORD_OUT, CRTC_INDEX, 0x8A05,
	VRS_WORD_OUT, CRTC_INDEX, 0x3013,

	VRS_END,
};

int vrs320x240x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_BYTE_OUT, SC_INDEX, MEMORY_MODE,
	VRS_BYTE_RMW, SC_DATA, ~0x08, 0x04,
	VRS_BYTE_OUT, GC_INDEX, GRAPHICS_MODE,
	VRS_BYTE_RMW, GC_DATA, ~0x13, 0x00,
	VRS_BYTE_OUT, GC_INDEX, MISCELLANOUS,
	VRS_BYTE_RMW, GC_DATA, ~0x02, 0x00,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x0D06,
	VRS_WORD_OUT, CRTC_INDEX, 0x3E07,
	VRS_WORD_OUT, CRTC_INDEX, 0x4109,
	VRS_WORD_OUT, CRTC_INDEX, 0xEA10,
	VRS_WORD_OUT, CRTC_INDEX, 0xAC11,
	VRS_WORD_OUT, CRTC_INDEX, 0xDF12,
	VRS_WORD_OUT, CRTC_INDEX, 0x0014,
	VRS_WORD_OUT, CRTC_INDEX, 0xE715,
	VRS_WORD_OUT, CRTC_INDEX, 0x0616,
	VRS_WORD_OUT, CRTC_INDEX, 0xE317,

	VRS_END,
};

int vrs360x240x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_WORD_OUT, SC_INDEX, 0x0604,
	VRS_BYTE_OUT, MISC_OUTPUT, 0xE7,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x6B00,
	VRS_WORD_OUT, CRTC_INDEX, 0x5901,
	VRS_WORD_OUT, CRTC_INDEX, 0x5A02,
	VRS_WORD_OUT, CRTC_INDEX, 0x8E03,
	VRS_WORD_OUT, CRTC_INDEX, 0x5E04,
	VRS_WORD_OUT, CRTC_INDEX, 0x8A05,
	VRS_WORD_OUT, CRTC_INDEX, 0x0D06,
	VRS_WORD_OUT, CRTC_INDEX, 0x3E07,
	VRS_WORD_OUT, CRTC_INDEX, 0x4109,
	VRS_WORD_OUT, CRTC_INDEX, 0xEA10,
	VRS_WORD_OUT, CRTC_INDEX, 0xAC11,
	VRS_WORD_OUT, CRTC_INDEX, 0xDF12,
	VRS_WORD_OUT, CRTC_INDEX, 0x3013,
	VRS_WORD_OUT, CRTC_INDEX, 0x0014,
	VRS_WORD_OUT, CRTC_INDEX, 0xE715,
	VRS_WORD_OUT, CRTC_INDEX, 0x0616,
	VRS_WORD_OUT, CRTC_INDEX, 0xE317,

	VRS_END,
};

int vrs320x350x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_BYTE_OUT, SC_INDEX, MEMORY_MODE,
	VRS_BYTE_RMW, SC_DATA, ~0x08, 0x04,
	VRS_BYTE_OUT, GC_INDEX, GRAPHICS_MODE,
	VRS_BYTE_RMW, GC_DATA, ~0x10, 0x00,
	VRS_BYTE_OUT, GC_INDEX, MISCELLANOUS,
	VRS_BYTE_RMW, GC_DATA, ~0x02, 0x00,
	VRS_BYTE_OUT, MISC_OUTPUT, 0xA3,	// 350-scan-line scan rate

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// stop scanning each line twice
//
	VRS_BYTE_OUT, CRTC_INDEX, MAX_SCAN_LINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x1F, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA, ~0x00, 0x40,

//
// set the vertical counts for 350-scan-line mode
//
	VRS_WORD_OUT, CRTC_INDEX, 0xBF06,
	VRS_WORD_OUT, CRTC_INDEX, 0x1F07,
	VRS_WORD_OUT, CRTC_INDEX, 0x8310,
	VRS_WORD_OUT, CRTC_INDEX, 0x8511,
	VRS_WORD_OUT, CRTC_INDEX, 0x5D12,
	VRS_WORD_OUT, CRTC_INDEX, 0x6315,
	VRS_WORD_OUT, CRTC_INDEX, 0xBA16,

	VRS_END,
};

int vrs360x350x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_WORD_OUT, SC_INDEX, 0x0604,
	VRS_BYTE_OUT, MISC_OUTPUT, 0xA7,	// 350-scan-line scan rate

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// stop scanning each line twice
//
	VRS_BYTE_OUT, CRTC_INDEX, MAX_SCAN_LINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x1F, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA, ~0x00, 0x40,

//
// set the vertical counts for 350-scan-line mode and 360 pixels across
//
	VRS_WORD_OUT, CRTC_INDEX, 0x6B00,
	VRS_WORD_OUT, CRTC_INDEX, 0x5901,
	VRS_WORD_OUT, CRTC_INDEX, 0x5A02,
	VRS_WORD_OUT, CRTC_INDEX, 0x8E03,
	VRS_WORD_OUT, CRTC_INDEX, 0x5E04,
	VRS_WORD_OUT, CRTC_INDEX, 0x8A05,
	VRS_WORD_OUT, CRTC_INDEX, 0xBF06,
	VRS_WORD_OUT, CRTC_INDEX, 0x1F07,
	VRS_WORD_OUT, CRTC_INDEX, 0x8310,
	VRS_WORD_OUT, CRTC_INDEX, 0x8511,
	VRS_WORD_OUT, CRTC_INDEX, 0x5D12,
	VRS_WORD_OUT, CRTC_INDEX, 0x3013,
	VRS_WORD_OUT, CRTC_INDEX, 0x6315,
	VRS_WORD_OUT, CRTC_INDEX, 0xBA16,

	VRS_END,
};

int vrs320x400x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,


	VRS_BYTE_OUT, SC_INDEX, MEMORY_MODE,
	VRS_BYTE_RMW, SC_DATA, ~0x08, 0x04,
	VRS_BYTE_OUT, GC_INDEX, GRAPHICS_MODE,
	VRS_BYTE_RMW, GC_DATA, ~0x10, 0x00,
	VRS_BYTE_OUT, GC_INDEX, MISCELLANOUS,
	VRS_BYTE_RMW, GC_DATA, ~0x02, 0x00,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// stop scanning each line twice
//
	VRS_BYTE_OUT, CRTC_INDEX, MAX_SCAN_LINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x1F, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA, ~0x00, 0x40,

	VRS_END,
};

int vrs360x400x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_WORD_OUT, SC_INDEX, 0x0604,
	VRS_BYTE_OUT, MISC_OUTPUT, 0x67,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// stop scanning each line twice
//
	VRS_BYTE_OUT, CRTC_INDEX, MAX_SCAN_LINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x1F, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA,  ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA,  ~0x00, 0x40,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x6B00,
	VRS_WORD_OUT, CRTC_INDEX, 0x5901,
	VRS_WORD_OUT, CRTC_INDEX, 0x5A02,
	VRS_WORD_OUT, CRTC_INDEX, 0x8E03,
	VRS_WORD_OUT, CRTC_INDEX, 0x5E04,
	VRS_WORD_OUT, CRTC_INDEX, 0x8A05,
	VRS_WORD_OUT, CRTC_INDEX, 0x3013,

	VRS_END,
};

int vrs320x480x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_BYTE_OUT, SC_INDEX, MEMORY_MODE,
	VRS_BYTE_RMW, SC_DATA, ~0x08, 0x04,
	VRS_BYTE_OUT, GC_INDEX, GRAPHICS_MODE,
	VRS_BYTE_RMW, GC_DATA, ~0x10, 0x00,
	VRS_BYTE_OUT, GC_INDEX, MISCELLANOUS,
	VRS_BYTE_RMW, GC_DATA, ~0x02, 0x00,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// stop scanning each line twice
//
	VRS_BYTE_OUT, CRTC_INDEX, MAX_SCAN_LINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x1F, 0x00,

//
// change the CRTC from doubleword to byte mode
//
	VRS_BYTE_OUT, CRTC_INDEX, UNDERLINE,
	VRS_BYTE_RMW, CRTC_DATA, ~0x40, 0x00,
	VRS_BYTE_OUT, CRTC_INDEX, MODE_CONTROL,
	VRS_BYTE_RMW, CRTC_DATA, ~0x00, 0x40,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x0D06,
	VRS_WORD_OUT, CRTC_INDEX, 0x3E07,
	VRS_WORD_OUT, CRTC_INDEX, 0xEA10,
	VRS_WORD_OUT, CRTC_INDEX, 0xAC11,
	VRS_WORD_OUT, CRTC_INDEX, 0xDF12,
	VRS_WORD_OUT, CRTC_INDEX, 0xE715,
	VRS_WORD_OUT, CRTC_INDEX, 0x0616,

	VRS_END,
};

int vrs360x480x256planar[] = {
//
// switch to linear, non-chain4 mode
//
	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  1,

	VRS_WORD_OUT, SC_INDEX, 0x0604,
	VRS_BYTE_OUT, MISC_OUTPUT, 0xE7,

	VRS_BYTE_OUT, SC_INDEX, SYNC_RESET,
	VRS_BYTE_OUT, SC_DATA,  3,

//
// unprotect CRTC0 through CRTC0
//
	VRS_BYTE_OUT, CRTC_INDEX, 0x11,
	VRS_BYTE_RMW, CRTC_DATA, ~0x80, 0x00,

//
// set up the CRT Controller
//
	VRS_WORD_OUT, CRTC_INDEX, 0x6B00,
	VRS_WORD_OUT, CRTC_INDEX, 0x5901,
	VRS_WORD_OUT, CRTC_INDEX, 0x5A02,
	VRS_WORD_OUT, CRTC_INDEX, 0x8E03,
	VRS_WORD_OUT, CRTC_INDEX, 0x5E04,
	VRS_WORD_OUT, CRTC_INDEX, 0x8A05,
	VRS_WORD_OUT, CRTC_INDEX, 0x0D06,
	VRS_WORD_OUT, CRTC_INDEX, 0x3E07,
	VRS_WORD_OUT, CRTC_INDEX, 0x4009,
	VRS_WORD_OUT, CRTC_INDEX, 0xEA10,
	VRS_WORD_OUT, CRTC_INDEX, 0xAC11,
	VRS_WORD_OUT, CRTC_INDEX, 0xDF12,
	VRS_WORD_OUT, CRTC_INDEX, 0x3013,
	VRS_WORD_OUT, CRTC_INDEX, 0x0014,
	VRS_WORD_OUT, CRTC_INDEX, 0xE715,
	VRS_WORD_OUT, CRTC_INDEX, 0x0616,
	VRS_WORD_OUT, CRTC_INDEX, 0xE317,

	VRS_END,
};

//
// extra VGA-specific data for vgavidmodes
//
vextra_t	extra320x200x256linear = {
	1, vrsnull
};
vextra_t	extra320x200x256planar = {
	1, vrs320x200x256planar
};
vextra_t	extra360x200x256planar = {
	1, vrs360x200x256planar
};
vextra_t	extra320x240x256planar = {
	1, vrs320x240x256planar
};
vextra_t	extra360x240x256planar = {
	1, vrs360x240x256planar
};
vextra_t	extra320x350x256planar = {
	1, vrs320x350x256planar
};
vextra_t	extra360x350x256planar = {
	1, vrs360x350x256planar
};
vextra_t	extra320x400x256planar = {
	1, vrs320x400x256planar
};
vextra_t	extra360x400x256planar = {
	1, vrs360x400x256planar
};
vextra_t	extra320x480x256planar = {
	1, vrs320x480x256planar
};
vextra_t	extra360x480x256planar = {
	1, vrs360x480x256planar
};

//
// base mode descriptors, in ascending order of number of pixels
//

vmode_t	vgavidmodes[] = {
{
	NULL,
	"320x200", "    ***** standard VGA modes *****    ",
	320, 200, (200.0/320.0)*(320.0/240.0), 320, 0, 1, &extra320x200x256linear,
	VGA_InitMode, VGA_SwapBuffers, VGA_SetPalette,
	VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"320x200", "    ***** Mode X-style modes *****    ",
	320, 200, (200.0/320.0)*(320.0/240.0), 320, 1, 1, &extra320x200x256planar,
	VGA_InitMode, VGA_SwapBuffers, VGA_SetPalette,
	VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"360x200", NULL, 360, 200, (200.0/360.0)*(320.0/240.0),
	384, 1, 1, &extra360x200x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"320x240", NULL, 320, 240, (240.0/320.0)*(320.0/240.0),
	320, 1, 1, &extra320x240x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"360x240", NULL, 360, 240, (240.0/360.0)*(320.0/240.0),
	384, 1, 1, &extra360x240x256planar,
	VGA_InitMode, VGA_SwapBuffers, VGA_SetPalette,
	VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"320x350", NULL, 320, 350, (350.0/320.0)*(320.0/240.0),
	320, 1, 1, &extra320x350x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"360x350", NULL, 360, 350, (350.0/360.0)*(320.0/240.0),
	384, 1, 1, &extra360x350x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"320x400", NULL, 320, 400, (400.0/320.0)*(320.0/240.0), 320,
	1, 1, &extra320x400x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"360x400", NULL, 360, 400, (400.0/360.0)*(320.0/240.0),
	384, 1, 1, &extra360x400x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"320x480", NULL, 320, 480, (480.0/320.0)*(320.0/240.0),
	320, 1, 1, &extra320x480x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
{
	NULL,
	"360x480", NULL, 360, 480, (480.0/360.0)*(320.0/240.0),
	384, 1, 1, &extra360x480x256planar, VGA_InitMode,
	VGA_SwapBuffers, 
	VGA_SetPalette, VGA_BeginDirectRect, VGA_EndDirectRect
},
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\vid_dos.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// vid_dos.h: header file for DOS-specific video stuff

typedef struct vmode_s {
	struct vmode_s	*pnext;
	char		*name;
	char		*header;
	unsigned	width;
	unsigned	height;
	float		aspect;
	unsigned	rowbytes;
	int			planar;
	int			numpages;
	void		*pextradata;
	int			(*setmode)(viddef_t *vid, struct vmode_s *pcurrentmode);
	void		(*swapbuffers)(viddef_t *vid, struct vmode_s *pcurrentmode,
							   vrect_t *rects);
	void		(*setpalette)(viddef_t *vid, struct vmode_s *pcurrentmode,
							  unsigned char *palette);
	void		(*begindirectrect)(viddef_t *vid, struct vmode_s *pcurrentmode,
								   int x, int y, byte *pbitmap, int width,
								   int height);
	void		(*enddirectrect)(viddef_t *vid, struct vmode_s *pcurrentmode,
								 int x, int y, int width, int height);
} vmode_t;

// vid_wait settings
#define VID_WAIT_NONE			0
#define VID_WAIT_VSYNC			1
#define VID_WAIT_DISPLAY_ENABLE	2

extern int		numvidmodes;
extern vmode_t	*pvidmodes;

extern int		VGA_width, VGA_height, VGA_rowbytes, VGA_bufferrowbytes;
extern byte		*VGA_pagebase;
extern vmode_t	*VGA_pcurmode;

extern cvar_t	vid_wait;
extern cvar_t	vid_nopageflip;
extern cvar_t	_vid_wait_override;

extern unsigned char colormap256[32][256];

extern void	*vid_surfcache;
extern int	vid_surfcachesize;

void VGA_Init (void);
void VID_InitVESA (void);
void VID_InitExtra (void);
void VGA_WaitVsync (void);
void VGA_ClearVideoMem (int planar);
void VGA_SetPalette(viddef_t *vid, vmode_t *pcurrentmode, unsigned char *pal);
void VGA_SwapBuffersCopy (viddef_t *vid, vmode_t *pcurrentmode,
	vrect_t *rects);
qboolean VGA_FreeAndAllocVidbuffer (viddef_t *vid, int allocnewbuffer);
qboolean VGA_CheckAdequateMem (int width, int height, int rowbytes,
	int allocnewbuffer);
void VGA_BeginDirectRect (viddef_t *vid, struct vmode_s *pcurrentmode, int x,
	int y, byte *pbitmap, int width, int height);
void VGA_EndDirectRect (viddef_t *vid, struct vmode_s *pcurrentmode, int x,
	int y, int width, int height);
void VGA_UpdateLinearScreen (void *srcptr, void *destptr, int width,
	int height, int srcrowbytes, int destrowbytes);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\net_udp.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// net_udp.h

int  UDP_Init (void);
void UDP_Shutdown (void);
void UDP_Listen (qboolean state);
int  UDP_OpenSocket (int port);
int  UDP_CloseSocket (int socket);
int  UDP_Connect (int socket, struct qsockaddr *addr);
int  UDP_CheckNewConnections (void);
int  UDP_Read (int socket, byte *buf, int len, struct qsockaddr *addr);
int  UDP_Write (int socket, byte *buf, int len, struct qsockaddr *addr);
int  UDP_Broadcast (int socket, byte *buf, int len);
char *UDP_AddrToString (struct qsockaddr *addr);
int  UDP_StringToAddr (char *string, struct qsockaddr *addr);
int  UDP_GetSocketAddr (int socket, struct qsockaddr *addr);
int  UDP_GetNameFromAddr (struct qsockaddr *addr, char *name);
int  UDP_GetAddrFromName (char *name, struct qsockaddr *addr);
int  UDP_AddrCompare (struct qsockaddr *addr1, struct qsockaddr *addr2);
int  UDP_GetSocketPort (struct qsockaddr *addr);
int  UDP_SetSocketPort (struct qsockaddr *addr, int port);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\games\xquake\h\r_shared.h ===
/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
#ifndef GLQUAKE
// r_shared.h: general refresh-related stuff shared between the refresh and the
// driver

// FIXME: clean up and move into d_iface.h

#ifndef _R_SHARED_H_
#define _R_SHARED_H_

#define	MAXVERTS	16					// max points in a surface polygon
#define MAXWORKINGVERTS	(MAXVERTS+4)	// max points in an intermediate
										//  polygon (while processing)
// !!! if this is changed, it must be changed in d_ifacea.h too !!!
#define	MAXHEIGHT		1024
#define	MAXWIDTH		1280
#define MAXDIMENSION	((MAXHEIGHT > MAXWIDTH) ? MAXHEIGHT : MAXWIDTH)

#define SIN_BUFFER_SIZE	(MAXDIMENSION+CYCLE)

#define INFINITE_DISTANCE	0x10000		// distance that's always guaranteed to
										//  be farther away than anything in
										//  the scene

//===================================================================

extern void	R_DrawLine (polyvert_t *polyvert0, polyvert_t *polyvert1);

extern int		cachewidth;
extern pixel_t	*cacheblock;
extern int		screenwidth;

extern	float	pixelAspect;

extern int		r_drawnpolycount;

extern cvar_t	r_clearcolor;

extern int	sintable[SIN_BUFFER_SIZE];
extern int	intsintable[SIN_BUFFER_SIZE];

extern	vec3_t	vup, base_vup;
extern	vec3_t	vpn, base_vpn;
extern	vec3_t	vright, base_vright;
extern	entity_t		*currententity;

#define NUMSTACKEDGES		2400
#define	MINEDGES			NUMSTACKEDGES
#define NUMSTACKSURFACES	800
#define MINSURFACES			NUMSTACKSURFACES
#define	MAXSPANS			3000

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct espan_s
{
	int				u, v, count;
	struct espan_s	*pnext;
} espan_t;

// FIXME: compress, make a union if that will help
// insubmodel is only 1, flags is fewer than 32, spanstate could be a byte
typedef struct surf_s
{
	struct surf_s	*next;			// active surface stack in r_edge.c
	struct surf_s	*prev;			// used in r_edge.c for active surf stack
	struct espan_s	*spans;			// pointer to linked list of spans to draw
	int			key;				// sorting key (BSP order)
	int			last_u;				// set during tracing
	int			spanstate;			// 0 = not in span
									// 1 = in span
									// -1 = in inverted span (end before
									//  start)
	int			flags;				// currentface flags
	void		*data;				// associated data like msurface_t
	entity_t	*entity;
	float		nearzi;				// nearest 1/z on surface, for mipmapping
	qboolean	insubmodel;
	float		d_ziorigin, d_zistepu, d_zistepv;

	int			pad[2];				// to 64 bytes
} surf_t;

extern	surf_t	*surfaces, *surface_p, *surf_max;

// surfaces are generated in back to front order by the bsp, so if a surf
// pointer is greater than another one, it should be drawn in front
// surfaces[1] is the background, and is used as the active surface stack.
// surfaces[0] is a dummy, because index 0 is used to indicate no surface
//  attached to an edge_t

//===================================================================

extern vec3_t	sxformaxis[4];	// s axis transformed into viewspace
extern vec3_t	txformaxis[4];	// t axis transformed into viewspac

extern vec3_t	modelorg, base_modelorg;

extern	float	xcenter, ycenter;
extern	float	xscale, yscale;
extern	float	xscaleinv, yscaleinv;
extern	float	xscaleshrink, yscaleshrink;

extern	int d_lightstylevalue[256]; // 8.8 frac of base light value

extern void TransformVector (vec3_t in, vec3_t out);
extern void SetUpForLineScan(fixed8_t startvertu, fixed8_t startvertv,
	fixed8_t endvertu, fixed8_t endvertv);

extern int	r_skymade;
extern void R_MakeSky (void);

extern int	ubasestep, errorterm, erroradjustup, erroradjustdown;

// flags in finalvert_t.flags
#define ALIAS_LEFT_CLIP				0x0001
#define ALIAS_TOP_CLIP				0x0002
#define ALIAS_RIGHT_CLIP			0x0004
#define ALIAS_BOTTOM_CLIP			0x0008
#define ALIAS_Z_CLIP				0x0010
// !!! if this is changed, it must be changed in d_ifacea.h too !!!
#define ALIAS_ONSEAM				0x0020	// also defined in modelgen.h;
											//  must be kept in sync
#define ALIAS_XY_CLIP_MASK			0x000F

// !!! if this is changed, it must be changed in asm_draw.h too !!!
typedef struct edge_s
{
	fixed16_t		u;
	fixed16_t		u_step;
	struct edge_s	*prev, *next;
	unsigned short	surfs[2];
	struct edge_s	*nextremove;
	float			nearzi;
	medge_t			*owner;
} edge_t;

#endif	// _R_SHARED_H_

#endif	// GLQUAKE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AW\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	AW.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AW\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__234F8F73_B00F_4DE5_89D1_D12AA50FC7C1__INCLUDED_)
#define AFX_STDAFX_H__234F8F73_B00F_4DE5_89D1_D12AA50FC7C1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers



// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__234F8F73_B00F_4DE5_89D1_D12AA50FC7C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AWClasses\AWClasses.cpp ===
/*
	Copyright Microsoft 2001 - all rights reserved

  author:  sethmil

  Abstract:

	// AWClasses.cpp
	//
	// source file for class AWClasses.h
	//
	// contains a bunch of classes to use with the AW
	// board for testing xbox
	//
	// class CXBoxControlr uses an ActiveWire USB Board
	// to cycle power on the xbox


	// pin out
	//		IO/0 - output - controls AC power
	//		IO/1 - output - controls POWSW
	//		IO/2 - input  - POWON
*/

#include <windows.h>
#include "AWClasses.h"
#include <i2clib.h>
#include <stdio.h>




// default constructor
// protected constructor - does nothing
CXBoxControl::CXBoxControl() {}

// standard constructor
// this is the constructor that will
// be used to create the class object
CXBoxControl::CXBoxControl( DWORD dwDevNum )
{
	
	if( AW_OK != Open( dwDevNum ) )
	{
		return;
	}

	wEnable = ACPOWER | POWSW | EJTSW;
	if( AW_OK != EnablePort( wEnable ) )
	{
		Close();
		return;
	}
	iDeviceNum = dwDevNum;
	SetSignalHigh( ACPOWER );
	SetSignalHigh( POWSW );
	SetSignalHigh( EJTSW );
}

// destructor
CXBoxControl::~CXBoxControl()
{
	CAWDevice::~CAWDevice();
}


// turns box power off (AC Main)
DWORD CXBoxControl::Unplug()
{
	wEnable = ACPOWER;
	EnablePort( wEnable );
	return SetSignalLow( ACPOWER );
}


// turns box power on (AC Main)
DWORD CXBoxControl::PlugIn()
{
	DWORD result = AW_OK;
	wEnable = ACPOWER | POWSW | EJTSW;
	EnablePort( wEnable );
	result = result | SetSignalHigh( ACPOWER );
	result = result |SetSignalHigh( POWSW );
	result = result | SetSignalHigh( EJTSW );
	return result;
}


// returns TRUE if the box is plugged in
BOOL CXBoxControl::PluggedIn()
{
	return SignalIsHigh( ACPOWER );
}


// BoxIsOn
// returns TRUE if POWON is asserted on the DUT
BOOL CXBoxControl::BoxIsOn()
{
	return SignalIsHigh( POWON );
}

// BoxIsOff()
// returns TRUE if the box is off
BOOL CXBoxControl::BoxIsOff()
{
	return !BoxIsOn();
}


// DeviceIsOpen
// returns TRUE if the AW device is open
BOOL CXBoxControl::DeviceIsOpen()
{
	return CAWDevice::DeviceIsOpen();
}


// ErrorMessage()
// returns a string version of the last error message
char* CXBoxControl::ErrorMessage()
{
	return CAWDevice::ErrorMessage();
}

// ErrorMessage( DWORD )
// returns a string version of the error message
char* CXBoxControl::ErrorMessage( const DWORD errcode )
{
	return CAWDevice::ErrorMessage( errcode );
}

// GetLastError
// returns the last error code
DWORD CXBoxControl::GetLastError()
{
	return CAWDevice::GetLastError();
}



// sets POWSW to LOW
// if POWSW is already LOW, does nothing
// if POWSW does not go low, returns an error.
// POWSW is pin IO/1
DWORD CXBoxControl::SetPOWSWLow()
{
	return SetSignalLow( POWSW );
}


// sets POWSW to HIGH
// if POWSW is already HIGH, does nothing
// if POWSW does not go high, returns an error
DWORD CXBoxControl::SetPOWSWHigh()
{
	return SetSignalHigh( POWSW );
}


// returns TRUE if POWSW signal is high
//
BOOL CXBoxControl::POWSWIsHigh()
{
	return SignalIsHigh( POWSW );
}


// Cycles DUT power by pulsing
// the POWSW line
DWORD CXBoxControl::CyclePower( const DWORD dwPulseWidth )
{
	DWORD dwResult;

	// check to see if POWSW is HIGH
	dwResult = SetPOWSWHigh();
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}
	Sleep( 100 );

	// now cycle power
	dwResult = SetPOWSWLow();
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}
	Sleep( dwPulseWidth );
	dwResult = SetPOWSWHigh();
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	return AW_OK;
}

	



// BoxOn
// turns the box on
// if the box is already on, does nothing
// if the box does not turn on,
// returns an error code
DWORD CXBoxControl::BoxOn( const DWORD dwTimeOut )
{
	DWORD dwResult;
	DWORD dwStartTime;

	// check to make sure the box is plugged in
	if( !PluggedIn() )
	{
		PlugIn();
		Sleep(200);
	}
	// check to make sure we're starting
	// with POWSW high
	if( !POWSWIsHigh() )
	{
		if(AW_OK != (dwResult = SetPOWSWHigh()))
		{
			return dwResult;
		}
		Sleep( 200 );
	}

	// check to see if power is on
	if( BoxIsOn() )
	{
		return AW_OK;
	}

	// if box is off, we must turn it on
	dwResult = CyclePower( 100 );
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	dwStartTime = GetTickCount();

	// now wait for box to turn on
	while( !BoxIsOn() )
	{
		// check timeout
		if( (GetTickCount() - dwStartTime) > dwTimeOut )
		{
			SetLastError( AW_ERROR_TIMEOUT );
			return AW_ERROR_TIMEOUT;
		}
		Sleep(10);
	}

	return AW_OK;
}



		
// BoxOff
// turns the box off
// if the box is already off, does nothing
// if the box does not turn off within the timeout,
// returns an error code
DWORD CXBoxControl::BoxOff( const DWORD dwTimeOut )
{
	DWORD dwResult;
	DWORD dwStartTime;

	// check to make sure we're starting
	// with POWSW high
	if( !POWSWIsHigh() )
	{
		if(AW_OK != (dwResult = SetPOWSWHigh()))
		{
			return dwResult;
		}
		Sleep( 200 );
	}

	// check to see if power is off
	if( BoxIsOff() )
	{
		return AW_OK;
	}

	// if box is on, we must turn it off
	dwResult = CyclePower( 100 );
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	dwStartTime = GetTickCount();

	// now wait for box to turn on
	while( BoxIsOn() )
	{
		// check timeout
		if( (GetTickCount() - dwStartTime) > dwTimeOut )
		{
			SetLastError( AW_ERROR_TIMEOUT );
			return AW_ERROR_TIMEOUT;
		}
		Sleep(10);
	}

	return AW_OK;
}


// returns TRUE if 3.3V standby is high
BOOL CXBoxControl::STBYIsHigh()
{
	return SignalIsHigh( STANDBY );
}


// pulses the EJTSW signal
DWORD CXBoxControl::EjectSwitch( const DWORD dwPulseWidth )
{
	// check to make sure EJTSW is high
	if( !SignalIsHigh( EJTSW ) )
	{
		SetSignalHigh( EJTSW );
		Sleep( 200 );
	}

	// now pulse the signal
	SetSignalLow( EJTSW );
	Sleep( dwPulseWidth );
	SetSignalHigh( EJTSW );

	return AW_OK;	

}

// closes the DVD - if the DVD is closed, does nothing
DWORD CXBoxControl::DVDClose()
{
	if( DVDIsClosed() )
	{
		return AW_OK;
	}

	EjectSwitch( 100 );

	if( DVDIsOpen() )
	{
		return AW_ERROR_HARDWARE;
	}

	return AW_OK;
}

// opens the DVD - if the DVD is open, does nothing
DWORD CXBoxControl::DVDOpen()
{
	if( DVDIsOpen() )
	{
		return AW_OK;
	}

	EjectSwitch( 100 );

	if( DVDIsClosed() )
	{
		return AW_ERROR_HARDWARE;
	}

	return AW_OK;
}

// returns TRUE if the DVD tray is open
BOOL CXBoxControl::DVDIsOpen()
{
	return DVDTrayOpen();
}

// returns TRUE if the DVD is in media detect state
BOOL CXBoxControl::DVDMediaDetect()
{
	WORD wData;
	InPort( &wData );

	// shift data so traystate bits are the 3 LSB's
	wData = wData >> 9;
	// mask out the traystate bits
	wData &= 0x0007;

	return ( wData == 0x0006 );	// Tray Open state
}

// return TRUE if the DVD is in NoMedia stata
BOOL CXBoxControl::DVDNoMedia()
{
	WORD wData;
	InPort( &wData );

	// shift data so traystate bits are the 3 LSB's
	wData = wData >> 9;
	// mask out the traystate bits
	wData &= 0x0007;

	return ( wData == 0x0004 );	// no media state
}

// returns TRUE if the DVD is in TRAYOPEN state
BOOL CXBoxControl::DVDTrayOpen()
{
	WORD wData;
	InPort( &wData );

	// shift data so traystate bits are the 3 LSB's
	wData = wData >> 9;
	// mask out the traystate bits
	wData &= 0x0007;

	return ( wData == 0x0001 );	// Tray Open state
}

// returns TRUE if the DVD is in CLOSED tray state
BOOL CXBoxControl::DVDTrayClosed()
{
	WORD wData;
	InPort( &wData );

	// shift data so traystate bits are the 3 LSB's
	wData = wData >> 9;
	// mask out the traystate bits
	wData &= 0x0007;

	return ( wData == 0x0000 );	// Tray Closed state
}

// returns TRUE if the DVD is closed
BOOL CXBoxControl::DVDIsClosed()
{
	WORD wData;
	InPort( &wData );

	// shift data so traystate bits are the 3 LSB's
	wData = wData >> 9;
	// mask out the traystate bits
	wData &= 0x0007;

	// tray closed, no media, and media detect states are
	// all valid
	if( (wData == 0x0000) || (wData == 0x0004) || (wData == 0x0006) )
	{
		return TRUE;
	}

	return FALSE;
}


// enables an output port
BOOL CXBoxControl::Enable( WORD wSignal )
{
	wEnable = wEnable | wSignal;
	return EnablePort( wEnable );
}


// disables an output prot
BOOL CXBoxControl::Disable( WORD wSignal )
{
	wEnable = wEnable & (~wSignal);
	return EnablePort( wEnable );
}




// protected functions
// ************************
// sets a signal high
DWORD CXBoxControl::SetSignalHigh( const WORD wSignal )	
{
	WORD wData;
	InPort( &wData );
	wData = wData | wSignal;
	if( AW_OK != OutPort( wData ) )
	{
		return GetLastError();
	}

	if( AW_OK != InPort( &wData ) )
	{
		return GetLastError();
	}

	if( !(wData & wSignal) )
	{
		SetLastError( AW_ERROR_HARDWARE );
		return GetLastError();
	}

	return AW_OK;

}
// sets a signal low
DWORD CXBoxControl::SetSignalLow( const WORD wSignal )
{
	WORD wData;
	InPort( &wData );
	wData = wData & (~wSignal);
	if( AW_OK != OutPort( wData ))
	{
		return GetLastError();
	}

	if( AW_OK != InPort( &wData ))
	{
		return GetLastError();
	}

	if( wData & wSignal )
	{
		SetLastError( AW_ERROR_HARDWARE );
		return GetLastError();
	}

	return AW_OK;
}		
// returns TRUE if a signal is high
BOOL  CXBoxControl::SignalIsHigh( const WORD wSignal )	
{
	WORD wData;
	InPort( &wData );
	return( wData & wSignal );
}	
// returns TRUE if a signal is low
BOOL  CXBoxControl::SignalIsLow( const WORD wSignal )
{
	return !SignalIsHigh( wSignal );
}	


//*********************************************************************************
// Class AV Pack
// controls AV Pack strappings
//
// Pin IO/4 = VMODE1
// PIN IO/5 = VMODE2
// PIN IO/6 = VMODE3
//////////////////////////////////////////////////////////////////

CAVPack::CAVPack( DWORD dwDevNum )
{
	dwErrCode = Open( dwDevNum );
	if( AW_OK != dwErrCode )
	{
		iDeviceNum = -1;
		return;
	}
	iDeviceNum = (int)dwDevNum;
	dwErrCode = OutPort( 0x0000 );
	if( AW_OK != dwErrCode )
		return;
	dwErrCode = EnablePort( 0x0000 );
	
}


CAVPack::~CAVPack()
{
	dwErrCode = EnablePort( 0x0000 );
	if( DeviceIsOpen() )
		Close( );
}


// Sets the AV Pack output
// AV is an enum that specifies the
// type of AV Pack
VOID CAVPack::SetAVPack( AVPack av )
{
	WORD wEnable = 0;
	
	// make sure outputs are all driven low
	
	switch( av )
	{
		case RFU:
			wEnable = VMODE3;
			break;
		case NOPACK:
			wEnable = 0x00;
			break;
		case POWEROFF:
			wEnable = VMODE2;
			break;
		case HDTV:
			wEnable = VMODE2 | VMODE3;
			break;
		case SDTV_ANALOG:
			wEnable = VMODE1;
			break;
		case VGA:
			wEnable = VMODE1 | VMODE3;
			break;
		case SDTV_DIGITAL:
			wEnable = VMODE1 | VMODE2;
			break;
		case SCART:
			wEnable = VMODE1 | VMODE2 | VMODE3;
			break;
		default:
			wEnable = 0x00;
			break;
	}

	EnablePort( wEnable );
	OutPort( 0x00 );	// bug bug
}



// Drives the AVPack lines
// the the desired mode
VOID CAVPack::DriveAVPack( AVPack av )
{
	WORD wData = 0x0;
	// make sure outputs are all driven low
	
	switch( av )
	{
		case RFU:
			wData = RFU << 4;
			break;
		case NOPACK:
			wData = NOPACK << 4;
			break;
		case POWEROFF:
			wData = POWEROFF << 4;
			break;
		case HDTV:
			wData = HDTV << 4;
			break;
		case SDTV_ANALOG:
			wData = SDTV_ANALOG << 4;
			break;
		case VGA:
			wData = VGA << 4;
			break;
		case SDTV_DIGITAL:
			wData = SDTV_DIGITAL << 4;
			break;
		case SCART:
			wData = SCART << 4;
			break;
		default:
			wData = 0x00;
			break;
	}

	OutPort( wData );
	EnablePort( VMODE1 | VMODE2 | VMODE3 );
}


// Power On
VOID CAVPack::PowerOn( )
{
	// Disable output port
	EnablePort( 0x00 );
	
	// now write the data
	OutPort( VMODE1 | VMODE2 | VMODE3 );
	EnablePort( VMODE1 | VMODE2 | VMODE3 );
}

// drive power off output
// Drives NOPACK for T1 ms
// Drives POWOFF for T2 ms
VOID CAVPack::PowerOff( )
{
	SetAVPack( POWEROFF );
}


DWORD CAVPack::GetLastError()
{
	return dwErrCode;
}

char* CAVPack::ErrorMessage()
{
	return CAWDevice::ErrorMessage( );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AW\AW.cpp ===
// AW.cpp : Defines the entry point for the DLL application.
//

#include <windows.h>
#include <awusbapi.h>
#include <stdio.h>
#include "aw.h"



static DWORD dwTlsIndex;		// address of shared memory


BOOL APIENTRY DllMain( HINSTANCE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
	LPVOID lpvData;
	//BOOL fIgnore;


    switch (ul_reason_for_call)
	{
		// The DLL is loading due to process 
        // initialization or a call to LoadLibrary. 
		case DLL_PROCESS_ATTACH:
			// allocate a tls index
			if(( dwTlsIndex = TlsAlloc()) == 0xFFFFFFFF)
			{
				return FALSE;
			}

			// no break.  initialize the index for 1st thread
		case DLL_THREAD_ATTACH:
			 
			/// Retrieve a data pointer for the current thread.
 
			lpvData = TlsGetValue(dwTlsIndex); 
 
			// If NULL, allocate memory for this thread.
 
			if (lpvData == NULL) { 
				lpvData = (LPVOID) LocalAlloc(LPTR, 256); 
				if (lpvData != NULL) 
					TlsSetValue(dwTlsIndex, lpvData); 
			} 
			break;
 
 

		case DLL_THREAD_DETACH:
			// Release the allocated memory for this thread.
 
            lpvData = TlsGetValue(dwTlsIndex); 
            if (lpvData != NULL) 
                LocalFree((HLOCAL) lpvData); 
 
            break; 
 
		case DLL_PROCESS_DETACH:
			// Release the allocated memory for this thread.
 
            lpvData = TlsGetValue(dwTlsIndex); 
            if (lpvData != NULL) 
                LocalFree((HLOCAL) lpvData); 
 
            // Release the TLS index.
 
            TlsFree(dwTlsIndex); 
            break; 
 
    }
    return TRUE;
	
}


/////////////////////////////////////////////////////////////////
// member functions for class CAWDevice
//

// default constructor
CAWDevice::CAWDevice()
{
	iDeviceNum = -1;
	dwErrCode = AW_OK;
}


// constructor with device num
// creates class and opens the device
CAWDevice::CAWDevice( DWORD devnum )
{
	dwErrCode = AwusbOpen( devnum );
	if( AW_OK != dwErrCode )
	{
		iDeviceNum = -1;
	}
	else
	{
		iDeviceNum = devnum;
	}
}


// destructor
CAWDevice::~CAWDevice()
{
	if( DeviceIsOpen() )
	{
		Close();
	}
}


// writes a word to the port
DWORD CAWDevice::OutPort( WORD data )
{
	BYTE d[2];
	d[0] = (BYTE)( data & 0x00FF );			// lower 8 bits
	d[1] = (BYTE)((data & 0xFF00) >>8);    // uper 8 bits

	dwErrCode = AwusbOutPort( d, 2 );
	return dwErrCode;
}


// reads a word from the port
//
DWORD CAWDevice::InPort( WORD* data )
{
	BYTE d[2];
	dwErrCode = AwusbInPort( d, 2 );

	*data  = (WORD)d[0];			// lower 8 bits
	*data |= ((WORD)d[1]) << 8;		// upper 8 bits

	return dwErrCode;
}

// enables the port for input/output
// for each bit:
//   1 = output
//   0 = input
DWORD CAWDevice::EnablePort( WORD data )
{
	BYTE d[2];
	d[0] = (BYTE)(data & 0x00FF);      // lower 8 bits
	d[1] = (BYTE)((data & 0xFF00)>>8); // upper 8 bits

	dwErrCode = AwusbEnablePort( d, 2 );
	return dwErrCode;
}


// sequentially writes bytes to the port
//  data is an array of BYTES
//  bytes with even array subscripts go to lower 8 bits
//  bytes with odd array sybscripts go to upper 8 bits
DWORD CAWDevice::OutPortEx( BYTE* data, DWORD count )
{
	dwErrCode = AwusbOutPort( data, count );
	return dwErrCode;
}


// sequentially reads bytes from the port
//  data is an array of BYTES
//  bytes with even array subscripts go to lower 8 bits
//  bytes with odd array sybscripts go to upper 8 bits
DWORD CAWDevice::InPortEx( BYTE* data, DWORD count )
{
	dwErrCode = AwusbInPort( data, count );
	return dwErrCode;
}


// sequentially enable output of the port
// for each bit, 1=output, 2 = input
//  data is an array of BYTES
//  bytes with even array subscripts go to lower 8 bits
//  bytes with odd array sybscripts go to upper 8 bits
DWORD CAWDevice::EnablePortEx( BYTE* data, DWORD count )
{
	dwErrCode = AwusbEnablePort( data, count );
	return dwErrCode;
}


// opens an AW device.
// if a device is already open, returns an error
// code 
DWORD CAWDevice::Open( DWORD devnum )
{
	// check if a device is open
	if( DeviceIsOpen() )
	{
		return AW_ERROR_USBNOTCLOSE;	// not closed yet
	}

	// now open the desired device
	dwErrCode = AwusbOpen( devnum );
	
	if( AW_OK == dwErrCode )
	{
		iDeviceNum = devnum;
	}

	return dwErrCode;
}


// closes the device
// if no device is open, this function returns an error
DWORD CAWDevice::Close()
{
	// check for a valid device
	if( !DeviceIsOpen() )
	{
		// device not opened
		return AW_ERROR_USBNOTOPEN;		// no open device
	}

	// otherwise, close the device
	dwErrCode = AwusbClose();

	// check for error
	if( AW_OK == dwErrCode )
	{
		iDeviceNum = -1;
	}
	return dwErrCode;
}

// returns the last error code
DWORD CAWDevice::GetLastError()
{
	return dwErrCode;
}


// sets the last error code
VOID CAWDevice::SetLastError( DWORD errcode )
{
	dwErrCode = errcode;
}


// returns a string represenation of the error code
char* CAWDevice::ErrorMessage(DWORD errcode)
{
	return AwusbErrorMessage( errcode );
}

// returns a string representation fo the last error code
char* CAWDevice::ErrorMessage()
{
	return AwusbErrorMessage( dwErrCode );
}


// returns true if a device is open
BOOL CAWDevice::DeviceIsOpen()
{
	return ( iDeviceNum >= 0 );
}











	





// writes a word to the port
//
AW_API DWORD AWOutPort( WORD data )
{
	BYTE	d[2];
	
	// break the word into upper and lower bits
	// we need to to this because of the way the ActiveWire USB API works.
	// see the ActiveWire USB SW reference for more information
	d[0] = (BYTE) ( data & 0x00FF );		// lower 8 bits
	d[1] = (BYTE) ( (data & 0xFF00) >> 8 );	// upper 8 bits

	return AwusbOutPort( d, 2 );
}



/* writes count bytes to the ports
 array elements with even subscripts are written to the lower
 8 bits of the port, elements with odd subscripts are written to
 the upper 8 bits of the port.  If count > 2, bytes are written consecutively to
 the port
*/
AW_API DWORD AWOutPortEx( BYTE* data, DWORD count )
{
	return AwusbOutPort( data, count );
}



// reads a word from the port
AW_API DWORD AWInPort ( WORD *data )
{
	DWORD	dwResult;
	BYTE	d[2];
	
	// get the input
	dwResult =  AwusbInPort( d, 2 );

	// pass the results back through the data param
	*data = (WORD)d[0];		// lower 8 bytes
	*data |= ((WORD)d[1]) << 8;

	return dwResult;

}



/* writes count bytes from the ports
 array elements with even subscripts are read from the lower
 8 bits of the port, elements with odd subscripts are read from
 the upper 8 bits of the port.  If count > 2, bytes are read consecutively from
 the port
*/
AW_API DWORD AWInPortEx ( BYTE* data, DWORD count )
{
	return AwusbInPort( data, count );
}


/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
*/
AW_API DWORD AWEnablePort ( WORD data )
{
	BYTE	d[2];
	
	// break the word into upper and lower bits
	// we need to to this because of the way the ActiveWire USB API works.
	// see the ActiveWire USB SW reference for more information
	d[0] = (BYTE) ( data & 0x00FF );		// lower 8 bits
	d[1] = (BYTE) ( (data & 0xFF00) >> 8 );	// upper 8 bits

	return AwusbEnablePort( d, 2 );
}



/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
	array elements with even subscripts enable the lower
	 8 bits of the port, elements with odd subscripts enable
	 the upper 8 bits of the port.  If count > 2, enable data is written
	 consecutively to the por
*/	
AW_API DWORD AWEnablePortEx ( BYTE* data, DWORD count )
{
	return AwusbEnablePort( data, count );
}


/*
	opens the USB device.  
	devnum is the device number
	0 is the 1st device attached, 1 is the second, etc

	each thread can open one device at a time.
*/
AW_API DWORD AWOpen ( WORD devnum )
{
	return AwusbOpen( devnum );
}


/*
	closes the device that is currently opened by the thread
*/
AW_API DWORD AWClose (  )
{
	return AwusbClose();
}



/*
	returns error string
*/
AW_API char * AWErrorMessage( DWORD errcode )
{
	return AwusbErrorMessage( errcode );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AW\AW.h ===
/* Copyright Micrsooft 2001 - all rights reserved

  Author: sethmil

  History:

		created		5/9/01		sethmil

  Abstract:
		A wrapper DLL for ActiveWire functions
		uses words as output instead of the activewire
		byte arrays.

*/

#ifndef __AW_H__
#define __AW_H__


// includes
#define WIN32_LEAN_AND_MEAN
#ifdef _XBOX
	#include <xtl.h>
#else
	#include <windows.h>
#endif


//#define	DEVROOTNAME		"AW-"
#define AW_DLL_NAME		"aw.dll"

#ifdef AW_DLL_EXPORT
#define AW_API __declspec(dllexport)
#else
#define AW_API __declspec(dllimport)
#endif




//////////////////////////////////////////////////////////////////
// class CAWDevice
// an IO class for activewire devices
/////////////////////////////////////////////////////////////////
//
class AW_API CAWDevice
{
public:
	// default constructor
	CAWDevice();

	// enumerates device devnum
	CAWDevice( DWORD devnum );

	// destructor
	~CAWDevice();

	// writes a word to the port
	DWORD OutPort (WORD data );

	// reads a word from the port
	DWORD InPort (WORD *data );

	// enables the port for input/output
	// 1=output
	// 0=input
	DWORD EnablePort( WORD data );

	// outputs bytes sequentially to the output
	// even subscript bytes are the lower 8 bits
	// odd subscript byytes are the upper 8 bits
	DWORD OutPortEx( BYTE*, DWORD count );

	// reads bytes sequentially from the port
	DWORD InPortEx( BYTE*, DWORD count );

	// enables the port sequentially
	DWORD EnablePortEx( BYTE*, DWORD count );

	// opens a device
	DWORD Open( DWORD devnum );

	// closes the device
	DWORD Close( );

	// returns the last error code
	DWORD GetLastError();

	// sets the last error code
	VOID SetLastError( DWORD errcode );

	// returns a string for the AW error message
	char* ErrorMessage( DWORD errcode );
	// returns string for the last error message
	char* ErrorMessage();

	// TRUE if the device is valid and opened
	BOOL DeviceIsOpen();

protected:
	int iDeviceNum;
	DWORD dwErrCode;
};

//////////////////////////////////////////////////////////////////////////

// Exported Functions
// See ActiveWire documentation for descriptions of these functions
//

extern "C" {

// writes a word to the port
AW_API DWORD AWOutPort ( WORD data );

/* writes count bytes to the ports
 array elements with even subscripts are written to the lower
 8 bits of the port, elements with odd subscripts are written to
 the upper 8 bits of the port.  If count > 2, bytes are written consecutively to
 the port
*/
AW_API DWORD AWOutPortEx ( BYTE* data, DWORD count );


// reads a word from the port
AW_API DWORD AWInPort ( WORD *data );


/* writes count bytes from the ports
 array elements with even subscripts are read from the lower
 8 bits of the port, elements with odd subscripts are read from
 the upper 8 bits of the port.  If count > 2, bytes are read consecutively from
 the port
*/
AW_API DWORD AWInPortEx ( BYTE* data, DWORD count );


/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
*/
AW_API DWORD AWEnablePort ( WORD data );


/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
	array elements with even subscripts enable the lower
	 8 bits of the port, elements with odd subscripts enable
	 the upper 8 bits of the port.  If count > 2, enable data is written
	 consecutively to the por
*/	
AW_API DWORD AWEnablePortEx ( BYTE* data, DWORD count );


/*
	opens the USB device.  
	devnum is the device number
	0 is the 1st device attached, 1 is the second, etc

	each thread can open one device at a time.
*/
AW_API DWORD AWOpen ( WORD devnum );


/*
	closes the device that is currently opened by the thread
*/
AW_API DWORD AWClose (  );


/*
	returns error string
*/
AW_API char * AWErrorMessage( DWORD errcode );



// Error Code
enum AW_ERROR_CODE_T {
	AW_OK	= 0,			// success
	AW_ERROR_FATAL,			// Fatal error, cannot continue
	AW_ERROR_SYSTEM,			// System error, use WIN32 GetLastError() for further error code
	AW_ERROR_MEMORY,			// Run out of memory
	
	AW_ERROR_FILEOPEN,		// File open failure
	AW_ERROR_FILEWRITE,		// File write failure
	AW_ERROR_FILEREAD,		// File read failure
	AW_ERROR_FILECLOSE,		// File close failure
	AW_ERROR_FILEFORMAT,		// File format error
	AW_ERROR_FILECHECKSUM,	// File checksum error
	AW_ERROR_FILEEOF,		// Unexpected end of file 

	AW_ERROR_HARDWARE,		// Hardware error, such as the device unplugged

	AW_ERROR_SOFTWARE,		// Software error, possibly a bug...
	AW_ERROR_NOTIMPLEMENTED,	// Not implemented yet...
	AW_ERROR_NOSUPPORT,		// Not supported

	AW_ERROR_USBNOTOPEN,		// Not opend yet
	AW_ERROR_USBNOTCLOSE,	// Not closed yet

	AW_ERROR_USBBADPIPE,		// Bad USB pipe
	AW_ERROR_USBBADOPCODE,	// Bad USB Command/Status Opcode
	AW_ERROR_USBZEROPACKET,	// Zero length USB data packet
	AW_ERROR_USBSHORTPACKET,	// Short USB data packet
	AW_ERROR_USBLONGPACKET,	// Longer USB data packet

	AW_ERROR_TIMEOUT,		// Time out, may or may not a problem...
	AW_ERROR_TRYAGAIN,		// Don't get too serious, try again, may work next time
	AW_ERROR_UNKNOWN,		// Unknown... Truth is out there...   :)
};

}  // extern "C"


#endif // __AW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AWClasses\CPowerCycle.cpp ===
/*
	Copyright Microsoft 2001 - all rights reserved

  author:  sethmil

  Abstract:

	// CPowerCycle.cpp
	//
	// source file for class CPowerCycle
	//
	// class CPowerCycler uses an ActiveWire USB Board
	// to cycle power on the xbox


	// pin out
	//		IO/0 - output - controls AC power
	//		IO/1 - output - controls POWSW
	//		IO/2 - input  - POWON
*/

#include <windows.h>
#include "CPowerCycle.h"




// default constructor
// protected constructor - does nothing
CPowerCycle::CPowerCycle() {}

// standard constructor
// this is the constructor that will
// be used to create the class object
CPowerCycle::CPowerCycle( DWORD dwDevNum )
{
	
	if( AW_OK != Open( dwDevNum ) )
	{
		return;
	}
	if( AW_OK != EnablePort( OUTPUT_PORT ) )
	{
		Close();
		return;
	}
	iDeviceNum = dwDevNum;
	SetPOWSWHigh();
}

// destructor
CPowerCycle::~CPowerCycle()
{
	CAWDevice::~CAWDevice();
}


// turns box power off (AC Main)
DWORD CPowerCycle::Unplug()
{
	WORD wData;
	InPort( &wData );
	wData = wData & (~ACPOWER) & (~POWSW);
	OutPort( wData );
	InPort( &wData );
	if( wData & POWON )
	{
		return AW_ERROR_HARDWARE;
	}
	return AW_OK;
}


// turns box power on (AC Main)
DWORD CPowerCycle::PlugIn()
{
	WORD wData;
	InPort( &wData );
	wData = wData | ACPOWER;
	OutPort( wData );
	InPort( &wData );
	if( !(wData & ACPOWER) )
	{
		return AW_ERROR_HARDWARE;
	}
	return AW_OK;
}


// returns TRUE if the box is plugged in
BOOL CPowerCycle::PluggedIn()
{
	WORD wData;
	InPort( &wData );
	return( wData & ACPOWER );
}


// BoxIsOn
// returns TRUE if POWON is asserted on the DUT
BOOL CPowerCycle::BoxIsOn()
{
	WORD wData;
	InPort( &wData );
	return ( wData & POWON );		// box is on if IO/2 is high
}

// BoxIsOff()
// returns TRUE if the box is off
BOOL CPowerCycle::BoxIsOff()
{
	return !BoxIsOn();
}


// DeviceIsOpen
// returns TRUE if the AW device is open
BOOL CPowerCycle::DeviceIsOpen()
{
	return CAWDevice::DeviceIsOpen();
}


// ErrorMessage()
// returns a string version of the last error message
char* CPowerCycle::ErrorMessage()
{
	return CAWDevice::ErrorMessage();
}

// ErrorMessage( DWORD )
// returns a string version of the error message
char* CPowerCycle::ErrorMessage( const DWORD errcode )
{
	return CAWDevice::ErrorMessage( errcode );
}

// GetLastError
// returns the last error code
DWORD CPowerCycle::GetLastError()
{
	return CAWDevice::GetLastError();
}



// sets POWSW to LOW
// if POWSW is already LOW, does nothing
// if POWSW does not go low, returns an error.
// POWSW is pin IO/1
DWORD CPowerCycle::SetPOWSWLow()
{
	WORD wData;
	InPort( &wData );
	wData = wData & (~POWSW);
	if( AW_OK != OutPort( wData ))
	{
		return GetLastError();
	}

	if( AW_OK != InPort( &wData ))
	{
		return GetLastError();
	}

	if( wData & POWSW )
	{
		SetLastError( AW_ERROR_HARDWARE );
		return GetLastError();
	}

	return AW_OK;
}


// sets POWSW to HIGH
// if POWSW is already HIGH, does nothing
// if POWSW does not go high, returns an error
DWORD CPowerCycle::SetPOWSWHigh()
{
	WORD wData;
	InPort( &wData );
	wData = wData | POWSW;
	if( AW_OK != OutPort( wData ) )
	{
		return GetLastError();
	}

	if( AW_OK != InPort( &wData ) )
	{
		return GetLastError();
	}

	if( !(wData & POWSW) )
	{
		SetLastError( AW_ERROR_HARDWARE );
		return GetLastError();
	}

	return AW_OK;
}


// returns TRUE if POWSW signal is high
//
BOOL CPowerCycle::POWSWIsHigh()
{
	WORD dwData;
	InPort( &dwData );
	return( dwData & POWSW );
}


// Cycles DUT power by pulsing
// the POWSW line
DWORD CPowerCycle::CyclePower( const DWORD dwPulseWidth )
{
	DWORD dwResult;

	// check to see if POWSW is HIGH
	if( !POWSWIsHigh() )
	{
		dwResult = SetPOWSWHigh();
		if( AW_OK != dwResult )
		{
			SetLastError( dwResult );
			return dwResult;
		}
		Sleep(200);
	}

	// now cycle power
	dwResult = SetPOWSWLow();
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}
	Sleep( dwPulseWidth );
	dwResult = SetPOWSWHigh();
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	return AW_OK;
}

	



// BoxOn
// turns the box on
// if the box is already on, does nothing
// if the box does not turn on,
// returns an error code
DWORD CPowerCycle::BoxOn( const DWORD dwTimeOut )
{
	DWORD dwResult;
	DWORD dwStartTime;

	// check to make sure the box is plugged in
	if( !PluggedIn() )
	{
		PlugIn();
		Sleep(200);
	}
	// check to make sure we're starting
	// with POWSW high
	if( !POWSWIsHigh() )
	{
		if(AW_OK != (dwResult = SetPOWSWHigh()))
		{
			return dwResult;
		}
		Sleep( 200 );
	}

	// check to see if power is on
	if( BoxIsOn() )
	{
		return AW_OK;
	}

	// if box is off, we must turn it on
	dwResult = CyclePower( 100 );
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	dwStartTime = GetTickCount();

	// now wait for box to turn on
	while( !BoxIsOn() )
	{
		// check timeout
		if( (GetTickCount() - dwStartTime) > dwTimeOut )
		{
			SetLastError( AW_ERROR_TIMEOUT );
			return AW_ERROR_TIMEOUT;
		}
		Sleep(10);
	}

	return AW_OK;
}



		
// BoxOff
// turns the box off
// if the box is already off, does nothing
// if the box does not turn off within the timeout,
// returns an error code
DWORD CPowerCycle::BoxOff( const DWORD dwTimeOut )
{
	DWORD dwResult;
	DWORD dwStartTime;

	// check to make sure we're starting
	// with POWSW high
	if( !POWSWIsHigh() )
	{
		if(AW_OK != (dwResult = SetPOWSWHigh()))
		{
			return dwResult;
		}
		Sleep( 200 );
	}

	// check to see if power is off
	if( BoxIsOff() )
	{
		return AW_OK;
	}

	// if box is on, we must turn it off
	dwResult = CyclePower( 100 );
	if( AW_OK != dwResult )
	{
		SetLastError( dwResult );
		return dwResult;
	}

	dwStartTime = GetTickCount();

	// now wait for box to turn on
	while( BoxIsOn() )
	{
		// check timeout
		if( (GetTickCount() - dwStartTime) > dwTimeOut )
		{
			SetLastError( AW_ERROR_TIMEOUT );
			return AW_ERROR_TIMEOUT;
		}
		Sleep(10);
	}

	return AW_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AWClasses\AWClasses.h ===
/*
	Copyright Microsoft 2001 - all rights reserved

  author:  sethmil

  Abstract:

	// AWClasses.h
	//
	// header file for classes used with the AW board
	//
	// class CXBoxControlr uses an ActiveWire USB Board
	// to cycle power on the xbox
*/


#ifndef __AWCLASSES_H__
#define __AWCLASSES_H__


#define WIN32_LEAN_AND_MEAN
#ifdef _XBOX
	#include <xtl.h>
#else
	#include <windows.h>
#endif
#include <aw.h>
#include <i2clib.h>

// constants
/*static const WORD  OUTPUT_PORT = 0x0003;
static const WORD  POWSW       = 0x0002;
static const WORD  ACPOWER     = 0x0001;
static const WORD  POWON	   = 0x0004;*/

//#define OUTPUT_PORT 0x0003
#define ACPOWER     0x0001		// output IO/0 - AC Power Control
#define POWSW       0x0002		// output IO/1 - POWSW control		
#define POWON       0x0004		// input IO/2 - POWON signal
#define STANDBY		0x0008		// input IO/3 - 3.3V stby voltage
#define VMODE1		0x0010		// input IO/4 - VMODE1
#define VMODE2		0x0020		// input IO/5 - VMODE2
#define VMODE3		0x0040		// input IO/6 - VMODE3
#define SYSRESET	0x0080		// input - sysreset

#define EJTSW		0x0100		// output DVD Eject
#define TRAYSTATE0	0x0200		// input TRAYState0
#define TRAYSTATE1  0x0400		// input traysate1
#define TRAYSTATE2  0x0800		// input traysate2
#define POWOK		0x1000		// output - POWOK
#define DVDEJECT	0x2000		// input - DVDEject



enum 
{
	OK_XBOX_POWER = 0,
	XBOX_POWER_OFF_ERROR,
	XBOX_POWER_ON_ERROR
};





// AV Pack definitions
static const enum AVPack
{
	NOPACK		= 0x7,
	RFU			= 0x3,
	POWEROFF	= 0x5,
	HDTV		= 0x1,
	SDTV_ANALOG = 0x6,
	VGA			= 0x2,
	SDTV_DIGITAL= 0x4,
	SCART		= 0x0
};



//********************************************************************************************
// Class definitions
//


// class CXBoxControlr uses an ActiveWire USB Board
// to cycle power on the xbox

class CXBoxControl : protected CAWDevice
{
public:
	CXBoxControl( DWORD dwDevNum );
	~CXBoxControl();

	// turns box power on (AC Main)
	DWORD Unplug();

	// turns box power off (AC Main)
	DWORD PlugIn();

	// returns TRUE if the box is plugged in
	BOOL PluggedIn();

	// turns the box on
	DWORD BoxOn( const DWORD dwTimeOut = 10000 );

	// turns the box off
	DWORD BoxOff( const DWORD dwTimeOut = 10000 );

	// asserts POWSW for dwPulseWidth milliseconds
	DWORD CyclePower( const DWORD dwPulseWidth );

	// sets the POWSW signal to LOW
	DWORD SetPOWSWLow();

	// sets the POWSW signal to HIGH
	DWORD SetPOWSWHigh();

	// pulses the EJTSW signal
	DWORD EjectSwitch( const DWORD dwPulseWidth );

	// closes the DVD - if the DVD is closed, does nothing
	DWORD DVDClose();

	// opens the DVD - if the DVD is open, does nothing
	DWORD DVDOpen();

	// returns TRUE if the DVD tray is open
	BOOL DVDIsOpen();

	// returns TRUE if the DVD is closed, or in media detect, or in nomedia
	BOOL DVDIsClosed();

	// returns TRUE if the DVD is in media detect state
	BOOL DVDMediaDetect();

	// return TRUE if the DVD is in NoMedia stata
	BOOL DVDNoMedia();

	// returns TRUE if the DVD is in TRAYOPEN state
	BOOL DVDTrayOpen();

	// returns TRUE if the DVD is in CLOSED tray state
	BOOL DVDTrayClosed();

	// returns TRUE if POWSW is high
	BOOL POWSWIsHigh();

	// return TRUE if the box is on
	BOOL BoxIsOn();

	// returns TRUE if the box is off
	BOOL BoxIsOff();

	// returns TRUE if the AW device is open
	BOOL DeviceIsOpen();

	// returns TRUE if 3.3V standby is high
	BOOL STBYIsHigh();

	// enables an output port
	BOOL Enable( WORD wSignal );

	// disables an output prot
	BOOL Disable( WORD wSignal );

	// Error handling
	DWORD GetLastError();
	char* ErrorMessage( const DWORD errcode );
	char* ErrorMessage();


protected:
	CXBoxControl();	// not to be used
	DWORD SetSignalHigh( const WORD wSignal );	// sets a signal high
	DWORD SetSignalLow( const WORD wSignal );		// sets a signal low
	BOOL  SignalIsHigh( const WORD wSignal );		// returns TRUE if a signal is high
	BOOL  SignalIsLow( const WORD wSignal );		// returns TRUE if a signal is low
	
	WORD	wEnable;
};


/////////////////////////////////////////////////////////////////
// Class AV Pack
// controls AV Pack strappings
//
// Pin IO/4 = VMODE1
// PIN IO/5 = VMODE2
// PIN IO/6 = VMODE3
//////////////////////////////////////////////////////////////////

class CAVPack : protected CAWDevice
{
public:
	CAVPack( DWORD dwDevNum );
	~CAVPack( );
	
	// Sets the AV Pack output
	// AV is an enum that specifies the
	// type of AV Pack
	VOID SetAVPack( AVPack av );

	// Drives the AVPack lines
	// the the desired mode
	VOID DriveAVPack( AVPack av );
	
	// Drives the PowerOn signal
	VOID PowerOn( );

	// sets AVPack to POWEROFF
	VOID PowerOff( );


	DWORD GetLastError();
	char* ErrorMessage();

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\AWClasses\CPowerCycle.h ===
/*
	Copyright Microsoft 2001 - all rights reserved

  author:  sethmil

  Abstract:

	// CPowerCycle.h
	//
	// header file for class CPowerCycle
	//
	// class CPowerCycler uses an ActiveWire USB Board
	// to cycle power on the xbox
*/



#ifndef __CPOWERCYCLE_H__
#define __CPOWERCYCLE_H__


#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <aw.h>

// constants
/*static const WORD  OUTPUT_PORT = 0x0003;
static const WORD  POWSW       = 0x0002;
static const WORD  ACPOWER     = 0x0001;
static const WORD  POWON	   = 0x0004;*/

#define OUTPUT_PORT 0x0003
#define POWSW       0x0002
#define ACPOWER     0x0001
#define POWON       0x0004	


enum 
{
	OK_XBOX_POWER = 0,
	XBOX_POWER_OFF_ERROR,
	XBOX_POWER_ON_ERROR
};


class CPowerCycle : protected CAWDevice
{
public:
	CPowerCycle( DWORD dwDevNum );
	~CPowerCycle();

	// turns box power on (AC Main)
	DWORD Unplug();

	// turns box power off (AC Main)
	DWORD PlugIn();

	// returns TRUE if the box is plugged in
	BOOL PluggedIn();

	// turns the box on
	DWORD BoxOn( const DWORD dwTimeOut = 10000 );

	// turns the box off
	DWORD BoxOff( const DWORD dwTimeOut = 10000 );

	// asserts POWSW for dwPulseWidth milliseconds
	DWORD CyclePower( const DWORD dwPulseWidth );

	// sets the POWSW signal to LOW
	DWORD SetPOWSWLow();

	// sets the POWSW signal to HIGH
	DWORD SetPOWSWHigh();

	// returns TRUE if POWSW is high
	BOOL POWSWIsHigh();

	// return TRUE if the box is on
	BOOL BoxIsOn();

	// returns TRUE if the box is off
	BOOL BoxIsOff();

	// returns TRUE if the AW device is open
	BOOL DeviceIsOpen();

	// Error handling
	DWORD GetLastError();
	char* ErrorMessage( const DWORD errcode );
	char* ErrorMessage();


protected:
	CPowerCycle();	// not to be used
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\AwusbIO.cpp ===
// AwusbIO.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "AwusbIO.h"
#include "AwusbIODlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAwusbIOApp

BEGIN_MESSAGE_MAP(CAwusbIOApp, CWinApp)
	//{{AFX_MSG_MAP(CAwusbIOApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAwusbIOApp construction

CAwusbIOApp::CAwusbIOApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CAwusbIOApp object

CAwusbIOApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CAwusbIOApp initialization

BOOL CAwusbIOApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CAwusbIODlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\AwusbIO.h ===
// AwusbIO.h : main header file for the AWUSBIO application
//

#if !defined(AFX_AWUSBIO_H__7802B6A8_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
#define AFX_AWUSBIO_H__7802B6A8_0C7F_11D3_AC25_00104B306BEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CAwusbIOApp:
// See AwusbIO.cpp for the implementation of this class
//

class CAwusbIOApp : public CWinApp
{
public:
	CAwusbIOApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAwusbIOApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CAwusbIOApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AWUSBIO_H__7802B6A8_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\AwusbIODlg.h ===
// AwusbIODlg.h : header file
//

#if !defined(AFX_AWUSBIODLG_H__7802B6AA_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
#define AFX_AWUSBIODLG_H__7802B6AA_0C7F_11D3_AC25_00104B306BEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CAwusbIODlg dialog

class CAwusbIODlg : public CDialog
{
// Construction
public:
	CAwusbIODlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAwusbIODlg)
	enum { IDD = IDD_AWUSBIO_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAwusbIODlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	WORD	Dir;
	WORD	Data;

	void Update();
	void DoDir(int num);
	void DoValue(int num);
	void Debug (char *fmt, ...);
	void Error (char *fmt, ...);

	// Generated message map functions
	//{{AFX_MSG(CAwusbIODlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnOpen();
	afx_msg void OnClose();
	afx_msg void OnDir0();
	afx_msg void OnDir1();
	afx_msg void OnDir2();
	afx_msg void OnDir3();
	afx_msg void OnDir4();
	afx_msg void OnDir5();
	afx_msg void OnDir6();
	afx_msg void OnDir7();
	afx_msg void OnDir8();
	afx_msg void OnDir9();
	afx_msg void OnDir10();
	afx_msg void OnDir11();
	afx_msg void OnDir12();
	afx_msg void OnDir13();
	afx_msg void OnDir14();
	afx_msg void OnDir15();
	afx_msg void OnValue0();
	afx_msg void OnValue1();
	afx_msg void OnValue2();
	afx_msg void OnValue3();
	afx_msg void OnValue4();
	afx_msg void OnValue5();
	afx_msg void OnValue6();
	afx_msg void OnValue7();
	afx_msg void OnValue8();
	afx_msg void OnValue9();
	afx_msg void OnValue10();
	afx_msg void OnValue11();
	afx_msg void OnValue12();
	afx_msg void OnValue13();
	afx_msg void OnValue14();
	afx_msg void OnValue15();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AWUSBIODLG_H__7802B6AA_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.dos\AwusbIO.cpp ===
/**************************************************************************
				ActiveWire USB Sample Application

 Copyright (c) 1999   ActiveWire, Inc. http//www.ActiveWireInc.com 
                    - All rights reserved. 

 		Oct.12th, 1999  by Mato Hattori <Mato@ActiveWireInc.com>

 This file is made by ActiveWire, Inc. to use with ActiveWire USB board.
 
 Redistribution and use in source and/or binary forms, with or without 
 modification, are permitted.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, 
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
 AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
 OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 SUCH DAMAGE. 
**************************************************************************/

/*

  This example shows a simple C program to control ActiveWire USB board.
  This also demonstrate explicit call of DLL function.

  There are 2 ways to use DLL in any application,
	1. Statically load DLL (Link implicitly)
	2. Dynamically load DLL  (Link Explicitly)
  In general, 1. Statically load DLL by statically linking Awusb.lib file
  is easier and recommended when using Microsoft Visual C++.
  
  If Borland C++ or any other build environment is desired, the DLL must 
  be linked explicitly.
  Please refer to Win32 API GetProcAddress().

  Because explicit call of DLL function implies far memory pointer call, 
  extra caution must be paid for code optimization option when compiling.

*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "AwusbAPI.h"

// function type declaration to use with pointer declaration 
typedef DWORD	(CALLBACK * FARPROCP_AwusbOpen) (DWORD devnum);
typedef DWORD	(CALLBACK * FARPROCP_AwusbClose) ();
typedef DWORD	(CALLBACK * FARPROCP_AwusbEnablePort) (BYTE *data, DWORD count);
typedef DWORD	(CALLBACK * FARPROCP_AwusbOutPort) (BYTE *data, DWORD count);
typedef DWORD	(CALLBACK * FARPROCP_AwusbInPort) (BYTE *data, DWORD count);
typedef char *	(CALLBACK * FARPROCP_AwusbErrorMessage) (DWORD ret);

// function pointer declaration
FARPROCP_AwusbOpen			Dll_AwusbOpen;
FARPROCP_AwusbClose			Dll_AwusbClose;
FARPROCP_AwusbEnablePort	Dll_AwusbEnablePort;
FARPROCP_AwusbOutPort		Dll_AwusbOutPort;
FARPROCP_AwusbInPort		Dll_AwusbInPort;
FARPROCP_AwusbErrorMessage	Dll_AwusbErrorMessage;


void main (void)
{
	HINSTANCE	hDll;
	char	buf[256];
	int		devnum;
	DWORD	ret;
	int		key;
	unsigned int	data = 0, dir = 0;

	// load DLL
	hDll = LoadLibrary (AWUSB_DLL_NAME);
	if (hDll == NULL)
		printf ("ERROR : %s\n", Dll_AwusbErrorMessage (AWUSB_ERROR_SYSTEM));
	else
	{
		// initialize function pointer
		Dll_AwusbOpen =			(FARPROCP_AwusbOpen) GetProcAddress (hDll, "AwusbOpen");
		Dll_AwusbClose =		(FARPROCP_AwusbClose) GetProcAddress (hDll, "AwusbClose");
		Dll_AwusbEnablePort =	(FARPROCP_AwusbEnablePort) GetProcAddress (hDll, "AwusbEnablePort");
		Dll_AwusbOutPort =		(FARPROCP_AwusbOutPort) GetProcAddress (hDll, "AwusbOutPort");
		Dll_AwusbInPort =		(FARPROCP_AwusbInPort) GetProcAddress (hDll, "AwusbInPort");
		Dll_AwusbErrorMessage = (FARPROCP_AwusbErrorMessage) GetProcAddress (hDll, "AwusbErrorMessage");

		// now ready to call ActiveWire DLL functions

		// banner
		printf ("ActiveWire USB Sample Application\n");
		printf ("Copyright (C) 1999  ActiveWire, Inc. - All rights reserved.\n");
		printf ("\n");
		printf ("Please select Device Number : ");
		fgets (buf, sizeof(buf), stdin);
		sscanf (buf, "%d", &devnum);

		// open the device
		ret = Dll_AwusbOpen (devnum);
		if (ret != AWUSB_OK)				// if any error
			printf ("ERROR : %s\n", Dll_AwusbErrorMessage (ret));
		else
		{
			// successfully opened
			printf ("Device #%d successfully opened.\n", devnum);
			printf ("Press Space to toggle direction Input or Output.\n");
			printf ("Press 0-9a-f to toggle an Output bit.\n");
			printf ("Hit ESC to quit.\n");
			printf ("\n");
			
			while (1)
			{
				key = getch();
				
				if (key == 0x1b)	// if ESC key
				{
					Dll_AwusbClose ();		// close the device
					break;
				}

				switch (tolower (key))
				{
					case '0':	data ^= 0x0001;	break;
					case '1':	data ^= 0x0002;	break;
					case '2':	data ^= 0x0004;	break;
					case '3':	data ^= 0x0008;	break;
					case '4':	data ^= 0x0010;	break;
					case '5':	data ^= 0x0020;	break;
					case '6':	data ^= 0x0040;	break;
					case '7':	data ^= 0x0080;	break;
					case '8':	data ^= 0x0100;	break;
					case '9':	data ^= 0x0200;	break;
					case 'a':	data ^= 0x0400;	break;
					case 'b':	data ^= 0x0800;	break;
					case 'c':	data ^= 0x1000;	break;
					case 'd':	data ^= 0x2000;	break;
					case 'e':	data ^= 0x4000;	break;
					case 'f':	data ^= 0x8000;	break;
					case ' ':   dir ^= 0xffff;	break;
					default:	break;
				}

				ret = Dll_AwusbEnablePort ((BYTE*)&dir, 2);
				if (ret != AWUSB_OK)
					printf ("ERROR : %s\n", Dll_AwusbErrorMessage (ret));

				ret = Dll_AwusbOutPort ((BYTE*)&data, 2);
				if (ret != AWUSB_OK)
					printf ("ERROR : %s\n", Dll_AwusbErrorMessage (ret));

				ret = Dll_AwusbInPort ((BYTE*)&data, 2);
				if (ret != AWUSB_OK)
					printf ("ERROR : %s\n", Dll_AwusbErrorMessage (ret));
				
				printf ("data = 0x%04x\n", data);
			}
		}

		// clean up
		FreeLibrary (hDll);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	AwusbIO.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7802B6AC_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
#define AFX_STDAFX_H__7802B6AC_0C7F_11D3_AC25_00104B306BEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7802B6AC_0C7F_11D3_AC25_00104B306BEE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AwusbIO.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_AWUSBIO_DIALOG              102
#define IDR_MAINFRAME                   128
#define IDC_DIR_0                       1001
#define IDC_VALUE_0                     1002
#define IDC_DIR_1                       1003
#define IDC_VALUE_1                     1004
#define IDC_DIR_2                       1005
#define IDC_VALUE_2                     1006
#define IDC_DIR_3                       1007
#define IDC_VALUE_3                     1008
#define IDC_DIR_4                       1009
#define IDC_VALUE_4                     1010
#define IDC_DIR_5                       1011
#define IDC_VALUE_5                     1012
#define IDC_DIR_6                       1013
#define IDC_VALUE_6                     1014
#define IDC_DIR_7                       1015
#define IDC_VALUE_7                     1016
#define IDC_DIR_8                       1017
#define IDC_VALUE_8                     1018
#define IDC_DIR_9                       1019
#define IDC_VALUE_9                     1020
#define IDC_DIR_10                      1021
#define IDC_VALUE_10                    1022
#define IDC_DIR_11                      1023
#define IDC_VALUE_11                    1024
#define IDC_DIR_12                      1025
#define IDC_VALUE_12                    1026
#define IDC_DIR_13                      1027
#define IDC_VALUE_13                    1028
#define IDC_DIR_14                      1029
#define IDC_VALUE_14                    1030
#define IDC_DIR_15                      1031
#define IDC_VALUE_15                    1032
#define IDC_DEV_NUM                     1033
#define IDC_OPEN                        1034
#define IDC_CLOSE                       1035
#define IDC_DEBUG                       1036

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\AwusbIO.exe_Src\AwusbIODlg.cpp ===
// AwusbIODlg.cpp : implementation file
//

#include "stdafx.h"
#include "AwusbIO.h"
#include "AwusbIODlg.h"

#include "AwusbAPI.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAwusbIODlg dialog

CAwusbIODlg::CAwusbIODlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAwusbIODlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAwusbIODlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CAwusbIODlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAwusbIODlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAwusbIODlg, CDialog)
	//{{AFX_MSG_MAP(CAwusbIODlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_OPEN, OnOpen)
	ON_BN_CLICKED(IDC_CLOSE, OnClose)
	ON_BN_CLICKED(IDC_DIR_0, OnDir0)
	ON_BN_CLICKED(IDC_DIR_1, OnDir1)
	ON_BN_CLICKED(IDC_DIR_2, OnDir2)
	ON_BN_CLICKED(IDC_DIR_3, OnDir3)
	ON_BN_CLICKED(IDC_DIR_4, OnDir4)
	ON_BN_CLICKED(IDC_DIR_5, OnDir5)
	ON_BN_CLICKED(IDC_DIR_6, OnDir6)
	ON_BN_CLICKED(IDC_DIR_7, OnDir7)
	ON_BN_CLICKED(IDC_DIR_8, OnDir8)
	ON_BN_CLICKED(IDC_DIR_9, OnDir9)
	ON_BN_CLICKED(IDC_DIR_10, OnDir10)
	ON_BN_CLICKED(IDC_DIR_11, OnDir11)
	ON_BN_CLICKED(IDC_DIR_12, OnDir12)
	ON_BN_CLICKED(IDC_DIR_13, OnDir13)
	ON_BN_CLICKED(IDC_DIR_14, OnDir14)
	ON_BN_CLICKED(IDC_DIR_15, OnDir15)
	ON_BN_CLICKED(IDC_VALUE_0, OnValue0)
	ON_BN_CLICKED(IDC_VALUE_1, OnValue1)
	ON_BN_CLICKED(IDC_VALUE_2, OnValue2)
	ON_BN_CLICKED(IDC_VALUE_3, OnValue3)
	ON_BN_CLICKED(IDC_VALUE_4, OnValue4)
	ON_BN_CLICKED(IDC_VALUE_5, OnValue5)
	ON_BN_CLICKED(IDC_VALUE_6, OnValue6)
	ON_BN_CLICKED(IDC_VALUE_7, OnValue7)
	ON_BN_CLICKED(IDC_VALUE_8, OnValue8)
	ON_BN_CLICKED(IDC_VALUE_9, OnValue9)
	ON_BN_CLICKED(IDC_VALUE_10, OnValue10)
	ON_BN_CLICKED(IDC_VALUE_11, OnValue11)
	ON_BN_CLICKED(IDC_VALUE_12, OnValue12)
	ON_BN_CLICKED(IDC_VALUE_13, OnValue13)
	ON_BN_CLICKED(IDC_VALUE_14, OnValue14)
	ON_BN_CLICKED(IDC_VALUE_15, OnValue15)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAwusbIODlg message handlers

BOOL CAwusbIODlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	

	// Load DLL library
	LoadLibrary (AWUSB_DLL_NAME);

	// Initialize global variables
	Dir = 0;
	Data = 0;

	// Set default device number
	SetDlgItemText (IDC_DEV_NUM, "0");	// default to 0


	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAwusbIODlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CAwusbIODlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CAwusbIODlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


void CAwusbIODlg::OnOpen() 
{
	DWORD	devnum;
	DWORD	ret;
	
	// Open USB device
	devnum = (DWORD) GetDlgItemInt (IDC_DEV_NUM, NULL, FALSE);
	ret = AwusbOpen (devnum);
	if (ret != AWUSB_OK)	// if error
	{
		Error ("%s", AwusbErrorMessage (ret));
		return;
	}
	else
		Debug ("Device #%ld : Open successfully.", devnum);

	// set the board to match with the current GUI
	ret = AwusbEnablePort ((BYTE*)(&Dir), 2);
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));

	ret = AwusbOutPort ((BYTE*)(&Data), 2);
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));

	// update GUI
	Update();
}


void CAwusbIODlg::OnClose() 
{
	DWORD	ret;

	// Close device
	ret = AwusbClose ();
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));
	else
		Debug ("Device Closed");
}


void CAwusbIODlg::Update() 
{
	int	IdcDir[] = { IDC_DIR_0, IDC_DIR_1, IDC_DIR_2, IDC_DIR_3, 
					 IDC_DIR_4, IDC_DIR_5, IDC_DIR_6, IDC_DIR_7, 
					 IDC_DIR_8, IDC_DIR_9, IDC_DIR_10, IDC_DIR_11, 
					 IDC_DIR_12, IDC_DIR_13, IDC_DIR_14, IDC_DIR_15, };
	int	IdcVal[] = { IDC_VALUE_0, IDC_VALUE_1, IDC_VALUE_2, IDC_VALUE_3, 
					 IDC_VALUE_4, IDC_VALUE_5, IDC_VALUE_6, IDC_VALUE_7, 
					 IDC_VALUE_8, IDC_VALUE_9, IDC_VALUE_10, IDC_VALUE_11, 
					 IDC_VALUE_12, IDC_VALUE_13, IDC_VALUE_14, IDC_VALUE_15, };
	int		i;
	DWORD	ret;

	// get current I/O port state
	ret = AwusbInPort ((BYTE*)(&Data), 2);
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));

	// update GUI
	for (i=0; i<16; i++)		// change button label according to the state
	{
		(Dir & (1<<i))  ? SetDlgItemText(IdcDir[i], "Out") : SetDlgItemText(IdcDir[i], "In");
		(Data & (1<<i)) ? SetDlgItemText(IdcVal[i], "High") : SetDlgItemText(IdcVal[i], "Low");
	}
}


void CAwusbIODlg::DoDir(int num) 
{
	// this will be called with the I/O number when user click on one of Directions buttons 

	DWORD	ret;

	if (Dir & (1<<num))			// invert the num'th bit of Dir register
		Dir &= (~(1<<num));
	else 
		Dir |= (1<<num);

	// Enable port
	ret = AwusbEnablePort ((BYTE*)(&Dir), 2);
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));

	Update();
}

void CAwusbIODlg::DoValue(int num) 
{
	// this will be called with the I/O number when user click on one of Value buttons 

	DWORD	ret;
	
	if (Data & (1<<num))			// invert the num'th bit of Data register
		Data &= (~(1<<num));
	else 
		Data |= (1<<num);

	// Output port
	ret = AwusbOutPort ((BYTE*)(&Data), 2);
	if (ret != AWUSB_OK)
		Error ("%s", AwusbErrorMessage (ret));
	
	Update();
}


void CAwusbIODlg::Debug (char *fmt, ...)
{
	char 	buf[1024];
	va_list	alist;

	va_start (alist, fmt);
	vsprintf(buf, fmt, alist);
	((CEdit*)GetDlgItem (IDC_DEBUG))->SetWindowText (buf);	// set test in the Debug message edit box
	va_end (alist);
}


void CAwusbIODlg::Error (char *fmt, ...)
{
	char 	buf[1024];
	va_list	alist;

	va_start (alist, fmt);
	vsprintf(buf, fmt, alist);
	Debug ("ERROR : %s", buf);	// call Debug() with "Error : " to indicate an error
	va_end (alist);
}


void CAwusbIODlg::OnDir0() 
{
	DoDir(0);	
}

void CAwusbIODlg::OnDir1() 
{
	DoDir(1);	
}

void CAwusbIODlg::OnDir2() 
{
	DoDir(2);	
}

void CAwusbIODlg::OnDir3() 
{
	DoDir(3);	
}

void CAwusbIODlg::OnDir4() 
{
	DoDir(4);	
}

void CAwusbIODlg::OnDir5() 
{
	DoDir(5);	
}

void CAwusbIODlg::OnDir6() 
{
	DoDir(6);	
}

void CAwusbIODlg::OnDir7() 
{
	DoDir(7);	
}

void CAwusbIODlg::OnDir8() 
{
	DoDir(8);	
}

void CAwusbIODlg::OnDir9() 
{
	DoDir(9);	
}

void CAwusbIODlg::OnDir10() 
{
	DoDir(10);	
}

void CAwusbIODlg::OnDir11() 
{
	DoDir(11);	
}

void CAwusbIODlg::OnDir12() 
{
	DoDir(12);	
}

void CAwusbIODlg::OnDir13() 
{
	DoDir(13);	
}

void CAwusbIODlg::OnDir14() 
{
	DoDir(14);	
}

void CAwusbIODlg::OnDir15() 
{
	DoDir(15);	
}



void CAwusbIODlg::OnValue0() 
{
	DoValue(0);
}

void CAwusbIODlg::OnValue1() 
{
	DoValue(1);	
}

void CAwusbIODlg::OnValue2() 
{
	DoValue(2);	
}

void CAwusbIODlg::OnValue3() 
{
	DoValue(3);	
}

void CAwusbIODlg::OnValue4() 
{
	DoValue(4);	
}

void CAwusbIODlg::OnValue5() 
{
	DoValue(5);	
}

void CAwusbIODlg::OnValue6() 
{
	DoValue(6);	
}

void CAwusbIODlg::OnValue7() 
{
	DoValue(7);	
}

void CAwusbIODlg::OnValue8() 
{
	DoValue(8);	
}

void CAwusbIODlg::OnValue9() 
{
	DoValue(9);	
}

void CAwusbIODlg::OnValue10() 
{
	DoValue(10);	
}

void CAwusbIODlg::OnValue11() 
{
	DoValue(11);	
}

void CAwusbIODlg::OnValue12() 
{
	DoValue(12);	
}

void CAwusbIODlg::OnValue13() 
{
	DoValue(13);	
}

void CAwusbIODlg::OnValue14() 
{
	DoValue(14);	
}

void CAwusbIODlg::OnValue15() 
{
	DoValue(15);	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbresource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbresource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\ActiveWire\Src\VisualC++\include\AwusbAPI.h ===
// AWUSBAPI.H : header file
//

#if !defined(AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_)
#define AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define	DEVROOTNAME		"Awusb-"
#define AWUSB_DLL_NAME	"awusb.dll"

#ifdef AWUSB_DLL_EXPORT
#define __AWUSB_DLL		__declspec(dllexport) 
#else
#define	__AWUSB_DLL		__declspec(dllimport) 
#endif

// typedef
typedef struct _AWUSB_INTELHEX_T
{
	BYTE	count;
	WORD	addr;
	BYTE	type;
	BYTE	data[256];
	BYTE	crc;
} 
AWUSB_INTELHEX;

#define AWUSB_MAX_NUMPIPE	32
typedef struct _AWUSB_PIPEINFO_T
{
	BYTE	numpipe;
	BYTE	type[AWUSB_MAX_NUMPIPE];
	BYTE	endpoint[AWUSB_MAX_NUMPIPE];
	BYTE	dir[AWUSB_MAX_NUMPIPE];
	WORD	size[AWUSB_MAX_NUMPIPE];
} 
AWUSB_PIPEINFO;


// Function prototype
// High level Application interface
__AWUSB_DLL	DWORD	AwusbOutPort (BYTE *data, DWORD count);
__AWUSB_DLL	DWORD	AwusbInPort (BYTE *data, DWORD count);
__AWUSB_DLL	DWORD	AwusbEnablePort (BYTE *data, DWORD count);

// Low level USB interface
__AWUSB_DLL	DWORD	AwusbOpen (DWORD devnum);
__AWUSB_DLL	DWORD	AwusbClose ();
__AWUSB_DLL	DWORD	AwusbSetInterface (DWORD intfc, DWORD altset);
__AWUSB_DLL	DWORD	AwusbRead (DWORD pipenum, BYTE *buf, DWORD count);
__AWUSB_DLL	DWORD	AwusbWrite (DWORD pipenum, BYTE *buf, DWORD count);
__AWUSB_DLL	DWORD	AwusbCancelIo (DWORD pipenum);
__AWUSB_DLL	DWORD	AwusbGetPipeInfo (AWUSB_PIPEINFO *pipeinfo);
__AWUSB_DLL	DWORD	AwusbResetPipe (DWORD pipenum);
__AWUSB_DLL	DWORD	AwusbDownload (AWUSB_INTELHEX hexrec);
__AWUSB_DLL	DWORD	AwusbReadIntelHexLine (char *buf, AWUSB_INTELHEX *hexrec);
__AWUSB_DLL	DWORD	AwusbDownloadIntelHexFile (char *filename);
__AWUSB_DLL	DWORD	Awusb8051Reset (BOOL hold);

// Error handling
__AWUSB_DLL	char *	AwusbErrorMessage (DWORD errcode);


// Error Code
enum AWUSB_ERROR_CODE_T {
	AWUSB_OK	= 0,			// success
	AWUSB_ERROR_FATAL,			// Fatal error, cannot continue
	AWUSB_ERROR_SYSTEM,			// System error, use WIN32 GetLastError() for further error code
	AWUSB_ERROR_MEMORY,			// Run out of memory
	
	AWUSB_ERROR_FILEOPEN,		// File open failure
	AWUSB_ERROR_FILEWRITE,		// File write failure
	AWUSB_ERROR_FILEREAD,		// File read failure
	AWUSB_ERROR_FILECLOSE,		// File close failure
	AWUSB_ERROR_FILEFORMAT,		// File format error
	AWUSB_ERROR_FILECHECKSUM,	// File checksum error
	AWUSB_ERROR_FILEEOF,		// Unexpected end of file 

	AWUSB_ERROR_HARDWARE,		// Hardware error, such as the device unplugged

	AWUSB_ERROR_SOFTWARE,		// Software error, possibly a bug...
	AWUSB_ERROR_NOTIMPLEMENTED,	// Not implemented yet...
	AWUSB_ERROR_NOSUPPORT,		// Not supported

	AWUSB_ERROR_USBNOTOPEN,		// Not opend yet
	AWUSB_ERROR_USBNOTCLOSE,	// Not closed yet

	AWUSB_ERROR_USBBADPIPE,		// Bad USB pipe
	AWUSB_ERROR_USBBADOPCODE,	// Bad USB Command/Status Opcode
	AWUSB_ERROR_USBZEROPACKET,	// Zero length USB data packet
	AWUSB_ERROR_USBSHORTPACKET,	// Short USB data packet
	AWUSB_ERROR_USBLONGPACKET,	// Longer USB data packet

	AWUSB_ERROR_TIMEOUT,		// Time out, may or may not a problem...
	AWUSB_ERROR_TRYAGAIN,		// Don't get too serious, try again, may work next time
	AWUSB_ERROR_UNKNOWN,		// Unknown... Truth is out there...   :)
};

#endif // !defined(AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.01 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &xiState.Gamepad, sizeof(XINPUT_STATE) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > 0 );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;

	m_AvPack = 0;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

	m_AvPack = XGetAVPack();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
		// Check for AV Pack Change
		if(m_AvPack != XGetAVPack()) {
			break;
		}


        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input functions:
        // -  Both triggers and white button triggers a screen dump
        // -  Both triggers and black button triggers a reboot
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                // With white button, dump the backbuffer contents
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
                    XGWriteSurfaceToFile( m_pBackBuffer, "D:\\BackBuffer.bmp" );

                // With black button, reboot to the Xbox Dashboard
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\AVPackTest.cpp ===
#include <xtl.h>
#include <xgraphics.h>
#include <xbfont.h>
#include <xbinput.h>
#include <av.h>

extern "C" extern DWORD D3D__AvInfo;

extern "C"
{
void    WINAPI D3DDevice_EnableCC(BOOL Enable);
void    WINAPI D3DDevice_SendCC(BOOL Field, BYTE cc1, BYTE cc2);
void    WINAPI D3DDevice_GetCCStatus(BOOL *pField1, BOOL *pField2);
};

class CXBD3DDevice
{
protected:
    // Main objects used for creating and rendering the 3D scene
	UINT				  m_Adapter;			// Adapter for this device
	UINT				  m_AdapterMode;		// Display mode for this apapter
	D3DDISPLAYMODE		  m_DisplayMode;		// Adapter display mode

    D3DPRESENT_PARAMETERS m_d3dpp;				// D3D presentation parameters
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer

	// AV Pack Info
	DWORD					m_VideoStandard;
	DWORD					m_VideoFlags;
	WCHAR 					m_szAvPackLine1[64];
	WCHAR 					m_szAvPackLine2[64];
	WCHAR 					m_szAvPackLine3[64];

	// Font
	CXBFont                 m_Font;

	// Misc
	CHAR	szText[64];

	// Functions
	VOID AVPackDescription();
	VOID SetDisplayMode();
	VOID SetD3DPresentationParams();
	DWORD IREtoDW(double dfIre);
	BOOL SmpteBars(void);
	BOOL ButtonMap(void);

public:
	// Variables
	DWORD					m_AvPack;

	// Display mode values, to change display modes set one or all of these values
	// and call Reset()
	UINT	m_DisplayWidth;
	UINT	m_DisplayHeight;
	BOOL	m_Interlaced;
	BOOL	m_Widescreen;
	BOOL	m_ClosedCaptioning;
	BOOL	m_DisplayButtonMap;

    // Functions to create, run, and clean up the application
	HRESULT Init();					//
	HRESULT Create();
	HRESULT	Reset();
	HRESULT Destroy();
	HRESULT Render();

	// Constructor
	CXBD3DDevice();
};


//-----------------------------------------------------------------------------
// Name: CXBD3DDevice()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBD3DDevice::CXBD3DDevice() {
    // Direct3D variables
	m_Adapter		  = D3DADAPTER_DEFAULT;
	m_AdapterMode	  = D3DCURRENT_DISPLAY_MODE;

	ZeroMemory(&m_DisplayMode, sizeof(m_DisplayMode));

	ZeroMemory(&m_d3dpp, sizeof(m_d3dpp));
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pBackBuffer     = NULL;

	// Av Pack Info
	m_AvPack = XGetAVPack();
	m_VideoStandard = XGetVideoStandard();
	m_VideoFlags = XGetVideoFlags();
}


//-----------------------------------------------------------------------------
// Name: Init()
// Desc: Init the D3D interface and HDTV modes
//-----------------------------------------------------------------------------
HRESULT CXBD3DDevice::Init() {
	// Create the Direct3D object
    OutputDebugStringA("XBApp: Initializing Direct3D...\n");
    if(NULL == (m_pD3D = Direct3DCreate8(D3D_SDK_VERSION))) {
        OutputDebugStringA("XBApp: Unable to create Direct3D!\n");
        return E_FAIL;
    }
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBD3DDevice::Create() {
	HRESULT hr;

	OutputDebugStringA("XBApp: Creating the D3D device...\n");

	// Set desired display mode parameters
	m_DisplayWidth		= 640;
	m_DisplayHeight		= 480;
	m_Interlaced		= TRUE;
	m_Widescreen		= FALSE;
	m_ClosedCaptioning	= TRUE;
	m_DisplayButtonMap	= FALSE;

	// Get Adapter Mode
	SetDisplayMode();

	// Set up the presentation parameters
	SetD3DPresentationParams();	
    
    // Create the device
    if(FAILED(hr = m_pD3D->CreateDevice(m_Adapter, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice))) {
        OutputDebugStringA("XBApp: Could not create D3D device!\n");
        return hr;
    }

	// Enable everything in D3D_AvInfo
    D3D__AvInfo |= AV_FLAGS_WIDESCREEN
                    | AV_FLAGS_HDTV_480p
                    | AV_FLAGS_HDTV_720p
                    | AV_FLAGS_HDTV_1080i
                    | AV_FLAGS_HDTV_480i
                    | AV_FLAGS_60Hz;

	// Reset with new modes
	SetDisplayMode();
	SetD3DPresentationParams();	
	if(FAILED(hr = m_pd3dDevice->Reset(&m_d3dpp))) {
        OutputDebugStringA("XBApp: Could not reset D3D device!\n");
        return hr;
    }

	wsprintfA(szText, "Width = %u Height = %u\n", m_DisplayMode.Width, m_DisplayMode.Height);
	OutputDebugStringA(szText);

	// Create description string
	AVPackDescription();

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetBackBuffer(0, 0, &m_pBackBuffer);
	
	// Create a font
	if(FAILED(m_Font.Create( m_pd3dDevice, "d:\\Media\\Font.xpr"))) {
		OutputDebugStringA("m_Font.Create() FAILED\n");
        return E_FAIL;
	}

	// Set Closed Captioning
    D3DDevice_EnableCC(m_ClosedCaptioning);
#if 0
	if(FAILED(D3DDevice_EnableCC(m_ClosedCaptioning))) {
		wsprintfA(szText, "m_pd3dDevice->EnableCC(%s) FAILED\n", m_ClosedCaptioning ? "ON" : "OFF");
		OutputDebugStringA(szText);
		return E_FAIL;
	}
#endif 

    // Clear the backbuffer
    m_pd3dDevice->Clear(0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L);
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Reset()
// Desc: Reset D3D Device to specified mode
//-----------------------------------------------------------------------------
HRESULT CXBD3DDevice::Reset() {
    HRESULT hr;

	OutputDebugStringA("XBApp: Reseting the D3D device...\n");

	// Release back buffer
	m_pBackBuffer->Release();

	// Set adapter and display mode
	SetDisplayMode();

	// Set up the presentation parameters
	SetD3DPresentationParams();	

    // Reset the device
    if(FAILED(hr = m_pd3dDevice->Reset(&m_d3dpp))) {
        OutputDebugStringA("XBApp: Could not reset D3D device!\n");
        return hr;
    }

	m_pD3D->GetAdapterDisplayMode(m_Adapter, &m_DisplayMode);

	// Get back buffer
	m_pd3dDevice->GetBackBuffer(0, 0, &m_pBackBuffer);

	// Set Closed Captioning
    D3DDevice_EnableCC(m_ClosedCaptioning);
#if 0
	if(FAILED(D3DDevice_EnableCC(m_ClosedCaptioning))) {
		wsprintfA(szText, "m_pd3dDevice->EnableCC(%s) FAILED\n", m_ClosedCaptioning ? "ON" : "OFF");
		OutputDebugStringA(szText);
		return E_FAIL;
	}
#endif 0

	// Create description string
	AVPackDescription();

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
HRESULT CXBD3DDevice::Destroy() {
    // Release display objects
	if(m_pBackBuffer) {
		m_pBackBuffer->Release();
        m_pBackBuffer = NULL;
    }
	
	if(m_pd3dDevice) {
		m_pd3dDevice->Release();
		m_pd3dDevice = NULL;
    }
    
	if(m_pD3D) {
		m_pD3D->Release();
		m_pD3D = NULL;
    }

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: SetDisplayMode()
// Desc: Set m_AdapterMode and m_DisplayMode from: m_DisplayWidth, m_DisplayHeight,
//			m_Interlaced, and m_Widscreen;
//-----------------------------------------------------------------------------
VOID CXBD3DDevice::SetDisplayMode() {
	UINT AdapterMode, AdapterModeCount;

	AdapterModeCount = m_pD3D->GetAdapterModeCount(m_Adapter);
	
	for(AdapterMode = 0; AdapterMode < AdapterModeCount; AdapterMode++) {
		m_pD3D->EnumAdapterModes(m_Adapter, AdapterMode, &m_DisplayMode);

		if((m_DisplayMode.Width == m_DisplayWidth) &&
				(m_DisplayMode.Height == m_DisplayHeight) &&
				(((m_DisplayMode.Flags & D3DPRESENTFLAG_INTERLACED) == D3DPRESENTFLAG_INTERLACED) == m_Interlaced) &&
				(((m_DisplayMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) == D3DPRESENTFLAG_PROGRESSIVE) == !m_Interlaced) &&
				(((m_DisplayMode.Flags & D3DPRESENTFLAG_WIDESCREEN) ==  D3DPRESENTFLAG_WIDESCREEN) == m_Widescreen) &&
				((m_DisplayMode.Flags & D3DPRESENTFLAG_FIELD) != D3DPRESENTFLAG_FIELD)) {
			m_AdapterMode = AdapterMode;
			break;
		}
	}
}


//-----------------------------------------------------------------------------
// Name: SetD3DPresentationParams()
// Desc: Populate m_d3dpp with info from m_DisplayMode
//-----------------------------------------------------------------------------
VOID CXBD3DDevice::SetD3DPresentationParams() {
	// Valid formats for AutoDepthStencilFormat
	D3DFORMAT Formats[] = {
        D3DFMT_D24S8, 
        D3DFMT_D16, 
        D3DFMT_F24S8, 
        D3DFMT_F16, 
        D3DFMT_D16_LOCKABLE 
    };
    UINT numFormats = sizeof(Formats) / sizeof(Formats[0]);
	UINT i;

	m_d3dpp.BackBufferWidth					= m_DisplayMode.Width;
    m_d3dpp.BackBufferHeight				= m_DisplayMode.Height;
    m_d3dpp.BackBufferFormat				= m_DisplayMode.Format;
    m_d3dpp.BackBufferCount					= 1;
	m_d3dpp.Flags							= m_DisplayMode.Flags;
    m_d3dpp.MultiSampleType					= D3DMULTISAMPLE_NONE;
	m_d3dpp.SwapEffect						= D3DSWAPEFFECT_DISCARD;
	m_d3dpp.hDeviceWindow					= NULL;
    m_d3dpp.Windowed						= FALSE;
    m_d3dpp.EnableAutoDepthStencil			= TRUE;

	// Find valid format for AutoDepthStencilFormat
	for(i = 0; i < numFormats; i++) {

        if(m_pD3D->CheckDepthStencilMatch(m_Adapter, D3DDEVTYPE_HAL, m_DisplayMode.Format,
											m_DisplayMode.Format, Formats[i]) == D3D_OK) {
			m_d3dpp.AutoDepthStencilFormat = Formats[i];
			break;
		}
	}

	m_d3dpp.FullScreen_RefreshRateInHz		= D3DPRESENT_RATE_DEFAULT;
    m_d3dpp.FullScreen_PresentationInterval	= D3DPRESENT_INTERVAL_ONE;
}

//-----------------------------------------------------------------------------
// Name: AVPackDescription()
// Desc: Populate m_szAvPack with AV Pack and Mode info
//-----------------------------------------------------------------------------
VOID CXBD3DDevice::AVPackDescription() {
	// wsprintfW(m_szAvPackLine1, L"AV Pack(%i,%i,%#x) ", m_AvPack, m_VideoStandard, m_VideoFlags);
	wsprintfW(m_szAvPackLine1, L"AV Pack ");
	// AV Pack
	switch(m_AvPack) {
		case XC_AV_PACK_SCART:
			lstrcatW(m_szAvPackLine1, L"SCART ");
			break;

		case XC_AV_PACK_HDTV:
			lstrcatW(m_szAvPackLine1, L"HDTV ");
			break;

		case XC_AV_PACK_VGA:
			lstrcatW(m_szAvPackLine1, L"VGA ");
			break;

		case XC_AV_PACK_RFU:
			lstrcatW(m_szAvPackLine1, L"RFU ");
			break;

		case XC_AV_PACK_SVIDEO:
			lstrcatW(m_szAvPackLine1, L"SVIDEO ");
			break;

		case XC_AV_PACK_STANDARD:
			lstrcatW(m_szAvPackLine1, L"STANDARD ");
			break;

		case 7:
			lstrcatW(m_szAvPackLine1, L"NONE ");
			break;

		default:
			lstrcatW(m_szAvPackLine1, L"UNKNOWN ");
			break;
	}

	// Video Standard
	switch(m_VideoStandard) {
		case XC_VIDEO_STANDARD_NTSC_M:
			lstrcatW(m_szAvPackLine1, L"NTSC_M ");
			break;

		case XC_VIDEO_STANDARD_NTSC_J:
			lstrcatW(m_szAvPackLine1, L"NTSC_J ");
			break;

		case XC_VIDEO_STANDARD_PAL_I:
			lstrcatW(m_szAvPackLine1, L"PAL_I ");
			break;

		default:
			lstrcatW(m_szAvPackLine1, L"UNKNOWN ");
			break;
	}

	// Video Flags
	/*
	if((m_VideoFlags & XC_VIDEO_FLAGS_WIDESCREEN) == XC_VIDEO_FLAGS_WIDESCREEN) {
		lstrcatW(m_szAvPackLine1, L"WIDESCREEN ");
	}
		

	if((m_VideoFlags & XC_VIDEO_FLAGS_HDTV_720p) == XC_VIDEO_FLAGS_HDTV_720p) {
		lstrcatW(m_szAvPackLine1, L"HDTV 720p ");
	}

	if((m_VideoFlags & XC_VIDEO_FLAGS_HDTV_1080i) == XC_VIDEO_FLAGS_HDTV_1080i) {
		lstrcatW(m_szAvPackLine1, L"HDTV 1080i ");
	}

	if((m_VideoFlags & XC_VIDEO_FLAGS_LETTERBOX) == XC_VIDEO_FLAGS_LETTERBOX) {
		lstrcatW(m_szAvPackLine1, L"LETTERBOX ");
	}

	if((m_VideoFlags & XC_VIDEO_FLAGS_PAL_60Hz) == XC_VIDEO_FLAGS_PAL_60Hz) {
		lstrcatW(m_szAvPackLine1, L"PAL 60Hz ");
	}
	*/

	// Dimension
	wsprintfW(m_szAvPackLine2, L"%i x %i ", m_DisplayMode.Width, m_DisplayMode.Height);

	// Interlaced or Progressive
	if((m_DisplayMode.Flags & D3DPRESENTFLAG_INTERLACED) == D3DPRESENTFLAG_INTERLACED) {
		lstrcatW(m_szAvPackLine2, L"INTERLACED ");
	}

	if((m_DisplayMode.Flags & D3DPRESENTFLAG_PROGRESSIVE) == D3DPRESENTFLAG_PROGRESSIVE) {
		lstrcatW(m_szAvPackLine2, L"PROGRESSIVE ");
	}

	// Widescreen
	if((m_DisplayMode.Flags & D3DPRESENTFLAG_WIDESCREEN) == D3DPRESENTFLAG_WIDESCREEN) {
		lstrcatW(m_szAvPackLine2, L"WIDESCREEN ");
	}

	// Closed Captioning
	wsprintfW(m_szAvPackLine3, L"Closed Captioning %s", m_ClosedCaptioning ? L"ON" : L"OFF");

	OutputDebugStringW(m_szAvPackLine1);
	OutputDebugStringA("\n");
	OutputDebugStringW(m_szAvPackLine2);
	OutputDebugStringA("\n");
	OutputDebugStringW(m_szAvPackLine3);
	OutputDebugStringA("\n");
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Draws the scene
//-----------------------------------------------------------------------------
HRESULT CXBD3DDevice::Render() {
    
    m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET, 0, 1.0f, 0L);

	// Display graphic
	if(m_DisplayButtonMap) {
		ButtonMap();
	} else {
		SmpteBars();

		// Write AV Pack info to screen
		m_pd3dDevice->BeginScene();
		m_Font.DrawText((float)m_DisplayMode.Width*2/10 + (float)m_Font.m_dwFontHeight,
						(float)m_DisplayMode.Height*2/10 + (float)m_Font.m_dwFontHeight,
						0xffffffff, m_szAvPackLine1);
		m_Font.DrawText((float)m_DisplayMode.Width*2/10 + (float)m_Font.m_dwFontHeight,
						(float)m_DisplayMode.Height*2/10 + (float)m_Font.m_dwFontHeight*2,
						0xffffffff, m_szAvPackLine2);
		m_Font.DrawText((float)m_DisplayMode.Width*2/10 + (float)m_Font.m_dwFontHeight,
						(float)m_DisplayMode.Height*2/10 + (float)m_Font.m_dwFontHeight*3,
						0xffffffff, m_szAvPackLine3);
		m_pd3dDevice->EndScene();
	}
    
	// Finally, show the frame (swaps the backbuffer to the front)
	m_pd3dDevice->Present(NULL, NULL, NULL, NULL);

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: IREtoDW()
// Desc: Helper function for color value converstions
//-----------------------------------------------------------------------------
DWORD CXBD3DDevice::IREtoDW (double dfIre) {
	return ((DWORD)(dfIre*255.0/100.0));
}


//-----------------------------------------------------------------------------
// Name: SmpteBars()
// Desc: Displays SMPTE color bars, plus concentric rectangles, center target
//-----------------------------------------------------------------------------
BOOL CXBD3DDevice::SmpteBars(void) {
    D3DLOCKED_RECT  dr;
	D3DRECT			Rect;
    LPDWORD         pData;
    DWORD           dwR, dwG, dwB;
    D3DSURFACE_DESC	SurfDesc;
	DWORD			x, y, z;
	DWORD			WINDOW_WIDTH, WINDOW_HEIGHT, PitchAdjust;
	DWORD			Black, White, Width, Height;
	WCHAR			szwText[64];


    m_pBackBuffer->GetDesc(&SurfDesc);

	WINDOW_WIDTH = SurfDesc.Width;
	WINDOW_HEIGHT = SurfDesc.Height;

    ZeroMemory(&dr, sizeof(dr));
    m_pBackBuffer->LockRect(&dr, NULL, D3DLOCK_TILED) ;
	PitchAdjust = dr.Pitch/4 - WINDOW_WIDTH;
    pData = (LPDWORD)dr.pBits;

    ZeroMemory(pData, WINDOW_WIDTH * WINDOW_HEIGHT * 4);

    for (y = 0; y < WINDOW_HEIGHT; y++)
	{
		if (y < WINDOW_HEIGHT*3/4)
		{
			for (x = 0; x < 1*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(75.0);
				dwG = IREtoDW(75.0);
				dwB = IREtoDW(75.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 2*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(75.0);
				dwG = IREtoDW(75.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 3*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(75.0);
				dwB = IREtoDW(75.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 4*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(75.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 5*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(75.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(75.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 6*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(75.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 7*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(75.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 8*WINDOW_WIDTH/8; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
		}
		else if (y < WINDOW_HEIGHT)
		{
			for (x = 0; x < 1*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(10.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 2*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(100.0);
				dwG = IREtoDW(100.0);
				dwB = IREtoDW(100.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 3*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(10.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 4*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 5*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(4.2);
				dwG = IREtoDW(4.2);
				dwB = IREtoDW(4.2);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
			for (; x < 6*WINDOW_WIDTH/6; x++)
			{
				dwR = IREtoDW(0.0);
				dwG = IREtoDW(0.0);
				dwB = IREtoDW(0.0);
				*pData++ = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
			}
		}

		pData += PitchAdjust;
	}

	m_pBackBuffer->UnlockRect(); 
	
	// Center squares
	dwR = IREtoDW(0.0);
	dwG = IREtoDW(0.0);
	dwB = IREtoDW(0.0);
	Black = D3DCOLOR_ARGB(0, dwR, dwG, dwB);

	dwR = IREtoDW(100.0);
	dwG = IREtoDW(100.0);
	dwB = IREtoDW(100.0);
	White = D3DCOLOR_ARGB(0, dwR, dwG, dwB);
	
	Rect.x1 = WINDOW_WIDTH/2 - 30;
	Rect.y1 = WINDOW_HEIGHT/2 - 30;
	Rect.x2 = WINDOW_WIDTH/2 + 30;
	Rect.y2 = WINDOW_HEIGHT/2 + 30;
	
	ZeroMemory(&dr, sizeof(dr));
	m_pBackBuffer->LockRect(&dr, (const RECT *)&Rect, D3DLOCK_TILED) ;
	pData = (LPDWORD)dr.pBits;
	PitchAdjust = dr.Pitch/4 - 60;

	for(y = 0; y < 30; y++) {
		for(x = 0; x < 30; x++) {
			*pData++ = Black;
		}

		for(x = 30 ; x < 60; x++) {
			*pData++ = White;
		}

		pData += PitchAdjust;
	}

	for(y = 30; y < 60; y++) {
		for(x = 0; x < 30; x++) {
			*pData++ = White;
		}

		for(x = 30 ; x < 60; x++) {
			*pData++ = Black;
		}

		pData += PitchAdjust;
	}

	m_pBackBuffer->UnlockRect(); 

	// Concentric Rectangles
	for(z = 0; z <= 20; z += 5) {
		Width = WINDOW_WIDTH*(100 - z)/100;
		Height = WINDOW_HEIGHT*(100 - z)/100;

		Rect.x1 = (WINDOW_WIDTH - Width)/2;
		Rect.y1 = (WINDOW_HEIGHT - Height)/2;
		Rect.x2 = WINDOW_WIDTH - Rect.x1;
		Rect.y2 = WINDOW_HEIGHT - Rect.y1;
		
		ZeroMemory(&dr, sizeof(dr));
		m_pBackBuffer->LockRect(&dr, (const RECT *)&Rect, D3DLOCK_TILED) ;
		pData = (LPDWORD)dr.pBits;
		PitchAdjust = dr.Pitch/4 - Width;

		// Top two lines
		for(y = 0; y < 2; y++) {
			for(x = 0; x < Width; x++) {
				if(*pData == White) {
					*pData++ = Black;
				} else {
					*pData++ = White;
				}
			}
			pData += PitchAdjust;
		}

		// Sides
		for(y = 2; y < Height - 2; y++) {
			for(x = 0; x < Width; x++) {
				if((x < 2) || (x > Width - 3)) {
					if(*pData == White) {
						*pData = Black;
					} else {
						*pData = White;
					}
				}
				pData++;
			}
			pData += PitchAdjust;
		}

		// Bottom two lines
		for(y = Height - 2; y < Height; y++) {
			for(x = 0; x < Width; x++) {
				if(*pData == White) {
					*pData++ = Black;
				} else {
					*pData++ = White;
				}
			}
			pData += PitchAdjust;
		}

		m_pBackBuffer->UnlockRect(); 

		// Display %
		wsprintfW(szwText, L"%i%%", z);
		m_Font.DrawText((FLOAT)Rect.x1, (FLOAT)Rect.y2 - (float)m_Font.m_dwFontHeight - (FLOAT)z*4, 0xffffffff, szwText);
	}
    return TRUE;
}


//-----------------------------------------------------------------------------
// Name: ButtonMap()
// Desc: Displays controller button mapping
//-----------------------------------------------------------------------------
BOOL CXBD3DDevice::ButtonMap(void) {
	FLOAT x, y;
	WCHAR			szwText[64];

	// Starting position of text (20% corner)
	x = (float)m_DisplayMode.Width*2/10;
	y = (float)m_DisplayMode.Height*2/10;

	m_pd3dDevice->BeginScene();
	wsprintfW(szwText, L"Controller Button Map");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"Start = Toggle Widescreen");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"Back = Toggle Closed Captioning");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"Black = Toggle Display Button Map");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"A = HDTV Only: 640 x 480p");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"B = HDTV Only: 720 x 480p");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"X = HDTV Only: 640 x 480i");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"Y = HDTV Only: 1920 x 1080i");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	wsprintfW(szwText, L"Both Triggers + Black = Reboot");
	m_Font.DrawText(x, y, 0xffffffff, szwText);
	y += m_Font.m_dwFontHeight;

	m_pd3dDevice->EndScene();
	return TRUE;
}


//-----------------------------------------------------------------------------
// Name: main()
// Desc: main routine of application
//-----------------------------------------------------------------------------
void __cdecl main() {
	HRESULT hr;
	XBGAMEPAD *pGamePad, DefaultGamePad;
	DWORD i, b;
	CXBD3DDevice xbApp;

	// Init game pads
	XInitDevices(0, NULL);

	// Create the gamepad devices
    OutputDebugStringA("XBApp: Creating gamepad devices...\n");
    if(FAILED(hr = XBInput_CreateGamepads(&pGamePad))) {
        OutputDebugStringA("XBApp: Call to CreateGamepads() FAILED!\n");
        Sleep(INFINITE);
    }

	if(FAILED(xbApp.Init())) {
        OutputDebugStringA("XBApp: Init() FAILED!\n");
        Sleep(INFINITE);
    }

	if(FAILED(xbApp.Create())) {
        OutputDebugStringA("XBApp: Create() FAILED!\n");
        Sleep(INFINITE);
    }

	if(FAILED(xbApp.Render())) {
        OutputDebugStringA("XBApp: Render() FAILED!\n");
        Sleep(INFINITE);
    }

	while(TRUE) {
		// Get Input
		XBInput_GetInput(pGamePad);

		// Combine input from all attached controllers
		 ZeroMemory(&DefaultGamePad, sizeof(DefaultGamePad));
        for(i = 0; i < 4; i++) {
            if(pGamePad[i].hDevice) {
				DefaultGamePad.sThumbLX = DefaultGamePad.sThumbLX + pGamePad[i].sThumbLX;
                DefaultGamePad.sThumbLY = DefaultGamePad.sThumbLY + pGamePad[i].sThumbLY;
                DefaultGamePad.sThumbRX = DefaultGamePad.sThumbRX + pGamePad[i].sThumbRX;
                DefaultGamePad.sThumbRY = DefaultGamePad.sThumbRY + pGamePad[i].sThumbRY;
                DefaultGamePad.fX1      += pGamePad[i].fX1;
                DefaultGamePad.fY1      += pGamePad[i].fY1;
                DefaultGamePad.fX2      += pGamePad[i].fX2;
                DefaultGamePad.fY2      += pGamePad[i].fY2;
                DefaultGamePad.wButtons        |= pGamePad[i].wButtons;
                DefaultGamePad.wPressedButtons |= pGamePad[i].wPressedButtons;
                DefaultGamePad.wLastButtons    |= pGamePad[i].wLastButtons;

                for(b =0 ; b < 8; b++) {
                    DefaultGamePad.bAnalogButtons[b]        |= pGamePad[i].bAnalogButtons[b];
                    DefaultGamePad.bPressedAnalogButtons[b] |= pGamePad[i].bPressedAnalogButtons[b];
                    DefaultGamePad.bLastAnalogButtons[b]    |= pGamePad[i].bLastAnalogButtons[b];
                }
            }
        }

		// Reboot
		if(DefaultGamePad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0) {
            if(DefaultGamePad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0) {
                if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK]) {
                    XLaunchNewImage( NULL, NULL );
				}
			}
		}

		// Check for Widescreen toggle (only for 640 wide)
		if(xbApp.m_DisplayWidth	== 640) {
			if((DefaultGamePad.wPressedButtons & XINPUT_GAMEPAD_START) == XINPUT_GAMEPAD_START) {
				xbApp.m_Widescreen = !(xbApp.m_Widescreen);
				xbApp.Reset();
			}
		}

		// Check for Closed Captioning toggle
		if((DefaultGamePad.wPressedButtons & XINPUT_GAMEPAD_BACK) == XINPUT_GAMEPAD_BACK) {
			xbApp.m_ClosedCaptioning = !(xbApp.m_ClosedCaptioning);
			xbApp.Reset();
		}


		// Check for button mapping display toggle
		if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK]) {
		// if((DefaultGamePad.wPressedButtons & XINPUT_GAMEPAD_BLACK) == XINPUT_GAMEPAD_BLACK) {
			xbApp.m_DisplayButtonMap = !(xbApp.m_DisplayButtonMap);
		}
	
		// Check for mode changes
		if(xbApp.m_AvPack == XC_AV_PACK_HDTV) {
			// If HDTV then check for mode changes
			if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_A]) {
				// A Button = 640x480p
				xbApp.m_DisplayWidth	= 640;
				xbApp.m_DisplayHeight	= 480;
				xbApp.m_Interlaced	= FALSE;
				xbApp.Reset();
			}

			if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_B]) {
				// B Button = 720x480p
				xbApp.m_DisplayWidth	= 720;
				xbApp.m_DisplayHeight	= 480;
				xbApp.m_Interlaced	= FALSE;
				xbApp.m_Widescreen	= TRUE;
				xbApp.Reset();
			}

			if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_X]) {
				// X Button = 640x480i
				xbApp.m_DisplayWidth	= 640;
				xbApp.m_DisplayHeight	= 480;
				xbApp.m_Interlaced	= TRUE;
				xbApp.Reset();
			}

			if(DefaultGamePad.bPressedAnalogButtons[XINPUT_GAMEPAD_Y]) {
				// Y Button = 1920x1080i
				xbApp.m_DisplayWidth	= 1920;
				xbApp.m_DisplayHeight	= 1080;
				xbApp.m_Interlaced	= TRUE;
				xbApp.m_Widescreen	= TRUE;
				xbApp.Reset();
			}
		}

		if(FAILED(xbApp.Render())) {
			OutputDebugStringA("XBApp: Render() FAILED!\n");
			Sleep(INFINITE);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

	// AV Pack variables
	DWORD					m_AvPack;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\cpuid\cpuid.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    cpuid.cpp

Abstract:

    cpuid test 

by:

    Jason Gould (jgould) 5 sept 2000

Environment:

    XBox

Revision History:

	Changed to stand alone xbox app.
	Added screeen output using dxconio.lib

--*/

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

union Features
{
	DWORD reg;
	struct
	{
		DWORD FPU:1;
		DWORD VME:1;
		DWORD DE:1;
		DWORD PSE:1;
		DWORD TSC:1;
		DWORD MSR:1;
		DWORD PAE:1;
		DWORD MCE:1;
		DWORD CXS:1;
		DWORD APIC:1;
		DWORD RES1:2;
		DWORD MTRR:1;
		DWORD PGE:1;
		DWORD MCA:1;
		DWORD CMOV:1;
		DWORD WHOKNOWS:7;
		DWORD MMX:1;
		DWORD FXSR:1;
		DWORD XMM:1;
		DWORD WNI:1;	//bit 26
	} p_reg;
};


char* features[] = {
	"Floating-Point Unit",
	"Virtual 8086 Mode",
	"Debugging Extensions",
	"Page Size Extensions",
	"Time Stamp Counter",
	"Machine Specific Registers",
	"Physical Address Extension",
	"Machine Check Excption",
	"CMPXCHG8B Instruction",
	"APIC",
	"Reserved",
	"Fast System Call",
	"Memory Type Range Registers",
	"PTE Global Flag",
	"Machine Check ARchitecture",
	"Conditional Move and Compare Instructions",
	"Page Attribute Table",
	"36-byte Page Size Extension",
	"Processor Number",
	"Reserved",
	"Reserved",
	"Reserved",
	"Reserved",
	"MMX Technology",
	"Fast FP/MMX/XMM Save/Restore",
	"XMM/Streaming SIMD Instructions"
};

char * proctypes[] = {
	"Origonal OEM Processor",
	"Intel Overdrive Processor",
	"Duel-Proc",
	"Reserved"
};

VOID
WINAPI
CpuIDStartTest(HANDLE LogHandle)
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/ 
{
    // HANDLE atapt;
	DWORD a, d;
	int i;

    xSetComponent( LogHandle, "Harness", "cpuid" );
    xSetFunctionName(LogHandle, "StartTest" );

	_asm {
		xor eax, eax
		inc eax
		cpuid
		mov [a], eax
		mov [d], edx
	}

    xStartVariation(gbConsoleOut, LogHandle, "CPUID: ProcInfo");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Processor Info: %08x", a);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Stepping ID: %d", a & 15);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Model: %d", ((a >> 4) & 15));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Family: %d", ((a >> 8) & 15));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Processor Type: %s", proctypes[(a >> 12) & 3]);

    xEndVariation(LogHandle);

    xStartVariation(gbConsoleOut, LogHandle, "CPUID: ProcFeatures");
	
	for(i = 0; i < sizeof(features) / sizeof(features[0]); i++) {
		if(d & (1 << i)) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "%s Supported", features[i]);
		} else {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "%s NOT Supported", features[i]);
		}
	}

    xEndVariation(LogHandle);

    return;
}


VOID
WINAPI
CpuIDEndTest()
/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	HANDLE LogHandle;
	BOOL RunForever = TRUE;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\cpuid.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if (LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("CPUID: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }
	xSetOwnerAlias(LogHandle, "a-emebac");

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		gbConsoleOut = TRUE;
	}

	// Start Test
	CpuIDStartTest(LogHandle);

	// End Test
	CpuIDEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("CPUID: End - Waiting for reboot...\n");
	while (RunForever) {
	}

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// xlog
	xCloseLog(LogHandle);

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( cpuid )
#pragma data_seg()

BEGIN_EXPORT_TABLE( cpuid )
    EXPORT_TABLE_ENTRY( "StartTest", CpuIDStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", CpuIDEndTest )
END_EXPORT_TABLE( cpuid )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\AVPackTest\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\disktest\disktest.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    disktest.c

Abstract:

    Test low-level IDE disk things for the hardware team

written by:

    John Daly (johndaly) 11-Sept-2000

Environment:

    XBox

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <xtl.h>
#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#include <pshpack1.h>
typedef struct _IDE_SMART_DATA {
    UCHAR VendorSpecific1[362];                 // bytes 0-361
    UCHAR OffLineCollectionStatus;              // byte 362
    UCHAR VendorSpecific2;                      // byte 363
    WORD  SecondsToComplete;                    // bytes 364, 365
    UCHAR VendorSpecific3;                      // byte 366
    UCHAR OffLineCollectionCapability;          // byte 367
    WORD  SMARTCapability;                      // byte 368, 369
    UCHAR Reserved[16];                         // bytes 370-385
    UCHAR VendorSpecific4[124];                 // bytes 386-510
    UCHAR Checksum;                             // byte 511
} IDE_SMART_DATA, *PIDE_SMART_DATA;
#include <poppack.h>

//
// Valid values for the bCommandReg member of IDEREGS.
//

#define SMART_CMD       0xB0            // Performs SMART cmd.
                                        // Requires valid bFeaturesReg,
                                        // bCylLowReg, and bCylHighReg

//
// Cylinder register defines for SMART command
//

#define SMART_CYL_LOW   0x4F
#define SMART_CYL_HI    0xC2

//
// bDriverError values
//

#define SMART_NO_ERROR          0       // No error
#define SMART_IDE_ERROR         1       // Error from IDE controller
#define SMART_INVALID_FLAG      2       // Invalid command flag
#define SMART_INVALID_COMMAND   3       // Invalid command byte
#define SMART_INVALID_BUFFER    4       // Bad buffer (null, invalid addr..)
#define SMART_INVALID_DRIVE     5       // Drive number not valid
#define SMART_INVALID_IOCTL     6       // Invalid IOCTL
#define SMART_ERROR_NO_MEM      7       // Could not lock user's buffer
#define SMART_INVALID_REGISTER  8       // Some IDE Register not valid
#define SMART_NOT_SUPPORTED     9       // Invalid cmd flag set
#define SMART_NO_IDE_DEVICE     10      // Cmd issued to device not present
                                        // although drive number is valid

//
// Feature register defines for SMART "sub commands"
//

#define READ_ATTRIBUTES         0xD0
#define READ_THRESHOLDS         0xD1
#define ENABLE_DISABLE_AUTOSAVE 0xD2
#define SAVE_ATTRIBUTE_VALUES   0xD3
#define EXECUTE_OFFLINE_DIAGS   0xD4
#define ENABLE_SMART            0xD8
#define DISABLE_SMART           0xD9
#define RETURN_SMART_STATUS     0xDA
#define ENABLE_DISABLE_AUTO_OFFLINE 0xDB


//
// SMART stuff
//

#define SMART_SetRegs(fea) \
    ZeroMemory(atapt, sizeof(ATA_PASS_THROUGH) + 512);  \
    atapt->IdeReg.bCommandReg   = SMART_CMD;            \
    atapt->DataBufferSize       = 512;                  \
    atapt->DataBuffer           = atapt + 1;            \
    atapt->IdeReg.bFeaturesReg  = fea;                  \
    atapt->IdeReg.bCylLowReg    = SMART_CYL_LOW;        \
    atapt->IdeReg.bCylHighReg   = SMART_CYL_HI ;        \
    atapt->IdeReg.bDriveHeadReg = 0;

#define SMART_DumpRegs()    \
            xLog(DiskTestLogHandle, XLL_FAIL, "SMART Error Detected! Investigate");                         \
            xLog(DiskTestLogHandle, XLL_FAIL, "Error Reg;         0x%X ", atapt->IdeReg.bFeaturesReg);      \
            xLog(DiskTestLogHandle, XLL_FAIL, "Sector Count Reg;  0x%X ", atapt->IdeReg.bSectorCountReg);   \
            xLog(DiskTestLogHandle, XLL_FAIL, "Sector Number Reg; 0x%X ", atapt->IdeReg.bSectorNumberReg);  \
            xLog(DiskTestLogHandle, XLL_FAIL, "Cyl Low Reg;       0x%X ", atapt->IdeReg.bCylLowReg);        \
            xLog(DiskTestLogHandle, XLL_FAIL, "Cyl High Reg;      0x%X ", atapt->IdeReg.bCylHighReg);       \
            xLog(DiskTestLogHandle, XLL_FAIL, "Drive Head Reg;    0x%X ", atapt->IdeReg.bDriveHeadReg);     \
            xLog(DiskTestLogHandle, XLL_FAIL, "Status Reg;        0x%X ", atapt->IdeReg.bCommandReg);
            
#define IDE_Status_ERR   0x01
#define IDE_Status_DRQ   0x08
#define IDE_Status_SERV  0x10
#define IDE_Status_DF    0x20
#define IDE_Status_DRDY  0x40
#define IDE_Status_BSY   0x80

//
// timer stuff
//

LARGE_INTEGER Frequency;
LARGE_INTEGER PerformanceCount;

//
// State of current device stuff
// yes, I know that these wonderful global variables will lead to spaghetti code
// so sue me...
//

WORD Current_Device_Heads;
WORD Current_Device_Cylinders;
WORD Current_Device_Sectors;
DWORD Current_Device_LBASectors;

//
// function prototypes
//

VOID
WINAPI
StartTimer(
    VOID
    );

DWORD
WINAPI
EndTimer(
    VOID
    );

VOID
WINAPI
test_identify(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
         );

VOID
WINAPI
test_SMART(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
    );

VOID
WINAPI
test_Seek(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
    );

DWORD
WINAPI
RunSeekTest(
    WORD StartCylinder,
    WORD EndCylinder,
    WORD FullStrokes,
    HANDLE fileHandle
    );

DWORD
WINAPI
LBARunSeekTest(
    DWORD StartCylinder,
    DWORD EndCylinder,
    WORD FullStrokes,
    HANDLE fileHandle
    );

//
// Heap handle from HeapCreate
//

HANDLE DiskTestHeapHandle;
HANDLE DiskTestLogHandle;

VOID
WINAPI
DiskTestStartTest(
         HANDLE LogHandleX
         )
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    DiskTestLogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/ 
{
    DWORD accessMode, shareMode;
    HANDLE fileHandle;
    PIDEREGS pIdeReg;
    CHAR    string[100];
    char    stringa[100];
    ULONG   i, j;
    int DrivesFound = 0;
    IDE_IDENTIFY_DATA idedata = {0};
    DWORD x;

    DiskTestLogHandle = LogHandleX; // make this global - there is no threading intended for this
    
    //
    // set up the timer
    //

    if ( FALSE == QueryPerformanceFrequency(&Frequency) ) {
        ;// log and exit
    }

    for ( i=0; i<2; i++ ) {
        if ( i == 0 ) {
            sprintf (string, "\\\\.\\Device\\Harddisk0\\Partition0");
        } else {
            sprintf (string, "Cdrom0:");
        }

        shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;  // default
        accessMode = GENERIC_READ | GENERIC_WRITE;       // default

        fileHandle = CreateFile(string,
                                accessMode,
                                shareMode,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);


        if ( fileHandle == INVALID_HANDLE_VALUE ) {
            continue;
        } else {
            ++DrivesFound;
        }

        //
        // run test sequences
        //

        test_identify(fileHandle, string, i);
        test_SMART(fileHandle, string, i);
        test_Seek(fileHandle, string, i);

        //
        // end test sequences
        //

        CloseHandle(fileHandle);
    }
    
    sprintf (stringa, "DrivesFound: %d", DrivesFound);
    xLog(DiskTestLogHandle, XLL_INFO, stringa);

    return;
}

VOID
WINAPI
test_Seek(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
    )
/*++

Routine Description:

    measures the Full Stroke seek time (does not differentiate outer->inner, inner->outer)
    measures the track to track seek time from inner, middle, outer track

Arguments:

    HANDLE fileHandle - handle to the selected device
    PWCHAR DeviceName - name of device being tested
    int index - Id index, 0 or 1 (0 hd, 1 cd/dvd)

Return Value:

    None
    

--*/ 
{
    DWORD Time;

    xSetComponent( DiskTestLogHandle, "hwtest", "disktest" );
    xSetFunctionName(DiskTestLogHandle, "test_Seek" );
    xStartVariation( DiskTestLogHandle, "variation1" );

    //
    // for now, only do on disks
    //
    
    if ( index == 1 ) {

        return;
    }

    //
    // Experiment with LBA values - full stroke
    //
    
    Time = LBARunSeekTest(0, Current_Device_LBASectors, 1000, fileHandle);
    if (Time) {
        xLog(DiskTestLogHandle, 
             XLL_PASS, 
             "LBA full stroke, 1000 (inner->outer , outer->inner) cycles : Time: %10.10u ms",
             Time);
    } else {
        xLog(DiskTestLogHandle, 
             XLL_FAIL, 
             "LBA full stroke, 1000 (inner->outer , outer->inner) cycles : FAILED");
    }

    //
    // Full Stroke
    //
    
    Time = RunSeekTest(0, Current_Device_Cylinders, 1000, fileHandle);
    if (Time) {
        xLog(DiskTestLogHandle, 
             XLL_PASS, 
             "full stroke, 1000 (inner->outer , outer->inner) cycles : Time: %10.10u ms",
             Time);
    } else {
        xLog(DiskTestLogHandle, 
             XLL_FAIL, 
             "full stroke, 1000 (inner->outer , outer->inner) cycles : FAILED");
    }
    
    //
    // Track to track, inner
    //
    
    Time = RunSeekTest(0, 1, 1000, fileHandle);
    if (Time) {
    xLog(DiskTestLogHandle, 
         XLL_PASS, 
         "track to track, 1000 (inner->inner + 1, inner + 1 ->inner) cycles : Time: %10.10u ms",
         Time);
    } else {
        xLog(DiskTestLogHandle, 
             XLL_FAIL, 
             "track to track, 1000 (inner->inner + 1, inner + 1 ->inner) cycles : FAILED");
    }
    
    
    //
    // Track to track, middle
    //
    
    Time = RunSeekTest((Current_Device_Cylinders / 2), (Current_Device_Cylinders / 2) + 1, 1000, fileHandle);
    if (Time) {
    xLog(DiskTestLogHandle, 
         XLL_PASS, 
         "track to track, 1000 (middle->middle + 1, middle + 1 -> middle) cycles : Time: %10.10u ms",
         Time);
    } else {
        xLog(DiskTestLogHandle, 
             XLL_FAIL, 
             "track to track, 1000 (middle->middle + 1, middle + 1 -> middle) cycles : FAILED");
    }
    
    //
    // Track to track, outer
    //

    Time = RunSeekTest(Current_Device_Cylinders, Current_Device_Cylinders - 1, 1000, fileHandle);
    if (Time) {
    xLog(DiskTestLogHandle, 
         XLL_PASS, 
         "track to track, 1000 (outer->outer - 1, outer - 1 ->outer) cycles : Time: %10.10u ms",
         Time);
    } else {
        xLog(DiskTestLogHandle, 
             XLL_FAIL, 
             "track to track, 1000 (outer->outer - 1, outer - 1 ->outer) cycles : FAILED");
    }
    
    xEndVariation( DiskTestLogHandle );
}

DWORD
WINAPI
RunSeekTest(
    WORD StartCylinder,
    WORD EndCylinder,
    WORD FullStrokes,
    HANDLE fileHandle
    )
/*++

Routine Description:

    measures the Full Stroke seek time (does not differentiate outer->inner, inner->outer)

Arguments:

    WORD StartCylinder - cylinder to start on
    WORD EndCylinder - cylinder to stop on
    WORD FullStrokes - number of times to move the head
    HANDLE fileHandle - handle to device

Return Value:

    DWORD - elapsed time in Milliseconds
    

--*/ 
{
    BOOL status;
    PATA_PASS_THROUGH atapt;
    DWORD x;
    DWORD returned;

    atapt = HeapAlloc(DiskTestHeapHandle, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(ATA_PASS_THROUGH)); 

    if ( !atapt ) {
        xLog(DiskTestLogHandle, XLL_BLOCK, "memory allocation failure");
        return(0);
    }

    //
    // always start on the same track
    //

    atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = (BYTE)(StartCylinder & 0xFF) ;
    atapt->IdeReg.bCylHighReg      = (BYTE)((StartCylinder & 0xFF00) >> 8);
    atapt->IdeReg.bDriveHeadReg    = 0 | 0x1 /* head 1*/;
    atapt->IdeReg.bHostSendsData   = 0;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
        //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
    }
    
    //
    // start timer
    //

    StartTimer();

    for (x = 0; x < 1000; x++) {

        //
        // seek beginning
        //

        atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
        atapt->IdeReg.bSectorNumberReg = 0;
        atapt->IdeReg.bCylLowReg       = (BYTE)(StartCylinder & 0xFF) ;
        atapt->IdeReg.bCylHighReg      = (BYTE)((StartCylinder & 0xFF00) >> 8);
        atapt->IdeReg.bDriveHeadReg    = 0 | 0x01 /* head 1*/;
        atapt->IdeReg.bHostSendsData   = 0;

        status = DeviceIoControl(fileHandle,
                                 IOCTL_IDE_PASS_THROUGH,
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 &returned,
                                 NULL);
        if ( status != 0 ) {
            if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
                (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
                !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
                SMART_DumpRegs()
            } else {                       
            //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
            }
        } else {
            xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
        }
        
        //
        // seek end
        // 

        atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
        atapt->IdeReg.bSectorNumberReg = 0x0;
        atapt->IdeReg.bCylLowReg       = (BYTE)(EndCylinder & 0xFF) ;
        atapt->IdeReg.bCylHighReg      = (BYTE)((EndCylinder & 0xFF00) >> 8);
        atapt->IdeReg.bDriveHeadReg    = 0 | 0x01 /* head 1*/;
        atapt->IdeReg.bHostSendsData   = 0;

        status = DeviceIoControl(fileHandle,
                                 IOCTL_IDE_PASS_THROUGH,
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 &returned,
                                 NULL);

        if ( status != 0 ) {
            if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
                (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
                !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
                SMART_DumpRegs()
            } else {                       
            //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
            }
        } else {
            xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
        }

    }

    //
    // stop timer
    //

    HeapFree (DiskTestHeapHandle, HEAP_NO_SERIALIZE, atapt);
    return(EndTimer());
    
}
    
DWORD
WINAPI
LBARunSeekTest(
    DWORD StartCylinder,
    DWORD EndCylinder,
    WORD FullStrokes,
    HANDLE fileHandle
    )
/*++

Routine Description:

    measures the Full Stroke seek time (does not differentiate outer->inner, inner->outer)

Arguments:

    WORD StartCylinder - cylinder to start on
    WORD EndCylinder - cylinder to stop on
    WORD FullStrokes - number of times to move the head
    HANDLE fileHandle - handle to device

Return Value:

    DWORD - elapsed time in Milliseconds
    

--*/ 
{
    BOOL status;
    PATA_PASS_THROUGH atapt;
    DWORD x;
    DWORD returned;

    atapt = HeapAlloc(DiskTestHeapHandle, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(ATA_PASS_THROUGH)); 

    if ( !atapt ) {
        xLog(DiskTestLogHandle, XLL_BLOCK, "memory allocation failure");
        return(0);
    }
    
    //
    // always start on the same track
    //

    atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
    atapt->IdeReg.bSectorNumberReg = (BYTE)(StartCylinder & 0xFF);
    atapt->IdeReg.bCylLowReg       = (BYTE)((StartCylinder & 0xFF00) >> 8);
    atapt->IdeReg.bCylHighReg      = (BYTE)((StartCylinder & 0xFF0000) >> 16);
    atapt->IdeReg.bDriveHeadReg    = (BYTE)((StartCylinder & 0x07000000) >> 24) | 0x20 /* LBA */;
    atapt->IdeReg.bHostSendsData   = 0;

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
        //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
    }
    
    //
    // start timer
    //

    StartTimer();

    for (x = 0; x < 1000; x++) {

        //
        // seek beginning
        //

        atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
        atapt->IdeReg.bSectorNumberReg = (BYTE)(StartCylinder & 0xFF);
        atapt->IdeReg.bCylLowReg       = (BYTE)((StartCylinder & 0xFF00) >> 8);
        atapt->IdeReg.bCylHighReg      = (BYTE)((StartCylinder & 0xFF0000) >> 16);
        atapt->IdeReg.bDriveHeadReg    = (BYTE)((StartCylinder & 0x07000000) >> 24) | 0x20 /* LBA */;
        atapt->IdeReg.bHostSendsData   = 0;

        status = DeviceIoControl(fileHandle,
                                 IOCTL_IDE_PASS_THROUGH,
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 &returned,
                                 NULL);
        if ( status != 0 ) {
            if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
                (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
                !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
                SMART_DumpRegs()
            } else {                       
            //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
            }
        } else {
            xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
        }
        
        //
        // seek end
        // 

        atapt->IdeReg.bCommandReg      = 0x70;  // SEEK
        atapt->IdeReg.bSectorNumberReg = (BYTE)(EndCylinder & 0xFF);
        atapt->IdeReg.bCylLowReg       = (BYTE)((EndCylinder & 0xFF00) >> 8);
        atapt->IdeReg.bCylHighReg      = (BYTE)((EndCylinder & 0xFF0000) >> 16);
        atapt->IdeReg.bDriveHeadReg    = (BYTE)((EndCylinder & 0x07000000) >> 24) | 0x20 /* LBA */;
        atapt->IdeReg.bHostSendsData   = 0;

        status = DeviceIoControl(fileHandle,
                                 IOCTL_IDE_PASS_THROUGH,
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 atapt,
                                 sizeof(ATA_PASS_THROUGH),
                                 &returned,
                                 NULL);

        if ( status != 0 ) {
            if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
                (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
                !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
                (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
                SMART_DumpRegs()
            } else {                       
            //    xLog(DiskTestLogHandle, XLL_PASS, "SEEK:SUCCEEDED");
            }
        } else {
            xLog(DiskTestLogHandle, XLL_FAIL, "SEEK:FAILED");
        }

    }

    //
    // stop timer
    //

    HeapFree (DiskTestHeapHandle, HEAP_NO_SERIALIZE, atapt);
    return(EndTimer());
    
}

VOID
WINAPI
test_identify(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
    )
/*++

Routine Description:

    Identifies the device and logs capabilities (like idelog)

Arguments:

    HANDLE fileHandle - handle to the selected device
    PWCHAR DeviceName - name of device being tested
    int index - Id index, 0 or 1 (0 hd, 1 cd/dvd)

Return Value:

    None

--*/
{
#define temp_buff_len   100
    BOOL status;
    int i;
    UCHAR tempBuf[temp_buff_len];
    USHORT bitmap;
    ULONG mode;
    PATA_PASS_THROUGH atapt;
    ULONG length, errorCode, returned;
    PIDE_IDENTIFY_DATA IdData;

    xSetComponent( DiskTestLogHandle, "hwtest", "disktest" );
    xSetFunctionName(DiskTestLogHandle, "test_identify" );
    xStartVariation( DiskTestLogHandle, "variation1" );

    atapt = HeapAlloc(DiskTestHeapHandle, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(ATA_PASS_THROUGH) + 512);

    if ( !atapt ) {
        xLog(DiskTestLogHandle, XLL_BLOCK, "memory allocation failure");
        return;
    }

    atapt->DataBufferSize = 512;
    atapt->DataBuffer = atapt + 1;
    atapt->IdeReg.bFeaturesReg     = 0;
    atapt->IdeReg.bSectorCountReg  = 0;
    atapt->IdeReg.bSectorNumberReg = 0;
    atapt->IdeReg.bCylLowReg       = 0;
    atapt->IdeReg.bCylHighReg      = 0;
    atapt->IdeReg.bDriveHeadReg    = 0;
    atapt->IdeReg.bHostSendsData   = 0;

    if ( index == 0 ) {

        atapt->IdeReg.bCommandReg      = 0xec;  // IDENTIFY DEVICE

    } else {

        atapt->IdeReg.bCommandReg      = 0xa1;  // IDENTIFY PACKET DEVICE
    }

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);

    if ( status != 0 ) {
        IdData = (PIDE_IDENTIFY_DATA)atapt->DataBuffer;

        xLog(DiskTestLogHandle, XLL_PASS, "%s", DeviceName);

        if ( IdData->GeneralConfiguration & (1 << 15) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "ATAPI device");
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "ATA device");
        }

        if ( IdData->GeneralConfiguration & (1 << 7) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "removable media device");
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "non-removable media device");
        }

        if ( IdData->MediaStatusNotification & 1 ) {

            xLog(DiskTestLogHandle, XLL_PASS, "MSN supported");
        } else {

            xLog(DiskTestLogHandle, XLL_PASS, "MSN not supported");
        }

        xLog(DiskTestLogHandle, XLL_PASS, "ATA standard supported: ");
        bitmap = IdData->MajorRevision;
        mode = 0;
        if ( (bitmap != 0) && (bitmap != 0xffff) ) {

            bitmap >>= 1;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "ATA-%d ", mode);
                }
                bitmap >>= 1;
                mode++;
            }
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "none");
        }

        for ( i=0; i<sizeof(IdData->ModelNumber); i+=2 ) {
            tempBuf[i + 0] = IdData->ModelNumber[i + 1];
            tempBuf[i + 1] = IdData->ModelNumber[i + 0];
        }
        tempBuf[i] = 0;
        xLog(DiskTestLogHandle, XLL_PASS, "Model Number: %s", tempBuf);

        for ( i=0; i<sizeof(IdData->SerialNumber); i+=2 ) {
            tempBuf[i + 0] = IdData->SerialNumber[i + 1];
            tempBuf[i + 1] = IdData->SerialNumber[i + 0];
        }
        tempBuf[i] = 0;
        xLog(DiskTestLogHandle, XLL_PASS, "Serial Number: %s", tempBuf);

        for ( i=0; i<sizeof(IdData->FirmwareRevision); i+=2 ) {
            tempBuf[i + 0] = IdData->FirmwareRevision[i + 1];
            tempBuf[i + 1] = IdData->FirmwareRevision[i + 0];
        }
        tempBuf[i] = 0;
        xLog(DiskTestLogHandle, XLL_PASS, "Firmware Revision: %s", tempBuf);

        xLog(DiskTestLogHandle, XLL_PASS, "default number of logical cylinder: 0x%x (%d)", IdData->NumberOfCylinders, IdData->NumberOfCylinders);
        xLog(DiskTestLogHandle, XLL_PASS, "default number of heads: 0x%x (%d)", IdData->NumberOfHeads, IdData->NumberOfHeads);
        xLog(DiskTestLogHandle, XLL_PASS, "default number of sectors per track: 0x%x (%d)", IdData->NumberOfSectorsPerTrack, IdData->NumberOfSectorsPerTrack);

        if ( IdData->MaximumBlockTransfer & 0xff ) {
            xLog(DiskTestLogHandle, XLL_PASS, "maximum number of sectors for READ/WRITE MULTIPLE: 0x%x (%d)", IdData->MaximumBlockTransfer, IdData->MaximumBlockTransfer & 0xf, IdData->MaximumBlockTransfer & 0xf);
        }
        if ( IdData->CurrentMultiSectorSetting & (1 << 8) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "current number of sectors for READ/WRITE MULTIPLE: 0x%x (%d)", IdData->MaximumBlockTransfer, IdData->MaximumBlockTransfer & 0xf, IdData->CurrentMultiSectorSetting & 0xf);
        }

        if ( IdData->Capabilities & (1 << 10) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "IORDY can be disabled");
        }
        if ( IdData->Capabilities & (1 << 11) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "IORDY is supported");
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "IORDY may be supported");
        }

        xLog(DiskTestLogHandle, XLL_PASS, "Highest PIO mode supported: 0x%x (%d)", IdData->PioCycleTimingMode, IdData->PioCycleTimingMode);

        if ( IdData->TranslationFieldsValid & 1 << 0 ) {

            xLog(DiskTestLogHandle, XLL_PASS, "current number of logical cylinder: 0x%x (%d)", IdData->NumberOfCurrentCylinders, IdData->NumberOfCurrentCylinders);
            Current_Device_Cylinders = IdData->NumberOfCurrentCylinders;
            xLog(DiskTestLogHandle, XLL_PASS, "current number of heads: 0x%x (%d)", IdData->NumberOfCurrentHeads, IdData->NumberOfCurrentHeads);
            Current_Device_Heads = IdData->NumberOfCurrentHeads;
            xLog(DiskTestLogHandle, XLL_PASS, "current number of sectors per track: 0x%x (%d)", IdData->CurrentSectorsPerTrack, IdData->CurrentSectorsPerTrack);
            Current_Device_Sectors = IdData->CurrentSectorsPerTrack;
            xLog(DiskTestLogHandle, XLL_PASS, "current capacity in sectors: 0x%x (%d)", IdData->CurrentSectorCapacity, IdData->CurrentSectorCapacity);
        }

        xLog(DiskTestLogHandle, XLL_PASS, "total number of user addressable LBA sectors: 0x%x (%d)", IdData->UserAddressableSectors, IdData->UserAddressableSectors);
        Current_Device_LBASectors = IdData->UserAddressableSectors;

        if ( IdData->TranslationFieldsValid & (1 << 1) ) {

            xLog(DiskTestLogHandle, XLL_PASS, "advanced PIO supported: ");
            bitmap = IdData->AdvancedPIOModes;
            mode = 0;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode + 3);
                }
                bitmap >>= 1;
                mode++;
            }
            if ( IdData->AdvancedPIOModes ) {
                ;
            } else {
                xLog(DiskTestLogHandle, XLL_PASS, "none");
            }

            xLog(DiskTestLogHandle, XLL_PASS, "sinlgeword DMA supported: ");
            bitmap = IdData->SingleWordDMASupport;
            mode = 0;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
                }
                bitmap >>= 1;
                mode++;
            }
            if ( IdData->SingleWordDMASupport ) {
                ;
            } else {
                xLog(DiskTestLogHandle, XLL_PASS, "none");
            }

            xLog(DiskTestLogHandle, XLL_PASS, "sinlgeword DMA active: ");
            bitmap = IdData->SingleWordDMAActive;
            mode = 0;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
                }
                bitmap >>= 1;
                mode++;
            }
            if ( IdData->SingleWordDMAActive ) {
                ;
            } else {
                xLog(DiskTestLogHandle, XLL_PASS, "none");
            }
        }

        xLog(DiskTestLogHandle, XLL_PASS, "multiword DMA supported: ");
        bitmap = IdData->MultiWordDMASupport;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->MultiWordDMASupport ) {
            ;
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "none");
        }

        xLog(DiskTestLogHandle, XLL_PASS, "multiword DMA active: ");
        bitmap = IdData->MultiWordDMAActive;
        mode = 0;
        while ( bitmap ) {

            if ( bitmap & 1 ) {
                xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
            }
            bitmap >>= 1;
            mode++;
        }
        if ( IdData->MultiWordDMAActive ) {
            ;
        } else {
            xLog(DiskTestLogHandle, XLL_PASS, "none");
        }

        if ( IdData->TranslationFieldsValid & (1 << 1) ) {
            xLog(DiskTestLogHandle, XLL_PASS, "min multiword DMA transfer cycle time (ns): 0x%x (%d)", IdData->MinimumMWXferCycleTime, IdData->MinimumMWXferCycleTime);
            xLog(DiskTestLogHandle, XLL_PASS, "recommended multiword DMA transfer cycle time (ns): 0x%x (%d)", IdData->RecommendedMWXferCycleTime, IdData->RecommendedMWXferCycleTime);
            xLog(DiskTestLogHandle, XLL_PASS, "min PIO transfer cycle time (ns) w/o flow control: 0x%x (%d)", IdData->MinimumPIOCycleTime, IdData->MinimumPIOCycleTime);
            xLog(DiskTestLogHandle, XLL_PASS, "min PIO transfer cycle time (ns) w/ flow control: 0x%x (%d)", IdData->MinimumPIOCycleTimeIORDY, IdData->MinimumPIOCycleTimeIORDY);
        }

        if ( IdData->TranslationFieldsValid & (1 << 2) ) {

            xLog(DiskTestLogHandle, XLL_PASS, "ultra DMA supported: ");
            bitmap = IdData->UltraDMASupport;
            mode = 0;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
                }
                bitmap >>= 1;
                mode++;
            }
            if ( IdData->UltraDMASupport ) {
                ;
            } else {
                xLog(DiskTestLogHandle, XLL_PASS, "none");
            }

            xLog(DiskTestLogHandle, XLL_PASS, "ultra DMA active: ");
            bitmap = IdData->UltraDMAActive;
            mode = 0;
            while ( bitmap ) {

                if ( bitmap & 1 ) {
                    xLog(DiskTestLogHandle, XLL_PASS, "mode %d ", mode);
                }
                bitmap >>= 1;
                mode++;
            }
            if ( IdData->UltraDMAActive ) {
                ;
            } else {
                xLog(DiskTestLogHandle, XLL_PASS, "none");
            }
        }

        xLog(DiskTestLogHandle, XLL_PASS, "number of unformatted bytes per track: 0x%x (%d)", IdData->Reserved2[0], IdData->Reserved2[0]);
        xLog(DiskTestLogHandle, XLL_PASS, "number of unformatted bytes per sector: 0x%x (%d)", IdData->Reserved2[1], IdData->Reserved2[1]);

    }

    HeapFree (DiskTestHeapHandle, HEAP_NO_SERIALIZE, atapt);
    xEndVariation( DiskTestLogHandle );
}

VOID
WINAPI
test_SMART(
    HANDLE fileHandle,
    PCHAR DeviceName,
    int index
    )
/*++

Routine Description:

    execute all the SMART commands against the selected device:
    SMART READ DATA
    SMART ENABLE/DISABLE ATTRIBUTE AUTOSAVE
    SMART SAVE ATTRIBUTE VALUES
    SMART EXECUTE OFF-LINE IMMEDIATE
    SMART ENABLE OPERATIONS
    SMART DISABLE OPERATIONS
    SMART RETURN STATUS

Arguments:

    HANDLE fileHandle - handle to the selected device
    PWCHAR DeviceName - name of device being tested
    int index - Id index, 0 or 1 (0 hd, 1 cd/dvd)

Return Value:

    None

--*/ 
{
    PATA_PASS_THROUGH atapt;
    BOOL status;
    ULONG returned;
    PIDE_SMART_DATA pSmart;
    PUCHAR pSmartChar;
    DWORD x;
    UCHAR checksum;

    xSetComponent( DiskTestLogHandle, "hwtest", "disktest" );
    xSetFunctionName(DiskTestLogHandle, "test_SMART" );
    xStartVariation( DiskTestLogHandle, "variation1" );

    //
    // SMART only works with disk drives, not CD-ROM devices, so punt
    //

    if ( index == 1 ) {

        return;
    }

    atapt = HeapAlloc(DiskTestHeapHandle, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, sizeof(ATA_PASS_THROUGH) + 512); 

    if ( !atapt ) {
        xLog(DiskTestLogHandle, XLL_BLOCK, "memory allocation failure");
        return;
    }

    // 
    // SMART ENABLE OPERATIONS
    // run this one first to make sure SMART is turned on
    // 
    
    SMART_SetRegs (ENABLE_SMART)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {

        //
        // check registers
        // note that we are abusing the struct here, but it should work and not ever change
        // (fameous last words...)
        //
        // atapt->IdeReg.bFeaturesReg;     // becomes Error after call 
        // atapt->IdeReg.bCommandReg;      // becomes Status after call
        //

        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:ENABLE_SMART:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:ENABLE_SMART:FAILED");
    }
    
    //
    // SMART READ DATA
    //

    SMART_SetRegs (READ_ATTRIBUTES)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);

    if ( status != 0 ) {

        //
        // check / verify / log returned data
        //

        pSmart = (PIDE_SMART_DATA)atapt->DataBuffer;
        pSmartChar = (PUCHAR)pSmart;
        
        switch (pSmart->OffLineCollectionStatus) {
            case 0x00:
            case 0x80:
                xLog(DiskTestLogHandle,
                     XLL_PASS, 
                     "OffLineCollectionStatus = never started : 0x%2.2x", 
                     pSmart->OffLineCollectionStatus);
                break;

            case 0x02:
            case 0x82:
                xLog(DiskTestLogHandle, 
                     XLL_PASS, 
                     "OffLineCollectionStatus = completed, no errors : 0x%2.2x",
                     pSmart->OffLineCollectionStatus);
                break;

            case 0x04:
            case 0x84:
                xLog(DiskTestLogHandle, 
                     XLL_PASS, 
                     "OffLineCollectionStatus = suspended, interrupted by host : 0x%2.2x",
                     pSmart->OffLineCollectionStatus);
                break;

            case 0x05:
            case 0x85:
                xLog(DiskTestLogHandle, 
                     XLL_PASS, 
                     "OffLineCollectionStatus = aborted, interrupted by host : 0x%2.2x",
                     pSmart->OffLineCollectionStatus);
                break;

            case 0x06:
            case 0x86:
                xLog(DiskTestLogHandle, 
                     XLL_PASS, 
                     "OffLineCollectionStatus = aborted by device, fatal error : 0x%2.2x",
                     pSmart->OffLineCollectionStatus);
                break;
            
            default:
                xLog(DiskTestLogHandle, 
                     XLL_PASS, 
                     "OffLineCollectionStatus = vendor specific, reserved, or unknown, see IDE spec : 0x%2.2x",
                     pSmart->OffLineCollectionStatus);
                break;

        }
        
        xLog(DiskTestLogHandle,
             XLL_PASS, 
             "SecondsToComplete = : 0x%1.1x",
             pSmart->SecondsToComplete);
        
        xLog(DiskTestLogHandle, 
             XLL_PASS, 
             "OffLineCollectionCapability = 0x%1.1x",
             pSmart->OffLineCollectionCapability);
        
        if(pSmart->OffLineCollectionCapability && 0x01){
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "OffLineCollectionCapability : EXECUTE OFF-LINE IMMEDIATE implemented");
        } else {
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "OffLineCollectionCapability : EXECUTE OFF-LINE IMMEDIATE not implemented");
        }
        
        if (pSmart->OffLineCollectionCapability && 0x04) {
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "OffLineCollectionCapability : EXECUTE OFF-LINE IMMEDIATE will abort with new command");
        } else {
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "OffLineCollectionCapability : EXECUTE OFF-LINE IMMEDIATE will suspend then resume with new command");
        }

        xLog(DiskTestLogHandle, 
             XLL_PASS, 
             "SMARTCapability = : 0x%1.1x",
             pSmart->SMARTCapability);
        
        if(pSmart->SMARTCapability && 0x01){
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "SMARTCapability : saves SMART data prior to entering power-saving mode");
        } else {
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "SMARTCapability : does not save SMART data prior to entering power-saving mode");
        }
        
        if (pSmart->SMARTCapability && 0x02) {
            xLog(DiskTestLogHandle, 
                 XLL_PASS,
                 "SMARTCapability : device complies with data autosave after event");
        } else {
            xLog(DiskTestLogHandle, 
                 XLL_PASS, 
                 "SMARTCapability : device does not comply with data autosave after event");
        }

        checksum = 0;
        for (x = 0; x < 511; x++) {
            //
            // yes, this is supposed to overshoot
            //
            checksum += pSmartChar[x];
        }

        if (checksum != pSmart->Checksum){
            xLog(DiskTestLogHandle, 
             XLL_FAIL, 
            "Checksum : SMART data structure checksum does not match");
        } else {
            xLog(DiskTestLogHandle, 
             XLL_PASS, 
            "Checksum : SMART data structure checksum matches");
        }


    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:READ_ATTRIBUTES:FAILED");
    }

    // 
    // SMART ENABLE/DISABLE ATTRIBUTE AUTOSAVE
    // 
    
    //
    // disable
    //

    SMART_SetRegs (ENABLE_DISABLE_AUTOSAVE)
    atapt->IdeReg.bSectorCountReg = 0x00;   // disable

    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:ENABLE_DISABLE_AUTOSAVE (disable):SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:ENABLE_DISABLE_AUTOSAVE (disable):FAILED");
    }
    

    //
    // enable
    //

    SMART_SetRegs (ENABLE_DISABLE_AUTOSAVE)
    atapt->IdeReg.bSectorCountReg = 0xF1;   // enable
    
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:ENABLE_DISABLE_AUTOSAVE (enable):SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:ENABLE_DISABLE_AUTOSAVE (enable):FAILED");
    }

    // 
    // SMART SAVE ATTRIBUTE VALUES
    // 
    
    SMART_SetRegs (SAVE_ATTRIBUTE_VALUES)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:SAVE_ATTRIBUTE_VALUES:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:SAVE_ATTRIBUTE_VALUES:FAILED");
    }
    
    // 
    // SMART EXECUTE_OFFLINE_DIAGS
    // then go back on line...
    // 
    
    SMART_SetRegs (EXECUTE_OFFLINE_DIAGS)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:EXECUTE_OFFLINE_DIAGS:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:EXECUTE_OFFLINE_DIAGS:FAILED");
    }
    
    // 
    // SMART DISABLE OPERATIONS
    // then turn them back on... after makining sure they are actually disabled
    // 
    
    SMART_SetRegs (DISABLE_SMART)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:DISABLE_SMART:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:DISABLE_SMART:FAILED");
    }

    //
    // do something simple that should fail...
    //

    SMART_SetRegs (READ_ATTRIBUTES)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);

    if ( status != 0 ) {
        if (!(atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) ||
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF) ||
            !(atapt->IdeReg.bFeaturesReg & 0x04))    // ABRT in Error register
            {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:READ_ATTRIBUTES:FAILED CORRECTLY");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:READ_ATTRIBUTES:FAILED");
    }

    //
    // now turn it back on...
    //
    
    SMART_SetRegs (ENABLE_SMART)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);
    
    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:ENABLE_SMART:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:ENABLE_SMART:FAILED");
    }
    
    // 
    // SMART RETURN STATUS
    //
    
    SMART_SetRegs (RETURN_SMART_STATUS)
    status = DeviceIoControl(fileHandle,
                             IOCTL_IDE_PASS_THROUGH,
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             atapt,
                             sizeof(ATA_PASS_THROUGH),
                             &returned,
                             NULL);

    if ( status != 0 ) {
        if ((atapt->IdeReg.bCommandReg & IDE_Status_ERR) ||  
            (atapt->IdeReg.bCommandReg & IDE_Status_BSY) || 
            !(atapt->IdeReg.bCommandReg & IDE_Status_DRDY) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DRQ) ||
            (atapt->IdeReg.bCommandReg & IDE_Status_DF)) {
            SMART_DumpRegs()
        } else {                       
            xLog(DiskTestLogHandle, XLL_PASS, "SMART:RETURN_SMART_STATUS:SUCCEEDED");
        }
    } else {
        xLog(DiskTestLogHandle, XLL_FAIL, "SMART:RETURN_SMART_STATUS:FAILED");
    }
    
    HeapFree (DiskTestHeapHandle, HEAP_NO_SERIALIZE, atapt);
    xEndVariation( DiskTestLogHandle );

}

VOID
WINAPI
DiskTestEndTest(
       VOID
       )

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/ 
{
    OutputDebugString( TEXT("IDELOG: EndTest is called\n") );
}

BOOL
WINAPI
DiskTestDllMain(
       HINSTANCE   hInstance,
       DWORD       fdwReason,
       LPVOID      lpReserved
       )
/*++

Routine Description:

    This function gets called whenever a dll is loaded, unloaded, 
    a thread created or thread exited

Arguments:

    HINSTANCE   hInstance : instance handle (The value is the base address of the DLL)
    fwdReason : DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, DLL_THREAD_DETACH,DLL_PROCESS_DETACH
    LPVOID      lpReserved : who knows!

Return Value:

    None

--*/ 
{
    UNREFERENCED_PARAMETER( hInstance );
    UNREFERENCED_PARAMETER( lpReserved );

    if ( fdwReason == DLL_PROCESS_ATTACH ) {

        DiskTestHeapHandle = HeapCreate( 0, 0, 0 );

        if ( !DiskTestHeapHandle ) {
            OutputDebugString( TEXT("SAMPLEDLL: Unable to create heap\n") );
        }

    } else if ( fdwReason == DLL_PROCESS_DETACH ) {

        if ( DiskTestHeapHandle ) {
            HeapDestroy( DiskTestHeapHandle );
        }
    }

    return(TRUE);
}

DWORD
WINAPI
EndTimer(
        VOID
        )
/*++

Routine Description:

    Ends the test timer and returns the elapsed time in Milliseconds

Arguments:

    None

Return Value:

    elapsed time in Milliseconds

--*/ 
{
    LARGE_INTEGER PerformanceCountFinish;

    QueryPerformanceCounter(&PerformanceCountFinish);
    return(DWORD)((PerformanceCountFinish.QuadPart - PerformanceCount.QuadPart) / (Frequency.QuadPart / 1000));
}

VOID
WINAPI
StartTimer(
          VOID
          )
/*++

Routine Description:

    Start the test timer and returns 

Arguments:

    None

Return Value:

    None

Notes:

    this uses a global variable so the calling function does not have to 
    maintain state. this is to make this as convienient and easy as possible 
    to use and un-clutter the calling function

--*/ 
{
    QueryPerformanceCounter(&PerformanceCount);
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( disktest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( disktest )
    EXPORT_TABLE_ENTRY( "StartTest", DiskTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DiskTestEndTest )
END_EXPORT_TABLE( disktest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\Resource.h ===
// Automatically generated by the bundler tool from resource.rdf

#define resource_NUM_RESOURCES 34UL

#define resource_DolphinTexture_OFFSET 0UL
#define resource_SeaFloorTexture_OFFSET 20UL
#define resource_WaterCaustic00_OFFSET 40UL
#define resource_WaterCaustic01_OFFSET 60UL
#define resource_WaterCaustic02_OFFSET 80UL
#define resource_WaterCaustic03_OFFSET 100UL
#define resource_WaterCaustic04_OFFSET 120UL
#define resource_WaterCaustic05_OFFSET 140UL
#define resource_WaterCaustic06_OFFSET 160UL
#define resource_WaterCaustic07_OFFSET 180UL
#define resource_WaterCaustic08_OFFSET 200UL
#define resource_WaterCaustic09_OFFSET 220UL
#define resource_WaterCaustic10_OFFSET 240UL
#define resource_WaterCaustic11_OFFSET 260UL
#define resource_WaterCaustic12_OFFSET 280UL
#define resource_WaterCaustic13_OFFSET 300UL
#define resource_WaterCaustic14_OFFSET 320UL
#define resource_WaterCaustic15_OFFSET 340UL
#define resource_WaterCaustic16_OFFSET 360UL
#define resource_WaterCaustic17_OFFSET 380UL
#define resource_WaterCaustic18_OFFSET 400UL
#define resource_WaterCaustic19_OFFSET 420UL
#define resource_WaterCaustic20_OFFSET 440UL
#define resource_WaterCaustic21_OFFSET 460UL
#define resource_WaterCaustic22_OFFSET 480UL
#define resource_WaterCaustic23_OFFSET 500UL
#define resource_WaterCaustic24_OFFSET 520UL
#define resource_WaterCaustic25_OFFSET 540UL
#define resource_WaterCaustic26_OFFSET 560UL
#define resource_WaterCaustic27_OFFSET 580UL
#define resource_WaterCaustic28_OFFSET 600UL
#define resource_WaterCaustic29_OFFSET 620UL
#define resource_WaterCaustic30_OFFSET 640UL
#define resource_WaterCaustic31_OFFSET 660UL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\DolphinClassic.cpp ===
//-----------------------------------------------------------------------------
// File: DolphinClassic.cpp
//
// Desc: Xbox sample of a swimming dolphin using vertex shaders and animated
//       textures for some nice underwater effects.
//
// Hist: 11.01.00 - Port for XBox for November XDK release
//       12.15.00 - Now using shaders for December release
//       12.20.00 - Added pixel shader
//       12.20.00 - Added spline path and better models
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"
#include "XBFont.h"
#include "XBMesh.h"
#include "XBResource.h"
#include "XBUtil.h"
#include <xtestlib.h>

// The following header file is generated from "Resource.rdf" file using the
// Bundler tool. In addition to the header, the tool outputs a binary file
// (Resource.xpr) which contains compiled (i.e. bundled) resources and is
// loaded at runtime using the CXBPackedResource class.
#include "Resource.h"




//-----------------------------------------------------------------------------
// Globals variables and definitions
//-----------------------------------------------------------------------------
DWORD g_dwWaterColor = 0x00004080; // Color of the water
FLOAT g_fLightAngle  = 0.0f;       // Orientation of light from above




// Vertex for the 3D meshes
struct SEAFLOORVERTEX
{
    D3DXVECTOR3 p;           // Position
    D3DXVECTOR3 n;           // Normal
    FLOAT       tu, tv;      // Tex coords
};




//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication
{
    // Packed resources for the app
    CXBPackedResource       m_xprResource;

    // Font
    CXBFont                 m_Font;

    // Transform matrices
    D3DXMATRIX              m_matWorld;
    D3DXMATRIX              m_matView;
    D3DXMATRIX              m_matProj;

    // Dolphin object
    LPDIRECT3DTEXTURE8      m_pDolphinTexture;
    CXBMesh                 m_DolphinMesh1;
    CXBMesh                 m_DolphinMesh2;
    CXBMesh                 m_DolphinMesh3;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB2;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinVB3;
    LPDIRECT3DINDEXBUFFER8  m_pDolphinIB;
    DWORD                   m_dwNumDolphinVertices;
    DWORD                   m_dwNumDolphinIndices;
    DWORD                   m_dwDolphinVertexShader;
    DWORD                   m_dwDolphinVertexSize;

    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream1;
    LPDIRECT3DVERTEXBUFFER8 m_pDolphinStream2;

    // Seafloor object
    LPDIRECT3DTEXTURE8      m_pSeaFloorTexture;
    CXBMesh                 m_SeaFloorMesh;
    LPDIRECT3DVERTEXBUFFER8 m_pSeaFloorVB;
    LPDIRECT3DINDEXBUFFER8  m_pSeaFloorIB;
    DWORD                   m_dwNumSeaFloorVertices;
    DWORD                   m_dwNumSeaFloorIndices;
    DWORD                   m_dwSeaFloorVertexShader;
    DWORD                   m_dwSeaFloorVertexSize;

    // Water caustics
    LPDIRECT3DTEXTURE8      m_pCausticTextures[32];
    LPDIRECT3DTEXTURE8      m_pCurrentCausticTexture;
    DWORD                   m_dwUnderWaterPixelShader;

    HRESULT CreatePixelShader();

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};

VOID WINAPI
DolphinClassicStartTest(HANDLE LogHandle) {
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

VOID WINAPI
DolphinClassicEndTest() {
}



//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
#if !defined(HARNESSLIB)
VOID __cdecl main() {
	DolphinClassicStartTest(NULL);

	DolphinClassicEndTest();
}
#endif


//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample()
            :CXBApplication()
{
    // Allow unlimited frame rate
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    // Dolphin object
    m_pDolphinTexture        = NULL;
    m_pDolphinVB1            = NULL;
    m_pDolphinVB2            = NULL;
    m_pDolphinVB3            = NULL;
    m_pDolphinIB             = NULL;
    m_dwDolphinVertexShader  = 0L;

    // SeaFloor object
    m_pSeaFloorTexture       = NULL;
    m_pSeaFloorVB            = NULL;
    m_pSeaFloorIB            = NULL;
    m_dwSeaFloorVertexShader = 0L;

    // Water caustics
    for( DWORD t=0; t<32; t++ )
        m_pCausticTextures[t] = NULL;
    m_dwUnderWaterPixelShader = 0L;
}




//-----------------------------------------------------------------------------
// Name: CreatePixelShader()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::CreatePixelShader()
{
    //
    // Setup the pixel shader. To blend in water caustics, we want the
    // following effect:
    //    result = t0 * ( t1 * v0 + c0 )
    // where:
    //    t0 = Base texture
    //    t1 = Water caustics texture
    //    c0 = Ambient light contribution
    //    v0 = Directional light contribution
    //
    // This can be encoded into a pixel shader with:
    //    1st stage: r0 = (t1*v0 + c0*1)
    //    Final:     A*B + (1-A)*C + D
    //               E*F = r0 * t0
    // where:
    //    A = Fog factor
    //    B = EF
    //    C = Fog color
    //    D = 0
    //    E = r0
    //    F = t0
    //
    D3DPIXELSHADERDEF psd;
    ZeroMemory( &psd, sizeof(psd) );
    psd.PSCombinerCount = PS_COMBINERCOUNT( 1,
                                            PS_COMBINERCOUNT_MUX_MSB | PS_COMBINERCOUNT_UNIQUE_C0 | PS_COMBINERCOUNT_UNIQUE_C1);
    psd.PSTextureModes  = PS_TEXTUREMODES( PS_TEXTUREMODES_PROJECT2D, PS_TEXTUREMODES_PROJECT2D,
                                           PS_TEXTUREMODES_NONE, PS_TEXTUREMODES_NONE );
    psd.PSInputTexture  = PS_INPUTTEXTURE( 0, 0, 0, 0 );
    psd.PSDotMapping    = PS_DOTMAPPING( 0, PS_DOTMAPPING_ZERO_TO_ONE,
                                         PS_DOTMAPPING_ZERO_TO_ONE, PS_DOTMAPPING_ZERO_TO_ONE );
    psd.PSCompareMode   = PS_COMPAREMODE( PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT,
                                          PS_COMPAREMODE_S_LT | PS_COMPAREMODE_T_LT | PS_COMPAREMODE_R_LT | PS_COMPAREMODE_Q_LT );

    //------------- Stage 0 -------------
    // Build factor from caustics and lighting (R0 = T1*V0 + C0)
    psd.PSRGBInputs[0]    = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_RGB,
                                               PS_REGISTER_V0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_C0  | PS_CHANNEL_RGB,
                                               PS_REGISTER_ONE | PS_CHANNEL_RGB );
    psd.PSAlphaInputs[0]  = PS_COMBINERINPUTS( PS_REGISTER_T1  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_V0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_C0  | PS_CHANNEL_ALPHA,
                                               PS_REGISTER_ONE | PS_CHANNEL_ALPHA );
    psd.PSRGBOutputs[0]   = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );
    psd.PSAlphaOutputs[0] = PS_COMBINEROUTPUTS( PS_REGISTER_DISCARD,
                                                PS_REGISTER_DISCARD,
                                                PS_REGISTER_R0,
                                                PS_COMBINEROUTPUT_AB_MULTIPLY | PS_COMBINEROUTPUT_CD_MULTIPLY | PS_COMBINEROUTPUT_AB_CD_SUM );

    psd.PSC0Mapping = 0xfffffff0;
    psd.PSC1Mapping = 0xffffffff;

    //------------- Final combiner -------------
    
    // EF is R0*T0. G is alpha and is set to 1.
    psd.PSFinalCombinerInputsEFG = PS_COMBINERINPUTS( PS_REGISTER_R0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_T0  | PS_CHANNEL_RGB,
                                                      PS_REGISTER_ONE | PS_CHANNEL_RGB,
                                                      0 | 0 | 0 );

    // Just factor the fog in with the results from the last stage:
    //    Result = Fog.a * R0 + (1-Fog.a)*Fog.rgb + 0
    psd.PSFinalCombinerInputsABCD = PS_COMBINERINPUTS( PS_REGISTER_FOG     | PS_CHANNEL_ALPHA,
                                                       PS_REGISTER_EF_PROD | PS_CHANNEL_RGB,
                                                       PS_REGISTER_FOG     | PS_CHANNEL_RGB,
                                                       PS_REGISTER_ZERO    | PS_CHANNEL_RGB );

    // Create the pixel shader, as defined above.
    if( FAILED( m_pd3dDevice->CreatePixelShader( &psd, &m_dwUnderWaterPixelShader ) ) )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
    HRESULT    hr;

    // Create the resources
    if( FAILED( m_xprResource.Create( m_pd3dDevice, "Resource.xpr", 
                                      resource_NUM_RESOURCES ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create a font
    if( FAILED( m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    // Create texture for the dolphin
    m_pDolphinTexture = m_xprResource.GetTexture( resource_DolphinTexture_OFFSET );

    // Load the file-based mesh objects for the dolphin
    if( FAILED( m_DolphinMesh1.Create( m_pd3dDevice, "Models\\Dolphin1.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh2.Create( m_pd3dDevice, "Models\\Dolphin2.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    if( FAILED( m_DolphinMesh3.Create( m_pd3dDevice, "Models\\Dolphin3.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pDolphinVB1 = &m_DolphinMesh1.GetMesh(0)->m_VB;
    m_pDolphinVB2 = &m_DolphinMesh2.GetMesh(0)->m_VB;
    m_pDolphinVB3 = &m_DolphinMesh3.GetMesh(0)->m_VB;
    m_pDolphinIB  = &m_DolphinMesh1.GetMesh(0)->m_IB;
    m_dwNumDolphinVertices = m_DolphinMesh1.GetMesh(0)->m_dwNumVertices;
    m_dwNumDolphinIndices  = m_DolphinMesh1.GetMesh(0)->m_dwNumIndices;
    m_dwDolphinVertexSize  = m_DolphinMesh1.GetMesh(0)->m_dwVertexSize;

    // Create vertex shader for the dolphin
    DWORD dwDolphinVertexDecl[] =
    {
        // m_pDolphinVB1
        D3DVSD_STREAM( 0 ),              // This data comes from stream 0
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // v0 = Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // v3 = Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // v6 = Tex coords

        // m_pDolphinVB2
        D3DVSD_STREAM( 1 ),              // This data comes from stream 1
        D3DVSD_REG( 1, D3DVSDT_FLOAT3 ), // v1 = Position of second mesh
        D3DVSD_REG( 4, D3DVSDT_FLOAT3 ), // v4 = Normal
        D3DVSD_REG( 7, D3DVSDT_FLOAT2 ), // v7 = Tex coords

        // m_pDolphinVB3
        D3DVSD_STREAM( 2 ),              // This data comes from stream 2
        D3DVSD_REG( 2, D3DVSDT_FLOAT3 ), // v2 = Position of second mesh
        D3DVSD_REG( 5, D3DVSDT_FLOAT3 ), // v5 = Normal
        D3DVSD_REG( 8, D3DVSDT_FLOAT2 ), // v8 = Tex coords
        D3DVSD_END()
    };

    hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\Dolphin.xvu",
                                    dwDolphinVertexDecl, &m_dwDolphinVertexShader );
    if( FAILED(hr) )
        return hr;

    // Create textures for the seafloor
    m_pSeaFloorTexture = m_xprResource.GetTexture( resource_SeaFloorTexture_OFFSET );
    
    // Load the file-based mesh object for the seafloor
    if( FAILED( m_SeaFloorMesh.Create( m_pd3dDevice, "Models\\SeaFloor.xbg" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_pSeaFloorVB = &m_SeaFloorMesh.GetMesh(0)->m_VB;
    m_pSeaFloorIB = &m_SeaFloorMesh.GetMesh(0)->m_IB;
    m_dwNumSeaFloorVertices = m_SeaFloorMesh.GetMesh(0)->m_dwNumVertices;
    m_dwNumSeaFloorIndices  = m_SeaFloorMesh.GetMesh(0)->m_dwNumIndices;
    m_dwSeaFloorVertexSize  = m_SeaFloorMesh.GetMesh(0)->m_dwVertexSize;

    // Add some bumpiness to the seafloor mesh
    SEAFLOORVERTEX* pDst;
    m_pSeaFloorVB->Lock( 0, 0, (BYTE**)&pDst, 0 );
    srand(5);
    for( DWORD i=0; i<m_dwNumSeaFloorVertices; i++ )
    {
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].p.y += (rand()/(FLOAT)RAND_MAX);
        pDst[i].tu  *= 10;
        pDst[i].tv  *= 10;
    }
    m_pSeaFloorVB->Unlock();

    // Create vertex shader for the seafloor
    DWORD dwSeaFloorVertexDecl[] =
    {
        D3DVSD_STREAM( 0 ),
        D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
        D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
        D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
        D3DVSD_END()
    };

    if( FAILED( hr = XBUtil_CreateVertexShader( m_pd3dDevice, "Shaders\\SeaFloor.xvu",
                                                dwSeaFloorVertexDecl,
                                                &m_dwSeaFloorVertexShader ) ) )
        return hr;

    // Create a pixel shader for the underwater effect
    hr = CreatePixelShader();
    if( FAILED(hr) )
        return hr;

    // Create textures for the water caustics
    m_pCausticTextures[ 0] = m_xprResource.GetTexture( resource_WaterCaustic00_OFFSET );
    m_pCausticTextures[ 1] = m_xprResource.GetTexture( resource_WaterCaustic01_OFFSET );
    m_pCausticTextures[ 2] = m_xprResource.GetTexture( resource_WaterCaustic02_OFFSET );
    m_pCausticTextures[ 3] = m_xprResource.GetTexture( resource_WaterCaustic03_OFFSET );
    m_pCausticTextures[ 4] = m_xprResource.GetTexture( resource_WaterCaustic04_OFFSET );
    m_pCausticTextures[ 5] = m_xprResource.GetTexture( resource_WaterCaustic05_OFFSET );
    m_pCausticTextures[ 6] = m_xprResource.GetTexture( resource_WaterCaustic06_OFFSET );
    m_pCausticTextures[ 7] = m_xprResource.GetTexture( resource_WaterCaustic07_OFFSET );
    m_pCausticTextures[ 8] = m_xprResource.GetTexture( resource_WaterCaustic08_OFFSET );
    m_pCausticTextures[ 9] = m_xprResource.GetTexture( resource_WaterCaustic09_OFFSET );
    m_pCausticTextures[10] = m_xprResource.GetTexture( resource_WaterCaustic10_OFFSET );
    m_pCausticTextures[11] = m_xprResource.GetTexture( resource_WaterCaustic11_OFFSET );
    m_pCausticTextures[12] = m_xprResource.GetTexture( resource_WaterCaustic12_OFFSET );
    m_pCausticTextures[13] = m_xprResource.GetTexture( resource_WaterCaustic13_OFFSET );
    m_pCausticTextures[14] = m_xprResource.GetTexture( resource_WaterCaustic14_OFFSET );
    m_pCausticTextures[15] = m_xprResource.GetTexture( resource_WaterCaustic15_OFFSET );
    m_pCausticTextures[16] = m_xprResource.GetTexture( resource_WaterCaustic16_OFFSET );
    m_pCausticTextures[17] = m_xprResource.GetTexture( resource_WaterCaustic17_OFFSET );
    m_pCausticTextures[18] = m_xprResource.GetTexture( resource_WaterCaustic18_OFFSET );
    m_pCausticTextures[19] = m_xprResource.GetTexture( resource_WaterCaustic19_OFFSET );
    m_pCausticTextures[20] = m_xprResource.GetTexture( resource_WaterCaustic20_OFFSET );
    m_pCausticTextures[21] = m_xprResource.GetTexture( resource_WaterCaustic21_OFFSET );
    m_pCausticTextures[22] = m_xprResource.GetTexture( resource_WaterCaustic22_OFFSET );
    m_pCausticTextures[23] = m_xprResource.GetTexture( resource_WaterCaustic23_OFFSET );
    m_pCausticTextures[24] = m_xprResource.GetTexture( resource_WaterCaustic24_OFFSET );
    m_pCausticTextures[25] = m_xprResource.GetTexture( resource_WaterCaustic25_OFFSET );
    m_pCausticTextures[26] = m_xprResource.GetTexture( resource_WaterCaustic26_OFFSET );
    m_pCausticTextures[27] = m_xprResource.GetTexture( resource_WaterCaustic27_OFFSET );
    m_pCausticTextures[28] = m_xprResource.GetTexture( resource_WaterCaustic28_OFFSET );
    m_pCausticTextures[29] = m_xprResource.GetTexture( resource_WaterCaustic29_OFFSET );
    m_pCausticTextures[30] = m_xprResource.GetTexture( resource_WaterCaustic30_OFFSET );
    m_pCausticTextures[31] = m_xprResource.GetTexture( resource_WaterCaustic31_OFFSET );

    // Set the transform matrices
    D3DXVECTOR3 vEyePt      = D3DXVECTOR3( 0.0f, 0.0f,-5.0f );
    D3DXVECTOR3 vLookatPt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpVec      = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
    D3DXMatrixIdentity( &m_matWorld );
    D3DXMatrixLookAtLH( &m_matView, &vEyePt, &vLookatPt, &vUpVec );
    D3DXMatrixPerspectiveFovLH( &m_matProj, D3DX_PI/3, 4.0f/3.0f, 1.0f, 10000.0f );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{
    // Animation attributes for the dolphin
    FLOAT fKickFreq    = 2*m_fAppTime;
    FLOAT fPhase       = m_fAppTime/3;
    FLOAT fBlendWeight = sinf( fKickFreq );

    // Move the dolphin in a circle
    D3DXMATRIX matDolphin, matTrans, matRotate1, matRotate2;
    D3DXMatrixScaling( &matDolphin, 0.01f, 0.01f, 0.01f );
    D3DXMatrixRotationZ( &matRotate1, -cosf(fKickFreq)/6 );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate1 );
    D3DXMatrixRotationY( &matRotate2, fPhase );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matRotate2 );
    D3DXMatrixTranslation( &matTrans, -5*sinf(fPhase), sinf(fKickFreq)/2, 10-10*cosf(fPhase) );
    D3DXMatrixMultiply( &matDolphin, &matDolphin, &matTrans );

    // Blend weight and vertex buffer selection for vertex tweening
    FLOAT fWeight1, fWeight2;
    if ( fBlendWeight > 0.0f )
    {
        // Use vertex sets one the two.
        fWeight1 = fBlendWeight;
        fWeight2 = 1.0f - fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB1;
        m_pDolphinStream2 = m_pDolphinVB2;
    }
    else
    {
        // Use vertex sets two and three.
        fWeight1 = 1.0f + fBlendWeight;
        fWeight2 = -fBlendWeight;

        m_pDolphinStream1 = m_pDolphinVB2;
        m_pDolphinStream2 = m_pDolphinVB3;
    }

    // Values passed into the vertex shader for lighting, etc.
    FLOAT fConstants0[4] = { 0.0f, 0.0f, 0.0f, 0.00f };
    FLOAT fConstants1[4] = { 1.0f, 0.5f, 0.2f, 0.05f };
    FLOAT fLight[4]      = { sinf(g_fLightAngle), cosf(g_fLightAngle), 0.0f, 0.0f };
    FLOAT fDiffuse[4]    = { 1.00f, 1.00f, 1.00f, 1.00f };
    FLOAT fAmbient[4]    = { 0.25f, 0.25f, 0.25f, 0.25f };
    FLOAT fFog[4]        = { 0.5f, 50.0f, 1.0f/(50.0f-1.0f), 0.0f };
    FLOAT fCaustics[4]   = { 0.05f, 0.05f, sinf(m_fAppTime)/8, cosf(m_fAppTime)/10 - m_fAppTime/10 };
    FLOAT fWeight[4]     = { fWeight1, fWeight2, 0.0f, 0.0f };

    // Calculate and set composite matrix for dolphin.
    D3DXMATRIX matComposite;
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    D3DXMatrixMultiply( &matComposite, &matComposite, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 4, &matComposite, 4 );

    // Scale and offset fog start and end by values from projection matrix.
    float fFogStart = 1.0f;
    float fFogEnd = 50.0f;

    fFogStart = fFogStart * m_matProj._33 + m_matProj._43;
    fFogEnd = fFogEnd * m_matProj._33 + m_matProj._43;

    fFog[2] = 1.0f / (fFogEnd - fFogStart);
    fFog[1] = fFogEnd * fFog[2];

    // Calculate and set composite matrix for seafloor.
    D3DXMatrixMultiply( &matComposite, &m_matView, &m_matProj );
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 8, &matComposite, 4 );

    // Calculate and set texgen matrix for dolphin.
    D3DXMatrixMultiply( &matComposite, &matDolphin, &m_matView );
    matComposite *= 0.5f;
    D3DXMatrixTranspose( &matComposite, &matComposite );
    m_pd3dDevice->SetVertexShaderConstant( 12, &matComposite, 4 );

    // Set the vertex shader constants
    m_pd3dDevice->SetVertexShaderConstant(  0, &fConstants0, 1 ); // Some constants
    m_pd3dDevice->SetVertexShaderConstant(  1, &fConstants1, 1 ); // More constants
    m_pd3dDevice->SetVertexShaderConstant(  2, &fWeight,     1 );

    m_pd3dDevice->SetVertexShaderConstant( 20, &fLight,      1 ); // Light direction
    m_pd3dDevice->SetVertexShaderConstant( 21, &fDiffuse,    1 ); // Diffuse color
    m_pd3dDevice->SetVertexShaderConstant( 23, &fFog,        1 ); // Fog factors
    m_pd3dDevice->SetVertexShaderConstant( 24, &fCaustics,   1 ); // Misc constants
    
    // Animate the caustic textures
    DWORD tex = ((DWORD)(m_fAppTime*32))%32;
    m_pCurrentCausticTexture = m_pCausticTextures[tex];

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------

HRESULT CXBoxSample::Render()
{
    // Clear the viewport
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         g_dwWaterColor, 1.0f, 0L );

    // Begin the scene
    m_pd3dDevice->BeginScene();

    // Set default render states
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGCOLOR,         g_dwWaterColor );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MINFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MAGFILTER, D3DTEXF_LINEAR );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_MIPFILTER, D3DTEXF_POINT );

    // Turn on the pixel shader for the underwater effect, which blends in the
    // current caustic texture.
    m_pd3dDevice->SetPixelShader( m_dwUnderWaterPixelShader );
    m_pd3dDevice->SetTexture( 1, m_pCurrentCausticTexture );

    // Set the ambient color input to the pixel shader.
    // Note: This must be done after the pixel shader is set.
    FLOAT fAmbient[4] = { 0.25f, 0.25f, 0.25f, 0.25f };
    m_pd3dDevice->SetPixelShaderConstant( 0, &fAmbient, 1 );

    // Render the seafloor. The vertex shader does the transformation, texture
    // projection (for the water caustics) and fog calculations.
    m_pd3dDevice->SetTexture( 0, m_pSeaFloorTexture );
    m_pd3dDevice->SetVertexShader( m_dwSeaFloorVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pSeaFloorVB, m_dwSeaFloorVertexSize );
    m_pd3dDevice->SetIndices( m_pSeaFloorIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumSeaFloorIndices, 
                                       D3D__IndexData );

    // Render the dolphin. The vertex shader does the vertex tweening, 
    // transformation, texture projection (for the water caustics) and fog
    // calculations.
    m_pd3dDevice->SetTexture( 0, m_pDolphinTexture );
    m_pd3dDevice->SetVertexShader( m_dwDolphinVertexShader );
    m_pd3dDevice->SetStreamSource( 0, m_pDolphinStream1, m_dwDolphinVertexSize );
    m_pd3dDevice->SetStreamSource( 1, m_pDolphinStream2, m_dwDolphinVertexSize );
    m_pd3dDevice->SetIndices( m_pDolphinIB, 0 );
    m_pd3dDevice->DrawIndexedVertices( D3DPT_TRIANGLESTRIP, m_dwNumDolphinIndices, 
                                       D3D__IndexData );

    // Show frame rate
    m_Font.Begin();
    m_Font.DrawText(  64, 50, 0xffffffff, L"DolphinClassic" );
    m_Font.DrawText( 450, 50, 0xffffff00, m_strFrameRate );
    m_Font.End();

    // End the scene.
    m_pd3dDevice->EndScene();

    return S_OK;
}


//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( DolphinClassic )
#pragma data_seg()

BEGIN_EXPORT_TABLE( DolphinClassic )
    EXPORT_TABLE_ENTRY( "StartTest", DolphinClassicStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DolphinClassicEndTest )
END_EXPORT_TABLE( DolphinClassic )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbmesh.h ===
//-----------------------------------------------------------------------------
// File: XBMesh.h
//
// Desc: Support code for loading geometry stored in .xbg files. These files
//       typically converted from .x geometry files using the MakeXBG tool. See
//       that tool for more information.
//
//       XBG files were designed to minimalize overhead in the loading and
//       rendering process on the Xbox. The data in a .xbg file is basically
//       stored in one system memory chunk, and one video memory chunk.
//       Therefore, loading a .xbg file is simply two fread() calls followed
//       by some patchup (which turns file offsets into real pointers).
//
//       Geometry files are loaded into arrays of the following structures.
//       XBMESH_FRAME structures contain data to make a frame hierarchy (such
//       as "next" and "child" pointers, plus a transformation matrix). The
//       XMMESH_DATA structure contains data for rendering a mesh (such as
//       the vertex buffer, num of indices, etc.). Finally, the XBMESH_SUBSET
//       structure contains subset properties (materials and textures) and
//       primitive ranges (start index, index count, etc.) for each subset of
//       the data in the XBMESH_DATA structure.
//
//       To use this class, simply instantiate the class, and call Create().
//       Thereafter, the mesh can be rendered with the Render() call. Some
//       render flags are available (see below) to limit what gets rendered.
//       For instance, an app might want to render opaque subsets only, or
//       use a custom vertex shader. For truely custom control, override the
//       CXBMesh class with a new RenderCallback() function, and put any
//       custom pre-rendering code in the callback. The typical use for this
//       is to pass data to a custom vertex shader.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//       04.17.01 - 16-byte aligning matrices in the file format
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBMESH_H
#define XBMESH_H
#include "XBResource.h"
#include "XBUtil.h"




// Rendering flags. Default is no flags (0x00000000)
#define XBMESH_OPAQUEONLY      0x00000001 // Only render opaque subsets
#define XBMESH_ALPHAONLY       0x00000002 // Only render alpha subsets

#define XBMESH_NOMATERIALS     0x00000010 // Do not use mesh materials
#define XBMESH_NOTEXTURES      0x00000020 // Do not use mesh textures
#define XBMESH_NOFVF           0x00000040 // Do not use mesh FVF code


// The magic number to identify .xbg files
#define XBG_FILE_ID (((DWORD)'X'<<0)|(((DWORD)'B'<<8))|(((DWORD)'G'<<16))|(2<<24))




//-----------------------------------------------------------------------------
// Name: struct XBMESH_SUBSET
// Desc: Struct to hold data for rendering a mesh
//-----------------------------------------------------------------------------
struct XBMESH_SUBSET
{
    D3DMATERIAL8       mtrl;            // Material for this subset
    LPDIRECT3DTEXTURE8 pTexture;        // Texture
    CHAR               strTexture[64];
    DWORD              dwVertexStart;   // Range of vertices to render
    DWORD              dwVertexCount;
    DWORD              dwIndexStart;    // Range of vertex indices to render
    DWORD              dwIndexCount;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESH_DATA
// Desc: Struct for mesh data
//-----------------------------------------------------------------------------
struct XBMESH_DATA
{
    D3DVertexBuffer   m_VB;            // Mesh geometry
    DWORD             m_dwNumVertices;
    D3DIndexBuffer    m_IB;
    DWORD             m_dwNumIndices;
    
    DWORD             m_dwFVF;         // Mesh vertex info
    DWORD             m_dwVertexSize;
    D3DPRIMITIVETYPE  m_dwPrimType;

    DWORD             m_dwNumSubsets;  // Subset info for rendering calls
    XBMESH_SUBSET*    m_pSubsets;
};




//-----------------------------------------------------------------------------
// Name: struct XBMESHFRAME
// Desc: Struct for building a hierarchy of meshes.
//-----------------------------------------------------------------------------
__declspec(align(16)) struct XBMESH_FRAME
{
    D3DXMATRIX        m_matTransform; // The transformation matrix for this frame
    
    XBMESH_DATA       m_MeshData;     // The mesh data belonging to this frame

    CHAR              m_strName[64];
    
    XBMESH_FRAME*     m_pChild;       // Child and sibling ptrs for the hierarchy
    XBMESH_FRAME*     m_pNext;
};




//-----------------------------------------------------------------------------
// Name: class CXBMesh
// Desc: Wrapper class for loading geoemtry files, and rendering the resulting
//       hierachy of meshes and frames.
//-----------------------------------------------------------------------------
class CXBMesh
{
    // Memory allocated during file loading. Ptrs are retained for cleanup.
    VOID* m_pAllocatedSysMem;
    VOID* m_pAllocatedVidMem;

public:
    // Hierarchy (frames and meshes) of loaded geometry
    XBMESH_FRAME* m_pMeshFrames;
    DWORD         m_dwNumFrames;

    // Internal rendering functions
    virtual HRESULT RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pMesh, 
                                 DWORD dwFlags );
    virtual HRESULT RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                                DWORD dwFlags );

    // Internal functions to find the radius of sphere centered at zero enclosing mesh.
    float ComputeFrameRadius(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat);
    float ComputeMeshRadius(XBMESH_DATA* pMesh, D3DXMATRIX* pMat);
	
    // Internal functions to find the bounding box of the mesh.
    HRESULT ComputeFrameBoundingBox(XBMESH_FRAME* pFrame, D3DXMATRIX* pParentMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
	HRESULT ComputeMeshBoundingBox(XBMESH_DATA* pMesh, D3DXMATRIX* pMat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);

public:
    // Reference counting
    DWORD   m_dwRefCount;
    DWORD   AddRef()  { return ++m_dwRefCount; }
    DWORD   Release() { if( --m_dwRefCount ) return m_dwRefCount;
                        delete this; return 0L; }

public:
    // Constructor/destructor
    CXBMesh();
    virtual ~CXBMesh();

    // Creation function. Call this function to create the hierarchy of frames
    // and meshes from a geometry file.
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                    CXBPackedResource* pResource = NULL );

    // Access functions
    XBMESH_FRAME* GetFrame( DWORD i ) { return &m_pMeshFrames[i]; }
    XBMESH_DATA*  GetMesh( DWORD i )  { return &m_pMeshFrames[i].m_MeshData; }

    // Overridable callback function (called before anything is rendered). 
    // This is useful for setting vertex shader constants, etc., before
    // rendering.
    virtual BOOL RenderCallback( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwSubset,
                                 XBMESH_SUBSET* pSubset, DWORD dwFlags ) { return TRUE; }
    
    // Render function. Call this function to render the hierarchy of frames
    // and meshes.
    HRESULT Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags = 0x00000000 );

    // Function to find the radius of sphere centered at zero enclosing mesh.
    float ComputeRadius();
    // find the bounding box of all the subsets
	HRESULT ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax);
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    // m_dwNumInputDeviceTypes = 0;
    // m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Clear the backbuffer
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,
                         0x00000000, 1.0f, 0L );
    m_pd3dDevice->Present( NULL, NULL, NULL, NULL );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    // XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
	/*
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }
	*/

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        // XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
		/*
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input functions:
        // -  Both triggers and white button triggers a screen dump
        // -  Both triggers and black button triggers a reboot
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                // With white button, dump the backbuffer contents
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_WHITE] )
                    XGWriteSurfaceToFile( m_pBackBuffer, "D:\\BackBuffer.bmp" );

                // With black button, reboot to the Xbox Dashboard
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }
		*/

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        // if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
        //     m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        // if( m_bPaused )
        //     qwElapsedAppTime.QuadPart = 0;
        // else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;

        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbmesh.cpp ===
//-----------------------------------------------------------------------------
// File: XBMesh.cpp
//
// Desc: Support code for loading geometry stored in .xbg files. See the
//       <XBMesh.h> header file for information on using this class.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       03.15.01 - Mass changes (removed D3DX and .x support) for April XDK
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgmath.h>
#include <stdio.h>
#include "XBMesh.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Name: CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::CXBMesh()
{
    m_pAllocatedSysMem = NULL;
    m_pAllocatedVidMem = NULL;
    m_pMeshFrames      = NULL;
    m_dwNumFrames      = 0;
    m_dwRefCount       = 1L;
}




//-----------------------------------------------------------------------------
// Name: ~CXBMesh()
// Desc: 
//-----------------------------------------------------------------------------
CXBMesh::~CXBMesh()
{
    // Free textures
    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        for( DWORD j = 0; j < m_pMeshFrames[i].m_MeshData.m_dwNumSubsets; j++ )
        {
            SAFE_RELEASE( m_pMeshFrames[i].m_MeshData.m_pSubsets[j].pTexture );
        }
    }

    // Free alloacted memory
    if( m_pAllocatedSysMem )
        delete[] m_pAllocatedSysMem;

    if( m_pAllocatedVidMem )
        D3D_FreeContiguousMemory( m_pAllocatedVidMem );
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: 
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Create( LPDIRECT3DDEVICE8 pd3dDevice, CHAR* strFilename,
                         CXBPackedResource* pResource )
{
    // Find the media file
    CHAR strMeshPath[512];
    if( FAILED( XBUtil_FindMediaFile( strMeshPath, strFilename ) ) )
        return E_FAIL;

    // Open the file
    FILE* file = fopen( strMeshPath, "rb" );
    if( file == NULL )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: File not found!\n") );
        return E_FAIL;
    }

    // Read the magic number
    DWORD dwFileID;
    fread( &dwFileID, 1, sizeof(DWORD), file ); 

    if( dwFileID != XBG_FILE_ID )
    {
        OutputDebugString( _T("CXBFile::Create(): ERROR: Invalid XBG file type!\n") );
        fclose( file );
        return E_FAIL;
    }

    // Read in header
    DWORD dwNumFrames;  // Number of mesh frames in the file
    DWORD dwSysMemSize; // Num bytes needed for system memory objects
    DWORD dwVidMemSize; // Num bytes needed for video memory objects

    fread( &dwNumFrames,  1, sizeof(DWORD), file );
    fread( &dwSysMemSize, 1, sizeof(DWORD), file );
    fread( &dwVidMemSize, 1, sizeof(DWORD), file );

    // Read in system memory objects
    m_pAllocatedSysMem = (VOID*)new BYTE[dwSysMemSize];
    fread( m_pAllocatedSysMem, dwSysMemSize, 1, file );

    // Read in video memory objects
    m_pAllocatedVidMem = D3D_AllocContiguousMemory( dwVidMemSize, D3DVERTEXBUFFER_ALIGNMENT );
    fread( m_pAllocatedVidMem, dwVidMemSize, 1, file ); 
    
    // Done with the file
    fclose( file );

    // Now we need to patch the mesh data. Any pointers read from the file were
    // stored as file offsets. So, we simply need to add a base address to patch
    // things up.
    m_pMeshFrames = (XBMESH_FRAME*)m_pAllocatedSysMem;
    m_dwNumFrames = dwNumFrames;

    for( DWORD i=0; i<m_dwNumFrames; i++ )
    {
        XBMESH_FRAME* pFrame = &m_pMeshFrames[i];
        XBMESH_DATA*  pMesh  = &m_pMeshFrames[i].m_MeshData;

        if( pFrame->m_pChild )
            pFrame->m_pChild  = (XBMESH_FRAME*)( (DWORD)pFrame->m_pChild - 16 + (DWORD)m_pMeshFrames );
        if( pFrame->m_pNext )
            pFrame->m_pNext   = (XBMESH_FRAME*)( (DWORD)pFrame->m_pNext  - 16 + (DWORD)m_pMeshFrames );
        if( pMesh->m_pSubsets )
            pMesh->m_pSubsets = (XBMESH_SUBSET*)( (DWORD)pMesh->m_pSubsets - 16 + (DWORD)m_pMeshFrames);
        
        if( pMesh->m_dwNumIndices )
            pMesh->m_IB.Data  = pMesh->m_IB.Data - 16 + (DWORD)m_pMeshFrames;
        if( pMesh->m_dwNumVertices )
            pMesh->m_VB.Register( m_pAllocatedVidMem );
    }

    // Finally, create any textures used by the meshes' subsets. In this 
    // implementation, we are pulling textures out of the passed in resource.
    if( pResource )
    {
        for( DWORD i=0; i<m_dwNumFrames; i++ )
        {
            XBMESH_DATA* pMesh = &m_pMeshFrames[i].m_MeshData;

            for( DWORD j = 0; j < pMesh->m_dwNumSubsets; j++ )
            {
                XBMESH_SUBSET* pSubset = &pMesh->m_pSubsets[j];

                pSubset->pTexture = pResource->GetTexture( pSubset->strTexture );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Renders the hierarchy of frames and meshes.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::Render( LPDIRECT3DDEVICE8 pd3dDevice, DWORD dwFlags )
{
    if( m_pMeshFrames )
        RenderFrame( pd3dDevice, m_pMeshFrames, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderFrame()
// Desc: Renders a frame (save state, apply matrix, render children, restore).
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderFrame( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_FRAME* pFrame, 
                              DWORD dwFlags )
{
    // Apply the frame's local transform
    D3DXMATRIX matSavedWorld, matWorld;
    pd3dDevice->GetTransform( D3DTS_WORLD, &matSavedWorld );
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, &matSavedWorld );
    pd3dDevice->SetTransform( D3DTS_WORLD, &matWorld );

    // Render the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        RenderMesh( pd3dDevice, &pFrame->m_MeshData, dwFlags );

    // Render any child frames
    if( pFrame->m_pChild ) 
        RenderFrame( pd3dDevice, pFrame->m_pChild, dwFlags );

    // Restore the transformation matrix
    pd3dDevice->SetTransform( D3DTS_WORLD, &matSavedWorld );
    
    // Render any sibling frames
    if( pFrame->m_pNext )  
        RenderFrame( pd3dDevice, pFrame->m_pNext, dwFlags );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderMesh()
// Desc: Renders the mesh geometry.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::RenderMesh( LPDIRECT3DDEVICE8 pd3dDevice, XBMESH_DATA* pMesh, 
                             DWORD dwFlags )
{
    D3DVertexBuffer* pVB           = &pMesh->m_VB;
    DWORD            dwNumVertices =  pMesh->m_dwNumVertices;
    D3DIndexBuffer*  pIB           = &pMesh->m_IB;
    DWORD            dwNumIndices  =  pMesh->m_dwNumIndices;
    DWORD            dwFVF         =  pMesh->m_dwFVF;
    DWORD            dwVertexSize  =  pMesh->m_dwVertexSize;
    D3DPRIMITIVETYPE dwPrimType    =  pMesh->m_dwPrimType;
    DWORD            dwNumSubsets  =  pMesh->m_dwNumSubsets;
    XBMESH_SUBSET*   pSubsets      = &pMesh->m_pSubsets[0];

    if( dwNumVertices == 0 )
        return S_OK;

    // Set the vertex stream
    pd3dDevice->SetStreamSource( 0, pVB, dwVertexSize );
    pd3dDevice->SetIndices( pIB, 0 );

    // Set the FVF code, unless the user asked us not to
    if( 0 == ( dwFlags & XBMESH_NOFVF ) )
        pd3dDevice->SetVertexShader( dwFVF );

    // Render the subsets
    for( DWORD i = 0; i < dwNumSubsets; i++ )
    {
        BOOL bRender = FALSE;

        // Render the opaque subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_ALPHAONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a >= 1.0f )
                    bRender = TRUE;
            }
            else
                bRender = TRUE;
        }

        // Render the transparent subsets, unless the user asked us not to
        if( 0 == ( dwFlags & XBMESH_OPAQUEONLY ) )
        {
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
            {
                if( pSubsets[i].mtrl.Diffuse.a < 1.0f )
                    bRender = TRUE;
            }
        }

        if( bRender )
        {
            // Set the material, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOMATERIALS ) )
                pd3dDevice->SetMaterial( &pSubsets[i].mtrl );

            // Set the texture, unless the user asked us not to
            if( 0 == ( dwFlags & XBMESH_NOTEXTURES ) )
                pd3dDevice->SetTexture( 0, pSubsets[i].pTexture );

            // Call the callback, so the app can tweak state before rendering
            // each subset
            BOOL bRenderSubset = RenderCallback( pd3dDevice, i, &pSubsets[i], dwFlags );

            // Draw the mesh subset
            if( bRenderSubset )
            {
                DWORD dwNumPrimitives = ( D3DPT_TRIANGLESTRIP == dwPrimType ) ? pSubsets[i].dwIndexCount-2 : pSubsets[i].dwIndexCount/3;
                pd3dDevice->DrawIndexedPrimitive( dwPrimType, 0, pSubsets[i].dwIndexCount,
                                                  pSubsets[i].dwIndexStart, dwNumPrimitives );
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeRadius()
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );

    return ComputeFrameRadius( m_pMeshFrames, &matIdentity );
}




//-----------------------------------------------------------------------------
// Name: ComputeFrameRadius()
// Desc: Calls ComputeMeshRadius for each frame with the correct transform.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeFrameRadius( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent )
{
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    FLOAT fRadius = 0.0f;

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets ) 
        fRadius = ComputeMeshRadius( &pFrame->m_MeshData, &matWorld );

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
        FLOAT fChildRadius = ComputeFrameRadius( pFrame->m_pChild, &matWorld  );

        if( fChildRadius > fRadius )
            fRadius = fChildRadius;
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
        FLOAT fSiblingRadius = ComputeFrameRadius( pFrame->m_pNext, pmatParent );

        if( fSiblingRadius > fRadius )
            fRadius = fSiblingRadius;
    }

    return fRadius;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshRadius()
// Desc: Finds the farthest point from zero on the mesh.
//-----------------------------------------------------------------------------
FLOAT CXBMesh::ComputeMeshRadius( XBMESH_DATA* pMesh, D3DXMATRIX* pmat )
{
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    FLOAT       fMaxDist2 = 0.0f;

    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );

    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );

        FLOAT fDist2 = vPos.x*vPos.x + vPos.y*vPos.y + vPos.z*vPos.z;

        if( fDist2 > fMaxDist2 )
            fMaxDist2 = fDist2;

        pVertices += dwVertexSize;
    }

    pMesh->m_VB.Unlock();

    return sqrtf( fMaxDist2 );
}

//-----------------------------------------------------------------------------
//  Take the union of two boxes
//-----------------------------------------------------------------------------
inline float MAX(float a, float b) { return a > b ? a : b; }
inline float MIN(float a, float b) { return a < b ? a : b; }
static void UnionBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax, const D3DXVECTOR3 &vMin, const D3DXVECTOR3 &vMax)
{
	pvMin->x = MIN(pvMin->x, vMin.x);
	pvMin->y = MIN(pvMin->y, vMin.y);
	pvMin->z = MIN(pvMin->z, vMin.z);
	pvMax->x = MAX(pvMax->x, vMax.x);
	pvMax->y = MAX(pvMax->y, vMax.y);
	pvMax->z = MAX(pvMax->z, vMax.z);
}

//-----------------------------------------------------------------------------
// Name: ComputeBoundingBox()
// Desc: Calculates the bounding box of the entire hierarchy.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeBoundingBox(D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
    D3DXMATRIX matIdentity;
    D3DXMatrixIdentity( &matIdentity );
    return ComputeFrameBoundingBox( m_pMeshFrames, &matIdentity, pvMin, pvMax );
}

//-----------------------------------------------------------------------------
// Name: ComputeFrameBoundingBox()
// Desc: Calls ComputeMeshBoundingBox for each frame with the correct transform.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeFrameBoundingBox( XBMESH_FRAME* pFrame, D3DXMATRIX* pmatParent, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	HRESULT hr;
	
	// initialize bounds to be reset on the first UnionBox
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
	
    // Apply the frame's local transform
    D3DXMATRIX matWorld;
    D3DXMatrixMultiply( &matWorld, &pFrame->m_matTransform, pmatParent );

    // Compute bounds for the mesh data
    if( pFrame->m_MeshData.m_dwNumSubsets )
	{
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeMeshBoundingBox( &pFrame->m_MeshData, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
	}

    // Compute bounds for any child frames
    if( pFrame->m_pChild ) 
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pChild, &matWorld, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }

    // Compute bounds for any sibling frames
    if( pFrame->m_pNext )  
    {
		D3DXVECTOR3 vMin, vMax;
        hr = ComputeFrameBoundingBox( pFrame->m_pNext, pmatParent, &vMin, &vMax );
		if (FAILED(hr))
			return hr;
		UnionBox(pvMin, pvMax, vMin, vMax);
    }
    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ComputeMeshBoundingBox()
// Desc: Calculate the bounding box of the transformed mesh.
//-----------------------------------------------------------------------------
HRESULT CXBMesh::ComputeMeshBoundingBox( XBMESH_DATA* pMesh, D3DXMATRIX* pmat, D3DXVECTOR3 *pvMin, D3DXVECTOR3 *pvMax)
{
	// initialize bounds to be reset on the first point
	pvMin->x = pvMin->y = pvMin->z = FLT_MAX;
	pvMax->x = pvMax->y = pvMax->z = -FLT_MAX;
    DWORD       dwNumVertices = pMesh->m_dwNumVertices;
    DWORD       dwVertexSize  = pMesh->m_dwVertexSize;
    BYTE*       pVertices;
    D3DXVECTOR3 vPos;
    pMesh->m_VB.Lock( 0, 0, &pVertices, 0 );
    while( dwNumVertices-- )
    {
        D3DXVec3TransformCoord( &vPos, (D3DXVECTOR3*)pVertices, pmat );
		UnionBox(pvMin, pvMax, vPos, vPos);	// expand the bounding box to include the point
        pVertices += dwVertexSize;
    }
    pMesh->m_VB.Unlock();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
// #include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    // XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    // DWORD                  m_dwNumInputDeviceTypes;
    // XBGAMEPAD*             m_Gamepad;
    // XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdauth\dvdauth.cpp ===
/*
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddcdvd.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <dvdx2.h>
#include <idex.h>
#include <align.h>
#include <stdio.h>
*/

#include <idex.h>
#include <rsa_sys.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

// structs
typedef struct _SelectFlags {
	UCHAR CDFValidFlag;
	UCHAR AuthenticationFlag;
	UCHAR PartitionFlag;
} SelectFlags;


VOID
IdexCdRomDecryptHostChallengeResponseTable(
    IN PDVDX2_CONTROL_DATA ControlData
    )
/*++

Routine Description:

    This routine decrypts the host challenge response table of the supplied
    DVD-X2 control data structure.

Arguments:

    ControlData - Specifies the control data structure that contains the host
        challenge response table to be decrypted.

Return Value:

    None.

--*/
{
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    struct RC4_KEYSTRUCT RC4KeyStruct;

    //
    // Compute the SHA-1 hash of the data between bytes 1183 to 1226 of the
    // control data structure.
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)&ControlData->AuthoringTimeStamp,
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringHash) -
        FIELD_OFFSET(DVDX2_CONTROL_DATA, AuthoringTimeStamp));
    A_SHAFinal(&SHAHash, SHADigest);

    //
    // Compute a 56-bit RC4 session key from the SHA-1 hash.
    //

    rc4_key(&RC4KeyStruct, 56 / 8, SHADigest);

    //
    // Decrypt the host challenge response table in place using the RC4 session
    // key.
    //

    rc4(&RC4KeyStruct, sizeof(ControlData->HostChallengeResponseTable.Entries),
        (PUCHAR)&ControlData->HostChallengeResponseTable.Entries);
}


VOID
DVDAuthLogSenseData(HANDLE LogHandle, SENSE_DATA SenseData) {
	// Log SenseData
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData ErrorCode:  0x%.2x", SenseData.ErrorCode);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Valid:  0x%.2x", SenseData.Valid);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SegmentNumber:  0x%.2x", SenseData.SegmentNumber);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKey:  0x%.2x", SenseData.SenseKey);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Reserved:  0x%.2x", SenseData.Reserved);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData IncorrectLength:  0x%.2x", SenseData.IncorrectLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData EndOfMedia:  0x%.2x", SenseData.EndOfMedia);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FileMark:  0x%.2x", SenseData.FileMark);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[0]:  0x%.2x", SenseData.Information[0]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[1]:  0x%.2x", SenseData.Information[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[2]:  0x%.2x", SenseData.Information[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[3]:  0x%.2x", SenseData.Information[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseLength:  0x%.2x", SenseData.AdditionalSenseLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[0]:  0x%.2x", SenseData.CommandSpecificInformation[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[1]:  0x%.2x", SenseData.CommandSpecificInformation[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[2]:  0x%.2x", SenseData.CommandSpecificInformation[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[3]:  0x%.2x", SenseData.CommandSpecificInformation[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCode:  0x%.2x", SenseData.AdditionalSenseCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCodeQualifier:  0x%.2x", SenseData.AdditionalSenseCodeQualifier);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FieldReplaceableUnitCode:  0x%.2x", SenseData.FieldReplaceableUnitCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[0]:  0x%.2x", SenseData.SenseKeySpecific[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[1]:  0x%.2x", SenseData.SenseKeySpecific[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[2]:  0x%.2x", SenseData.SenseKeySpecific[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[3]:  0x%.2x", SenseData.SenseKeySpecific[3]);	
}


VOID
LogAuthentication(HANDLE LogHandle, DVDX2_AUTHENTICATION Authentication) {
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication ModeDataLength[0]: %#x", Authentication.Header.ModeDataLength[0]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication ModeDataLength[1]: %#x", Authentication.Header.ModeDataLength[1]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication Page Code: %#x", Authentication.AuthenticationPage.PageCode);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication Page Length: %#x", Authentication.AuthenticationPage.PageLength);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication PartitionArea: %#x", Authentication.AuthenticationPage.PartitionArea);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication CDFValid: %#x", Authentication.AuthenticationPage.CDFValid);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication Authentication: %#x", Authentication.AuthenticationPage.Authentication);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication DiscCategoryAndVersion: %#x", Authentication.AuthenticationPage.DiscCategoryAndVersion);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication DrivePhaseLevel: %#x", Authentication.AuthenticationPage.DrivePhaseLevel);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication ChallengeID: %#x", Authentication.AuthenticationPage.ChallengeID);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication ChallengeValue: %#x", Authentication.AuthenticationPage.ChallengeValue);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Authentication ResponseValue: %#x", Authentication.AuthenticationPage.ResponseValue);
}

VOID
LogLayerDescriptor(HANDLE LogHandle, DVD_LAYER_DESCRIPTOR LayerDescriptor) {
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor BookVersion: %#x", LayerDescriptor.BookVersion);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor BookType: %#x", LayerDescriptor.BookType);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor MinimumRate: %#x", LayerDescriptor.MinimumRate);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor DiskSize: %#x", LayerDescriptor.DiskSize);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor LayerType: %#x", LayerDescriptor.LayerType);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor TrackPath: %#x", LayerDescriptor.TrackPath);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor NumberOfLayers: %#x", LayerDescriptor.NumberOfLayers);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor LinearDensity: %#x", LayerDescriptor.LinearDensity);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor TrackDensity: %#x", LayerDescriptor.TrackDensity);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor StartingDataSector: %#x", LayerDescriptor.StartingDataSector);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor EndDataSector: %#x", LayerDescriptor.EndDataSector);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor EndLayerZeroSector: %#x", LayerDescriptor.EndLayerZeroSector);
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "LayerDescriptor BCAFlag: %#x", LayerDescriptor.BCAFlag);
}

VOID
LogResponseTable(HANDLE LogHandle, DVDX2_HOST_CHALLENGE_RESPONSE_TABLE ResponseTable) {
	UCHAR i;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Version: %#x", ResponseTable.Version);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable NumberOfEntries: %#u", ResponseTable.NumberOfEntries);
	
	for(i = 0; i < ResponseTable.NumberOfEntries; i++) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Entry[%u] ChallengeLevel: %#x", i, ResponseTable.Entries[i].ChallengeLevel);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Entry[%u] ChallengeID: %#x", i, ResponseTable.Entries[i].ChallengeID);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Entry[%u] ChallengeValue: %#x", i, ResponseTable.Entries[i].ChallengeValue);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Entry[%u] ResponseModifier: %#x", i, ResponseTable.Entries[i].ResponseModifier);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "ResponseTable Entry[%u] ResponseValue: %#x", i, ResponseTable.Entries[i].ResponseValue);
	}
}

VOID
LogCDB(HANDLE LogHandle, PCDB Cdb) {
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cdb OperationCode: %#x", Cdb->MODE_SENSE10.OperationCode);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cdb PageCode: %#x", Cdb->MODE_SENSE10.PageCode);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cdb AllocationLength[0]: %#x", Cdb->MODE_SENSE10.AllocationLength[0]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cdb AllocationLength[1]: %#x", Cdb->MODE_SENSE10.AllocationLength[1]);
}
	

VOID
WINAPI
DVDAuthStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	BOOL bReturn, bPass;
    DWORD cbBytesReturned;
	UCHAR DrivePhaseLevel, ChallengeAttempt, ChallengePass, LastTableEntry, i;
	SelectFlags FirstChallenge, OtherChallenge, LastChallenge;
	SENSE_DATA SenseData;
	DISK_GEOMETRY DiskGeometryBefore, DiskGeometryAfter;

    SCSI_PASS_THROUGH_DIRECT PassThrough;
    PCDB Cdb = (PCDB)&PassThrough.Cdb;
    DVDX2_AUTHENTICATION AuthChallenge, AuthResponse;
    DVDX2_CONTROL_DATA ControlData;

	// Set global log handle
	LogHandle = LogHandle;

    xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "DVDAuth");
    
	// Get config from testini.ini
	xSetFunctionName(LogHandle, "Configuration");

	// Flags for First MODE_SELECT
	FirstChallenge.CDFValidFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("FirstCDFValidFlag"), 1);
	FirstChallenge.AuthenticationFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("FirstAuthenticationFlag"), 0);
	FirstChallenge.PartitionFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("FirstPartitionFlag"), 0);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "First MODE_SELECT: CDFValid = %#x Authentication = %#x Partition = %#x", 
		FirstChallenge.CDFValidFlag, FirstChallenge.AuthenticationFlag, FirstChallenge.PartitionFlag);

	// Flags for Other MODE_SELECT
	OtherChallenge.CDFValidFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("OtherCDFValidFlag"), 1);
	OtherChallenge.AuthenticationFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("OtherAuthenticationFlag"), 1);
	OtherChallenge.PartitionFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("OtherPartitionFlag"), 0);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Other MODE_SELECT: CDFValid = %#x Authentication = %#x Partition = %#x", 
		OtherChallenge.CDFValidFlag, OtherChallenge.AuthenticationFlag, OtherChallenge.PartitionFlag);

	// Flags for Last MODE_SELECT
	LastChallenge.CDFValidFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("LastCDFValidFlag"), 1);
	LastChallenge.AuthenticationFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("LastAuthenticationFlag"), 1);
	LastChallenge.PartitionFlag = (UCHAR)GetProfileInt(TEXT("dvdauth"), TEXT("LastPartitionFlag"), 1);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Last MODE_SELECT: CDFValid = %#x Authentication = %#x Partition = %#x", 
		LastChallenge.CDFValidFlag, LastChallenge.AuthenticationFlag, LastChallenge.PartitionFlag);


	// open device
	xSetFunctionName(LogHandle, "Open Device");
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,NULL);

	if(hDevice == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile FAILED LastError = %d", GetLastError());
		return;
	}

	// Get Before Authentication Geometry
	xSetFunctionName(LogHandle, "Disk Geometry Before Auth");
	RtlZeroMemory(&DiskGeometryBefore, sizeof(DiskGeometryBefore));
	bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_GET_DRIVE_GEOMETRY, 
								NULL, 0, 
								&DiskGeometryBefore, sizeof(DiskGeometryBefore), 
								&cbBytesReturned, 
								NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "IOCTL_CDROM_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cylinders = %u", DiskGeometryBefore.Cylinders.QuadPart);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "TracksPerCylinder = %u", DiskGeometryBefore.TracksPerCylinder);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "SectorsPerTrack = %u", DiskGeometryBefore.SectorsPerTrack);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "BytesPerSector = %u", DiskGeometryBefore.BytesPerSector);
	}

    //
    // Request the authentication page from the DVD-X2 drive.
    //
	xSetFunctionName(LogHandle, "Initial CDFValid Check");
	RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
	RtlZeroMemory(&AuthChallenge, sizeof(DVDX2_AUTHENTICATION));
    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
 
	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &AuthChallenge;
    PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
    Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
    *((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

   bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED cbBytesReturned > 0");
			DVDAuthLogSenseData(LogHandle, SenseData);
		}
		return;
	}

	LogAuthentication(LogHandle, AuthChallenge);
	DrivePhaseLevel = AuthChallenge.AuthenticationPage.DrivePhaseLevel;

	// Check for valid CDF header
	if(AuthChallenge.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CDF Valid FAILED (Unrecognized Media)");
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_PASS, "CDF Valid PASSED (Media Recognized)");
	}


    //
    // Request the control data structure from the DVD-X2 drive.
    //
	xSetFunctionName(LogHandle, "Read DVD Structure");		
	RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
	RtlZeroMemory(&ControlData, sizeof(DVDX2_CONTROL_DATA));

    RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = &ControlData;
    PassThrough.DataTransferLength = sizeof(DVDX2_CONTROL_DATA);
    Cdb->READ_DVD_STRUCTURE.OperationCode = SCSIOP_READ_DVD_STRUCTURE;
    *((PUSHORT)&Cdb->READ_DVD_STRUCTURE.AllocationLength) =
        (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_CONTROL_DATA));
    *((PULONG)Cdb->READ_DVD_STRUCTURE.RMDBlockNumber) =
        IdexConstantUlongByteSwap((ULONG)(~DVDX2_CONTROL_DATA_BLOCK_NUMBER));
    Cdb->READ_DVD_STRUCTURE.LayerNumber = (UCHAR)(~DVDX2_CONTROL_DATA_LAYER);
    Cdb->READ_DVD_STRUCTURE.Format = DvdPhysicalDescriptor;
    Cdb->READ_DVD_STRUCTURE.Control = 0xC0;

	bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ_DVD_STRUCTURE FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ_DVD_STRUCTURE FAILED cbBytesReturned > 0");
			DVDAuthLogSenseData(LogHandle, SenseData);
		}
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_PASS, "SCSIOP_READ_DVD_STRUCTURE PASSED");
	}

	LogLayerDescriptor(LogHandle, ControlData.LayerDescriptor);
	
	// xLog(gbConsoleOut, LogHandle, XLL_INFO, "Before Decryption");
	// LogResponseTable(LogHandle, ControlData.HostChallengeResponseTable);
	
	IdexCdRomDecryptHostChallengeResponseTable(&ControlData);

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "After Decryption");
	LogResponseTable(LogHandle, ControlData.HostChallengeResponseTable);
	
	//
	// Do all challenge response pairs
	//
	ChallengeAttempt = 0;
	ChallengePass = 0;
	LastTableEntry = 0;
	xSetFunctionName(LogHandle, "Challenge/Response");
	for(i = 0; i < ControlData.HostChallengeResponseTable.NumberOfEntries; i++) {
		// Only do Challenge/Response if ChallengeLevel == DrivePhaseLeve
		if(ControlData.HostChallengeResponseTable.Entries[i].ChallengeLevel == DrivePhaseLevel) {
			// Count number of challenges
			ChallengeAttempt++;
			LastTableEntry = i;
			bPass = TRUE;

			// Challenge to drive
			RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
			RtlZeroMemory(&AuthChallenge, sizeof(DVDX2_AUTHENTICATION));
			*((PUSHORT)&AuthChallenge.Header.ModeDataLength) = 
				IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION) - FIELD_OFFSET(DVDX2_AUTHENTICATION, Header.MediumType));
			AuthChallenge.AuthenticationPage.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
			AuthChallenge.AuthenticationPage.PageLength = sizeof(DVDX2_AUTHENTICATION_PAGE) -
				FIELD_OFFSET(DVDX2_AUTHENTICATION_PAGE, PartitionArea);

			if(ChallengeAttempt == 1) {
				// First Challenge
				AuthChallenge.AuthenticationPage.PartitionArea = FirstChallenge.PartitionFlag;
				AuthChallenge.AuthenticationPage.CDFValid = FirstChallenge.CDFValidFlag;
				AuthChallenge.AuthenticationPage.Authentication = FirstChallenge.AuthenticationFlag;
			} else {
				// Other Challenges
				AuthChallenge.AuthenticationPage.PartitionArea = OtherChallenge.PartitionFlag;
				AuthChallenge.AuthenticationPage.CDFValid = OtherChallenge.CDFValidFlag;
				AuthChallenge.AuthenticationPage.Authentication = OtherChallenge.AuthenticationFlag;
			}
			
			AuthChallenge.AuthenticationPage.DiscCategoryAndVersion =
				(ControlData.LayerDescriptor.BookType << 4) + ControlData.LayerDescriptor.BookVersion;
			AuthChallenge.AuthenticationPage.DrivePhaseLevel = DrivePhaseLevel;
			AuthChallenge.AuthenticationPage.ChallengeID = ControlData.HostChallengeResponseTable.Entries[i].ChallengeID;
			AuthChallenge.AuthenticationPage.ChallengeValue = ControlData.HostChallengeResponseTable.Entries[i].ChallengeValue;
			
			RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
			PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
			PassThrough.DataBuffer = &AuthChallenge;
			PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
			PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
			Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
			// Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
			*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
				(USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));
  
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Challenge[%u] Before (MODE_SELECT)", i);
			LogCDB(LogHandle, Cdb);
			LogAuthentication(LogHandle, AuthChallenge);
			
			bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
										&PassThrough, sizeof(PassThrough), 
										&SenseData, sizeof(SenseData),
										&cbBytesReturned, NULL);

			if((!bReturn) || (cbBytesReturned > 0)) {
				bPass = FALSE;
				if(!bReturn) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Challenge[%u] FAILED LastError = %d", i, GetLastError());
				}

				if(cbBytesReturned > 0) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Challenge[%u] FAILED cbBytesReturned > 0", i);
					DVDAuthLogSenseData(LogHandle, SenseData);
				}
			}

			// xLog(gbConsoleOut, LogHandle, XLL_INFO, "Challenge[%u] After (MODE_SELECT)", i);
			// LogAuthentication(LogHandle, AuthChallenge);

			// Recieve response from drive
			RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
			RtlZeroMemory(&AuthResponse, sizeof(DVDX2_AUTHENTICATION));
			RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
			PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
			PassThrough.DataBuffer = &AuthResponse;
			PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
			PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
			Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
			Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
			*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) = (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

			// xLog(gbConsoleOut, LogHandle, XLL_INFO, "Response[%u] Before (MODE_SENSE)", i);
			// LogCDB(LogHandle, Cdb);
			// LogAuthentication(LogHandle, AuthResponse);

			bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
										&PassThrough, sizeof(PassThrough), 
										&SenseData, sizeof(SenseData),
										&cbBytesReturned, NULL);

			if((!bReturn) || (cbBytesReturned > 0)) {
				bPass = FALSE;
				if(!bReturn) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED LastError = %d", i, GetLastError());
				}

				if(cbBytesReturned > 0) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED cbBytesReturned > 0", i);
					DVDAuthLogSenseData(LogHandle, SenseData);
				}
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_INFO, "Response[%u] (After MODE_SENSE)", i);
				LogAuthentication(LogHandle, AuthResponse);

				if(AuthResponse.AuthenticationPage.ResponseValue != ControlData.HostChallengeResponseTable.Entries[i].ResponseValue) {
					bPass = FALSE;
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED ResponseValue", i);
				} else {
					xLog(gbConsoleOut, LogHandle, XLL_PASS, "Response[%u] PASSED ResponseValue", i);
				}

				if(AuthResponse.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
					bPass = FALSE;
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED CDFValid not 1", i);
				} else {
					xLog(gbConsoleOut, LogHandle, XLL_PASS, "Response[%u] PASSED CDFValid", i);
				}

				if(AuthResponse.AuthenticationPage.Authentication != 1) {
					bPass = FALSE;
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED Authentication not 1", i);
				} else {
					xLog(gbConsoleOut, LogHandle, XLL_PASS, "Response[%u] PASSED Authentication", i);
				}

				if(AuthResponse.AuthenticationPage.PartitionArea != 0) {
					bPass = FALSE;
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Response[%u] FAILED PartitionArea not 0", i);
				} else {
					xLog(gbConsoleOut, LogHandle, XLL_PASS, "Response[%u] PASSED PartitionArea", i);
				}
			}

			// Count successful challenges
			if(bPass) {
				ChallengePass++;
			}
		}
	}

	if((ChallengeAttempt > 0) && (ChallengeAttempt == ChallengePass)) {
		xLog(gbConsoleOut, LogHandle, XLL_PASS, "Challenge/Response PASSED TableEntries=%u Challenges Issued=%u Challenges Passed=%u", 
			ControlData.HostChallengeResponseTable.NumberOfEntries, ChallengeAttempt, ChallengePass);
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Challenge/Response FAILED TableEntries=%u Challenges Issued=%u Challenges Passed=%u", 
			ControlData.HostChallengeResponseTable.NumberOfEntries, ChallengeAttempt, ChallengePass);
	}

	// Switch to XBox Partition
	xSetFunctionName(LogHandle, "Switch to XBox Partition");
	RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
	RtlZeroMemory(&AuthChallenge, sizeof(DVDX2_AUTHENTICATION));
	*((PUSHORT)&AuthChallenge.Header.ModeDataLength) = 
		IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION) - FIELD_OFFSET(DVDX2_AUTHENTICATION, Header.MediumType));
	AuthChallenge.AuthenticationPage.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
	AuthChallenge.AuthenticationPage.PageLength = sizeof(DVDX2_AUTHENTICATION_PAGE) -
		FIELD_OFFSET(DVDX2_AUTHENTICATION_PAGE, PartitionArea);
	AuthChallenge.AuthenticationPage.PartitionArea = LastChallenge.PartitionFlag;
	AuthChallenge.AuthenticationPage.CDFValid = LastChallenge.CDFValidFlag;
	AuthChallenge.AuthenticationPage.Authentication = LastChallenge.AuthenticationFlag;
	AuthChallenge.AuthenticationPage.DiscCategoryAndVersion =
		(ControlData.LayerDescriptor.BookType << 4) + ControlData.LayerDescriptor.BookVersion;
	AuthChallenge.AuthenticationPage.DrivePhaseLevel = DrivePhaseLevel;
	AuthChallenge.AuthenticationPage.ChallengeID = ControlData.HostChallengeResponseTable.Entries[LastTableEntry].ChallengeID;
	AuthChallenge.AuthenticationPage.ChallengeValue = ControlData.HostChallengeResponseTable.Entries[LastTableEntry].ChallengeValue;
    			
	RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
	PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
	PassThrough.DataBuffer = &AuthChallenge;
	PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
	Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SELECT10;
	Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
	*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
		(USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));
    
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Last Challenge (Before MODE_SELECT)");
	LogCDB(LogHandle, Cdb);
	LogAuthentication(LogHandle, AuthChallenge);
		
	bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) {
		bPass = FALSE;
		if(!bReturn) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Challenge FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Challenge FAILED cbBytesReturned > 0");
			DVDAuthLogSenseData(LogHandle, SenseData);
		}
	}

	// Recieve response from drive
	RtlZeroMemory(&SenseData, sizeof(SENSE_DATA));
	RtlZeroMemory(&AuthResponse, sizeof(DVDX2_AUTHENTICATION));
	RtlZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));
	PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
	PassThrough.DataBuffer = &AuthResponse;
	PassThrough.DataTransferLength = sizeof(DVDX2_AUTHENTICATION);
	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
	Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
	Cdb->MODE_SENSE10.PageCode = DVDX2_MODE_PAGE_AUTHENTICATION;
	*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) = (USHORT)IdexConstantUshortByteSwap(sizeof(DVDX2_AUTHENTICATION));

	bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED cbBytesReturned > 0");
			DVDAuthLogSenseData(LogHandle, SenseData);
		}
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Last Response (MODE_SENSE)");
		LogAuthentication(LogHandle, AuthResponse);

		if(AuthResponse.AuthenticationPage.ResponseValue != ControlData.HostChallengeResponseTable.Entries[LastTableEntry].ResponseValue) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED ResponseValue");
		} else {
			xLog(gbConsoleOut, LogHandle, XLL_PASS, "Last Response PASSED ResponseValue");
		}

		if(AuthResponse.AuthenticationPage.CDFValid != DVDX2_CDF_VALID) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED CDFValid not 1");
		} else {
			xLog(gbConsoleOut, LogHandle, XLL_PASS, "Last Response PASSED CDFValid");
		}

		if(AuthResponse.AuthenticationPage.Authentication != 1) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED Authentication not 1");
		} else {
			xLog(gbConsoleOut, LogHandle, XLL_PASS, "Last Response PASSED Authentication");
		}

		if(AuthResponse.AuthenticationPage.PartitionArea != 1) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Last Response FAILED PartitionArea not 1");
		} else {
			xLog(gbConsoleOut, LogHandle, XLL_PASS, "Last Response PASSED PartitionArea");
		}
	}

	// Get Disk Geometry After Authentication
	xSetFunctionName(LogHandle, "Disk Geometry After Auth");
	RtlZeroMemory(&DiskGeometryAfter, sizeof(DiskGeometryAfter));
	bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_GET_DRIVE_GEOMETRY, 
								NULL, 0, 
								&DiskGeometryAfter, sizeof(DiskGeometryAfter), 
								&cbBytesReturned, 
								NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "IOCTL_CDROM_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Cylinders = %u", DiskGeometryAfter.Cylinders.QuadPart);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "TracksPerCylinder = %u", DiskGeometryAfter.TracksPerCylinder);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "SectorsPerTrack = %u", DiskGeometryAfter.SectorsPerTrack);
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "BytesPerSector = %u", DiskGeometryAfter.BytesPerSector);
	}

	// Check for increased size in partition 1
	if(DiskGeometryAfter.Cylinders.QuadPart <= DiskGeometryBefore.Cylinders.QuadPart) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "Partion after authentication is NOT larger than before");
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_PASS, "Partion after authentication is larger than before");
	}

	// close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CloseHandle FAILED LastError = %d", GetLastError());
	}
}


VOID WINAPI
DVDAuthEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\dvdauth.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("DVDAuth: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("DVDAuth: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }
	
	gbConsoleOut = TRUE;

	// Copy ini to t:\\ if not already there

	// Start Test
	DVDAuthStartTest(LogHandle);

	// End Test
	DVDAuthEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("DVDAuth: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dvdauth )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dvdauth )
    EXPORT_TABLE_ENTRY( "StartTest", DVDAuthStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DVDAuthEndTest )
END_EXPORT_TABLE( dvdauth )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\DolphinClassic\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbfont.h ===
//-----------------------------------------------------------------------------
// File: XBFont.h
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBFONT_H
#define XBFONT_H
#include "XBResource.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Number of vertex buffers for rendering text. Having this number be greater
// than 1 can reduce potential stalling of the GPU.
//-----------------------------------------------------------------------------
#define NUM_FONT_BUFFERS 2



//-----------------------------------------------------------------------------
// Flags for the CXBFont::DrawText() function
//-----------------------------------------------------------------------------
#define XBFONT_LEFT     0x00000000
#define XBFONT_RIGHT    0x00000001
#define XBFONT_CENTER_X 0x00000002
#define XBFONT_CENTER_Y 0x00000004




//-----------------------------------------------------------------------------
// Custom vertex type for rendering text
//-----------------------------------------------------------------------------
struct XBFONTVERTEX 
{ 
    D3DXVECTOR4 p;
    DWORD       color;
    FLOAT       tu, tv; 
};

#define D3DFVF_XBFONTVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)




//-----------------------------------------------------------------------------
// Name: struct GLYPH_ATTR
// Desc: Structure to hold information about one glyph (font character image)
//-----------------------------------------------------------------------------
struct GLYPH_ATTR
{
    FLOAT left, top, right, bottom; // Texture coordinates for the image
    SHORT wOffset;                  // Pixel offset for glyph start
    SHORT wWidth;                   // Pixel width of the glyph
    SHORT wAdvance;                 // Pixels to advance after the glyph
};




//-----------------------------------------------------------------------------
// Name: class CXBFont
// Desc: Class to implement texture-based font rendering. A .tga image file of 
//       the pre-rendered font is used to create the texture. A .abc file
//       contains information for spacing the font characters (aka glyphs).
//-----------------------------------------------------------------------------
class CXBFont
{
public:
    // Font and texture dimensions
    DWORD         m_dwFontHeight;
    DWORD         m_dwTexWidth;
    DWORD         m_dwTexHeight;

    // Unicode ranges
    WCHAR         m_cLowChar;
    WCHAR         m_cHighChar;

    // Glyph data for the font
    DWORD         m_dwNumGlyphs;
    GLYPH_ATTR*   m_Glyphs;

    // D3D rendering objects
    CXBPackedResource       m_xprResource;
    LPDIRECT3DDEVICE8       m_pd3dDevice;
    LPDIRECT3DTEXTURE8      m_pTexture;
    LPDIRECT3DVERTEXBUFFER8 m_pVBs[NUM_FONT_BUFFERS];
    LPDIRECT3DVERTEXBUFFER8 m_pVB;
    DWORD                   m_dwCurrentBuffer;
    XBFONTVERTEX*           m_pVertices;
    DWORD                   m_dwNumQuads;
    DWORD                   m_dwNestedBeginCount;
    BOOL                    m_bTextureFromFile;

    // Internal call to trigger rendering of the vertex buffer
    HRESULT Render();

    // Access functions for debugging purposes
    LPDIRECT3DTEXTURE8 GetTexture() const    { return m_pTexture; }
    DWORD              GetFontHeight() const { return m_dwFontHeight; }

public:
    // Constructor/destructor
    CXBFont();
    ~CXBFont();

    // Functions to create and destroy the internal objects
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                    const CHAR* strFontResourceFileName );
    HRESULT Destroy();

    // Replaces invalid (outside the valid glyph range) characters in a string
    VOID    ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const;

    // Returns the dimensions of a text string
    HRESULT GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                           FLOAT* pHeight, BOOL bFirstLineOnly=FALSE ) const;

    // Function to create a texture containing rendered text
    LPDIRECT3DTEXTURE8 CreateTexture( const WCHAR* strText, 
                                      D3DCOLOR dwBackgroundColor = 0x00000000,
                                      D3DCOLOR dwTextColor = 0xffffffff,
                                      D3DFORMAT d3dFormat = D3DFMT_LIN_A8R8G8B8 );

    // Public calls to render text. Callers can simply call DrawText(), but for
    // performance, they should batch multople calls together, bracketed by 
    // calls to Begin() and End().
    HRESULT Begin();
    HRESULT DrawText( FLOAT sx, FLOAT sy, DWORD dwColor, 
                      const WCHAR* strText, DWORD dwFlags=0L );
    HRESULT End();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbapp.h ===
//-----------------------------------------------------------------------------
// File: XBApp.h
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBAPP_H
#define XBAPP_H

#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBInput.h"
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
extern LPDIRECT3DDEVICE8 g_pd3dDevice;




//-----------------------------------------------------------------------------
// Error codes
//-----------------------------------------------------------------------------
#define XBAPPERR_MEDIANOTFOUND       0x82000003




//-----------------------------------------------------------------------------
// Name: class CXBApplication
// Desc: A base class for creating sample Xbox applications. To create a simple
//       Xbox application, simply derive this class and override the following
//       functions:
//          Initialize()          - To initialize the device-dependant objects
//          FrameMove()           - To animate the scene
//          Render()              - To render the scene
//-----------------------------------------------------------------------------
class CXBApplication
{
protected:
    // Main objects used for creating and rendering the 3D scene
    D3DPRESENT_PARAMETERS m_d3dpp;
    LPDIRECT3D8           m_pD3D;              // The D3D enumerator object
    LPDIRECT3DDEVICE8     m_pd3dDevice;        // The D3D rendering device
    LPDIRECT3DSURFACE8    m_pBackBuffer;       // The backbuffer
    LPDIRECT3DSURFACE8    m_pDepthBuffer;      // The depthbuffer

    // Variables for timing
    FLOAT      m_fTime;             // Current absolute time in seconds
    FLOAT      m_fElapsedTime;      // Elapsed absolute time since last frame
    FLOAT      m_fAppTime;          // Current app time in seconds
    FLOAT      m_fElapsedAppTime;   // Elapsed app time since last frame
    BOOL       m_bPaused;           // Whether app time is paused by user
    FLOAT      m_fFPS;              // Instanteous frame rate
    WCHAR      m_strFrameRate[20];  // Frame rate written to a string
    HANDLE     m_hFrameCounter;     // Handle to framerate perf counter

    // Members to init the XINPUT devices.
    XDEVICE_PREALLOC_TYPE* m_InputDeviceTypes;
    DWORD                  m_dwNumInputDeviceTypes;
    XBGAMEPAD*             m_Gamepad;
    XBGAMEPAD              m_DefaultGamepad;

    // Helper functions
    HRESULT RenderGradientBackground( DWORD dwTopColor, DWORD dwBottomColor );

    // Overridable functions for the 3D scene created by the app
    virtual HRESULT Initialize()            { return S_OK; }
    virtual HRESULT FrameMove()             { return S_OK; }
    virtual HRESULT Render()                { return S_OK; }
    virtual HRESULT Cleanup()               { return S_OK; }

public:
    // Functions to create, run, and clean up the application
    HRESULT Create();
    INT     Run();
    VOID    Destroy();

    // Internal constructor
    CXBApplication();
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdecc\dvdecc.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

   DVD ECC - dvdecc.c

Abstract:

   Tally data from DVD ECC Mode Sense page for every DVD cache size read

Author:

   Emeron Bachhuber

Notes:


--*/


//#include <idex.h>
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <devioctl.h>
#include <scsi.h>
#include <ntddscsi.h>

// Macros to swap the byte order of a USHORT or ULONG at compile time.
#define IdexConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define IdexConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))


#define BytesPerSector 2048				// 2KB sectors
#define MaxSectors 64					// Maximum sectors for SCSIOP_READ
#define CacheLBAs 192					// Thomson says to read 192 LBAs per ECC read
#define BufSize  CacheLBAs*BytesPerSector


struct ECCData {
	LARGE_INTEGER Bytes;
	DWORD BytesCorrected;
	DWORD BlocksCorrected;
	DWORD BlocksUncorrectable;
	DWORD BlocksProcessed;
};


// Globals
ECCData FileECC, TotalECC;
BOOL LogPerRead;
HANDLE hDevice;
UCHAR *Buf;


VOID
DVDECCLogSenseData(HANDLE LogHandle, SENSE_DATA SenseData) {
	// Log SenseData
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData ErrorCode:  0x%.2x", SenseData.ErrorCode);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Valid:  0x%.2x", SenseData.Valid);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SegmentNumber:  0x%.2x", SenseData.SegmentNumber);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKey:  0x%.2x", SenseData.SenseKey);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Reserved:  0x%.2x", SenseData.Reserved);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData IncorrectLength:  0x%.2x", SenseData.IncorrectLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData EndOfMedia:  0x%.2x", SenseData.EndOfMedia);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FileMark:  0x%.2x", SenseData.FileMark);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[0]:  0x%.2x", SenseData.Information[0]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[1]:  0x%.2x", SenseData.Information[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[2]:  0x%.2x", SenseData.Information[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[3]:  0x%.2x", SenseData.Information[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseLength:  0x%.2x", SenseData.AdditionalSenseLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[0]:  0x%.2x", SenseData.CommandSpecificInformation[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[1]:  0x%.2x", SenseData.CommandSpecificInformation[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[2]:  0x%.2x", SenseData.CommandSpecificInformation[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[3]:  0x%.2x", SenseData.CommandSpecificInformation[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCode:  0x%.2x", SenseData.AdditionalSenseCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCodeQualifier:  0x%.2x", SenseData.AdditionalSenseCodeQualifier);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FieldReplaceableUnitCode:  0x%.2x", SenseData.FieldReplaceableUnitCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[0]:  0x%.2x", SenseData.SenseKeySpecific[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[1]:  0x%.2x", SenseData.SenseKeySpecific[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[2]:  0x%.2x", SenseData.SenseKeySpecific[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[3]:  0x%.2x", SenseData.SenseKeySpecific[3]);	
}


VOID
GetECCPage(HANDLE LogHandle, DWORD Bytes) {
	UCHAR ECCPage[24];
	SENSE_DATA SenseData;
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	PCDB Cdb = (PCDB)&PassThrough.Cdb;
	BOOL bReturn;
	DWORD cbBytesReturned;
	DWORD BytesCorrected, BlocksCorrected, BlocksUncorrectable, BlocksProcessed;

	ZeroMemory(ECCPage, sizeof(ECCPage));
	ZeroMemory(&SenseData, sizeof(SENSE_DATA));
	ZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
	PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
	PassThrough.DataBuffer = ECCPage;
	PassThrough.DataTransferLength = sizeof(ECCPage);
	Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
	Cdb->MODE_SENSE10.PageCode = 0x24;
	*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
		(USHORT)IdexConstantUshortByteSwap(sizeof(ECCPage));

	bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
							&PassThrough, sizeof(PassThrough), 
							&SenseData, sizeof(SenseData),
							&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED cbBytesReturned > 0");
			DVDECCLogSenseData(LogHandle, SenseData);
		}
	}

	// Increment Counters
	BytesCorrected = (ECCPage[8]<<24) + (ECCPage[9]<<16) + (ECCPage[10]<<8) + ECCPage[11];
	BlocksCorrected = (ECCPage[12]<<24) + (ECCPage[13]<<16) + (ECCPage[14]<<8) + ECCPage[15];
	BlocksUncorrectable = (ECCPage[16]<<24) + (ECCPage[17]<<16) + (ECCPage[18]<<8) + ECCPage[19];
	BlocksProcessed = (ECCPage[20]<<24) + (ECCPage[21]<<16) + (ECCPage[22]<<8) + ECCPage[23];
	
	FileECC.Bytes.QuadPart += Bytes;
	FileECC.BytesCorrected += BytesCorrected;
	FileECC.BlocksCorrected += BlocksCorrected;
	FileECC.BlocksUncorrectable += BlocksUncorrectable;
	FileECC.BlocksProcessed += BlocksProcessed;
	
	
	TotalECC.BytesCorrected += BytesCorrected;
	TotalECC.BlocksCorrected += BlocksCorrected;
	TotalECC.BlocksUncorrectable += BlocksUncorrectable;
	TotalECC.BlocksProcessed += BlocksProcessed;
	TotalECC.Bytes.QuadPart += Bytes;
		
	// Log
	if(LogPerRead) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Bytes Read: %#x (%u)", Bytes, Bytes);
		xLog(gbConsoleOut, LogHandle, XLL_INFO,	"ECC Bytes Corrected: %#.8x (%u)", BytesCorrected, BytesCorrected);
		xLog(gbConsoleOut, LogHandle, XLL_INFO,	"ECC Blocks Corrected: %#.8x (%u)", BlocksCorrected, BlocksCorrected);
		xLog(gbConsoleOut, LogHandle, XLL_INFO,	"ECC Blocks Uncorrectable: %#.8x (%u)", BlocksUncorrectable, BlocksUncorrectable);
		xLog(gbConsoleOut, LogHandle, XLL_INFO,	"ECC Blocks Processed: %#.8x (%u)", BlocksProcessed, BlocksProcessed);
	}
}


VOID 
LogFileECC(HANDLE LogHandle, CHAR *strFile) {
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"%s Bytes Read: %#I64x (%I64u)", strFile, FileECC.Bytes.QuadPart, FileECC.Bytes.QuadPart);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"%s ECC Bytes Corrected: %#.8x (%u)", strFile, FileECC.BytesCorrected, FileECC.BytesCorrected);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"%s ECC Blocks Corrected: %#.8x (%u)", strFile, FileECC.BlocksCorrected, FileECC.BlocksCorrected);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"%s ECC Blocks Uncorrectable: %#.8x (%u)", strFile, FileECC.BlocksUncorrectable, FileECC.BlocksUncorrectable);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"%s ECC Blocks Processed: %#.8x (%u)", strFile, FileECC.BlocksProcessed, FileECC.BlocksProcessed);
}


VOID 
LogTotalECC(HANDLE LogHandle) {
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Total Bytes Read: %#I64x (%I64u)", TotalECC.Bytes.QuadPart, TotalECC.Bytes.QuadPart);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Total ECC Bytes Corrected: %#.8x (%u)", TotalECC.BytesCorrected, TotalECC.BytesCorrected);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Total ECC Blocks Corrected: %#.8x (%u)", TotalECC.BlocksCorrected, TotalECC.BlocksCorrected);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Total ECC Blocks Uncorrectable: %#.8x (%u)", TotalECC.BlocksUncorrectable, TotalECC.BlocksUncorrectable);
	xLog(gbConsoleOut, LogHandle, XLL_INFO,	"Total ECC Blocks Processed: %#.8x (%u)", TotalECC.BlocksProcessed, TotalECC.BlocksProcessed);
}


VOID
ReadFileECC(HANDLE LogHandle, CHAR *strFile) {
	DWORD Bytes;
    HANDLE hFile;
	BOOL bReturn, bEOF;

	xSetFunctionName(LogHandle, "ReadFileECC");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "File: %s", strFile);

	// Clear per file counters
	ZeroMemory(&FileECC, sizeof(FileECC));

	// Open file
	hFile = CreateFile(strFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CreateFile(%s) returned INVALID_HANDLE_VALUE, Error Code = %u", strFile, GetLastError());
		return;
	}

	bEOF = FALSE;
	while(!bEOF) {
		// Read from file
		bReturn = ReadFile(hFile, Buf, BufSize, &Bytes, NULL);
		if(bReturn) {
			if(Bytes == 0) {
				// EOF
				bEOF = TRUE;
			} else {
				// Log ECC for this read
				GetECCPage(LogHandle, Bytes);
			}
		} else {
			// error
			bEOF = TRUE;
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"ReadFile(%s) Failed Error Code = %u", strFile, GetLastError());
		}
	}

	// Log ECC for this file
	LogFileECC(LogHandle, strFile);

	// Close file
	if(!CloseHandle(hFile)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CloseHande(%s) Error Code = %u", strFile, GetLastError());
	}
}


VOID
ListFiles(HANDLE LogHandle, CHAR *strFind) {
	CHAR strPath[MAX_PATH], strNewFind[MAX_PATH], strFile[MAX_PATH];
	int i, LastBackSlash;
    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    xSetFunctionName(LogHandle, "List Files");

	LastBackSlash = 0;
	for(i = 0; i < lstrlenA(strFind); i++) {
		if(strFind[i] == '\\') {
			LastBackSlash = i;
		}
	}
	lstrcpynA(strPath, strFind, LastBackSlash + 1);


    // Start the find and check for failure.
    hFind = FindFirstFile(strFind, &wfd);

    if(INVALID_HANDLE_VALUE == hFind) {
        xLog(gbConsoleOut, LogHandle, XLL_FAIL, "FindFirstFile failed");
    } else {
        // Display each file and ask for the next.
        do {
			if((wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY) {
				// Recurse on sub directory
				lstrcpyA(strNewFind, strPath);
				lstrcatA(strNewFind, "\\");
				lstrcatA(strNewFind, wfd.cFileName);					// add directory name
				lstrcatA(strNewFind, "\\*");							// add wild card
				ListFiles(LogHandle, strNewFind);
			} else {
				// Read file
				lstrcpyA(strFile, strPath);
				lstrcatA(strFile, "\\");
				lstrcatA(strFile, wfd.cFileName);
				ReadFileECC(LogHandle, strFile);
			}
        } while(FindNextFile(hFind, &wfd));

        // Close the find handle.
        FindClose(hFind);
    }
}


VOID
ReadLBA(HANDLE LogHandle, ULONG LBA, USHORT Sectors) {
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	BOOL bReturn;
	ULONG i, Reps;
	USHORT RemainSectors;

	// Divide sectors into number of MaxSector reads
	Reps = Sectors/MaxSectors;
	RemainSectors = (USHORT)(Sectors%MaxSectors);

	// Prepare read CDB
	ZeroMemory(&PassThrough, sizeof(PassThrough));

	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
	PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
	PassThrough.DataBuffer = Buf;
	PassThrough.DataTransferLength = MaxSectors*BytesPerSector;

	Cdb = (PCDB)&PassThrough.Cdb;
	Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.TransferBlocks = IdexConstantUshortByteSwap(MaxSectors);
	
	// Read MaxSector size chunks
	for(i = 0; i < Reps; i++) {
		// Set starting LBA
		Cdb->CDB10.LogicalBlock = IdexConstantUlongByteSwap(LBA + i*MaxSectors);

		bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
									&PassThrough, sizeof(PassThrough), 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) {
			// Read error
			if(!bReturn) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, LastError = %d", LBA + i*MaxSectors, MaxSectors, GetLastError());
			}

			if(cbBytesReturned > 0) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, cbBytesReturned > 0", LBA, MaxSectors);
				DVDECCLogSenseData(LogHandle, SenseData);
			}
		}
	}

	// Read remaining LBAs
	if(RemainSectors > 0) {
		PassThrough.DataTransferLength = RemainSectors*BytesPerSector;
		Cdb->CDB10.LogicalBlock = IdexConstantUlongByteSwap(LBA + Reps*MaxSectors);
		Cdb->CDB10.TransferBlocks = IdexConstantUshortByteSwap(RemainSectors);

		bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
									&PassThrough, sizeof(PassThrough), 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) {
			// Read error
			if(!bReturn) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, LastError = %d", LBA + i*MaxSectors, RemainSectors, GetLastError());
			}

			if(cbBytesReturned > 0) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, cbBytesReturned > 0", LBA, RemainSectors);
				DVDECCLogSenseData(LogHandle, SenseData);
			}
		}
	}

	// Log ECC
	GetECCPage(LogHandle, Sectors*BytesPerSector);
}


VOID
LBAECC(HANDLE LogHandle, ULONG StartLBA, ULONG EndLBA) {
	ULONG i, NumLBAs, Reps;
	USHORT RemainLBAs;
	CHAR strFile[MAX_PATH];

	xSetFunctionName(LogHandle, "LBAECC");

	wsprintfA(strFile, "LBA (%u - %u)", StartLBA, EndLBA);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Reading %s", strFile);

	// Clear per file counters
	ZeroMemory(&FileECC, sizeof(FileECC));

	// Compute Reps based on the number of LBAs that fit in the cache
	NumLBAs = EndLBA - StartLBA + 1;
	Reps = NumLBAs/CacheLBAs;
	RemainLBAs = (USHORT)(NumLBAs%CacheLBAs);


	// Read maximum allowed sectors
	for(i = 0; i < Reps; i++) {
		ReadLBA(LogHandle, i*CacheLBAs + StartLBA, CacheLBAs);
		
	}

	// Read the remaining LBAs
	if(RemainLBAs > 0) {
		ReadLBA(LogHandle, Reps*CacheLBAs + StartLBA, RemainLBAs);
	}

	// Log ECC for this LBA range
	LogFileECC(LogHandle, strFile);
}


VOID
DVDECCStartTest(HANDLE LogHandle) {
	CHAR strFile[MAX_PATH];
	ULONG StartLBA, EndLBA;


	xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "DVD ECC");

	// Get ini settings
	GetProfileStringA("dvdecc", "FileName", "", strFile, MAX_PATH);
	StartLBA = GetProfileIntA("dvdecc", "StartLBA", 0);
	EndLBA = GetProfileIntA("dvdecc", "EndLBA", 0);
	if(GetProfileIntA("dvdecc", "LogPerRead", 0) == 1) {
		LogPerRead = TRUE;
	} else {
		LogPerRead = FALSE;
	}

  	// Allocate Buf
	Buf = (UCHAR *)VirtualAlloc(NULL, BufSize, MEM_COMMIT, PAGE_READWRITE);
	if(Buf == NULL) {
		xSetFunctionName(LogHandle, "Allocate Buffer");
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "VirtualAlloc (%u bytes) FAILED LastError = %d", 
				BufSize, GetLastError());
		return;
	}

	// Open DVD device
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, NULL);

	if(hDevice == INVALID_HANDLE_VALUE) {
		xSetFunctionName(LogHandle, "Open DVD Device");
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile FAILED LastError = %d", GetLastError());
		return;
	}

	// Read files
	if(lstrlenA(strFile) > 0) {
		ZeroMemory(&TotalECC, sizeof(TotalECC));
		ListFiles(LogHandle, strFile);
		LogTotalECC(LogHandle);
	}

	// Read LBAs
	if(EndLBA > 0) {
		ZeroMemory(&TotalECC, sizeof(TotalECC));
		LBAECC(LogHandle, StartLBA, EndLBA);
		LogTotalECC(LogHandle);
	}

	// Close device
	if(!CloseHandle(hDevice)) {
		xSetFunctionName(LogHandle, "Close Device");
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CloseHande(DVD Device) Error Code = %u", GetLastError());
	}
}


VOID
DVDECCEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_A("t:\\dvdecc.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("DVDECC: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("DVDECC: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }
	
	gbConsoleOut = TRUE;

	// Copy ini to t:\\ if not already there

	// Start Test
	DVDECCStartTest(LogHandle);

	// End Test
	DVDECCEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("DVDECC: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dvdecc )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dvdecc )
    EXPORT_TABLE_ENTRY( "StartTest", DVDECCStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DVDECCEndTest )
END_EXPORT_TABLE( dvdecc )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbinput.cpp ===
//-----------------------------------------------------------------------------
// File: XBInput.cpp
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.cpp for December XDK release
//       01.03.01 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include "XBInput.h"




//-----------------------------------------------------------------------------
// Globals
//-----------------------------------------------------------------------------

// Deadzone for thumbsticks
#define XBINPUT_DEADZONE 0.24f

// Global instance of gamepad devices
XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads )
{
    // Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices( XDEVICE_TYPE_GAMEPAD );

    // Open the devices
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        ZeroMemory( &g_Gamepads[i], sizeof(XBGAMEPAD) );
        if( dwDeviceMask & (1<<i) ) 
        {
            // Get a handle to the device
            g_Gamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                                XDEVICE_NO_SLOT, NULL );

            // Store capabilites of the device
            XInputGetCapabilities( g_Gamepads[i].hDevice, &g_Gamepads[i].caps );
        }
    }

    // Created devices are kept global, but for those who prefer member
    // variables, they can get a pointer to the gamepads returned.
    if( ppGamepads )
        (*ppGamepads) = g_Gamepads;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads )
{
    if( NULL == pGamepads )
        pGamepads = g_Gamepads;

    // TCR 3-21 Controller Discovery
    // Get status about gamepad insertions and removals. Note that, in order to
    // not miss devices, we will check for removed device BEFORE checking for
    // insertions
    DWORD dwInsertions, dwRemovals;
    XGetDeviceChanges( XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals );

    // Loop through all gamepads
    for( DWORD i=0; i < XGetPortCount(); i++ )
    {
        // Handle removed devices.
        pGamepads[i].bRemoved = ( dwRemovals & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bRemoved )
        {
            XInputClose( pGamepads[i].hDevice );
            pGamepads[i].hDevice = NULL;
            pGamepads[i].Feedback.Rumble.wLeftMotorSpeed  = 0;
            pGamepads[i].Feedback.Rumble.wRightMotorSpeed = 0;
        }

        // Handle inserted devices
        pGamepads[i].bInserted = ( dwInsertions & (1<<i) ) ? TRUE : FALSE;
        if( pGamepads[i].bInserted ) 
        {
            // TCR 1-14 Device Types
            pGamepads[i].hDevice = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, 
                                               XDEVICE_NO_SLOT, NULL );
            XInputGetCapabilities( pGamepads[i].hDevice, &pGamepads[i].caps );
        }

        // If we have a valid device, poll it's state and track button changes
        if( pGamepads[i].hDevice )
        {
            // Read the input state
            XINPUT_STATE xiState;
            XInputGetState( pGamepads[i].hDevice, &xiState );

            // Copy gamepad to local structure
            memcpy( &pGamepads[i], &xiState.Gamepad, sizeof(XINPUT_STATE) );

            // Put Xbox device input for the gamepad into our custom format
            FLOAT fX1 = (pGamepads[i].sThumbLX+0.5f)/32767.5f;
            pGamepads[i].fX1 = ( fX1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY1 = (pGamepads[i].sThumbLY+0.5f)/32767.5f;
            pGamepads[i].fY1 = ( fY1 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY1)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fX2 = (pGamepads[i].sThumbRX+0.5f)/32767.5f;
            pGamepads[i].fX2 = ( fX2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fX2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            FLOAT fY2 = (pGamepads[i].sThumbRY+0.5f)/32767.5f;
            pGamepads[i].fY2 = ( fY2 >= 0.0f ? 1.0f : -1.0f ) *
                               max( 0.0f, (fabsf(fY2)-XBINPUT_DEADZONE)/(1.0f-XBINPUT_DEADZONE) );

            // Get the boolean buttons that have been pressed since the last
            // call. Each button is represented by one bit.
            pGamepads[i].wPressedButtons = ( pGamepads[i].wLastButtons ^ pGamepads[i].wButtons ) & pGamepads[i].wButtons;
            pGamepads[i].wLastButtons    = pGamepads[i].wButtons;

            // Get the analog buttons that have been pressed or released since
            // the last call.
            for( DWORD b=0; b<8; b++ )
            {
                // Turn the 8-bit polled value into a boolean value
                BOOL bPressed = ( pGamepads[i].bAnalogButtons[b] > 0 );

                if( bPressed )
                    pGamepads[i].bPressedAnalogButtons[b] = !pGamepads[i].bLastAnalogButtons[b];
                else
                    pGamepads[i].bPressedAnalogButtons[b] = FALSE;
                
                // Store the current state for the next time
                pGamepads[i].bLastAnalogButtons[b] = bPressed;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbinput.h ===
//-----------------------------------------------------------------------------
// File: XBInput.h
//
// Desc: Input helper functions for the XBox samples
//
// Hist: 12.15.00 - Separated from XBUtil.h for December XDK release
//       01.03.00 - Made changes for real Xbox controller
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBINPUT_H
#define XBINPUT_H




//-----------------------------------------------------------------------------
// Name: struct XBGAMEPAD
// Desc: structure for holding Gamepad data
//-----------------------------------------------------------------------------
struct XBGAMEPAD : public XINPUT_GAMEPAD
{
    // The following members are inherited from XINPUT_GAMEPAD:
    //    WORD    wButtons;
    //    BYTE    bAnalogButtons[8];
    //    SHORT   sThumbLX;
    //    SHORT   sThumbLY;
    //    SHORT   sThumbRX;
    //    SHORT   sThumbRY;

    // Thumb stick values converted to range [-1,+1]
    FLOAT      fX1;
    FLOAT      fY1;
    FLOAT      fX2;
    FLOAT      fY2;
    
    // State of buttons tracked since last poll
    WORD       wLastButtons;
    BOOL       bLastAnalogButtons[8];
    WORD       wPressedButtons;
    BOOL       bPressedAnalogButtons[8];

    // Rumble properties
    XINPUT_RUMBLE   Rumble;
    XINPUT_FEEDBACK Feedback;

    // Device properties
    XINPUT_CAPABILITIES caps;
    HANDLE     hDevice;

    // Flags for whether gamepad was just inserted or removed
    BOOL       bInserted;
    BOOL       bRemoved;
};




//-----------------------------------------------------------------------------
// Global access to gamepad devices
//-----------------------------------------------------------------------------
extern XBGAMEPAD g_Gamepads[4];




//-----------------------------------------------------------------------------
// Name: XBInput_CreateGamepads()
// Desc: Creates the gamepad devices
//-----------------------------------------------------------------------------
HRESULT XBInput_CreateGamepads( XBGAMEPAD** ppGamepads = NULL );




//-----------------------------------------------------------------------------
// Name: XBInput_GetInput()
// Desc: Processes input from the gamepads
//-----------------------------------------------------------------------------
VOID XBInput_GetInput( XBGAMEPAD* pGamepads = NULL );




#endif // XBINPUT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\XBResource.cpp ===
//-----------------------------------------------------------------------------
// File: XBResource.cpp
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <stdio.h>
#include "XBUtil.h"
#include "XBResource.h"




//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource )
{
    switch( pResource->GetType() )
    {
        case D3DRTYPE_TEXTURE:       return sizeof(D3DTexture);
        case D3DRTYPE_VOLUMETEXTURE: return sizeof(D3DVolumeTexture);
        case D3DRTYPE_CUBETEXTURE:   return sizeof(D3DCubeTexture);
        case D3DRTYPE_VERTEXBUFFER:  return sizeof(D3DVertexBuffer);
        case D3DRTYPE_INDEXBUFFER:   return sizeof(D3DIndexBuffer);
        case D3DRTYPE_PALETTE:       return sizeof(D3DPalette);
    }
    return 0;
}




//-----------------------------------------------------------------------------
// Name: CXBPackedResource()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBPackedResource::CXBPackedResource()
{
    m_pSysMemData    = NULL;
    m_pVidMemData    = NULL;
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBPackedResource()
// Desc: Destructor
//-----------------------------------------------------------------------------
CXBPackedResource::~CXBPackedResource()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: GetData()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
VOID* CXBPackedResource::GetData( const CHAR* strName ) const
{
    if( NULL==m_pResourceTags || NULL==strName )
        return NULL;

    for( DWORD i=0; i<m_dwNumResources; i++ )
    {
        if( !_stricmp( strName, m_pResourceTags[i].strName ) )
            return &m_pSysMemData[m_pResourceTags[i].dwOffset];
    }

    return NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Loads all the texture resources from the given XPR.
//-----------------------------------------------------------------------------
HRESULT CXBPackedResource::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, DWORD dwNumResources,
                                   XBRESOURCE* pResourceTags )
{
    // Find the media file
    CHAR strResourcePath[512];
    if( FAILED( XBUtil_FindMediaFile( strResourcePath, strFilename ) ) )
        return E_FAIL;

    // Open the fileto read the XPR headers
    FILE* file = fopen( strResourcePath, "rb" );
    if( NULL == file )
        return E_FAIL;

    // Read in and verify the XPR magic header
    XPR_HEADER xprh;
    fread( &xprh, sizeof(XPR_HEADER), 1, file );
    if( xprh.dwMagic != XPR_MAGIC_VALUE )
    {
        OutputDebugString( _T("Invalid Xbox Packed Resource (.xpr) file") );
        fclose( file );
        return E_INVALIDARG;
    }

    // Compute memory requirements
    DWORD dwSysMemDataSize = xprh.dwHeaderSize - sizeof(XPR_HEADER);
    DWORD dwVidMemDataSize = xprh.dwTotalSize - xprh.dwHeaderSize;

    // Allocate memory
    m_pSysMemData = new BYTE[dwSysMemDataSize];
    m_pVidMemData = (BYTE*)D3D_AllocContiguousMemory( dwVidMemDataSize, D3DTEXTURE_ALIGNMENT );

    // Read in the data from the file
    fread( m_pSysMemData, dwSysMemDataSize, 1, file );
    fread( m_pVidMemData, dwVidMemDataSize, 1, file );

    // Done with the file
    fclose( file );
    
    // Loop over resources, calling Register()
    BYTE* pData = m_pSysMemData;

    for( DWORD i = 0; i < dwNumResources; i++ )
    {
		// Check for userdata
		if( *((DWORD*)pData) & 0x80000000 )
		{
			DWORD dwType = ((DWORD*)pData)[0];
			DWORD dwSize = ((DWORD*)pData)[1];
			pData += 8;

			pData += dwSize;
		}
		else
		{
			// Get the resource
			LPDIRECT3DRESOURCE8 pResource = (LPDIRECT3DRESOURCE8)pData;
    
	        // Register the resource
		    pResource->Register( m_pVidMemData );
        
			// Advance the pointer
			pData += XBResource_SizeOf( pResource );
		}
    }

    // Finally, store number of resources and the resource tags
    m_dwNumResources = dwNumResources;
    m_pResourceTags  = pResourceTags;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Tears down the packed resource data
//-----------------------------------------------------------------------------
VOID CXBPackedResource::Destroy() 
{
    if( m_pSysMemData != NULL )
    {
        delete[] m_pSysMemData;
        m_pSysMemData = NULL;
    }
    if( m_pVidMemData != NULL )
    {
        D3D_FreeContiguousMemory( m_pVidMemData );
        m_pVidMemData = NULL;
    }
    m_dwNumResources = 0L;
    m_pResourceTags  = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\XBResource.h ===
//-----------------------------------------------------------------------------
// File: XBResource.h
//
// Desc: Loads resources from an XPR (Xbox Packed Resource) file.  
//
// Hist: 03.12.01 - New for April XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBRESOURCE_H
#define XBRESOURCE_H



//-----------------------------------------------------------------------------
// Name: XBResource_SizeOf()
// Desc: Determines the byte size of a D3DResource
//-----------------------------------------------------------------------------
DWORD XBResource_SizeOf( LPDIRECT3DRESOURCE8 pResource );





//-----------------------------------------------------------------------------
// Name: struct XBRESOURCE
// Desc: Name tag for resources. An app may initialize this structure, and pass
//       it to the resource's Create() function. From then on, the app may call
//       GetResource() to retrieve a resource using an ascii name.
//-----------------------------------------------------------------------------
struct XBRESOURCE
{
    CHAR* strName;
    DWORD dwOffset;
};





//-----------------------------------------------------------------------------
// Name: class CXBPackedResource
// Desc: 
//-----------------------------------------------------------------------------
class CXBPackedResource
{
protected:
    BYTE*       m_pSysMemData;    // Alloc'ed mem for resource headers etc.
    BYTE*       m_pVidMemData;    // Alloc'ed mem for resource data, etc.

    DWORD       m_dwNumResources; // Number of loaded resources
 
    XBRESOURCE* m_pResourceTags;  // Tags to associate names with the resources

public:
    // Loads the resources out of the specified bundle
    HRESULT Create( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strFilename, 
                    DWORD dwNumResources, XBRESOURCE* pResourceTags = NULL );

    VOID Destroy();

    // Functions to retrieve resources by their offset
    VOID* GetData( DWORD dwOffset ) const
    { return &m_pSysMemData[dwOffset]; }

    LPDIRECT3DRESOURCE8 GetResource( DWORD dwOffset ) const
    { return (LPDIRECT3DRESOURCE8)GetData(dwOffset); }

    LPDIRECT3DTEXTURE8 GetTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DTEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( DWORD dwOffset ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( DWORD dwOffset ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetData( dwOffset ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( DWORD dwOffset ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetData( dwOffset ); }

    // Functions to retrieve resources by their name
    VOID* GetData( const CHAR* strName ) const;

    LPDIRECT3DRESOURCE8 GetResource( const CHAR* strName ) const
    { return (LPDIRECT3DRESOURCE8)GetData( strName ); }

    LPDIRECT3DTEXTURE8 GetTexture( const CHAR* strName ) const
    { return (LPDIRECT3DTEXTURE8)GetResource( strName ); }

    LPDIRECT3DCUBETEXTURE8 GetCubemap( const CHAR* strName ) const
    { return (LPDIRECT3DCUBETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVOLUMETEXTURE8 GetVolumeTexture( const CHAR* strName ) const
    { return (LPDIRECT3DVOLUMETEXTURE8)GetResource( strName ); }

    LPDIRECT3DVERTEXBUFFER8 GetVertexBuffer( const CHAR* strName ) const
    { return (LPDIRECT3DVERTEXBUFFER8)GetResource( strName ); }

    // Constructor/destructor
    CXBPackedResource();
    ~CXBPackedResource();
};




#endif XBRESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xmenu.h ===
#ifndef __XMENU_H
#define __XMENU_H

#include "XBFont.h"
#include "XBInput.h"

// menu item flags
#define MITEM_SEPARATOR		0x0001			// this item is a separator
#define MITEM_ROUTINE		0x0002			// this item calls a routine
#define MITEM_DISABLED		0x0004			// this item is greyed out

// menu routine commands
#define MROUTINE_INIT		0xffff			// first call to routine
#define MROUTINE_ABORT		0xfffe			// abort routine triggered

// menu routine return values
#define MROUTINE_RETURN		0x0001			// return to menu
#define MROUTINE_DIE		0x0002			// kill routine
#define MROUTINE_SLEEP		0x0003			// routine sleeps

// menu item definition
#define MITEM_STRINGLEN 48
typedef struct _xmenuitem
{
	DWORD flags;
	WCHAR string[MITEM_STRINGLEN];			// text to display
	DWORD val1;								// user defined values
	DWORD val2;
	void *action;							// link to menu or routine
	struct _xmenu *menu;					// menu that owns this item
	DWORD color;							// item color
} XMenuItem;

// menu commands
#define MENU_NEXTITEM		0x0001			// next menu item
#define MENU_PREVITEM		0x0002			// previous menu item
#define MENU_SELECTITEM		0x0003			// select this menu item
#define MENU_BACK			0x0004			// go back one level
#define MENU_ACTIVATE		0x0005			// activate menu

// menu flags
#define MENU_LEFT			0x0001			// left justify menu text
#define MENU_RIGHT			0x0002			// right justify menu text
#define MENU_WRAP			0x0004			// wrap menu selection
#define MENU_NOBACK			0x0008			// cannot use back button

typedef struct _xmenu
{
	float x, y;								// screen position
	float w, h;								// menu size
	DWORD flags;							// menu flags
	DWORD topcolor, bottomcolor;			// menu background gradient color
	DWORD seltopcolor, selbotcolor;			// menu selection bar gradient color
	DWORD itemcolor;						// menu item default color
	struct _xmenu *parent;					// parent menu

	WCHAR title[MITEM_STRINGLEN];			// menu title
	DWORD titlecolor;						// memu title color
	DWORD maxshow;							// max # of items to show at one time
	DWORD maxitems;							// max # of items
	DWORD nitems;							// # of items
	DWORD curitem;							// current selected item
	XMenuItem *items;						// items

	DWORD (*abortroutine)(DWORD, XMenuItem *);	// called when menu aborted
} XMenu;

#ifdef __cplusplus
extern "C" {
#endif

extern XMenu *XMenu_CurMenu;
extern int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);

void XMenu_SetFont(CXBFont *font);
XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *));
void XMenu_Shutdown();
void XMenu_Delete(XMenu *m);
XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action);
void XMenu_DeleteItem(XMenuItem *mi);
void XMenu_SetMaxShow(XMenu *m, DWORD maxshow);
void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color);
void XMenu_SetItemText(XMenuItem *mi, WCHAR *string);
#define XMenu_IsActive() (XMenu_CurMenu||XMenu_CurRoutine)

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad);	// gets command based on joypad
DWORD XMenu_Activate(XMenu *m);				// activates a menu
DWORD XMenu_Routine(DWORD command);			// called each frame to update menu

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbapp.cpp ===
//-----------------------------------------------------------------------------
// File: XBApp.cpp
//
// Desc: Application class for the XBox samples.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       12.19.01 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include "XBApp.h"




//-----------------------------------------------------------------------------
// Global access to common members
//-----------------------------------------------------------------------------
CXBApplication*    g_pXBApp     = NULL;
LPDIRECT3DDEVICE8  g_pd3dDevice = NULL;




//-----------------------------------------------------------------------------
// Name: CXBApplication()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBApplication::CXBApplication()
{
    // Initialize member variables
    g_pXBApp          = this;

    // Direct3D variables
    m_pD3D            = NULL;
    m_pd3dDevice      = NULL;
    m_pDepthBuffer    = NULL;
    m_pBackBuffer     = NULL;

    // Variables to perform app timing
    m_bPaused         = FALSE;
    m_fTime           = 0.0f;
    m_fElapsedTime    = 0.0f;
    m_fAppTime        = 0.0f;
    m_fElapsedAppTime = 0.0f;
    m_fFPS            = 0.0f;
    m_strFrameRate[0] = L'\0';

    // Set up the presentation parameters for a double-bufferd, 640x480,
    // 32-bit display using depth-stencil. Override these parameters in
    // your derived class as your app requires.
    ZeroMemory( &m_d3dpp, sizeof(m_d3dpp) );
    m_d3dpp.BackBufferWidth        = 640;
    m_d3dpp.BackBufferHeight       = 480;
    m_d3dpp.BackBufferFormat       = D3DFMT_A8R8G8B8;
    m_d3dpp.BackBufferCount        = 1;
    m_d3dpp.EnableAutoDepthStencil = TRUE;
    m_d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
    m_d3dpp.SwapEffect             = D3DSWAPEFFECT_DISCARD;

    // Specify number and type of input devices this app will be using. By
    // default, you can use 0 and NULL, which triggers XInputDevices() to
    // prealloc the default number and types of devices. To use chat or
    // other devices, override these variables in your derived class.
    m_dwNumInputDeviceTypes = 0;
    m_InputDeviceTypes      = NULL;
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the app
//-----------------------------------------------------------------------------
HRESULT CXBApplication::Create()
{
    HRESULT hr;

    // Create the Direct3D object
    OutputDebugString( _T("XBApp: Creating Direct3D...\n") );
    if( NULL == ( m_pD3D = Direct3DCreate8(D3D_SDK_VERSION) ) )
    {
        OutputDebugString( _T("XBApp: Unable to create Direct3D!\n") );
        return E_FAIL;
    }

    // Create the device
    OutputDebugString( _T("XBApp: Creating the D3D device...\n") );
    if( FAILED( hr = m_pD3D->CreateDevice( 0, D3DDEVTYPE_HAL, NULL, 
                                           D3DCREATE_HARDWARE_VERTEXPROCESSING, 
                                           &m_d3dpp, &m_pd3dDevice ) ) )
    {
        OutputDebugString( _T("XBApp: Could not create D3D device!\n") );
        return hr;
    }

    // Allow global access to the device
    g_pd3dDevice = m_pd3dDevice;

    // Store pointers to the depth and back buffers
    m_pd3dDevice->GetDepthStencilSurface( &m_pDepthBuffer );
    m_pd3dDevice->GetBackBuffer( 0, 0, &m_pBackBuffer );

    // Initialize core peripheral port support. Note: If these parameters
    // are 0 and NULL, respectively, then the default number and types of 
    // controllers will be initialized.
    XInitDevices( m_dwNumInputDeviceTypes, m_InputDeviceTypes );

    // Create the gamepad devices
    OutputDebugString( _T("XBApp: Creating gamepad devices...\n") );
    if( FAILED( hr = XBInput_CreateGamepads( &m_Gamepad ) ) )
    {
        OutputDebugString( _T("XBApp: Call to CreateGamepads() failed!\n") );
        return hr;
    }

    // Initialize the app's device-dependent objects
    OutputDebugString( _T("XBApp: Initializing the app...\n") );
    if( FAILED( hr = Initialize() ) )
    {
        OutputDebugString( _T("XBApp: Call to Initialize() failed!\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Cleanup objects
//-----------------------------------------------------------------------------
VOID CXBApplication::Destroy()
{
    // Perform app-specific cleanup
    Cleanup();

    // Release display objects
    SAFE_RELEASE( m_pd3dDevice );
    SAFE_RELEASE( m_pD3D );
}




//-----------------------------------------------------------------------------
// Name: Run()
// Desc: 
//-----------------------------------------------------------------------------
INT CXBApplication::Run()
{
    OutputDebugString( _T("XBApp: Running the application...\n") );

    // Get the frequency of the timer
    LARGE_INTEGER qwTicksPerSec;
    QueryPerformanceFrequency( &qwTicksPerSec );
    FLOAT fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;

    // Save the start time
    LARGE_INTEGER qwTime, qwLastTime, qwElapsedTime;
    QueryPerformanceCounter( &qwTime );
    qwLastTime.QuadPart = qwTime.QuadPart;

    LARGE_INTEGER qwAppTime, qwElapsedAppTime;
    qwAppTime.QuadPart        = 0;
    qwElapsedTime.QuadPart    = 0;
    qwElapsedAppTime.QuadPart = 0;

    // Run the game loop, animating and rendering frames
    while( TRUE )
    {
        //-----------------------------------------
        // Handle input
        //-----------------------------------------

        // Read the input for all connected gampads
        XBInput_GetInput( m_Gamepad );

        // Lump inputs of all connected gamepads into one common structure.
        // This is done so apps that need only one gamepad can function with
        // any gamepad.
        ZeroMemory( &m_DefaultGamepad, sizeof(m_DefaultGamepad) );
        for( DWORD i=0; i<4; i++ )
        {
            if( m_Gamepad[i].hDevice )
            {
                m_DefaultGamepad.sThumbLX += m_Gamepad[i].sThumbLX;
                m_DefaultGamepad.sThumbLY += m_Gamepad[i].sThumbLY;
                m_DefaultGamepad.sThumbRX += m_Gamepad[i].sThumbRX;
                m_DefaultGamepad.sThumbRY += m_Gamepad[i].sThumbRY;
                m_DefaultGamepad.fX1      += m_Gamepad[i].fX1;
                m_DefaultGamepad.fY1      += m_Gamepad[i].fY1;
                m_DefaultGamepad.fX2      += m_Gamepad[i].fX2;
                m_DefaultGamepad.fY2      += m_Gamepad[i].fY2;
                m_DefaultGamepad.wButtons        |= m_Gamepad[i].wButtons;
                m_DefaultGamepad.wPressedButtons |= m_Gamepad[i].wPressedButtons;
                m_DefaultGamepad.wLastButtons    |= m_Gamepad[i].wLastButtons;

                for( DWORD b=0; b<8; b++ )
                {
                    m_DefaultGamepad.bAnalogButtons[b]        |= m_Gamepad[i].bAnalogButtons[b];
                    m_DefaultGamepad.bPressedAnalogButtons[b] |= m_Gamepad[i].bPressedAnalogButtons[b];
                    m_DefaultGamepad.bLastAnalogButtons[b]    |= m_Gamepad[i].bLastAnalogButtons[b];
                }
            }
        }

        // Handle special input combo to trigger a reboot to the Xbox Dashboard
        if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] > 0 )
        {
            if( m_DefaultGamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] > 0 )
            {
                if( m_DefaultGamepad.bPressedAnalogButtons[XINPUT_GAMEPAD_BLACK] )
                    XLaunchNewImage( NULL, NULL );
            }
        }

        //-----------------------------------------
        // Perform app timing
        //-----------------------------------------

        // Check Start button
        if( m_DefaultGamepad.wPressedButtons & XINPUT_GAMEPAD_START )
            m_bPaused = !m_bPaused;

        // Get the current time (keep in LARGE_INTEGER format for precision)
        QueryPerformanceCounter( &qwTime );
        qwElapsedTime.QuadPart = qwTime.QuadPart - qwLastTime.QuadPart;
        qwLastTime.QuadPart    = qwTime.QuadPart;
        if( m_bPaused )
            qwElapsedAppTime.QuadPart = 0;
        else
            qwElapsedAppTime.QuadPart = qwElapsedTime.QuadPart;
        qwAppTime.QuadPart    += qwElapsedAppTime.QuadPart;

        // Store the current time values as floating point
        m_fTime           = fSecsPerTick * ((FLOAT)(qwTime.QuadPart));
        m_fElapsedTime    = fSecsPerTick * ((FLOAT)(qwElapsedTime.QuadPart));
        m_fAppTime        = fSecsPerTick * ((FLOAT)(qwAppTime.QuadPart));
        m_fElapsedAppTime = fSecsPerTick * ((FLOAT)(qwElapsedAppTime.QuadPart));

        // Compute the FPS (frames per second) once per second
        static FLOAT fLastTime = 0.0f;
        static DWORD dwFrames  = 0L;
        dwFrames++;

        if( m_fTime - fLastTime > 1.0f )
        {
            m_fFPS    = dwFrames / ( m_fTime - fLastTime );
            fLastTime = m_fTime;
            dwFrames  = 0L;
            swprintf( m_strFrameRate, L"%0.02f fps", m_fFPS );
        }

        //-----------------------------------------
        // Animate and render a frame
        //-----------------------------------------

        // Frame move the scene
        FrameMove();

        // Render the scene
        Render();

        // Finally, show the frame (swaps the backbuffer to the front)
        m_pd3dDevice->Present( NULL, NULL, NULL, NULL );
    }

    return 0;
}




//-----------------------------------------------------------------------------
// Name: RenderGradientBackground()
// Desc: Draws a gradient filled background
//-----------------------------------------------------------------------------
HRESULT CXBApplication::RenderGradientBackground( DWORD dwTopColor, 
                                                  DWORD dwBottomColor )
{
    // First time around, allocate a vertex buffer
    static LPDIRECT3DVERTEXBUFFER8 g_pVB  = NULL;
    if( g_pVB == NULL )
    {
        m_pd3dDevice->CreateVertexBuffer( 4*5*sizeof(FLOAT), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &g_pVB );
        struct BACKGROUNDVERTEX { D3DXVECTOR4 p; D3DCOLOR color; };
        BACKGROUNDVERTEX* v;
        g_pVB->Lock( 0, 0, (BYTE**)&v, 0L );
        v[0].p = D3DXVECTOR4(   0,   0, 1.0f, 1.0f ); v[0].color = dwTopColor;
        v[1].p = D3DXVECTOR4( 640,   0, 1.0f, 1.0f ); v[1].color = dwTopColor;
        v[2].p = D3DXVECTOR4(   0, 480, 1.0f, 1.0f ); v[2].color = dwBottomColor;
        v[3].p = D3DXVECTOR4( 640, 480, 1.0f, 1.0f ); v[3].color = dwBottomColor;
        g_pVB->Unlock();
    }

    // Set states
    m_pd3dDevice->SetTexture( 0, NULL );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP, D3DTOP_DISABLE );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE ); 
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE ); 
    m_pd3dDevice->SetVertexShader( D3DFVF_XYZRHW|D3DFVF_DIFFUSE );
    m_pd3dDevice->SetStreamSource( 0, g_pVB, 5*sizeof(FLOAT) );

    m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );

    // Clear the zbuffer
    m_pd3dDevice->Clear( 0, NULL, D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL, 0x00000000, 1.0f, 0L );

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\dvdjumpcounter.cpp ===
#include "xbapp.h"
#include "xmenu.h"

#include <devioctl.h>
#include <scsi.h>
#include <ntddscsi.h>

//
// Macros to swap the byte order of a USHORT or ULONG at compile time.
//

#define IdexConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define IdexConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))


// Program option struct
struct OPTIONS
{
	BOOL DisplayCounter;
	BOOL ResetCounter;
};

// Global options
OPTIONS     g_Options;

//-----------------------------------------------------------------------------
// Name: DisplayJumpCounter()
// Desc: Menu callback for first menu item select
//-----------------------------------------------------------------------------
DWORD SetDisplayJumpCounter(DWORD cmd, XMenuItem *pmi)
{
	OutputDebugStringA("SetDisplayJumpCounter\n");
	g_Options.DisplayCounter = TRUE;
    return MROUTINE_DIE;
}


//-----------------------------------------------------------------------------
// Name: ResetJumpCounter()
// Desc: Menu callback for second menu item select
//-----------------------------------------------------------------------------
DWORD SetResetJumpCounter(DWORD cmd, XMenuItem *pmi)
{
	OutputDebugStringA("SetResetJumpCounter\n");
	g_Options.ResetCounter = TRUE;
    return MROUTINE_DIE;
}


//-----------------------------------------------------------------------------
// Name: class CXBoxSample
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CXBoxSample : public CXBApplication {
private:
    // Font for rendering stats and help
    FLOAT           m_fFontHeight;
    FLOAT           m_fFontWidth;
    CXBFont         m_Font;
	
	// Menu system
    DWORD           m_dwMenuCommand;
    XMenu*          m_pMainMenu;

	// Display flag and strings
	BOOL			m_TextDisplayed;
	WCHAR			m_szDisplayLine1[64];
	WCHAR			m_szDisplayLine2[64];
	
	// Menu functions
	VOID DisplayJumpCounter();
	VOID ResetJumpCounter();
	VOID DisplayOutputStrings();

	VOID LogSenseData(SENSE_DATA SenseData);
	VOID ReadLBA(HANDLE hDevice, ULONG LBA, USHORT Sectors);

public:
    HRESULT Initialize();
    HRESULT Render();
    HRESULT FrameMove();

    CXBoxSample();
};

//-----------------------------------------------------------------------------
// Name: main()
// Desc: Entry point to the program.
//-----------------------------------------------------------------------------
VOID __cdecl main()
{
    CXBoxSample xbApp;
    if( FAILED( xbApp.Create() ) )
        return;
    xbApp.Run();
}

//-----------------------------------------------------------------------------
// Name: CXBoxSample()
// Desc: Constructor
//-----------------------------------------------------------------------------
CXBoxSample::CXBoxSample():CXBApplication()
{
	m_pMainMenu = NULL;

    m_d3dpp.MultiSampleType = D3DMULTISAMPLE_2_SAMPLES;
    m_d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
	m_d3dpp.BackBufferFormat = D3DFMT_X8R8G8B8;
	m_d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
}

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initialize all dependencies and states
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Initialize()
{
	HRESULT             hr;

	// Clear options
	g_Options.DisplayCounter = FALSE;
	g_Options.ResetCounter = FALSE;
	m_TextDisplayed = FALSE;

	// Font
    if( FAILED( hr = m_Font.Create( m_pd3dDevice, "Font.xpr" ) ) )
        return XBAPPERR_MEDIANOTFOUND;

    m_Font.GetTextExtent( L"M", &m_fFontWidth, &m_fFontHeight, TRUE );

	// Disable antialiasing by default
    m_pd3dDevice->SetRenderState(D3DRS_MULTISAMPLEANTIALIAS, FALSE);

    // Display initial wait screen
	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
	m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
    m_pd3dDevice->Present(NULL, NULL, NULL, NULL);

	// Menu
    XMenu_SetFont(&m_Font);

    m_pMainMenu = XMenu_Init(320.0f, 100.0f, 2, MENU_NOBACK, NULL);
    m_pMainMenu->topcolor = 0xffffffff;
    m_pMainMenu->bottomcolor = 0xffffffff;
    m_pMainMenu->itemcolor = 0xff000000;
    m_pMainMenu->seltopcolor = 0xffcedfad;
    m_pMainMenu->selbotcolor = 0xff84b642;

	XMenu_SetTitle(m_pMainMenu, L"DVD Seek Jump Counter", 0xff000000);

    XMenu_AddItem(m_pMainMenu, MITEM_ROUTINE, L"Display", SetDisplayJumpCounter);  
	XMenu_AddItem(m_pMainMenu, MITEM_ROUTINE, L"Reset", SetResetJumpCounter);  

	XMenu_Activate(m_pMainMenu);

	return S_OK;
}

//-----------------------------------------------------------------------------
// Name: FrameMove()
// Desc: Called once per frame, the call is the entry point for animating
//       the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::FrameMove()
{

	// Process options
	if(g_Options.DisplayCounter) 
	{
		DisplayJumpCounter();
	} 
	else if(g_Options.ResetCounter)
	{
		ResetJumpCounter();
	}

	// Check for 'Back' button press
	if(m_DefaultGamepad.wPressedButtons&XINPUT_GAMEPAD_BACK)
	{
		OutputDebugStringA("Back Button Press\n");
		g_Options.DisplayCounter = FALSE;
		g_Options.ResetCounter = FALSE;
		m_TextDisplayed = FALSE;
		m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
		m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
		m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
		m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
		XMenu_Activate(m_pMainMenu);
	}

    if(XMenu_IsActive())
	{
		m_dwMenuCommand = XMenu_GetCommand(&m_DefaultGamepad);
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Render()
// Desc: Called once per frame, the call is the entry point for 3d
//       rendering. This function sets up render states, clears the
//       viewport, and renders the scene.
//-----------------------------------------------------------------------------
HRESULT CXBoxSample::Render()
{
	if(XMenu_IsActive())
	{
		XMenu_Routine(m_dwMenuCommand); 
	} else 
	{
		// m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
	}

	return S_OK;
}


//-----------------------------------------------------------------------------
// Name: DisplayJumpCounter
// Desc: Load output strings with contents of DVD Seek Jump Counter
//-----------------------------------------------------------------------------
VOID CXBoxSample::DisplayJumpCounter()
{
	char cText[64];

	BOOL bReturn, bSuccess = TRUE;

	HANDLE hDevice;
    DWORD cbBytesReturned;
	SENSE_DATA SenseData;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
	UCHAR Counter[8];
	ULONG i;
	
	if(!m_TextDisplayed)
	{
		// Open DVD device
		hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, NULL);
		if(hDevice == INVALID_HANDLE_VALUE) 
		{
			OutputDebugStringA("DisplayJumpCounter: CreateFile FAILED\n");
			bSuccess = FALSE;
		}

		// Do some jumps
		/*
		ULONG LBA = 0;
		for(i = 0; i < 5; i++)
		{
			ReadLBA(hDevice, LBA, 1);

			// Toggle LBA
			if(LBA == 0)
			{
				LBA = 333109;
			}
			else
			{
				LBA = 0;
			}
		}
		*/


		// Get counter from DVD
		ZeroMemory(Counter, sizeof(Counter));
		ZeroMemory(&PassThrough, sizeof(PassThrough));
		PassThrough.Length = sizeof(PassThrough);
		PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
		PassThrough.DataBuffer = Counter;
		PassThrough.DataTransferLength = sizeof(Counter);
		// PassThrough.CdbLength = 12;
		PassThrough.Cdb[0] =0x25;
		PassThrough.Cdb[1] =0xFF;

		ZeroMemory(&SenseData, sizeof(SenseData));
		cbBytesReturned = 0;

		bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
									&PassThrough, sizeof(PassThrough), 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) 
		{
			if(!bReturn)
			{
				OutputDebugStringA("DisplayJumpCounter: DeviceIoControl returned FALSE\n");
				wsprintfA(cText, "DisplayJumpCounter: LastError = %i\n", GetLastError());
				OutputDebugStringA(cText);
			}

			if(cbBytesReturned > 0)
			{
				OutputDebugStringA("DisplayJumpCounter: DeviceIoControl cbBytesReturned not 0\n");
				LogSenseData(SenseData);
			}
			bSuccess = FALSE;

		}

		CloseHandle(hDevice);

		// Load Display text
		if(bSuccess)
		{
			wsprintfW(m_szDisplayLine1, L"Seek Jump Counter = 0x%.2x%.2x%.2x%.2x\n",
				Counter[0], Counter[1], Counter[2], Counter[3]);

			for(i = 0; i < 8; i++)
			{
				wsprintfA(cText, "Counter[%d] = %#x\n", i, Counter[i]);
				OutputDebugStringA(cText);
			}
		}
		else
		{
			wsprintfW(m_szDisplayLine1, L"Display Seek Jump Counter FAILED");
		}
		wsprintfW(m_szDisplayLine2, L"Press 'Back' button to continue");
		DisplayOutputStrings();		
		m_TextDisplayed = TRUE;
	}
}


//-----------------------------------------------------------------------------
// Name: ResetJumpCounter
// Desc: Reset DVD Seek Jump Counter
//-----------------------------------------------------------------------------
VOID CXBoxSample::ResetJumpCounter()
{
	char cText[64];

	BOOL bReturn, bSuccess = TRUE;

	HANDLE hDevice;
    DWORD cbBytesReturned;
	SENSE_DATA SenseData;
    SCSI_PASS_THROUGH_DIRECT PassThrough;
    
	if(!m_TextDisplayed)
	{
		// Reset DVD counter
		hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, NULL);
		if(hDevice == INVALID_HANDLE_VALUE) 
		{
			OutputDebugStringA("ResetJumpCounter: CreateFile FAILED\n");
			bSuccess = FALSE;
		}

		ZeroMemory(&PassThrough, sizeof(PassThrough));
		PassThrough.Length = sizeof(PassThrough);
		PassThrough.DataIn = SCSI_IOCTL_DATA_OUT;
		PassThrough.DataBuffer = NULL;
		PassThrough.DataTransferLength = 0;
		PassThrough.CdbLength = 12;
		PassThrough.Cdb[0] =0x1B;
		PassThrough.Cdb[4] =0xFF;

		ZeroMemory(&SenseData, sizeof(SenseData));
		cbBytesReturned = 0;

		bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
									&PassThrough, sizeof(PassThrough), 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) 
		{
			if(!bReturn)
			{
				OutputDebugStringA("ResetJumpCounter: DeviceIoControl returned FALSE\n");
				wsprintfA(cText, "ResetJumpCounter: LastError = %i\n", GetLastError());
				OutputDebugStringA(cText);
			}

			if(cbBytesReturned > 0)
			{
				OutputDebugStringA("ResetJumpCounter: DeviceIoControl cbBytesReturned not 0\n");
				LogSenseData(SenseData);
			}
			bSuccess = FALSE;

		}

		CloseHandle(hDevice);

		// Load Display text
		if(bSuccess)
		{
			wsprintfW(m_szDisplayLine1, L"Seek Jump Counter Reset");
		}
		else
		{
			wsprintfW(m_szDisplayLine1, L"Seek Jump Counter Reset FAILED");
		}
		wsprintfW(m_szDisplayLine2, L"Press 'Back' button to continue");
		DisplayOutputStrings();
		m_TextDisplayed = TRUE;
	}
}

//-----------------------------------------------------------------------------
// Name: DisplayOutputStrings
// Desc: Display output strings
//-----------------------------------------------------------------------------
VOID CXBoxSample::DisplayOutputStrings()
{
	OutputDebugStringA("DisplayOutputStrings\n");
	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
	m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
	m_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL , 0x00000000, 0.0f, 0L);
	m_Font.Begin();
	m_Font.DrawText(50.0, 50.0, 0xffffffff, m_szDisplayLine1);
	m_Font.DrawText(50.0, (float)(50 + m_Font.m_dwFontHeight), 0xffffffff, m_szDisplayLine2);
	m_Font.End();
	m_pd3dDevice->Present(NULL, NULL, NULL, NULL);
}

VOID CXBoxSample::LogSenseData(SENSE_DATA SenseData)
{
	char cText[64];

	// Log SenseData

	wsprintfA(cText, "SenseData ErrorCode:  0x%.2x\n", SenseData.ErrorCode);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Valid:  0x%.2x\n", SenseData.Valid);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData SegmentNumber:  0x%.2x\n", SenseData.SegmentNumber);
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData SenseKey:  0x%.2x\n", SenseData.SenseKey);
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Reserved:  0x%.2x\n", SenseData.Reserved);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData IncorrectLength:  0x%.2x\n", SenseData.IncorrectLength);
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Reserved:  0x%.2x\n", SenseData.Reserved);
	OutputDebugStringA(cText);
	
    wsprintfA(cText, "SenseData IncorrectLength:  0x%.2x\n", SenseData.IncorrectLength);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData EndOfMedia:  0x%.2x\n", SenseData.EndOfMedia);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData FileMark:  0x%.2x\n", SenseData.FileMark);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData Information[0]:  0x%.2x\n", SenseData.Information[0]);
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Information[1]:  0x%.2x\n", SenseData.Information[1]);
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Information[2]:  0x%.2x\n", SenseData.Information[2]);
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData Information[3]:  0x%.2x\n", SenseData.Information[3]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData AdditionalSenseLength:  0x%.2x\n", SenseData.AdditionalSenseLength);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData CommandSpecificInformation[0]:  0x%.2x\n", SenseData.CommandSpecificInformation[0]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData CommandSpecificInformation[1]:  0x%.2x\n", SenseData.CommandSpecificInformation[1]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData CommandSpecificInformation[2]:  0x%.2x\n", SenseData.CommandSpecificInformation[2]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData CommandSpecificInformation[3]:  0x%.2x\n", SenseData.CommandSpecificInformation[3]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData AdditionalSenseCode:  0x%.2x\n", SenseData.AdditionalSenseCode);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData AdditionalSenseCodeQualifier:  0x%.2x\n", SenseData.AdditionalSenseCodeQualifier);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData FieldReplaceableUnitCode:  0x%.2x\n", SenseData.FieldReplaceableUnitCode);	
	OutputDebugStringA(cText);

    wsprintfA(cText, "SenseData SenseKeySpecific[0]:  0x%.2x\n", SenseData.SenseKeySpecific[0]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData SenseKeySpecific[1]:  0x%.2x\n", SenseData.SenseKeySpecific[1]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData SenseKeySpecific[2]:  0x%.2x\n", SenseData.SenseKeySpecific[2]);	
	OutputDebugStringA(cText);

	wsprintfA(cText, "SenseData SenseKeySpecific[3]:  0x%.2x\n", SenseData.SenseKeySpecific[3]);	
	OutputDebugStringA(cText);
}


VOID CXBoxSample::ReadLBA(HANDLE hDevice, ULONG LBA, USHORT Sectors) {
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	BOOL bReturn;
	UCHAR Buf[2048];
	char cText[64];


    RtlZeroMemory(&PassThrough, sizeof(PassThrough));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = Buf;
    PassThrough.DataTransferLength = sizeof(Buf);

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.LogicalBlock = IdexConstantUlongByteSwap(LBA);
	Cdb->CDB10.TransferBlocks = IdexConstantUshortByteSwap(Sectors);

    bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	if((!bReturn) || (cbBytesReturned > 0)) 
	{
		if(!bReturn)
		{
			OutputDebugStringA("ReadLBA: DeviceIoControl returned FALSE\n");
			wsprintfA(cText, "ReadLBA: LastError = %i\n", GetLastError());
			OutputDebugStringA(cText);
		}

		if(cbBytesReturned > 0)
		{
			OutputDebugStringA("ReadLBA: DeviceIoControl cbBytesReturned not 0\n");
			LogSenseData(SenseData);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbutil.cpp ===
//-----------------------------------------------------------------------------
// File: XBUtil.cpp
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//       02.19.00 - Changes for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <xgraphics.h>
#include <tchar.h> 
#include <stdio.h> 
#include "XBUtil.h"




//-----------------------------------------------------------------------------
// Path to the XBox media files on the target machine
//-----------------------------------------------------------------------------
CHAR g_strMediaPath[512] = "D:\\Media\\";




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath()
// Desc: Sets the path to media files
//-----------------------------------------------------------------------------
VOID XBUtil_SetMediaPath( const CHAR* strPath )
{
    strcpy( g_strMediaPath, strPath );
}

    
    
    
//-----------------------------------------------------------------------------
// Name: XBUtil_FindMediaFile()
// Desc: Returns a valid path to a media file.
//-----------------------------------------------------------------------------
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename )
{
    // Check for valid arguments
    if( NULL==strFilename || NULL==strPath )
    {
        OutputDebugStringA( "XBUtil_FindMediaFile(): Invalid arguments\n" );
        return E_INVALIDARG;
    }

    // Default path is the filename itself as a fully qualified path
    strcpy( strPath, strFilename );

    // Check for the ':' character to see if the filename is a fully
    // qualified path. If not, prepend the media directory
    if( strFilename[1] != ':' )
        sprintf( strPath, "%s%s", g_strMediaPath, strFilename );

    // Try to open the file
    HANDLE hFile = CreateFile( strPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
                               OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
    {
        // Return error
        CHAR strBuffer[80];
        sprintf( strBuffer, "XBUtil_FindMediaFile(): Could not find file [%s]\n", 
                            strFilename );
        OutputDebugStringA( strBuffer );
        return 0x82000004;
    }

    // Found the file. Close the file and return
    CloseHandle( hFile );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer opertations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
FLOAT XBUtil_Timer( TIMER_COMMAND command )
{
    static BOOL  m_bTimerInitialized = FALSE;
    static FLOAT m_fSecsPerTick = 0.0f;
    static FLOAT m_fBaseTime    = 0.0f;
    static FLOAT m_fStopTime    = 0.0f;
    FLOAT        fTime;

    // Initialize the timer
    if( FALSE == m_bTimerInitialized )
    {
        m_bTimerInitialized = TRUE;

        // Use QueryPerformanceFrequency() to get frequency of timer.
        LARGE_INTEGER qwTicksPerSec;
        QueryPerformanceFrequency( &qwTicksPerSec );
        m_fSecsPerTick = 1.0f / (FLOAT)qwTicksPerSec.QuadPart;
    }

    // Get the current time using QueryPerformanceCounter() or timeGetTime()
    LARGE_INTEGER qwTime;
    QueryPerformanceCounter( &qwTime );
    fTime = ((FLOAT)qwTime.QuadPart) * m_fSecsPerTick;

    // Reset the timer
    if( command == TIMER_RESET )
    {
        m_fBaseTime = fTime;
        return 0.0f;
    }

    // Return the current time
    if( command == TIMER_GETAPPTIME )
        return fTime - m_fBaseTime;

    // Start the timer
    if( command == TIMER_START )
        m_fBaseTime += fTime - m_fStopTime;

    // Stop the timer
    if( command == TIMER_STOP )
        m_fStopTime = fTime;

    // Advance the timer by 1/10th second
    if( command == TIMER_ADVANCE )
        m_fBaseTime += fTime - ( m_fStopTime + 0.1f );

    // Retract the timer by 1/10th second
    if( command == TIMER_RETRACT )
        m_fBaseTime += fTime - ( m_fStopTime - 0.1f );

    return fTime;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r, FLOAT g, FLOAT b,
                          FLOAT a )
{
    ZeroMemory( &mtrl, sizeof(D3DMATERIAL8) );
    mtrl.Diffuse.r = mtrl.Ambient.r = r;
    mtrl.Diffuse.g = mtrl.Ambient.g = g;
    mtrl.Diffuse.b = mtrl.Ambient.b = b;
    mtrl.Diffuse.a = mtrl.Ambient.a = a;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x, FLOAT y, FLOAT z )
{
    ZeroMemory( &light, sizeof(D3DLIGHT8) );
    light.Type         = ltType;
    light.Diffuse.r    = 1.0f;
    light.Diffuse.g    = 1.0f;
    light.Diffuse.b    = 1.0f;
    light.Position     = D3DXVECTOR3(x,y,z);

    light.Position.x   = x;
    light.Position.y   = y;
    light.Position.z   = z;
    D3DXVECTOR3 vSource(x,y,z);
    D3DXVec3Normalize( (D3DXVECTOR3*)&light.Direction, &vSource );
    light.Range        = 1000.0f;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture, D3DFORMAT d3dFormat )
{
    HRESULT hr;

    // Find the media file
    CHAR strTexturePath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strTexturePath, strTexture ) ) )
        return hr;

    // Create the texture using D3DX. Check the current directory
    return D3DXCreateTextureFromFileEx( pd3dDevice, strTexturePath, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, D3DX_DEFAULT, 
                                        0, d3dFormat, D3DPOOL_DEFAULT, 
                                        D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, 
                                        ppTexture );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture2D()
// Desc: Unswizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleRect( pSrcBits, pDesc->Width, pDesc->Height, NULL, pLock->pBits, 
                     0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture3D()
// Desc: Unswizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGUnswizzleBox( pSrcBits, pDesc->Width, pDesc->Height, pDesc->Depth, NULL, pLock->pBits,
                    0, 0, NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture2D()
// Desc: Swizzles a 2D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleRect( pSrcBits, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_SwizzleTexture3D()
// Desc: Swizzles a 3D texture before it gets unlocked. Note: this operation
//       can be very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc )
{
    DWORD dwPixelSize   = XGBytesPerPixelFromFormat( pDesc->Format );
    DWORD dwTextureSize = pDesc->Width * pDesc->Height * pDesc->Depth * dwPixelSize;

    BYTE* pSrcBits = new BYTE[ dwTextureSize ];
    memcpy( pSrcBits, pLock->pBits, dwTextureSize );
    
    XGSwizzleBox( pSrcBits, 0, 0, NULL, pLock->pBits,
                  pDesc->Width, pDesc->Height, pDesc->Depth, 
                  NULL, dwPixelSize );

    SAFE_DELETE_ARRAY( pSrcBits );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename,
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the vertex shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory to read the vertex shader file
    DWORD dwSize = GetFileSize( hFile, NULL );
    BYTE* pData  = new BYTE[dwSize+4];
    if( NULL == pData )
        return E_FAIL;
    ZeroMemory( pData, dwSize+4 );

    // Read the pre-compiled vertex shader microcode
    DWORD dwBytesRead;
    ReadFile( hFile, pData, dwSize, &dwBytesRead, NULL );

    // Create the vertex shader
    hr = pd3dDevice->CreateVertexShader( pdwVertexDecl, (const DWORD*)pData,
                                         pdwVertexShader, 0 );

    // Cleanup and return
    CloseHandle( hFile );
    delete [] pData;
    return hr;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader )
{
    HRESULT hr;

    // Find the media file
    CHAR strShaderPath[512];
    if( FAILED( hr = XBUtil_FindMediaFile( strShaderPath, strFilename ) ) )
        return hr;

    // Open the pixel shader file
    HANDLE hFile = CreateFile( strShaderPath, GENERIC_READ, FILE_SHARE_READ, 
                               NULL, OPEN_EXISTING, 0, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Load the pre-compiled pixel shader microcode
    D3DPIXELSHADERDEF_FILE psdf;
    DWORD                  dwBytesRead;
    ReadFile( hFile, &psdf, sizeof(D3DPIXELSHADERDEF_FILE), &dwBytesRead, NULL );
    CloseHandle( hFile );

    // Make sure the pixel shader is valid
    if( dwBytesRead != sizeof(D3DPIXELSHADERDEF_FILE) || 
        psdf.FileID != D3DPIXELSHADERDEF_FILE_ID )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Invalid pixel shader file\n") );
        return E_FAIL;
    }

    // Create the pixel shader
    if( FAILED( hr = pd3dDevice->CreatePixelShader( &(psdf.Psd), pdwPixelShader ) ) )
    {
        OutputDebugString( _T("XBUtil_CreatePixelShader(): Could not create pixel shader\n") );
        return hr;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace )
{
    D3DXVECTOR3 vEyePt   = D3DXVECTOR3( 0.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
    D3DXVECTOR3 vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );

    switch( dwFace )
    {
        case D3DCUBEMAP_FACE_POSITIVE_X:
            vLookDir = D3DXVECTOR3( 1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_X:
            vLookDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Y:
            vLookDir = D3DXVECTOR3( 0.0f,-1.0f, 0.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            break;
        case D3DCUBEMAP_FACE_POSITIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f, 1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
        case D3DCUBEMAP_FACE_NEGATIVE_Z:
            vLookDir = D3DXVECTOR3( 0.0f, 0.0f,-1.0f );
            vUpDir   = D3DXVECTOR3( 0.0f, 1.0f, 0.0f );
            break;
    }

    // Set the view transform for this cubemap surface
    D3DXMATRIX matView;
    D3DXMatrixLookAtLH( &matView, &vEyePt, &vLookDir, &vUpDir );
    return matView;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap )
{
    HRESULT hr;

    // Create the cube map
    if( FAILED( hr = pd3dDevice->CreateCubeTexture( dwSize, 1, 0, D3DFMT_X8R8G8B8, 
                                                    D3DPOOL_DEFAULT, ppCubeMap ) ) )
        return E_FAIL;
    
    // Allocate temp space for swizzling the cubemap surfaces
    DWORD* pSourceBits = new DWORD[ dwSize * dwSize ];

    // Fill all six sides of the cubemap
    for( DWORD i=0; i<6; i++ )
    {
        // Lock the i'th cubemap surface
        LPDIRECT3DSURFACE8 pCubeMapFace;
        (*ppCubeMap)->GetCubeMapSurface( (D3DCUBEMAP_FACES)i, 0, &pCubeMapFace );

        // Write the RGBA-encoded normals to the surface pixels
        DWORD*      pPixel = pSourceBits;
        D3DXVECTOR3 n;
        FLOAT       w, h;

        for( DWORD y = 0; y < dwSize; y++ )
        {
            h  = (FLOAT)y / (FLOAT)(dwSize-1);  // 0 to 1
            h  = ( h * 2.0f ) - 1.0f;           // -1 to 1
            
            for( DWORD x = 0; x < dwSize; x++ )
            {
                w = (FLOAT)x / (FLOAT)(dwSize-1);   // 0 to 1
                w = ( w * 2.0f ) - 1.0f;            // -1 to 1

                // Calc the normal for this texel
                switch( i )
                {
                    case D3DCUBEMAP_FACE_POSITIVE_X:    // +x
                        n.x = +1.0;
                        n.y = -h;
                        n.z = -w;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_X:    // -x
                        n.x = -1.0;
                        n.y = -h;
                        n.z = +w;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Y:    // y
                        n.x = +w;
                        n.y = +1.0;
                        n.z = +h;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Y:    // -y
                        n.x = +w;
                        n.y = -1.0;
                        n.z = -h;
                        break;
                        
                    case D3DCUBEMAP_FACE_POSITIVE_Z:    // +z
                        n.x = +w;
                        n.y = -h;
                        n.z = +1.0;
                        break;
                        
                    case D3DCUBEMAP_FACE_NEGATIVE_Z:    // -z
                        n.x = -w;
                        n.y = -h;
                        n.z = -1.0;
                        break;
                }

                // Store the normal as an RGBA color
                D3DXVec3Normalize( &n, &n );
                *pPixel++ = XBUtil_VectorToRGBA( &n );
            }
        }
        
        // Swizzle the result into the cubemap face surface
        D3DLOCKED_RECT lock;
        pCubeMapFace->LockRect( &lock, 0, 0L );
        XGSwizzleRect( pSourceBits, 0, NULL, lock.pBits, dwSize, dwSize,
                       NULL, sizeof(DWORD) );
        pCubeMapFace->UnlockRect();

        // Release the cubemap face
        pCubeMapFace->Release();
    }

    // Free temp space
    SAFE_DELETE_ARRAY( pSourceBits );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName )
{
    // Get the surface description. Make sure it's a 32-bit format
    D3DSURFACE_DESC desc;
    pSurface->GetDesc( &desc );
    if( desc.Size != ( desc.Width * desc.Height * sizeof(DWORD) ) )
        return E_NOTIMPL;

    // Lock the surface
    D3DLOCKED_RECT lock;
    if( FAILED( pSurface->LockRect( &lock, 0, 0 ) ) )
        return E_FAIL;

    // Allocate memory for storing the surface bits
    VOID* pBits = (VOID*)new DWORD[desc.Width*desc.Height];

    // Unswizzle the bits, if necessary
    if( XGIsSwizzledFormat( desc.Format ) )
        XGUnswizzleRect( lock.pBits, desc.Width, desc.Height, NULL,
                         pBits, lock.Pitch, NULL, sizeof(DWORD) );
    else
        memcpy( pBits, lock.pBits, desc.Size );
    
    // Unlock the surface
    pSurface->UnlockRect();

    // Setup the TGA file header
    struct TargaHeader
    {
        BYTE IDLength;
        BYTE ColormapType;
        BYTE ImageType;
        BYTE ColormapSpecification[5];
        WORD XOrigin;
        WORD YOrigin;
        WORD ImageWidth;
        WORD ImageHeight;
        BYTE PixelDepth;
        BYTE ImageDescriptor;
    } tgaHeader;

    ZeroMemory( &tgaHeader, sizeof(tgaHeader) );
    tgaHeader.IDLength        = 0;
    tgaHeader.ImageType       = 2;
    tgaHeader.ImageWidth      = (WORD)desc.Width;
    tgaHeader.ImageHeight     = (WORD)desc.Height;
    tgaHeader.PixelDepth      = 32;
    tgaHeader.ImageDescriptor = 0x28;

    // Create a new file
    FILE* file = fopen( strFileName, "wb" );
    if( NULL == file )
    {
        pSurface->UnlockRect();
        return E_FAIL;
    }

    // Write the Targa header and the surface pixels to the file
    fwrite( &tgaHeader, sizeof(TargaHeader), 1, file );
    fwrite( pBits, sizeof(BYTE), desc.Size, file );
    fclose( file );

    // Cleanup and return
    delete[] pBits;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u )
{
    // Generate coeffecients from the two end points and two tangents
    D3DXVECTOR3 a =  2*p0 - 2*p1 +   v0 + v1; // a = 2p0 - 2p1 +  v0 + v1
    D3DXVECTOR3 b = -3*p0 + 3*p1 - 2*v0 - v1; // b =-3p0 + 3p1 - 2v0 + v1
    D3DXVECTOR3 c =                  v0;      // c = v0  
    D3DXVECTOR3 d =    p0;                    // d = p0

    // Evaluate the equation at u, where:
    //    f(u) = au^3 + bu^2 + cu + d
    return ( ( a * u + b ) * u + c ) * u + d;
}




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u )
{
    // Generate coeffecients from four spline points
    D3DXVECTOR3 a =   -p1 + 3*p2 - 3*p3 + p4;
    D3DXVECTOR3 b =  2*p1 - 5*p2 + 4*p3 - p4;
    D3DXVECTOR3 c =   -p1        +   p3;
    D3DXVECTOR3 d =         2*p2;

    // Evaluate the equation at u, where:
    //    f(u) = 0.5 * ( au^3 + bu^2 + cu + d )
    return 0.5f * ( ( ( a * u + b ) * u + c ) * u + d );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts,
                            FLOAT t, D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent )
{
    DWORD p0 = ( t > 1.0 ) ? (DWORD)floorf(t)-1 : dwNumSpinePts-1;
    DWORD p1 = ( p0 < dwNumSpinePts-1 ) ? p0 + 1 : 0;
    DWORD p2 = ( p1 < dwNumSpinePts-1 ) ? p1 + 1 : 0;
    DWORD p3 = ( p2 < dwNumSpinePts-1 ) ? p2 + 1 : 0;
    FLOAT u  = t - floorf(t);

    if( pvPoint )
        (*pvPoint) = XBUtil_EvaluateCatmullRom( pSpline[p0], pSpline[p1], 
                                                pSpline[p2], pSpline[p3], u );

    if( pvTangent )
        (*pvTangent) = 0.5f * ( (1-u) * ( pSpline[p2] - pSpline[p0] ) + 
                                  (u) * ( pSpline[p3] - pSpline[p1] ) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes )
{
    pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );
    pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TFACTOR );
    pd3dDevice->SetVertexShader( D3DFVF_XYZ );

    for( FLOAT u = 0; u < dwNumSplinePts; u += 1.0f )
    {
        D3DXVECTOR3 p[2];
        D3DXVECTOR3 vTangent, vSide, vUp;

        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+0, &p[0], &vTangent );
        XBUtil_GetSplinePoint( pSpline, dwNumSplinePts, u+1, &p[1], NULL );

        D3DXVec3Normalize( &vTangent, &vTangent );
        D3DXVECTOR3 v1( 0, 1, 0 );
        D3DXVec3Cross( &vSide, &v1, &vTangent );
        D3DXVec3Cross( &vUp, &vTangent, &vSide );

        pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, dwColor );
        pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

        if( bRenderAxes )
        {
            p[1] = p[0] + vTangent/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffff0000 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vSide/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xff00ff00 );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );

            p[1] = p[0] + vUp/4;
            pd3dDevice->SetRenderState( D3DRS_TEXTUREFACTOR, 0xffffffff );
            pd3dDevice->DrawPrimitiveUP( D3DPT_LINELIST, 1, p, sizeof(D3DXVECTOR3) );
        }
    }
}




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0     = Vertex position
//          v1     = Vertex blend weights
//          v2     = Vertex normal
//          v3     = Vertex diffuse color
//          v4     = Vertex specular color
//       // v5     = Vertex fog (no FVF code)
//       // v6     = Vertex pointsize (no FVF code)
//       // v7     = Vertex back diffuse color (no FVF code)
//       // v8     = Vertex back specular color (no FVF code)
//          v9-v12 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
                                  DWORD Declaration[MAX_FVF_DECL_SIZE] )
{
    // Start the declaration
    DWORD decl = 0;
    Declaration[decl++] = D3DVSD_STREAM(0);

    // Handle position
    DWORD dwPositionFVF = ( dwFVF & D3DFVF_POSITION_MASK );
    if( dwPositionFVF == D3DFVF_XYZRHW ) Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT4 ); 
    else                                 Declaration[decl++] = D3DVSD_REG( 0, D3DVSDT_FLOAT3 ); 

    // Handle blend weights
    if( dwPositionFVF == D3DFVF_XYZB1 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT1 ); 
    if( dwPositionFVF == D3DFVF_XYZB2 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT2 ); 
    if( dwPositionFVF == D3DFVF_XYZB3 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT3 ); 
    if( dwPositionFVF == D3DFVF_XYZB4 )  Declaration[decl++] = D3DVSD_REG( 1, D3DVSDT_FLOAT4 ); 

    // Handle normal, diffuse, and specular
    if( dwFVF & D3DFVF_NORMAL )          Declaration[decl++] = D3DVSD_REG( 2, D3DVSDT_FLOAT3 );
    if( dwFVF & D3DFVF_DIFFUSE )         Declaration[decl++] = D3DVSD_REG( 3, D3DVSDT_D3DCOLOR );
    if( dwFVF & D3DFVF_SPECULAR )        Declaration[decl++] = D3DVSD_REG( 4, D3DVSDT_D3DCOLOR );

    // Handle texture coordinates
    DWORD dwNumTextures = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    for( DWORD i=0; i<dwNumTextures; i++ )
    {
        DWORD dwNumTexCoords = 0;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE1(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE1(i) )
            dwNumTexCoords = D3DVSDT_FLOAT1;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE2(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE2(i) )
            dwNumTexCoords = D3DVSDT_FLOAT2;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE3(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE3(i) )
            dwNumTexCoords = D3DVSDT_FLOAT3;
        if( ( dwFVF & D3DFVF_TEXCOORDSIZE4(i) ) == (DWORD)D3DFVF_TEXCOORDSIZE4(i) )
            dwNumTexCoords = D3DVSDT_FLOAT4;

        Declaration[decl++] = D3DVSD_REG( 9 + i, dwNumTexCoords );
    }

    // End the declarator
    Declaration[decl++] = D3DVSD_END();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbutil.h ===
//-----------------------------------------------------------------------------
// File: XBUtil.h
//
// Desc: Shortcut macros and helper functions for the XBox samples
//
// Hist: 11.01.00 - New for November XDK release
//       12.01.00 - Moved input code to XBInput.cpp
//       12.15.00 - Changes for December XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef XBUTIL_H
#define XBUTIL_H

#include <tchar.h>




//-----------------------------------------------------------------------------
// Miscellaneous helper functions
//-----------------------------------------------------------------------------

// For deleting and releasing objects
#define SAFE_DELETE(p)       { delete (p);     (p)=NULL; }
#define SAFE_DELETE_ARRAY(p) { delete[] (p);   (p)=NULL; }
#define SAFE_RELEASE(p)      { if(p) { (p)->Release(); (p)=NULL; } }

// For converting a FLOAT to a DWORD (useful for SetRenderState() calls)
inline DWORD FtoDW( FLOAT f ) { return *((DWORD*)&f); }




//-----------------------------------------------------------------------------
// Name: XBUtil_SetMediaPath() and XBUtil_FindMediaFile()
// Desc: Functions for setting a media path and returning a valid path to a
//       media file.
//-----------------------------------------------------------------------------
VOID    XBUtil_SetMediaPath( const CHAR* strPath );
HRESULT XBUtil_FindMediaFile( CHAR* strPath, const CHAR* strFilename );




//-----------------------------------------------------------------------------
// Name: XBUtil_Timer()
// Desc: Performs timer operations. Use the following commands:
//          TIMER_RESET           - to reset the timer
//          TIMER_START           - to start the timer
//          TIMER_STOP            - to stop (or pause) the timer
//          TIMER_ADVANCE         - to advance the timer by 0.1 seconds
//          TIMER_RETRACT         - to retract the timer by 0.1 seconds
//          TIMER_GETABSOLUTETIME - to get the absolute system time
//          TIMER_GETAPPTIME      - to get the current time
//-----------------------------------------------------------------------------
enum TIMER_COMMAND { TIMER_RESET, TIMER_START, TIMER_STOP, 
                     TIMER_ADVANCE, TIMER_RETRACT, 
                     TIMER_GETABSOLUTETIME, TIMER_GETAPPTIME };
FLOAT XBUtil_Timer( TIMER_COMMAND command );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitMaterial()
// Desc: Initializes a D3DMATERIAL8 structure, setting the diffuse and ambient
//       colors. It does not set emissive or specular colors.
//-----------------------------------------------------------------------------
VOID XBUtil_InitMaterial( D3DMATERIAL8& mtrl, FLOAT r=0.0f, FLOAT g=0.0f,
                                              FLOAT b=0.0f, FLOAT a=1.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_InitLight()
// Desc: Initializes a D3DLIGHT structure, setting the light position. The
//       diffuse color is set to white, specular and ambient left as black.
//-----------------------------------------------------------------------------
VOID XBUtil_InitLight( D3DLIGHT8& light, D3DLIGHTTYPE ltType,
                       FLOAT x=0.0f, FLOAT y=0.0f, FLOAT z=0.0f );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateTexture()
// Desc: Helper function to create a texture.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateTexture( LPDIRECT3DDEVICE8 pd3dDevice, const CHAR* strTexture,
                              LPDIRECT3DTEXTURE8* ppTexture,
                              D3DFORMAT d3dFormat = D3DFMT_UNKNOWN );




//-----------------------------------------------------------------------------
// Name: XBUtil_UnswizzleTexture() / XBUtil_SwizzleTexture()
// Desc: Unswizzles / swizzles a texture before it gets unlocked. Note: this
//       operation is typically very slow.
//-----------------------------------------------------------------------------
VOID XBUtil_UnswizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_UnswizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );
VOID XBUtil_SwizzleTexture2D( D3DLOCKED_RECT* pLock, const D3DSURFACE_DESC* pDesc );
VOID XBUtil_SwizzleTexture3D( D3DLOCKED_BOX* pLock, const D3DVOLUME_DESC* pDesc );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateVertexShader()
// Desc: Creates a file-based vertex shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateVertexShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                   const CHAR* strFilename, 
                                   const DWORD* pdwVertexDecl,
                                   DWORD* pdwVertexShader );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreatePixelShader()
// Desc: Creates a file-based pixel shader
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreatePixelShader( LPDIRECT3DDEVICE8 pd3dDevice, 
                                  const CHAR* strFilename, DWORD* pdwPixelShader );

                                    
                                    
                                    
//-----------------------------------------------------------------------------
// Name: XBUtil_VectorToRGBA()
// Desc: Converts a normal into an RGBA vector.
//-----------------------------------------------------------------------------
inline D3DCOLOR XBUtil_VectorToRGBA( const D3DXVECTOR3* v, FLOAT fHeight = 1.0f )
{
    D3DCOLOR r = (D3DCOLOR)( ( v->x + 1.0f ) * 127.5f );
    D3DCOLOR g = (D3DCOLOR)( ( v->y + 1.0f ) * 127.5f );
    D3DCOLOR b = (D3DCOLOR)( ( v->z + 1.0f ) * 127.5f );
    D3DCOLOR a = (D3DCOLOR)( 255.0f * fHeight );
    return( (a<<24L) + (r<<16L) + (g<<8L) + (b<<0L) );
}




//-----------------------------------------------------------------------------
// Name: XBUtil_GetCubeMapViewMatrix()
// Desc: Returns a view matrix for rendering to a face of a cubemap.
//-----------------------------------------------------------------------------
D3DXMATRIX XBUtil_GetCubeMapViewMatrix( DWORD dwFace );




//-----------------------------------------------------------------------------
// Name: XBUtil_CreateNormalizationCubeMap()
// Desc: Creates a cubemap and fills it with normalized RGBA vectors.
//-----------------------------------------------------------------------------
HRESULT XBUtil_CreateNormalizationCubeMap( LPDIRECT3DDEVICE8 pd3dDevice, 
                                           DWORD dwSize, 
                                           LPDIRECT3DCUBETEXTURE8* ppCubeMap );




//-----------------------------------------------------------------------------
// Name: XBUtil_DumpSurface()
// Desc: Writes the contents of a surface (32-bit only) to a .tga file. This
//       could be a backbuffer, texture, or any other 32-bit surface.
//-----------------------------------------------------------------------------
HRESULT XBUtil_DumpSurface( LPDIRECT3DSURFACE8 pSurface, const CHAR* strFileName );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateHermite()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Hermite curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateHermite( const D3DXVECTOR3& p0, const D3DXVECTOR3& p1, 
                                    const D3DXVECTOR3& v0, const D3DXVECTOR3& v1,
                                    FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_EvaluateCatmullRom()
// Desc: Evaluate a cubic parametric equation. Returns the point at u on a
//       Catmull-Rom curve.
//-----------------------------------------------------------------------------
D3DXVECTOR3 XBUtil_EvaluateCatmullRom( const D3DXVECTOR3& p1, const D3DXVECTOR3& p2, 
                                       const D3DXVECTOR3& p3, const D3DXVECTOR3& p4,
                                       FLOAT u );




//-----------------------------------------------------------------------------
// Name: XBUtil_GetSplinePoint()
// Desc: Returns a point on a spline. The spline is defined by an array of
//       points, and the point and tangent returned are located at position t
//       on the spline, where 0 < t < dwNumSpinePts.
//-----------------------------------------------------------------------------
VOID XBUtil_GetSplinePoint( const D3DXVECTOR3* pSpline, DWORD dwNumSpinePts, FLOAT t, 
                            D3DXVECTOR3* pvPoint, D3DXVECTOR3* pvTangent );




//-----------------------------------------------------------------------------
// Name: XBUtil_RenderSpline()
// Desc: For debugging purposes, visually renders a spline.
//-----------------------------------------------------------------------------
VOID XBUtil_RenderSpline( LPDIRECT3DDEVICE8 pd3dDevice, const D3DXVECTOR3* pSpline, 
                          DWORD dwNumSplinePts, DWORD dwColor, BOOL bRenderAxes );




//-----------------------------------------------------------------------------
// Name: XBUtil_DeclaratorFromFVF()
// Desc: Create a vertex declaration from an FVF. Registers are assigned as
//       follows:
//          v0    = Vertex position
//          v1    = Vertex blend weights
//          v2    = Vertex normal
//          v3    = Vertex pointsize
//          v4    = Vertex diffuse color
//          v5    = Vertex specular color
//          v6-v9 = Vertex texture coords
//-----------------------------------------------------------------------------
HRESULT XBUtil_DeclaratorFromFVF( DWORD dwFVF, 
								  DWORD Declaration[MAX_FVF_DECL_SIZE] );

#endif // XBUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdperf\dvdperf.cpp ===
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define AT_STANDBY_IMMEDIATE	0xE0
#define AT_IDLE_IMMEDIATE		0xE1


// Globals
HANDLE gLogHandle;
DISK_GEOMETRY gDiskGeometry;
LARGE_INTEGER gFrequency;
UCHAR *gcBuf;


VOID
LogSenseData(SENSE_DATA SenseData) {
	// Log SenseData
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData ErrorCode:  0x%.2x", SenseData.ErrorCode);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Valid:  0x%.2x", SenseData.Valid);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SegmentNumber:  0x%.2x", SenseData.SegmentNumber);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKey:  0x%.2x", SenseData.SenseKey);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Reserved:  0x%.2x", SenseData.Reserved);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData IncorrectLength:  0x%.2x", SenseData.IncorrectLength);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData EndOfMedia:  0x%.2x", SenseData.EndOfMedia);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData FileMark:  0x%.2x", SenseData.FileMark);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[0]:  0x%.2x", SenseData.Information[0]);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[1]:  0x%.2x", SenseData.Information[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[2]:  0x%.2x", SenseData.Information[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData Information[3]:  0x%.2x", SenseData.Information[3]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseLength:  0x%.2x", SenseData.AdditionalSenseLength);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[0]:  0x%.2x", SenseData.CommandSpecificInformation[0]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[1]:  0x%.2x", SenseData.CommandSpecificInformation[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[2]:  0x%.2x", SenseData.CommandSpecificInformation[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData CommandSpecificInformation[3]:  0x%.2x", SenseData.CommandSpecificInformation[3]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseCode:  0x%.2x", SenseData.AdditionalSenseCode);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData AdditionalSenseCodeQualifier:  0x%.2x", SenseData.AdditionalSenseCodeQualifier);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData FieldReplaceableUnitCode:  0x%.2x", SenseData.FieldReplaceableUnitCode);	
    xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[0]:  0x%.2x", SenseData.SenseKeySpecific[0]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[1]:  0x%.2x", SenseData.SenseKeySpecific[1]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[2]:  0x%.2x", SenseData.SenseKeySpecific[2]);	
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SenseData SenseKeySpecific[3]:  0x%.2x", SenseData.SenseKeySpecific[3]);	
}


VOID
LogAtaPassThrough(ATA_PASS_THROUGH AtaPassThrough) {
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bFeaturesReg = %#x", AtaPassThrough.IdeReg.bFeaturesReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorCountReg = %#x", AtaPassThrough.IdeReg.bSectorCountReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorNumberReg = %#x", AtaPassThrough.IdeReg.bSectorNumberReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylLowReg = %#x", AtaPassThrough.IdeReg.bCylLowReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylHighReg = %#x", AtaPassThrough.IdeReg.bCylHighReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bDriveHeadReg = %#x", AtaPassThrough.IdeReg.bDriveHeadReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCommandReg = %#x", AtaPassThrough.IdeReg.bCommandReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bHostSendsData = %#x", AtaPassThrough.IdeReg.bHostSendsData);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.DataBufferSize = %#x", AtaPassThrough.DataBufferSize);
}


LARGE_INTEGER
ReadLBA(HANDLE hDevice, ULONG LBA, USHORT Sectors) {
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	LARGE_INTEGER StartTime, EndTime, ReturnValue;
	BOOL bReturn;

    RtlZeroMemory(&PassThrough, sizeof(PassThrough));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
    PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
    PassThrough.DataBuffer = gcBuf;
    PassThrough.DataTransferLength = Sectors*gDiskGeometry.BytesPerSector;

	Cdb = (PCDB)&PassThrough.Cdb;
    Cdb->CDB10.OperationCode = SCSIOP_READ;
	Cdb->CDB10.ForceUnitAccess = 1;
	Cdb->CDB10.LogicalBlock = RtlUlongByteSwap(LBA);
	Cdb->CDB10.TransferBlocks = RtlUshortByteSwap(Sectors);

	// Start timer
	QueryPerformanceCounter(&StartTime);

    bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	// Stop timer
	QueryPerformanceCounter(&EndTime);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, Sectors = %u, LastError = %d", LBA, Sectors, GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_READ FAILED LBA = %u, cbBytesReturned > 0", LBA);
			LogSenseData(SenseData);
		}
		ReturnValue.QuadPart = -1;
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SCSIOP_READ LBA = %u, Sectors = %u, %f ms", LBA, Sectors, 1000.0*(EndTime.QuadPart - StartTime.QuadPart)/gFrequency.QuadPart);
		ReturnValue.QuadPart = EndTime.QuadPart - StartTime.QuadPart;
	}
	return ReturnValue;
}


LARGE_INTEGER
SeekLBA(HANDLE hDevice, ULONG LBA) {
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	BOOL bReturn;
	LARGE_INTEGER StartTime, EndTime, ReturnValue;

	RtlZeroMemory(&PassThrough, sizeof(PassThrough));

    PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);

	Cdb = (PCDB)&PassThrough.Cdb;
	Cdb->SEEK.OperationCode = SCSIOP_SEEK;
	*((PULONG)Cdb->SEEK.LogicalBlockAddress) = RtlUlongByteSwap(LBA);

	// Start timer
	QueryPerformanceCounter(&StartTime);

	bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
								&PassThrough, sizeof(PassThrough), 
								&SenseData, sizeof(SenseData),
								&cbBytesReturned, NULL);

	// Stop timer
	QueryPerformanceCounter(&EndTime);

	if((!bReturn) || (cbBytesReturned > 0)) {
		if(!bReturn) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_SEEK FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SCSIOP_SEEK FAILED cbBytesReturned > 0");
			LogSenseData(SenseData);
		}

		ReturnValue.QuadPart = -1;
 	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SCSIOP_SEEK LBA = %u, %f ms",
		//	LBA, 1000.0*(EndTime.QuadPart - StartTime.QuadPart)/gFrequency.QuadPart);
		ReturnValue.QuadPart = EndTime.QuadPart - StartTime.QuadPart;
	}
	return ReturnValue;
}


DOUBLE
AccessTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG LBA;

	// Initialize
	TotalTime.QuadPart = 0;
	ReturnVal = 1.0/(DOUBLE)Reps;

	// Goto End
	ReturnTime = ReadLBA(hDevice, End,1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	LBA = Start;
	while(Reps > 0) {
		// Access the LBA
		ReturnTime = ReadLBA(hDevice, LBA, 1);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
		}

		// Swap LBA between Start and End
		if(LBA == Start) {
			LBA = End;
		} else {
			LBA = Start;
		}
		Reps--;
	}

	// return average access time in ms (already initialized to 1/Reps)
	ReturnVal *= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (DOUBLE)gFrequency.QuadPart;
	ReturnVal *= 1000.0;	// convert to ms
	return ReturnVal;
}


DOUBLE
StreamTime(HANDLE hDevice, ULONG Start, ULONG End, USHORT MaxSectors) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG i, Reps;
	USHORT RemainSectors;

	// Init Totaltime
	TotalTime.QuadPart = 0;

	// Compute Reps based on Sectors and 64 sector limit per read
	Reps = (End - Start)/MaxSectors;
	RemainSectors = (USHORT)((End - Start)%MaxSectors);

	// Goto Start
	ReturnTime = ReadLBA(hDevice, Start, 1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	for(i=0; i<Reps; i++) {
		ReturnTime = ReadLBA(hDevice, i*MaxSectors + Start, MaxSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	if(RemainSectors > 0) {
		ReturnTime = ReadLBA(hDevice, Reps*MaxSectors + Start, RemainSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	// return elapsed time in mbits/s
	ReturnVal = (DOUBLE)(End - Start);
	ReturnVal *= (DOUBLE)gDiskGeometry.BytesPerSector;
	ReturnVal *= (DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= 131072.0;	// convert to mbits
	return ReturnVal;
}


//
// SetPowerMode
//		Send AT command to drive
//
BOOL
SetPowerMode(HANDLE hDevice, UCHAR Command) {
	ATA_PASS_THROUGH	AtaPassThrough;
	DWORD cbBytesReturned;
	BOOL bReturn;

	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = Command;
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBuffer = NULL;

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		LogAtaPassThrough(AtaPassThrough);
		return FALSE;
	} else {
		return TRUE;
	}
}


DOUBLE
StartUpTime(HANDLE hDevice, UCHAR Command, ULONG Reps) {
	LARGE_INTEGER StartTime, EndTime, ReturnTime, TotalTime;
	ULONG i;
	DOUBLE ReturnVal;
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	SENSE_DATA SenseData;
	DWORD cbBytesReturned;
	PCDB Cdb;
	BOOL bReturn;

	// Goto read location
	ReturnTime = ReadLBA(hDevice, 1, 1);

	TotalTime.QuadPart = 0;

	for(i = 0; i < Reps; i++) {
		// Put drive in Standby mode
		if(!SetPowerMode(hDevice, Command)) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode(%#x) FAILED", Command);
			return 0;
		}
	
		// Wait for drive to spin down
		Sleep(6000);

		// Set up pass through to read
	    RtlZeroMemory(&PassThrough, sizeof(PassThrough));
		PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
		PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
		PassThrough.DataBuffer = gcBuf;
		PassThrough.DataTransferLength = 1*gDiskGeometry.BytesPerSector;
		Cdb = (PCDB)&PassThrough.Cdb;
		Cdb->CDB10.OperationCode = SCSIOP_READ;
		Cdb->CDB10.ForceUnitAccess = 1;
		Cdb->CDB10.LogicalBlock = RtlUlongByteSwap(1);
		Cdb->CDB10.TransferBlocks = RtlUshortByteSwap(1);

		// Start timer
		QueryPerformanceCounter(&StartTime);
		
		// Read from drive until successful
		do {
			bReturn = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
										&PassThrough, sizeof(PassThrough), 
										&SenseData, sizeof(SenseData),
										&cbBytesReturned, NULL);
		} while(bReturn == FALSE);

		// Stop timer
		QueryPerformanceCounter(&EndTime);

		TotalTime.QuadPart += (EndTime.QuadPart - StartTime.QuadPart);
	}

	// Return average Startup time
	ReturnVal = (DOUBLE)TotalTime.QuadPart/(DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)Reps;
	return ReturnVal;
}


VOID
WINAPI
DVDPerfStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	BOOL bReturn, bDoAuth;
    DWORD cbBytesReturned;
	SENSE_DATA SenseData;
	DOUBLE dTime;
	ULONG RestartReps;
	ULONG ThirdStartLBA, ThirdEndLBA, ThirdReps;
	ULONG FullStartLBA, FullEndLBA, FullReps;
	ULONG StreamStartLBA, StreamEndLBA;
	USHORT MaxSectors;

	// Set global log handle
	gLogHandle = LogHandle;

	// Get timer frequency (ticks/sec)
	QueryPerformanceFrequency(&gFrequency);

    xSetOwnerAlias(gLogHandle, "a-emebac");
	xSetComponent(gLogHandle, "Hardware", "DVDPerf");
	xSetFunctionName(gLogHandle, "StartTest");

	// open device
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
							FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,NULL);

	if(hDevice == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CreateFile FAILED LastError = %d", GetLastError());
		return;
	}

	// Get authentication parameter from ini
	bDoAuth = (BOOL)GetProfileInt(TEXT("dvdperf"), TEXT("DoAuth"), 0);
	// Authenticate a Xbox DVD 
	// If the media is not a Xbox DVD, then don't care if this fails
	if(bDoAuth) {
		bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_AUTHENTICATION_SEQUENCE, 
									NULL, 0, 
									&SenseData, sizeof(SenseData),
									&cbBytesReturned, NULL);

		if((!bReturn) || (cbBytesReturned > 0)) {
			if(!bReturn) {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE FAILED LastError = %d", GetLastError());
			}

			if(cbBytesReturned > 0) {
				xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE cbBytesReturned > 0");
				LogSenseData(SenseData);
			}
		} else {
			xLog(gbConsoleOut, gLogHandle, XLL_PASS, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE Succeeded");
		}
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "IOCTL_CDROM_AUTHENTICATION_SEQUENCE Not performed");
	}
	
	// get geometry
	bReturn = DeviceIoControl(hDevice, IOCTL_CDROM_GET_DRIVE_GEOMETRY, 
								NULL, 0, 
								&gDiskGeometry, sizeof(gDiskGeometry), 
								&cbBytesReturned, 
								NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_CDROM_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
		CloseHandle(hDevice);
		return;
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %08x:%08x", gDiskGeometry.Cylinders.HighPart, gDiskGeometry.Cylinders.LowPart);
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.LowPart);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.QuadPart);
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MediaType = %s", gDiskGeometry.MediaType);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "TracksPerCylinder = %u", gDiskGeometry.TracksPerCylinder);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u", gDiskGeometry.SectorsPerTrack);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "BytesPerSector = %u", gDiskGeometry.BytesPerSector);
	}
	
	// allocate gcBuf
	gcBuf = (UCHAR *)VirtualAlloc(NULL, 64*gDiskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
	if(gcBuf == NULL) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "VirtualAlloc (%u bytes) FAILED LastError = %d", 
				64*gDiskGeometry.BytesPerSector, GetLastError());
		CloseHandle(hDevice);
		return;
	}

	// Get parameters from ini file
	RestartReps = GetProfileInt(TEXT("dvdperf"), TEXT("RestartReps"), 10);
	ThirdStartLBA = GetProfileInt(TEXT("dvdperf"), TEXT("ThirdStartLBA"), 0);
	ThirdEndLBA = GetProfileInt(TEXT("dvdperf"), TEXT("ThirdEndLBA"), (ULONG)gDiskGeometry.Cylinders.QuadPart/3);
	ThirdReps = GetProfileInt(TEXT("dvdperf"), TEXT("ThirdReps"), 200);
	FullStartLBA = GetProfileInt(TEXT("dvdperf"), TEXT("FullStartLBA"), 0);
	FullEndLBA = GetProfileInt(TEXT("dvdperf"), TEXT("FullEndLBA"), (ULONG)gDiskGeometry.Cylinders.QuadPart - 1);
	FullReps = GetProfileInt(TEXT("dvdperf"), TEXT("FullReps"), 200);
	StreamStartLBA = GetProfileInt(TEXT("dvdperf"), TEXT("StreamStartLBA"), 0);
	StreamEndLBA = GetProfileInt(TEXT("dvdperf"), TEXT("StreamEndLBA"), (ULONG)gDiskGeometry.Cylinders.QuadPart/4);

	// Average Recovery Time from Standby
	xSetFunctionName(gLogHandle, "StandbyTime");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Average Recovery Time from Standby: Reps = %u", RestartReps);
	dTime = StartUpTime(hDevice, AT_STANDBY_IMMEDIATE, RestartReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Recovery Time from Standby = %f s", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Recovery Time from Standby FAILED");
	}

	// Average Recovery Time from Idle
	xSetFunctionName(gLogHandle, "IdleTime");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Average Recovery Time from Idle: Reps = %u", RestartReps);
	dTime = StartUpTime(hDevice, AT_IDLE_IMMEDIATE, RestartReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Recovery Time from Idle = %f s", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Recovery Time from Idle FAILED");
	}


	// Measure average 1/3 stroke access times
	xSetFunctionName(gLogHandle, "Average (First 1/3 stroke)");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, Reps = %u", ThirdStartLBA, ThirdEndLBA, ThirdReps);
	
	dTime = AccessTime(hDevice, ThirdStartLBA, ThirdEndLBA, ThirdReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Access Time (1/3 Stroke) = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Access Time (1/3 Stroke) FAILED");
	}

	// Measure full-stroke access time
	xSetFunctionName(gLogHandle, "Full-Stroke");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, Reps = %u", FullStartLBA, FullEndLBA, FullReps);
	
	dTime = AccessTime(hDevice, FullStartLBA, FullEndLBA, FullReps);
	
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Full-Stroke Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Full-Stroke Access Time FAILED");
	}

	//
	// Measure data stream rate
	xSetFunctionName(gLogHandle, "Sustained Data Rate");
	for(USHORT i = 0; i <=6; i++) {
		MaxSectors = 1<<i;
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Start LBA = %u, End LBA = %u, MaxSectors = %u", StreamStartLBA, StreamEndLBA, MaxSectors);
	
		dTime = StreamTime(hDevice, StreamStartLBA, StreamEndLBA, MaxSectors);
	
		if(dTime > 0) {
			xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Sustained Data Rate = %f Mbits/s", dTime);
		} else {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Sustained Data Rate FAILED");
		}
	}

	// free gcBuf
	xSetFunctionName(gLogHandle, "EndTest");
	if(!VirtualFree(gcBuf, 0, MEM_RELEASE)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "VirtualFree FAILED LastError = %d", GetLastError());
	}

	// close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CloseHandle FAILED LastError = %d", GetLastError());
	}
}


VOID WINAPI
DVDPerfEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\dvdperf.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("DVDPerf: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("DVDPerf: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }
	
	gbConsoleOut = TRUE;

	// Copy ini to t:\\ if not already there

	// Start Test
	DVDPerfStartTest(LogHandle);

	// End Test
	DVDPerfEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("DVDPerf: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// xlog
	xCloseLog(LogHandle);
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dvdperf )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dvdperf )
    EXPORT_TABLE_ENTRY( "StartTest", DVDPerfStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DVDPerfEndTest )
END_EXPORT_TABLE( dvdperf )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdservopage\dvdservopage.cpp ===
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <devioctl.h>
#include <scsi.h>
#include <ntddscsi.h>

// Macros to swap the byte order of a USHORT or ULONG at compile time.
#define IdexConstantUshortByteSwap(ushort) \
    ((((USHORT)ushort) >> 8) + ((((USHORT)ushort) & 0x00FF) << 8))

#define IdexConstantUlongByteSwap(ulong) \
    ((((ULONG)ulong) >> 24) + ((((ULONG)ulong) & 0x00FF0000) >> 8) + \
    ((((ULONG)ulong) & 0x0000FF00) << 8) + ((((ULONG)ulong) & 0x000000FF) << 24))


#define SERVO_PAGE_LENGTH 0x30

VOID
DVDServoPageLogSenseData(HANDLE LogHandle, SENSE_DATA SenseData) {
	// Log SenseData
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData ErrorCode:  0x%.2x", SenseData.ErrorCode);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Valid:  0x%.2x", SenseData.Valid);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SegmentNumber:  0x%.2x", SenseData.SegmentNumber);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKey:  0x%.2x", SenseData.SenseKey);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Reserved:  0x%.2x", SenseData.Reserved);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData IncorrectLength:  0x%.2x", SenseData.IncorrectLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData EndOfMedia:  0x%.2x", SenseData.EndOfMedia);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FileMark:  0x%.2x", SenseData.FileMark);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[0]:  0x%.2x", SenseData.Information[0]);
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[1]:  0x%.2x", SenseData.Information[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[2]:  0x%.2x", SenseData.Information[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData Information[3]:  0x%.2x", SenseData.Information[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseLength:  0x%.2x", SenseData.AdditionalSenseLength);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[0]:  0x%.2x", SenseData.CommandSpecificInformation[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[1]:  0x%.2x", SenseData.CommandSpecificInformation[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[2]:  0x%.2x", SenseData.CommandSpecificInformation[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData CommandSpecificInformation[3]:  0x%.2x", SenseData.CommandSpecificInformation[3]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCode:  0x%.2x", SenseData.AdditionalSenseCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData AdditionalSenseCodeQualifier:  0x%.2x", SenseData.AdditionalSenseCodeQualifier);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData FieldReplaceableUnitCode:  0x%.2x", SenseData.FieldReplaceableUnitCode);	
    xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[0]:  0x%.2x", SenseData.SenseKeySpecific[0]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[1]:  0x%.2x", SenseData.SenseKeySpecific[1]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[2]:  0x%.2x", SenseData.SenseKeySpecific[2]);	
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "SenseData SenseKeySpecific[3]:  0x%.2x", SenseData.SenseKeySpecific[3]);	
}

VOID
DVDServoPageStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	UCHAR ServoPage[SERVO_PAGE_LENGTH];
	SENSE_DATA SenseData;
	SCSI_PASS_THROUGH_DIRECT PassThrough;
	PCDB Cdb = (PCDB)&PassThrough.Cdb;
	BOOL bRet;
	DWORD cbBytesReturned, i;

	// Open DVD device
	// xSetFunctionName(LogHandle, "Open DVD Device");
	hDevice = CreateFile("cdrom0:",	GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING, NULL);

	if(hDevice == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile FAILED LastError = %d", GetLastError());
		return;
	}

	ZeroMemory(ServoPage, sizeof(ServoPage));
	ZeroMemory(&SenseData, sizeof(SENSE_DATA));
	ZeroMemory(&PassThrough, sizeof(SCSI_PASS_THROUGH_DIRECT));

	PassThrough.Length = sizeof(SCSI_PASS_THROUGH_DIRECT);
	PassThrough.DataIn = SCSI_IOCTL_DATA_IN;
	PassThrough.DataBuffer = ServoPage;
	PassThrough.DataTransferLength = sizeof(ServoPage);
	Cdb->MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
	Cdb->MODE_SENSE10.Dbd = 1;
	Cdb->MODE_SENSE10.PageCode = 0x25;
	*((PUSHORT)&Cdb->MODE_SENSE10.AllocationLength) =
		(USHORT)IdexConstantUshortByteSwap(sizeof(ServoPage));

	bRet = DeviceIoControl(hDevice, IOCTL_SCSI_PASS_THROUGH_DIRECT,
							&PassThrough, sizeof(PassThrough), 
							&SenseData, sizeof(SenseData),
							&cbBytesReturned, NULL);

	if((!bRet) || (cbBytesReturned > 0)) {
		if(!bRet) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED LastError = %d", GetLastError());
		}

		if(cbBytesReturned > 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SCSIOP_MODE_SENSE10 FAILED cbBytesReturned > 0");
			DVDServoPageLogSenseData(LogHandle, SenseData);
		}
	}

	for(i = 0; i < SERVO_PAGE_LENGTH; i++) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Servo Page Byte[%u] = 0x%.2x", i, ServoPage[i]);
	}

		// Close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
			"CloseHande(DVD Device) Error Code = %u", GetLastError());
	}
}

VOID
DVDServoPageEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\dvdservopage.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGDEFAULT,
                            XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("DVDServoPage: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("DVDServoPage: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }
	
	gbConsoleOut = TRUE;

	// Start Test
	DVDServoPageStartTest(LogHandle);

	// End Test
	DVDServoPageEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("DVDServoPage: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dvdservopage )
#pragma data_seg()

BEGIN_EXPORT_TABLE( dvdservopage )
    EXPORT_TABLE_ENTRY( "StartTest", DVDServoPageStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DVDServoPageEndTest )
END_EXPORT_TABLE( dvdservopage )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdsoftreset\dvdsoftreset.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dvdsoftreset.cpp

Abstract:

    test app that repeatedly sends an ATA device reset command
	to the dvd.

--*/


#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>
#include <fscache.h>



// SMC Functions

extern "C"
    {
    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalReadSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN ReadWordValue,
        OUT ULONG *DataValue
        );

    DECLSPEC_IMPORT
    LONG
    WINAPI
    HalWriteSMBusValue(
        IN UCHAR SlaveAddress,
        IN UCHAR CommandCode,
        IN BOOLEAN WriteWordValue,
        IN ULONG DataValue
        );
    }

DWORD WriteSMC(unsigned char addr, unsigned char value)
    {
    return HalWriteSMBusValue(0x20, addr, FALSE, value);
    }

DWORD ReadSMC(unsigned char addr)
    {
    DWORD value = 0xCCCCCCCC;
    HalReadSMBusValue(0x21, addr, FALSE, &value);
    return value;
    }




// performs a soft reset on the dvd
//

BOOL
DVDSoftReset(HANDLE hDevice, UCHAR Command) {

 WCHAR buff[256];
 ATA_PASS_THROUGH AtaPassThrough;
 DWORD cbBytesReturned;
 BOOL bReturn;
 memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
 AtaPassThrough.IdeReg.bCommandReg = Command;
 AtaPassThrough.IdeReg.bDriveHeadReg = 0xb0;      // Device 0
 AtaPassThrough.DataBuffer = NULL;
 bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &AtaPassThrough, sizeof(ATA_PASS_THROUGH),
        &cbBytesReturned, NULL);
 if(!bReturn) {
  //xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode FAILED StatusReg=%#x ErrorReg=%#x LastError = %d",
   //AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
  //HDPerf_LogAtaPassThrough(AtaPassThrough);

  wsprintf( buff, L"\nReset error: Last Error: %d\n\n", GetLastError() );
  OutputDebugString ( buff );
  return FALSE;
 } else {
  return TRUE;
 }
}



void DebugPrint(LPWSTR format, ...)
    {
    va_list args;
    va_start(args, format);

    WCHAR szBuffer[1024];

    wsprintf(szBuffer, format, args);
    OutputDebugString(szBuffer);

    va_end(args);
    }






void __cdecl main()
{
	OBJECT_STRING objname;		// object name
	OBJECT_ATTRIBUTES oa;		// obj attributes
	IO_STATUS_BLOCK iosb;		// IO status block
	NTSTATUS status;			// status
	HANDLE hDevice;				// handle to the dvd
	HANDLE hLog;				// handle to the log file
	HANDLE hSearch;				// handle to a file search
	DWORD dwSMCTrayState;		// smc tray state
	WIN32_FIND_DATA fd;			// find find data
	DWORD dwResets = 0;				// counter

	BYTE buff[256];
	DWORD bytenum = 256;
	HANDLE hInFile;

	
	//DebugBreak();



	// initialize the log
	hLog = xCreateLog( L"t:\\DVDSoftReset.log", NULL, INVALID_SOCKET, XLL_LOGALL, XLO_DEBUG );
	if( INVALID_HANDLE_VALUE == hLog )
	{
		DebugPrint( L"\nCould not open log file\n" );
		DebugBreak();
	}
	xSetOwnerAlias( hLog, "sethmil" );
	xSetComponent( hLog, "DVD", "Soft Reset" );
	xSetFunctionName( hLog, "Soft Reset Stress" );
	xStartVariation( hLog, "DVD Soft Reset" );


	
	


	// test algorithm
	//    1.  Mount the drive
	//    2.  Send soft reset
	//    3.  Check media detect
	//    4.  Create cdrom:\\ file
	//    5.  Search for default.xbe in the DVD root directory
	//    6.  Read default.xbe from the drive
	//    Repeat.
	//
	while( true )
	{
		dwResets++;

		// mount the DVD device
		//
		RtlInitObjectString(&objname, OTEXT("\\Device\\cdrom0"));
		InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
		status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
		
		// send soft reset to the DVD
		//
		DVDSoftReset( hDevice, 0x08 );
		DebugPrint(L"Reset the dvd\n");
		Sleep( 1000 );


		// flush the file system cache
		FscInvalidateIdleBlocks();
		


		// make sure we have media detect
		//
		dwSMCTrayState = (ReadSMC( 0x03 ) >> 4) & 0x0F ;
		if( dwSMCTrayState != 0x6 )
		{
			xLog( hLog, XLL_FAIL, "No Media Detect" );
		}



		// open the DVDROM device
		//
		hDevice = CreateFile("cdrom0:",	GENERIC_READ, 0, NULL, OPEN_EXISTING, 
								FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,NULL);
		if( hDevice == INVALID_HANDLE_VALUE )
		{
			DebugPrint( L"Could not open DVD after reset \n" );
			xLog( hLog, XLL_FAIL, "Could not open DVD after reset");
		}


		// search for 'default.xbe' in the root directory
		//
		hSearch = FindFirstFile( "cdrom0:\\default.xbe", &fd );
		if( INVALID_HANDLE_VALUE == hSearch )
		{
			// fail
			xLog( hLog, XLL_FAIL, "Could not find cdrom:\\default.xbe" );
		}
		


		// open default.xbe and read it 
		// from the DVD
		//
		hInFile = CreateFile( "cdrom0:\\default.xbe", 
								GENERIC_READ,
								FILE_SHARE_READ,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL );
		if( INVALID_HANDLE_VALUE == hInFile )
		{
			//fail
			xLog( hLog, XLL_FAIL, "Could not open file cdrom:\\default.xbe" );
		}

		// read the file
		bytenum = 256;
		while( bytenum == 256 ){
			if( !ReadFile( hInFile, buff, 256, &bytenum, NULL ) )
			{
				//fail
				xLog( hLog, XLL_FAIL, "Error reading default.xbe from DVD" );
				DebugPrint(L" \n\nHalt for failure\n\n");
				DebugBreak();
				break;
			}
		}

		
		// log # of reboots
		//
		xLog( hLog, XLL_INFO, "Reboot num: %d", dwResets );


		// close all the files
		CloseHandle( hSearch );
		CloseHandle( hInFile );
		CloseHandle( hDevice );

	}


	// never gets here
	// DebugPrint( L"\n\nend\n\n");
	Sleep( INFINITE );



}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xmenu.cpp ===
#include <xtl.h>
#include "assert.h"
#include "XBUtil.h"
#include "XBInput.h"
#include "xmenu.h"

extern LPDIRECT3DDEVICE8 g_pd3dDevice;

CXBFont *XMenu_Font = NULL;				// pointer to font
DWORD XMenu_FontLoaded = FALSE;			// font loaded flag
XMenu *XMenu_CurMenu = NULL;
int (*XMenu_CurRoutine)(DWORD cmd, XMenuItem *mi);			// called when item selected

void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor);

void XMenu_SetFont(CXBFont *font)
{
	XMenu_Font = font;
}

XMenu *XMenu_Init(float x, float y, DWORD maxitems, DWORD flags, DWORD (*abortroutine)(DWORD, XMenuItem *))
{
	XMenu *m;
	BYTE *mem;

	assert(XMenu_Font!=NULL);				// make sure font is set

	// allocate memory for menu
	mem = new BYTE[sizeof(XMenu) + maxitems*sizeof(XMenuItem)];
	memset(mem, 0, sizeof(XMenu) + maxitems*sizeof(XMenuItem));

	m = (XMenu *)mem;
	m->items = (XMenuItem *)(mem+sizeof(XMenu));
	m->flags = flags;
	m->topcolor = 0xff000000;
	m->bottomcolor = 0xff0000c0;
	m->seltopcolor = 0xff000000;
	m->selbotcolor = 0xffc00000;
	m->maxitems = maxitems;
	m->abortroutine = abortroutine;
	m->itemcolor = 0xffffffff;

	m->x = x;
	m->y = y;
	m->w = 100.0f;

	XMenu_SetMaxShow(m, m->maxitems);		// sets height

	return m;
}

void XMenu_Delete(XMenu *m)
{
	delete m;
}

void XMenu_SetMaxShow(XMenu *m, DWORD maxshow)
{
	m->maxshow = maxshow;
	m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

XMenuItem *XMenu_AddItem(XMenu *m, DWORD flags, WCHAR *string, void *action)
{
	XMenuItem *mi;

	assert(m->nitems<m->maxitems);		// make sure we dont overstep our allocation
	mi = &m->items[m->nitems];

	mi->flags = flags;
	mi->action = action;
	mi->val1 = 0;
	mi->val2 = 0;
	mi->menu = m;
	mi->color = m->itemcolor;
	XMenu_SetItemText(&m->items[m->nitems], string);

	m->nitems++;

	return &m->items[m->nitems-1];
}

void XMenu_DeleteItem(XMenuItem *mi)
{
	XMenu *m;
	DWORD i;
	
	// get pointer to the menu that owns this item
	m = mi->menu;

	// find the item to delete
	for(i=0; i<m->nitems; i++)
		if(&m->items[i]==mi)
		{
			// shift em down
			memcpy(&m->items[i], &m->items[i+1], (m->nitems-i-1)*sizeof(XMenuItem));
			m->nitems--;
			break;
		}
}

void XMenu_SetTitle(XMenu *m, WCHAR *string, DWORD color)
{
	float w, h;

	m->titlecolor = color;

	if(string)
	{
		// set string
		wcsncpy(m->title, string, MITEM_STRINGLEN-1);

		// calculate new menu width based on this item
		XMenu_Font->GetTextExtent(string, &w, &h);
		if(m->w<(w+16.0f))
			m->w = w+16.0f;
	
		m->h = ((float)m->maxshow+2.5f) * XMenu_Font->GetFontHeight();
	}
	else
		m->h = (float)(m->maxshow+1) * XMenu_Font->GetFontHeight();
}

void XMenu_SetItemText(XMenuItem *mi, WCHAR *string)
{
	float w, h;

	if(!string || (mi->flags&MITEM_SEPARATOR))
		return;

	// set string
	wcsncpy(mi->string, string, MITEM_STRINGLEN-1);

	// calculate new menu width based on this item
	XMenu_Font->GetTextExtent(string, &w, &h);
	if(mi->menu->w<(w+16.0f))
		mi->menu->w = w+16.0f;
}

DWORD XMenu_Activate(XMenu *m)
{
	XMenu_CurMenu = m;

	return 1;
}

DWORD XMenu_GetCommand(XBGAMEPAD *gamepad)
{
	DWORD command;

	command = 0;

	// get menu command
	if(XMenu_CurMenu || XMenu_CurRoutine)
	{
		if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_A] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
			command = MENU_SELECTITEM;
		else if(gamepad->bPressedAnalogButtons[XINPUT_GAMEPAD_B] ||
		   gamepad->wPressedButtons&XINPUT_GAMEPAD_BACK)
			command = MENU_BACK;
		else if(gamepad->fY1>0.25f)
			command = MENU_PREVITEM;
		else if(gamepad->fY1<-0.25f)
			command = MENU_NEXTITEM;
	}
	else if(gamepad->wPressedButtons&XINPUT_GAMEPAD_START)
		command = MENU_ACTIVATE;

	return command;
}

DWORD XMenu_Routine(DWORD command)
{
	float menux, menuy;
	float rectx, recty, rectw, recth;
	float itemy, itemh;
	DWORD i, color;
	static float menutime = 0.0f;
	float time;
	XMenu *m;
	XMenuItem *mi;
	DWORD firstitem, nitems;
	WCHAR ddd[16] = L"[--MORE--]";
	WCHAR *str;
	DWORD status;

	// check for menu routine first
	if(XMenu_CurRoutine)
	{
		status = XMenu_CurRoutine(command, NULL);
		if(status==MROUTINE_DIE)
			XMenu_CurRoutine = NULL;
		return 0;
	}

	// no routine so do menu processing
	m = XMenu_CurMenu;
	if(!m)
		return 0;

	// get height of font
	itemh = (float)XMenu_Font->GetFontHeight();

	// draw menu background
	rectx = m->x;
	recty = m->y - itemh/2.0f;
	rectw = m->w;
	recth = m->h;

	if(m->flags&(MENU_LEFT|MENU_RIGHT))
		DrawRect(rectx-8.0f, recty, rectw, recth, m->topcolor, m->bottomcolor);
	else
		DrawRect(rectx-(rectw/2.0f), recty, rectw, recth, m->topcolor, m->bottomcolor);

	menux = m->x;
	menuy = m->y;

	// determine which menu items to show (firstitem, nitems)
	if(m->nitems>m->maxshow)
	{
		if(m->curitem<(m->maxshow/2))
			firstitem = 0;
		else if(m->curitem<(m->nitems-(m->maxshow/2)))
			firstitem = m->curitem-(m->maxshow/2)+1;
		else
			firstitem = m->nitems-m->maxshow;
	}
	else
		firstitem = 0;

	if(m->nitems>m->maxshow)
		nitems = m->maxshow;
	else
		nitems = m->nitems;

	itemy = menuy;

	// draw the menu title
	if(m->title[0])
	{
		if(m->flags&MENU_LEFT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title);
		else if(m->flags&MENU_RIGHT)
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_RIGHT);
		else
			XMenu_Font->DrawText(menux, itemy, m->titlecolor, m->title, XBFONT_CENTER_X);
			
		itemy += 1.5f*itemh;
	}

	// draw the menu items
	for(i=firstitem; i<nitems+firstitem; i++)
	{
		mi = &m->items[i];

		if(!(mi->flags&MITEM_SEPARATOR))
		{
			// do menu scroll
			str = mi->string;
			if(m->nitems>m->maxshow)
			{
				if((i==firstitem) && (firstitem!=0))
					str = ddd;
				if((i==(firstitem+nitems-1)) && (firstitem!=(m->nitems-m->maxshow)))
					str = ddd;
			}

			// draw menu hilight bar
			if(i==m->curitem)
			{
				if(m->flags&(MENU_LEFT|MENU_RIGHT))
					DrawRect(rectx-8.0f, itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
				else
					DrawRect(rectx-(rectw/2.0f), itemy-2.0f, rectw, XMenu_Font->GetFontHeight()+4.0f, m->seltopcolor, m->selbotcolor);
			}

			// set item color
			if(mi->flags&MITEM_DISABLED)
				color = (mi->color&0xffffff) | 0x40000000;	// lower alpha
			else
				color = mi->color;
	
			// draw the menu text
			if(!(m->flags&(MENU_LEFT|MENU_RIGHT)))
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_CENTER_X);
			else if(m->flags&MENU_LEFT)
				XMenu_Font->DrawText(menux, itemy, color, str);
			else if(m->flags&MENU_RIGHT)
				XMenu_Font->DrawText(menux, itemy, color, str, XBFONT_RIGHT);
		}

		itemy += XMenu_Font->GetFontHeight();
	}

	time = XBUtil_Timer(TIMER_GETABSOLUTETIME);

	switch(command)
	{
		case MENU_NEXTITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do
			{
				m->curitem++;
				if(m->curitem==m->nitems)
					if(m->flags&MENU_WRAP)
						m->curitem = 0;
					else
						m->curitem = m->nitems-1;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));
			break;

		case MENU_PREVITEM:
			if((time-menutime)<0.2f)
				return 0;
			menutime = time;

			do 
			{
				m->curitem--;
				if(m->curitem==-1)
					if(m->flags&MENU_WRAP)
						m->curitem = m->nitems-1;
					else
						m->curitem = 0;
			} while(m->items[m->curitem].flags&(MITEM_SEPARATOR|MITEM_DISABLED));

			menutime = time;
			break;

		case MENU_SELECTITEM:
			mi = &m->items[m->curitem];

			if(mi->flags&MITEM_ROUTINE)
			{
				// do routine
				XMenu_CurRoutine = (int (*)(DWORD, XMenuItem *))mi->action;
				status = XMenu_CurRoutine(MROUTINE_INIT, mi);

				// check return value... 
				if(status==MROUTINE_DIE)
				{
					XMenu_Activate(NULL);			// kill the current menu
					XMenu_CurRoutine = NULL;		// and the routine
				}
				else if(status==MROUTINE_RETURN)	// just kill the routine
					XMenu_CurRoutine = NULL;
				else if(status==MROUTINE_SLEEP)
					XMenu_Activate(NULL);			// just kill current menu
			}
			else
			{	
				// activate next menu if it exists
				if(mi->action)
				{
					XMenu_Activate((XMenu *)mi->action);
					XMenu_CurMenu->parent = m;		// the menu that called me
				}
				else
				{
					if(m->abortroutine)
						m->abortroutine(MROUTINE_ABORT, NULL);

					XMenu_Activate(NULL);
				}
			}
			break;

		case MENU_BACK:
			if(!(m->flags&MENU_NOBACK))
			{
				if(m->abortroutine)						// call abort routine if it exists
					m->abortroutine(MROUTINE_ABORT, NULL);

				if(m->parent)							// activate parent menu if it exists
					XMenu_Activate(m->parent);
				else
					XMenu_Activate(NULL);
			}
			break;

		default:
			break;
	}

	return 1;
}

//-----------------------------------------------------------------------------
// Name: DrawRect
// Desc: Draws a gradient filled rectangle
//-----------------------------------------------------------------------------
void DrawRect(float x, float y, float w, float h, DWORD dwTopColor, DWORD dwBottomColor)
{
    static LPDIRECT3DVERTEXBUFFER8 XMenu_VB = NULL;
    struct BACKGROUNDVERTEX 
	{ 
		D3DXVECTOR4 p; 
		D3DCOLOR color; 
	} *v;

    if(XMenu_VB == NULL)
        g_pd3dDevice->CreateVertexBuffer(4*sizeof(BACKGROUNDVERTEX), D3DUSAGE_WRITEONLY, 
                                          0L, D3DPOOL_DEFAULT, &XMenu_VB);

    // Setup vertices for a background-covering quad
	XMenu_VB->Lock(0, 0, (BYTE **)&v, 0L);
    v[0].p = D3DXVECTOR4(x, y, 1.0f, 1.0f);
	v[0].color = dwTopColor;
    v[1].p = D3DXVECTOR4(x+w, y, 1.0f, 1.0f);
	v[1].color = dwTopColor;
    v[2].p = D3DXVECTOR4(x, y+h, 1.0f, 1.0f); 
	v[2].color = dwBottomColor;
    v[3].p = D3DXVECTOR4(x+w, y+h, 1.0f, 1.0f);
	v[3].color = dwBottomColor;
	XMenu_VB->Unlock();

	// set render states
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE); 
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, FALSE);

    // Set states
    g_pd3dDevice->SetTexture(0, NULL);
    g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_DISABLE);
    g_pd3dDevice->SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE);
    g_pd3dDevice->SetStreamSource(0, XMenu_VB, sizeof(BACKGROUNDVERTEX));

    // Render the quad
    g_pd3dDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);

	// restore render state
    g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE); 
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\dvdjumpcounter\xbfont.cpp ===
//-----------------------------------------------------------------------------
// File: XBFont.cpp
//
// Desc: Texture-based font class. This class reads .abc font files that are
//       generated by the FontMaker tool. These .abc files are used to create
//       a texture with all the font's glyph, and also extract information on
//       the dimensions of each glyph.
//
//       Once created, this class is used to render text in a 3D scene with the
//       following function:
//          DrawText( fScreenY, fScreenSpaceY, dwTextColor, strText,
//                    dwJustificationFlags );
//
//       For performance, you can batch mulitple DrawText calls together
//       between Begin() and End() calls, as in the following example:
//          pFont->Begin();
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->DrawText( ... );
//          pFont->End();
//
//       The size (extent) of the text can be computed without rendering with
//       the following function:
//          GetTextExtent( strText, pfReturnedWidth, pfReturnedHeight,
//                         bComputeExtentUsingFirstLineOnly );
//
//       Finally, the font class can create a texture to hold rendered text,
//       which is useful for static text that must be rendered for many
//       frames, or can even be used within a 3D scene. (For instance, for a
//       player's name on a jersey.) Use the following function for this:
//          CreateTexture( strText, d3dTextureFormat );
//
//       See the XDK docs for more information.
//
// Hist: 11.01.00 - New for November XDK release
//       12.15.00 - Changes for December XDK release
//       02.18.01 - Changes for March XDK release
//       04.15.01 - Using packed resources for May XDK
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <xtl.h>
#include <stdio.h>
#include "XBFont.h"




// Max size for the font class' vertex buffer
const DWORD XBFONT_MAX_VERTICES = 1024 * 4;

// Helper function to init a vertex
inline XBFONTVERTEX InitFontVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                    FLOAT tu, FLOAT tv )
{
    XBFONTVERTEX v;   
    v.p     = p;   
    v.color = color;   
    v.tu    = tu;   
    v.tv    = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CXBFont()
// Desc: Font class constructor.
//-----------------------------------------------------------------------------
CXBFont::CXBFont()
{
    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;

    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        m_pVBs[i] = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CXBFont()
// Desc: Font class destructor.
//-----------------------------------------------------------------------------
CXBFont::~CXBFont()
{
    Destroy();
}




//-----------------------------------------------------------------------------
// Name: Create()
// Desc: Create the font's internal objects (texture and array of glyph info)
//       using the image and information from two files.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Create( LPDIRECT3DDEVICE8 pd3dDevice, 
                         const CHAR* strFontResourceFileName )
{
    HRESULT hr;

    // Store the device for use in member functions
    m_pd3dDevice = pd3dDevice;

    if( FAILED( m_xprResource.Create( m_pd3dDevice, strFontResourceFileName, 
                                      2 ) ) )
        return E_FAIL;

    m_pTexture = m_xprResource.GetTexture( 0UL );

    BYTE* pData = (BYTE*)m_xprResource.GetData( XBResource_SizeOf(m_pTexture) );
    DWORD dwResourceType = ((DWORD*)pData)[0];
    DWORD dwResourceSize = ((DWORD*)pData)[1];
    pData += 2*sizeof(DWORD);

    DWORD dwVersion = ((DWORD*)pData)[0];
    m_dwFontHeight  = ((DWORD*)pData)[1];
    m_dwTexWidth    = ((DWORD*)pData)[2];
    m_dwTexHeight   = ((DWORD*)pData)[3];
    DWORD dwBPP     = ((DWORD*)pData)[4];
    pData += 5*sizeof(DWORD);

    // Check version of file (to make sure it matches up with the FontMaker tool)
    if( dwVersion != 0x00000004 )
    {
        OutputDebugStringA( "XBFont: Incorrect version number on font file!\n" );
        return E_FAIL;
    }

    // Read the low and high char
    m_cLowChar  = ((WCHAR*)pData)[0];
    m_cHighChar = ((WCHAR*)pData)[1];
    pData += 2*sizeof(WCHAR);

    // Read the glyph attributes from the file
    m_Glyphs = (GLYPH_ATTR*)(pData+4);

    // Create vertex buffer for rendering text strings
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
    {
        hr = pd3dDevice->CreateVertexBuffer( XBFONT_MAX_VERTICES*sizeof(XBFONTVERTEX),
                                             D3DUSAGE_WRITEONLY, 0L,
                                             D3DPOOL_DEFAULT, &m_pVBs[i] );
        if( FAILED(hr) )
            return hr;
    }

    // Assign a current vertex buffer
    m_dwCurrentBuffer = 0L;
    m_pVB = m_pVBs[m_dwCurrentBuffer];

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Destroy()
// Desc: Destroys the font object
//-----------------------------------------------------------------------------
HRESULT CXBFont::Destroy()
{
    m_xprResource.Destroy();

    // Delete vertex buffers
    for( DWORD i=0; i<NUM_FONT_BUFFERS; i++ )
        SAFE_RELEASE( m_pVBs[i] );

    if( m_bTextureFromFile )
    {
        SAFE_RELEASE( m_pTexture );
        delete [] m_Glyphs;
    }

    m_pd3dDevice         = NULL;
    m_pTexture           = NULL;
    m_pVB                = NULL;
    m_dwCurrentBuffer    = 0L;
    m_bTextureFromFile   = FALSE;

    m_pVertices          = NULL;
    m_dwNumQuads         = 0L;
    m_dwNestedBeginCount = 0L;

    m_dwFontHeight       = 36;
    m_dwTexWidth         = 64;
    m_dwTexHeight        = 64;

    m_cLowChar           = 0;
    m_cHighChar          = 0;

    m_dwNumGlyphs        = 0L;
    m_Glyphs             = NULL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CXBFont::GetTextExtent( const WCHAR* strText, FLOAT* pWidth, 
                                FLOAT* pHeight, BOOL bFirstLineOnly ) const
{
    // Check parameters
    if( NULL==strText || NULL==pWidth || NULL==pHeight )
        return E_INVALIDARG;

    // Set default text extent in output parameters
    (*pWidth)   = 0.0f;
    (*pHeight)  = 0.0f;

    // Initialize counters that keep track of text extent
    FLOAT sx = 0.0f;
    FLOAT sy = (FLOAT)(m_dwFontHeight + 1);

    // Loop through each character and update text extent
    while( *strText )
    {
        WCHAR letter = *strText++;
        
        // Handle newline character
        if( letter == L'\n' )
        {
            if( bFirstLineOnly )
                return S_OK;
            sx  = 0.0f;
            sy += (FLOAT)(m_dwFontHeight + 1);
        }

        // Ignore unprintable characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get text extent for this character's glyph
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter - m_cLowChar];
        sx += pGlyph->wOffset;
        sx += pGlyph->wAdvance;

        // Store text extent of string in output parameters
        if( sx > (*pWidth) )   (*pWidth)  = sx;
        if( sy > (*pHeight) )  (*pHeight) = sy;
     }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Begin()
// Desc: Prepares the font vertex buffers for rendering.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Begin()
{
    // Lock vertex buffer on the first call (allow nesting of begin/end calls)
    if( 0 == m_dwNestedBeginCount )
    {
        // Assign a current vertex buffer
        if( m_pVB->IsBusy() )
        {
            if( ++m_dwCurrentBuffer >= NUM_FONT_BUFFERS )
                m_dwCurrentBuffer = 0L;
            m_pVB = m_pVBs[m_dwCurrentBuffer];
        }

        // Lock the vertex buffer
        m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
        m_dwNumQuads = 0;
    }

    // Keep track of the nested begin/end calls.
    m_dwNestedBeginCount++;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws text as textured polygons
//-----------------------------------------------------------------------------
HRESULT CXBFont::DrawText( FLOAT fOriginX, FLOAT fOriginY, DWORD dwColor,
                           const WCHAR* strText, DWORD dwFlags )
{
    // Set up stuff (i.e. lock the vertex buffer) to prepare for drawing text
    Begin();

    // Set the starting screen position
    FLOAT sx = fOriginX;
    FLOAT sy = fOriginY;

    // If vertically centered, offset the starting sy value
    if( dwFlags & XBFONT_CENTER_Y )
    {
        FLOAT w, h;
        GetTextExtent( strText, &w, &h );
        sy = floorf( sy - h/2 );
    }

    // Set a flag so we can determine initial justification effects
    BOOL bStartingNewLine = TRUE;

    while( *strText )
    {
        // If starting text on a new line, determine justification effects
        if( bStartingNewLine )
        {
            if( dwFlags & (XBFONT_RIGHT|XBFONT_CENTER_X) )
            {
                // Get the extent of this line
                FLOAT w, h;
                GetTextExtent( strText, &w, &h, TRUE );

                // Offset this line's starting sx value
                if( dwFlags & XBFONT_RIGHT )
                    sx = floorf( fOriginX - w );
                if( dwFlags & XBFONT_CENTER_X )
                    sx = floorf( fOriginX - w/2 );
            }
            bStartingNewLine = FALSE;
        }

        // Get the current letter in the string
        WCHAR letter = *strText++;

        // Handle the newline character
        if( letter == L'\n' )
        {
            sx  = fOriginX;
            sy += m_dwFontHeight;
            bStartingNewLine = TRUE;
        }

        // Skip invalid characters
        if( letter<m_cLowChar || letter>m_cHighChar )
            continue;

        // Get the glyph for this character
        GLYPH_ATTR* pGlyph = &m_Glyphs[letter-m_cLowChar];

        // Setup the screen coordinates (note the 0.5f shift value which is to
        // align texel centers with pixel centers)
        sx += pGlyph->wOffset;
        FLOAT sx1 = sx - 0.5f;
        FLOAT sx2 = sx - 0.5f + ((FLOAT)pGlyph->wWidth + 1);
        FLOAT sy1 = sy - 0.5f;
        FLOAT sy2 = sy - 0.5f + ((FLOAT)m_dwFontHeight + 1);
        sx += pGlyph->wAdvance;

        // Setup the texture coordinates (note the fudge factor for converting
        // from integer texel values to floating point texture coords).
        FLOAT tx1 = ( pGlyph->left   * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty1 = ( pGlyph->top    * (m_dwTexHeight-1) ) / m_dwTexHeight;
        FLOAT tx2 = ( pGlyph->right  * ( m_dwTexWidth-1) ) / m_dwTexWidth;
        FLOAT ty2 = ( pGlyph->bottom * (m_dwTexHeight-1) ) / m_dwTexHeight;

        // Set up the vertices (1 quad = 2 triangles = 6 vertices)
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy2,0.0f,0.0f), dwColor, tx1, ty2 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx1,sy1,0.0f,0.0f), dwColor, tx1, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy1,0.0f,0.0f), dwColor, tx2, ty1 );
        *m_pVertices++ = InitFontVertex( D3DXVECTOR4(sx2,sy2,0.0f,0.0f), dwColor, tx2, ty2 );
        m_dwNumQuads++;

        // If the vertex buffer is full, render it. This will stall the GPU, so
        // we should sure that XBFONT_MAX_VERTICES is big enough.
        if( (m_dwNumQuads+1)*4 > XBFONT_MAX_VERTICES )
        {
            // Unlock, render, and relock the vertex buffer
            m_pVB->Unlock();
            Render();
            m_pVB->Lock( 0, 0, (BYTE**)&m_pVertices, 0L );
            m_dwNumQuads = 0L;
        }
    }

    // Call End() to complete the begin/end pair for drawing text
    End();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: End()
// Desc: Called after Begin(), this function triggers the rendering of the
//       vertex buffer contents filled during calls to DrawText().
//-----------------------------------------------------------------------------
HRESULT CXBFont::End()
{
    // Keep track of nested calls to begin/end.
    if( 0L == m_dwNestedBeginCount )
        return E_FAIL;
    if( --m_dwNestedBeginCount > 0 )
        return S_OK;
    
    // Unlock the vertex buffer
    m_pVB->Unlock();

    // Render the contents of the vertex buffer
    if( m_dwNumQuads > 0 )
        Render();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render()
// Desc: The internal call to actually render the vertices.
//-----------------------------------------------------------------------------
HRESULT CXBFont::Render()
{
    // Set the necessary renderstates
    m_pd3dDevice->SetTexture( 0, m_pTexture );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, sizeof(XBFONTVERTEX) );
    m_pd3dDevice->SetVertexShader( D3DFVF_XBFONTVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,         D3DBLEND_SRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,        D3DBLEND_INVSRCALPHA );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
    m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,        D3DCMP_GREATEREQUAL );
    m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,         D3DFILL_SOLID );
    m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,         D3DCULL_CCW );
    m_pd3dDevice->SetRenderState( D3DRS_ZENABLE,          FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_FOGTABLEMODE,     D3DFOG_NONE );
    m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
    m_pd3dDevice->SetRenderState( D3DRS_EDGEANTIALIAS,    FALSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MINFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MAGFILTER, D3DTEXF_POINT );
    m_pd3dDevice->SetTextureStageState( 0, D3DTSS_MIPFILTER, D3DTEXF_NONE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

    // Render the vertex buffer
    m_pd3dDevice->DrawPrimitive( D3DPT_QUADLIST, 0, m_dwNumQuads );

    // We can restore state here, if we like. Unfortunately, for generic use,
    // it's hard to guess what state the app will want everything restored to.

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: RenderToTexture()
// Desc: Creates a texture and renders a text string into it. The texture
//       format defaults to a 32-bit linear texture
//-----------------------------------------------------------------------------
LPDIRECT3DTEXTURE8 CXBFont::CreateTexture( const WCHAR* strText, 
                                           D3DCOLOR dwBackgroundColor, 
                                           D3DCOLOR dwTextColor, 
                                           D3DFORMAT d3dFormat )
{
    // Calculate texture dimensions
    FLOAT fTexWidth;
    FLOAT fTexHeight;
    GetTextExtent( strText, &fTexWidth, &fTexHeight );
    DWORD dwWidth  = (DWORD)fTexWidth;
    DWORD dwHeight = (DWORD)fTexHeight;

    switch( d3dFormat )
    {
        case D3DFMT_A8R8G8B8:
        case D3DFMT_X8R8G8B8:
        case D3DFMT_R5G6B5:
        case D3DFMT_X1R5G5B5:
            // For swizzled textures, make sure the dimensions are a power of two
            for( DWORD wmask=1; dwWidth&(dwWidth-1); wmask = (wmask<<1)+1 )
                dwWidth  = ( dwWidth + wmask ) & ~wmask;
            for( DWORD hmask=1; dwHeight&(dwHeight-1); hmask = (hmask<<1)+1 )
                dwHeight = ( dwHeight + hmask ) & ~hmask;
            break;

        case D3DFMT_LIN_A8R8G8B8:
        case D3DFMT_LIN_X8R8G8B8:
        case D3DFMT_LIN_R5G6B5:
        case D3DFMT_LIN_X1R5G5B5:
            // For linear textures, make sure the stride is a multiple of 64 bytes
            dwWidth  = ( dwWidth + 0x1f ) & ~0x1f;
            break;

        default:
            // All other formats are unsupported as render targets
            return NULL;
    }

    // Create the texture
    LPDIRECT3DTEXTURE8 pTexture;
    if( FAILED( m_pd3dDevice->CreateTexture( dwWidth, dwHeight, 1, 0L, d3dFormat, 
                                             D3DPOOL_DEFAULT, &pTexture ) ) )
        return NULL;
    
    // Get the current backbuffer and zbuffer
    LPDIRECT3DSURFACE8 pBackBuffer, pZBuffer;
    m_pd3dDevice->GetRenderTarget( &pBackBuffer );
    m_pd3dDevice->GetDepthStencilSurface( &pZBuffer );

    // Set the new texture as the render target
    LPDIRECT3DSURFACE8 pTextureSurface;
    pTexture->GetSurfaceLevel( 0, &pTextureSurface );
    D3DVIEWPORT8 vp = { 0, 0, dwWidth, dwHeight, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pTextureSurface, NULL );
    m_pd3dDevice->SetViewport( &vp );
    m_pd3dDevice->Clear( 0L, NULL, D3DCLEAR_TARGET, dwBackgroundColor, 1.0f, 0L );

    // Render the text
    DrawText( 0, 0, dwTextColor, strText, 0L );

    // Restore the rendertarget
    D3DVIEWPORT8 vpBackBuffer = { 0, 0, 640, 480, 0.0f, 1.0f };
    m_pd3dDevice->SetRenderTarget( pBackBuffer, pZBuffer );
    m_pd3dDevice->SetViewport( &vpBackBuffer );
    SAFE_RELEASE( pBackBuffer );
    SAFE_RELEASE( pZBuffer );
    SAFE_RELEASE( pTextureSurface );

    // Return the new texture
    return pTexture;
}




//-----------------------------------------------------------------------------
// Name: ReplaceInvalidChars()
// Desc: Replaces any character that does not have a glyph in the font with
//       the specified character value. Function is useful for replacing
//       invalid characters with the null "box" character.
//-----------------------------------------------------------------------------
VOID CXBFont::ReplaceInvalidChars( WCHAR* strUpdate, WCHAR cReplacement ) const
{
    // TCR 3-26 Unsupported Characters
    for( ; *strUpdate; ++strUpdate )
    {
        WCHAR cLetter = *strUpdate;
        if( cLetter == L'\n' )
            continue;
        if( cLetter < m_cLowChar || cLetter > m_cHighChar )
            *strUpdate = cReplacement;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\cpu.h ===
extern long THE_END;			// End of the used address space

BOOL FPUStress();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\fft.cpp ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.

#include "precomp.h"
#include "math.h"
#define TRUE 1
#define FALSE 0

#define INTERLEAVE		1

long addr (unsigned long p, unsigned long fftlen, unsigned long i)
{
	unsigned long addr, pass1, pass2, col, section, section_size;

	p=0;						// meaningless, just did to stop compiler from
								// complaining about unreferenced parameter.

	pass1 = i >> 9;				// Top bits
	col = (i >> 7) & 3;			// Middle 2 bits
 	pass2 = i & 127;			// Bottom 7 bits

// Compute the lower part of the address, inserting waste bytes.
// Waste is 1 cache line every 128 cache lines (32 bytes per 4K page).
// Addr is: pass1 || pass2 % 8 || optional-interleave-bit || col || 000

	addr = pass1;
	addr = (addr << 3) + (pass2 & 7);
	addr = (addr >> 7) * (128 + 1) + (addr & 127);  // Add waste
	addr *= INTERLEAVE;
	addr = ((addr << 2) + col) << 3;

// Compute the upper part of the address adding more waste bytes
// to avoid 64KB spacing.  Note there is no guarantee that the OS
// will place our 4K pages linearly in memory, but there are times
// that the OS does, so we'll optimize for that case.

	section = pass2 >> 3;
	section_size = (fftlen >> 4) * sizeof (double);
	section_size += 4096 + 8*32;	// BUG - Not ideal for all fftlen?
	section_size *= INTERLEAVE;
	addr += section * section_size;

// Return the full address

	return (DATA_ADDR + addr);
}

// Routine to handle a multiplication and modulo operation where
// the intermediate multiplication result can be more than 32 bits.

unsigned long mulmod (
	unsigned long a,
	unsigned long b,
	unsigned long c)
{
	unsigned long tmp;
	tmp = a * (b & 0x3FF);
	tmp += ((a << 10) % c) * (b >> 10);
	return (tmp % c);
}

// Some words in the FFT data contain floor(p/N), some words contain
// floor(p/N)+1 bits.  This function returns TRUE in the latter case.

int is_big_word (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i)
{
	unsigned long b, s;

// The first FFT word is always big.

	if (i == 0) return (TRUE);

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// The rest are uniformly distributed. Use floating point
// arithmetic to avoid losing data in the b * i operation.

	return (mulmod (b, i, fftlen) > s);
}

// Each FFT word is multiplied by a two-to-phi value.  These
// routines set and get the FFT value without the two-to-phi
// multiplier.

#pragma warning(disable:4725) // Disables Pentium FDIV warning.
void get_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	*retval)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*retval = (long)*dblp;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Divide by two-to-phi to generate an integer.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	tmp = *dblp;
	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld tmp
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fdivp st(1), st
	__asm frndint
	__asm fstp tmp
	*retval = (long) tmp;
}
#pragma warning(default:4725)

void set_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	val)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*dblp = val;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Multiply value by two-to-phi before setting fft value.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fimul val
	__asm fstp tmp
	*dblp = tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\cpu.cpp ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// Title: cpu
//
// Abstract: This is the entry point into the CPU tests
//           
// History:
//
// 02/07/97 V1.00 SSS Release V1.00.
// 02/25/97 V1.10 SSS Testlib recompile.
// 03/17/97 V1.11
// 05/08/97 V2.00 MET Linked to testlib V2.00 DLL.
// 06/26/97 V2.01 JWW Added 'Stress subtest.
// 07/21/97 V2.02 JWW Added CPU.HLP file.
// 07/21/97 V2.03 JWW Added AUTOCONFIGURE.
// 01/06/98 V2.04 JWW Corrected bug in AUTOCONFIGURE.
// 				  Removed unnecessary status messages.
// 02/12/98 V2.05 JWW Modified OffSteppingsNotAllowed_X parameters
//                to OffSteppingsNotAllowed[X].	Modified help file
//				  to include Autoconfigure subtest.
// 03/12/98 V2.06 JWW Modified Autoconfigure and .snp file for V3.00.
// 08/25/98 V2.08 TRW Added SIMD features test, and cleaned up cpu clone problem in selfsense.
// 04/08/00 V2.09 SLK Corrected bug in SIMD test, added CPU speed test, cleaned up
//				  level 4 warnings, added cache and cpu text descriptions.  
//				  Renamed Katmai/MMX2 notations to SIMD.
//

#include "stdafx.h"
#include "wtlib.h"
#include "cpu.h"
#include "Prime95.h"
#include "windows.h"
#include "process.h"
#include "dmi16.h"
#include "string.h"

BOOL BIOSmapped;
BYTE *pBuffer;
Type CPUType;
Cache CacheRegA, CacheRegB, CacheRegC, CacheRegD;
Features CPUFeatures;

// assign values to variables declared in cpu.h
extern "C" unsigned long PARG=0;
extern "C" double MAXERR=0.0;
extern "C" double SUMINP=0.0;
extern "C" double SUMOUT=0.0;
extern "C" double ERRCHK=0.0;

char ERRMSG1A[]="ERROR: ILLEGAL SUMOUT";
char ERRMSG1B[]="ERROR: SUM(INPUTS) != SUM(OUTPUTS), %.10g != %.10g\n";
char ERRMSG1C[]="ERROR: ROUND OFF (%.10g) > 0.40\n";

// functions in xmm.asm, external because Microsoft C++ compiler doesn't recognize yet.
extern "C" void xmm128SHF(struct_128* fresultp);
extern "C" void xmm128CMP(void* dataf1, void* dataf2, struct_128* fresultp);
extern "C" void xmm128FLT(void* dataf1, void* dataf2, struct_128* fresultp);
extern "C" void xmm128INT(void* dataf1, struct_128* iresultp);
extern "C" void xmmtest(void);

#pragma warning (disable:4725)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
#endif

static unsigned char versionnumber[] = "version_number=3.0";	  /* compiler says never used-but is used in WinMTA */
int TestNumber;

#define NUM_TIMES 20
#define MBYTE 0x100000
#define ERR_INVALIDTESTCASE			0x0
#define ERR_CPUIDNOTSUPPORTED		0x1
#define ERR_CPUIDEXCEPTION			0x2
#define ERR_VALUENOTSAVED_S			0x3
#define ERR_ERRMSGNOTRETRIEVED		0x4
#define ERR_COULDNTREADOSVERS		0x5
#define ERR_SIMDEXCEPTION			0x6
#define ERR_PARAMETERNOTFOUND_S		0x7
#define ERR_WRONGFAMILY_D			0x8
#define ERR_WRONGMODEL_D			0x9
#define ERR_STEPPINGNOTALLOWED_X	0xA
#define ERR_MMXNOTPRESENT			0xB
#define ERR_MMXPRESENT_INVALID		0xC
#define ERR_SIMDNOTPRESENT			0xD
#define ERR_SIMDPRESENT_INVALID		0xE
#define ERR_FPUNOTPRESENT			0xF
#define ERR_FPUPRESENT_INVALID		0x10
#define ERR_MMX_MOVE				0x11
#define ERR_PENTIUMBUG_F			0x12
#define ERR_FREEINGMEMORY			0x13
#define ERR_ALLOCMEMORY				0x14
#define ERR_SIMD_NOTSUPPORT_OS		0x15	
#define ERR_COPYGROUP_S				0x16
#define ERR_SIMD_MOVE				0x17 
#define ERR_SIMD_FP_SP				0x18
#define ERR_SIMD_CMP_MAX_SUB		0x19
#define ERR_SIMD_MUL_DIV_CVT		0x1A
#define ERR_CHG_CLASS_PRIORITY		0x1B
#define	ERR_CHG_THREAD_PRIORITY		0x1C
#define	ERR_CREATE_MUTEX_D			0x1D
#define ERR_ACCESS_MUTEX_D			0x1E
#define ERR_RELEASE_MUTEX_D			0x1F
#define	ERR_NOORIGVALUE_S			0x20
#define	ERR_NOMATCH_ORIGANDNEW_DD	0x21
#define	ERR_BUSSPEED_OS				0x22	
#define ERR_LASTERRTXT_S			0x23
#define ERR_SQ_NUM_S				0x24
#define ERR_ROUNDING_S				0x25
#define ERR_FFT_FAILURE_S			0x26
#define ERR_UNEXPECTED_RESULT_S		0x27
#define ERR_INSUFF_SPACE			0x28
#define ERR_NULL_PTR				0x29
#define ERR_CACHE_DESC_KEY			0x2A
#define ERR_CPU_DESC				0x2B
#define ERR_CACHE_DESC				0x2C
#define ERR_RETRIEVING_VALUE_S		0x2D
#define ERR_DESC_SPACE				0x2E
#define ERR_WRONG_CPU_TYPE_DD		0x2F
#define ERR_LOC_PROCESSOR_INFO		0x30
#define ERR_RETRIEVING_BUS_SPEED	0x31
#define ERR_READING_SMBIOS			0x32
#define ERR_RETR_ERRMSG				0x33
#define ERR_MAPPING_BIOS			0x34
#define ERR_FINDING_PROC_STRUCTURE	0x35
#define ERR_2STEPPINGLISTS			0x36

char *error_list[]={
	"Test case number not valid.",												// 0
	"CPUID instruction not supported, unable to continue.",						// 1
	"Unexpected exception from CPUID instruction.",								// 2
	"Unable to save value %s.",													// 3
	"Unable to retrieve error message.",										// 4
	"Unable to read Operating System version.",									// 5
	"Unrecognized exception to Streaming SIMD instruction.",					// 6
	"The following parameter was not found: %s.",								// 7
	"The CPU is not of the correct family (value retrieved=%d).",				// 8
	"The CPU is not of the correct model (value retrieved=%d).",				// 9
	"Stepping is not allowed: 0x%x.",											// A
	"MMX support not present when it should be.",								// B
	"MMX support present when it should not be.",								// C
	"SIMD support not present when it should be.",								// D
	"SIMD support present when it should not be.",								// E
	"FPU unit not present when it should be.",									// F
	"FPU unit present when it should not be.",									// 10
	"MMX mov operations failed.",												// 11
	"Pentium FDIV bug detected\n Expected 4915835/3145727*3145727-4915835 = 0\nReceived %f.", // 12
	"Error Freeing Memory.",														// 13
	"Error Allocating Memory.",													// 14
	"Operating System does not support Streaming SIMD Extensions.\nWindows NT 4.0 requires SP5 or greater.\nIf you already have SP5 installed, please reinstall then retry the test.",			// 15
	"Unable to copy group %s.",													// 16
	"Streaming SIMD Register move operations failed.",							// 17
	"SIMD FP SP operations failed.",											// 18
	"SIMD CMP MAX AND SUB FP SP operations failed.",							// 19
	"SIMD MUL, DIV, CVT FP SP operations failed.",								// 1A
	"Unable to change class priority.",											// 1B
	"Unable to change thread priority.",										// 1C
	"Unable to create mutex, error code is %d.",								// 1D
	"Unable to access mutex, error code is %d.",								// 1E
	"Unable to release mutex, error code is %d.",								// 1F
	"Unable to retrieve original value of parameter %s.  Did auto-configure run?",	// 20
	"Original value (%d) did not match new value (%d).",						// 21
	"Bus Speed test must run on Windows NT or 2000 operating systems.",			// 22
	"Last error text=%s.",														// 23
	"Squaring: %s.",															// 24
	"Rounding: %s.",															// 25
	"FFT Failure: %s.",															// 26
	"Unexpected result: %s.",													// 27
	"Not enough space allocated for return value.",								// 28
	"Pointer cannot be NULL.",													// 29
	"Cannot access cache description key.",										// 2A
	"Unable to retrieve CPU description.",										// 2B
	"Unable to retrieve cache description",										// 2C
	"Unable to retrieve saved value %s.",										// 2D
	"Insufficient space to store all information.",								// 2E
	"The CPU (%d) is not of the correct type (%d).",							// 2F
	"Unable to locate Processor Information structure.",						// 30
	"Unable to retrieve bus speed.",											// 31
	"Unable to read SMBIOS table from memory.",									// 32
	"Unable to retrieve last error code and text.",								// 33
	"Unable to map BIOS.",														// 34
	"Unable to find processor structure in BIOS.",								// 35
	"Cannot have both 'Steppings Allowed' and 'Steppings Not Allowed' lists.",	// 36
	"",		// 37
	"",		// 38
	"",		// 39
	"",		// 3A
	"",		// 3B
	"",		// 3C
	"",		// 3D
	"",		// 3E
	""		// 3F
};

/////////////////////////////////////////////////////////////////////////////
// CCpuApp

BEGIN_MESSAGE_MAP(CCpuApp, CWinApp)
	//{{AFX_MSG_MAP(CCpuApp)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCpuApp construction

CCpuApp::CCpuApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCpuApp object

CCpuApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CCpuApp initialization
#pragma optimize("g",off)//Necessary for use with in line assembly with Intel compiler

BOOL CCpuApp::InitInstance()
{
	if(!wt_initialize(&TestNumber))
		return FALSE;
	//get a test parameter common to all tests
	int status = wt_getint("loops",&status);
	// you would check status here if this was a required parameter
	status = wt_getint("faultinject",&status);
	status = wt_getint("devdebug",&status);

	if (TestNumber != 0) // ie, not autoconfig
	{
		int cpu;
		if (wt_getint ("cpu number", &cpu))
		{
			DWORD threadMask = 1;
			threadMask <<= cpu;
			SetThreadAffinityMask (GetCurrentThread (), threadMask);
			Sleep (0); // Wait for the next quantum to switch to the selected CPU
		} else {
			cpu=-1;		// unable to retrieve CPU number
		}
	}

	// Using the TestNumber passed to us we switch to the specific code for the given test.
	switch(TestNumber)
	{
		case 0:   SelfSense();			  break;
		case 1:   DisplayCPUFeatures();   break;
		case 2:   CPUFeatureCheck();      break;
		case 3:   FPUFeatures();          break;
		case 4:   MMXFeatures();          break;
		case 5:   FPUStress();            break;    
		case 6:   SIMDFeatures();         break;    
		case 7:	  CkCPUSpeed();			  break;


		default:  PrintError(ERR_INVALIDTESTCASE,error_list[ERR_INVALIDTESTCASE]);
	}

	wt_progress(100);
	wt_done();
	return FALSE;	  
}



//******************************************************************
// Title: SelfSense
// Abstract: Sets CPU configuation parameters.
//******************************************************************

void SelfSenseCPU (char *path, char *name, int cpu)
{
	int cpu_speed_val;
//	WORD bus_speed_val;			/* ADD BACK IN ONCE LIBRARY DAN OSAWA IS CREATING IS DONE */

	Sleep (1); // Wait for the next quantum to be schedualed on the selected CPU
	char PathStr[80] = "";
	
	GetCPUID();
	// Set configuration parameters
	  if(!wt_copy_group (path, name, PathStr, sizeof (PathStr))) {
		  PrintError(ERR_COPYGROUP_S, error_list[ERR_COPYGROUP_S], "CPU");
		  return;
	  }
	  if(!wt_putint(PathStr,"CPU NUMBER",cpu)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU NUMBER");
		  return;
	  }
	  if(!wt_putint(PathStr,"CPU TYPE",CPUType.ProcType)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU TYPE");
		  return;
	  }
	  if(!wt_putint(PathStr,"MODEL",CPUType.Model)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "MODEL");
		  return;
	  }
	  if(!wt_putint(PathStr,"FAMILY",CPUType.Family)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "FAMILY");
		  return;
	  }
	  if(!wt_putint(PathStr,"MMX",CPUFeatures.MMX)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "MMX");
		  return;
	  }
	  if(!wt_putint(PathStr,"FPU",CPUFeatures.FPU)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "FPU");
		  return;
	  }
	  if(!wt_putint(PathStr,"SIMD",CPUFeatures.XMM)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "SIMD");
		  return;
	  }

	// ck processor speed
	cpu_speed_val=CPUSpeed();
	if(!wt_putint(PathStr, "CPU SPEED", cpu_speed_val)) {
		PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU SPEED");
		return;
	}
/*	ADD CODE BACK IN ONCE LIBRARY THAT DAN OSAWA IS CREATING IS COMPLETE
	// ck bus speed	ONLY IF OS =Windows NT/2000
	if(!IsNTor2000()) {
		wt_remove_subtest(PathStr, 0x09);
	} else { 
		if(!BusSpeed(&bus_speed_val, cpu)) {
			wt_remove_subtest(PathStr, 0x09);
			PrintError(0x31, error_list[0x31]);
			wt_done();
			return;
		}
		if(!wt_putint(PathStr, "BUS SPEED", bus_speed_val)) {
			PrintError(0x03, error_list[0x03]);
			return;
		}
	}
*/
	if(!CPUFeatures.FPU)
	{
		wt_remove_subtest(PathStr,0x03);
		wt_remove_subtest(PathStr,0x05);
	}
	if(!CPUFeatures.MMX)
		wt_remove_subtest(PathStr,0x04);

	if(!CPUFeatures.XMM) {
		wt_remove_subtest(PathStr,0x06);
	} else {		// processor reports SIMD support - does OS support also?
		if(!TrySIMD()) {	// operating system does NOT support
			wt_remove_subtest(PathStr, 0x06);
		}
	}
	wt_remove_subtest(PathStr, 0x08);
	return;
}

/***************************************************************************************\
* Title:	SelfSense
* Abstract:	
\***************************************************************************************/
void SelfSense ()
{
	char pathName[128] = "";
	char groupName [128], origGroupName[128];

	// set global variable BIOSMAPPED to FALSE to indicate that MapBios() fcn hasn't run
	BIOSmapped=FALSE;

	// First get the path 
	wt_getstring("$PATH",pathName,sizeof(pathName));
	char *name = strrchr (pathName, '.');
	strcpy (origGroupName, name? (name + 1):pathName);

/* ADD CODE BACK IN ONCE LIBRARY THAT DAN OSAWA IS CREATING IS DONE
	// BIOS should be mapped once for entire SelfSense, so map before calling SelfSenseCPU
	if(IsNTor2000()) {			// only works on Windows NT or Windows 2000 OS
		if(!MapBIOS()) {
			PrintError(0x34, error_list[0x34]);
		}
		BIOSmapped=TRUE;		// flag to stop from trying to map multiple times.
	}
*/

	// Get the process affinity mask to see how many processors are available
	DWORD processMask, systemMask, threadMask = 1;
	BOOL gotMask = GetProcessAffinityMask (GetCurrentProcess (), &processMask, &systemMask);
	if (gotMask && (processMask != systemMask))
		wt_advisory ("This process does not have access to all CPU's");

		for (int cpu = 0; cpu < 32; cpu++)
		{
			sprintf(groupName, "%s %d", origGroupName, cpu);
			if (processMask & 1) // if low bit set
			{
				if (SetThreadAffinityMask (GetCurrentThread (), threadMask))
					SelfSenseCPU (pathName, groupName, cpu);
				else
				{
					DWORD error = GetLastError();
					wt_advisory ("SetThreadAffinityMask failed for CPU %d\n%s", cpu, 
						GetLastErrorText(error));
				}
			}
			threadMask <<= 1;
			processMask >>= 1;
		}

		wt_remove_group (pathName);
}



//******************************************************************
// Title: CPUFeatureCheck
//
// Abstract: Checks the features on the CPU vs any parameters
//******************************************************************

void CPUFeatureCheck()
{
	char SteppingsParamName[256], cpu_desc[1024]="", cache_desc[1024]="";
	unsigned int SteppingsAllowed;
	unsigned int SteppingsNotAllowed;
	unsigned int Model, Family, Type;
	BOOL SteppingOK = TRUE;
	int x, locStepAllw=0, locStepNotAllw=0;
	unsigned int fpu,mmx, simd;

	GetCPUID();

	// check the family, type and model
	if (!wt_getuint("Family",&Family)){	
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Family");
		wt_done();
	}
	if(!wt_getuint("CPU Type", &Type)) {
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Type");
		wt_done();
	}
	if (!wt_getuint("Model",&Model)){	
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Model");
		wt_done();
	}
	// retrieve original CPU description
	if(!CPUDescription(cpu_desc, 1024, Type, Model, Family)) {
		PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
		wt_done();
	}

	if(Family != CPUType.Family){
		PrintError(ERR_WRONGFAMILY_D, error_list[ERR_WRONGFAMILY_D], Family);
	}
	if(Model != CPUType.Model) {
		PrintError(ERR_WRONGMODEL_D,error_list[ERR_WRONGMODEL_D],Model);
	}
	if(Type != CPUType.ProcType) {
		PrintError(ERR_WRONG_CPU_TYPE_DD, error_list[ERR_WRONG_CPU_TYPE_DD],Type);
	}
	wt_status("CPU description: %s", cpu_desc);

	// check for steppings not allowed
	for(x=0;x<99;x++)
	{
		sprintf(SteppingsParamName,"SteppingsNotAllowed[%d]",x);
		if (!wt_getuint(SteppingsParamName,&SteppingsNotAllowed)){
			break;
		}
		locStepNotAllw=TRUE;
		// if we found the featuresAllowed once from now on we must find a match
		if( SteppingsNotAllowed == (unsigned int)CPUType.Stepping){
			PrintError(ERR_STEPPINGNOTALLOWED_X, error_list[ERR_STEPPINGNOTALLOWED_X],CPUType.Stepping);
			wt_done();
		}
	}

	// check the steppings allowed
	for(x=0;x<99;x++)
	{
		sprintf(SteppingsParamName,"SteppingsAllowed[%d]",x);
		if (!wt_getuint(SteppingsParamName,&SteppingsAllowed)){
			break;
		}
		locStepAllw=TRUE;
		// if we found the featuresAllowed once from now on we must find a match
		SteppingOK = FALSE;
		if( SteppingsAllowed == (unsigned int)CPUType.Stepping){
			SteppingOK = TRUE;
			break;
		}
	}
	// can't have both a "Steppings Allowed" AND a "Steppings Not Allowed" list
	if (locStepAllw && locStepNotAllw) {
		PrintError(ERR_2STEPPINGLISTS, error_list[ERR_2STEPPINGLISTS]);
	}

	if (SteppingOK == FALSE) {
		PrintError(ERR_STEPPINGNOTALLOWED_X, error_list[ERR_STEPPINGNOTALLOWED_X], CPUType.Stepping);
	}
	
	// check for MMX
	if (wt_getuint("mmx",&mmx))
	{
		if(mmx != CPUFeatures.MMX)
		{
			if (CPUFeatures.MMX == 0)
			   PrintError(ERR_MMXNOTPRESENT,error_list[ERR_MMXNOTPRESENT]);
			else
			   PrintError(ERR_MMXPRESENT_INVALID,error_list[ERR_MMXPRESENT_INVALID]);
		}
	}

	// check for SIMD/mmx2
	if (wt_getuint("SIMD",&simd))
	{
		if(simd != CPUFeatures.XMM)
		{
			if (CPUFeatures.XMM == 0)
			   PrintError(ERR_SIMDNOTPRESENT,error_list[ERR_SIMDNOTPRESENT]);
			else
			   PrintError(ERR_SIMDPRESENT_INVALID,error_list[ERR_SIMDPRESENT_INVALID]);
		}
	}

	// check for FPU
	if (wt_getuint("fpu",&fpu))
	{
		if(fpu != CPUFeatures.FPU)
		{
			if (CPUFeatures.FPU == 0)
			   PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
			else
			   PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
		}
	}

	// retrieve the cache description
	if(!CacheDescription(cache_desc, 1024)) {
		PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
		wt_done();
	}
	wt_status("Cache=%s", cache_desc);
}


//******************************************************************
// Title:		MMXFeatures
// Abstract:	Test MMX commands
//******************************************************************
void mmxtest(void *TempDwordPtr, void *ResultPtr)
{
	_asm {
		; Move inst.	
		mov	eax,12345678h
		movd	mm0,eax
		movd	ebx,mm0
		movd	mm1,ebx
		mov	edi,TempDwordPtr
		movd	[EDI],mm1
		movd	mm2,[EDI]
		movq	mm3,mm2
		movd	[EDI],mm3
		movq	mm4,[EDI]
		movq	mm5,mm4
		movq	mm6,mm5
		movq	mm7,mm6
		mov	edi,ResultPtr
		movd	[edi],mm7
		emms		     ; empty MMX state
	}
	return;
}

void MMXFeatures()
{
	DWORD TempDword;
	DWORD * TempDwordPtr;
	DWORD Result;
	DWORD * ResultPtr;
	unsigned int x,y;
	int iTestProgress = 0;

	// check for an MMX unit
	GetCPUID();
	if(CPUFeatures.MMX == 0)
	{
		PrintError(ERR_MMXNOTPRESENT,error_list[ERR_MMXNOTPRESENT]);
		wt_done();
	}
	for(y=1;y<100;y++)
	{

    	// Record progress
		if(y%10 == 0)
		{
			iTestProgress+=10;
			wt_progress(iTestProgress);
		}

		
		for(x=0;x<1000;x++)
		{
			ResultPtr = &Result;
			TempDwordPtr = &TempDword;
			mmxtest(TempDwordPtr,ResultPtr);
			if(Result != 0x12345678)
			{
				PrintError(ERR_MMX_MOVE,error_list[ERR_MMX_MOVE]);
				break;
			}
		} //x
		Sleep(100);
	} //y
}
//******************************************************************
// Title: MMXDTC
// Abstract:
//******************************************************************
void MMXDTC()
{
}
//******************************************************************
// Title:	CPUfault
// Abstract:
//******************************************************************
void CPUfault()
{
}
//******************************************************************
// Title:	DisplayCPUFeatures
// Abstract:
//******************************************************************
void DisplayCPUFeatures()
{
	char cache_desc[1024]="", cpu_desc[1024]="";

	GetCPUID();
	wt_status("Type reg=0x%x, Feature reg = 0x%x",CPUType.reg,CPUFeatures.reg);
	wt_status("Stepping=0x%x\nModel=0x%x\nFamily=0x%x\nType=0x%x",CPUType.Stepping, CPUType.Model, CPUType.Family, CPUType.ProcType);
	if(!CacheDescription(cache_desc, 1024)) {
		PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
		return;
	}
	if(!CPUDescription(cpu_desc, 1024, CPUType.ProcType, CPUType.Model, CPUType.Family)) {
		PrintError(ERR_CPU_DESC, error_list[ERR_CPU_DESC]);
		return;
	}
	
	wt_status("CPU Description=%s\nCache Description=%s", cpu_desc, cache_desc);
	
	if(CPUFeatures.FPU)
		wt_status("Floating Point unit present");
	else
		wt_status("Floating Point unit not present");
	if(CPUFeatures.MMX)
		wt_status("MMX unit present");
	else
		wt_status("MMX unit not present");
	if(CPUFeatures.XMM)
		wt_status("SIMD unit present");
	else
		wt_status("SIMD unit not present");
}


//******************************************************************
// Title:	FPUFeatures
// Abstract:
//******************************************************************
void FPUFeatures()
{
	double num = 4195835;
	double den = 3145727;
	double result;
	unsigned int x,y;

	// check for an MMX unit
	GetCPUID();

	if(CPUFeatures.FPU == 0)
	{
		PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
		wt_done();
	}
	
	for(y=1;y<100;y++)
	{
	for(x=1;x<100000;x++)
	{
	// Pentium Bug Check

	result = num / den * den - num;

	/*
	 * Bad to test floating point for equality, allows some error.
	 * A real failure returns -256 anyway.
	 */
	if(result < -0.000000001 || result > 0.000000001)
	{
		PrintError(ERR_PENTIUMBUG_F, error_list[ERR_PENTIUMBUG_F],result);
		wt_done();
	}
	} //x
	Sleep(100);
	} //y
}
//******************************************************************
// Title: PrintError
// Abstract: Tacks the module number and testnumber on to our error messages
//******************************************************************

void PrintError(unsigned int ecode, LPCTSTR format_string,...)
{
	char ErrorMessage[4096];
	unsigned int mcode = 0x85;
	va_list argptr;

	mcode = (mcode << 20) + (TestNumber <<12) + ecode;
		
	va_start(argptr,format_string);
	vsprintf(ErrorMessage,format_string,argptr);
	wt_error(mcode,ErrorMessage);

}


//******************************************************************
// Title: FPUStress 
// Abstract: Computes Mersenne Prine Numbers
//           Uses Dr. Richard Crandall's algorithm
//******************************************************************
void FPUStress()
{
	static LPVOID memreserved = NULL;
	unsigned long fftlen;
	char buf[100];
	unsigned long k;
	unsigned int i;
	unsigned long p;
	unsigned int ll_iters;
	char failed;
	int iTestProgress = 0;
	failed=FALSE;
	fftlen=65536;

		
	// Load the appropriate EXE file and setup
	THE_END = THE_END_64;
	lucas = lucas64;
	
	// Now we know how much memory to reserve

	//freeing memory
	if (memreserved != NULL) 
	{
		if (!VirtualFree (memreserved,0, MEM_RELEASE))
		{		
			PrintError(ERR_FREEINGMEMORY,error_list[ERR_FREEINGMEMORY]);
			wt_done();				
		}
			
		memreserved = NULL;
	}


	// Allocate memory for the assembly code
	memreserved = VirtualAlloc ((void*)DATA_ADDR,   /* compiler complains but it works */
		THE_END - DATA_ADDR,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE);

	if (memreserved == NULL) 
	{
			PrintError(ERR_ALLOCMEMORY,error_list[ERR_ALLOCMEMORY]);
			wt_done();				
	}

	// Determine the range from which we'll choose an exponent to test.
	i=128; 
	p=1344999;

	
	// Check for configuration parameter
	if(!wt_getuint("ITERATIONS",&ll_iters))
			ll_iters = 400;

	// Now run Lucas setup
	PARG = p;
	setup64 ();

	// Init data area with a pre-determined value
	//clear the memory
	for (k=0; k<fftlen; k++) 
		set_fft_value(p, fftlen,k,0);
	set_fft_value (p, fftlen, 0, 4);


	// Do Lucas-Lehmer iterations
	for (k = 0; k <ll_iters; k++) 
	{
		
		// Record progress
		if(k%40 == 0)
		{
			iTestProgress+=10;
			wt_progress(iTestProgress);
		}
		// One Lucas-Lehmer test with error checking			
		
		ERRCHK++;
		(*lucas)();
		ERRCHK--;
		
		// If the sum of the output values is an error (such as infinity)
		// then raise an error.  For some reason these bad values are treated
		// as zero by the C compiler.  There is probably a better way to
		// check for this error condition.

		if (SUMOUT <= 0.0) 
		{
			sprintf(buf,"i=%u, k=%lu, ",i,k);
			failed=TRUE;
			break;
		}

		// Check that the sum of the input numbers squared is approximately
		// equal to the sum of unfft results.  Note that as the sum of the
		// inputs approaches zero the more error we must tolerate. 

		if (SUMOUT < SUMINP-128.0 || SUMOUT > SUMINP+128.0) 
		{
			sprintf (buf, ERRMSG1B, SUMINP, SUMOUT);
			sprintf(buf,"i=%u, k=%lu, ",i,k);
			PrintError(ERR_SQ_NUM_S,error_list[ERR_SQ_NUM_S],buf);
			failed=TRUE;
			break;
		}


		// Make sure round off error is tolerable
		if (MAXERR > 0.40) 
		{
			sprintf (buf, ERRMSG1C, MAXERR);
			sprintf(buf,"k=%lu, ",k);
			failed=TRUE;
			PrintError(ERR_ROUNDING_S,error_list[ERR_ROUNDING_S],buf);
			break;
		}

	} // end for

	// Check for failure 
	if (failed==TRUE) 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		PrintError(ERR_FFT_FAILURE_S,error_list[ERR_FFT_FAILURE_S],buf);
		// FAILED!
	} 
	
	else 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		wt_status("Passed FPU stress test!");
		// PASSED!	
	}
		

}

/***************************************************************************************\
* Title:	GetLastErrorText
* Abstract:	Retrieve error text matching code input as parameter to function.
\***************************************************************************************/
CString GetLastErrorText(DWORD dwLastError)
{
	DWORD dwRet;
	LPTSTR lpszTemp = NULL;
	CString msg;

	dwRet = ::FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		 FORMAT_MESSAGE_FROM_SYSTEM    |
		 FORMAT_MESSAGE_ARGUMENT_ARRAY |
		 FORMAT_MESSAGE_MAX_WIDTH_MASK,
		NULL,
		dwLastError,
		LANG_NEUTRAL,
		(LPTSTR)&lpszTemp,
		0,
		NULL);

	// supplied buffer is not long enough
	if(dwRet)
	{
		lpszTemp[lstrlen(lpszTemp) - 2] = TEXT('\0');  //remove cr+lf
		msg.Format(TEXT("%s (0x%x)"),lpszTemp,dwLastError);
		LocalFree((HLOCAL)lpszTemp);
	}

	return msg;
}



/***************************************************************************************\
* Title:	SIMDFeatures 
* Abstract:	Invoke SIMD commands, make sure appropriate values are returned.  If 
*			processor doesn't support SIMD, this function should have been disabled.
*			Error if this function is called and the processor does NOT support SIMD.
\***************************************************************************************/
void SIMDFeatures()
{
	char buf[100];

	unsigned int x,y;
	int iTestProgress = 0;
	
	// check for a SIMD unit
	GetCPUID();
	if(CPUFeatures.XMM == 0)
	{
		PrintError(ERR_SIMDNOTPRESENT,error_list[ERR_SIMDNOTPRESENT]);
		wt_done();
	}
	// Check for Streaming SIMD Extension OS Support
	if(!TrySIMD()) {
		wt_advisory(error_list[ERR_SIMD_NOTSUPPORT_OS]);
		wt_done();
	}
	for(y=1;y<10;y++)
	{
		iTestProgress+=10;
		wt_progress(iTestProgress);

		for (x=0;x<10;x++)
		{

			/* set up 128 bit INT data and INT results */			
			struct_128 data_int = {1,2,3,4};
			void* datai = &data_int;			/* compiler says never used - used in ASM */
			struct_128 iresult;
			struct_128* iresultp = &iresult;		/* compiler says never used - used in ASM */
			xmm128INT(datai, iresultp);
			if(memcmp(&data_int,&iresult,16) != 0)
			{
				PrintError(0x17,error_list[0x17]);
				sprintf(buf,"Expected=%08lx%08lx%08lx%08lx\nReceived=%08lx%08lx%08lx%08lx",data_int.d,data_int.c,data_int.b,data_int.a,
				iresult.d,iresult.c,iresult.b,iresult.a);
				PrintError(ERR_UNEXPECTED_RESULT_S, error_list[ERR_UNEXPECTED_RESULT_S], buf);
				break;
			}
			struct_128 data_float1 = {(float)1.2, (float)5.6, (float)9.7, (float)0.4};	/* compiler says never used - used in ASM */
			struct_128 data_float2 = {(float)5.3, (float)2.1, (float)10.2, (float)7.0};	/* compiler says never used - used in ASM */
			struct_128 exp_fresult = {(float)2.5495097637176514, (float)2.100000, (float)4.460942, (float)2.7202942371368408};
			struct_128 fresult;
			void* dataf1 = &data_float1;			/* compiler says never used - used in ASM */
			void* dataf2 = &data_float2;			/* compiler says never used - used in ASM */
			struct_128* fresultp = &fresult;			/* compiler says never used - used in ASM*/
			xmm128FLT(dataf1, dataf2, fresultp);
			if(memcmp(&exp_fresult,&fresult,16) != 0)
			{
				PrintError(0x18,error_list[0x18]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",exp_fresult.aa,exp_fresult.bb,exp_fresult.cc,exp_fresult.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}
			xmm128CMP(dataf1, dataf2, fresultp);
			struct_128 check2 = {(float)-4.10000038146972660000, (float)-2.1, (float)-.5, (float)-6.6};
			if(memcmp(&check2,&fresult,16) != 0)
			{
				PrintError(0x19,error_list[0x19]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",check2.aa,check2.bb,check2.cc,check2.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}  
			xmm128SHF(fresultp);
			struct_128 check3 = {20,42,42,40};
			if(memcmp(&check3,&fresult,16) != 0)
			{
				PrintError(0x1A,error_list[0x1A]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",check3.aa,check3.bb,check3.cc,check3.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}  


		} //x
		Sleep(100);
	} //y
}


/*****************************************************************************************\
* Title:	CPUSpeed
* Abstract:	Set process and thread priority to realtime.  Run test several times,
*			choose median because first 4-6 times run slower than the correct speed.
*			***If speed is reported incorrectly, increase the NUM_TIMES value to get past these
*			first incorrect values.***  Speed is rounded to nearest normal value if it's
*			within a small range.  If it doesn't fit into that range, the actual value
*			is returned.
*			NOTE:  This test is not guaranteed to work as expected on laptop systems, due
*			to the CPU speed/power management policies used by laptops.
\*****************************************************************************************/
int CPUSpeed() {
	double b, c, d, results[NUM_TIMES], sorted_results[NUM_TIMES];
	int i, j, k, cpu_speed=0, origThreadPriority;
	DWORD e, wait_result;
	HANDLE hMutex;
	LARGE_INTEGER speed_v, speed_w, speed_x, speed_y, speed_z;

	origThreadPriority=GetThreadPriority(GetCurrentThread());

	if(!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)) {
		PrintError(ERR_CHG_CLASS_PRIORITY,error_list[ERR_CHG_CLASS_PRIORITY]);
		return 0;
	}

	if(!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL)) {
		PrintError(ERR_CHG_THREAD_PRIORITY, error_list[ERR_CHG_THREAD_PRIORITY]);
		return 0;
	}
	Sleep(1);
    hMutex=CreateMutex(NULL, TRUE, "WINMTA_REALTIME_MUTEX");
	if (hMutex==NULL) {		// error creating mutex
		PrintError(ERR_CREATE_MUTEX_D, error_list[ERR_CREATE_MUTEX_D], GetLastError());
		return 0;
	}
	wait_result=WaitForSingleObject(hMutex, 60000);		// wait 1 min. for mutex to be released
	if (wait_result==WAIT_TIMEOUT || wait_result==WAIT_FAILED) {
		PrintError(ERR_ACCESS_MUTEX_D, error_list[ERR_ACCESS_MUTEX_D], wait_result);
		return 0;
	}
	QueryPerformanceFrequency(&speed_v);
	for(i=0; i < NUM_TIMES; ++i) {					// # of tests to make - pick median
		QueryPerformanceCounter(&speed_x);
		__asm rdtsc									// read TimeStampCounter
		__asm mov speed_y.HighPart, edx
	    __asm mov speed_y.LowPart, eax
	    Sleep(15);									// wait X milliseconds
	    QueryPerformanceCounter(&speed_w);
	    __asm rdtsc									// Read TimeStampCounter again
	    __asm mov speed_z.HighPart, edx
	    __asm mov speed_z.LowPart, eax
		results[i]=(double)(speed_w.QuadPart-speed_x.QuadPart)/speed_v.QuadPart;
		results[i]=(double)(speed_z.QuadPart-speed_y.QuadPart)/results[i];
	}
	// set priorities back to original
	if(!SetThreadPriority(GetCurrentThread(), origThreadPriority)) {
		PrintError(ERR_CHG_THREAD_PRIORITY, error_list[ERR_CHG_THREAD_PRIORITY]);
		return 0;
	}
	if(!SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS)) {
		PrintError(ERR_CREATE_MUTEX_D, error_list[ERR_CREATE_MUTEX_D]);
		return 0;
	}		
	  
	// Sort array - will pick median value
	for (i=0; i < NUM_TIMES; ++i) {		// find largest value	 
		for (j=0, b=0, k=0; j < NUM_TIMES; ++j) {
			if (results[j]>b) {
				b=results[j];
			    k=j;
			}
		}
	    // move into sorted_results[i]
	    sorted_results[i]=b;
	    results[k]=0;
	}

	// round speed value 
	c=sorted_results[NUM_TIMES/2];
	c=c/1000;
	e=(int)c/1000;
	d=e % 100;			// retrieve last two digits
	e=e/100;			// retrieve first digit
	if (d >= 0 && d <=2) 
		d=0;
	else if (d >= 22 && d <= 27)
		d=25;
	else if (d>=30 && d <= 35)
		d=33;
	else if (d >= 46 && d <= 52)
		d=50;
	else if (d >= 63 && d <= 69)
		d=66;
	else if (d >= 71 && d <= 77)
		d=75;
	else if (d >= 96 && d <= 100)
		d=100;
	// otherwise, just leave d the way it is
#pragma warning(disable:4244)  // compiler complained of double->int conversion.  It's OK here.
	cpu_speed=(int)(e*100)+d;
#pragma warning(default:4244)

	if(!ReleaseMutex(hMutex)) {		
		PrintError(ERR_RELEASE_MUTEX_D, error_list[ERR_RELEASE_MUTEX_D], GetLastError());
		return 0;
	}
	CloseHandle(hMutex);	

	return cpu_speed;
}


/*****************************************************************************************\
* Title:	CkCPUSpeed
* Abstract:	Retrieves CPU SPEED value (should have been input through autoconfig).
*			Runs CPUSpeed test again, and compares the values.  Outputs error if they
*			don't match, or if the original value wasn't input.	
\******************************************************************************************/
void CkCPUSpeed() {
	int orig_cpu_speed, new_cpu_speed;

	if(!wt_getint("CPU SPEED", &orig_cpu_speed)) {
		PrintError(ERR_NOORIGVALUE_S, error_list[ERR_NOORIGVALUE_S], "(CPU SPEED)");
		return;
	}

	// check current speed
	new_cpu_speed=CPUSpeed();

	// compare speeds
	if (orig_cpu_speed != new_cpu_speed) {
		PrintError(ERR_NOMATCH_ORIGANDNEW_DD, error_list[ERR_NOMATCH_ORIGANDNEW_DD], orig_cpu_speed, new_cpu_speed);
		return;
	}

	return;
}




/*******************************************************************************************\
* Title:	CPUDescription
* Abstract:	Pass in a string to contain the return value of the processor, length of
*			string, and Type, Model and Family parameters.  Function uses those
*			parameters to identify the name of the processor.  Returns FALSE if error
*			occurs, TRUE otherwise.
\*******************************************************************************************/
BOOL CPUDescription(char *desc, int desc_len, int Type, int Model, int Family) {
	char *NoMatch="New processor added, CPUDescription() test needs to be updated.";

	// make sure desc_len contains enough characters for the max option
	if (desc_len < 125) {
		PrintError(ERR_INSUFF_SPACE,error_list[ERR_INSUFF_SPACE]);
		return FALSE;
	}

	// desc can't be null
	if(desc==NULL) {
		PrintError(ERR_NULL_PTR, error_list[ERR_NULL_PTR]);
		return FALSE;
	}
	// Depending on the values, copy a string containing the name of the processor
	switch(Type) {
	case 0:
		switch(Family) {
		case 4:
			switch(Model) {
			case 0:
			case 1:
				if(!AppendData(desc, desc_len, "Intel 486 DX processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 2:
				if(!AppendData(desc, desc_len, "Intel 486 SX processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Intel 487 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Intel 486 SL processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 5:
				if(!AppendData(desc, desc_len, "Intel SX2 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 7:
				if(!AppendData(desc, desc_len, "Write-Back Enhanced Intel DX2 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 8:
				if(!AppendData(desc, desc_len, "Intel DX4 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}	
			break;		// end switch(Model) inside Type 00, Family 0100
		case 5:
			switch(Model) {
			case 1:
			case 2:
				if(!AppendData(desc, desc_len, "Pentium processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Pentium processor with MMX technology.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			} 
			break;		// end switch(Model) inside Type 00, Family 0101
		case 6:
			switch(Model) {
			case 1:
				if(!AppendData(desc, desc_len, "Pentium Pro processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Pentium II processor, model 3.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 5:
				if(!AppendData(desc, desc_len, "Pentium II processor, model 5, Pentium II Xeon processor, model 5, or Intel Celeron processor, model 5.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 6:
				if(!AppendData(desc, desc_len, "Intel Celeron Processor, model 6.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 7:
				if(!AppendData(desc, desc_len, "Pentium III processor, model 7, or Pentium III Xeon processor, model 7.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 8:
				if(!AppendData(desc, desc_len, "Pentium III processor, model 8, Pentium III Xeon processor, model 8, or Intel Celeron processor, model 8.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}
			break;
		default:
			if(!AppendData(desc, desc_len, NoMatch)) {
				PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
				return FALSE;
			}
			break;
		}					// end switch(Family) inside Type 00
		break;				// end Type 00
		case 1:
		switch(Family) {
		case 5:
			switch(Model) {
			case 1:
			case 2:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processor for Pentium processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processors for Intel 486 processor-based systems.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processor with MMX technology for Pentium processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;

			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			} 
			break;		// end case Family 0101, Type 01
		case 6:
			switch(Model) {
			case 3:
				if(!AppendData(desc, desc_len, "Intel Pentium II OverDrive processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}
			break;
		}
		break;			// end switch(Family) inside Type 01
		default:		// no type match found
			if(!AppendData(desc, desc_len, NoMatch)) {
				PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
				return FALSE;
			}
			break;
	}
 	return TRUE;
}


/******************************************************************************************\
* Title:	CacheDescription
* Abstract:	Copy cache description into string passed into function.  Returns TRUE if passed,
*			FALSE if failed.
\******************************************************************************************/
void cacheinfo(DWORD ptrCacheRegA, DWORD ptrCacheRegB, DWORD ptrCacheRegC, DWORD ptrCacheRegD)
{
	_asm {
		mov		eax, 2		; ask for the cache information
		cpuid
		mov		edi, ptrCacheRegA
		mov		[edi], eax
		mov		edi, ptrCacheRegB
		mov		[edi], ebx
		mov		edi, ptrCacheRegC
		mov		[edi], ecx
		mov		edi, ptrCacheRegD
		mov		[edi], edx
	}
	return;
}

BOOL CacheDescription(char *desc, int desc_len) {
	int stop=0, count=0;

	
	if (desc==NULL) {
		PrintError(ERR_NULL_PTR,error_list[ERR_NULL_PTR]);
		return FALSE;
	}

	while (!stop) {
		++count;				 
		// get the cache information
		__try{		// necessary in case processor doesn't support CPUID call
			cacheinfo((DWORD)&(CacheRegA.reg), (DWORD)&(CacheRegB.reg), (DWORD)&(CacheRegC.reg), (DWORD)&(CacheRegD.reg));
		}				
		__except(EXCEPTION_EXECUTE_HANDLER) {
			if(_exception_code()==STATUS_ILLEGAL_INSTRUCTION) {
				wt_error(0x01,error_list[0x01]);
				return FALSE;
			}
			// if we get here, an unexpected error has occurred - what?
			PrintError(ERR_CPUIDEXCEPTION, error_list[ERR_CPUIDEXCEPTION]);
			return FALSE;
		}
		// check EAX bits 0-7.  Indicate how many times CPUID needs to be called with 2 in EAX
		if((unsigned)count >= CacheRegA.byte0) {
			stop=1;
		}

		if(!(CacheRegA.byte3 & 0x80)) {		// register values valid only if bit 31==0
			// no need to find match on byte0 - used to tell # calls/CPUID necessary
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

		if(!(CacheRegB.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;	
			}
		}

		if (!(CacheRegC.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

		if (!(CacheRegD.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

	} // end of while(!stop) loop
	return TRUE;
}


/**************************************************************************************\
* Title:	AppendData
* Abstract:	Append second data string to first if there's room in the first.  If not,
*			return FALSE.  Otherwise, return TRUE.
\***************************************************************************************/
BOOL AppendData(char* data1, int data1_len, char* data2) {
	int len1, len2;

	if(data1==NULL || data2==NULL) {
		PrintError(ERR_NULL_PTR, error_list[ERR_NULL_PTR]);
		return FALSE;
	}

	len1=strlen(data1);
	len2=strlen(data2);
	if(len1+len2+1 < data1_len) {
		if(len1 != 0) {
			strcat(data1, "\n");
		}
		strcat(data1, data2);
	} else {
		return FALSE;
	}
	return TRUE;
}



/***************************************************************************************\
* Title:	FindCacheMatch
* Abstract:	Search for match to "masked_data" criteria.  Return FALSE if error occurs,
*			TRUE otherwise.
\***************************************************************************************/
BOOL FindCacheMatch(char *desc, int desc_len, __int16 masked_data)
{
	switch(masked_data) {
	case 0x00:		// these first cases are for minor caches, don't bother to list them
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x06:
	case 0x08:
	case 0x0A:
	case 0x0C:
		break;
	case 0x40:
		if(!AppendData(desc, desc_len, "No L2 cache.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x41:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 128K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x42:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 256K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x43:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 512K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x44:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 1M.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x45:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 2M.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x82:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 8 way set associative, 256K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	default:
		if(!AppendData(desc, desc_len, "New cache description, CacheDescription() function needs to be updated.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	}
	return TRUE;
}


/***************************************************************************************\
* Title:	IsNTor2000
* Abstract:	Check version of current operating system.  Return TRUE is Windows NT or 
*			Windows 2000, returns FALSE if unable to retrieve error or if OS is NOT
*			Windows NT or 2000.
\***************************************************************************************/
BOOL IsNTor2000() {
	OSVERSIONINFO OS;

	// get version information
	OS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(!GetVersionEx(&OS)) {
		return FALSE;					// unable to retrieve version info
	}
	if(OS.dwPlatformId!=VER_PLATFORM_WIN32_NT) {
		return FALSE;					// version info didn't meet requirements
	}
	return TRUE;
}


/***************************************************************************************\
* Title:	GetCPUID
* Abstract:	Try to call CPUID instruction, and store value in CPUType and CPUFeatures
*			structures.  If an exception occurs, and the exception is 
*			STATUS_ILLEGAL_INSTRUCTION, print an error message.  Otherwise, let the
*			exception filter up higher.
\***************************************************************************************/
void getcpuid(DWORD	ptrCPUTYPE, DWORD ptrCPUFEATURES)
{
	_asm {
		mov	eax, 1			; ask for the feature information
		cpuid
		mov	edi,ptrCPUTYPE
		mov	[edi], eax
		mov	edi,ptrCPUFEATURES
		mov	[edi], edx
	}
		return;
}

void GetCPUID() {
	__try{		// necessary in case processor doesn't support CPUID call
		getcpuid((DWORD)&(CPUType.reg), (DWORD)&(CPUFeatures.reg));
	  }
	__except(GetExceptionCode()==STATUS_ILLEGAL_INSTRUCTION) {
		wt_error(ERR_CPUIDNOTSUPPORTED,error_list[ERR_CPUIDNOTSUPPORTED]);
		return;
	}
}


/***************************************************************************************\
* Title:	TrySIMD
* Abstract:	Try a SIMD instruction to see if OS supports SIMD instructions.  Returns
*			TRUE if support exists, FALSE if support does not exist.
\***************************************************************************************/
BOOL TrySIMD() {
	  __try {
		  xmmtest();
	  }
	  __except(GetExceptionCode()==STATUS_ILLEGAL_INSTRUCTION) { // exception occurred
		  return FALSE;
	  }
	  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\floatpt.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    memsize.c

Abstract:

    floating point tests for the hardware team
    intel source->xbox port by JGould

Environment:

    Xbox

Revision History:

--*/


#include "precomp.h"
#include "xtestlib.h"

LONG THE_END;
BOOL BIOSmapped;
BYTE *pBuffer;
//Type CPUType;
//Cache CacheRegA, CacheRegB, CacheRegC, CacheRegD;
//Features CPUFeatures;

// assign values to variables declared in cpu.h
extern "C" unsigned long PARG=0;
extern "C" double MAXERR=0.0;
extern "C" double SUMINP=0.0;
extern "C" double SUMOUT=0.0;
extern "C" double ERRCHK=0.0;



BOOL FPUStress()
{
	static LPVOID memreserved = NULL;
	unsigned long fftlen;
	char buf[100];
	unsigned long k;
	unsigned int i;
	unsigned long p;
	unsigned int ll_iters;
	char failed;
//	int iTestProgress = 0;
	failed=FALSE;
	fftlen=65536;


	// Allocate memory for the assembly code
	memreserved = VirtualAlloc ((void*)DATA_ADDR,   /* compiler complains but it works */
		THE_END - DATA_ADDR,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE);

	if (memreserved == NULL) 
	{
		return FALSE;
	}

	// Determine the range from which we'll choose an exponent to test.
	i=128; 
	p=1344999;

	
	// Check for configuration parameter
	ll_iters = 400;

	// Now run Lucas setup
	PARG = p;
	setup64 ();

	// Init data area with a pre-determined value
	//clear the memory
	for (k=0; k<fftlen; k++) 
		set_fft_value(p, fftlen,k,0);
	set_fft_value (p, fftlen, 0, 4);


	// Do Lucas-Lehmer iterations
	for (k = 0; k <ll_iters; k++) 
	{
		ERRCHK++;
		lucas64();
		ERRCHK--;
		
		// If the sum of the output values is an error (such as infinity)
		// then raise an error.  For some reason these bad values are treated
		// as zero by the C compiler.  There is probably a better way to
		// check for this error condition.

		if (SUMOUT <= 0.0) 
		{
			sprintf(buf,"i=%u, k=%lu, ",i,k);
			failed=TRUE;
			break;
		}

		// Check that the sum of the input numbers squared is approximately
		// equal to the sum of unfft results.  Note that as the sum of the
		// inputs approaches zero the more error we must tolerate. 

		if (SUMOUT < SUMINP-128.0 || SUMOUT > SUMINP+128.0) 
		{
//			sprintf (buf, ERRMSG1B, SUMINP, SUMOUT);
//			sprintf(buf,"i=%u, k=%lu, ",i,k);
			failed = TRUE;
			break;
		}


		// Make sure round off error is tolerable
		if (MAXERR > 0.40) 
		{
//			sprintf (buf, ERRMSG1C, MAXERR);
//			sprintf(buf,"k=%lu, ",k);
			failed=TRUE;
//			PrintError(ERR_ROUNDING_S,error_list[ERR_ROUNDING_S],buf);
			break;
		}

	} // end for

	// Check for failure 
	if(failed) return FALSE;
	else return TRUE;

/*
	if (failed==TRUE) 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		PrintError(ERR_FFT_FAILURE_S,error_list[ERR_FFT_FAILURE_S],buf);
		// FAILED!
	} 
	
	else 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		wt_status("Passed FPU stress test!");
		// PASSED!	
	}
*/		

}

VOID WINAPI FpTestStartTest(HANDLE LogHandle)
{
    xSetComponent( LogHandle, "Hardware", "floatpt" );
    xSetFunctionName( LogHandle, "FloatPt" );
    xStartVariation( LogHandle, "FloatPt" );

	if(FPUStress()) {
		xLog( LogHandle, XLL_PASS, "The floating point unit works!");
	} else {
		xLog( LogHandle, XLL_FAIL, "The floating point unit failed???");
	}

    xEndVariation( LogHandle );
}


VOID WINAPI FpTestEndTest(VOID)
{
}


//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( floatpt )
#pragma data_seg()

BEGIN_EXPORT_TABLE( floatpt )
    EXPORT_TABLE_ENTRY( "StartTest", FpTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", FpTestEndTest )
END_EXPORT_TABLE( floatpt )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 17-Aug-2000

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>
#include "xlog.h"
#include <stdio.h>
#include "cpu.h"
#include "prime95.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\i386\lucas64.asm ===
.386
.model flat
	TITLE   setup


_TEXT32 SEGMENT PARA USE32 PUBLIC 'DATA'

IFDEF WIN31
_MAXERR		DQ	0.0		; Maximum error
_SUMINP		DQ	0.0		; Sum of inputs
_SUMOUT		DQ	0.0		; Sum of outputs
_ERRCHK		DD	0		; Is error checking enabled?
_PARG		DD	0		; Prime exponent being tested

ELSE
EXTRN	_MAXERR:QWORD
EXTRN	_SUMINP:QWORD
EXTRN	_SUMOUT:QWORD
EXTRN	_ERRCHK:DWORD
EXTRN	_PARG:DWORD
ENDIF

;
; Global variables needed in squaring
;

        align   8
HALF		DD	0.5		; One-half
MINUS2		DD	-2.0		; Used to subtract 2.
BIGVAL		DD	0.0		; Used to round to an integer
scaled_numbig	DD	0		; numbig * (2^32 / n)
scaled_numlit	DD	0		; numlit * (2^32 / n)
		; These values only used during setup
p		DD	0		; Mersenne prime being tested
numlit		DD	0		; number of small words in the fft
numbig		DD	0		; number of big words in the fft
_TEXT32	ENDS


	ASSUME  CS: _TEXT32, DS: _TEXT32, SS: _TEXT32, ES: _TEXT32

n	EQU	65536		; size of the FFT

.code

INCLUDE common.mac

;
; FFT.CPP should fully describe the memory layout.
; In pass1:
;	The distance between each data element is 8 bytes.
;	The distance between every fourth element is 256 bytes.
;	The distance between every 64th element is 4K bytes + gap.
; In pass2:
;	The distance between each data element is 32 bytes.
;	The distance between every eighth element is 32K bytes + gaps.
;	The distance between every 128th element is 4K bytes + gap.
;

	assign_addrs 0, 3072, 1536, 0, 179520

pass1_distances MACRO
	dist1 = 8
	dist4 =	256			*INTERLEAVE
	dist64 = (4096+32)		*INTERLEAVE
	dist512 = 32			*INTERLEAVE
	dist4096 = (32768+4096+8*32)	*INTERLEAVE
	ENDM
pass2_distances MACRO
	dist1 = 32			*INTERLEAVE
	dist8 = (32768+4096+8*32)	*INTERLEAVE
	dist128 = 8
	dist512 = 256			*INTERLEAVE
	dist8192 = (4096+32)		*INTERLEAVE
	ENDM


; Setup routine

	PUBLIC	_setup64
	IFDEF WIN31
	ORG	0400h
_setup64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_PARG, ecx
	ELSE
_setup64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Initialize

	finit				; Init FPU

; Save p

	mov	eax, _PARG		; p
	mov	p, eax

; Compute two-to-phi and two-to-minus-phi multipliers

	normalize_setup

; Compute the array of sine and cosine/sine values

	sine_cosine_1_setup
	sine_cosine_2_setup
	pre_multiplier_setup pre_mults2, n, 128

; Return

	IFDEF WIN31
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret
_setup64 ENDP

;
; Compute next number in lucas sequence.  i.e.
; square the input number mod 2**p-1, subtract 2
;

	PUBLIC	_lucas64
	IFDEF WIN31
	ORG	1000h
_lucas64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_ERRCHK, ecx		; ERRCHK is passed in ecx
	ELSE
_lucas64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Init the FPU every iteration just to be safe

	finit

; Start the fft process, do pass1 fft
; 128 sections of 512 values
; Perform nine levels of the FFT on 512 real values.

	pass1_distances
	mov	esi, input		; U - Starting address
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b0a:	nine_levels_fft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b0a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b0a			; V - Iterate if necessary

; Do the first section of pass 2

	pass2_distances
	seven_levels_real_fft_sq_unfft

; Do the other 255 sections of pass 2 

	mov	esi, input+2*dist128	; U - Restore source pointer
	mov	ebp, pre_mults2		; V - Addr of group pre-multipliers
	mov	edx, 8*256+16+80000000h	; U - 8 iters of 16 iters of 1 or 2
b1b:	seven_levels_fft_sq_unfft
	xor	edx, 80000000h		; U - Test inner loop counter
	JS_X	b1b			; V - Iterate if necessary
	lea	esi, [esi-4*dist128+dist512]; U - Next source pointer
	dec	dl			; V - Test outer loop counter
	JNZ_X	b1b			;*V - Iterate if necessary
	lea	esi, [esi-16*dist512+dist8192]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 16			; U - Reload inner loop counter
	JNZ_X	b1b			; V - Iterate if necessary

; Finish the inverse fft process, do pass1 inverse fft

	pass1_distances
	mov	esi, input		; U - Source pointer
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b2a:	nine_levels_unfft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b2a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b2a			; V - Iterate if necessary

; Error check - find largest round off error

	cmp	_ERRCHK, 0
	JZ_X	noechk

; Code to check for how close we are to incurring a round-off error

	pass2_distances
	fldz				; Maximum error
	mov	edx, norm_grp_mults	; Address of the group multipliers
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; Used to compute big vs little words
	mov	ebp, scaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
elp4:	mov	save_counter, ebx
	mov	ecx, 4*256		; 4 iterations of
elp3:	mov	cl, 16			; 128 / 8 iterations
	mov	ebx, norm_col_mults	; Restart the column multipliers
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
elp2:	error_check			; Error check eight values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	elp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	elp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	mov	ebx, save_counter
	dec	bl
	JNZ_X	elp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	elp4			; Loop til done
	fstp	_MAXERR			; Store maximum error

; Normalize the results

noechk:	pass2_distances
	fldz				; Init SUMOUT
	fld	MINUS2			; Start normalization process
	fadd	BIGVAL			; with a BIGVAL-2.0 carry!
	mov	edx, norm_grp_mults	; Address of the group multipliers
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; Used to compute big vs little words
	mov	ebp, scaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
nlp4:	mov	save_counter, ebx
	mov	ecx, 4*256		; 4 iterations of
nlp3:	mov	cl, 16			; 128 / 8 iterations
	mov	ebx, norm_col_mults	; Restart the column multipliers
	fld	QWORD PTR [edx]		; Two-to-phi
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx]		; Two-to-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
nlp2:	normalize			; Normalize 8 values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	nlp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	nlp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	mov	ebx, save_counter
	dec	bl
	JNZ_X	nlp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	nlp4			; Loop til done

					; Add any carry to first values
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; To compute big vs little words
	mov	ebx, norm_col_mults	; Restart the column multipliers
	normalize_012

; Normalize SUMOUT value by multiplying by 1 / (n/2).
; This is the value of the first two-to-minus-phi group multiplier

	fmul	QWORD PTR ds:(norm_grp_mults+norm_gap)
	fstp	_SUMOUT

; Return

exit:	IFDEF WIN31
	fld	_SUMINP			;; Return values in floating
	fld	_SUMOUT			;; point registers
	fld	_MAXERR
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret

_lucas64 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\floatpt\prime95.h ===
/////////////////////////////////////////////////////////////////////////////
// My non-MFC stuff went here
/////////////////////////////////////////////////////////////////////////////

// Constants

#define MIN_PRIME	5L		// Smallest testable prime
#define MAX_PRIME	LIMIT256	// Largest testable prime
#define MAX_FACTOR	LIMIT256	// Largest factorable number

// Limits based on 1000 iterations with an error no greater than 0.30.

#define LIMIT256	5260000L	// Crossover points
#define LIMIT224	4605000L
#define LIMIT192	3960000L
#define LIMIT160	3310000L
#define LIMIT128	2655000L
#define LIMIT112	2330000L
#define LIMIT96		2000000L
#define LIMIT80		1675000L
#define LIMIT64		1345000L

#define FAC61	LIMIT224		// How far to factor
#define FAC60	3540000L
#define FAC59	2750000L
#define FAC58	LIMIT112
#define FAC57	1750000L
#define FAC56	LIMIT64
#define FAC55	1050000L
#define FAC54	750000L

#define DATA_ADDR	0x20010000	// Addr of the input doubles
#define THE_END_64	0x200D0780	// Max addr for 64K FFT len
#define THE_END_80	0x200FBF00	// Max addr for 80K FFT len
#define THE_END_96	0x20127700	// Max addr for 96K FFT len
#define THE_END_112	0x201531C0	// Max addr for 112K FFT len
#define THE_END_128	0x2017E9C0	// Max addr for 128K FFT len
#define THE_END_160	0x201D61A0	// Max addr for 160K FFT len
#define THE_END_192	0x2022D520	// Max addr for 192K FFT len
#define THE_END_224	0x202848E0	// Max addr for 224K FFT len
#define THE_END_256	0x202DBBC0	// Max addr for 256K FFT len
extern long THE_END;			// End of the used address space

#define REL_486_SPEED	7.0	// 486 is 7 times slower than Pentium
#define REL_PRO_SPEED	0.87	// Pro is little faster than Pentium

#ifndef SEC1
#define SEC1(p)		0
#define SEC2(p,hi,lo)	0
#define SEC3(p)		0
#define SEC4(p)		0
#endif

// Global variables

extern char *INI_SECTION;		// Section name in INI file
extern int THREAD_ACTIVE;		// True if a thread is active
extern int volatile THREAD_STOP;	// TRUE if thread should stop
extern int AUTO_CONTINUE;		// 1 if auto continue is on
extern int ADVANCED_ENABLED;		// 1 if advanced menu is enabled
extern int TRAY_ICON;			// Display tiny tray icon
extern int HIDE_ICON;			// Display no icon
//extern "C" int volatile ERRCHK;		// 1 to turn on error checking
extern int JUST_FIND_FACTORS;		// Factor the range
extern int DOUBLE_CHECK;		// Double-check the range
extern "C" unsigned int volatile CPU_TYPE;// 3=Cyrix, 4=486, 5=Pentium, 6=Pro
extern unsigned long volatile CPU_SPEED;// For 90MHz = 90
extern unsigned long RANGE_START;	// Start of range to test
extern unsigned long RANGE_END;		// End of range to test
extern unsigned long NEXT_RANGE_START;	// Start of range to test next
extern unsigned long NEXT_RANGE_END;	// End of range to test next
extern unsigned int volatile ITER_OUTPUT;// Iterations between outputs
extern int TXT_EXTENSION;		// True if output file is results.txt

extern int PRIORITY;			// Desired priority level
extern int TIMED_RUN;			// TRUE if this is a timed run
//extern CTime END_TIME;			// End time for a timed run
extern int SILENT_VICTORY;		// Quiet find of new Mersenne prime

extern HMODULE HLIB;			// Handle of networking DLL
extern int (__stdcall *HPROC_GET_NEXT_EXPONENT)(unsigned long *, int *);
extern int (__stdcall *HPROC_WRITE_RESULTS)(char *);

const int NumLines = 32;
extern char *lines[NumLines];
extern int charHeight;

// Internal routines

UINT threadDispatch (LPVOID);
void findSmallestP (unsigned long *);
int readFileHeader (char *, int *, short *, unsigned long *);
int readFileData (int, unsigned long, unsigned long);
int writeToFile (unsigned long, char *, unsigned long, unsigned long);
void clearPrime (unsigned long, int);
void makestr64 (char *);
void writeResults (char *);
void primeClear (unsigned long, unsigned long);
void generateRandomData (unsigned long, unsigned long);
void checkResultsFile (unsigned long, int *, int *);

extern "C" void setupf ();
extern "C" int factor64 ();
extern "C" void __cdecl setup64 ();
extern "C" int __cdecl lucas64 ();
extern "C" void setup80 ();
extern "C" int lucas80 ();
extern "C" void setup96 ();
extern "C" int lucas96 ();
extern "C" void setup112 ();
extern "C" int lucas112 ();
extern "C" void setup128 ();
extern "C" int lucas128 ();
extern "C" void setup160 ();
extern "C" int lucas160 ();
extern "C" void setup192 ();
extern "C" int lucas192 ();
extern "C" void setup224 ();
extern "C" int lucas224 ();
extern "C" void setup256 ();
extern "C" int lucas256 ();

long  addr (unsigned long, unsigned long, unsigned long);
int is_big_word (unsigned long, unsigned long, unsigned long);
void get_fft_value (unsigned long, unsigned long, unsigned long, long *);
void set_fft_value (unsigned long, unsigned long, unsigned long, long);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hawk\hawk.cpp ===
//#define DSOUND_INCLUDE_XHAWK
//#include <xtl.h>
//#include <dsound.h>


extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
}


#include <xtl.h>
#include <dsound.h>
//#include <dsoundp.h>
#include <xvoice.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xlogconio.h>
#include "hawk.h"

#define VERIFY_SUCCESS(xprsn) \
{\
    HRESULT hrTemp = (xprsn);\
    if(!SUCCEEDED(hrTemp))\
    {\
        DebugPrint("Call failed: %s(%d): 0x%0.8x\n", __FILE__, __LINE__, hrTemp);\
    }\
}

// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}


#if !defined(HARNESSLIB)
BOOL g_RunForever = TRUE;
BOOL g_Pause = FALSE;
#else
extern BOOL g_RunForever;
extern BOOL g_Pause;
#endif


// 
// Pink noise generator
//
PinkNumber::PinkNumber() {
	// Zero vars
	m_Index = 0;
	m_RunningSum = 0;
	ZeroMemory(m_Rows, sizeof(m_Rows));

	// Mask used to determin the number of trailing zeros in Index
	m_IndexMask = (1<<PINK_NOISE_ROWS) - 1;

	// Seed random number generator
	srand(timeGetTime());
}


PinkNumber::~PinkNumber() {
}


WORD PinkNumber::GetNextValue() {
	int NumZeros, n;
	WORD RandNum;

	// Imcrement and mask index
	m_Index++;
	m_Index &= m_IndexMask;

	// Update random values for Index !=0
	if(m_Index != 0) {
		// Determine the number of trailing zeros in Index
		NumZeros = 0;
		n = m_Index;
		while((n & 1) == 0) {
			n = n >> 1;
			NumZeros++;
		}

		// Use NumZeros to determine which row to update
		m_RunningSum = m_RunningSum - m_Rows[NumZeros];
		RandNum = (WORD)rand();
		m_RunningSum = m_RunningSum + RandNum;
		m_Rows[NumZeros] = RandNum;
	}

	// Add white noise and scale
	RandNum = (WORD)rand();
	return (m_RunningSum + RandNum)%PINK_MAX;
}

 
/*
**
**  Implementation of CHawkUnit that does loop back test
**  on a single unit.
**
*/
CHawkUnit::CHawkUnit():
        m_dwPortNumber(0),
        m_pHeadphone(NULL),
        m_pMicrophone(NULL),
        m_dwBuffersSent(0),
        m_dwBuffersReceived(0),
        m_dwLoopbackErrors(0),
        m_fConnected(FALSE),
        m_fStarted(FALSE),
        m_dwPatternPosition(0),
        m_NextMicrophoneBufferIndex(0),
        m_NextHeadphoneBufferIndex(0)
{
}


BOOL CHawkUnit::IsConnected() {
	return m_fConnected;
}


void CHawkUnit::Init(DWORD dwPortNumber, HANDLE hEvent)
{
    m_dwPortNumber = dwPortNumber;

    //
    // Initialize the media buffers
    //
    for(int i=0; i <3; i++)
    {
        
        HeadphoneBuffers[i].xMediaPacket.dwMaxSize  = XHAWK_TEST_BUFFER_SIZE;
        HeadphoneBuffers[i].xMediaPacket.pvBuffer = new BYTE[XHAWK_TEST_BUFFER_SIZE];
        HeadphoneBuffers[i].xMediaPacket.pdwCompletedSize = &HeadphoneBuffers[i].dwCompletedSize;
        HeadphoneBuffers[i].xMediaPacket.pdwStatus = &HeadphoneBuffers[i].dwStatus;
        HeadphoneBuffers[i].xMediaPacket.hCompletionEvent = hEvent;
        

        MicrophoneBuffers[i].xMediaPacket.dwMaxSize  = XHAWK_TEST_BUFFER_SIZE;
        MicrophoneBuffers[i].xMediaPacket.pvBuffer = new BYTE[XHAWK_TEST_BUFFER_SIZE];
        MicrophoneBuffers[i].xMediaPacket.pdwCompletedSize = &MicrophoneBuffers[i].dwCompletedSize;
        MicrophoneBuffers[i].xMediaPacket.pdwStatus = &MicrophoneBuffers[i].dwStatus;
        MicrophoneBuffers[i].xMediaPacket.hCompletionEvent = hEvent;

        if(NULL == HeadphoneBuffers[i].xMediaPacket.pvBuffer)
        {
            DebugPrint("Buffer allocation Failed (Headphone Buffer #%d)\n", i);
        }
        if(NULL == MicrophoneBuffers[i].xMediaPacket.pvBuffer)
        {
            DebugPrint("Buffer allocation Failed (Microphone Buffer #%d)\n", i);
        }
    }
}

CHawkUnit::~CHawkUnit()
{
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    
    for(int i=0; i <3; i++)
    {
        delete MicrophoneBuffers[i].xMediaPacket.pvBuffer;
        delete HeadphoneBuffers[i].xMediaPacket.pvBuffer;
    }
}

void CHawkUnit::Inserted(HANDLE LogHandle)
{
    int i;
	WAVEFORMATEX    wfxFormat;

	m_LogHandle = LogHandle;

    //
    // Headset initialization
    //
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = XHAWK_VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2*XHAWK_VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    //
    //  Create a microphone and a headphone.
    //
    VERIFY_SUCCESS(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, m_dwPortNumber , 
												XHAWK_TEST_BUFFER_COUNT, &wfxFormat, &m_pMicrophone));

    VERIFY_SUCCESS(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, m_dwPortNumber , 
												XHAWK_TEST_BUFFER_COUNT, &wfxFormat, &m_pHeadphone));

    m_fConnected = TRUE;
    m_NextMicrophoneBufferIndex = 0;
    m_NextHeadphoneBufferIndex = 0;
    m_dwBuffersSent = 0;
    m_dwBuffersReceived = 0;
    m_dwLoopbackErrors = 0;
    
    //
    //  Initialize the status of all the buffer
    //
    for(i=0; i < XHAWK_TEST_BUFFER_COUNT; i++) {
        HeadphoneBuffers[i].dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
        MicrophoneBuffers[i].dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
    }

    //
    //  Start up the streaming
    //
    for(i=0; i < XHAWK_TEST_BUFFER_COUNT; i++) {
        //  Fill the headphone buffer with a test pattern
        for(int bufferOffset=0 ; bufferOffset < XHAWK_TEST_BUFFER_SIZE/sizeof(WORD); bufferOffset++) {
			((PWORD)HeadphoneBuffers[i].xMediaPacket.pvBuffer)[bufferOffset] = m_PinkNoise.GetNextValue();
        }
        
        //  Wipe the microphone buffer clean
        memset(MicrophoneBuffers[i].xMediaPacket.pvBuffer, 0, XHAWK_TEST_BUFFER_SIZE);
                
        //  Attach media buffer for headphone XMO's
        VERIFY_SUCCESS(m_pHeadphone->Process(&HeadphoneBuffers[i].xMediaPacket, NULL));
                
        //  For the first buffer, introduce a 10 ms delay, to give the loop back device
        //  a few cycles to process the first data.
        if(i==0) Sleep(25);

        //
        //  Attach media buffer for microphone
        VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MicrophoneBuffers[i].xMediaPacket));
    }

	m_fStarted = TRUE;
	xLog(gbConsoleOut, m_LogHandle, XLL_INFO, "Added Hawk: Port: %ld", m_dwPortNumber);
}


void CHawkUnit::StartStreaming() {
	int i;

	// Start streaming if connected and not started
	if(g_Pause) {
		// Applicatioin is paused, do not start streaming and clear Started flag
		m_fStarted = FALSE;
	} else {
		// Application is not paused, start streaming if connected and not started
		if(m_fConnected && !m_fStarted) {
			//  Start up the streaming
			for(i=0; i < XHAWK_TEST_BUFFER_COUNT; i++) {
				//  Fill the headphone buffer with a test pattern
				for(int bufferOffset=0 ; bufferOffset < XHAWK_TEST_BUFFER_SIZE/sizeof(WORD); bufferOffset++) {
					((PWORD)HeadphoneBuffers[i].xMediaPacket.pvBuffer)[bufferOffset] = m_PinkNoise.GetNextValue();
				}

				//  Wipe the microphone buffer clean
				memset(MicrophoneBuffers[i].xMediaPacket.pvBuffer, 0, XHAWK_TEST_BUFFER_SIZE);
                
				//  Attach media buffer for headphone XMO's
				VERIFY_SUCCESS(m_pHeadphone->Process(&HeadphoneBuffers[i].xMediaPacket, NULL));
                
				if(i==0) Sleep(25);

				//  Attach media buffer for microphone
				VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MicrophoneBuffers[i].xMediaPacket));
			}

			m_fStarted = TRUE;
		}
	}
}


void CHawkUnit::Removed()
{
    if(m_pMicrophone)
    {
        m_pMicrophone->Release();
    }
    if(m_pHeadphone)
    {
        m_pHeadphone->Release();
    }
    m_fConnected = FALSE;
	m_fStarted = FALSE;
}

void CHawkUnit::Process()
/*++
    
    This routine is called because this XMO's event
    was signaled.  Since we pass the same event with
    every buffer, we do not know whether th microphone or
    headphone completed.

--*/
{
    
    //
    //  Handle a headphone completions
    //
    while(XMEDIAPACKET_STATUS_PENDING != HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus)
    {
        if(XMEDIAPACKET_STATUS_SUCCESS == HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus)
        {
            m_dwBuffersSent++;
        }
        HeadphoneBuffers[m_NextHeadphoneBufferIndex].dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;
        m_NextHeadphoneBufferIndex = (m_NextHeadphoneBufferIndex+1)%XHAWK_TEST_BUFFER_COUNT;
    }

    //
    //  Handle a microphone completions
    //
    while(XMEDIAPACKET_STATUS_PENDING != MicrophoneBuffers[m_NextMicrophoneBufferIndex].dwStatus) {
		switch(MicrophoneBuffers[m_NextMicrophoneBufferIndex].dwStatus) {
		case XMEDIAPACKET_STATUS_SUCCESS:
			//  Record that the data was receieved
			m_dwBuffersReceived++;
			if(m_dwBuffersReceived > m_dwBuffersSent) {
				DebugPrint("ERROR: m_dwBuffersReceived > m_dwBuffersSent\n");
				_asm int 3;
			}
			//  Check for loopback errors
			/*
			if(0!=memcmp(MicrophoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket.pvBuffer, HeadphoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket.pvBuffer, XHAWK_TEST_BUFFER_SIZE)) {
				m_dwLoopbackErrors++;
				xLog(gbConsoleOut, m_LogHandle, XLL_FAIL, "Hawk: Port: %ld Microphone Loopback Error %d", m_dwPortNumber, m_dwLoopbackErrors);
			}
			*/
			break;

		case XMEDIAPACKET_STATUS_FLUSHED:
	        m_dwLoopbackErrors++;
			xLog(gbConsoleOut, m_LogHandle, XLL_FAIL, "Hawk: Port: %ld XMEDIAPACKET_STATUS_FLUSHED", m_dwPortNumber);
			break;

		case XMEDIAPACKET_STATUS_FAILURE:
	        m_dwLoopbackErrors++;
			xLog(gbConsoleOut, m_LogHandle, XLL_FAIL, "Hawk: Port: %ld XMEDIAPACKET_STATUS_FAILURE", m_dwPortNumber);
			break;
		}

        //
        //  Reset the status to pending so we don't accidentaly
        //  process twice.
        //
        MicrophoneBuffers[m_NextMicrophoneBufferIndex].dwStatus = (DWORD)XMEDIAPACKET_STATUS_PENDING;

        //
        //  If the device is still connected, resubmit the buffers.
		//  and not paused
        //
        if(m_fConnected && !g_Pause)
        {
            //  Fill the headphone buffer with a test pattern
            for(int bufferOffset=0 ; bufferOffset < XHAWK_TEST_BUFFER_SIZE/sizeof(WORD); bufferOffset++) {
				((PWORD)HeadphoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket.pvBuffer)[bufferOffset] = m_PinkNoise.GetNextValue();
            }
    
            //  Wipe the microphone buffer clean
            memset(MicrophoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket.pvBuffer, 0, XHAWK_TEST_BUFFER_SIZE);
            
            //  Attach media buffer for headphone XMO's
            VERIFY_SUCCESS(m_pHeadphone->Process(&HeadphoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket, NULL));
            
            //  Attach media buffer for microphone
            VERIFY_SUCCESS(m_pMicrophone->Process(NULL, &MicrophoneBuffers[m_NextMicrophoneBufferIndex].xMediaPacket));
        }

        //  Process the next microphone buffer, if it is ready.
        m_NextMicrophoneBufferIndex = (m_NextMicrophoneBufferIndex+1)%XHAWK_TEST_BUFFER_COUNT;
    }
}    

void CHawkUnit::Log(WCHAR *pwstrText)
{
    DebugPrint("%ws\n", pwstrText);
}

/*
**
**  Implementation of CHawkUnits that tracks multiple hawk units.
**
*/
CHawkUnits::CHawkUnits() {   
    for(int i=0; i<4; i++) {
        m_pProcessEvents[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_pHawkUnits[i].Init(i, m_pProcessEvents[i]);
    }        
}


CHawkUnits::~CHawkUnits(){
}


void CHawkUnits::Run(HANDLE LogHandle)
{
    int i;
    
    DWORD dwConnectedMicrophones;
    DWORD dwConnectedHeadphones;

    //
    //  Get the initial connected state of the devices
    //
    dwConnectedMicrophones = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);
    dwConnectedHeadphones = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);
    if( dwConnectedMicrophones != dwConnectedHeadphones)
    {
        DebugPrint("dwConnectedMicrophones != dwConnectedHeadphone\n");
        _asm int 3;
    }
    for(i=0; i < 4; i++)
    {
        if(dwConnectedMicrophones&(1<<i))
        {
            m_pHawkUnits[i].Inserted(LogHandle);
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Added Hawk: Port: %ld", i);
        }
    }

    //
    //  Now loop forever
    //
    while(g_RunForever)
    {
		//  Start streaming (does nothing if: not paused, connected, and started
		for(i=0; i<4; i++) {
			m_pHawkUnits[i].StartStreaming();
		}
        
        //
        //  Wait until something happens, or 16 ms, whichever is first
        //
        DWORD dwReason = WaitForMultipleObjects(4, this->m_pProcessEvents, FALSE, 16);

        //
        //  If the wait expired due to one of the events, then call
        //  the appropriate hawk unit.
		//
		//	Do not .Process() if global Pause flag set.
        //
        if((dwReason >= WAIT_OBJECT_0) && (dwReason <= WAIT_OBJECT_0+3) && (!g_Pause)) {
		    int i = dwReason-WAIT_OBJECT_0;
            m_pHawkUnits[i].Process();
        }

        //
        //  Always check for hot-plugs
        //
        DWORD dwMicrophoneInsertions, dwHeadphoneInsertions, dwMicrophoneRemovals, dwHeadphoneRemovals;
        if(XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwMicrophoneInsertions, &dwMicrophoneRemovals))
        {
            if(!XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwHeadphoneInsertions, &dwHeadphoneRemovals))
            {
                DebugPrint("GetDeviceChanges does not match\n");
                _asm int 3;
            }
            if(
                (dwMicrophoneInsertions != dwHeadphoneInsertions) ||
                (dwMicrophoneRemovals != dwHeadphoneRemovals)
            ){
                DebugPrint("GetDeviceChanges does not match, different\n");
                _asm int 3;
            }

            //
            //  Loop over all the ports
            //
            for(i=0; i<4; i++)
            {
                //
                //  Handle Removal, if there is one.
                //
                if(dwMicrophoneRemovals&(1<<i))
                {
                    m_pHawkUnits[i].Removed();
					xLog(gbConsoleOut, LogHandle, XLL_INFO, "Removed Hawk: Port: %ld", i);
                }

                //
                //  Handle Insertion, if there is one.
                //

                if(dwMicrophoneInsertions&(1<<i))
                {
                    m_pHawkUnits[i].Inserted(LogHandle);
                }
            } //end of loop over ports
        }  //end of check for getting device changes
    } //end of infinite loop
}

VOID
WINAPI
HawkStartTest(HANDLE LogHandle) {

	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetComponent( LogHandle, "EMC", "Hawk" );
    xSetFunctionName( LogHandle, "LoopBack" );

    CHawkUnits hawkUnits;
    hawkUnits.Run(LogHandle);
}


VOID
WINAPI
HawkEndTest( VOID) {
}

#if !defined(HARNESSLIB)
int __cdecl main() {
	HANDLE	LogHandle = NULL;

	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	gbConsoleOut = TRUE;
	g_RunForever = TRUE;
	g_Pause = FALSE;

	// xlog
	LogHandle = xCreateLog_W(L"t:\\hawk.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("HAWK: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Start Test
	xDebugStringA("All attached Hawk Units will be exercised.\n");
	XInitDevices(0, NULL);
	HawkStartTest(LogHandle);
	

	// End Test
	HawkEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// Return to launcher
	XLaunchNewImage(NULL, NULL);
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( hawk )
#pragma data_seg()

BEGIN_EXPORT_TABLE( hawk )
    EXPORT_TABLE_ENTRY( "StartTest", HawkStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", HawkEndTest )
END_EXPORT_TABLE( hawk )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hawk\hawk.h ===
#define PINK_NOISE_ROWS 16
#define PINK_MAX 0x5555		// 1/3 of max for IEC 60065

class PinkNumber {
	
	private:
		WORD m_Rows[PINK_NOISE_ROWS];
		WORD m_RunningSum;
		WORD m_Index;
		WORD m_IndexMask;

	public: 
		PinkNumber();
		~PinkNumber();
		WORD GetNextValue();
};

//
//  The buffer size should not be divisible by 8 USB frames.
//  Depending on the hardware, it is either 32 bytes or 48
//  bytes.  So it is either (29*3) ms or (29*2) ms of data.
//
#define XHAWK_VOICE_SAMPLING_RATE 8000
#define XHAWK_TEST_BUFFER_SIZE (16*2*3*29)		// 16 bytes/ms * time
#define XHAWK_TEST_BUFFER_COUNT 3

struct HAWKMEDIABUFFER
{
    XMEDIAPACKET xMediaPacket;
    DWORD        dwCompletedSize;
    DWORD        dwStatus;
};

class CHawkUnit
{
  public:

    CHawkUnit();
    ~CHawkUnit();
    void Init(DWORD dwPort, HANDLE hEvent);
    void Inserted(HANDLE LogHandle);
    void Removed();
    void Process();
    // void Draw();
    void Log(WCHAR *pwstrText);
	BOOL IsConnected();
	void StartStreaming();
  
  private:
	HANDLE m_LogHandle;
    XMediaObject *m_pMicrophone;
    XMediaObject *m_pHeadphone;
    DWORD m_dwPortNumber;
    BOOL m_fConnected;
    BOOL m_fStarted;
    
    //
    //  Buffers for test.
    //
    HAWKMEDIABUFFER HeadphoneBuffers[XHAWK_TEST_BUFFER_COUNT];
    HAWKMEDIABUFFER MicrophoneBuffers[XHAWK_TEST_BUFFER_COUNT];

	//
	// Pink Noise
	//
	PinkNumber m_PinkNoise;

    //
    //  Progress Stats.
    //
    DWORD  m_dwPatternPosition;
    DWORD  m_dwBuffersSent;
    DWORD  m_dwBuffersReceived;
    DWORD  m_dwLoopbackErrors;

    //
    //  Keeps track of the next buffer that is 
    //  expected to complete.
    //
    ULONG m_NextMicrophoneBufferIndex;
    ULONG m_NextHeadphoneBufferIndex;
};

class CHawkUnits
{
    public:
        CHawkUnits();
        ~CHawkUnits();
        void Run(HANDLE LogHandle);
    private:
        CHawkUnit m_pHawkUnits[4];
        HANDLE m_pProcessEvents[4];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\inc\AW.h ===
/* Copyright Micrsooft 2001 - all rights reserved

  Author: sethmil

  History:

		created		5/9/01		sethmil

  Abstract:
		A wrapper DLL for ActiveWire functions
		uses words as output instead of the activewire
		byte arrays.

*/

#ifndef __AW_H__
#define __AW_H__


// includes
#define WIN32_LEAN_AND_MEAN
#ifdef _XBOX
	#include <xtl.h>
#else
	#include <windows.h>
#endif


//#define	DEVROOTNAME		"AW-"
#define AW_DLL_NAME		"aw.dll"

#ifdef AW_DLL_EXPORT
#define AW_API __declspec(dllexport)
#else
#define AW_API __declspec(dllimport)
#endif




//////////////////////////////////////////////////////////////////
// class CAWDevice
// an IO class for activewire devices
/////////////////////////////////////////////////////////////////
//
class AW_API CAWDevice
{
public:
	// default constructor
	CAWDevice();

	// enumerates device devnum
	CAWDevice( DWORD devnum );

	// destructor
	~CAWDevice();

	// writes a word to the port
	DWORD OutPort (WORD data );

	// reads a word from the port
	DWORD InPort (WORD *data );

	// enables the port for input/output
	// 1=output
	// 0=input
	DWORD EnablePort( WORD data );

	// outputs bytes sequentially to the output
	// even subscript bytes are the lower 8 bits
	// odd subscript byytes are the upper 8 bits
	DWORD OutPortEx( BYTE*, DWORD count );

	// reads bytes sequentially from the port
	DWORD InPortEx( BYTE*, DWORD count );

	// enables the port sequentially
	DWORD EnablePortEx( BYTE*, DWORD count );

	// opens a device
	DWORD Open( DWORD devnum );

	// closes the device
	DWORD Close( );

	// returns the last error code
	DWORD GetLastError();

	// sets the last error code
	VOID SetLastError( DWORD errcode );

	// returns a string for the AW error message
	char* ErrorMessage( DWORD errcode );
	// returns string for the last error message
	char* ErrorMessage();

	// TRUE if the device is valid and opened
	BOOL DeviceIsOpen();

protected:
	int iDeviceNum;
	DWORD dwErrCode;
};

//////////////////////////////////////////////////////////////////////////

// Exported Functions
// See ActiveWire documentation for descriptions of these functions
//

extern "C" {

// writes a word to the port
AW_API DWORD AWOutPort ( WORD data );

/* writes count bytes to the ports
 array elements with even subscripts are written to the lower
 8 bits of the port, elements with odd subscripts are written to
 the upper 8 bits of the port.  If count > 2, bytes are written consecutively to
 the port
*/
AW_API DWORD AWOutPortEx ( BYTE* data, DWORD count );


// reads a word from the port
AW_API DWORD AWInPort ( WORD *data );


/* writes count bytes from the ports
 array elements with even subscripts are read from the lower
 8 bits of the port, elements with odd subscripts are read from
 the upper 8 bits of the port.  If count > 2, bytes are read consecutively from
 the port
*/
AW_API DWORD AWInPortEx ( BYTE* data, DWORD count );


/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
*/
AW_API DWORD AWEnablePort ( WORD data );


/* enables input or output of the port
	for each bit:
		write a 1 to make the bit an output
		write a 0 to make the bit an input
	array elements with even subscripts enable the lower
	 8 bits of the port, elements with odd subscripts enable
	 the upper 8 bits of the port.  If count > 2, enable data is written
	 consecutively to the por
*/	
AW_API DWORD AWEnablePortEx ( BYTE* data, DWORD count );


/*
	opens the USB device.  
	devnum is the device number
	0 is the 1st device attached, 1 is the second, etc

	each thread can open one device at a time.
*/
AW_API DWORD AWOpen ( WORD devnum );


/*
	closes the device that is currently opened by the thread
*/
AW_API DWORD AWClose (  );


/*
	returns error string
*/
AW_API char * AWErrorMessage( DWORD errcode );



// Error Code
enum AW_ERROR_CODE_T {
	AW_OK	= 0,			// success
	AW_ERROR_FATAL,			// Fatal error, cannot continue
	AW_ERROR_SYSTEM,			// System error, use WIN32 GetLastError() for further error code
	AW_ERROR_MEMORY,			// Run out of memory
	
	AW_ERROR_FILEOPEN,		// File open failure
	AW_ERROR_FILEWRITE,		// File write failure
	AW_ERROR_FILEREAD,		// File read failure
	AW_ERROR_FILECLOSE,		// File close failure
	AW_ERROR_FILEFORMAT,		// File format error
	AW_ERROR_FILECHECKSUM,	// File checksum error
	AW_ERROR_FILEEOF,		// Unexpected end of file 

	AW_ERROR_HARDWARE,		// Hardware error, such as the device unplugged

	AW_ERROR_SOFTWARE,		// Software error, possibly a bug...
	AW_ERROR_NOTIMPLEMENTED,	// Not implemented yet...
	AW_ERROR_NOSUPPORT,		// Not supported

	AW_ERROR_USBNOTOPEN,		// Not opend yet
	AW_ERROR_USBNOTCLOSE,	// Not closed yet

	AW_ERROR_USBBADPIPE,		// Bad USB pipe
	AW_ERROR_USBBADOPCODE,	// Bad USB Command/Status Opcode
	AW_ERROR_USBZEROPACKET,	// Zero length USB data packet
	AW_ERROR_USBSHORTPACKET,	// Short USB data packet
	AW_ERROR_USBLONGPACKET,	// Longer USB data packet

	AW_ERROR_TIMEOUT,		// Time out, may or may not a problem...
	AW_ERROR_TRYAGAIN,		// Don't get too serious, try again, may work next time
	AW_ERROR_UNKNOWN,		// Unknown... Truth is out there...   :)
};

}  // extern "C"


#endif // __AW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\inc\AWClasses.h ===
/*
	Copyright Microsoft 2001 - all rights reserved

  author:  sethmil

  Abstract:

	// AWClasses.h
	//
	// header file for classes used with the AW board
	//
	// class CXBoxControlr uses an ActiveWire USB Board
	// to cycle power on the xbox
*/


#ifndef __AWCLASSES_H__
#define __AWCLASSES_H__


#define WIN32_LEAN_AND_MEAN
#ifdef _XBOX
	#include <xtl.h>
#else
	#include <windows.h>
#endif
#include <aw.h>
#include <i2clib.h>

// constants
/*static const WORD  OUTPUT_PORT = 0x0003;
static const WORD  POWSW       = 0x0002;
static const WORD  ACPOWER     = 0x0001;
static const WORD  POWON	   = 0x0004;*/

//#define OUTPUT_PORT 0x0003
#define ACPOWER     0x0001		// output IO/0 - AC Power Control
#define POWSW       0x0002		// output IO/1 - POWSW control		
#define POWON       0x0004		// input IO/2 - POWON signal
#define STANDBY		0x0008		// input IO/3 - 3.3V stby voltage
#define VMODE1		0x0010		// input IO/4 - VMODE1
#define VMODE2		0x0020		// input IO/5 - VMODE2
#define VMODE3		0x0040		// input IO/6 - VMODE3
#define SYSRESET	0x0080		// input - sysreset

#define EJTSW		0x0100		// output DVD Eject
#define TRAYSTATE0	0x0200		// input TRAYState0
#define TRAYSTATE1  0x0400		// input traysate1
#define TRAYSTATE2  0x0800		// input traysate2
#define POWOK		0x1000		// output - POWOK
#define DVDEJECT	0x2000		// input - DVDEject



enum 
{
	OK_XBOX_POWER = 0,
	XBOX_POWER_OFF_ERROR,
	XBOX_POWER_ON_ERROR
};





// AV Pack definitions
static const enum AVPack
{
	NOPACK		= 0x7,
	RFU			= 0x3,
	POWEROFF	= 0x5,
	HDTV		= 0x1,
	SDTV_ANALOG = 0x6,
	VGA			= 0x2,
	SDTV_DIGITAL= 0x4,
	SCART		= 0x0
};



//********************************************************************************************
// Class definitions
//


// class CXBoxControlr uses an ActiveWire USB Board
// to cycle power on the xbox

class CXBoxControl : protected CAWDevice
{
public:
	CXBoxControl( DWORD dwDevNum );
	~CXBoxControl();

	// turns box power on (AC Main)
	DWORD Unplug();

	// turns box power off (AC Main)
	DWORD PlugIn();

	// returns TRUE if the box is plugged in
	BOOL PluggedIn();

	// turns the box on
	DWORD BoxOn( const DWORD dwTimeOut = 10000 );

	// turns the box off
	DWORD BoxOff( const DWORD dwTimeOut = 10000 );

	// asserts POWSW for dwPulseWidth milliseconds
	DWORD CyclePower( const DWORD dwPulseWidth );

	// sets the POWSW signal to LOW
	DWORD SetPOWSWLow();

	// sets the POWSW signal to HIGH
	DWORD SetPOWSWHigh();

	// pulses the EJTSW signal
	DWORD EjectSwitch( const DWORD dwPulseWidth );

	// closes the DVD - if the DVD is closed, does nothing
	DWORD DVDClose();

	// opens the DVD - if the DVD is open, does nothing
	DWORD DVDOpen();

	// returns TRUE if the DVD tray is open
	BOOL DVDIsOpen();

	// returns TRUE if the DVD is closed, or in media detect, or in nomedia
	BOOL DVDIsClosed();

	// returns TRUE if the DVD is in media detect state
	BOOL DVDMediaDetect();

	// return TRUE if the DVD is in NoMedia stata
	BOOL DVDNoMedia();

	// returns TRUE if the DVD is in TRAYOPEN state
	BOOL DVDTrayOpen();

	// returns TRUE if the DVD is in CLOSED tray state
	BOOL DVDTrayClosed();

	// returns TRUE if POWSW is high
	BOOL POWSWIsHigh();

	// return TRUE if the box is on
	BOOL BoxIsOn();

	// returns TRUE if the box is off
	BOOL BoxIsOff();

	// returns TRUE if the AW device is open
	BOOL DeviceIsOpen();

	// returns TRUE if 3.3V standby is high
	BOOL STBYIsHigh();

	// enables an output port
	BOOL Enable( WORD wSignal );

	// disables an output prot
	BOOL Disable( WORD wSignal );

	// Error handling
	DWORD GetLastError();
	char* ErrorMessage( const DWORD errcode );
	char* ErrorMessage();


protected:
	CXBoxControl();	// not to be used
	DWORD SetSignalHigh( const WORD wSignal );	// sets a signal high
	DWORD SetSignalLow( const WORD wSignal );		// sets a signal low
	BOOL  SignalIsHigh( const WORD wSignal );		// returns TRUE if a signal is high
	BOOL  SignalIsLow( const WORD wSignal );		// returns TRUE if a signal is low
	
	WORD	wEnable;
};


/////////////////////////////////////////////////////////////////
// Class AV Pack
// controls AV Pack strappings
//
// Pin IO/4 = VMODE1
// PIN IO/5 = VMODE2
// PIN IO/6 = VMODE3
//////////////////////////////////////////////////////////////////

class CAVPack : protected CAWDevice
{
public:
	CAVPack( DWORD dwDevNum );
	~CAVPack( );
	
	// Sets the AV Pack output
	// AV is an enum that specifies the
	// type of AV Pack
	VOID SetAVPack( AVPack av );

	// Drives the AVPack lines
	// the the desired mode
	VOID DriveAVPack( AVPack av );
	
	// Drives the PowerOn signal
	VOID PowerOn( );

	// sets AVPack to POWEROFF
	VOID PowerOff( );


	DWORD GetLastError();
	char* ErrorMessage();

};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\inc\AwusbAPI.h ===
// AWUSBAPI.H : header file
//

#if !defined(AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_)
#define AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define	DEVROOTNAME		"Awusb-"
#define AWUSB_DLL_NAME	"awusb.dll"

#ifdef AWUSB_DLL_EXPORT
#define __AWUSB_DLL		__declspec(dllexport) 
#else
#define	__AWUSB_DLL		__declspec(dllimport) 
#endif

// typedef
typedef struct _AWUSB_INTELHEX_T
{
	BYTE	count;
	WORD	addr;
	BYTE	type;
	BYTE	data[256];
	BYTE	crc;
} 
AWUSB_INTELHEX;

#define AWUSB_MAX_NUMPIPE	32
typedef struct _AWUSB_PIPEINFO_T
{
	BYTE	numpipe;
	BYTE	type[AWUSB_MAX_NUMPIPE];
	BYTE	endpoint[AWUSB_MAX_NUMPIPE];
	BYTE	dir[AWUSB_MAX_NUMPIPE];
	WORD	size[AWUSB_MAX_NUMPIPE];
} 
AWUSB_PIPEINFO;


// Function prototype
// High level Application interface
__AWUSB_DLL	DWORD	AwusbOutPort (BYTE *data, DWORD count);
__AWUSB_DLL	DWORD	AwusbInPort (BYTE *data, DWORD count);
__AWUSB_DLL	DWORD	AwusbEnablePort (BYTE *data, DWORD count);

// Low level USB interface
__AWUSB_DLL	DWORD	AwusbOpen (DWORD devnum);
__AWUSB_DLL	DWORD	AwusbClose ();
__AWUSB_DLL	DWORD	AwusbSetInterface (DWORD intfc, DWORD altset);
__AWUSB_DLL	DWORD	AwusbRead (DWORD pipenum, BYTE *buf, DWORD count);
__AWUSB_DLL	DWORD	AwusbWrite (DWORD pipenum, BYTE *buf, DWORD count);
__AWUSB_DLL	DWORD	AwusbCancelIo (DWORD pipenum);
__AWUSB_DLL	DWORD	AwusbGetPipeInfo (AWUSB_PIPEINFO *pipeinfo);
__AWUSB_DLL	DWORD	AwusbResetPipe (DWORD pipenum);
__AWUSB_DLL	DWORD	AwusbDownload (AWUSB_INTELHEX hexrec);
__AWUSB_DLL	DWORD	AwusbReadIntelHexLine (char *buf, AWUSB_INTELHEX *hexrec);
__AWUSB_DLL	DWORD	AwusbDownloadIntelHexFile (char *filename);
__AWUSB_DLL	DWORD	Awusb8051Reset (BOOL hold);

// Error handling
__AWUSB_DLL	char *	AwusbErrorMessage (DWORD errcode);


// Error Code
enum AWUSB_ERROR_CODE_T {
	AWUSB_OK	= 0,			// success
	AWUSB_ERROR_FATAL,			// Fatal error, cannot continue
	AWUSB_ERROR_SYSTEM,			// System error, use WIN32 GetLastError() for further error code
	AWUSB_ERROR_MEMORY,			// Run out of memory
	
	AWUSB_ERROR_FILEOPEN,		// File open failure
	AWUSB_ERROR_FILEWRITE,		// File write failure
	AWUSB_ERROR_FILEREAD,		// File read failure
	AWUSB_ERROR_FILECLOSE,		// File close failure
	AWUSB_ERROR_FILEFORMAT,		// File format error
	AWUSB_ERROR_FILECHECKSUM,	// File checksum error
	AWUSB_ERROR_FILEEOF,		// Unexpected end of file 

	AWUSB_ERROR_HARDWARE,		// Hardware error, such as the device unplugged

	AWUSB_ERROR_SOFTWARE,		// Software error, possibly a bug...
	AWUSB_ERROR_NOTIMPLEMENTED,	// Not implemented yet...
	AWUSB_ERROR_NOSUPPORT,		// Not supported

	AWUSB_ERROR_USBNOTOPEN,		// Not opend yet
	AWUSB_ERROR_USBNOTCLOSE,	// Not closed yet

	AWUSB_ERROR_USBBADPIPE,		// Bad USB pipe
	AWUSB_ERROR_USBBADOPCODE,	// Bad USB Command/Status Opcode
	AWUSB_ERROR_USBZEROPACKET,	// Zero length USB data packet
	AWUSB_ERROR_USBSHORTPACKET,	// Short USB data packet
	AWUSB_ERROR_USBLONGPACKET,	// Longer USB data packet

	AWUSB_ERROR_TIMEOUT,		// Time out, may or may not a problem...
	AWUSB_ERROR_TRYAGAIN,		// Don't get too serious, try again, may work next time
	AWUSB_ERROR_UNKNOWN,		// Unknown... Truth is out there...   :)
};

#endif // !defined(AFX_ACTIVEWIREUSB_H__C5F11600_F0F9_11D2_AC25_00104B306BEE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hdperf\hdperf.cpp ===
//
//	hdperf.cpp
//	Hard drive performance test using low level commands
//

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>


#define KB              1024
#define MB              (KB*KB)
#define MINBUFSIZE      (4*KB)
#define MAXBUFSIZE      (128*KB)
#define TESTFILESIZE    (64*MB)
#define TESTDIRNAME     "z:\\test"
#define TESTFILENAME    "z:\\perftest.dat"
#define SAMPLEBLOCKSIZE (256*MB)
#define SAMPLEREADSIZE  (16*MB)
#define SECTORSIZE      512
#define MAXSMALLFILESIZE (4*KB)
#define FILECOUNT        2048
#define READBUFSIZE     (4*KB)
#define WRITEBUFSIZE    512
#define CACHEFILESIZE   (256*KB)
#define STARTINGPOS     (16*MB)

// AT Commands
#define AT_STANDBY_IMMEDIATE	0xE0	// 0x94 or 0xE0
#define AT_IDLE_IMMEDIATE		0xE1	// 0x95 or 0xE1
#define AT_STANDBY				0xE2	// 0x96 or 0xE2
#define AT_IDLE					0xE3	// 0x97 or 0xE3
#define AT_CHECK_POWER_MODE		0xE5	// 0x98 or 0xE5


// Globals
static HANDLE gLogHandle;
static DISK_GEOMETRY gDiskGeometry;
static LARGE_INTEGER gFrequency;


VOID
HDPerf_LogAtaPassThrough(ATA_PASS_THROUGH AtaPassThrough) {
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bFeaturesReg = %#x", AtaPassThrough.IdeReg.bFeaturesReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorCountReg = %#x", AtaPassThrough.IdeReg.bSectorCountReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorNumberReg = %#x", AtaPassThrough.IdeReg.bSectorNumberReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylLowReg = %#x", AtaPassThrough.IdeReg.bCylLowReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylHighReg = %#x", AtaPassThrough.IdeReg.bCylHighReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bDriveHeadReg = %#x", AtaPassThrough.IdeReg.bDriveHeadReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCommandReg = %#x", AtaPassThrough.IdeReg.bCommandReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bHostSendsData = %#x", AtaPassThrough.IdeReg.bHostSendsData);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.DataBufferSize = %#x", AtaPassThrough.DataBufferSize);
}

VOID
LogDiskCacheInformation(DISK_CACHE_INFORMATION DiskCacheInformation) {
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ParametersSavable = %#x", DiskCacheInformation.ParametersSavable);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ReadCacheEnabled = %#x", DiskCacheInformation.ReadCacheEnabled);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.WriteCacheEnabled = %#x", DiskCacheInformation.WriteCacheEnabled);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ReadRetentionPriority = %#x", DiskCacheInformation.ReadRetentionPriority);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.WriteRetentionPriority = %#x", DiskCacheInformation.WriteRetentionPriority);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.DisablePrefetchTransferLength = %#x", DiskCacheInformation.DisablePrefetchTransferLength);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.PrefetchScalar = %#x", DiskCacheInformation.PrefetchScalar);
	if(DiskCacheInformation.PrefetchScalar == TRUE ) {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.Minimum = %#x", DiskCacheInformation.ScalarPrefetch.Minimum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.Maximum = %#x", DiskCacheInformation.ScalarPrefetch.Maximum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.MaximumBlocks = %#x", DiskCacheInformation.ScalarPrefetch.MaximumBlocks);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.BlockPrefetch.Minimum = %#x", DiskCacheInformation.BlockPrefetch.Minimum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.BlockPrefetch.Maximum = %#x", DiskCacheInformation.BlockPrefetch.Maximum);
	}
}


LARGE_INTEGER
ReadLBA(HANDLE hDevice, ULONG LBA, ULONG Sectors) {
	IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
	UCHAR *Buffer;
	ULONG BufferSize;
	LARGE_INTEGER StartTime, EndTime, ReturnValue, Offset;

	// Allocate Data Buffer
	BufferSize = Sectors*gDiskGeometry.BytesPerSector;
	Buffer = (UCHAR *)GlobalAlloc(GPTR, BufferSize);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "GlobalAlloc(Buffer %u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		ReturnValue.QuadPart = -1;
		return ReturnValue;
	}

	// Calculate Offset
	Offset.QuadPart = LBA*gDiskGeometry.BytesPerSector;

	// Start timer
	QueryPerformanceCounter(&StartTime);

	// Read bytes at offset
	status = NtReadFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, Buffer, BufferSize, &Offset);

	// Stop timer
	QueryPerformanceCounter(&EndTime);

	if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "NtReadFile(%u Bytes at Offset %#x) FAILED Status = %d", 
			BufferSize, Offset.QuadPart, status);
		ReturnValue.QuadPart = -1;
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "NtReadFile = %u Bytes at Offset %#x, %f ms", Bytes, Offset.QuadPart, 1000.0*(EndTime.QuadPart - StartTime.QuadPart)/gFrequency.QuadPart);
		ReturnValue.QuadPart = EndTime.QuadPart - StartTime.QuadPart;
	}

	GlobalFree(Buffer);

	return ReturnValue;
}


DOUBLE
HDAccessTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG LBA;
	// NTSTATUS status;
	// IO_STATUS_BLOCK ioStatusBlock;

	// Initialize
	TotalTime.QuadPart = 0;
	ReturnVal = 1.0/(DOUBLE)Reps;

	// Flush Buffers
	// status = NtFlushBuffersFile(hDevice, &ioStatusBlock);

	// Goto End
	ReturnTime = ReadLBA(hDevice, End, 1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	LBA = Start;
	while(Reps > 0) {
		// Access the LBA
		ReturnTime = ReadLBA(hDevice, LBA, 1);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
		}

		// Swap LBA between Start and End
		if(LBA == Start) {
			LBA = End;
		} else {
			LBA = Start;
		}
		Reps--;
	}

	// return average access time in ms
	ReturnVal *= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (DOUBLE)gFrequency.QuadPart;
	ReturnVal *= 1000.0;	// convert to ms
	return ReturnVal;
}


DOUBLE
StreamTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG MaxSectors) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG i, Reps;
	USHORT RemainSectors;
	NTSTATUS status;
	IO_STATUS_BLOCK ioStatusBlock;

	// Init Totaltime
	TotalTime.QuadPart = 0;

	// Compute Reps based on Sectors
	Reps = (End - Start)/MaxSectors;
	RemainSectors = (USHORT)((End - Start)%MaxSectors);

	// Flush Buffers
	status = NtFlushBuffersFile(hDevice, &ioStatusBlock);

	// Goto Start
	ReturnTime = ReadLBA(hDevice, Start, 1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	for(i=0; i<Reps; i++) {
		ReturnTime = ReadLBA(hDevice, i*MaxSectors + Start, MaxSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	if(RemainSectors > 0) {
		ReturnTime = ReadLBA(hDevice, Reps*MaxSectors + Start, RemainSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	// return elapsed time in mbits/s
	ReturnVal = (DOUBLE)(End - Start);
	ReturnVal *= (DOUBLE)gDiskGeometry.BytesPerSector;
	ReturnVal *= (DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (1024*1024);	// convert to MBytes
	return ReturnVal;
}


//
// HDPerf_SetPowerMode
//		Send AT command to drive
//
BOOL
HDPerf_SetPowerMode(HANDLE hDevice, UCHAR Command) {
	ATA_PASS_THROUGH	AtaPassThrough;
	DWORD cbBytesReturned;
	BOOL bReturn;

	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = Command;
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBuffer = NULL;

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		HDPerf_LogAtaPassThrough(AtaPassThrough);
		return FALSE;
	} else {
		return TRUE;
	}
}


DOUBLE
StartUpTime(HANDLE hDevice, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	ULONG i;
	DOUBLE ReturnVal;

	TotalTime.QuadPart = 0;

	for(i = 0; i < Reps; i++) {
		// Put drive in Standby mode
		if(!HDPerf_SetPowerMode(hDevice, AT_STANDBY_IMMEDIATE)) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode(AT_STANDBY_IMMEDIATE) FAILED");
			return 0;
		}
	
		// Wait for drive to spin down
		Sleep(6000);

		// Read from drive
		ReturnTime = ReadLBA(hDevice, 0, 1);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
		}
	}

	// Return average Startup time
	ReturnVal = (DOUBLE)TotalTime.QuadPart/(DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)Reps;
	return ReturnVal;
}


//
// Peak sequential streaming throughput - both write and read
//
VOID
FileReadWriteTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	DWORD BufferSize;
	DWORD Bytes, TotalBytes;
	LARGE_INTEGER BytesToMove, StartTime, EndTime, Frequency;
	DOUBLE Rate;

	// Initialize
	xSetFunctionName(LogHandle, "FileReadWriteTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}
	
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		// Creat file for write
		hFile = CreateFile(TESTFILENAME, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Size file
		BytesToMove.QuadPart = TESTFILESIZE;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}
		if(!SetEndOfFile(hFile)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetEndOfFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Go back to the beginning
		BytesToMove.QuadPart = 0;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}

		// Write file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!WriteFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		CloseHandle(hFile);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_PASS, "Sequential File Write (%3uKB Buffer) %f KB/s",
			BufferSize/KB, Rate);

		// Open file for read
		hFile = CreateFile(TESTFILENAME, GENERIC_READ, 0, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Read file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential File Read  (%3uKB Buffer) %f KB/s", BufferSize/KB, Rate);

		CloseHandle(hFile);

		DeleteFile(TESTFILENAME);
	}

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Raw read streaming from various part of the hard disk
//
VOID 
RawReadTest(HANDLE LogHandle, DWORD BufferSize) {
	HANDLE hDevice;
	DISK_GEOMETRY DiskGeometry;
	VOID* Buffer;
	DWORD BytesReturned;
	LARGE_INTEGER DeviceOffset, SampleOffset, MaxOffset;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DOUBLE Rate;
	BOOL bReturn;

    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;


	// Initialize
	xSetFunctionName(LogHandle, "RawReadTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);

	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	for(DeviceOffset.QuadPart = 0; DeviceOffset.QuadPart <= MaxOffset.QuadPart - SAMPLEREADSIZE; DeviceOffset.QuadPart += SAMPLEBLOCKSIZE) {
		// Read SAMPLEREADSIZE at Offset
		SampleOffset.QuadPart = DeviceOffset.QuadPart;
		QueryPerformanceCounter(&StartTime);
        do {
			status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &SampleOffset);
            if(!NT_SUCCESS(status)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtReadFile() FAILED Status = %d", status);
				return;
			}
			// Increment the SampleOffset
            SampleOffset.QuadPart += BufferSize;
        } while ((SampleOffset.QuadPart -  DeviceOffset.QuadPart) <= SAMPLEREADSIZE);
		QueryPerformanceCounter(&EndTime);

		// Compute read rate
		Rate = (DOUBLE)SAMPLEREADSIZE;
		Rate /= (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)1024;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read Block %#.9I64x %f KB/s", DeviceOffset.QuadPart, Rate);
    }

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Random raw reads to measure seek time
//
VOID RandomRawDiskRead(HANDLE LogHandle, DWORD BufferSize) {
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE hDevice;
	VOID* Buffer;
	DISK_GEOMETRY DiskGeometry;
	DWORD BytesReturned;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	LARGE_INTEGER Offset, MaxOffset;
	DWORD MaxBuffers, TotalBytesRead;
	DOUBLE Rate;
	BOOL bReturn;

	// Initialize
	xSetFunctionName(LogHandle, "RandomRawDiskRead");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);
	srand('RAWR');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);
	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	//Maximum number of buffer sized chunks
    MaxBuffers = (DWORD)MaxOffset.QuadPart/BufferSize;
    TotalBytesRead = 0;

	// Read TESTFILESIZE bytes at random locations
	QueryPerformanceCounter(&StartTime);
    do {
        Offset.QuadPart = rand()*MaxBuffers/RAND_MAX;
        Offset.QuadPart *= BufferSize;
        status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &Offset);
        TotalBytesRead += BufferSize;
    } while (TotalBytesRead < TESTFILESIZE);
	QueryPerformanceCounter(&EndTime);

	// Compute read rate
	Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
	Rate *= (DOUBLE)Frequency.QuadPart;
	Rate /= (DOUBLE)KB;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %f KB/s", Rate);

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Small file creation test to measure caching effects
//
VOID SmallFileCreationTest(HANDLE LogHandle) {
	HANDLE hFile;
    CHAR FileName[MAX_PATH];
	VOID* Buffer;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DWORD FileSize, Bytes;
	DOUBLE Time;
	int i;

	// Initialize
	xSetFunctionName(LogHandle, "SmallFileCreationTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Small File Creation Test: %u files", FILECOUNT);
	QueryPerformanceFrequency(&Frequency);
	srand('DIRS');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXSMALLFILESIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXSMALLFILESIZE, GetLastError());
		return;
	}

	// Create test directory
    CreateDirectory(TESTDIRNAME, NULL);
		
	// Create files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH,
                        NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile(%s) FAILED LastError = %d", FileName, GetLastError());
			return;
		}

		FileSize= rand() % MAXSMALLFILESIZE + 1;
        if(!WriteFile(hFile, Buffer, FileSize, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%s, %u bytes) FAILED LastError = %d", 
					FileName, FileSize, GetLastError());
			return;
		}

		CloseHandle(hFile);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Create %u Small Files: %f ms", FILECOUNT, Time);

    // Delete files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        DeleteFile(FileName);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Delete %u Small Files: %f ms", FILECOUNT, Time);

    RemoveDirectory(TESTDIRNAME);

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Simple disk cache test
//
VOID DiskCacheTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	LARGE_INTEGER ReadStartTime, ReadEndTime, WriteStartTime, WriteEndTime, Frequency;
	DWORD BufferSize, Bytes, TotalBytes, Offset;
	DOUBLE ReadTime[READBUFSIZE/WRITEBUFSIZE], WriteTime[READBUFSIZE/WRITEBUFSIZE];
	DOUBLE ReadTimeSeq[6][4], ReadTimeScat[6][4];
	int i, j;

	// Initialize
	xSetFunctionName(LogHandle, "DiskCacheTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}

	// Open file
    hFile = CreateFile("z:", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL| FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
	
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
		return;
	}

    //
    // Interleaved reads and writes
    //
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		// Goto STARTINGPOS
        if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		TotalBytes = 0;

		// Read CACHEFILESIZE bytes
		QueryPerformanceCounter(&ReadStartTime);
        do {
            if(!ReadFile(hFile, Buffer, READBUFSIZE, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
				return;
			}
            TotalBytes += Bytes;
        } while (TotalBytes < CACHEFILESIZE);
		QueryPerformanceCounter(&ReadEndTime);

		// Goto write spot
        if(SetFilePointer(hFile, STARTINGPOS + CACHEFILESIZE - READBUFSIZE + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		// Write WRITEBUFSIZE bytes
		QueryPerformanceCounter(&WriteStartTime);
		if(!WriteFile(hFile, (CHAR*) Buffer + Offset, WRITEBUFSIZE, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile() FAILED LastError = %d", GetLastError());
			return;
		}
		QueryPerformanceCounter(&WriteEndTime);

		// Store results
		ReadTime[j] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		WriteTime[j] = (DOUBLE)(WriteEndTime.QuadPart - WriteStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		j++;
    }

    //
    // Reads same 256KB of data using different buffer sizes
    //
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			// Goto STARTINGPOS
			if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
				return;
			}
            
            TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
	            TotalBytes += Bytes;
		    } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeSeq[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    //
    // Read 256KB scattered
    //
	j = 0;
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			Offset = 0;
			TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
				SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN);
				ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL);
				//
				if(SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
					return;
				}

	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
				//
	            TotalBytes += Bytes;
				Offset += MB;
	        } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeScat[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    CloseHandle(hFile);
		
	VirtualFree(Buffer, 0, MEM_RELEASE);

	// Log Interleaved results
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %uKB %fms Write (Offset %u bytes): %fms", CACHEFILESIZE/KB, ReadTime[j], Offset, WriteTime[j]); 
		j++;
	}

	// Log Sequential results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeSeq[j][i]); 
		}
		j++;
	}

	// Log Scattered results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u Scattered: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeScat[j][i]); 
		}
		j++;
	}
}


VOID
WINAPI
HDPerfStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	BOOL bReturn;
    DWORD cbBytesReturned;
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
	ATA_PASS_THROUGH	AtaPassThrough, AtaPassThroughOut;
	IDE_IDENTIFY_DATA	IdeIdData;
	DOUBLE dTime;
	ULONG StartUpReps;
	ULONG TrackToTrackStartLBA, TrackToTrackEndLBA, TrackToTrackReps;
	ULONG FullStartLBA, FullEndLBA, FullReps;
	ULONG StreamStartLBA, StreamEndLBA;
	ULONG MaxLBA;
	ULONG MaxSectors = 0, i;

	// Set global log handle
	gLogHandle = LogHandle;

	xSetOwnerAlias(gLogHandle, "a-emebac");
	xSetComponent(gLogHandle, "Hardware", "HDPerf");
	xSetFunctionName(gLogHandle, "Initialization");

	// Get timer frequency (ticks/sec)
	QueryPerformanceFrequency(&gFrequency);


	// open device
	RtlInitObjectString(&objectName, "\\Device\\Harddisk0\\Partition0");
	InitializeObjectAttributes(&objectAttributes, &objectName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	status = NtOpenFile(&hDevice, 
							GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
							&objectAttributes,
							&ioStatusBlock,
							0,
							FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

	if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "NtOpenFile FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&gDiskGeometry, 0, sizeof(gDiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&gDiskGeometry, sizeof(gDiskGeometry), 
								&cbBytesReturned, NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_DISK_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
		CloseHandle(hDevice);
		return;
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.QuadPart);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "TracksPerCylinder = %u", gDiskGeometry.TracksPerCylinder);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u", gDiskGeometry.SectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "BytesPerSector = %u", gDiskGeometry.BytesPerSector);

	// Populate pass through command for Identify Device
	memset(&IdeIdData, 0, sizeof(IDE_IDENTIFY_DATA));
	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = 0xec;						// Identify Device DMA
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBufferSize = sizeof(IDE_IDENTIFY_DATA);
	AtaPassThrough.DataBuffer = &IdeIdData;

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);
	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IDENTIFY DEVICE FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		HDPerf_LogAtaPassThrough(AtaPassThrough);
		CloseHandle(hDevice);
		return;
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u",						IdeIdData.NumberOfCylinders);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Heads = %u",							IdeIdData.NumberOfHeads);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u",					IdeIdData.NumberOfSectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Cylinders = %u",				IdeIdData.NumberOfCurrentCylinders);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Heads = %u",					IdeIdData.NumberOfCurrentHeads);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current SectorsPerTrack = %u",			IdeIdData.CurrentSectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Sector Capacity = %u",			IdeIdData.CurrentSectorCapacity);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Multi Sector Setting = %u",	IdeIdData.CurrentMultiSectorSetting);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "User Addressable Sectors = %u",		IdeIdData.UserAddressableSectors);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MultiWordDMASupport = %u",				IdeIdData.MultiWordDMASupport);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MultiWordDMAActive = %u",				IdeIdData.MultiWordDMAActive);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "UltraDMASupport = %u",					IdeIdData.UltraDMASupport);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "UltraDMAActive = %u",					IdeIdData.UltraDMAActive);

	// Populate pass through command for Disable read look-ahead
	
	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = 0xef;						// Set features
	AtaPassThrough.IdeReg.bFeaturesReg = 0x55;						// Disable read look-ahead
	AtaPassThrough.IdeReg.bSectorCountReg = 0;
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBufferSize = 0;
	AtaPassThrough.DataBuffer = NULL;

	memset(&AtaPassThroughOut, 0, sizeof(ATA_PASS_THROUGH));

	/*
	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);
	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SET FEATURES: Disable read look-ahead FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		HDPerf_LogAtaPassThrough(AtaPassThrough);
		return;
	}
	*/

	// Get parameters from ini file
	MaxLBA = IdeIdData.UserAddressableSectors - 1;
	StartUpReps = GetProfileInt(TEXT("hdperf"), TEXT("StartUpReps"), 10);
	TrackToTrackStartLBA = GetProfileInt(TEXT("hdperf"), TEXT("TrackToTrackStartLBA"), 585);
	TrackToTrackEndLBA = GetProfileInt(TEXT("hdperf"), TEXT("TrackToTrackEndLBA"), 586);
	TrackToTrackReps = GetProfileInt(TEXT("hdperf"), TEXT("TrackToTrackReps"), 200);
	FullStartLBA = GetProfileInt(TEXT("hdperf"), TEXT("FullStartLBA"), 0);
	FullEndLBA = GetProfileInt(TEXT("hdperf"), TEXT("FullEndLBA"), MaxLBA);
	FullReps = GetProfileInt(TEXT("hdperf"), TEXT("FullReps"), 200);
	StreamStartLBA = GetProfileInt(TEXT("hdperf"), TEXT("StreamStartLBA"), 0);
	StreamEndLBA = GetProfileInt(TEXT("hdperf"), TEXT("StreamEndLBA"), 1048576/gDiskGeometry.BytesPerSector);	// 1MB

	// Startup time
	xSetFunctionName(gLogHandle, "StartUpTime");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Average Startup Time: Reps = %u", StartUpReps);
	dTime = StartUpTime(hDevice, StartUpReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Startup Time = %f s", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Startup Time FAILED");
	}

	// Measure Track to Track access times
	xSetFunctionName(gLogHandle, "AccessTime");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Track to Track: Start LBA = %u End LBA = %u Reps = %u", TrackToTrackStartLBA, TrackToTrackEndLBA, TrackToTrackReps);
	dTime = HDAccessTime(hDevice, TrackToTrackStartLBA, TrackToTrackEndLBA, TrackToTrackReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Track to Track Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Track to Track Access Time FAILED");
	}

	// Measure full-stroke access time
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Full-Stroke Start LBA = %u, End LBA = %u, Reps = %u", FullStartLBA, FullEndLBA, FullReps);
	dTime = HDAccessTime(hDevice, FullStartLBA, FullEndLBA, FullReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Full-Stroke Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Full-Stroke Access Time FAILED");
	}

	// Measure data stream rate
	xSetFunctionName(gLogHandle, "StreamTime");
	for(i = 0; i <= 8; i++) {
		MaxSectors = 1<<i;
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Stream Rate Start LBA = %u, End LBA = %u, Read Buffer = %u bytes", StreamStartLBA, StreamEndLBA, MaxSectors*gDiskGeometry.BytesPerSector);
		dTime = StreamTime(hDevice, StreamStartLBA, StreamEndLBA, MaxSectors);
		if(dTime > 0) {
			xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Sustained Data Rate = %f MBytes/s", dTime);
		} else {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Sustained Data Rate FAILED");
		}
	}

	// close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CloseHandle FAILED LastError = %d", GetLastError());
	}

	// File tests
	if(GetProfileIntA("hdperf", "FileReadWriteTest", 1)) {
		FileReadWriteTest(LogHandle);
	}
    
	if(GetProfileIntA("hdperf", "RawReadTest", 1)) {
		RawReadTest(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf", "SmallFileCreationTest", 1)) {
		SmallFileCreationTest(LogHandle);
	}

	if(GetProfileIntA("hdperf", "RandomRawDiskRead", 1)) {
		RandomRawDiskRead(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf", "DiskCacheTest", 1)) {
		DiskCacheTest(LogHandle);
	}
}


VOID WINAPI
HDPerfEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	// xSetFontA(12.0, 18.0, NULL);
	
	// xlog
	gLogHandle = xCreateLog_A("t:\\hdperf.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(gLogHandle == INVALID_HANDLE_VALUE ) {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "HDPerf: couldn't create log (%s)", WinErrorSymbolicName(GetLastError()));
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "HDPerf: End - Waiting for reboot...");
		Sleep(INFINITE);
    }

	gbConsoleOut = TRUE;


	// Start Test
	HDPerfStartTest(gLogHandle);

	// End Test
	HDPerfEndTest();

	// xlog
	xCloseLog(gLogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "hdperf: End - Waiting for reboot...");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( hdperf )
#pragma data_seg()

BEGIN_EXPORT_TABLE( hdperf )
    EXPORT_TABLE_ENTRY( "StartTest", HDPerfStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", HDPerfEndTest )
END_EXPORT_TABLE( hdperf )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hdperf_sw\hdperf_sw.cpp ===
//
//	hdperf_sw.cpp
//
//		Hard disk performance test using higher level functions to represent
//		game like usage.
//		Based on David Xu's test.
//		
#include <ntos.h>
#include <xtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define KB              1024
#define MB              (KB*KB)
#define MINBUFSIZE      (4*KB)
#define MAXBUFSIZE      (128*KB)
#define TESTFILESIZE    (64*MB)
#define TESTDIRNAME     "z:\\test"
#define TESTFILENAME    "z:\\perftest.dat"
#define SAMPLEBLOCKSIZE (256*MB)
#define SAMPLEREADSIZE  (16*MB)
#define SECTORSIZE      512
#define MAXSMALLFILESIZE (4*KB)
#define FILECOUNT        2048
#define READBUFSIZE     (4*KB)
#define WRITEBUFSIZE    512
#define CACHEFILESIZE   (256*KB)
#define STARTINGPOS     (16*MB)


//
// Peak sequential streaming throughput - both write and read
//
VOID
FileReadWriteTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	DWORD BufferSize;
	DWORD Bytes, TotalBytes;
	LARGE_INTEGER BytesToMove, StartTime, EndTime, Frequency;
	DOUBLE Rate;

	// Initialize
	xSetFunctionName(LogHandle, "FileReadWriteTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}
	
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		// Creat file for write
		hFile = CreateFile(TESTFILENAME, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Size file
		BytesToMove.QuadPart = TESTFILESIZE;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}
		if(!SetEndOfFile(hFile)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetEndOfFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Go back to the beginning
		BytesToMove.QuadPart = 0;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}

		// Write file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!WriteFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		CloseHandle(hFile);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_PASS, "Sequential File Write (%3uKB Buffer) %f KB/s",
			BufferSize/KB, Rate);

		// Open file for read
		hFile = CreateFile(TESTFILENAME, GENERIC_READ, 0, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Read file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential File Read  (%3uKB Buffer) %f KB/s", BufferSize/KB, Rate);

		CloseHandle(hFile);

		DeleteFile(TESTFILENAME);
	}

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Raw read streaming from various part of the hard disk
//
VOID 
RawReadTest(HANDLE LogHandle, DWORD BufferSize) {
	HANDLE hDevice;
	DISK_GEOMETRY DiskGeometry;
	VOID* Buffer;
	DWORD BytesReturned;
	LARGE_INTEGER DeviceOffset, SampleOffset, MaxOffset;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DOUBLE Rate;
	BOOL bReturn;

    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;


	// Initialize
	xSetFunctionName(LogHandle, "RawReadTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);

	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	for(DeviceOffset.QuadPart = 0; DeviceOffset.QuadPart <= MaxOffset.QuadPart - SAMPLEREADSIZE; DeviceOffset.QuadPart += SAMPLEBLOCKSIZE) {
		// Read SAMPLEREADSIZE at Offset
		SampleOffset.QuadPart = DeviceOffset.QuadPart;
		QueryPerformanceCounter(&StartTime);
        do {
			status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &SampleOffset);
            if(!NT_SUCCESS(status)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtReadFile() FAILED Status = %d", status);
				return;
			}
			// Increment the SampleOffset
            SampleOffset.QuadPart += BufferSize;
        } while ((SampleOffset.QuadPart -  DeviceOffset.QuadPart) <= SAMPLEREADSIZE);
		QueryPerformanceCounter(&EndTime);

		// Compute read rate
		Rate = (DOUBLE)SAMPLEREADSIZE;
		Rate /= (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)1024;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read Block %#.9I64x %f KB/s", DeviceOffset.QuadPart, Rate);
    }

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Random raw reads to measure seek time
//
VOID RandomRawDiskRead(HANDLE LogHandle, DWORD BufferSize) {
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE hDevice;
	VOID* Buffer;
	DISK_GEOMETRY DiskGeometry;
	DWORD BytesReturned;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	LARGE_INTEGER Offset, MaxOffset;
	DWORD MaxBuffers, TotalBytesRead;
	DOUBLE Rate;
	BOOL bReturn;

	// Initialize
	xSetFunctionName(LogHandle, "RandomRawDiskRead");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);
	srand('RAWR');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);
	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	//Maximum number of buffer sized chunks
    MaxBuffers = (DWORD)MaxOffset.QuadPart/BufferSize;
    TotalBytesRead = 0;

	// Read TESTFILESIZE bytes at random locations
	QueryPerformanceCounter(&StartTime);
    do {
        Offset.QuadPart = rand()*MaxBuffers/RAND_MAX;
        Offset.QuadPart *= BufferSize;
        status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &Offset);
        TotalBytesRead += BufferSize;
    } while (TotalBytesRead < TESTFILESIZE);
	QueryPerformanceCounter(&EndTime);

	// Compute read rate
	Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
	Rate *= (DOUBLE)Frequency.QuadPart;
	Rate /= (DOUBLE)KB;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %f KB/s", Rate);

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Small file creation test to measure caching effects
//
VOID SmallFileCreationTest(HANDLE LogHandle) {
	HANDLE hFile;
    CHAR FileName[MAX_PATH];
	VOID* Buffer;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DWORD FileSize, Bytes;
	DOUBLE Time;
	int i;

	// Initialize
	xSetFunctionName(LogHandle, "SmallFileCreationTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Small File Creation Test: %u files", FILECOUNT);
	QueryPerformanceFrequency(&Frequency);
	srand('DIRS');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXSMALLFILESIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXSMALLFILESIZE, GetLastError());
		return;
	}

	// Create test directory
    CreateDirectory(TESTDIRNAME, NULL);
		
	// Create files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH,
                        NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile(%s) FAILED LastError = %d", FileName, GetLastError());
			return;
		}

		FileSize= rand() % MAXSMALLFILESIZE + 1;
        if(!WriteFile(hFile, Buffer, FileSize, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%s, %u bytes) FAILED LastError = %d", 
					FileName, FileSize, GetLastError());
			return;
		}

		CloseHandle(hFile);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Create %u Small Files: %f ms", FILECOUNT, Time);

    // Delete files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        DeleteFile(FileName);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Delete %u Small Files: %f ms", FILECOUNT, Time);

    RemoveDirectory(TESTDIRNAME);

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Simple disk cache test
//

VOID DiskCacheTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	LARGE_INTEGER ReadStartTime, ReadEndTime, WriteStartTime, WriteEndTime, Frequency;
	DWORD BufferSize, Bytes, TotalBytes, Offset;
	DOUBLE ReadTime[READBUFSIZE/WRITEBUFSIZE], WriteTime[READBUFSIZE/WRITEBUFSIZE];
	DOUBLE ReadTimeSeq[6][4], ReadTimeScat[6][4];
	int i, j;

	// Initialize
	xSetFunctionName(LogHandle, "DiskCacheTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}

	// Open file
    hFile = CreateFile("z:", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL| FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
	
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
		return;
	}

    //
    // Interleaved reads and writes
    //
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		// Goto STARTINGPOS
        if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		TotalBytes = 0;

		// Read CACHEFILESIZE bytes
		QueryPerformanceCounter(&ReadStartTime);
        do {
            if(!ReadFile(hFile, Buffer, READBUFSIZE, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
				return;
			}
            TotalBytes += Bytes;
        } while (TotalBytes < CACHEFILESIZE);
		QueryPerformanceCounter(&ReadEndTime);

		// Goto write spot
        if(SetFilePointer(hFile, STARTINGPOS + CACHEFILESIZE - READBUFSIZE + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		// Write WRITEBUFSIZE bytes
		QueryPerformanceCounter(&WriteStartTime);
		if(!WriteFile(hFile, (CHAR*) Buffer + Offset, WRITEBUFSIZE, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile() FAILED LastError = %d", GetLastError());
			return;
		}
		QueryPerformanceCounter(&WriteEndTime);

		// Store results
		ReadTime[j] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		WriteTime[j] = (DOUBLE)(WriteEndTime.QuadPart - WriteStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		j++;
    }

    //
    // Reads same 256KB of data using different buffer sizes
    //
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			// Goto STARTINGPOS
			if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
				return;
			}
            
            TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
	            TotalBytes += Bytes;
		    } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeSeq[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    //
    // Read 256KB scattered
    //
	j = 0;
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			Offset = 0;
			TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
				SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN);
				ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL);
				//
				if(SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
					return;
				}

	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
				//
	            TotalBytes += Bytes;
				Offset += MB;
	        } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeScat[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    CloseHandle(hFile);
		
	VirtualFree(Buffer, 0, MEM_RELEASE);

	// Log Interleaved results
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %uKB %fms Write (Offset %u bytes): %fms", CACHEFILESIZE/KB, ReadTime[j], Offset, WriteTime[j]); 
		j++;
	}

	// Log Sequential results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeSeq[j][i]); 
		}
		j++;
	}

	// Log Scattered results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u Scattered: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeScat[j][i]); 
		}
		j++;
	}
}


VOID 
HDPerfSWStartTest(HANDLE LogHandle) {

	xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "HDPerf_sw");

	if(GetProfileIntA("hdperf_sw", "FileReadWriteTest", 1)) {
		FileReadWriteTest(LogHandle);
	}
    
	if(GetProfileIntA("hdperf_sw", "RawReadTest", 1)) {
		RawReadTest(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf_sw", "SmallFileCreationTest", 1)) {
		SmallFileCreationTest(LogHandle);
	}

	if(GetProfileIntA("hdperf_sw", "RandomRawDiskRead", 1)) {
		RandomRawDiskRead(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf_sw", "DiskCacheTest", 1)) {
		DiskCacheTest(LogHandle);
	}
}

VOID 
HDPerfSWEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	HANDLE LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	// xSetFontA(12.0, 18.0, NULL);
	
	// xlog
	LogHandle = xCreateLog_A("t:\\hdperf_sw.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("HDPerf_sw: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		xDebugStringA("HDPerf_sw: End - Waiting for reboot...\n");
		Sleep(INFINITE);
    }

	gbConsoleOut = TRUE;

	// Start Test
	HDPerfSWStartTest(LogHandle);

	// End Test
	HDPerfSWEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("HDPerf_sw: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( hdperf_sw )
#pragma data_seg()

BEGIN_EXPORT_TABLE( hdperf_sw )
    EXPORT_TABLE_ENTRY( "StartTest", HDPerfSWStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", HDPerfSWEndTest )
END_EXPORT_TABLE( hdperf_sw )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hdrw\hdrw.cpp ===
#include <ntos.h>
#include <ntdddisk.h>
#include <xtl.h>
#include <xtestlib.h>
#include <dxconio.h>

// Globals
HANDLE ghGamePads[4];
BOOL gbPause = FALSE;
BOOL gbQuit = FALSE;


void
DumpBuffer(PUCHAR Buffer, ULONG BufferSize) {
	ULONG i, j;

	for(i = 0; i < BufferSize/24; i++) {
		for(j = 0; j < 24; j++) {
			xDebugStringA("%.2x ", Buffer[i*20 + j]);
		}
		xDebugStringA("\n");
	}
}

void
InitGamePads() {
	DWORD i;
	XDEVICE_PREALLOC_TYPE xdpt;

	// Initialize gamepads
	xdpt.DeviceType = XDEVICE_TYPE_GAMEPAD;
	xdpt.dwPreallocCount = 4;

	XInitDevices(1, &xdpt);

	// Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Open the devices
	for(i = 0; i < 4; i++){
		// Initialize game pad array
		ghGamePads[i] = NULL;

        if( dwDeviceMask & (1<<i) ) {
            // Get a handle to the device
            ghGamePads[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
			xDebugStringA("Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
        }
	}
}


void
ReadGamePads() {
	DWORD dwInsertions, dwRemovals;
	DWORD b, i, Buttons = 0;
	XINPUT_STATE State;
	BOOL AnalogButtons[8];

	// Get gamepad insertions and removals
	XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals);
	for(i = 0; i < 4; i++) {
		// Handle removed devices.
		if(dwRemovals & (1<<i) ) {
			XInputClose( ghGamePads[i]);
			xDebugStringA("HD RW: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}

		// Handle inserted devices
		if(dwInsertions & (1<<i)) {
			ghGamePads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
			xDebugStringA("HD RW: Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
		}
	}

	// Init button variables
	Buttons = 0;
	for(b = 0; b < 8; b++) {
		AnalogButtons[b] = FALSE;
	}

	// Get button presses
	for(i = 0; i < 4; i++) {
		if(ghGamePads[i] != NULL) {
			XInputGetState(ghGamePads[i], &State);

			// Digital buttons
			Buttons |= State.Gamepad.wButtons;

			// Analog buttons (threshold = 25/256)
			for(b = 0; b < 8; b++) {
				AnalogButtons[b] |= (State.Gamepad.bAnalogButtons[b] > 25);
			}
		}
	}

	// Check button presses
	// Back button pauses app
	if((Buttons & XINPUT_GAMEPAD_BACK) > 0) {
		if(!gbPause) {
			xDebugStringA("HD RW: Application Paused\n");
			gbPause = TRUE;
		}
	}

	// Start button unpauses app
	if((Buttons & XINPUT_GAMEPAD_START) > 0 ) {
		if(gbPause) {
			xDebugStringA("HD RW: Application NOT Paused\n");
			gbPause = FALSE;
		}
	}

	// Both triggers plus Black button quits app (from Samples)
	if(AnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_BLACK]) {
		if(!gbQuit) {
			xDebugStringA("HD RW: Application Quiting...\n");
			gbQuit = TRUE;
		}
	}
}


void
CloseGamePads() {
	DWORD i;

	for(i = 0; i < 4; i++ ) {
		if(ghGamePads[i] != NULL) {
			XInputClose(ghGamePads[i]);
			xDebugStringA("HD RW: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}
	}
}


void
__cdecl main() {
	HANDLE hFile;

	DWORD BytesRead;
	BOOL  bRO, bWO;

	ULONG FileSize, TimeDuration;
	LONG BufferSize;

	LARGE_INTEGER CurrentTime, EndTime, Frequency;
	LARGE_INTEGER BytesToMove;

	PUCHAR Buffer;

	// Initialize Console Output
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	xDebugStringA("HD RW: Press the 'Back' button to Pause the application.\n");
	xDebugStringA("HD RW: Press the 'Start' button to Resume the application.\n");
	xDebugStringA("HD RW: Press both triggers and the 'Black' button to quit the application.\n");

	// Initialize Game Pads
	InitGamePads();

	// Allocate buffer
	BufferSize = 512;
	Buffer = (PUCHAR)GlobalAlloc(GPTR, BufferSize);
	if(Buffer == NULL) {
		xDebugStringA("GlobalAlloc(Buffer) FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}

	// Get file size from testini.ini
	FileSize = GetProfileIntA("hdrw", "FileSize", 8);
	xDebugStringA("HD RW: File Size = %u MB\n", FileSize);

	// Get read only flag from testini.ini
	if(GetProfileIntA("hdrw", "ReadOnly", 1) == 1) {
		bRO = TRUE;
	} else {
		bRO = FALSE;
	}
	
	// Get write only flag from testini.ini
	if(GetProfileIntA("hdrw", "WriteOnly", 0) == 1) {
		bWO = TRUE;
	} else {
		bWO = FALSE;
	}

	if(bRO && bWO) {
		xDebugStringA("HD RW: Read/Write\n");
	} else if(bRO && !bWO) {
		xDebugStringA("HD RW: Read Only\n");
	} else if(!bRO && bWO) {
		xDebugStringA("HD RW: Write Only\n");
	} else {
		xDebugStringA("HD RW: Nothing\n");
	}

	// Get time to run from testini.ini
	TimeDuration = GetProfileIntA("hdrw", "TimeDuration", 0);
	if(TimeDuration == 0) {
		xDebugStringA("HD RW: Time Duration = Run Forever\n");
	} else {
		xDebugStringA("HD RW: Time Duration = %u secs\n", TimeDuration);
	}
	QueryPerformanceFrequency(&Frequency);
	QueryPerformanceCounter(&CurrentTime);
	EndTime.QuadPart = CurrentTime.QuadPart + Frequency.QuadPart*TimeDuration;

	// Open file
	hFile = CreateFile("t:\\hdrwtest.txt", GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
		FILE_FLAG_NO_BUFFERING | FILE_FLAG_DELETE_ON_CLOSE, NULL);
	if(hFile == INVALID_HANDLE_VALUE) { 
		xDebugStringA("CreateFile(%s) FAILED LastError = %d\n", "t:\\hdrwtest.txt", GetLastError());
		Sleep(INFINITE);
	}
	
	// Size the file
	BytesToMove.QuadPart = FileSize*1024*1024;
	if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
		xDebugStringA("SetFilePointerEx(%u bytes) FAILED LastError = %d\n", BytesToMove.QuadPart, GetLastError());
		Sleep(INFINITE);
	}

	if(!SetEndOfFile(hFile)) {
		xDebugStringA("SetEndOfFile FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}

	while(!gbQuit) {
		if(!gbPause) {
			if(bRO) {
				// Read at beginning of file
				BytesToMove.QuadPart = 0;
				if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
					xDebugStringA("SetFilePointerEx(%u bytes) FAILED LastError = %d\n", BytesToMove.QuadPart, GetLastError());
					Sleep(INFINITE);
				}
				if(!ReadFile(hFile, Buffer, BufferSize, &BytesRead, NULL)) {
					xDebugStringA("ReadFile() FAILED LastError = %d\n", GetLastError());
					Sleep(INFINITE);
				}

				// Read at end of file
				BytesToMove.QuadPart = -BufferSize;
				if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_END)) {
					xDebugStringA("SetFilePointerEx(%u bytes) FAILED LastError = %d\n", BytesToMove.QuadPart, GetLastError());
					Sleep(INFINITE);
				}
				if(!ReadFile(hFile, Buffer, BufferSize, &BytesRead, NULL)) {
					xDebugStringA("ReadFile() FAILED LastError = %d\n", GetLastError());
					Sleep(INFINITE);
				}
			}

			if(bWO) {
				// Read at beginning of file
				BytesToMove.QuadPart = 0;
				if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
					xDebugStringA("SetFilePointerEx(%u bytes) FAILED LastError = %d\n", BytesToMove.QuadPart, GetLastError());
					Sleep(INFINITE);
				}
				if(!WriteFile(hFile, Buffer, BufferSize, &BytesRead, NULL)) {
					xDebugStringA("WriteFile() FAILED LastError = %d\n", GetLastError());
					Sleep(INFINITE);
				}

				// Write at end of file
				BytesToMove.QuadPart = -BufferSize;
				if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_END)) {
					xDebugStringA("SetFilePointerEx(%u bytes) FAILED LastError = %d\n", BytesToMove.QuadPart, GetLastError());
					Sleep(INFINITE);
				}
				if(!WriteFile(hFile, Buffer, BufferSize, &BytesRead, NULL)) {
					xDebugStringA("WrtieFile() FAILED LastError = %d\n", GetLastError());
					Sleep(INFINITE);
				}
			}
		}

		// Get button presses
		ReadGamePads();

		// Check time duration
		if(TimeDuration != 0) {
			QueryPerformanceCounter(&CurrentTime);
			if(CurrentTime.QuadPart > EndTime.QuadPart) {
				break;
			}
		}
	}

	// Close device
	CloseHandle(hFile);

	// Close gamepads
	CloseGamePads();

	// Free buffers
	GlobalFree(Buffer);

	// Close console
	xReleaseConsole();

	// Reboot
	XLaunchNewImage(NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hdperf_ll\hdperf_ll.cpp ===
//
//	hdperf.cpp
//	Hard drive performance test using low level commands
//

#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddscsi.h>
#include <scsi.h>
#include <align.h>
#include <stdio.h>
#include <stdlib.h>
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>


#define KB              1024
#define MB              (KB*KB)
#define MINBUFSIZE      (4*KB)
#define MAXBUFSIZE      (128*KB)
#define TESTFILESIZE    (64*MB)
#define TESTDIRNAME     "z:\\test"
#define TESTFILENAME    "z:\\perftest.dat"
#define SAMPLEBLOCKSIZE (256*MB)
#define SAMPLEREADSIZE  (16*MB)
#define SECTORSIZE      512
#define MAXSMALLFILESIZE (4*KB)
#define FILECOUNT        2048
#define READBUFSIZE     (4*KB)
#define WRITEBUFSIZE    512
#define CACHEFILESIZE   (256*KB)
#define STARTINGPOS     (16*MB)

// AT Commands
#define AT_STANDBY_IMMEDIATE	0xE0	// 0x94 or 0xE0
#define AT_IDLE_IMMEDIATE		0xE1	// 0x95 or 0xE1
#define AT_STANDBY				0xE2	// 0x96 or 0xE2
#define AT_IDLE					0xE3	// 0x97 or 0xE3
#define AT_CHECK_POWER_MODE		0xE5	// 0x98 or 0xE5


// Globals
static HANDLE gLogHandle;
static DISK_GEOMETRY gDiskGeometry;
static LARGE_INTEGER gFrequency;


VOID
LogAtaPassThrough(ATA_PASS_THROUGH AtaPassThrough) {
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bFeaturesReg = %#x", AtaPassThrough.IdeReg.bFeaturesReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorCountReg = %#x", AtaPassThrough.IdeReg.bSectorCountReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bSectorNumberReg = %#x", AtaPassThrough.IdeReg.bSectorNumberReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylLowReg = %#x", AtaPassThrough.IdeReg.bCylLowReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCylHighReg = %#x", AtaPassThrough.IdeReg.bCylHighReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bDriveHeadReg = %#x", AtaPassThrough.IdeReg.bDriveHeadReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bCommandReg = %#x", AtaPassThrough.IdeReg.bCommandReg);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.IdeReg.bHostSendsData = %#x", AtaPassThrough.IdeReg.bHostSendsData);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "AtaPassThrough.DataBufferSize = %#x", AtaPassThrough.DataBufferSize);
}

VOID
LogDiskCacheInformation(DISK_CACHE_INFORMATION DiskCacheInformation) {
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ParametersSavable = %#x", DiskCacheInformation.ParametersSavable);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ReadCacheEnabled = %#x", DiskCacheInformation.ReadCacheEnabled);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.WriteCacheEnabled = %#x", DiskCacheInformation.WriteCacheEnabled);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ReadRetentionPriority = %#x", DiskCacheInformation.ReadRetentionPriority);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.WriteRetentionPriority = %#x", DiskCacheInformation.WriteRetentionPriority);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.DisablePrefetchTransferLength = %#x", DiskCacheInformation.DisablePrefetchTransferLength);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.PrefetchScalar = %#x", DiskCacheInformation.PrefetchScalar);
	if(DiskCacheInformation.PrefetchScalar == TRUE ) {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.Minimum = %#x", DiskCacheInformation.ScalarPrefetch.Minimum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.Maximum = %#x", DiskCacheInformation.ScalarPrefetch.Maximum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.ScalarPrefetch.MaximumBlocks = %#x", DiskCacheInformation.ScalarPrefetch.MaximumBlocks);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.BlockPrefetch.Minimum = %#x", DiskCacheInformation.BlockPrefetch.Minimum);
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "DiskCacheInformation.BlockPrefetch.Maximum = %#x", DiskCacheInformation.BlockPrefetch.Maximum);
	}
}


LARGE_INTEGER
ReadLBA(HANDLE hDevice, ULONG LBA, ULONG Sectors) {
	IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
	UCHAR *Buffer;
	ULONG BufferSize;
	LARGE_INTEGER StartTime, EndTime, ReturnValue, Offset;

	// Allocate Data Buffer
	BufferSize = Sectors*gDiskGeometry.BytesPerSector;
	Buffer = (UCHAR *)GlobalAlloc(GPTR, BufferSize);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "GlobalAlloc(Buffer %u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		ReturnValue.QuadPart = -1;
		return ReturnValue;
	}

	// Calculate Offset
	Offset.QuadPart = LBA*gDiskGeometry.BytesPerSector;

	// Start timer
	QueryPerformanceCounter(&StartTime);

	// Read bytes at offset
	status = NtReadFile(hDevice, NULL, NULL, NULL, &ioStatusBlock, Buffer, BufferSize, &Offset);

	// Stop timer
	QueryPerformanceCounter(&EndTime);

	if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "NtReadFile(%u Bytes at Offset %#x) FAILED Status = %d", 
			BufferSize, Offset.QuadPart, status);
		ReturnValue.QuadPart = -1;
	} else {
		// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "NtReadFile = %u Bytes at Offset %#x, %f ms", Bytes, Offset.QuadPart, 1000.0*(EndTime.QuadPart - StartTime.QuadPart)/gFrequency.QuadPart);
		ReturnValue.QuadPart = EndTime.QuadPart - StartTime.QuadPart;
	}

	GlobalFree(Buffer);

	return ReturnValue;
}


DOUBLE
HDAccessTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG LBA;
	NTSTATUS status;
	IO_STATUS_BLOCK ioStatusBlock;

	// Initialize
	TotalTime.QuadPart = 0;
	ReturnVal = 1.0/(DOUBLE)Reps;

	// Flush Buffers
	status = NtFlushBuffersFile(hDevice, &ioStatusBlock);

	// Goto End
	ReturnTime = ReadLBA(hDevice, End, 1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	LBA = Start;
	while(Reps > 0) {
		// Access the LBA
		ReturnTime = ReadLBA(hDevice, LBA, 1);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
		}

		// Swap LBA between Start and End
		if(LBA == Start) {
			LBA = End;
		} else {
			LBA = Start;
		}
		Reps--;
	}

	// return average access time in ms
	ReturnVal *= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (DOUBLE)gFrequency.QuadPart;
	ReturnVal *= 1000.0;	// convert to ms
	return ReturnVal;
}


DOUBLE
StreamTime(HANDLE hDevice, ULONG Start, ULONG End, ULONG MaxSectors) {
	LARGE_INTEGER ReturnTime, TotalTime;
	DOUBLE ReturnVal;
	ULONG i, Reps;
	USHORT RemainSectors;
	NTSTATUS status;
	IO_STATUS_BLOCK ioStatusBlock;

	// Init Totaltime
	TotalTime.QuadPart = 0;

	// Compute Reps based on Sectors
	Reps = (End - Start)/MaxSectors;
	RemainSectors = (USHORT)((End - Start)%MaxSectors);

	// Flush Buffers
	status = NtFlushBuffersFile(hDevice, &ioStatusBlock);

	// Goto Start
	ReturnTime = ReadLBA(hDevice, Start, 1);
	if(ReturnTime.QuadPart == -1) {
		return 0;
	}

	for(i=0; i<Reps; i++) {
		ReturnTime = ReadLBA(hDevice, i*MaxSectors + Start, MaxSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	if(RemainSectors > 0) {
		ReturnTime = ReadLBA(hDevice, Reps*MaxSectors + Start, RemainSectors);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
			// xLog(gbConsoleOut, gLogHandle, XLL_INFO, "ReturnTime = %d TotalTime = %u", ReturnTime.QuadPart, TotalTime.QuadPart);
		}
	}

	// return elapsed time in mbits/s
	ReturnVal = (DOUBLE)(End - Start);
	ReturnVal *= (DOUBLE)gDiskGeometry.BytesPerSector;
	ReturnVal *= (DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)TotalTime.QuadPart;
	ReturnVal /= (1024*1024);	// convert to MBytes
	return ReturnVal;
}


//
// SetPowerMode
//		Send AT command to drive
//
BOOL
SetPowerMode(HANDLE hDevice, UCHAR Command) {
	ATA_PASS_THROUGH	AtaPassThrough;
	DWORD cbBytesReturned;
	BOOL bReturn;

	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = Command;
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBuffer = NULL;

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		LogAtaPassThrough(AtaPassThrough);
		return FALSE;
	} else {
		return TRUE;
	}
}


DOUBLE
StartUpTime(HANDLE hDevice, ULONG Reps) {
	LARGE_INTEGER ReturnTime, TotalTime;
	ULONG i;
	DOUBLE ReturnVal;

	TotalTime.QuadPart = 0;

	for(i = 0; i < Reps; i++) {
		// Put drive in Standby mode
		if(!SetPowerMode(hDevice, AT_STANDBY_IMMEDIATE)) {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SetPowerMode(AT_STANDBY_IMMEDIATE) FAILED");
			return 0;
		}
	
		// Wait for drive to spin down
		Sleep(6000);

		// Read from drive
		ReturnTime = ReadLBA(hDevice, 0, 1);
		if(ReturnTime.QuadPart == -1) {
			return 0;
		} else {
			TotalTime.QuadPart += ReturnTime.QuadPart;
		}
	}

	// Return average Startup time
	ReturnVal = (DOUBLE)TotalTime.QuadPart/(DOUBLE)gFrequency.QuadPart;
	ReturnVal /= (DOUBLE)Reps;
	return ReturnVal;
}


//
// Peak sequential streaming throughput - both write and read
//
VOID
FileReadWriteTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	DWORD BufferSize;
	DWORD Bytes, TotalBytes;
	LARGE_INTEGER BytesToMove, StartTime, EndTime, Frequency;
	DOUBLE Rate;

	// Initialize
	xSetFunctionName(LogHandle, "FileReadWriteTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}
	
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		// Creat file for write
		hFile = CreateFile(TESTFILENAME, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Size file
		BytesToMove.QuadPart = TESTFILESIZE;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}
		if(!SetEndOfFile(hFile)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetEndOfFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Go back to the beginning
		BytesToMove.QuadPart = 0;
		if(!SetFilePointerEx(hFile, BytesToMove, NULL, FILE_BEGIN)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointerEx(%u bytes) FAILED LastError = %d", BytesToMove.QuadPart, GetLastError());
			return;
		}

		// Write file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!WriteFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		CloseHandle(hFile);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_PASS, "Sequential File Write (%3uKB Buffer) %f KB/s",
			BufferSize/KB, Rate);

		// Open file for read
		hFile = CreateFile(TESTFILENAME, GENERIC_READ, 0, NULL, OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
			return;
		}

		// Read file
		TotalBytes = 0;
		QueryPerformanceCounter(&StartTime);
		do {
			if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile(%u bytes) FAILED LastError = %d", 
					BufferSize, GetLastError());
				return;
			}
			TotalBytes += Bytes;
		} while(TotalBytes < TESTFILESIZE);
		QueryPerformanceCounter(&EndTime);

		Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)KB;

		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential File Read  (%3uKB Buffer) %f KB/s", BufferSize/KB, Rate);

		CloseHandle(hFile);

		DeleteFile(TESTFILENAME);
	}

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Raw read streaming from various part of the hard disk
//
VOID 
RawReadTest(HANDLE LogHandle, DWORD BufferSize) {
	HANDLE hDevice;
	DISK_GEOMETRY DiskGeometry;
	VOID* Buffer;
	DWORD BytesReturned;
	LARGE_INTEGER DeviceOffset, SampleOffset, MaxOffset;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DOUBLE Rate;
	BOOL bReturn;

    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;


	// Initialize
	xSetFunctionName(LogHandle, "RawReadTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);

	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	for(DeviceOffset.QuadPart = 0; DeviceOffset.QuadPart <= MaxOffset.QuadPart - SAMPLEREADSIZE; DeviceOffset.QuadPart += SAMPLEBLOCKSIZE) {
		// Read SAMPLEREADSIZE at Offset
		SampleOffset.QuadPart = DeviceOffset.QuadPart;
		QueryPerformanceCounter(&StartTime);
        do {
			status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &SampleOffset);
            if(!NT_SUCCESS(status)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtReadFile() FAILED Status = %d", status);
				return;
			}
			// Increment the SampleOffset
            SampleOffset.QuadPart += BufferSize;
        } while ((SampleOffset.QuadPart -  DeviceOffset.QuadPart) <= SAMPLEREADSIZE);
		QueryPerformanceCounter(&EndTime);

		// Compute read rate
		Rate = (DOUBLE)SAMPLEREADSIZE;
		Rate /= (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
		Rate *= (DOUBLE)Frequency.QuadPart;
		Rate /= (DOUBLE)1024;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Sequential Raw Read Block %#.9I64x %f KB/s", DeviceOffset.QuadPart, Rate);
    }

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Random raw reads to measure seek time
//
VOID RandomRawDiskRead(HANDLE LogHandle, DWORD BufferSize) {
    OBJECT_STRING objname;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;
    HANDLE hDevice;
	VOID* Buffer;
	DISK_GEOMETRY DiskGeometry;
	DWORD BytesReturned;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	LARGE_INTEGER Offset, MaxOffset;
	DWORD MaxBuffers, TotalBytesRead;
	DOUBLE Rate;
	BOOL bReturn;

	// Initialize
	xSetFunctionName(LogHandle, "RandomRawDiskRead");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %3uKB Buffer", BufferSize/KB);
	QueryPerformanceFrequency(&Frequency);
	srand('RAWR');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, BufferSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", BufferSize, GetLastError());
		return;
	}

	// Open device
    RtlInitObjectString(&objname, OTEXT("\\Device\\Harddisk0\\partition0"));
    InitializeObjectAttributes(&oa, &objname, OBJ_CASE_INSENSITIVE, NULL, NULL);
    status = NtOpenFile(&hDevice, GENERIC_READ|SYNCHRONIZE, &oa, &iosb, 0, FILE_SYNCHRONOUS_IO_ALERT);
    if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "NtOpenFile() FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);
	// Maximum Offset
	MaxOffset.QuadPart = DiskGeometry.BytesPerSector*(DiskGeometry.Cylinders.QuadPart*DiskGeometry.TracksPerCylinder*DiskGeometry.SectorsPerTrack - 1);

	//Maximum number of buffer sized chunks
    MaxBuffers = (DWORD)MaxOffset.QuadPart/BufferSize;
    TotalBytesRead = 0;

	// Read TESTFILESIZE bytes at random locations
	QueryPerformanceCounter(&StartTime);
    do {
        Offset.QuadPart = rand()*MaxBuffers/RAND_MAX;
        Offset.QuadPart *= BufferSize;
        status = NtReadFile(hDevice, 0, NULL, NULL, &iosb, Buffer, BufferSize, &Offset);
        TotalBytesRead += BufferSize;
    } while (TotalBytesRead < TESTFILESIZE);
	QueryPerformanceCounter(&EndTime);

	// Compute read rate
	Rate = (DOUBLE)TESTFILESIZE/(DOUBLE)(EndTime.QuadPart - StartTime.QuadPart);
	Rate *= (DOUBLE)Frequency.QuadPart;
	Rate /= (DOUBLE)KB;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Random Raw Read: %f KB/s", Rate);

    NtClose(hDevice);
	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Small file creation test to measure caching effects
//
VOID SmallFileCreationTest(HANDLE LogHandle) {
	HANDLE hFile;
    CHAR FileName[MAX_PATH];
	VOID* Buffer;
	LARGE_INTEGER StartTime, EndTime, Frequency;
	DWORD FileSize, Bytes;
	DOUBLE Time;
	int i;

	// Initialize
	xSetFunctionName(LogHandle, "SmallFileCreationTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Small File Creation Test: %u files", FILECOUNT);
	QueryPerformanceFrequency(&Frequency);
	srand('DIRS');

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXSMALLFILESIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXSMALLFILESIZE, GetLastError());
		return;
	}

	// Create test directory
    CreateDirectory(TESTDIRNAME, NULL);
		
	// Create files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        hFile = CreateFile(FileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_WRITE_THROUGH,
                        NULL);
		if(hFile == INVALID_HANDLE_VALUE) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile(%s) FAILED LastError = %d", FileName, GetLastError());
			return;
		}

		FileSize= rand() % MAXSMALLFILESIZE + 1;
        if(!WriteFile(hFile, Buffer, FileSize, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile(%s, %u bytes) FAILED LastError = %d", 
					FileName, FileSize, GetLastError());
			return;
		}

		CloseHandle(hFile);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Create %u Small Files: %f ms", FILECOUNT, Time);

    // Delete files
	QueryPerformanceCounter(&StartTime);
    for (i = 0; i < FILECOUNT; i++) {
		sprintf(FileName, "%s\\%04x", TESTDIRNAME, i);
        DeleteFile(FileName);
    }
	QueryPerformanceCounter(&EndTime);

	Time = (DOUBLE)(EndTime.QuadPart - StartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Delete %u Small Files: %f ms", FILECOUNT, Time);

    RemoveDirectory(TESTDIRNAME);

	VirtualFree(Buffer, 0, MEM_RELEASE);
}


//
// Simple disk cache test
//
VOID DiskCacheTest(HANDLE LogHandle) {
	HANDLE hFile;
	VOID* Buffer;
	LARGE_INTEGER ReadStartTime, ReadEndTime, WriteStartTime, WriteEndTime, Frequency;
	DWORD BufferSize, Bytes, TotalBytes, Offset;
	DOUBLE ReadTime[READBUFSIZE/WRITEBUFSIZE], WriteTime[READBUFSIZE/WRITEBUFSIZE];
	DOUBLE ReadTimeSeq[6][4], ReadTimeScat[6][4];
	int i, j;

	// Initialize
	xSetFunctionName(LogHandle, "DiskCacheTest");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "Begin");
	QueryPerformanceFrequency(&Frequency);

	// Allocate buffer
	Buffer = (PUCHAR)VirtualAlloc(NULL, MAXBUFSIZE, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	if(Buffer == NULL) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "GlobalAlloc(%u bytes) FAILED LastError = %d", MAXBUFSIZE, GetLastError());
		return;
	}

	// Open file
    hFile = CreateFile("z:", GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL, OPEN_EXISTING, 
					FILE_ATTRIBUTE_NORMAL| FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_NO_BUFFERING, NULL);
	
	if(hFile == INVALID_HANDLE_VALUE) {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "CreateFile() FAILED LastError = %d", GetLastError());
		return;
	}

    //
    // Interleaved reads and writes
    //
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		// Goto STARTINGPOS
        if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		TotalBytes = 0;

		// Read CACHEFILESIZE bytes
		QueryPerformanceCounter(&ReadStartTime);
        do {
            if(!ReadFile(hFile, Buffer, READBUFSIZE, &Bytes, NULL)) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
				return;
			}
            TotalBytes += Bytes;
        } while (TotalBytes < CACHEFILESIZE);
		QueryPerformanceCounter(&ReadEndTime);

		// Goto write spot
        if(SetFilePointer(hFile, STARTINGPOS + CACHEFILESIZE - READBUFSIZE + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
			return;
		}

		// Write WRITEBUFSIZE bytes
		QueryPerformanceCounter(&WriteStartTime);
		if(!WriteFile(hFile, (CHAR*) Buffer + Offset, WRITEBUFSIZE, &Bytes, NULL)) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, "WriteFile() FAILED LastError = %d", GetLastError());
			return;
		}
		QueryPerformanceCounter(&WriteEndTime);

		// Store results
		ReadTime[j] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		WriteTime[j] = (DOUBLE)(WriteEndTime.QuadPart - WriteStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000;
		j++;
    }

    //
    // Reads same 256KB of data using different buffer sizes
    //
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			// Goto STARTINGPOS
			if(SetFilePointer(hFile, STARTINGPOS, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
				return;
			}
            
            TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
	            TotalBytes += Bytes;
		    } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeSeq[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    //
    // Read 256KB scattered
    //
	j = 0;
	for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			Offset = 0;
			TotalBytes = 0;
			QueryPerformanceCounter(&ReadStartTime);
			do {
				SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN);
				ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL);
				//
				if(SetFilePointer(hFile, STARTINGPOS + Offset, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "SetFilePointer() FAILED LastError = %d", GetLastError());
					return;
				}

	            if(!ReadFile(hFile, Buffer, BufferSize, &Bytes, NULL)) {
					xLog(gbConsoleOut, LogHandle, XLL_FAIL, "ReadFile() FAILED LastError = %d", GetLastError());
					return;
				}
				//
	            TotalBytes += Bytes;
				Offset += MB;
	        } while (TotalBytes < CACHEFILESIZE);
			QueryPerformanceCounter(&ReadEndTime);

			// Store results
			ReadTimeScat[j][i] = (DOUBLE)(ReadEndTime.QuadPart - ReadStartTime.QuadPart)/(DOUBLE)Frequency.QuadPart*1000.0;
        }
		j++;
    }

    CloseHandle(hFile);
		
	VirtualFree(Buffer, 0, MEM_RELEASE);

	// Log Interleaved results
	j = 0;
    for(Offset=0; Offset < READBUFSIZE; Offset += WRITEBUFSIZE) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %uKB %fms Write (Offset %u bytes): %fms", CACHEFILESIZE/KB, ReadTime[j], Offset, WriteTime[j]); 
		j++;
	}

	// Log Sequential results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeSeq[j][i]); 
		}
		j++;
	}

	// Log Scattered results
	j = 0;
    for(BufferSize = MINBUFSIZE; BufferSize <= MAXBUFSIZE; BufferSize *= 2) {
		for(i = 0; i < 4; i++) {
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read %u Scattered: %uKB (%3dKB Buffer): %fms", i, CACHEFILESIZE/KB, BufferSize/KB, ReadTimeScat[j][i]); 
		}
		j++;
	}
}


VOID
WINAPI
HDPerf_llStartTest(HANDLE LogHandle) {
	HANDLE hDevice;
	BOOL bReturn;
    DWORD cbBytesReturned;
    OBJECT_STRING objectName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
	ATA_PASS_THROUGH	AtaPassThrough, AtaPassThroughOut;
	IDE_IDENTIFY_DATA	IdeIdData;
	DOUBLE dTime;
	ULONG StartUpReps;
	ULONG TrackToTrackLBA, TrackToTrackReps;
	ULONG FullStartLBA, FullEndLBA, FullReps;
	ULONG StreamStartLBA, StreamEndLBA;
	ULONG MaxLBA, NextTrack;
	ULONG MaxSectors = 0, i;

	// Set global log handle
	gLogHandle = LogHandle;

	xSetOwnerAlias(gLogHandle, "a-emebac");
	xSetComponent(gLogHandle, "Hardware", "HDPerf");
	xSetFunctionName(gLogHandle, "Initialization");

	// Get timer frequency (ticks/sec)
	QueryPerformanceFrequency(&gFrequency);


	// open device
	RtlInitObjectString(&objectName, "\\Device\\Harddisk0\\Partition0");
	InitializeObjectAttributes(&objectAttributes, &objectName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	status = NtOpenFile(&hDevice, 
							GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
							&objectAttributes,
							&ioStatusBlock,
							0,
							FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

	if(!NT_SUCCESS(status)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "NtOpenFile FAILED Status = %d", status);
		return;
	}

	// get geometry
	memset(&gDiskGeometry, 0, sizeof(gDiskGeometry));
	bReturn = DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&gDiskGeometry, sizeof(gDiskGeometry), 
								&cbBytesReturned, NULL);

	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IOCTL_DISK_GET_DRIVE_GEOMETRY FAILED LastError = %d", GetLastError());
		CloseHandle(hDevice);
		return;
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u", gDiskGeometry.Cylinders.QuadPart);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "TracksPerCylinder = %u", gDiskGeometry.TracksPerCylinder);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u", gDiskGeometry.SectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "BytesPerSector = %u", gDiskGeometry.BytesPerSector);

	// Populate pass through command for Identify Device
	memset(&IdeIdData, 0, sizeof(IDE_IDENTIFY_DATA));
	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = 0xec;						// Identify Device DMA
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBufferSize = sizeof(IDE_IDENTIFY_DATA);
	AtaPassThrough.DataBuffer = &IdeIdData;

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);
	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "IDENTIFY DEVICE FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		LogAtaPassThrough(AtaPassThrough);
		CloseHandle(hDevice);
		return;
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Cylinders = %u",						IdeIdData.NumberOfCylinders);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Heads = %u",							IdeIdData.NumberOfHeads);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "SectorsPerTrack = %u",					IdeIdData.NumberOfSectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Cylinders = %u",				IdeIdData.NumberOfCurrentCylinders);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Heads = %u",					IdeIdData.NumberOfCurrentHeads);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current SectorsPerTrack = %u",			IdeIdData.CurrentSectorsPerTrack);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Sector Capacity = %u",			IdeIdData.CurrentSectorCapacity);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Current Multi Sector Setting = %u",	IdeIdData.CurrentMultiSectorSetting);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "User Addressable Sectors = %u",		IdeIdData.UserAddressableSectors);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MultiWordDMASupport = %u",				IdeIdData.MultiWordDMASupport);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "MultiWordDMAActive = %u",				IdeIdData.MultiWordDMAActive);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "UltraDMASupport = %u",					IdeIdData.UltraDMASupport);
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "UltraDMAActive = %u",					IdeIdData.UltraDMAActive);

	// Populate pass through command for Disable read look-ahead
	memset(&AtaPassThrough, 0, sizeof(ATA_PASS_THROUGH));
	AtaPassThrough.IdeReg.bCommandReg = 0xef;						// Set features
	AtaPassThrough.IdeReg.bFeaturesReg = 0x55;						// Disable read look-ahead
	AtaPassThrough.IdeReg.bSectorCountReg = 0;
	AtaPassThrough.IdeReg.bDriveHeadReg = 0xa0;						// Device 0
	AtaPassThrough.DataBufferSize = 0;
	AtaPassThrough.DataBuffer = NULL;

	memset(&AtaPassThroughOut, 0, sizeof(ATA_PASS_THROUGH));

	bReturn = DeviceIoControl(hDevice, IOCTL_IDE_PASS_THROUGH,
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&AtaPassThrough, sizeof(ATA_PASS_THROUGH),
								&cbBytesReturned, NULL);
	if(!bReturn) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "SET FEATURES: Disable read look-ahead FAILED StatusReg=%#x ErrorReg=%#x LastError = %d", 
			AtaPassThrough.IdeReg.bCommandReg, AtaPassThrough.IdeReg.bFeaturesReg, GetLastError());
		LogAtaPassThrough(AtaPassThrough);
		return;
	}

	// Get parameters from ini file
	MaxLBA = IdeIdData.UserAddressableSectors - 1;
	StartUpReps = GetProfileInt(TEXT("hdperf"), TEXT("StartUpReaps"), 10);
	TrackToTrackLBA = GetProfileInt(TEXT("hdperf"), TEXT("TrackToTrackLBA"), MaxLBA/2);
	TrackToTrackReps = GetProfileInt(TEXT("hdperf"), TEXT("TrackToTrackReps"), 200);
	FullStartLBA = GetProfileInt(TEXT("hdperf"), TEXT("FullStartLBA"), 0);
	FullEndLBA = GetProfileInt(TEXT("hdperf"), TEXT("FullEndLBA"), MaxLBA);
	FullReps = GetProfileInt(TEXT("hdperf"), TEXT("FullReps"), 200);
	StreamStartLBA = GetProfileInt(TEXT("hdperf"), TEXT("StreamStartLBA"), 0);
	StreamEndLBA = GetProfileInt(TEXT("hdperf"), TEXT("StreamEndLBA"), 1048576/gDiskGeometry.BytesPerSector);	// 1MB

	// Startup time
	xSetFunctionName(gLogHandle, "StartUpTime");
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Average Startup Time: Reps = %u", StartUpReps);
	dTime = StartUpTime(hDevice, StartUpReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Startup Time = %f s", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Startup Time FAILED");
	}

	// Measure Track to Track access times
	xSetFunctionName(gLogHandle, "AccessTime");
	NextTrack = gDiskGeometry.SectorsPerTrack + 1;
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Track to Track: Start LBA = %u End LBA = %u Reps = %u", 0, NextTrack, TrackToTrackReps);
	dTime = HDAccessTime(hDevice, 0, NextTrack, TrackToTrackReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Track to Track Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Track to Track Access Time FAILED");
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Track to Track: Start LBA = %u, End LBA = %u, Reps = %u", MaxLBA/2, MaxLBA/2 + NextTrack, TrackToTrackReps);
	dTime = HDAccessTime(hDevice, MaxLBA/2, MaxLBA/2 + NextTrack, TrackToTrackReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Track to Track Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Track to Track Access Time FAILED");
	}

	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Track to Track: Start LBA = %u End LBA = %u Reps = %u", MaxLBA - NextTrack, MaxLBA, TrackToTrackReps);
	dTime = HDAccessTime(hDevice, MaxLBA - NextTrack, MaxLBA, TrackToTrackReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Track to Track Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Track to Track Access Time FAILED");
	}

	// Measure full-stroke access time
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Full-Stroke Start LBA = %u, End LBA = %u, Reps = %u", FullStartLBA, FullEndLBA, FullReps);
	dTime = HDAccessTime(hDevice, FullStartLBA, FullEndLBA, FullReps);
	if(dTime > 0) {
		xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Full-Stroke Access Time = %f ms", dTime);
	} else {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Full-Stroke Access Time FAILED");
	}

	// Measure data stream rate
	xSetFunctionName(gLogHandle, "StreamTime");
	for(i = 0; i <= 8; i++) {
		MaxSectors = 1<<i;
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "Stream Rate Start LBA = %u, End LBA = %u, Read Buffer = %u bytes", StreamStartLBA, StreamEndLBA, MaxSectors*gDiskGeometry.BytesPerSector);
		dTime = StreamTime(hDevice, StreamStartLBA, StreamEndLBA, MaxSectors);
		if(dTime > 0) {
			xLog(gbConsoleOut, gLogHandle, XLL_PASS, "Average Sustained Data Rate = %f MBytes/s", dTime);
		} else {
			xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "Average Sustained Data Rate FAILED");
		}
	}

	// close device
	if(!CloseHandle(hDevice)) {
		xLog(gbConsoleOut, gLogHandle, XLL_FAIL, "CloseHandle FAILED LastError = %d", GetLastError());
	}

	// File tests
	if(GetProfileIntA("hdperf", "FileReadWriteTest", 1)) {
		FileReadWriteTest(LogHandle);
	}
    
	if(GetProfileIntA("hdperf", "RawReadTest", 1)) {
		RawReadTest(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf", "SmallFileCreationTest", 1)) {
		SmallFileCreationTest(LogHandle);
	}

	if(GetProfileIntA("hdperf", "RandomRawDiskRead", 1)) {
		RandomRawDiskRead(LogHandle, 64*KB);
	}

	if(GetProfileIntA("hdperf", "DiskCacheTest", 1)) {
		DiskCacheTest(LogHandle);
	}
}


VOID WINAPI
HDPerf_llEndTest() {
}


#if !defined(HARNESSLIB)
void __cdecl main() {
	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	// xSetFontA(12.0, 18.0, NULL);
	
	// xlog
	gLogHandle = xCreateLog_A("t:\\hdperf.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(gLogHandle == INVALID_HANDLE_VALUE ) {
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "HDPerf: couldn't create log (%s)", WinErrorSymbolicName(GetLastError()));
		xLog(gbConsoleOut, gLogHandle, XLL_INFO, "HDPerf: End - Waiting for reboot...");
		Sleep(INFINITE);
    }

	gbConsoleOut = TRUE;


	// Start Test
	HDPerf_llStartTest(gLogHandle);

	// End Test
	HDPerf_llEndTest();

	// xlog
	xCloseLog(gLogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xLog(gbConsoleOut, gLogHandle, XLL_INFO, "hdperf: End - Waiting for reboot...");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( hdperf_ll )
#pragma data_seg()

BEGIN_EXPORT_TABLE( hdperf_ll )
    EXPORT_TABLE_ENTRY( "StartTest", HDPerf_llStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", HDPerf_llEndTest )
END_EXPORT_TABLE( hdperf_ll )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\hdsit\hdsit.cpp ===
#include <ntos.h>
#include <ntdddisk.h>
#include <xtl.h>
#include <xtestlib.h>
#include <dxconio.h>

// Globals
HANDLE ghGamePads[4];
BOOL gbPause = FALSE;
BOOL gbQuit = FALSE;


void
DumpBuffer(PUCHAR Buffer, ULONG BufferSize) {
	ULONG i, j;

	for(i = 0; i < BufferSize/24; i++) {
		for(j = 0; j < 24; j++) {
			xDebugStringA("%.2x ", Buffer[i*20 + j]);
		}
		xDebugStringA("\n");
	}
}

void
InitGamePads() {
	DWORD i;
	XDEVICE_PREALLOC_TYPE xdpt;

	// Initialize gamepads
	xdpt.DeviceType = XDEVICE_TYPE_GAMEPAD;
	xdpt.dwPreallocCount = 4;

	XInitDevices(1, &xdpt);

	// Get a mask of all currently available devices
    DWORD dwDeviceMask = XGetDevices(XDEVICE_TYPE_GAMEPAD);

    // Open the devices
	for(i = 0; i < 4; i++){
		// Initialize game pad array
		ghGamePads[i] = NULL;

        if( dwDeviceMask & (1<<i) ) {
            // Get a handle to the device
            ghGamePads[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL );
			xDebugStringA("Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
        }
	}
}


void
ReadGamePads() {
	DWORD dwInsertions, dwRemovals;
	DWORD b, i, Buttons = 0;
	XINPUT_STATE State;
	BOOL AnalogButtons[8];

	// Get gamepad insertions and removals
	XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals);
	for(i = 0; i < 4; i++) {
		// Handle removed devices.
		if(dwRemovals & (1<<i) ) {
			XInputClose( ghGamePads[i]);
			xDebugStringA("HD SIT: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}

		// Handle inserted devices
		if(dwInsertions & (1<<i)) {
			ghGamePads[i] = XInputOpen(XDEVICE_TYPE_GAMEPAD, i, XDEVICE_NO_SLOT, NULL);
			xDebugStringA("HD SIT: Added Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
		}
	}

	// Init button variables
	Buttons = 0;
	for(b = 0; b < 8; b++) {
		AnalogButtons[b] = FALSE;
	}

	// Get button presses
	for(i = 0; i < 4; i++) {
		if(ghGamePads[i] != NULL) {
			XInputGetState(ghGamePads[i], &State);

			// Digital buttons
			Buttons |= State.Gamepad.wButtons;

			// Analog buttons (threshold = 25/256)
			for(b = 0; b < 8; b++) {
				AnalogButtons[b] |= (State.Gamepad.bAnalogButtons[b] > 25);
			}
		}
	}

	// Check button presses
	// Back button pauses app
	if((Buttons & XINPUT_GAMEPAD_BACK) > 0) {
		if(!gbPause) {
			xDebugStringA("HD SIT: Application Paused\n");
			gbPause = TRUE;
		}
	}

	// Start button unpauses app
	if((Buttons & XINPUT_GAMEPAD_START) > 0 ) {
		if(gbPause) {
			xDebugStringA("HD SIT: Application NOT Paused\n");
			gbPause = FALSE;
		}
	}

	// Both triggers plus Black button quits app (from Samples)
	if(AnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] & AnalogButtons[XINPUT_GAMEPAD_BLACK]) {
		if(!gbQuit) {
			xDebugStringA("HD SIT: Application Quiting...\n");
			gbQuit = TRUE;
		}
	}
}


void
CloseGamePads() {
	DWORD i;

	for(i = 0; i < 4; i++ ) {
		if(ghGamePads[i] != NULL) {
			XInputClose(ghGamePads[i]);
			xDebugStringA("HD SIT: Removed Gamepad: Port: %ld Handle: %#x\n", i , ghGamePads[i]);
			ghGamePads[i] = NULL;
		}
	}
}


void
__cdecl main() {
	HANDLE hFile, hPattern;

	OBJECT_STRING objectName;
	OBJECT_ATTRIBUTES objectAttributes;
	IO_STATUS_BLOCK ioStatusBlock;
	NTSTATUS status;
	DWORD BytesReturned, BytesRead;
	BOOL bReturn, bRO, bWO;
	DISK_GEOMETRY DiskGeometry;

	ULONG Cylinder, Head, Sector, SectorsToRead, BufferSize, i;
	LARGE_INTEGER LBA, ByteOffset;
	CHAR PatternFile[MAX_PATH], cString[MAX_PATH];
	UCHAR Pattern[8];
	PUCHAR OrigBuffer, WriteBuffer, ReadBuffer;

	// Initialize Console Output
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);

	xDebugStringA("HD SIT: Press the 'Back' button to Pause the application.\n");
	xDebugStringA("HD SIT: Press the 'Start' button to Resume the application.\n");
	xDebugStringA("HD SIT: Press both triggers and the 'Black' button to quit the application.\n");

	// Initialize Game Pads
	InitGamePads();

	// Open device
	RtlInitObjectString(&objectName, "\\Device\\Harddisk0\\Partition0");
	InitializeObjectAttributes(&objectAttributes, &objectName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	status = NtOpenFile(&hFile, 
							GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
							&objectAttributes,
							&ioStatusBlock,
							0,
							FILE_SYNCHRONOUS_IO_ALERT | FILE_NO_INTERMEDIATE_BUFFERING);

	if(!NT_SUCCESS(status)) {
		xDebugStringA("NtOpenFile FAILED Status = %d\n", status);
		Sleep(INFINITE);
	}

	// get geometry
	memset(&DiskGeometry, 0, sizeof(DiskGeometry));
	bReturn = DeviceIoControl(hFile, IOCTL_DISK_GET_DRIVE_GEOMETRY,
								NULL, 0, 
								&DiskGeometry, sizeof(DiskGeometry), 
								&BytesReturned, NULL);

	if(!bReturn) {
		xDebugStringA("IOCTL_DISK_GET_DRIVE_GEOMETRY FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}

	xDebugStringA("Disk Geometry: Cylinders = %u\n", DiskGeometry.Cylinders.QuadPart);
	xDebugStringA("Disk Geometry: TracksPerCylinder = %u\n", DiskGeometry.TracksPerCylinder);
	xDebugStringA("Disk Geometry: SectorsPerTrack = %u\n", DiskGeometry.SectorsPerTrack);
	xDebugStringA("Disk Geometry: BytesPerSector = %u\n", DiskGeometry.BytesPerSector);

	// Get location from ini
	Cylinder =		GetProfileIntA("hdsit", "Cylinder", (INT)DiskGeometry.Cylinders.QuadPart - 1);
	Head =			GetProfileIntA("hdsit", "Head", DiskGeometry.TracksPerCylinder - 1);
	Sector =		GetProfileIntA("hdsit", "Sector", DiskGeometry.SectorsPerTrack - 1);
	SectorsToRead = GetProfileIntA("hdsit", "SectorsToRead", 1);

	// LBA.QuadPart = DiskGeometry.SectorsPerTrack*(DiskGeometry.Cylinders.QuadPart*(Head)  + Cylinder) + Sector - 1;
	LBA.QuadPart = DiskGeometry.SectorsPerTrack*(DiskGeometry.TracksPerCylinder*Cylinder + Head) + Sector - 1;
	BufferSize = SectorsToRead*DiskGeometry.BytesPerSector;
	ByteOffset.QuadPart = LBA.QuadPart*DiskGeometry.BytesPerSector;

	xDebugStringA("Test Location: Cylinder = %u\n", Cylinder);
	xDebugStringA("Test Location: Head = %u\n", Head);
	xDebugStringA("Test Location: Sector = %u\n", Sector);
	xDebugStringA("Test Location: LBA = %u\n", LBA.QuadPart);
	xDebugStringA("Test Location: BufferSize = %u\n", BufferSize);
	xDebugStringA("Test Location: ByteOffset = %u\n", ByteOffset.QuadPart);

	// Allocate buffers
	OrigBuffer = (PUCHAR)GlobalAlloc(GPTR, BufferSize);
	if(OrigBuffer == NULL) {
		xDebugStringA("GlobalAlloc(OrigBuffer) FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}

	ReadBuffer = (PUCHAR)GlobalAlloc(GPTR, BufferSize);
	if(ReadBuffer == NULL) {
		xDebugStringA("GlobalAlloc(ReadBuffer) FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}
	
	WriteBuffer = (PUCHAR)GlobalAlloc(GPTR, BufferSize);
	if(WriteBuffer == NULL) {
		xDebugStringA("GlobalAlloc(WriteBuffer) FAILED LastError = %d\n", GetLastError());
		Sleep(INFINITE);
	}

	// Get read only flag from testini.ini
	if(GetProfileIntA("hdsit", "ReadOnly", 1) == 1) {
		bRO = TRUE;
	} else {
		bRO = FALSE;
	}

	// Get write only flag from testini.ini
	if(GetProfileIntA("hdsit", "WriteOnly", 0) == 1) {
		bWO = TRUE;
	} else {
		bWO = FALSE;
	}

	if(bRO && bWO) {
		xDebugStringA("TestLocation: Read/Write\n");
	} else if(bRO && !bWO) {
		xDebugStringA("TestLocation: Read Only\n");
	} else if(!bRO && bWO) {
		xDebugStringA("TestLocation: Write Only\n");
	} else {
		xDebugStringA("TestLocation: Nothing\n");
	}

	// Get test pattern from testini or from file
	GetProfileStringA("hdsit", "PatternFile", "NoFile", PatternFile, MAX_PATH);
	IniRemoveStringCommentA(PatternFile);
	if(lstrcmpA(PatternFile, "NoFile") == 0) {
		// No pattern file, get pattern bytes from testini.ini
		for(i = 0; i < 8; i++) {
			wsprintfA(cString, "PatternByte%u", i);
			Pattern[i] = (UCHAR)GetProfileIntA("hdsit", cString, i);
			xDebugStringA("Test Pattern Byte %u: %u\n", i, Pattern[i]);
		}
	
		// Fill WriteBuffer with pattern
		for(i = 0; i < BufferSize; i++) {
			WriteBuffer[i] = Pattern[i%8];
		}

	} else {
		// Get pattern file
		xDebugStringA("Test Location: Test Pattern File = %s\n", PatternFile);
		hPattern = CreateFile(PatternFile, GENERIC_READ, 0, NULL, 
			OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if(hPattern == INVALID_HANDLE_VALUE) { 
			xDebugStringA("CreateFile(%s) FAILED LastError = %d\n", PatternFile, GetLastError());
			Sleep(INFINITE);
		}

		// Read pattern
		if(!ReadFile(hPattern, WriteBuffer, BufferSize, &BytesRead, NULL)) {
			xDebugStringA("ReadFile(%s) FAILED LastError = %d\n", PatternFile, GetLastError());
			Sleep(INFINITE);
		}

		CloseHandle(hPattern);
	}

	// xDebugStringA("Pattern to Write (in Hex) at ByteOffset %u\n",  ByteOffset.QuadPart);
	// DumpBuffer(WriteBuffer, BufferSize);

	// Read current current contents at location
	xDebugStringA("Reading Original Contents at ByteOffset %u\n", ByteOffset.QuadPart);
	status = NtReadFile(hFile, NULL, NULL, NULL, &ioStatusBlock, OrigBuffer, BufferSize, &ByteOffset);

	if(!NT_SUCCESS(status)) {
		xDebugStringA("NtReadFile(OrigBuffer %u Bytes at Offset %u) FAILED Status = %d\n", 
			BufferSize, ByteOffset.QuadPart, status);
		Sleep(INFINITE);
	}

	// xDebugStringA("Original Contents (in Hex) at ByteOffset %u\n",  ByteOffset.QuadPart);
	// DumpBuffer(OrigBuffer, BufferSize);

	// Write pattern
	xDebugStringA("Write Pattern at ByteOffset %u\n", ByteOffset.QuadPart);
	status = NtWriteFile(hFile, NULL, NULL, NULL, &ioStatusBlock, WriteBuffer, BufferSize, &ByteOffset);

	if(!NT_SUCCESS(status)) {
		xDebugStringA("NtWriteFile(WriteBuffer %u Bytes at Offset %u) FAILED Status = %d\n", 
			BufferSize, ByteOffset.QuadPart, status);
		Sleep(INFINITE);
	}

	while(!gbQuit) {
		if(!gbPause) {
			if(bRO) {
				// Read location
				status = NtReadFile(hFile, NULL, NULL, NULL, &ioStatusBlock, ReadBuffer, BufferSize, &ByteOffset);

				if(!NT_SUCCESS(status)) {
					xDebugStringA("NtReadFile(ReadBuffer %u Bytes at Offset %u) FAILED Status = %d\n", 
						BufferSize, LBA.QuadPart, status);
				Sleep(INFINITE);
				}
			}

			if(bWO) {
				// Write location
				status = NtWriteFile(hFile, NULL, NULL, NULL, &ioStatusBlock, WriteBuffer, BufferSize, &ByteOffset);

				if(!NT_SUCCESS(status)) {
					xDebugStringA("NtWriteFile(WriteBuffer %u Bytes at Offset %u) FAILED Status = %d\n", 
						BufferSize, ByteOffset.QuadPart, status);
					Sleep(INFINITE);
				}
			}
		}

		// Get button presses
		ReadGamePads();
	}

	// Write original contents back to loaction
	xDebugStringA("Write Original Contents at ByteOffset %u\n", ByteOffset.QuadPart);
	status = NtWriteFile(hFile, NULL, NULL, NULL, &ioStatusBlock, OrigBuffer, BufferSize, &ByteOffset);

	if(!NT_SUCCESS(status)) {
		xDebugStringA("NtWriteFile(OrigBuffer %u Bytes at Offset %u) FAILED Status = %d\n", 
			BufferSize, ByteOffset.QuadPart, status);
		Sleep(INFINITE);
	}

	// Close device
	CloseHandle(hFile);

	// Close gamepads
	CloseGamePads();

	// Free buffers
	GlobalFree(OrigBuffer);
	GlobalFree(ReadBuffer);
	GlobalFree(WriteBuffer);

	// Close console
	xReleaseConsole();

	// Reboot
	XLaunchNewImage(NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\inc\Cali2c32.h ===
//	Copyright	Calibre UK Ltd 1999	
//	File name	Cali2c32.h
//	Description	Include file for cali2c32.lib
//				Defines all functions within the PCI I2C library
//	Version		1.0 As written
//	Date		1 December 1999

#ifndef __CALI2C32_H__
#define __CALI2C32_H__

extern __declspec(dllimport) int WINAPI setup (int, int, int);
extern __declspec(dllimport) int WINAPI sendaddress (int, int, int);
extern __declspec(dllimport) int WINAPI writebyte(int, int);
extern __declspec(dllimport) int WINAPI readbyte(int, int);
extern __declspec(dllimport) int WINAPI sendstop(int);
extern __declspec(dllimport) int WINAPI restart (int, int, int);
extern __declspec(dllimport) int WINAPI getstatus(int);
extern __declspec(dllimport) int WINAPI recover(int);
extern __declspec(dllimport) int WINAPI slavelastbyte(int);
extern __declspec(dllimport) int WINAPI dllissue(void);





#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\rtcacc.asm ===
P586
	;.model large
	public  _get_tsc
	public	_get_tick
	public	_time_gold_system
	public	_clocks_per_rtc_update
test	SEGMENT USE16
	ASSUME  CS:test


rdtsc	macro
	db	0Fh
	db	31h
	endm


wait_till_uip macro
		local	W1, W2
		MOV 	AL,8AH
		OUT 	70H,AL
		DAA
		DAA
W1:		IN		AL,71H			; Wait for the uip to be low
		AND		AL,80H
		JNZ		W1
		IN		AL,71H			; Wait for the uip to be low
		AND		AL,80H
		JNZ		W1

		MOV 	AL,8AH
		OUT 	70H,AL
		DAA
		DAA
W2:    	IN		AL,71H			; Wait for the uip to be high
		AND		AL,80H
		JZ		W2
    	IN		AL,71H			; Wait for the uip to be high
		AND		AL,80H
		JZ		W2
        endm


wait_till_change macro
		local	wc
		;mov		dx,379H
		mov		dx,3FEH		;new !!!
		in		al,dx
		mov		ah,al
wc:     in		al,dx
		xor		al,ah
		and		al,10h		;new !!!
		jz		wc			;new !!!
		;jns		wc
		endm


wait_rtc_second macro
		local	W1
		MOV 	AL,0H
		OUT 	70H,AL
		DAA
		DAA
		IN		AL,71H
		MOV		AH,AL
W1:    	IN		AL,71H
		CMP		AL,AH
		JZ		W1
		endm



_get_tick	proc far
	push ds
	mov bx,0
	mov ds,bx
	mov bx,46CH
	mov ax,[bx]
	pop ds
	ret
	endp


_get_tsc	proc far
	rdtsc
	mov dx,ax
	ror eax,16
	xchg dx,ax
	ret
	endp


_clocks_per_rtc_update	proc C far
	arg howmany:word
	cli
	mov cx,howmany
	wait_till_uip
	rdtsc
over:
	mov	edi,eax
	mov	esi,edx
	wait_till_uip
	loop over
	rdtsc
	SUB     EAX, EDI
	SBB		EDX, ESI
	STI                     ; Start Interrupts
	MOV     ECX, EAX        ; Preserve the low DWORD of CPU counts in ECX
	MOV     AX, CX          ; Load the lowest 16 bits of the CPU clock time into AX
	SHR     ECX, 16
	MOV     DX, CX          ; Load the next 16 bits of the CPU clock time into DX
    ret
	endp



_time_gold_system	proc far
        PUSH    EBX
        PUSH    ECX
        PUSH    EDI
        PUSH    ESI
        PUSH    ES
        CLI                     ;  stop interrupts
		wait_till_change
		rdtsc                   ; Read the time-stamp counter
        MOV     EDI, EAX        ; Preserve the Least Significant 32 bits
        MOV     ESI, EDX        ; Preserve the Most Significant 32 bits
		wait_till_change
		rdtsc                   ; Read the time-stamp counter
		SUB     EAX, EDI
		SBB		EDX, ESI
		STI                     ; Start Interrupts
		MOV     ECX, EAX        ; Preserve the low DWORD of CPU counts in ECX
		MOV     AX, CX          ; Load the lowest 16 bits of the CPU clock time into AX
		SHR     ECX, 16
		MOV     DX, CX          ; Load the next 16 bits of the CPU clock time into DX
		POP     ES
        POP     ESI
        POP     EDI
        POP     ECX
        POP     EBX
		RET                     ; Return with result in AX
        endp

test	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\inc\i2clib.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i2clib.h

Abstract:

    This module contains routines that speak to access
	the i2c temp chip and the SMC.
	The module is compiled into a static lib.

Author:

    Seth Milman (sethmil) 12/22/00

Environment:

    Windows

Revision History:


  12/22/00		created			sethmil


--*/



#ifndef _I2CLIB_H__
#define _I2CLIB_H__


/////////////////////////////////////////////////////
// 
// include files
//

#ifdef _XBOX
	#include <xtl.h>
#else
	#include <windows.h>
#endif
//#include <stdio.h>
//#include "cali2c32.h"




 
////////////////////////////////////////////////////
// constants
//
// Note, I2C Error codes have bit 16 set.
////////////////////////////////////////////////////

static const int NOACK				= 1;
static const int ACK				= 0;
static const int I2CBOARD			= 0;
static const DWORD SMCERROR			= 0xB001;
static const DWORD SMCWRITEERROR	= 0xB002;
static const DWORD SMCREADERROR		= 0xB003;




static const enum Frequency
{
	FREQ90K = 0,
	FREQ45K = 1,
	FREQ10K = 2
};



//
// SMC read registers
//
static const enum SMCReg
{
	FWVER				= 0x01,
	RESET				= 0x02,
	TRAYSTATE			= 0x03,
	VMODE				= 0x04,
	FANOVERRIDE			= 0x05,
	REQFANSPEED			= 0x06,
	LEDOVERRIDE			= 0x07,
	LEDSTATES			= 0x08,
	CPUTEMP				= 0x09,
	AIRTEMP				= 0x0A,
	AUDIOCLAMP			= 0x0B,
	DVDTRAYOP			= 0x0C,
	OSRESUME			= 0x0D,
	ERRORCODE_W			= 0x0E,
	ERRORCODE_R			= 0x0F,
	READFANSPEED		= 0x10,
	SMICODE				= 0x11,
	RAMTESTRESULTS_W	= 0x12,
	RAMTYPE_W			= 0x13,
	RAMTESTRESULTS_R	= 0x14,
	RAMTYPE_R			= 0x15,
	LASTREGWRITTEN		= 0x16,
	LASTBYTEWRITTEN		= 0x17,
	FORCESMI			= 0x18,
	TRAYRESETOVERRIDE	= 0x19,
	OSREADY				= 0x1A

};


static const enum AMDReg
{
	AMDAIRTEMP = 0x00,
    AMDCPUTEMP = 0x01
};

//
// I2C Error Codes
//
// note SMC error codes have bit 16 set
//
static const UINT SETUPERROR		= 0x9000;
static const UINT SENDADDRESSERROR	= 0x8001;
static const UINT WRITEBYTEERROR	= 0x8004;
static const UINT SENDSTOPERROR		= 0x8002;
static const UINT READBYTEERROR		= 0x8005;
static const UINT RESTARTERROR		= 0x8003;
static const UINT RECOVERERROR		= 0x8006;

static const UINT SLAVEERROR			= 0xA001;
static const UINT MASTERERROR			= 0xA002;
static const UINT SLAVENOTRESPONDING	= 0xA003;
static const UINT I2CERROR				= 0xA004;




#define I2CERROR(Status) ((DWORD)(Status) & 0x8000)

//
// SMC Status Bits
//		See PICA documentation for the definition of these bits
//
//		PIN = Pending Inerrupt Not - used for polling for recieved data
//				Transmitting: =0 when data has been sent, 1 when sending
//				Recieving:	  =0 when data has been recieved, 1 other times
//      STS = used for stop condition detection
//				1 when externally generated stop detected
//				0 other times
//		BER = bus error bit
//				1 when misplaces stop or start detected
//				0 other times
//		LRB = last recieved bit - when in master mode, used to detect slave's ack
//				= value is equal to slave acknowledge
//		ADO = address 0 - when in slave mode, used to detect a call to addr 0 (General call address)
//				1 if addressed as general address (address 0)
//		AAS = addressed as slave - used to determine if the card has been addressed to its slave address
//				1 if addressed as slave
//				0 other times
//		LAB = lost arbitration - in multimaster mode, used to detect loss of arbitration.
//				1 if lost arbitration
//				0 other times
//		BB  = bus busy bit - =1 if bus is busy, = 0 if bus is free
//				0 if bus is busy
//				1 if bus is free
//
static const DWORD		PIN = 0x80;
static const DWORD		STS = 0x20;
static const DWORD		BER = 0x10;
static const DWORD		ADO = 0x08;
static const DWORD		LRB = 0x08;
static const DWORD		AAS = 0x04;
static const DWORD		LAB = 0x02;
static const DWORD		BB  = 0x01;


//
// SMC addresses
//
static const DWORD SMCRADDR = 0x21;
static const DWORD SMCWADDR = 0x20;

static const DWORD AMDRADDR = 0x99;
static const DWORD AMDWADDR = 0x98;


//*******************************************************************
// Other SMC/I2C consts and enums


#ifdef _XBOX
	extern "C"
		{
		DECLSPEC_IMPORT
		LONG
		WINAPI
		HalReadSMBusValue(
			IN UCHAR SlaveAddress,
			IN UCHAR CommandCode,
			IN BOOLEAN ReadWordValue,
			OUT ULONG *DataValue
			);

		DECLSPEC_IMPORT
		LONG
		WINAPI
		HalWriteSMBusValue(
			IN UCHAR SlaveAddress,
			IN UCHAR CommandCode,
			IN BOOLEAN WriteWordValue,
			IN ULONG DataValue
			);
		}


	void WriteSMC(unsigned char reg, unsigned char value)
		{
		HalWriteSMBusValue(SMCWADDR, reg, FALSE, value);
		}


	DWORD ReadSMC(unsigned char reg)
		{
		DWORD value = 0xCCCCCCCC;
		HalReadSMBusValue(SMCRADDR, reg, FALSE, &value);
		return value;
		}


	void WriteAMD( unsigned char reg, unsigned char value)
	{
		HalWriteSMBusValue( AMDWADDR, reg, FALSE, value );
	}


	DWORD ReadAMD( unsigned char reg )
	{
		DWORD value = 0xCCCCCCCC;
		HalReadSMBusValue(AMDRADDR, reg, FALSE, &value );
		return value;
	}
#endif



////////////////////////////////////////////////////////////////
//
// Generic I2C functions
//
////////////////////////////////////////////////////////////////



	/****************
		sets up the I2C board
		addr - board address - bits 7..1 are used to set the address
			bit 0 is used as the R/!W bit
		freq - board Frequency

		sets up addresses

		returns error code
	*/
	DWORD I2CSetup( const UINT addr, const Frequency f );



	/*
		writes an address byte out
		to the I2C Bus

		returns error code
	*/
	DWORD I2CSendAddress( const UINT addr, const UINT ACK );


	/* 
		writes a byte of data out to the 
		I2C Bus

		returns error code
	*/
	DWORD I2CWriteByte( const UINT DATA );


	/* 
		reads a byte of data out to the 
		I2C Bus

		returns the byte
	*/
	DWORD I2CReadByte( const UINT ack );
	

	/*
		sends a stop to the I2C Bus
		
		return error code
	*/
	DWORD I2CSendStop();


	/*
		Restarts the I2CBoard

		returns error code
	*/
	DWORD I2CRestart( const UINT addr , const UINT ack );

	/*
		gets status of the I2CBoard

		returns status
	*/
	DWORD I2CGetStatus(  );

	/*
		tries to recover the I2CBoard

		returns error code
	*/
	DWORD I2CRecover();


	/* 
		returns the last slave byte read
	*/
	DWORD I2CSlaveLastByte( );


	/*
		dll issue??
	*/
	DWORD I2CDLLIssue();
	
	/*
		writes bytes to SMC address addr.
		writes "LENGHT" bytes from the lpzData string.  
		lpzData is a null terminated string
	*/
	DWORD I2CWrite( const TCHAR* lpzData, const UINT LENGTH, const UINT ADDR );



/////////////////////////////////////////////////////////////////////////////////////////////
//
// I2C Transaction Functions
//
/////////////////////////////////////////////////////////////////////////////////////////////
	/*
		uses Send Bytes SMC protocol to write an address
		and 1 byte of data

		Error Codes:
		returns SLAVENOTRESPONDING if the slave fails to respond
		returns SENDADDRESSERROR if I2CSendAddress returns an error.
		returns READBYTEERROR if read byte error occurred
		returns SENDSTOPERROR if send stop error occurred
	*/
	DWORD I2CSendByteTransaction( DWORD* dwDataArray, const DWORD dwArrayLength, 
							 const UINT uiAddr, const UINT uiData, const DWORD dwWaitCount );


	/*
		uses WriteByte protocol to write an
		address, command code, and data to a device
		on the SMBus.

		returns SLAVENOTRESPONDING if the slave fails to respond
		returns SENDADDRESSERROR if I2CSendAddress returns an error.
		returns WRITEBYTEERROR if write byte error occurred
		returns SENDSTOPERROR if send stop error occurred
	*/
	DWORD I2CWriteByteTransaction( DWORD* dwDataArray, 
								   const DWORD dwArrayLength, 
								   const UINT uiAddr, 
								   const UINT uiData1, 
								   const UINT uiData2,
								   const DWORD dwWaitCount );


	/*
		Master Mode
		Reads a byte from the slave using Receive Byte
		SMBus protocol

		returns SLAVENOTRESPONDING if the slave fails to respond
		returns SENDADDRESSERROR if I2CSendAddress returns an error.
		returns READBYTEERROR if read byte error occurred
		returns SENDSTOPERROR if send stop error occurred
	*/
	DWORD I2CReceiveByteTransaction( DWORD* dwDataArray,
								  const DWORD dwArrayLength,
								  const UINT uiAddr,
								  const DWORD dwWaitCount );



////////////////////////////////////////////////////////////////
//
// SMC Write functions
//
////////////////////////////////////////////////////////////////


	

	DWORD SMCWriteReg( SMCReg reg, DWORD data );

	/*
		write a reset to the SMC

		data: {0,0,0,0,0,0,0,assert_reset}
	*/

	DWORD SMCReset( DWORD data );



	/*
		write fan override data

		{0,0,0,0,0,0,0,Fan_override}
	*/
	DWORD SMCFanOverride( DWORD data );


	/*
		write fan speed to SMC

		data: RequestedFanSpeed7..0
	*/
	DWORD SMCRequestFanSpeed( DWORD data );


	/*
		writes LED override data

		data: {0,0,0,0,0,0,0,LED_override}
	*/
	DWORD SMCLEDOverride( DWORD data );


	/*
		writes Audio Clamp register

		data: {0,0,0,0,0,Audio_release_now, Audio_off}
	*/
	DWORD SMCAudioClamp( DWORD data );


	/*
		writes DVDTrayOp register

		data: {0,0,0,0,0,0,
				OS_DVD_open_request,
				OS_DVD_close_request}
	*/
	DWORD SMCDVDTrayOp( DWORD data );



	/*
		write OSResume register

		data: {0,0,0,0,0,
				OS_resume,
				OS_shutdown_in_progress,
				OS_shutdown_complete
				}
	*/
	DWORD SMCOSResume( DWORD data );


	/*
		writes ErrorCode register

		data: TBD
	*/
	DWORD SMCWriteErrorCode( DWORD data );




////////////////////////////////////////////////////////////////
//
// I2C/SMC Read functions
//
////////////////////////////////////////////////////////////////


	/* 
		I2C read function
		reads "length" bytes from the SMC

		returns -1 if failed
	*/
	INT I2CRead( TCHAR* lpData, const UINT LENGTH, const UINT ADDR, const UINT REG );

	
	/* 
		SMC read function
		reads "numbytes" bytes from the SMC

		returns -1 if failed
	*/
	INT SMCRead( TCHAR* lpData, const UINT LENGTH, const SMCReg REG );


	/* 
		SMC read byte function
		reads 1 byte from the SMC

		returns the byte read from the SMC
		returns -1 if failed
	*/
	INT SMCReadByte(  );


	/*
	//
	// DWORD SMCGetFWVersion( TCHAR* lpsFWVer, DWORD addr )
	//
	// parameters:
	//
	//  lpsFWVer - pointer to string that will contain
	//		the firmware version
	//  addr - address of the SMC
	//
	*/
	DWORD SMCGetFWVersion( TCHAR* lpsFWVer );


	/*
		reads tray state
		passes Tray State back as a LPS parameter
	*/
	DWORD SMCGetTrayState( TCHAR* lpsTrayState );


	/*
		reads video mode
		passes video mode as a parameter
	*/
	DWORD SMCGetVMode( TCHAR* lpsVMode );


	/*
		reads CPU temp
		returns CPU temp as a parameter
	*/
	DWORD SMCGetCPUTemp( TCHAR* lpsTemp );



	/* 
		reads Air Temp
		returns Air Temp as a parameter
	*/
	DWORD SMCGetAirTemp( TCHAR* lpsTemp );



	/* 
		reads ErrorCode Register

		returns ErrorCode as a parameter
	*/
	DWORD SMCGetErrorCode( TCHAR* lpsErrorCode );



///////////////////////////////////////////////////////////
//
// I2C Status Functions
//
//////////////////////////////////////////////////////////

	/*
		Name: I2CDataReady
		Desc: gets status of bus and returns TRUE if there is slave
				data ready to read
	*/
	BOOL	I2CDataReady();


	/*
		Name: I2CExternalStopDetected()
		Desc: When in slave mode, returns TRUE if a STOP was detected
				from the master
	*/
	BOOL	I2CExternalStopDetected();


	/* 
		Name: I2CBusError()
		Desc: Returns TRUE if the bus error status bit is set
	*/
	BOOL	I2CBusError();


	/*
		Name: I2CSlaveAck()
		Desc: Returns TRUE if an ACK was recieved from the slave
	*/
	BOOL	I2CSlaveAck();

	/*
		Name: I2CGeneralCallAddress
		Desc: returns TRUE if the slave address recieved was the 
				General Call Address
	*/
	BOOL	I2CGeneralCallAddress();


	/* 
		Name: I2CAddressedAsSlave
		Desc: Returns TRUE if the test card is acting as a slave
	*/
	BOOL	I2CAddressedAsSlave();


	/* 
		Name: I2CLostArbitration()
		Desc: In multimaster mode, returns TRUE if lost bus arbitration
	*/
	BOOL	I2CLostArbitration();


	/* 
		Name: I2CBusBusy()
		Desc: Returns TRUE if the I2C Bus is busy
	*/
	BOOL	I2CBusBusy();
	


//******************************************************************************
//
// SMC Functions
//
//******************************************************************************



//**********************************************************************************
// this function acts as a slave for transactions where the SMC is the master
//
// returns the number of bytes read from the bus
// dwDataArray is a pointer to a DWORD array.
// dwArrayLength is the lengto of the data array
// dwTemp is the temperature that the function will write to the SMC
// dwWaitCount is a counter.  The counter is used to determine the length of time
//			the function will wait before writing a byte.
//
// requires that the PIC93 card has been initialized with I2CSetup()
//
// returns READBYTEERROR if a read byte error occurred.
// returns WRITEBYTERROR if a write byte error occurred.
// *********************************************************************************


DWORD SMCSlaveTransaction( DWORD* dwDataArray, const DWORD dwArrayLength, 
						  const DWORD dwTemp, const DWORD dwWaitCount );


#endif // _I2CLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\speed.c ===
#include "dos.h"
#include "conio.h"
#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#define lptbase 0x378
#define ulong unsigned long
#define TRUE 1
#define FALSE 0

ulong ticks_per_gold_cycle, ticks_per_internal_cycle, delta;
int irep_rate, nloops=0;
float ppm, total_ppm = 0;
double one_second, rep_rate;


ulong time_gold_system(void);
ulong clocks_per_rtc_update(int hownamy);
int round(float number);


void main (void)
{
	printf("ͻ\n");
	printf("            CPU Speed Measurement using TSC             \n");
	printf("                     version 1.0                        \n");
	printf("                                                        \n");
	printf("   Intel OEM Products & Solutions Division, BVL Lab     \n");
	printf("           copyright (c) Intel Corp. 1998               \n");
	printf("ͼ\n\n");
	one_second = (double)clocks_per_rtc_update(1);
	printf ("CPU core frequency = %f MHz\n", one_second/1000000.0);
}


int round(float number)
{
	if (fmod(number, 1) < .5)
		return floor(number);
	else
		return ceil(number);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\msr.c ===
/****************************************
*                                       *
*     MSR Read/Write Utility            *
*     Russell Smith                     *
*     Intel.OPSD.BVL                    *
*     last edit: 26-Feb-99              *
*                                       *
*****************************************/



#include "stdio.h"
#include "stdlib.h"
#include "conio.h"
#include "time.h"
#include "process.h"
#include "dos.h"
#include "mem.h"
#include "ctype.h"
#include "string.h"


#define FALSE 0
#define TRUE 1
#define uchar unsigned char
#define uint unsigned int

#define out_of_range(bit) (bit>63) || (bit<0)

enum {READ, WRITE};
enum {FULL, SINGLE, RANGE};

// function prototypes

char top_level_menu(void);
void banner(void);
char usage(void);
char bad_range(void);
char bad_order(void);
char bad_syntax(void);
char bad_data(void);
void rdmsr(long addess, char *where);
void wrmsr(long addess, char *mask, char *bits);
char *get_psp_command_tail();
char pattern_match(char *text, char *pattern);
char scan_digits(char **ptr, char radix);
char isadigit(char ch, char howmany);
void display_full_msr(char *buffer, char base);
void display_binary(char *buffer, char left, char right);
void display_hex(char *buffer);
char bit_extract(char *buffer, char bitposition);
void bit_insert(char *buffer, char bitposition, char bit);
void shift_left_qword(char *buffer, char bit);
void shift_right_qword(char *buffer, char bit);
void set_attrib(int row, int col, char background, char foreground);

// global variables

char *temp, *delim;
int n, ch;
char type = FULL;
char direction = READ;
char base = 16;
unsigned long msr_address;
char leftbit, rightbit, singlebit;
char msr_buffer[8], input_buffer[8];
char and_buffer[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
char or_buffer[8] = {0,0,0,0,0,0,0,0};
	


	
void main(int argc, char *argv[])
{
	if (argc<2) exit(usage());  //just show usage message if null command line
/*	
  	get pointer to DOS command tail	and do a rigorous syntax check for all possible
  	valid command lines that fit the format "address [bit range] [=data] [/b]". uses
  	template matching routine pattern_match to scan for legal combinations of hex,
  	decimal and binary numbers, delimiters and switch characters.
*/
	temp = get_psp_command_tail();
	if (!(pattern_match(temp, "X"          ) ||
		  pattern_match(temp, "X /b"       ) ||
	      pattern_match(temp, "X=X"        ) ||
		  pattern_match(temp, "X=B /b"     ) ||
		  pattern_match(temp, "X D"        ) ||
		  pattern_match(temp, "X D=B"      ) ||
		  pattern_match(temp, "X D:D"      ) ||
		  pattern_match(temp, "X D:D /b"   ) ||
		  pattern_match(temp, "X D:D=X"    ) ||
		  pattern_match(temp, "X D:D=B /b" ))) exit(bad_syntax());
/*
	check last arg for /b switch. change radix to 2 from 16 and decrement argc if found.
*/	 	
	delim = strchr(argv[argc-1], '/');
	if (delim)
	{
		if (toupper(*(++delim)) == 'B') base = 2;
		argc--;
	}
/*
	parse first arg as hex MSR address.
*/
	msr_address = strtol(argv[1], &temp, 16);
/*
	check second arg for bit range specifier. if colon found, parse decimal numbers on
	both sides and check for legal values (0..63) and precedence (left# bigger than right#).
	if no colon, just parse a single decimal number.
*/
	if (argc == 3)
	{
		delim = strchr(argv[2], ':');
		if (delim)
		{
			leftbit = strtol(argv[2], &temp, 10);
			rightbit = strtol(delim+1, &temp, 10);
			type = RANGE;
			if (out_of_range(leftbit) || out_of_range(rightbit)) exit(bad_range());
			if (rightbit>=leftbit) exit(bad_order());
		}
		else
		{
			singlebit = strtol(argv[2], &temp, 10);
			type = SINGLE;
			if (out_of_range(singlebit)) exit(bad_range());
		}
	}
/*
	check last arg for write specifier (equals sign). if found parse the data according
	to binary/hex setting and verify that it will fit in MSR bit field specified.
*/
	delim = strchr(argv[argc-1], '=');
	if (delim++)
	{
		if (base==2)
		{
			while(isadigit(ch = *delim++, 2))
				shift_left_qword(input_buffer, ch);
		}
		else
		{
			while(isadigit(ch = *delim++, 16))
			{
				if (ch > '9') ch += 9;
				shift_left_qword(input_buffer, ch>>3);
				shift_left_qword(input_buffer, ch>>2);
				shift_left_qword(input_buffer, ch>>1);
				shift_left_qword(input_buffer, ch);
			}
		}
		direction = WRITE;
		for (n=63; n>0; n--)
		{
			if (bit_extract(input_buffer, n)) break;
		}
		if ((type == SINGLE) && (n > 0)) exit(bad_data());
		if ((type == RANGE) && (n > (leftbit-rightbit))) exit(bad_data());
	}
	
//	finally finished parsing, now really do something

	if (direction == READ)
	{
		rdmsr(msr_address, msr_buffer);
		switch(type)
		{
			case FULL:
					display_full_msr(msr_buffer, base);
					break;
			case SINGLE:
					printf("%d", bit_extract(msr_buffer, singlebit));
					break;
			case RANGE:
					for (n=leftbit; n>=rightbit; n--)
						shift_left_qword(or_buffer, bit_extract(msr_buffer, n));
					if (base==2)
						display_binary(or_buffer, leftbit-rightbit, 0);
					else
						display_hex(or_buffer);
					break;
		}
	}
	else
	{
		switch(type)
		{
			case FULL:
					wrmsr(msr_address, and_buffer, input_buffer);
					display_full_msr(input_buffer, base);
					break;
			case SINGLE:
					bit_insert(and_buffer, singlebit, 0);
					bit_insert(or_buffer, singlebit, input_buffer[0] & 1);
					wrmsr(msr_address, and_buffer, or_buffer);
					display_full_msr(or_buffer, base);
					break;
			case RANGE:
					for (n=rightbit; n<=leftbit; n++)
					{
						bit_insert(and_buffer, n, 0);
						bit_insert(or_buffer, n, input_buffer[0] & 1);
						shift_right_qword(input_buffer, 0);
					}
					wrmsr(msr_address, and_buffer, or_buffer);
					display_full_msr(or_buffer, base);
					break;
		}
	}
	exit(0);
 }


void banner(void)
{
	printf("ͻ\n");
	printf("        MSR Read/Write Utility  1.0        \n");
	printf("                                           \n");
	printf("        OPSD Board Validation Lab          \n");
	printf("     copyright (c) Intel Corp. 1999        \n");
	printf("ͼ\n\n");
}


char usage(void)
{
	banner();
	printf("Usage:   MSR address [bit range] [=data] [/b] \n\n");
	printf("         MSR address                  display contents of MSR \n");
	printf("         MSR address=data             write data to MSR \n");
	printf("         MSR address bit#             display single bit of MSR \n");
	printf("         MSR address bit#=data        write data to single bit in MSR \n");
	printf("         MSR address bit#:bit#        display contents of bit range of MSR \n");
	printf("         MSR address bit#:bit#=data   write data to bit range in MSR \n");
	printf("note: \n");
	printf("         data is entered and displayed as hexadecimal \n");
	printf("         by default or binary if /b switch present. \n");
	printf("         bit positions are always specified as decimal. \n");
	return 255;
}

char bad_range(void)
{
	banner();
	printf("invalid bit# specified, must be between 0 and 63\n");
	return 255;
}


char bad_order(void)
{
	banner();
	printf("left bit# must be greater than right bit#\n");
	return 255;
}


char bad_data(void)
{
	banner();
	printf("write data is too big for bit field specified\n");
	return 255;
}


char bad_syntax(void)
{
	banner();
	printf("syntax error in command line. type MSR<cr> to see usage screen\n");
	return 255;
}


void display_full_msr(char *buffer, char base)
{
	char n;
	
	if (base==2)
	{
		for (n=63; n >= 0; n--)
		{
			printf("%d", bit_extract(buffer, n));    //display in binary
			set_attrib(wherey(), wherex()-1, BLACK, (n&8)?LIGHTGRAY:WHITE);
		}
	}
	else
		for (n=7; n >= 0; n--)
			printf("%02X", (uchar)buffer[n]);    //display in hexadecimal
}



void set_attrib(int row, int col, char background, char foreground)
{
	char buffer[2];
	
	gettext(col, row, col, row, buffer);
    buffer[1] = foreground + (background << 4);
	puttext(col, row, col, row, buffer);
}


void display_binary(char *buffer, char left, char right)
{
	char n;
	
	for (n=left; n >= right; n--)
		printf("%d", bit_extract(buffer, n));
}



void display_hex(char *buffer)
{
	char n, ch;
	char done_non_zero_digit = FALSE;
	
	for (n=0; n < 15; n++)
	{
		ch = (buffer[7] >> 4) & 0x0F;
		if (ch)
		{
			printf("%X", ch);
			done_non_zero_digit = TRUE;
		}
		else
		{
			if (done_non_zero_digit)
				printf("0");
		}
		shift_left_qword(buffer, 0);
		shift_left_qword(buffer, 0);
		shift_left_qword(buffer, 0);
		shift_left_qword(buffer, 0);
	}
	printf("%X", (buffer[7] >> 4) & 0x0F);
}



char bit_extract(char *buffer, char bitposition)
{
	if (buffer[bitposition >> 3] & (1 << (bitposition & 7)))
		return 1;
	else
		return 0;
}



void bit_insert(char *buffer, char bitposition, char bit)
{
	char index, mask;
	
	index = bitposition >> 3;
	mask = 1 << (bitposition & 7);
	buffer[index] &= ~mask;
	if (bit)
		buffer[index] |= mask;
}


char pattern_match(char *text, char *pattern)
{
	char ch;
	
	while(ch = *pattern++)
	{
		switch(ch)
		{
			case 'X':	if (!scan_digits(&text, 16))         return FALSE; break;
			case 'D':	if (!scan_digits(&text, 10))         return FALSE; break;
			case 'B':	if (!scan_digits(&text,  2))         return FALSE; break;
			default:	if (toupper(*text++) != toupper(ch)) return FALSE;
		}
	}
	if (*text)
		return FALSE;
	else
		return TRUE;
}


char scan_digits(char **ptr, char radix)
{
	char *start;

	start = *ptr;
	while (isadigit(**ptr, radix)) (*ptr)++;
	if (start == *ptr)
		return FALSE;
	else
		return TRUE;
}


char isadigit(char ch, char howmany)
{
	char n;
	static char lookup[]="0123456789ABCDEF";
	
	for (n=0; n<howmany; n++)
	{
		if (toupper(ch) == lookup[n]) return TRUE;	
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\msr_util.asm ===
P586

test	SEGMENT USE16
	ASSUME  CS:test
	
	public	_rdmsr
	public	_wrmsr
	public	_shift_left_qword
	public	_shift_right_qword
	public	_get_psp_command_tail


_rdmsr	proc	C far
	arg	address:dword, where:dword
	push	ds
	pusha
	mov	ecx,address
	rdmsr
	lds	bx,where
	mov	[bx+4],edx
	mov	[bx],eax
	popa
	pop	ds
	ret
	endp


_wrmsr	proc	C far
	arg	address:dword, mask:dword, data:dword
	push	ds
	pusha
	mov	ecx,address
	cli
	wbinvd			;must write back dirty lines in case wrmsr alters any cache controls!!!
	jmp	next
next:	nop
	rdmsr			;do wrmsr as a read-modify-write operation
	lds	bx,mask
	and	edx,[bx+4]
	and	eax,[bx]
	lds	bx,data
	or	edx,[bx+4]
	or	eax,[bx]
	mov	[bx+4],edx	;return what we wrote in data arg
	mov	[bx],eax
	wrmsr
	popa
	pop	ds
	ret
	endp
	

_shift_left_qword proc	C far
	arg	address:dword, bit:word
	push	ds
	pusha
	lds	bx,address
	ror	byte ptr[bit],1
	rcl	dword ptr[bx],1
	rcl	dword ptr[bx+4],1
	popa
	pop	ds
	ret
	endp

	
_shift_right_qword proc	C far
	arg	address:dword, bit:word
	push	ds
	pusha
	lds	bx,address
	ror	byte ptr[bit],1
	rcr	dword ptr[bx+4],1
	rcr	dword ptr[bx],1
	popa
	pop	ds
	ret
	endp
	
	
_get_psp_command_tail proc C far
	push	bx
	push	ds
	mov	ah,51h
	int	21h
	mov	ds,bx
	mov	bx,81h
	add	bl,[bx-1]
	adc	bh,0
	mov	byte ptr[bx],0
	mov	dx,ds
	mov	ax,82h
	pop	ds
	pop	bx
	ret
	endp	


test	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\cpu.cpp ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// Title: cpu
//
// Abstract: This is the entry point into the CPU tests
//           
// History:
//
// 02/07/97 V1.00 SSS Release V1.00.
// 02/25/97 V1.10 SSS Testlib recompile.
// 03/17/97 V1.11
// 05/08/97 V2.00 MET Linked to testlib V2.00 DLL.
// 06/26/97 V2.01 JWW Added 'Stress subtest.
// 07/21/97 V2.02 JWW Added CPU.HLP file.
// 07/21/97 V2.03 JWW Added AUTOCONFIGURE.
// 01/06/98 V2.04 JWW Corrected bug in AUTOCONFIGURE.
// 				  Removed unnecessary status messages.
// 02/12/98 V2.05 JWW Modified OffSteppingsNotAllowed_X parameters
//                to OffSteppingsNotAllowed[X].	Modified help file
//				  to include Autoconfigure subtest.
// 03/12/98 V2.06 JWW Modified Autoconfigure and .snp file for V3.00.
// 08/25/98 V2.08 TRW Added SIMD features test, and cleaned up cpu clone problem in selfsense.
// 04/08/00 V2.09 SLK Corrected bug in SIMD test, added CPU speed test, cleaned up
//				  level 4 warnings, added cache and cpu text descriptions.  
//				  Renamed Katmai/MMX2 notations to SIMD.
//

#include "stdafx.h"
#include "wtlib.h"
#include "cpu.h"
#include "Prime95.h"
#include "windows.h"
#include "process.h"
#include "dmi16.h"
#include "string.h"

BOOL BIOSmapped;
BYTE *pBuffer;
Type CPUType;
Cache CacheRegA, CacheRegB, CacheRegC, CacheRegD;
Features CPUFeatures;

// assign values to variables declared in cpu.h
extern "C" unsigned long PARG=0;
extern "C" double MAXERR=0.0;
extern "C" double SUMINP=0.0;
extern "C" double SUMOUT=0.0;
extern "C" double ERRCHK=0.0;

char ERRMSG1A[]="ERROR: ILLEGAL SUMOUT";
char ERRMSG1B[]="ERROR: SUM(INPUTS) != SUM(OUTPUTS), %.10g != %.10g\n";
char ERRMSG1C[]="ERROR: ROUND OFF (%.10g) > 0.40\n";

// functions in xmm.asm, external because Microsoft C++ compiler doesn't recognize yet.
extern "C" void xmm128SHF(struct_128* fresultp);
extern "C" void xmm128CMP(void* dataf1, void* dataf2, struct_128* fresultp);
extern "C" void xmm128FLT(void* dataf1, void* dataf2, struct_128* fresultp);
extern "C" void xmm128INT(void* dataf1, struct_128* iresultp);
extern "C" void xmmtest(void);

#pragma warning (disable:4725)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
#endif

static unsigned char versionnumber[] = "version_number=3.0";	  /* compiler says never used-but is used in WinMTA */
int TestNumber;

#define NUM_TIMES 20
#define MBYTE 0x100000
#define ERR_INVALIDTESTCASE			0x0
#define ERR_CPUIDNOTSUPPORTED		0x1
#define ERR_CPUIDEXCEPTION			0x2
#define ERR_VALUENOTSAVED_S			0x3
#define ERR_ERRMSGNOTRETRIEVED		0x4
#define ERR_COULDNTREADOSVERS		0x5
#define ERR_SIMDEXCEPTION			0x6
#define ERR_PARAMETERNOTFOUND_S		0x7
#define ERR_WRONGFAMILY_D			0x8
#define ERR_WRONGMODEL_D			0x9
#define ERR_STEPPINGNOTALLOWED_X	0xA
#define ERR_MMXNOTPRESENT			0xB
#define ERR_MMXPRESENT_INVALID		0xC
#define ERR_SIMDNOTPRESENT			0xD
#define ERR_SIMDPRESENT_INVALID		0xE
#define ERR_FPUNOTPRESENT			0xF
#define ERR_FPUPRESENT_INVALID		0x10
#define ERR_MMX_MOVE				0x11
#define ERR_PENTIUMBUG_F			0x12
#define ERR_FREEINGMEMORY			0x13
#define ERR_ALLOCMEMORY				0x14
#define ERR_SIMD_NOTSUPPORT_OS		0x15	
#define ERR_COPYGROUP_S				0x16
#define ERR_SIMD_MOVE				0x17 
#define ERR_SIMD_FP_SP				0x18
#define ERR_SIMD_CMP_MAX_SUB		0x19
#define ERR_SIMD_MUL_DIV_CVT		0x1A
#define ERR_CHG_CLASS_PRIORITY		0x1B
#define	ERR_CHG_THREAD_PRIORITY		0x1C
#define	ERR_CREATE_MUTEX_D			0x1D
#define ERR_ACCESS_MUTEX_D			0x1E
#define ERR_RELEASE_MUTEX_D			0x1F
#define	ERR_NOORIGVALUE_S			0x20
#define	ERR_NOMATCH_ORIGANDNEW_DD	0x21
#define	ERR_BUSSPEED_OS				0x22	
#define ERR_LASTERRTXT_S			0x23
#define ERR_SQ_NUM_S				0x24
#define ERR_ROUNDING_S				0x25
#define ERR_FFT_FAILURE_S			0x26
#define ERR_UNEXPECTED_RESULT_S		0x27
#define ERR_INSUFF_SPACE			0x28
#define ERR_NULL_PTR				0x29
#define ERR_CACHE_DESC_KEY			0x2A
#define ERR_CPU_DESC				0x2B
#define ERR_CACHE_DESC				0x2C
#define ERR_RETRIEVING_VALUE_S		0x2D
#define ERR_DESC_SPACE				0x2E
#define ERR_WRONG_CPU_TYPE_DD		0x2F
#define ERR_LOC_PROCESSOR_INFO		0x30
#define ERR_RETRIEVING_BUS_SPEED	0x31
#define ERR_READING_SMBIOS			0x32
#define ERR_RETR_ERRMSG				0x33
#define ERR_MAPPING_BIOS			0x34
#define ERR_FINDING_PROC_STRUCTURE	0x35
#define ERR_2STEPPINGLISTS			0x36

char *error_list[]={
	"Test case number not valid.",												// 0
	"CPUID instruction not supported, unable to continue.",						// 1
	"Unexpected exception from CPUID instruction.",								// 2
	"Unable to save value %s.",													// 3
	"Unable to retrieve error message.",										// 4
	"Unable to read Operating System version.",									// 5
	"Unrecognized exception to Streaming SIMD instruction.",					// 6
	"The following parameter was not found: %s.",								// 7
	"The CPU is not of the correct family (value retrieved=%d).",				// 8
	"The CPU is not of the correct model (value retrieved=%d).",				// 9
	"Stepping is not allowed: 0x%x.",											// A
	"MMX support not present when it should be.",								// B
	"MMX support present when it should not be.",								// C
	"SIMD support not present when it should be.",								// D
	"SIMD support present when it should not be.",								// E
	"FPU unit not present when it should be.",									// F
	"FPU unit present when it should not be.",									// 10
	"MMX mov operations failed.",												// 11
	"Pentium FDIV bug detected\n Expected 4915835/3145727*3145727-4915835 = 0\nReceived %f.", // 12
	"Error Freeing Memory.",														// 13
	"Error Allocating Memory.",													// 14
	"Operating System does not support Streaming SIMD Extensions.\nWindows NT 4.0 requires SP5 or greater.\nIf you already have SP5 installed, please reinstall then retry the test.",			// 15
	"Unable to copy group %s.",													// 16
	"Streaming SIMD Register move operations failed.",							// 17
	"SIMD FP SP operations failed.",											// 18
	"SIMD CMP MAX AND SUB FP SP operations failed.",							// 19
	"SIMD MUL, DIV, CVT FP SP operations failed.",								// 1A
	"Unable to change class priority.",											// 1B
	"Unable to change thread priority.",										// 1C
	"Unable to create mutex, error code is %d.",								// 1D
	"Unable to access mutex, error code is %d.",								// 1E
	"Unable to release mutex, error code is %d.",								// 1F
	"Unable to retrieve original value of parameter %s.  Did auto-configure run?",	// 20
	"Original value (%d) did not match new value (%d).",						// 21
	"Bus Speed test must run on Windows NT or 2000 operating systems.",			// 22
	"Last error text=%s.",														// 23
	"Squaring: %s.",															// 24
	"Rounding: %s.",															// 25
	"FFT Failure: %s.",															// 26
	"Unexpected result: %s.",													// 27
	"Not enough space allocated for return value.",								// 28
	"Pointer cannot be NULL.",													// 29
	"Cannot access cache description key.",										// 2A
	"Unable to retrieve CPU description.",										// 2B
	"Unable to retrieve cache description",										// 2C
	"Unable to retrieve saved value %s.",										// 2D
	"Insufficient space to store all information.",								// 2E
	"The CPU (%d) is not of the correct type (%d).",							// 2F
	"Unable to locate Processor Information structure.",						// 30
	"Unable to retrieve bus speed.",											// 31
	"Unable to read SMBIOS table from memory.",									// 32
	"Unable to retrieve last error code and text.",								// 33
	"Unable to map BIOS.",														// 34
	"Unable to find processor structure in BIOS.",								// 35
	"Cannot have both 'Steppings Allowed' and 'Steppings Not Allowed' lists.",	// 36
	"",		// 37
	"",		// 38
	"",		// 39
	"",		// 3A
	"",		// 3B
	"",		// 3C
	"",		// 3D
	"",		// 3E
	""		// 3F
};

/////////////////////////////////////////////////////////////////////////////
// CCpuApp

BEGIN_MESSAGE_MAP(CCpuApp, CWinApp)
	//{{AFX_MSG_MAP(CCpuApp)
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCpuApp construction

CCpuApp::CCpuApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCpuApp object

CCpuApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CCpuApp initialization
#pragma optimize("g",off)//Necessary for use with in line assembly with Intel compiler

BOOL CCpuApp::InitInstance()
{
	if(!wt_initialize(&TestNumber))
		return FALSE;
	//get a test parameter common to all tests
	int status = wt_getint("loops",&status);
	// you would check status here if this was a required parameter
	status = wt_getint("faultinject",&status);
	status = wt_getint("devdebug",&status);

	if (TestNumber != 0) // ie, not autoconfig
	{
		int cpu;
		if (wt_getint ("cpu number", &cpu))
		{
			DWORD threadMask = 1;
			threadMask <<= cpu;
			SetThreadAffinityMask (GetCurrentThread (), threadMask);
			Sleep (0); // Wait for the next quantum to switch to the selected CPU
		} else {
			cpu=-1;		// unable to retrieve CPU number
		}
	}

	// Using the TestNumber passed to us we switch to the specific code for the given test.
	switch(TestNumber)
	{
		case 0:   SelfSense();			  break;
		case 1:   DisplayCPUFeatures();   break;
		case 2:   CPUFeatureCheck();      break;
		case 3:   FPUFeatures();          break;
		case 4:   MMXFeatures();          break;
		case 5:   FPUStress();            break;    
		case 6:   SIMDFeatures();         break;    
		case 7:	  CkCPUSpeed();			  break;


		default:  PrintError(ERR_INVALIDTESTCASE,error_list[ERR_INVALIDTESTCASE]);
	}

	wt_progress(100);
	wt_done();
	return FALSE;	  
}



//******************************************************************
// Title: SelfSense
// Abstract: Sets CPU configuation parameters.
//******************************************************************

void SelfSenseCPU (char *path, char *name, int cpu)
{
	int cpu_speed_val;
//	WORD bus_speed_val;			/* ADD BACK IN ONCE LIBRARY DAN OSAWA IS CREATING IS DONE */

	Sleep (1); // Wait for the next quantum to be schedualed on the selected CPU
	char PathStr[80] = "";
	
	GetCPUID();
	// Set configuration parameters
	  if(!wt_copy_group (path, name, PathStr, sizeof (PathStr))) {
		  PrintError(ERR_COPYGROUP_S, error_list[ERR_COPYGROUP_S], "CPU");
		  return;
	  }
	  if(!wt_putint(PathStr,"CPU NUMBER",cpu)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU NUMBER");
		  return;
	  }
	  if(!wt_putint(PathStr,"CPU TYPE",CPUType.ProcType)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU TYPE");
		  return;
	  }
	  if(!wt_putint(PathStr,"MODEL",CPUType.Model)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "MODEL");
		  return;
	  }
	  if(!wt_putint(PathStr,"FAMILY",CPUType.Family)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "FAMILY");
		  return;
	  }
	  if(!wt_putint(PathStr,"MMX",CPUFeatures.MMX)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "MMX");
		  return;
	  }
	  if(!wt_putint(PathStr,"FPU",CPUFeatures.FPU)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "FPU");
		  return;
	  }
	  if(!wt_putint(PathStr,"SIMD",CPUFeatures.XMM)) {
		  PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "SIMD");
		  return;
	  }

	// ck processor speed
	cpu_speed_val=CPUSpeed();
	if(!wt_putint(PathStr, "CPU SPEED", cpu_speed_val)) {
		PrintError(ERR_VALUENOTSAVED_S, error_list[ERR_VALUENOTSAVED_S], "CPU SPEED");
		return;
	}
/*	ADD CODE BACK IN ONCE LIBRARY THAT DAN OSAWA IS CREATING IS COMPLETE
	// ck bus speed	ONLY IF OS =Windows NT/2000
	if(!IsNTor2000()) {
		wt_remove_subtest(PathStr, 0x09);
	} else { 
		if(!BusSpeed(&bus_speed_val, cpu)) {
			wt_remove_subtest(PathStr, 0x09);
			PrintError(0x31, error_list[0x31]);
			wt_done();
			return;
		}
		if(!wt_putint(PathStr, "BUS SPEED", bus_speed_val)) {
			PrintError(0x03, error_list[0x03]);
			return;
		}
	}
*/
	if(!CPUFeatures.FPU)
	{
		wt_remove_subtest(PathStr,0x03);
		wt_remove_subtest(PathStr,0x05);
	}
	if(!CPUFeatures.MMX)
		wt_remove_subtest(PathStr,0x04);

	if(!CPUFeatures.XMM) {
		wt_remove_subtest(PathStr,0x06);
	} else {		// processor reports SIMD support - does OS support also?
		if(!TrySIMD()) {	// operating system does NOT support
			wt_remove_subtest(PathStr, 0x06);
		}
	}
	wt_remove_subtest(PathStr, 0x08);
	return;
}

/***************************************************************************************\
* Title:	SelfSense
* Abstract:	
\***************************************************************************************/
void SelfSense ()
{
	char pathName[128] = "";
	char groupName [128], origGroupName[128];

	// set global variable BIOSMAPPED to FALSE to indicate that MapBios() fcn hasn't run
	BIOSmapped=FALSE;

	// First get the path 
	wt_getstring("$PATH",pathName,sizeof(pathName));
	char *name = strrchr (pathName, '.');
	strcpy (origGroupName, name? (name + 1):pathName);

/* ADD CODE BACK IN ONCE LIBRARY THAT DAN OSAWA IS CREATING IS DONE
	// BIOS should be mapped once for entire SelfSense, so map before calling SelfSenseCPU
	if(IsNTor2000()) {			// only works on Windows NT or Windows 2000 OS
		if(!MapBIOS()) {
			PrintError(0x34, error_list[0x34]);
		}
		BIOSmapped=TRUE;		// flag to stop from trying to map multiple times.
	}
*/

	// Get the process affinity mask to see how many processors are available
	DWORD processMask, systemMask, threadMask = 1;
	BOOL gotMask = GetProcessAffinityMask (GetCurrentProcess (), &processMask, &systemMask);
	if (gotMask && (processMask != systemMask))
		wt_advisory ("This process does not have access to all CPU's");

		for (int cpu = 0; cpu < 32; cpu++)
		{
			sprintf(groupName, "%s %d", origGroupName, cpu);
			if (processMask & 1) // if low bit set
			{
				if (SetThreadAffinityMask (GetCurrentThread (), threadMask))
					SelfSenseCPU (pathName, groupName, cpu);
				else
				{
					DWORD error = GetLastError();
					wt_advisory ("SetThreadAffinityMask failed for CPU %d\n%s", cpu, 
						GetLastErrorText(error));
				}
			}
			threadMask <<= 1;
			processMask >>= 1;
		}

		wt_remove_group (pathName);
}



//******************************************************************
// Title: CPUFeatureCheck
//
// Abstract: Checks the features on the CPU vs any parameters
//******************************************************************

void CPUFeatureCheck()
{
	char SteppingsParamName[256], cpu_desc[1024]="", cache_desc[1024]="";
	unsigned int SteppingsAllowed;
	unsigned int SteppingsNotAllowed;
	unsigned int Model, Family, Type;
	BOOL SteppingOK = TRUE;
	int x, locStepAllw=0, locStepNotAllw=0;
	unsigned int fpu,mmx, simd;

	GetCPUID();

	// check the family, type and model
	if (!wt_getuint("Family",&Family)){	
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Family");
		wt_done();
	}
	if(!wt_getuint("CPU Type", &Type)) {
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Type");
		wt_done();
	}
	if (!wt_getuint("Model",&Model)){	
		PrintError(ERR_PARAMETERNOTFOUND_S, error_list[ERR_PARAMETERNOTFOUND_S], "Model");
		wt_done();
	}
	// retrieve original CPU description
	if(!CPUDescription(cpu_desc, 1024, Type, Model, Family)) {
		PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
		wt_done();
	}

	if(Family != CPUType.Family){
		PrintError(ERR_WRONGFAMILY_D, error_list[ERR_WRONGFAMILY_D], Family);
	}
	if(Model != CPUType.Model) {
		PrintError(ERR_WRONGMODEL_D,error_list[ERR_WRONGMODEL_D],Model);
	}
	if(Type != CPUType.ProcType) {
		PrintError(ERR_WRONG_CPU_TYPE_DD, error_list[ERR_WRONG_CPU_TYPE_DD],Type);
	}
	wt_status("CPU description: %s", cpu_desc);

	// check for steppings not allowed
	for(x=0;x<99;x++)
	{
		sprintf(SteppingsParamName,"SteppingsNotAllowed[%d]",x);
		if (!wt_getuint(SteppingsParamName,&SteppingsNotAllowed)){
			break;
		}
		locStepNotAllw=TRUE;
		// if we found the featuresAllowed once from now on we must find a match
		if( SteppingsNotAllowed == (unsigned int)CPUType.Stepping){
			PrintError(ERR_STEPPINGNOTALLOWED_X, error_list[ERR_STEPPINGNOTALLOWED_X],CPUType.Stepping);
			wt_done();
		}
	}

	// check the steppings allowed
	for(x=0;x<99;x++)
	{
		sprintf(SteppingsParamName,"SteppingsAllowed[%d]",x);
		if (!wt_getuint(SteppingsParamName,&SteppingsAllowed)){
			break;
		}
		locStepAllw=TRUE;
		// if we found the featuresAllowed once from now on we must find a match
		SteppingOK = FALSE;
		if( SteppingsAllowed == (unsigned int)CPUType.Stepping){
			SteppingOK = TRUE;
			break;
		}
	}
	// can't have both a "Steppings Allowed" AND a "Steppings Not Allowed" list
	if (locStepAllw && locStepNotAllw) {
		PrintError(ERR_2STEPPINGLISTS, error_list[ERR_2STEPPINGLISTS]);
	}

	if (SteppingOK == FALSE) {
		PrintError(ERR_STEPPINGNOTALLOWED_X, error_list[ERR_STEPPINGNOTALLOWED_X], CPUType.Stepping);
	}
	
	// check for MMX
	if (wt_getuint("mmx",&mmx))
	{
		if(mmx != CPUFeatures.MMX)
		{
			if (CPUFeatures.MMX == 0)
			   PrintError(ERR_MMXNOTPRESENT,error_list[ERR_MMXNOTPRESENT]);
			else
			   PrintError(ERR_MMXPRESENT_INVALID,error_list[ERR_MMXPRESENT_INVALID]);
		}
	}

	// check for SIMD/mmx2
	if (wt_getuint("SIMD",&simd))
	{
		if(simd != CPUFeatures.XMM)
		{
			if (CPUFeatures.XMM == 0)
			   PrintError(ERR_SIMDNOTPRESENT,error_list[ERR_SIMDNOTPRESENT]);
			else
			   PrintError(ERR_SIMDPRESENT_INVALID,error_list[ERR_SIMDPRESENT_INVALID]);
		}
	}

	// check for FPU
	if (wt_getuint("fpu",&fpu))
	{
		if(fpu != CPUFeatures.FPU)
		{
			if (CPUFeatures.FPU == 0)
			   PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
			else
			   PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
		}
	}

	// retrieve the cache description
	if(!CacheDescription(cache_desc, 1024)) {
		PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
		wt_done();
	}
	wt_status("Cache=%s", cache_desc);
}


//******************************************************************
// Title:		MMXFeatures
// Abstract:	Test MMX commands
//******************************************************************
void mmxtest(void *TempDwordPtr, void *ResultPtr)
{
	_asm {
		; Move inst.	
		mov	eax,12345678h
		movd	mm0,eax
		movd	ebx,mm0
		movd	mm1,ebx
		mov	edi,TempDwordPtr
		movd	[EDI],mm1
		movd	mm2,[EDI]
		movq	mm3,mm2
		movd	[EDI],mm3
		movq	mm4,[EDI]
		movq	mm5,mm4
		movq	mm6,mm5
		movq	mm7,mm6
		mov	edi,ResultPtr
		movd	[edi],mm7
		emms		     ; empty MMX state
	}
	return;
}

void MMXFeatures()
{
	DWORD TempDword;
	DWORD * TempDwordPtr;
	DWORD Result;
	DWORD * ResultPtr;
	unsigned int x,y;
	int iTestProgress = 0;

	// check for an MMX unit
	GetCPUID();
	if(CPUFeatures.MMX == 0)
	{
		PrintError(ERR_MMXNOTPRESENT,error_list[ERR_MMXNOTPRESENT]);
		wt_done();
	}
	for(y=1;y<100;y++)
	{

    	// Record progress
		if(y%10 == 0)
		{
			iTestProgress+=10;
			wt_progress(iTestProgress);
		}

		
		for(x=0;x<1000;x++)
		{
			ResultPtr = &Result;
			TempDwordPtr = &TempDword;
			mmxtest(TempDwordPtr,ResultPtr);
			if(Result != 0x12345678)
			{
				PrintError(ERR_MMX_MOVE,error_list[ERR_MMX_MOVE]);
				break;
			}
		} //x
		Sleep(100);
	} //y
}
//******************************************************************
// Title: MMXDTC
// Abstract:
//******************************************************************
void MMXDTC()
{
}
//******************************************************************
// Title:	CPUfault
// Abstract:
//******************************************************************
void CPUfault()
{
}
//******************************************************************
// Title:	DisplayCPUFeatures
// Abstract:
//******************************************************************
void DisplayCPUFeatures()
{
	char cache_desc[1024]="", cpu_desc[1024]="";

	GetCPUID();
	wt_status("Type reg=0x%x, Feature reg = 0x%x",CPUType.reg,CPUFeatures.reg);
	wt_status("Stepping=0x%x\nModel=0x%x\nFamily=0x%x\nType=0x%x",CPUType.Stepping, CPUType.Model, CPUType.Family, CPUType.ProcType);
	if(!CacheDescription(cache_desc, 1024)) {
		PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
		return;
	}
	if(!CPUDescription(cpu_desc, 1024, CPUType.ProcType, CPUType.Model, CPUType.Family)) {
		PrintError(ERR_CPU_DESC, error_list[ERR_CPU_DESC]);
		return;
	}
	
	wt_status("CPU Description=%s\nCache Description=%s", cpu_desc, cache_desc);
	
	if(CPUFeatures.FPU)
		wt_status("Floating Point unit present");
	else
		wt_status("Floating Point unit not present");
	if(CPUFeatures.MMX)
		wt_status("MMX unit present");
	else
		wt_status("MMX unit not present");
	if(CPUFeatures.XMM)
		wt_status("SIMD unit present");
	else
		wt_status("SIMD unit not present");
}


//******************************************************************
// Title:	FPUFeatures
// Abstract:
//******************************************************************
void FPUFeatures()
{
	double num = 4195835;
	double den = 3145727;
	double result;
	unsigned int x,y;

	// check for an MMX unit
	GetCPUID();

	if(CPUFeatures.FPU == 0)
	{
		PrintError(ERR_FPUNOTPRESENT,error_list[ERR_FPUNOTPRESENT]);
		wt_done();
	}
	
	for(y=1;y<100;y++)
	{
	for(x=1;x<100000;x++)
	{
	// Pentium Bug Check

	result = num / den * den - num;

	/*
	 * Bad to test floating point for equality, allows some error.
	 * A real failure returns -256 anyway.
	 */
	if(result < -0.000000001 || result > 0.000000001)
	{
		PrintError(ERR_PENTIUMBUG_F, error_list[ERR_PENTIUMBUG_F],result);
		wt_done();
	}
	} //x
	Sleep(100);
	} //y
}
//******************************************************************
// Title: PrintError
// Abstract: Tacks the module number and testnumber on to our error messages
//******************************************************************

void PrintError(unsigned int ecode, LPCTSTR format_string,...)
{
	char ErrorMessage[4096];
	unsigned int mcode = 0x85;
	va_list argptr;

	mcode = (mcode << 20) + (TestNumber <<12) + ecode;
		
	va_start(argptr,format_string);
	vsprintf(ErrorMessage,format_string,argptr);
	wt_error(mcode,ErrorMessage);

}


//******************************************************************
// Title: FPUStress 
// Abstract: Computes Mersenne Prine Numbers
//           Uses Dr. Richard Crandall's algorithm
//******************************************************************
void FPUStress()
{
	static LPVOID memreserved = NULL;
	unsigned long fftlen;
	char buf[100];
	unsigned long k;
	unsigned int i;
	unsigned long p;
	unsigned int ll_iters;
	char failed;
	int iTestProgress = 0;
	failed=FALSE;
	fftlen=65536;

		
	// Load the appropriate EXE file and setup
	THE_END = THE_END_64;
	lucas = lucas64;
	
	// Now we know how much memory to reserve

	//freeing memory
	if (memreserved != NULL) 
	{
		if (!VirtualFree (memreserved,0, MEM_RELEASE))
		{		
			PrintError(ERR_FREEINGMEMORY,error_list[ERR_FREEINGMEMORY]);
			wt_done();				
		}
			
		memreserved = NULL;
	}


	// Allocate memory for the assembly code
	memreserved = VirtualAlloc ((void*)DATA_ADDR,   /* compiler complains but it works */
		THE_END - DATA_ADDR,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_READWRITE);

	if (memreserved == NULL) 
	{
			PrintError(ERR_ALLOCMEMORY,error_list[ERR_ALLOCMEMORY]);
			wt_done();				
	}

	// Determine the range from which we'll choose an exponent to test.
	i=128; 
	p=1344999;

	
	// Check for configuration parameter
	if(!wt_getuint("ITERATIONS",&ll_iters))
			ll_iters = 400;

	// Now run Lucas setup
	PARG = p;
	setup64 ();

	// Init data area with a pre-determined value
	//clear the memory
	for (k=0; k<fftlen; k++) 
		set_fft_value(p, fftlen,k,0);
	set_fft_value (p, fftlen, 0, 4);


	// Do Lucas-Lehmer iterations
	for (k = 0; k <ll_iters; k++) 
	{
		
		// Record progress
		if(k%40 == 0)
		{
			iTestProgress+=10;
			wt_progress(iTestProgress);
		}
		// One Lucas-Lehmer test with error checking			
		
		ERRCHK++;
		(*lucas)();
		ERRCHK--;
		
		// If the sum of the output values is an error (such as infinity)
		// then raise an error.  For some reason these bad values are treated
		// as zero by the C compiler.  There is probably a better way to
		// check for this error condition.

		if (SUMOUT <= 0.0) 
		{
			sprintf(buf,"i=%u, k=%lu, ",i,k);
			failed=TRUE;
			break;
		}

		// Check that the sum of the input numbers squared is approximately
		// equal to the sum of unfft results.  Note that as the sum of the
		// inputs approaches zero the more error we must tolerate. 

		if (SUMOUT < SUMINP-128.0 || SUMOUT > SUMINP+128.0) 
		{
			sprintf (buf, ERRMSG1B, SUMINP, SUMOUT);
			sprintf(buf,"i=%u, k=%lu, ",i,k);
			PrintError(ERR_SQ_NUM_S,error_list[ERR_SQ_NUM_S],buf);
			failed=TRUE;
			break;
		}


		// Make sure round off error is tolerable
		if (MAXERR > 0.40) 
		{
			sprintf (buf, ERRMSG1C, MAXERR);
			sprintf(buf,"k=%lu, ",k);
			failed=TRUE;
			PrintError(ERR_ROUNDING_S,error_list[ERR_ROUNDING_S],buf);
			break;
		}

	} // end for

	// Check for failure 
	if (failed==TRUE) 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		PrintError(ERR_FFT_FAILURE_S,error_list[ERR_FFT_FAILURE_S],buf);
		// FAILED!
	} 
	
	else 
	{
		sprintf(buf,"FFT length=%lu --> ",fftlen);
		wt_status("Passed FPU stress test!");
		// PASSED!	
	}
		

}

/***************************************************************************************\
* Title:	GetLastErrorText
* Abstract:	Retrieve error text matching code input as parameter to function.
\***************************************************************************************/
CString GetLastErrorText(DWORD dwLastError)
{
	DWORD dwRet;
	LPTSTR lpszTemp = NULL;
	CString msg;

	dwRet = ::FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		 FORMAT_MESSAGE_FROM_SYSTEM    |
		 FORMAT_MESSAGE_ARGUMENT_ARRAY |
		 FORMAT_MESSAGE_MAX_WIDTH_MASK,
		NULL,
		dwLastError,
		LANG_NEUTRAL,
		(LPTSTR)&lpszTemp,
		0,
		NULL);

	// supplied buffer is not long enough
	if(dwRet)
	{
		lpszTemp[lstrlen(lpszTemp) - 2] = TEXT('\0');  //remove cr+lf
		msg.Format(TEXT("%s (0x%x)"),lpszTemp,dwLastError);
		LocalFree((HLOCAL)lpszTemp);
	}

	return msg;
}



/***************************************************************************************\
* Title:	SIMDFeatures 
* Abstract:	Invoke SIMD commands, make sure appropriate values are returned.  If 
*			processor doesn't support SIMD, this function should have been disabled.
*			Error if this function is called and the processor does NOT support SIMD.
\***************************************************************************************/
void SIMDFeatures()
{
	char buf[100];

	unsigned int x,y;
	int iTestProgress = 0;
	
	// check for a SIMD unit
	GetCPUID();
	if(CPUFeatures.XMM == 0)
	{
		PrintError(ERR_SIMDNOTPRESENT,error_list[ERR_SIMDNOTPRESENT]);
		wt_done();
	}
	// Check for Streaming SIMD Extension OS Support
	if(!TrySIMD()) {
		wt_advisory(error_list[ERR_SIMD_NOTSUPPORT_OS]);
		wt_done();
	}
	for(y=1;y<10;y++)
	{
		iTestProgress+=10;
		wt_progress(iTestProgress);

		for (x=0;x<10;x++)
		{

			/* set up 128 bit INT data and INT results */			
			struct_128 data_int = {1,2,3,4};
			void* datai = &data_int;			/* compiler says never used - used in ASM */
			struct_128 iresult;
			struct_128* iresultp = &iresult;		/* compiler says never used - used in ASM */
			xmm128INT(datai, iresultp);
			if(memcmp(&data_int,&iresult,16) != 0)
			{
				PrintError(0x17,error_list[0x17]);
				sprintf(buf,"Expected=%08lx%08lx%08lx%08lx\nReceived=%08lx%08lx%08lx%08lx",data_int.d,data_int.c,data_int.b,data_int.a,
				iresult.d,iresult.c,iresult.b,iresult.a);
				PrintError(ERR_UNEXPECTED_RESULT_S, error_list[ERR_UNEXPECTED_RESULT_S], buf);
				break;
			}
			struct_128 data_float1 = {(float)1.2, (float)5.6, (float)9.7, (float)0.4};	/* compiler says never used - used in ASM */
			struct_128 data_float2 = {(float)5.3, (float)2.1, (float)10.2, (float)7.0};	/* compiler says never used - used in ASM */
			struct_128 exp_fresult = {(float)2.5495097637176514, (float)2.100000, (float)4.460942, (float)2.7202942371368408};
			struct_128 fresult;
			void* dataf1 = &data_float1;			/* compiler says never used - used in ASM */
			void* dataf2 = &data_float2;			/* compiler says never used - used in ASM */
			struct_128* fresultp = &fresult;			/* compiler says never used - used in ASM*/
			xmm128FLT(dataf1, dataf2, fresultp);
			if(memcmp(&exp_fresult,&fresult,16) != 0)
			{
				PrintError(0x18,error_list[0x18]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",exp_fresult.aa,exp_fresult.bb,exp_fresult.cc,exp_fresult.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}
			xmm128CMP(dataf1, dataf2, fresultp);
			struct_128 check2 = {(float)-4.10000038146972660000, (float)-2.1, (float)-.5, (float)-6.6};
			if(memcmp(&check2,&fresult,16) != 0)
			{
				PrintError(0x19,error_list[0x19]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",check2.aa,check2.bb,check2.cc,check2.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}  
			xmm128SHF(fresultp);
			struct_128 check3 = {20,42,42,40};
			if(memcmp(&check3,&fresult,16) != 0)
			{
				PrintError(0x1A,error_list[0x1A]);
				sprintf(buf,"Expected=%08.20f%08.20f%08.20f%08.20f\nReceived=%08.20f%08.20f%08.20f%08.20f",check3.aa,check3.bb,check3.cc,check3.dd,
				fresult.aa,fresult.bb,fresult.cc,fresult.dd);
				PrintError(ERR_UNEXPECTED_RESULT_S,error_list[ERR_UNEXPECTED_RESULT_S],buf);
				break;
			}  


		} //x
		Sleep(100);
	} //y
}


/*****************************************************************************************\
* Title:	CPUSpeed
* Abstract:	Set process and thread priority to realtime.  Run test several times,
*			choose median because first 4-6 times run slower than the correct speed.
*			***If speed is reported incorrectly, increase the NUM_TIMES value to get past these
*			first incorrect values.***  Speed is rounded to nearest normal value if it's
*			within a small range.  If it doesn't fit into that range, the actual value
*			is returned.
*			NOTE:  This test is not guaranteed to work as expected on laptop systems, due
*			to the CPU speed/power management policies used by laptops.
\*****************************************************************************************/
int CPUSpeed() {
	double b, c, d, results[NUM_TIMES], sorted_results[NUM_TIMES];
	int i, j, k, cpu_speed=0, origThreadPriority;
	DWORD e, wait_result;
	HANDLE hMutex;
	LARGE_INTEGER speed_v, speed_w, speed_x, speed_y, speed_z;

	origThreadPriority=GetThreadPriority(GetCurrentThread());

	if(!SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS)) {
		PrintError(ERR_CHG_CLASS_PRIORITY,error_list[ERR_CHG_CLASS_PRIORITY]);
		return 0;
	}

	if(!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL)) {
		PrintError(ERR_CHG_THREAD_PRIORITY, error_list[ERR_CHG_THREAD_PRIORITY]);
		return 0;
	}
	Sleep(1);
    hMutex=CreateMutex(NULL, TRUE, "WINMTA_REALTIME_MUTEX");
	if (hMutex==NULL) {		// error creating mutex
		PrintError(ERR_CREATE_MUTEX_D, error_list[ERR_CREATE_MUTEX_D], GetLastError());
		return 0;
	}
	wait_result=WaitForSingleObject(hMutex, 60000);		// wait 1 min. for mutex to be released
	if (wait_result==WAIT_TIMEOUT || wait_result==WAIT_FAILED) {
		PrintError(ERR_ACCESS_MUTEX_D, error_list[ERR_ACCESS_MUTEX_D], wait_result);
		return 0;
	}
	QueryPerformanceFrequency(&speed_v);
	for(i=0; i < NUM_TIMES; ++i) {					// # of tests to make - pick median
		QueryPerformanceCounter(&speed_x);
		__asm rdtsc									// read TimeStampCounter
		__asm mov speed_y.HighPart, edx
	    __asm mov speed_y.LowPart, eax
	    Sleep(15);									// wait X milliseconds
	    QueryPerformanceCounter(&speed_w);
	    __asm rdtsc									// Read TimeStampCounter again
	    __asm mov speed_z.HighPart, edx
	    __asm mov speed_z.LowPart, eax
		results[i]=(double)(speed_w.QuadPart-speed_x.QuadPart)/speed_v.QuadPart;
		results[i]=(double)(speed_z.QuadPart-speed_y.QuadPart)/results[i];
	}
	// set priorities back to original
	if(!SetThreadPriority(GetCurrentThread(), origThreadPriority)) {
		PrintError(ERR_CHG_THREAD_PRIORITY, error_list[ERR_CHG_THREAD_PRIORITY]);
		return 0;
	}
	if(!SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS)) {
		PrintError(ERR_CREATE_MUTEX_D, error_list[ERR_CREATE_MUTEX_D]);
		return 0;
	}		
	  
	// Sort array - will pick median value
	for (i=0; i < NUM_TIMES; ++i) {		// find largest value	 
		for (j=0, b=0, k=0; j < NUM_TIMES; ++j) {
			if (results[j]>b) {
				b=results[j];
			    k=j;
			}
		}
	    // move into sorted_results[i]
	    sorted_results[i]=b;
	    results[k]=0;
	}

	// round speed value 
	c=sorted_results[NUM_TIMES/2];
	c=c/1000;
	e=(int)c/1000;
	d=e % 100;			// retrieve last two digits
	e=e/100;			// retrieve first digit
	if (d >= 0 && d <=2) 
		d=0;
	else if (d >= 22 && d <= 27)
		d=25;
	else if (d>=30 && d <= 35)
		d=33;
	else if (d >= 46 && d <= 52)
		d=50;
	else if (d >= 63 && d <= 69)
		d=66;
	else if (d >= 71 && d <= 77)
		d=75;
	else if (d >= 96 && d <= 100)
		d=100;
	// otherwise, just leave d the way it is
#pragma warning(disable:4244)  // compiler complained of double->int conversion.  It's OK here.
	cpu_speed=(int)(e*100)+d;
#pragma warning(default:4244)

	if(!ReleaseMutex(hMutex)) {		
		PrintError(ERR_RELEASE_MUTEX_D, error_list[ERR_RELEASE_MUTEX_D], GetLastError());
		return 0;
	}
	CloseHandle(hMutex);	

	return cpu_speed;
}


/*****************************************************************************************\
* Title:	CkCPUSpeed
* Abstract:	Retrieves CPU SPEED value (should have been input through autoconfig).
*			Runs CPUSpeed test again, and compares the values.  Outputs error if they
*			don't match, or if the original value wasn't input.	
\******************************************************************************************/
void CkCPUSpeed() {
	int orig_cpu_speed, new_cpu_speed;

	if(!wt_getint("CPU SPEED", &orig_cpu_speed)) {
		PrintError(ERR_NOORIGVALUE_S, error_list[ERR_NOORIGVALUE_S], "(CPU SPEED)");
		return;
	}

	// check current speed
	new_cpu_speed=CPUSpeed();

	// compare speeds
	if (orig_cpu_speed != new_cpu_speed) {
		PrintError(ERR_NOMATCH_ORIGANDNEW_DD, error_list[ERR_NOMATCH_ORIGANDNEW_DD], orig_cpu_speed, new_cpu_speed);
		return;
	}

	return;
}




/*******************************************************************************************\
* Title:	CPUDescription
* Abstract:	Pass in a string to contain the return value of the processor, length of
*			string, and Type, Model and Family parameters.  Function uses those
*			parameters to identify the name of the processor.  Returns FALSE if error
*			occurs, TRUE otherwise.
\*******************************************************************************************/
BOOL CPUDescription(char *desc, int desc_len, int Type, int Model, int Family) {
	char *NoMatch="New processor added, CPUDescription() test needs to be updated.";

	// make sure desc_len contains enough characters for the max option
	if (desc_len < 125) {
		PrintError(ERR_INSUFF_SPACE,error_list[ERR_INSUFF_SPACE]);
		return FALSE;
	}

	// desc can't be null
	if(desc==NULL) {
		PrintError(ERR_NULL_PTR, error_list[ERR_NULL_PTR]);
		return FALSE;
	}
	// Depending on the values, copy a string containing the name of the processor
	switch(Type) {
	case 0:
		switch(Family) {
		case 4:
			switch(Model) {
			case 0:
			case 1:
				if(!AppendData(desc, desc_len, "Intel 486 DX processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 2:
				if(!AppendData(desc, desc_len, "Intel 486 SX processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Intel 487 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Intel 486 SL processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 5:
				if(!AppendData(desc, desc_len, "Intel SX2 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 7:
				if(!AppendData(desc, desc_len, "Write-Back Enhanced Intel DX2 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 8:
				if(!AppendData(desc, desc_len, "Intel DX4 processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}	
			break;		// end switch(Model) inside Type 00, Family 0100
		case 5:
			switch(Model) {
			case 1:
			case 2:
				if(!AppendData(desc, desc_len, "Pentium processor")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Pentium processor with MMX technology.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			} 
			break;		// end switch(Model) inside Type 00, Family 0101
		case 6:
			switch(Model) {
			case 1:
				if(!AppendData(desc, desc_len, "Pentium Pro processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Pentium II processor, model 3.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 5:
				if(!AppendData(desc, desc_len, "Pentium II processor, model 5, Pentium II Xeon processor, model 5, or Intel Celeron processor, model 5.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 6:
				if(!AppendData(desc, desc_len, "Intel Celeron Processor, model 6.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 7:
				if(!AppendData(desc, desc_len, "Pentium III processor, model 7, or Pentium III Xeon processor, model 7.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 8:
				if(!AppendData(desc, desc_len, "Pentium III processor, model 8, Pentium III Xeon processor, model 8, or Intel Celeron processor, model 8.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}
			break;
		default:
			if(!AppendData(desc, desc_len, NoMatch)) {
				PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
				return FALSE;
			}
			break;
		}					// end switch(Family) inside Type 00
		break;				// end Type 00
		case 1:
		switch(Family) {
		case 5:
			switch(Model) {
			case 1:
			case 2:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processor for Pentium processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 3:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processors for Intel 486 processor-based systems.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			case 4:
				if(!AppendData(desc, desc_len, "Pentium OverDrive processor with MMX technology for Pentium processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;

			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			} 
			break;		// end case Family 0101, Type 01
		case 6:
			switch(Model) {
			case 3:
				if(!AppendData(desc, desc_len, "Intel Pentium II OverDrive processor.")) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			default:
				if(!AppendData(desc, desc_len, NoMatch)) {
					PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
					return FALSE;
				}
				break;
			}
			break;
		}
		break;			// end switch(Family) inside Type 01
		default:		// no type match found
			if(!AppendData(desc, desc_len, NoMatch)) {
				PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
				return FALSE;
			}
			break;
	}
 	return TRUE;
}


/******************************************************************************************\
* Title:	CacheDescription
* Abstract:	Copy cache description into string passed into function.  Returns TRUE if passed,
*			FALSE if failed.
\******************************************************************************************/
void cacheinfo(DWORD ptrCacheRegA, DWORD ptrCacheRegB, DWORD ptrCacheRegC, DWORD ptrCacheRegD)
{
	_asm {
		mov		eax, 2		; ask for the cache information
		cpuid
		mov		edi, ptrCacheRegA
		mov		[edi], eax
		mov		edi, ptrCacheRegB
		mov		[edi], ebx
		mov		edi, ptrCacheRegC
		mov		[edi], ecx
		mov		edi, ptrCacheRegD
		mov		[edi], edx
	}
	return;
}

BOOL CacheDescription(char *desc, int desc_len) {
	int stop=0, count=0;

	
	if (desc==NULL) {
		PrintError(ERR_NULL_PTR,error_list[ERR_NULL_PTR]);
		return FALSE;
	}

	while (!stop) {
		++count;				 
		// get the cache information
		__try{		// necessary in case processor doesn't support CPUID call
			cacheinfo((DWORD)&(CacheRegA.reg), (DWORD)&(CacheRegB.reg), (DWORD)&(CacheRegC.reg), (DWORD)&(CacheRegD.reg));
		}				
		__except(EXCEPTION_EXECUTE_HANDLER) {
			if(_exception_code()==STATUS_ILLEGAL_INSTRUCTION) {
				wt_error(0x01,error_list[0x01]);
				return FALSE;
			}
			// if we get here, an unexpected error has occurred - what?
			PrintError(ERR_CPUIDEXCEPTION, error_list[ERR_CPUIDEXCEPTION]);
			return FALSE;
		}
		// check EAX bits 0-7.  Indicate how many times CPUID needs to be called with 2 in EAX
		if((unsigned)count >= CacheRegA.byte0) {
			stop=1;
		}

		if(!(CacheRegA.byte3 & 0x80)) {		// register values valid only if bit 31==0
			// no need to find match on byte0 - used to tell # calls/CPUID necessary
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegA.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

		if(!(CacheRegB.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegB.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;	
			}
		}

		if (!(CacheRegC.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegC.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

		if (!(CacheRegD.byte3 & 0x80)) {		// register values valid only if bit 31==0
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte0)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte1)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte2)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
			if(!FindCacheMatch(desc, desc_len, CacheRegD.byte3)) {
				PrintError(ERR_CACHE_DESC, error_list[ERR_CACHE_DESC]);
				return FALSE;
			}
		}

	} // end of while(!stop) loop
	return TRUE;
}


/**************************************************************************************\
* Title:	AppendData
* Abstract:	Append second data string to first if there's room in the first.  If not,
*			return FALSE.  Otherwise, return TRUE.
\***************************************************************************************/
BOOL AppendData(char* data1, int data1_len, char* data2) {
	int len1, len2;

	if(data1==NULL || data2==NULL) {
		PrintError(ERR_NULL_PTR, error_list[ERR_NULL_PTR]);
		return FALSE;
	}

	len1=strlen(data1);
	len2=strlen(data2);
	if(len1+len2+1 < data1_len) {
		if(len1 != 0) {
			strcat(data1, "\n");
		}
		strcat(data1, data2);
	} else {
		return FALSE;
	}
	return TRUE;
}



/***************************************************************************************\
* Title:	FindCacheMatch
* Abstract:	Search for match to "masked_data" criteria.  Return FALSE if error occurs,
*			TRUE otherwise.
\***************************************************************************************/
BOOL FindCacheMatch(char *desc, int desc_len, __int16 masked_data)
{
	switch(masked_data) {
	case 0x00:		// these first cases are for minor caches, don't bother to list them
	case 0x01:
	case 0x02:
	case 0x03:
	case 0x06:
	case 0x08:
	case 0x0A:
	case 0x0C:
		break;
	case 0x40:
		if(!AppendData(desc, desc_len, "No L2 cache.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x41:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 128K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x42:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 256K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x43:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 512K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x44:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 1M.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x45:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 4-way set associative, 2M.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	case 0x82:
		if(!AppendData(desc, desc_len, "Unified cache, 32 byte cache line, 8 way set associative, 256K.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	default:
		if(!AppendData(desc, desc_len, "New cache description, CacheDescription() function needs to be updated.")) {
			PrintError(ERR_DESC_SPACE, error_list[ERR_DESC_SPACE]);
			return FALSE;
		}
		break;
	}
	return TRUE;
}


/***************************************************************************************\
* Title:	IsNTor2000
* Abstract:	Check version of current operating system.  Return TRUE is Windows NT or 
*			Windows 2000, returns FALSE if unable to retrieve error or if OS is NOT
*			Windows NT or 2000.
\***************************************************************************************/
BOOL IsNTor2000() {
	OSVERSIONINFO OS;

	// get version information
	OS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if(!GetVersionEx(&OS)) {
		return FALSE;					// unable to retrieve version info
	}
	if(OS.dwPlatformId!=VER_PLATFORM_WIN32_NT) {
		return FALSE;					// version info didn't meet requirements
	}
	return TRUE;
}


/***************************************************************************************\
* Title:	GetCPUID
* Abstract:	Try to call CPUID instruction, and store value in CPUType and CPUFeatures
*			structures.  If an exception occurs, and the exception is 
*			STATUS_ILLEGAL_INSTRUCTION, print an error message.  Otherwise, let the
*			exception filter up higher.
\***************************************************************************************/
void getcpuid(DWORD	ptrCPUTYPE, DWORD ptrCPUFEATURES)
{
	_asm {
		mov	eax, 1			; ask for the feature information
		cpuid
		mov	edi,ptrCPUTYPE
		mov	[edi], eax
		mov	edi,ptrCPUFEATURES
		mov	[edi], edx
	}
		return;
}

void GetCPUID() {
	__try{		// necessary in case processor doesn't support CPUID call
		getcpuid((DWORD)&(CPUType.reg), (DWORD)&(CPUFeatures.reg));
	  }
	__except(GetExceptionCode()==STATUS_ILLEGAL_INSTRUCTION) {
		wt_error(ERR_CPUIDNOTSUPPORTED,error_list[ERR_CPUIDNOTSUPPORTED]);
		return;
	}
}


/***************************************************************************************\
* Title:	TrySIMD
* Abstract:	Try a SIMD instruction to see if OS supports SIMD instructions.  Returns
*			TRUE if support exists, FALSE if support does not exist.
\***************************************************************************************/
BOOL TrySIMD() {
	  __try {
		  xmmtest();
	  }
	  __except(GetExceptionCode()==STATUS_ILLEGAL_INSTRUCTION) { // exception occurred
		  return FALSE;
	  }
	  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\cpu.h ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// cpu.h : main header file for the CPU application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

long THE_END;			// End of the used address space
int (__cdecl *lucas)();

/////////////////////////////////////////////////////////////////////////////
// CCpuApp:
// See cpu.cpp for the implementation of this class
//

class CCpuApp : public CWinApp
{
public:
	CCpuApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCpuApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCpuApp)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

void SelfSense();    
void SelfSenseCPU(char *path, char *name, int cpu = -1);    
void TestCleanup();    
void DisplayCPUFeatures();
void CPUFeatureCheck();               
void MMXCode();
void PrintError(unsigned int ecode, LPCTSTR format_string,...);
void FPUFeatures();
void MMXFeatures();
void SIMDFeatures();
extern "C" void xmmtest();
void FPUStress();
CString GetLastErrorText(DWORD dwLastError);
int CPUSpeed();
void CkCPUSpeed();
BOOL CPUDescription(char *desc, int desc_len, int Type, int Model, int Family);
BOOL CacheDescription(char *desc, int desc_len);
BOOL AppendData(char* data1, int data1_len, char* data2);
BOOL FindCacheMatch(char *desc, int desc_len, __int16 masked_data);
BOOL IsNTor2000();
void GetCPUID();
BOOL TrySIMD();
								   
union Type 
{
	DWORD reg;
	struct
	{
		DWORD Stepping:4;
		DWORD Model:4;
		DWORD Family:4;		// used to be 3, but spec says should be 4!
		DWORD ProcType:2;
	};
public:
};

union Cache
{
	DWORD reg;
	struct 
	{
		DWORD byte0:8;
		DWORD byte1:8;
		DWORD byte2:8;
		DWORD byte3:8;		// bit 7 of byte3 will be 0 if this register is valid
	};
	public:
};


union Features
{
	DWORD reg;
	struct
	{
		DWORD FPU:1;
		DWORD VME:1;
		DWORD DE:1;
		DWORD PSE:1;
		DWORD TSC:1;
		DWORD MSR:1;
		DWORD PAE:1;
		DWORD MCE:1;
		DWORD CXS:1;
		DWORD APIC:1;
		DWORD RES1:2;
		DWORD MTRR:1;
		DWORD PGE:1;
		DWORD MCA:1;
		DWORD CMOV:1;
		DWORD WHOKNOWS:7;
		DWORD MMX:1;
		DWORD FXSR:1;
		DWORD XMM:1;
		DWORD WNI:1;	//bit 26
	};
};

union struct_128 
{
	struct					// view data as 32 bit floating point numbers
	{
		float aa,bb,cc,dd;
	};
	struct
	{
		double low_float, high_float;
	};
	struct					// view data as 32 bit integers
	{
		DWORD a, b, c, d;
	};
	struct
	{
		DWORD low_int,high_int;	// view data as 64 bit integers
	};
public:
};
struct int_2x32{__int32 a, b;};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\fft.cpp ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.

#include "stdafx.h"
#include "Prime95.h"
#include "math.h"
#define TRUE 1
#define FALSE 0

#define INTERLEAVE		1

long addr (unsigned long p, unsigned long fftlen, unsigned long i)
{
	unsigned long addr, pass1, pass2, col, section, section_size;

	p=0;						// meaningless, just did to stop compiler from
								// complaining about unreferenced parameter.

	pass1 = i >> 9;				// Top bits
	col = (i >> 7) & 3;			// Middle 2 bits
 	pass2 = i & 127;			// Bottom 7 bits

// Compute the lower part of the address, inserting waste bytes.
// Waste is 1 cache line every 128 cache lines (32 bytes per 4K page).
// Addr is: pass1 || pass2 % 8 || optional-interleave-bit || col || 000

	addr = pass1;
	addr = (addr << 3) + (pass2 & 7);
	addr = (addr >> 7) * (128 + 1) + (addr & 127);  // Add waste
	addr *= INTERLEAVE;
	addr = ((addr << 2) + col) << 3;

// Compute the upper part of the address adding more waste bytes
// to avoid 64KB spacing.  Note there is no guarantee that the OS
// will place our 4K pages linearly in memory, but there are times
// that the OS does, so we'll optimize for that case.

	section = pass2 >> 3;
	section_size = (fftlen >> 4) * sizeof (double);
	section_size += 4096 + 8*32;	// BUG - Not ideal for all fftlen?
	section_size *= INTERLEAVE;
	addr += section * section_size;

// Return the full address

	return (DATA_ADDR + addr);
}

// Routine to handle a multiplication and modulo operation where
// the intermediate multiplication result can be more than 32 bits.

unsigned long mulmod (
	unsigned long a,
	unsigned long b,
	unsigned long c)
{
	unsigned long tmp;
	tmp = a * (b & 0x3FF);
	tmp += ((a << 10) % c) * (b >> 10);
	return (tmp % c);
}

// Some words in the FFT data contain floor(p/N), some words contain
// floor(p/N)+1 bits.  This function returns TRUE in the latter case.

int is_big_word (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i)
{
	unsigned long b, s;

// The first FFT word is always big.

	if (i == 0) return (TRUE);

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// The rest are uniformly distributed. Use floating point
// arithmetic to avoid losing data in the b * i operation.

	return (mulmod (b, i, fftlen) > s);
}

// Each FFT word is multiplied by a two-to-phi value.  These
// routines set and get the FFT value without the two-to-phi
// multiplier.

#pragma warning(disable:4725) // Disables Pentium FDIV warning.
void get_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	*retval)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*retval = (long)*dblp;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Divide by two-to-phi to generate an integer.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	tmp = *dblp;
	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld tmp
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fdivp st(1), st
	__asm frndint
	__asm fstp tmp
	*retval = (long) tmp;
}
#pragma warning(default:4725)

void set_fft_value (
	unsigned long p,
	unsigned long fftlen,
	unsigned long i,
	long	val)
{
	double	*dblp, tmp, pow;
	unsigned long b, s;

// Get address of fft value

	dblp = (double *) addr (p, fftlen, i);

// The first FFT word is not multiplied by anything.

	if (i == 0) {
		*dblp = val;
		return;
	}

// Compute the number of big FFT words.

	b = p % fftlen;

// Compute the number of small FFT words.

	s = fftlen - b;

// Multiply value by two-to-phi before setting fft value.
// Do not trust the pow routine.  The assembly code will
// generate the value with greater accuracy.

	pow = (double) mulmod (s, i, fftlen) / (double) fftlen;
	__asm fld pow
	__asm f2xm1
	__asm fld1
	__asm faddp st(1), st
	__asm fimul val
	__asm fstp tmp
	*dblp = tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\dmi16.h ===
/*
 * (c) Copyright 1999-2000 Intel Corp. All rights reserved.
 * Intel Confidential.
 */

#if !defined(_DMIFUNC_H_)
#define _DMIFUNC_H_

#if defined(__cplusplus)
extern "C" {
#endif

extern WORD _F000h;
extern WORD _0040h;

#define NO_MORE_HANDLES 0xFFFF

typedef enum tagMSGTYPE {
	MT_STATUS,
	MT_ADVISORY,
	MT_ERROR
} MSGTYPE;


/*
 @ TYPE DEFINITIONS and MACROS
 */

typedef int (__cdecl *LPPNPENTRY)(int,...);

#pragma pack(1)
#pragma warning(disable:4214 4201)

typedef	struct	tagPNPHEADER
{
	BYTE	baSignature[4];
	BYTE	bVersion;
	BYTE	bLength;
	WORD	wCtrlField;
	BYTE	bChecksum;
	DWORD	dwEventNotifyFlagAddr;
	WORD	wRealOffset;
	WORD	wRealBaseAddr;
	WORD	wProtOffset;
	DWORD	dwProtBaseAddr;
	DWORD	dwOEMDeviceID;
	WORD	wRealDataAddr;
	DWORD	dwProtDataAddr;
} PNPHEADER,*LPPNPHEADER;

typedef struct tagDMIHEADER
{
	BYTE	bType;
	BYTE	bLength;
	WORD	wHandle;
} DMIHEADER,*LPDMIHEADER;

typedef struct tagDMIDATABUFFER
{
	BYTE		bCommand;
	BYTE		bFieldOffset;
	DWORD		dwChangeMask;
	DWORD		dwChangeValue;
	WORD		wDataLength;
	DMIHEADER	stStructHeader;
	char		baUpdatedString[128];
} DMIDATABUFFER,*LPDMIDATABUFFER;

typedef struct tagMFGACCESS
{
	void far	*pWorkBuffer;
	void far	*pKey;
} MFGACCESS,*LPMFGACCESS;

typedef struct tagWRITEONCE
{
	BYTE		bType;
	WORD		wHandle;
	void far	*pWorkBuffer;
	BYTE		bElementOffset;
	char		baSecurity[9];
} WRITEONCE,*LPWRITEONCE;

typedef struct tagSWBRDACCESS
{
	BYTE		bCommand;
	BYTE		bRevision;
	DWORD		dwData;
	void far	*pWorkBuffer;
} SWBRDACCESS,*LPSWBRDACCESS;

#define SBA_READ  0x00
#define SBA_WRITE 0x01

typedef struct tagQWORD
{
	DWORD	Low;
	DWORD	High;
} QWORD,*LPQWORD;


/* BIOS Information (Type 0) */
typedef	struct tagDMITYPE0
{
	BYTE	bType;			/* 0 - BIOS Information Indicator */
	BYTE	bLength;		/* 12h + number of BIOS Characteristics Extension Bytes */
	WORD	wHandle;
	BYTE	bVendor;		/* String number of BIOS Vendor's Name */
	BYTE	bVersion;		/* String number of BIOS Version */
	WORD	wStartAddrSeg;	/* Segment location of BIOS starting address */
	BYTE	bReleaseDate;	/* String number of BIOS release date, in format mm/dd/yy */
	BYTE	bROMSize;		/* BIOS ROM Size - Size (n) is 64K * (n+1) */
	QWORD	qFunctions;		/* Defines which functions the BIOS supports - See 3.2.1.1 */
} DMITYPE0, *PDMITYPE0;

/* System Information (Type 1) */
typedef	struct tagDMITYPE1
{
	BYTE	bType;			/* 1 - Component ID Information Indicator */
	BYTE	bLength;		/* 08h */
	WORD	wHandle;
	BYTE	bManu;			/* Manufacturer - Number of null terminated string */
	BYTE	bProduct;		/* Product - Number of null terminated string */
	BYTE	bVersion;		/* Version - Number of null terminated string */
	BYTE	bSerialNum;		/* Serial Number - Number of null terminated string */
	BYTE    bUUID[16];		/* UUID */
	BYTE	bWakeupType;	/* Enumerated:
							   00h - Reserved
							   01h - Other
							   02h - Unknown
							   03h - APM Timer
							   04h - Modem Ring
							   05h - LAN Remote */
} DMITYPE1, *PDMITYPE1;

/* Base Board Information (Type 2) */
typedef	struct tagDMITYPE2
{
	BYTE	bType;			/* 2 - Base Board Information Indicator */
	BYTE	bLength;		/* 08h */
	WORD	wHandle;
	BYTE	bManu;			/* Manufacturer - Number of null terminated string */
	BYTE	bProduct;		/* Product - Number of null terminated string */
	BYTE	bVersion;		/* Version - Number of null terminated string */
	BYTE	bSerialNum;		/* Serial Number - Number of null terminated string */
} DMITYPE2, *PDMITYPE2;

/* System Enclosure or Chassis (Type 3) */
typedef	struct tagDMITYPE3
{
	BYTE	bType;			/* 3 - System Enclosure Indicator */
	BYTE	bLength;		/* 09h */
	WORD	wHandle;
	BYTE	bManu;			/* Manufacturer - Number of null terminated string */
	BYTE	bType1;			/* Bit 7 - Chassis Lock
								1 - Chassis Lock present
								0 - Either lock not present or unknown
							   Bits 6:0 - Chassis Types - See 3.2.4.1 */
	BYTE	bVersion;		/* Version - Number of null terminated string */
	BYTE	bSerialNum;		/* Serial Number - Number of null terminated string */
	BYTE	bTagNum;		/* Asset Tag Number - Number of null terminated string */
	BYTE	bBootupState;	/* bootup state - Enumerated Value */
	BYTE	bPowerSupplyState; /* power supply state - enumerated */
	BYTE	bThermalState;	/* thermal state - enumerated */
	BYTE	bSecurityStatus;/* security status - enumerated */
	DWORD	dwOEMinfo;		/* oem defined */
} DMITYPE3, *PDMITYPE3;

/* Processor Information (Type 4) */
typedef struct tagDMITYPE4
{
	BYTE	bType;			/* 4 - Processor Information Indicator */
	BYTE	bLength;		/* 1Ah */
	WORD	wHandle;
	BYTE	bSocketDesign;	/* String number for Reference Designation */
	BYTE	bProcType;		/* Processor Type - See 3.2.5.1 */
	BYTE	bProcFamily;	/* Processor Family - See 3.2.5.2 */
	BYTE	bProcManu;		/* String number of Processor Manufacturer */
	QWORD	qProcID;		/* Raw processor indentification data - See 3.2.5.3 */
	BYTE	bProcVersion;	/* String number describing the processor */
	BYTE	bVol;			/* Bits 7:4 - Reserved, must be zero
							   Bits 3:0 - Voltage capability
								Bit 0 - 5.0V
								Bit 1 - 3.3V
								Bit 2 - 2.9V
								Bit 3 - Reserved, must be 0
								Note: Setting of multiple bits indicates
								the socket is configurable */
	WORD	wExtClock;		/* External Clock Frequency */
	WORD	wMaxSpeed;		/* Maximum Speed, in MHz */
	WORD	wCurSpeed;		/* Same as Max Speed */
	BYTE	bStatus;		/* Bit 7 - Reserved, must be 0
							   Bit 6 - CPU Socket Populated
								1 - CPU Socket Populated
								0 - CPU Socket Unpopulated
							   Bits 5:3 - Reserved, must be 0
							   Bits 2:0 - CPU Status
								0h   - Unknown
								1h   - CPU Enabled
								2h   - CPU Disabled by user (via BIOS SETUP)
								3h   - CPU Disabled by System BIOS (POST Error)
								4h   - CPU is idle (waiting to be Enabled)
								5-6h - Reserved
								7h   - Other */
	BYTE	bProcUpgrade;	/* Processor Upgrade - See 3.2.5.4 */
} DMITYPE4,*PDMITYPE4;

/* Memory Controller Information (Type 5) */
typedef	struct tagDMITYPE5
{
	BYTE	bType;			/* 5 - Memory Controller Indicator */
	BYTE	bLength;		/* 15 + (2 * Number of Assoc. Mem. Slots), offset 0Eh */
	WORD	wHandle;
	BYTE	bErrDetectM;	/* Error Detecting Method - See 3.2.6.1 */
	BYTE	bErrCorrect;	/* Error Correcting Capability - See 3.2.6.2 */
	BYTE	bSupInter;		/* Supported Interleave - See 3.2.6.3 */
	BYTE	bCurInter;		/* Current Interleave - See 3.2.6.3 */
	BYTE	bMaxMemMod;		/* Size of largest memory module supported
							   (per slot), specified as n,
							   where 2**n is maximum size in MB */
	WORD	wSupSpeed;		/* Supported Speeds - See 3.2.6.4 */
	WORD	wSupMemType;	/* Supported Memory Types - See 3.2.7.1 */
	BYTE	bMemModVol;		/* Bits 7:3 - Reserved, must be 0
							   Bit 2 - 2.9V
							   Bit 1 - 3.3V
							   Bit 0 - 5V */
	BYTE	bNumMemSlots;	/* Number of Memory Module Information blocks
							   controlled by this controller */
} DMITYPE5,*PDMITYPE5;

/* Memory Module Information (Type 6) */
typedef	struct tagDMITYPE6
{
	BYTE	bType;			/* 6 - Memory Module Configuration Indicator */
	BYTE	bLength;		/* 0Ch */
	WORD	wHandle;
	BYTE	bSocketDesign;	/* String Number for Reference Designation */
	BYTE	bBankConnect;	/* Each nibble indicates a bank connection */
	BYTE	bCurSpeed;		/* Speed of the memory module, in ns */
	WORD	wCurMemType;	/* Current Memory Type - See 3.2.7.1 */
	BYTE	bInstallSize;	/* Installed Size - See 3.2.7.2 */
	BYTE	bEnSize;		/* Enabled Size -  See 3.2.7.2 */
	BYTE	bErrStatus;		/* Bits 7:2 - Reserved, set to 0's
							   Bit 1 - Correctable errors, if set
							   Bit 0 - Uncorrectable errors, if set */
} DMITYPE6, *PDMITYPE6;

/* Cache Information (Type 7) */
typedef	struct tagDMITYPE7
{
	BYTE	bType;			/* 7 - Cache Information Indicator */
	BYTE	bLength;		/* 0Fh */
	WORD	wHandle;
	BYTE	bSocketDesign;	/* String Number for Reference Designation */
	union
	{
		WORD	wCacheConfig;
		struct
		{
			WORD Level:		3;	/* Bits 2:0 - Cache Level - 1 through 8 */
			WORD Socketed:	1;	/* Bit 3 - Cache Socketed
									1b - Socketed
									0b - Not Socketed */
			WORD Reserved1:	1;	/* Bit 4 - Reserved, must be 0 */
			WORD Location:	2;	/* Bits 6:5 - Location, relative to the CPU module
									00b - Internal
									01b - External
									10b - Reserved
									11b - Unknown */
			WORD Enabled:	1;	/* Bit 7 - Enabled/Disabled (at boot time)
									1b - Enabled
									0b - Disabled */
			WORD Mode:		2;	/* Bits 9:8 - Operational Mode
									00b - Write Through
									01b - Write Back
									10b - Varies with Memory Address
									11b - Unknown */
			WORD Reserved2:	6;	/* Bits 15:10 - Reserved, must be 0 */
		} CacheConfig;
	};
	union
	{
		WORD	wMaxCacheSize;	/* Max size that can be installed */
		struct
		{
			WORD Size:15;		/* Bits 14:0 - Size in given granularity */
			WORD Granularity:1;	/* Bit 15 - Granularity
									0 - 1K granularity
									1 - 64K granularity */
		} MaxCacheSize;
	};
	union
	{
		WORD	wInstallSize;	/* Same as Max Cache Size field */
		struct
		{
			WORD Size:15;		/* Bits 14:0 - Size in given granularity */
			WORD Granularity:1;	/* Bit 15 - Granularity
									0 - 1K granularity
									1 - 64K granularity */
		} InstallSize;
	};
	union
	{
		WORD	wSupportedSRAMType;	/* See 3.2.8.1 */
		struct
		{
			WORD Other:1;
			WORD Unknown:1;
			WORD NonBurst:1;
			WORD Burst:1;
			WORD PipelineBurst:1;
			WORD Synchronous:1;
			WORD Asynchronous:1;
			WORD Reserved:9;
		} SupportedSRAMType;
	};
	union
	{
		WORD	wCurrentSRAMType;	/* See 3.2.8.1 */
		struct
		{
			WORD Other:1;
			WORD Unknown:1;
			WORD NonBurst:1;
			WORD Burst:1;
			WORD PipelineBurst:1;
			WORD Synchronous:1;
			WORD Asynchronous:1;
			WORD Reserved:9;
		} CurrentSRAMType;
	};
} DMITYPE7, *PDMITYPE7;

/* Port Connector Information (Type 8) */
typedef	struct tagDMITYPE8
{
	BYTE	bType;				/* 8 - Connector Information Indicator */
	BYTE	bLength;			/* 09h */
	WORD	wHandle;
	BYTE	bInRefDesign;		/* String number for Internal Reference Designator */
	BYTE	bInConnectType;		/* Internal Connector type - See 3.2.9.2 */
	BYTE	bExtRefDesign;		/* String number for External Reference Designator */
	BYTE	bExtConnectType;	/* External Connector type - See 3.2.9.2 */
	BYTE	bPortType;			/* Describes the function of the port - See 3.2.9.3 */
} DMITYPE8, *PDMITYPE8;

/* System Slots (Type 9) */
typedef	struct tagDMITYPE9
{
	BYTE	bType;			/* 9 - System Slot Structure Indicator */
	BYTE	bLength;		/* 0Ch */
	WORD	wHandle;
	BYTE	bSlotDesign;	/* String number for Reference Designation */
	BYTE	bSlotType;		/* Slot type - See 3.2.10.1 */
	BYTE	bSlotDBWidth;	/* Slot Data Bus Width - See 3.2.10.2 */
	BYTE	bCurUsage;		/* Current Usage - See 3.2.10.3 */
	BYTE	bSlotLength;	/* Slot Length - See 3.2.10.4 */
	WORD	wSlotID;		/* Slot ID - See 3.2.10.5 */
	BYTE	bSlotChar;		/* Slot Characteristics - See 3.2.10.6 */
} DMITYPE9,*PDMITYPE9;

/* On Board Devices Information (Type 10) */
typedef struct tagDEVICE
{
	BYTE    bDevType;		/* Bit 7 - Device Status
								1 - Device Enabled
								0 - Device Disabled
							   Bit 6:0 - Type of Device - See 3.2.11.1 */
	BYTE    bDescription;	/* String number of description */
} DEVICE;

typedef struct tagDMITYPE10
{
	BYTE    bType;			/* 10 - On Board Devices Information Indicator */
	BYTE    bLength;		/* 4 + (Number of Devices * 2) */
	WORD    wHandle;
	DEVICE  stDev;			/* See tagDEVICE above */
} DMITYPE10, *PDMITYPE10;

/* OEM Strings (Type 11) */
typedef struct tagDMITYPE11
{
	BYTE	bType;			/* 11 - OEM Strings Indicator */
	BYTE	bLength;		/* 05h */
	WORD	wHandle;
	BYTE	bCount;			/* Number of strings */
} DMITYPE11, *PDMITYPE11;

/* System Configuration Options (Type 12) */
typedef struct tagDMITYPE12
{
	BYTE	bType;			/* 12 - Configuration Information Indicator */
	BYTE	bLength;		/* 05h */
	WORD	wHandle;
	BYTE	bCount;         /* Number of strings */
} DMITYPE12, *PDMITYPE12;

/* BIOS Language Information (Type 13) */
typedef struct tagDMITYPE13
{
	BYTE	bType;			/* 13 - Language Information Indicator */
	BYTE	bLength;		/* 16h */
	WORD	wHandle;
	BYTE	bLanguages;     /* Installable Languages - Number of languages available */
	BYTE	baReserved[16]; /* Reserved for future use */
	BYTE	bCurLanguage;	/* Current Language - String number of current language */
} DMITYPE13, *PDMITYPE13;

/* Group Associations (Type 14) */
typedef struct tagITEM
{
	BYTE	bItemType;		/* Item (Structure) Type of this member */
	WORD	wItemHandle;
} ITEM;

typedef struct tagDMITYPE14
{
	BYTE	bType;			/* 14 - Group Associations Indicator */
	BYTE	bLength;		/* 5 + (3 bytes for each item in the group) */
	WORD	wHandle;
	BYTE	bGroupName;		/* String number of string describing the group */
	ITEM	stItem;			/* See tagITEM above */
} DMITYPE14,*PDMITYPE14;

/* System Event Log (Type 15) */
typedef struct tagDMITYPE15
{
	BYTE	bType;					/* 15 - Event Log Type Indicator */
	BYTE	bLength;				/* 14h */
	WORD	wHandle;
	WORD	wLogAreaLength;			/* Length of the overall event log area */
	WORD	wLogHeaderStartOffset;	/* Starting offset from Access Method Address */
	WORD	wLogDataStartOffset;	/* Starting offset from Access Method Address */
	BYTE	bAccessMethod;			/* Defines the Location and Method used by
									   higher-level software to access the log area
										00h - Indexed I/O: 1 8-bit index port, 1 8-bit data port
										01h - Indexed I/O: 2 8-bit index ports, 1 8-bit data port
										02h - Indexed I/O: 1 16-bit index port, 1 8-bit data port
										03h - Memory-mapped physical 32-bit address
										04h - Available via GPNV data functions
										05h-FFh - Available for future assignment */
	union
	{
		BYTE	bLogStatus;				/* Current status of system event log */
		struct
		{
			BYTE LogAreaValid:1;		/*  Bit 0 - Log area valid, if 1      */
			BYTE LogAreaFull:1;			/*  Bit 1 - Log area full, if 1       */
			BYTE Reserved:6;			/*  Bit 7:2 - Reserved, set to 0's    */
		} LogStatus;
	};
	DWORD	dwLogChangeToken;		/* Unique token that is reassigned every time
									   the event log changes */
	DWORD   dwAccessMethodAddress;	/* Address associated with the access method */
	BYTE	bLogHeaderFormat;		/* Log header format 
											00h		No header (header is 0 bytes in length
											01h		Type 1 header (16 bytes - see 3.3.16.5.1)
											02h-7Fh	Available for future assignment
											80h-FFh	BIOS Vendor or OEM-specific header */
	BYTE	bNumLogTypeDescriptors;	/* number of support log type descriptors */
	BYTE	bLengthEachDescriptor;	/* length of each log type descriptor */
	BYTE	bDescriptorList;		/* Variable list of Event Log Descriptors
										(this variable just a marker for pointer assignment) */

} DMITYPE15, *PDMITYPE15;


typedef struct tagEVENTLOGHEADER
{
	BYTE	baOptionROMHeader[5];
	BYTE	bGTGN;
	BYTE	bGCGN;
	BYTE	baPreBootClearEventLog[2];
	BYTE	baCMOSChecksumRegion[3];
	BYTE	baReserved[3];
	BYTE	bRevision;
} EVENTLOGHEADER;

typedef struct tagEVENTLOGREC
{
	BYTE	bEventType;
	BYTE	bLength;
	BYTE	bcdYear;
	BYTE	bcdMonth;
	BYTE	bcdDay;
	BYTE	bcdHour;
	BYTE	bcdMinute;
	BYTE	bcdSecond;
	DWORD	dwLogVariableData[2];
} EVENTLOGREC;

typedef struct tagBLOCKERASEDATA
{
	BYTE		bBlockEraseCommand;
	BYTE		baSecurityKey[8];
	void far	*pDmiWorkBuffer;
} BLOCKERASEDATA;

typedef struct tagMUXDATA
{
	BYTE		bCommand;
	BYTE		bType;
	DWORD		dwData;
	void far	*lpDmiWorkBuffer;
	BYTE		baSecurityKey[8];
} MUXDATA;

#define MUX_READ  0x00
#define MUX_WRITE 0x01
#define MUX_CHANGE_CPU_SPEED 0x00

#pragma warning(default:4214 4201)
#pragma pack()


#define SUPPORTED_DMI_REVISION			0x20
#define SUPPORTED_SMBIOS_VERSION		0x21

/* SM BIOS STRUCTURE TYPES */
#define SMB_BIOSINFO					 0
#define SMB_SYSTEMINFO					 1
#define SMB_BASEBOARDINFO				 2
#define SMB_CHASSISINFO					 3
#define SMB_PROCESSORINFO				 4
#define SMB_MEMORYCONTROLLERINFO		 5
#define SMB_MEMORYMODULEINFO			 6
#define SMB_CACHEINFO					 7
#define SMB_PORTCONNECTORINFO			 8
#define SMB_SYSTEMSLOTINFO				 9
#define SMB_ONBOARDDEVICEINFO			10
#define SMB_OEMSTRINGINFO				11
#define SMB_SYSTEMCONFIGOPTIONS			12
#define SMB_BIOSLANGUAGEINFO			13
#define SMB_GROUPASSOCIATIONS			14
#define SMB_EVENTLOGINFO				15

/* DMI BIOS Functions */
#define GET_DMI_INFORMATION				0x50
#define GET_DMI_STRUCTURE				0x51
#define SET_DMI_STRUCTURE				0x52
#define GET_DMI_STRUCTURE_CHANGE_INFO	0x53
#define DMI_CONTROL						0x54
#define GET_GPNV_INFORMATION			0x55
#define READ_GPNV_DATA					0x56
#define WRITE_GPNV_DATA					0x57

/* DMI BIOS Error Return Codes */
#define DMI_SUCCESS						0x00
#define DMI_UNKNOWN_FUNCTION			0x81
#define DMI_FUNCTION_NOT_SUPPORTED		0x82
#define DMI_INVALID_HANDLE				0x83
#define DMI_BAD_PARAMETER				0x84
#define DMI_INVALID_SUBFUNCTION			0x85
#define DMI_NO_CHANGE					0x86
#define DMI_ADD_STRUCTURE_FAILED		0x87
#define DMI_READ_ONLY					0x8D
#define DMI_LOCK_NOT_SUPPORTED			0x90
#define DMI_CURRENTLY_LOCKED			0x91
#define DMI_INVALID_LOCK				0x92
#define DMI_NO_ENTRY					0xFF

/* SET_DMI_STRUCTURE - dmiDataBuffer - Command */
#define DMI_CMD_SET_BYTE				0x00
#define DMI_CMD_SET_WORD				0x01
#define DMI_CMD_SET_DWORD				0x02
#define DMI_CMD_ADD_STRUCT				0x03
#define DMI_CMD_DEL_STRUCT				0x04
#define DMI_CMD_SET_STRING				0x05

/* DMI_CONTROL - SubFunction - DMI BIOS SubFunctions */
#define DMI_CLEAR_EVENT_LOG				0x0000	/* AMI Uses 0x4002 - see below */
#define DMI_CONTROL_LOGGING				0x0001

/* DMI_CONTROL - SubFunction - BIOS Vendor SubFunctions */
#define DMI_iSTRUCTURE_ELEMENT_ERASE	0x4000
#define DMI_STRUCTURE_ELEMENT_ERASE		DMI_iSTRUCTURE_ELEMENT_ERASE
#define DMI_iMANUFACTURING_ACCESS		0x4001
#define DMI_MANUFACTURING_ACCESS		DMI_iMANUFACTURING_ACCESS
#define DMI_iCLEAR_EVENT_LOG			0x4002	/* pData points to buffer of size wMinGPNVRWSize */
#define DMI_iHECETA_CONFIG				0x4003
#define DMI_HECETA_CONFIG				DMI_iHECETA_CONFIG
#define DMI_iSWITCHBOARD_ACCESS			0x4004
#define DMI_SWITCHBOARD_ACCESS			DMI_iSWITCHBOARD_ACCESS
#define DMI_iSTRUCTURE_BLOCK_ERASE		0x4005
#define DMI_STRUCTURE_BLOCK_ERASE		DMI_iSTRUCTURE_BLOCK_ERASE
#define DMI_iJUMPERLESS_MB_MUX			0x4006
#define DMI_JUMPERLESS_MB_MUX			DMI_iJUMPERLESS_MB_MUX

/* DMI_CONTROL - Control */
#define VERIFY_PARAMETERS				0x00
#define PERFORM_OPERATION				0x01

/* READ/WRITE_GPNV_DATA - Handle */
#define GPNV_DMI_HANDLE					0
#define GPNV_MFG_HANDLE					1
#define GPNV_CMS_HANDLE					2

#define IGNORE_GPNV_LOCK				-1

/* System Event Log - Access Methods */
#define EVENT_LOG_ACCESS_PHYS32			0x03
#define EVENT_LOG_ACCESS_GPNV			0x04


/* System Event Log - Events */
#define EVENT_ALL_EVENTS				0x00
#define EVENT_SINGLEBIT_ECC				0x01
#define EVENT_MULTIBIT_ECC				0x02
#define EVENT_POST_ERROR				0x08
#define EVENT_LOGGING_DISABLED			0x0E
#define EVENT_SYSTEM_LIMIT				0x10
#define EVENT_SYSTEM_BOOT				0x17
/* System Event Log - OEM Events */
#define EVENT_OEM_BASE					0x80
#define EVENT_VIRUS_SCAN				0x80
/* System Event Log - End of Records */
#define EVENT_END_OF_RECORDS			0xFF

/* System Event Log - Virus Scan */
#define VIRUS_DETECTION_MASK			0x00000001l
#define VIRUS_DETECTION_NOT_DETECTED	0x00000000l
#define VIRUS_DETECTION_DETECTED		0x00000001l

#define VIRUS_CLEAN_MASK				0x00000006l
#define VIRUS_CLEAN_BOOTED_INFECTED		0x00000000l
#define VIRUS_CLEAN_CLEANED				0x00000002l
#define VIRUS_CLEAN_FAILED				0x00000004l
#define VIRUS_CLEAN_RESET_SYSTEM		0x00000006l

#define VIRUS_DEVICE_MASK				0x00000038l
#define VIRUS_DEVICE_NONE				0x00000000l
#define VIRUS_DEVICE_FDD				0x00000008l
#define VIRUS_DEVICE_HDD				0x00000010l
#define VIRUS_DEVICE_OTHER				0x00000038l


typedef enum tagSECURITY
{
	SEC_NONE,
	SEC_MFG,
	SEC_OEM,
	SEC_ADMIN
} SECURITY;

typedef enum tagBLOCKERASECOMMAND
{
	BLOCK_ERASE_SYSTEM	= 0x00,
	BLOCK_ERASE_CHASSIS	= 0x01,
	BLOCK_ERASE_OEM		= 0x02,
	BLOCK_ERASE_BOARD	= 0x80,
	BLOCK_ERASE_ALL		= 0x81
} BLOCKERASECOMMAND;


/*
 @ FUNCTION PROTOTYPES
 */

WORD GetPnpEntry(LPPNPENTRY* pPnpFunction,WORD *pPnpBiosSeg);

/* Function 50h - GET_DMI_INFORMATION */
BOOL PASCAL GetDmiInfo(BYTE *pDmiBIOSRevision,WORD *pNumStructures,
                       WORD *pStructureSize,DWORD *pDmiStorageBase,
                       int *pErrorCode);

/* Function 51h - GET_DMI_STRUCTURE */
BOOL PASCAL GetDmiStruct(WORD *pStructure, void *pDmiStrucBuffer,
                         DWORD DmiStorageBase,int *pErrorCode);

/* Function 52h - SET_DMI_STRUCTURE */
BOOL PASCAL SetDmiStruct(DMIDATABUFFER *pDmiDataBuffer,void *pDmiWorkBuffer,
				         BYTE Control,DWORD DmiStorageBase,int *pErrorCode);

/* Function 53h - GET_DMI_STRUCTURE_CHANGE_INFO */

/* Function 54h - DMI_CONTROL */
BOOL PASCAL DmiControl(short SubFunction,void *pData,BYTE Control,
                       DWORD DmiStorageBase,int *pErrorCode);

/* Function 55h - GET_GPNV_INFORMATION */
BOOL PASCAL GetGpnvInfo(WORD *pHandle, WORD *pMinGPNVRWSize, WORD *pGPNVSize,
                        DWORD *pGPNVStorageBase, int *pErrorCode);

/* Function 56h - READ_GPNV_DATA */
BOOL PASCAL ReadGpnvData(WORD Handle,BYTE *pGPNVBuffer,short *pGPNVLock,
                         DWORD dwGPNVStorageBase,int *pErrorCode);

/* Function 57h - WRITE_GPNV_DATA */
/* BOOL WriteGpnvData(WORD Handle, BYTE *pGPNVBuffer, short *pGPNVLock,
				   WORD wGPNVStorageSeg, int *pErrorCode);
 */

BOOL PASCAL SwitchBoard(BYTE bCommand, DWORD dwDmiStorageSeg, DWORD *pdwData,
                        BYTE *pbRevision, int *pErrorCode);

BOOL JumperlessMbMux(BYTE bCommand, BYTE bType, DWORD* pdwData,
					 WORD wDmiStorageSeg, int* pErrorCode);

BOOL GetGpnvStruct(WORD Handle, void *pDmiStrucBuffer, short *lock,
				   WORD DmiStorageSeg, int *pErrorCode);

BOOL PASCAL ClearEventLog16(int *pErrorCode);

BOOL PASCAL DMI_ThunkConnect16(LPSTR pszDll16,LPSTR pszDll32,WORD hInst,DWORD dwReason);

/*
 @ SECURITY ROUTINES
 */
void MfgAccess(DWORD dmibase, char * mfg_access_key);

/* Type 1,2,3 erase functions */
BOOL PASCAL StructureElementErase(SECURITY sec,BYTE type,WORD handle,BYTE element_offset,DWORD dmibase,
									char * mfg_access_key, char * mfg_security_key);
BOOL PASCAL StructureBlockErase(BLOCKERASECOMMAND command,SECURITY sec,DWORD dmibase,int *pErrorCode,
									char * mfg_access_key, char * mfg_security_key);

#if defined(__cplusplus)
}
#endif

#endif /* _DMIFUNC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\prime95.h ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// Prime95.h : main header file for the PRIME95 application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

//#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// My non-MFC stuff went here
/////////////////////////////////////////////////////////////////////////////

// Constants

#define MIN_PRIME	5L		// Smallest testable prime
#define MAX_PRIME	LIMIT256	// Largest testable prime
#define MAX_FACTOR	LIMIT256	// Largest factorable number

// Limits based on 1000 iterations with an error no greater than 0.30.

#define LIMIT256	5260000L	// Crossover points
#define LIMIT224	4605000L
#define LIMIT192	3960000L
#define LIMIT160	3310000L
#define LIMIT128	2655000L
#define LIMIT112	2330000L
#define LIMIT96		2000000L
#define LIMIT80		1675000L
#define LIMIT64		1345000L

#define FAC61	LIMIT224		// How far to factor
#define FAC60	3540000L
#define FAC59	2750000L
#define FAC58	LIMIT112
#define FAC57	1750000L
#define FAC56	LIMIT64
#define FAC55	1050000L
#define FAC54	750000L

#define DATA_ADDR	0x20010000	// Addr of the input doubles
#define THE_END_64	0x200D0780	// Max addr for 64K FFT len
#define THE_END_80	0x200FBF00	// Max addr for 80K FFT len
#define THE_END_96	0x20127700	// Max addr for 96K FFT len
#define THE_END_112	0x201531C0	// Max addr for 112K FFT len
#define THE_END_128	0x2017E9C0	// Max addr for 128K FFT len
#define THE_END_160	0x201D61A0	// Max addr for 160K FFT len
#define THE_END_192	0x2022D520	// Max addr for 192K FFT len
#define THE_END_224	0x202848E0	// Max addr for 224K FFT len
#define THE_END_256	0x202DBBC0	// Max addr for 256K FFT len
extern long THE_END;			// End of the used address space

#define REL_486_SPEED	7.0	// 486 is 7 times slower than Pentium
#define REL_PRO_SPEED	0.87	// Pro is little faster than Pentium

#ifndef SEC1
#define SEC1(p)		0
#define SEC2(p,hi,lo)	0
#define SEC3(p)		0
#define SEC4(p)		0
#endif

// Global variables

extern char *INI_SECTION;		// Section name in INI file
extern int THREAD_ACTIVE;		// True if a thread is active
extern int volatile THREAD_STOP;	// TRUE if thread should stop
extern int AUTO_CONTINUE;		// 1 if auto continue is on
extern int ADVANCED_ENABLED;		// 1 if advanced menu is enabled
extern int TRAY_ICON;			// Display tiny tray icon
extern int HIDE_ICON;			// Display no icon
//extern "C" int volatile ERRCHK;		// 1 to turn on error checking
extern int JUST_FIND_FACTORS;		// Factor the range
extern int DOUBLE_CHECK;		// Double-check the range
extern "C" unsigned int volatile CPU_TYPE;// 3=Cyrix, 4=486, 5=Pentium, 6=Pro
extern unsigned long volatile CPU_SPEED;// For 90MHz = 90
extern unsigned long RANGE_START;	// Start of range to test
extern unsigned long RANGE_END;		// End of range to test
extern unsigned long NEXT_RANGE_START;	// Start of range to test next
extern unsigned long NEXT_RANGE_END;	// End of range to test next
extern unsigned int volatile ITER_OUTPUT;// Iterations between outputs
extern int TXT_EXTENSION;		// True if output file is results.txt

extern int PRIORITY;			// Desired priority level
extern int TIMED_RUN;			// TRUE if this is a timed run
extern CTime END_TIME;			// End time for a timed run
extern int SILENT_VICTORY;		// Quiet find of new Mersenne prime

extern HMODULE HLIB;			// Handle of networking DLL
extern int (__stdcall *HPROC_GET_NEXT_EXPONENT)(unsigned long *, int *);
extern int (__stdcall *HPROC_WRITE_RESULTS)(char *);

const int NumLines = 32;
extern char *lines[NumLines];
extern int charHeight;

// Internal routines

UINT threadDispatch (LPVOID);
void findSmallestP (unsigned long *);
int readFileHeader (char *, int *, short *, unsigned long *);
int readFileData (int, unsigned long, unsigned long);
int writeToFile (unsigned long, char *, unsigned long, unsigned long);
void clearPrime (unsigned long, int);
void makestr64 (char *);
void writeResults (char *);
void primeClear (unsigned long, unsigned long);
void generateRandomData (unsigned long, unsigned long);
void checkResultsFile (unsigned long, int *, int *);

extern "C" void setupf ();
extern "C" int factor64 ();
extern "C" void setup64 ();
extern "C" int lucas64 ();
extern "C" void setup80 ();
extern "C" int lucas80 ();
extern "C" void setup96 ();
extern "C" int lucas96 ();
extern "C" void setup112 ();
extern "C" int lucas112 ();
extern "C" void setup128 ();
extern "C" int lucas128 ();
extern "C" void setup160 ();
extern "C" int lucas160 ();
extern "C" void setup192 ();
extern "C" int lucas192 ();
extern "C" void setup224 ();
extern "C" int lucas224 ();
extern "C" void setup256 ();
extern "C" int lucas256 ();

long  addr (unsigned long, unsigned long, unsigned long);
int is_big_word (unsigned long, unsigned long, unsigned long);
void get_fft_value (unsigned long, unsigned long, unsigned long, long *);
void set_fft_value (unsigned long, unsigned long, unsigned long, long);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\stdafx.h ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\lucas64.asm ===
TITLE   setup

	.386

_TEXT32 SEGMENT PARA USE32 PUBLIC 'DATA'

IFDEF WIN31
_MAXERR		DQ	0.0		; Maximum error
_SUMINP		DQ	0.0		; Sum of inputs
_SUMOUT		DQ	0.0		; Sum of outputs
_ERRCHK		DD	0		; Is error checking enabled?
_PARG		DD	0		; Prime exponent being tested

ELSE
EXTRN	_MAXERR:QWORD
EXTRN	_SUMINP:QWORD
EXTRN	_SUMOUT:QWORD
EXTRN	_ERRCHK:DWORD
EXTRN	_PARG:DWORD
ENDIF

;
; Global variables needed in squaring
;

        align   8
HALF		DD	0.5		; One-half
MINUS2		DD	-2.0		; Used to subtract 2.
BIGVAL		DD	0.0		; Used to round to an integer
scaled_numbig	DD	0		; numbig * (2^32 / n)
scaled_numlit	DD	0		; numlit * (2^32 / n)
		; These values only used during setup
p		DD	0		; Mersenne prime being tested
numlit		DD	0		; number of small words in the fft
numbig		DD	0		; number of big words in the fft
_TEXT32	ENDS


	ASSUME  CS: _TEXT32, DS: _TEXT32, SS: _TEXT32, ES: _TEXT32

n	EQU	65536		; size of the FFT

INCLUDE common.mac

;
; FFT.CPP should fully describe the memory layout.
; In pass1:
;	The distance between each data element is 8 bytes.
;	The distance between every fourth element is 256 bytes.
;	The distance between every 64th element is 4K bytes + gap.
; In pass2:
;	The distance between each data element is 32 bytes.
;	The distance between every eighth element is 32K bytes + gaps.
;	The distance between every 128th element is 4K bytes + gap.
;

	assign_addrs 0, 3072, 1536, 0, 179520

pass1_distances MACRO
	dist1 = 8
	dist4 =	256			*INTERLEAVE
	dist64 = (4096+32)		*INTERLEAVE
	dist512 = 32			*INTERLEAVE
	dist4096 = (32768+4096+8*32)	*INTERLEAVE
	ENDM
pass2_distances MACRO
	dist1 = 32			*INTERLEAVE
	dist8 = (32768+4096+8*32)	*INTERLEAVE
	dist128 = 8
	dist512 = 256			*INTERLEAVE
	dist8192 = (4096+32)		*INTERLEAVE
	ENDM

_TEXT32	SEGMENT 

; Setup routine

	PUBLIC	_setup64
	IFDEF WIN31
	ORG	0400h
_setup64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_PARG, ecx
	ELSE
_setup64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Initialize

	finit				; Init FPU

; Save p

	mov	eax, _PARG		; p
	mov	p, eax

; Compute two-to-phi and two-to-minus-phi multipliers

	normalize_setup

; Compute the array of sine and cosine/sine values

	sine_cosine_1_setup
	sine_cosine_2_setup
	pre_multiplier_setup pre_mults2, n, 128

; Return

	IFDEF WIN31
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret
_setup64 ENDP

;
; Compute next number in lucas sequence.  i.e.
; square the input number mod 2**p-1, subtract 2
;

	PUBLIC	_lucas64
	IFDEF WIN31
	ORG	1000h
_lucas64 PROC FAR
	push	es			; USE32 routines must preserve es,bp
	push	ebp
	push	ds			; copy ds to es
	pop	es
	mov	_ERRCHK, ecx		; ERRCHK is passed in ecx
	ELSE
_lucas64 PROC NEAR
	push	ebp
	push	ebx
	push	edi
	push	esi
	ENDIF

; Init the FPU every iteration just to be safe

	finit

; Start the fft process, do pass1 fft
; 128 sections of 512 values
; Perform nine levels of the FFT on 512 real values.

	pass1_distances
	mov	esi, input		; U - Starting address
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b0a:	nine_levels_fft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b0a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b0a			; V - Iterate if necessary

; Do the first section of pass 2

	pass2_distances
	seven_levels_real_fft_sq_unfft

; Do the other 255 sections of pass 2 

	mov	esi, input+2*dist128	; U - Restore source pointer
	mov	ebp, pre_mults2		; V - Addr of group pre-multipliers
	mov	edx, 8*256+16+80000000h	; U - 8 iters of 16 iters of 1 or 2
b1b:	seven_levels_fft_sq_unfft
	xor	edx, 80000000h		; U - Test inner loop counter
	JS_X	b1b			; V - Iterate if necessary
	lea	esi, [esi-4*dist128+dist512]; U - Next source pointer
	dec	dl			; V - Test outer loop counter
	JNZ_X	b1b			;*V - Iterate if necessary
	lea	esi, [esi-16*dist512+dist8192]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 16			; U - Reload inner loop counter
	JNZ_X	b1b			; V - Iterate if necessary

; Finish the inverse fft process, do pass1 inverse fft

	pass1_distances
	mov	esi, input		; U - Source pointer
	mov	edx, 16*256+8		; V - 16 iterations of 8 iterations
b2a:	nine_levels_unfft
	dec	dl			; V - Test inner loop counter
	JNZ_X	b2a			;*V - Iterate if necessary
	lea	esi, [esi-8*dist512+dist4096]; U - Next source pointer
	sub	edx, 256		; V - Test outer loop counter
	mov	dl, 8			; U - Reload inner loop counter
	JNZ_X	b2a			; V - Iterate if necessary

; Error check - find largest round off error

	cmp	_ERRCHK, 0
	JZ_X	noechk

; Code to check for how close we are to incurring a round-off error

	pass2_distances
	fldz				; Maximum error
	mov	edx, norm_grp_mults	; Address of the group multipliers
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; Used to compute big vs little words
	mov	ebp, scaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
elp4:	mov	save_counter, ebx
	mov	ecx, 4*256		; 4 iterations of
elp3:	mov	cl, 16			; 128 / 8 iterations
	mov	ebx, norm_col_mults	; Restart the column multipliers
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
elp2:	error_check			; Error check eight values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	elp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	elp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	mov	ebx, save_counter
	dec	bl
	JNZ_X	elp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	elp4			; Loop til done
	fstp	_MAXERR			; Store maximum error

; Normalize the results

noechk:	pass2_distances
	fldz				; Init SUMOUT
	fld	MINUS2			; Start normalization process
	fadd	BIGVAL			; with a BIGVAL-2.0 carry!
	mov	edx, norm_grp_mults	; Address of the group multipliers
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; Used to compute big vs little words
	mov	ebp, scaled_numbig
	mov	eax, -1			; First word is a big word (-1)
	mov	ebx, 8*256+16		; 8 iterations of 16 iterations of
nlp4:	mov	save_counter, ebx
	mov	ecx, 4*256		; 4 iterations of
nlp3:	mov	cl, 16			; 128 / 8 iterations
	mov	ebx, norm_col_mults	; Restart the column multipliers
	fld	QWORD PTR [edx]		; Two-to-phi
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi group multiplier
	fld	QWORD PTR [edx]		; Two-to-phi group multiplier
	fld	QWORD PTR [edx+norm_gap]; Two-to-minus-phi
nlp2:	normalize			; Normalize 8 values
	lea	esi, [esi+dist8]	; Next source
	lea	ebx, [ebx+4*norm_gap]	; Next set of 8 column multipliers
	dec	cl
	JNZ_X	nlp2			; Loop til done
	lea	esi, [esi-16*dist8+dist128]; Next source
	lea	edx, [edx+8]		; Next group multiplier
	fcompp				; Pop group multipliers
	fcompp				; Pop group multipliers
	sub	ecx, 256
	JNZ_X	nlp3			; Loop til done
	lea	esi, [esi-4*dist128+dist512]; Next source
	lea	edx, [edx-4*8+big_norm_gap]; Next group multiplier
	mov	ebx, save_counter
	dec	bl
	JNZ_X	nlp4			; Loop til done
	lea	esi, [esi-16*dist512+dist8192]; Next source
	sub	ebx, 256
	mov	bl, 16
	JNZ_X	nlp4			; Loop til done

					; Add any carry to first values
	mov	esi, input		; Address of squared number
	mov	edi, scaled_numlit	; To compute big vs little words
	mov	ebx, norm_col_mults	; Restart the column multipliers
	normalize_012

; Normalize SUMOUT value by multiplying by 1 / (n/2).
; This is the value of the first two-to-minus-phi group multiplier

	fmul	QWORD PTR ds:(norm_grp_mults+norm_gap)
	fstp	_SUMOUT

; Return

exit:	IFDEF WIN31
	fld	_SUMINP			;; Return values in floating
	fld	_SUMOUT			;; point registers
	fld	_MAXERR
	pop	ebp
	pop	es
	ELSE
	pop	esi
	pop	edi
	pop	ebx
	pop	ebp
	ENDIF
	ret

_lucas64 ENDP

_TEXT32	ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\stdafx.cpp ===
// (c) Copyright 1999-2000 Intel Corp. All rights reserved.
// Intel Confidential.
//
// stdafx.cpp : source file that includes just the standard includes
//	cpu.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cpu.rc
//
#define IDD_CPU_DIALOG                  102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\xmm.asm ===
.686
		.xmm
		.model flat,c

		.data

		.code
xmmtest		PROC C PUBLIC 
		xorps xmm0, xmm0
		ret
xmmtest		ENDP

xmm128INT	PROC C PUBLIC USES EAX EDI, datai:DWORD, iresultp:DWORD
		mov	eax,datai
		movups	xmm0,[eax]
		movaps	xmm1, xmm0
		movaps	xmm2, xmm1
		movaps	xmm3, xmm2
		movaps	xmm4, xmm3
		movaps	xmm5, xmm4
		movaps	xmm6, xmm5
		movaps	xmm7, xmm6
		shufps	xmm7, xmm7, 1bh	;shuffle a3,a2,a1,a0 to a0,a1,a2,a3
		shufps	xmm7, xmm7, 1bh	;shuffle a3,a2,a1,a0 to a0,a1,a2,a3
		mov	edi,iresultp
		movups	[edi],xmm7
		ret
xmm128INT	ENDP

xmm128FLT	PROC C PUBLIC USES EAX EDI, dataf1:DWORD, dataf2:DWORD, fresultp:DWORD
		mov	eax, dataf1		;load 2 registers with 128 bit floats
		movups	xmm0, [eax]
		mov	eax, dataf2
		movups	xmm1, [eax]		
		addps	xmm0, xmm1		;add xmm0 + xmm1 store in xmm0
		sqrtps	xmm2, xmm0		;sqrt xmm0 store in xmm2
		minps	xmm1, xmm2		;take the min of xmm1 and xmm2, store in xmm1
		mov	edi,  fresultp		;point to result structure
		movups	[edi],xmm1		;xfr result to structure
		ret
xmm128FLT	ENDP


xmm128CMP	PROC C PUBLIC USES EAX EDI, dataf1:DWORD, dataf2:DWORD, fresultp:DWORD
		mov	eax, dataf1
		movups	xmm0, [eax]
		mov	eax, dataf2
		movups	xmm1, [eax]
		maxps	xmm1, xmm0	;find max and store in xmm1
		movups	xmm2, [eax]
		cmpeqps	xmm1, xmm2	;which value changed?  should be second value
		andps	xmm0, xmm1	;lose the second value in xmm0
		subps	xmm0, xmm2	;
		mov	edi,  fresultp	;point to result structure
		movups	[edi],xmm0	;xfr result to structure				
		ret
xmm128CMP	ENDP

xmm128SHF	PROC C PUBLIC USES EAX EDI, fresultp:DWORD
		mov		eax, 5
		cvtsi2ss	xmm0, eax		;load 5 into lsd
		shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 2 of 4
		mov		eax, 6
		cvtsi2ss	xmm0, eax		;load 6 into lsd
		shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 3 of 4
		mov		eax, 7
		cvtsi2ss	xmm0, eax		;load 7	
		shufps		xmm0, xmm0, 93h		;rotate by 32 bits 5 in 4 of 4
		mov		eax, 8
		cvtsi2ss	xmm0, eax		;load 8   xmm0 = 5678
		movaps		xmm1, xmm0
		shufps		xmm1, xmm1, 1bh		;rotate	  xmm1 = 8765
		mulps		xmm1, xmm0		;ans  40,42,42,40
		mov		eax, 2
		cvtsi2ss	xmm0, eax		;load 2
		divss		xmm1, xmm0		;divide by 2 scalar

		mov		edi,  fresultp		;point to result structure
		movups		[edi],xmm1		;xfr result to structure
		ret
xmm128SHF	ENDP

		END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\memsize\precomp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compile header file

Author:

    Sakphong Chanbai (schanbai) 17-Aug-2000

Environment:

    Xbox

Revision History:

--*/


#include <xtl.h>
#include "xlog.h"
#include "xtestlib.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mempat\mempat.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    mempat.cpp

Abstract:

    Memory pattern test based on MATS. Designed to catch coupling faults by stepping up and down
	memory while alternating reads and writes.

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define PAGE_SIZE 0x00001000

//
// Prototypes and Typedefs from mm.h ke.h
//

extern "C" {
	ULONG_PTR
	WINAPI
	MmGetPhysicalAddress (
		IN PVOID BaseAddress
		);
}


struct MyInt128 {
	unsigned __int64 LowPart;
	unsigned __int64 HighPart;
};


// Globals
BOOL	gbFailed = FALSE;


//
// Function:	WUp128(...)
// Purpose:		Step up through memory writing a 128 bit value
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Starting address of memory to test
//				EndAddr		Ending address of memory to test, adjusted for data width
//				W_Value		Value to write
// Notes:		
//
BOOL
WUp128(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr,
	  unsigned __int64 W_Value1, unsigned __int64 W_Value2) {

	volatile MyInt128 *loc;
	MyInt128 W_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "WUp128:   Write Value: %#.16I64x%.16I64x", W_Value1, W_Value2);

	W_Value.LowPart = W_Value2;
	W_Value.HighPart = W_Value1;

	
	for(loc = (MyInt128 *)StartAddr; loc <= (MyInt128 *)EndAddr; loc++) {
				memcpy((void *)loc, &W_Value, sizeof(W_Value));
		}
	return TRUE;
}

//
// Function:	RWUp128(...)
// Purpose:		Step up through memory reading an expected value and writing a 128 bit value
//
BOOL
RWUp128(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value1, unsigned __int64 Exp_Value2, 
		unsigned __int64 W_Value1, unsigned __int64 W_Value2) {

	volatile MyInt128 *loc;
	MyInt128 Exp_Value, R_Value, W_Value;

	Exp_Value.LowPart = Exp_Value2;
	Exp_Value.HighPart = Exp_Value1;
	W_Value.LowPart = W_Value2;
	W_Value.HighPart = W_Value1;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWUp128:   Expected Value: %#.16I64x%.16I64x, Write Value: %#.16I64x%.16I64x", 
		Exp_Value.HighPart, Exp_Value.LowPart, W_Value.HighPart, W_Value.LowPart);

	for(loc = (MyInt128 *)StartAddr; loc <= (MyInt128 *)EndAddr; loc++) {
		// Read expected value
		memcpy(&R_Value,  (void *)loc, sizeof(R_Value));
		if(memcmp(&Exp_Value, &R_Value, sizeof(R_Value)) != 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWUp128:   FAILED at %p (physical = %p), Read: %#.16I64x%.16I64x, Expected: %#.16I64x%.16I64x",
						loc, MmGetPhysicalAddress((void *)loc), 
						R_Value.HighPart, R_Value.LowPart, Exp_Value.HighPart, Exp_Value.LowPart);
			return FALSE;
		}

		// Write new value	
		memcpy((void *)loc, &W_Value, sizeof(W_Value));
	}
	return TRUE;
}	

//
// Function:	RWDown128(...)
// Purpose:		Step down through memory reading an expected value and writing a 128 bit value
//
BOOL
RWDown128(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value1, unsigned __int64 Exp_Value2, 
		unsigned __int64 W_Value1, unsigned __int64 W_Value2) {

	volatile MyInt128 *loc;
	MyInt128 Exp_Value, R_Value, W_Value;

	Exp_Value.LowPart = Exp_Value2;
	Exp_Value.HighPart = Exp_Value1;
	W_Value.LowPart = W_Value2;
	W_Value.HighPart = W_Value1;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWDown128: Expected Value: %#.16I64x%.16I64x, Write Value: %#.16I64x%.16I64x", 
		Exp_Value.HighPart, Exp_Value.LowPart, W_Value.HighPart, W_Value.LowPart);

	for(loc = (MyInt128 *)EndAddr; loc >= (MyInt128 *)StartAddr; loc--) {
		// Read expected value
		memcpy(&R_Value, (void *)loc, sizeof(R_Value));
		if(memcmp(&Exp_Value, &R_Value, sizeof(R_Value)) != 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWDown128: FAILED at %p (physical = %p), Read: %#.16I64x%.16I64x, Expected: %#.16I64x%.16I64x",
						loc, MmGetPhysicalAddress((void *)loc), 
						R_Value.HighPart, R_Value.LowPart, Exp_Value.HighPart, Exp_Value.LowPart);
			return FALSE;
		}

		// Write new value	
		memcpy((void *)loc, &W_Value, sizeof(W_Value));
	}
	return TRUE;
}	
	
//
// Function:	RDown128(...)
// Purpose:		Step down through memory reading an expected value
//
BOOL
RDown128(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value1, unsigned __int64 Exp_Value2) {

	volatile MyInt128 *loc;
	MyInt128 Exp_Value, R_Value;

	Exp_Value.LowPart = Exp_Value2;
	Exp_Value.HighPart = Exp_Value1;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RDown128:  Expected Value: %#.16I64x%.16I64x", Exp_Value.HighPart, Exp_Value.LowPart);

	for(loc = (MyInt128 *)EndAddr; loc >= (MyInt128 *)StartAddr; loc--) {
		// Read expected value
		memcpy(&R_Value, (void *)loc, sizeof(R_Value));
		if(memcmp(&Exp_Value, &R_Value, sizeof(R_Value)) != 0) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RDown128:  FAILED at %p (physical = %p), Read: %#.16I64x%.16I64x, Expected: %#.16I64x%.16I64x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value.HighPart, R_Value.LowPart, 
						Exp_Value.HighPart, Exp_Value.LowPart);
			return FALSE;
		}
	}
	return TRUE;
}	

//
// Function:	WUp64(...)
// Purpose:		Step up through memory writing a 64 bit value
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Starting address of memory to test
//				EndAddr		Ending address of memory to test, adjusted for data width
//				W_Value		Value to write
// Notes:		
//
BOOL
WUp64(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr,
	  unsigned __int64 W_Value) {

	volatile unsigned __int64 *loc;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "WUp64:    Write Value: %#.16I64x", W_Value);
	
	for(loc = (unsigned __int64 *)StartAddr; loc <= (unsigned __int64 *)EndAddr; loc++) {
				*loc = W_Value;
		}
	return TRUE;
}

//
// Function:	RWUp64(...)
// Purpose:		Step up through memory reading an expected value and writing a 64 bit value
//
BOOL
RWUp64(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value, unsigned __int64 W_Value) {

	volatile unsigned __int64 *loc;
	unsigned __int64 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWUp64:   Expected Value: %#.16I64x, Write Value: %#.16I64x", Exp_Value, W_Value);

	for(loc = (unsigned __int64 *)StartAddr; loc <= (unsigned __int64 *)EndAddr; loc++) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWUp64:   FAILED at %p (physical = %p), Read: %#.16I64x, Expected: %#.16I64x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	

//
// Function:	RWDown64(...)
// Purpose:		Step down through memory reading an expected value and writing a 64 bit value
//
BOOL
RWDown64(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value, unsigned __int64 W_Value) {

	volatile unsigned __int64 *loc;
	unsigned __int64 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWDown64: Expected Value: %#.16I64x, Write Value: %#.16I64x", Exp_Value, W_Value);

	for(loc = (unsigned __int64 *)EndAddr; loc >= (unsigned __int64 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWDown64: FAILED at %p (physical = %p), Read: %#.16I64x, Expected: %#.16I64x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	
	
//
// Function:	RDown64(...)
// Purpose:		Step down through memory reading an expected value
//
BOOL
RDown64(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int64 Exp_Value) {

	volatile unsigned __int64 *loc;
	unsigned __int64 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RDown64:  Expected Value: %#.16I64x", Exp_Value);

	for(loc = (unsigned __int64 *)EndAddr; loc >= (unsigned __int64 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RDown64:  FAILED at %p (physical = %p), Read: %#.16I64x, Expected: %#.16I64x",
				loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}
	}
	return TRUE;
}	

//
// Function:	WUp32(...)
// Purpose:		Step up through memory writing a 32 bit value
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Starting address of memory to test
//				EndAddr		Ending address of memory to test, adjusted for data width
//				W_Value		Value to write
// Notes:		
//
BOOL
WUp32(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr,
	  unsigned __int32 W_Value) {

	volatile unsigned __int32 *loc;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "WUp32:    Write Value: %#.8x", W_Value);
	
	for(loc = (unsigned __int32 *)StartAddr; loc <= (unsigned __int32 *)EndAddr; loc++) {
				*loc = W_Value;
		}
	return TRUE;
}

//
// Function:	RWUp32(...)
// Purpose:		Step up through memory reading an expected value and writing a 32 bit value
//
BOOL
RWUp32(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int32 Exp_Value, unsigned __int32 W_Value) {

	volatile unsigned __int32 *loc;
	unsigned __int32 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWUp32:   Expected Value: %#.8x, Write Value: %#.8x", Exp_Value, W_Value);

	for(loc = (unsigned __int32 *)StartAddr; loc <= (unsigned __int32 *)EndAddr; loc++) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWUp32:   FAILED at %p (physical = %p), Read: %#.8x, Expected: %#.8x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	

//
// Function:	RWDown32(...)
// Purpose:		Step down through memory reading an expected value and writing a 32 bit value
//
BOOL
RWDown32(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int32 Exp_Value, unsigned __int32 W_Value) {

	volatile unsigned __int32 *loc;
	unsigned __int32 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWDown32: Expected Value: %#.8x, Write Value: %#.8x", Exp_Value, W_Value);

	for(loc = (unsigned __int32 *)EndAddr; loc >= (unsigned __int32 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWDown32: FAILED at %p (physical = %p), Read: %#.8x, Expected: %#.8x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	
	
//
// Function:	RDown32(...)
// Purpose:		Step down through memory reading an expected value
//
BOOL
RDown32(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int32 Exp_Value) {

	volatile unsigned __int32 *loc;
	unsigned __int32 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RDown32:  Expected Value: %#.8x", Exp_Value);

	for(loc = (unsigned __int32 *)EndAddr; loc >= (unsigned __int32 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RDown32:  FAILED at %p (physical = %p), Read: %#.8x, Expected: %#.8x",
				loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}
	}
	return TRUE;
}	


//
// Function:	WUp16(...)
// Purpose:		Step up through memory writing a 16 bit value
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Starting address of memory to test
//				EndAddr		Ending address of memory to test, adjusted for data width
//				W_Value		Value to write
// Notes:		
//
BOOL
WUp16(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr,
	  unsigned __int16 W_Value) {

	volatile unsigned __int16 *loc;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "WUp16:    Write Value: %#.4x", W_Value);
	
	for(loc = (unsigned __int16 *)StartAddr; loc <= (unsigned __int16 *)EndAddr; loc++) {
				*loc = W_Value;
		}
	return TRUE;
}

//
// Function:	RWUp16(...)
// Purpose:		Step up through memory reading an expected value and writing a 16 bit value
//
BOOL
RWUp16(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int16 Exp_Value, unsigned __int16 W_Value) {

	volatile unsigned __int16 *loc;
	unsigned __int16 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWUp16:   Expected Value: %#.4x, Write Value: %#.4x", Exp_Value, W_Value);

	for(loc = (unsigned __int16 *)StartAddr; loc <= (unsigned __int16 *)EndAddr; loc++) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWUp16:   FAILED at %p (physical = %p), Read: %#.4x, Expected: %#.4x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	

//
// Function:	RWDown16(...)
// Purpose:		Step down through memory reading an expected value and writing a 16 bit value
//
BOOL
RWDown16(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int16 Exp_Value, unsigned __int16 W_Value) {

	volatile unsigned __int16 *loc;
	unsigned __int16 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWDown16: Expected Value: %#.4x, Write Value: %#.4x", Exp_Value, W_Value);

	for(loc = (unsigned __int16 *)EndAddr; loc >= (unsigned __int16 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWDown16: FAILED at %p (physical = %p), Read: %#.4x, Expected: %#.4x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	
	
//
// Function:	RDown16(...)
// Purpose:		Step down through memory reading an expected value
//
BOOL
RDown16(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int16 Exp_Value) {

	volatile unsigned __int16 *loc;
	unsigned __int16 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RDown16:  Expected Value: %#.4x", Exp_Value);

	for(loc = (unsigned __int16 *)EndAddr; loc >= (unsigned __int16 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RDown16:  FAILED at %p (physical = %p), Read: %#.4x, Expected: %#.4x",
				loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}
	}
	return TRUE;
}	

//
// Function:	WUp8(...)
// Purpose:		Step up through memory writing a 8 bit value
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Starting address of memory to test
//				EndAddr		Ending address of memory to test, adjusted for data width
//				W_Value		Value to write
// Notes:		
//
BOOL
WUp8(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr,
	  unsigned __int8 W_Value) {

	volatile unsigned __int8 *loc;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "WUp8:     Write Value: %#.2x", W_Value);
	
	for(loc = (unsigned __int8 *)StartAddr; loc <= (unsigned __int8 *)EndAddr; loc++) {
				*loc = W_Value;
		}
	return TRUE;
}

//
// Function:	RWUp8(...)
// Purpose:		Step up through memory reading an expected value and writing a 8 bit value
//
BOOL
RWUp8(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int8 Exp_Value, unsigned __int8 W_Value) {

	volatile unsigned __int8 *loc;
	unsigned __int8 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWUp8:     Expected Value: %#.2x, Write Value: %#.2x", Exp_Value, W_Value);

	for(loc = (unsigned __int8 *)StartAddr; loc <= (unsigned __int8 *)EndAddr; loc++) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWUp8:     FAILED at %p (physical = %p), Read: %#.2x, Expected: %#.2x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	

//
// Function:	RWDown8(...)
// Purpose:		Step down through memory reading an expected value and writing a 8 bit value
//
BOOL
RWDown8(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int8 Exp_Value, unsigned __int8 W_Value) {

	volatile unsigned __int8 *loc;
	unsigned __int8 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RWDown8:  Expected Value: %#.2x, Write Value: %#.2x", Exp_Value, W_Value);

	for(loc = (unsigned __int8 *)EndAddr; loc >= (unsigned __int8 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RWDown8:  FAILED at %p (physical = %p), Read: %#.2x, Expected: %#.2x",
						loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}

		// Write new value	
		*loc = W_Value;
	}
	return TRUE;
}	
	
//
// Function:	RDown8(...)
// Purpose:		Step down through memory reading an expected value
//
BOOL
RDown8(HANDLE LogHandle, unsigned __int8 *StartAddr, unsigned __int8 *EndAddr, 
		unsigned __int8 Exp_Value) {

	volatile unsigned __int8 *loc;
	unsigned __int8 R_Value;

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"RDown8:   Expected Value: %#.2x", Exp_Value);

	for(loc = (unsigned __int8 *)EndAddr; loc >= (unsigned __int8 *)StartAddr; loc--) {
		// Read expected value
		R_Value = *loc;
		if(Exp_Value != R_Value) {
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
				"RDown8:   FAILED at %p (physical = %p), Read: %#.2x, Expected: %#.2x",
				loc, MmGetPhysicalAddress((void *)loc), R_Value, Exp_Value);
			return FALSE;
		}
	}
	return TRUE;
}	


VOID
WINAPI
MemPatStartTest(HANDLE LogHandle) {
    unsigned __int8 *StartAddr, *EndAddr;
	SIZE_T TestableMemSize, PercentAvail;
	ULONG PhysicalAddress, Alignment;
	MEMORYSTATUS ms;
	BOOL Width128, Width64, Width32, Width16, Width8, UseWriteCombine, bDone, bPass;
	DWORD Protect;
	int TestIterations, i;

	// Initialize
	i = 0;
	bDone = FALSE;

	// Get test configuration from ini file
	Width128 = GetProfileInt(TEXT("mempat"), TEXT("Width128"), 1);
	Width64 = GetProfileInt(TEXT("mempat"), TEXT("Width64"), 1);
	Width32 = GetProfileInt(TEXT("mempat"), TEXT("Width32"), 1);
	Width16 = GetProfileInt(TEXT("mempat"), TEXT("Width16"), 1);
	Width8 = GetProfileInt(TEXT("mempat"), TEXT("Width8"), 1);
	TestIterations = GetProfileInt(TEXT("mempat"), TEXT("TestIterations"), 1);
	PercentAvail = GetProfileInt(TEXT("mempat"), TEXT("PercentAvail"), 80);
	UseWriteCombine = GetProfileInt(TEXT("mempat"), TEXT("UseWriteCombine"), 0);

    xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "MemTest");
    xSetFunctionName(LogHandle, "MemTest");
	xStartVariation( gbConsoleOut, LogHandle, "Initialization" );

	// Query global memory status
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus( &ms );
	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"MEMPAT: GlobalMemoryStatus returned %u bytes of %u bytes available", 
		ms.dwAvailPhys, ms.dwTotalPhys);

	// Allocate specified % of available memory
	TestableMemSize = (SIZE_T)((double)ms.dwAvailPhys*(double)PercentAvail/100.0);

	// Round to neareast int128
	TestableMemSize -= TestableMemSize%(sizeof(MyInt128));

	// Start at any physical address
	PhysicalAddress = MAXULONG_PTR;

	// Default alignment (PAGE)
	Alignment = 0;

	// Memory Protection
	if(UseWriteCombine) {
		Protect = PAGE_READWRITE | PAGE_WRITECOMBINE;
	} else {
		Protect = PAGE_READWRITE | PAGE_NOCACHE;
	}
	
	// Reduce TestableMemSize a page at a time until memory can be allocated
    for (;;) {
		StartAddr = (unsigned __int8 *)XPhysicalAlloc(TestableMemSize, PhysicalAddress, Alignment, Protect);
  
        if ( StartAddr ) {
            break;
        }
        if ( TestableMemSize <= PAGE_SIZE ) {
            break;
        }
        TestableMemSize -= PAGE_SIZE;
    }

    if ( !StartAddr ) {
        xLog(gbConsoleOut, LogHandle, XLL_BLOCK, "MEMPAT: unable to allocate memory (size=%lu, error=%s)",
            TestableMemSize, WinErrorSymbolicName(GetLastError()));
        return;
    }

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemPat: %lu bytes allocated as %s", 
		TestableMemSize, UseWriteCombine ? "PAGE_WRITECOMBINE" : "PAGE_NOCACHE");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemPat: Starting Address %p (physical %p)",
		StartAddr, MmGetPhysicalAddress(StartAddr));
	xEndVariation(LogHandle);

	do {
		// Increment iteration counter
		i++;

		// 128 bit data
		if (Width128) {
			bPass = TRUE;
			EndAddr = StartAddr + TestableMemSize - sizeof(MyInt128);
			xStartVariation(gbConsoleOut, LogHandle, "128 Bit Data");
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "128 Bit Data: Iteration %d: StartAddr = %p, EndAddr = %p", i, StartAddr, EndAddr);

			bPass &= WUp128	 (LogHandle, StartAddr, EndAddr, 0x0000000000000000, 0x0000000000000000);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0xffffffffffffffff, 0xffffffffffffffff, 0x5555555555555555, 0x5555555555555555);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x5555555555555555, 0x5555555555555555, 0xaaaaaaaaaaaaaaaa, 0xaaaaaaaaaaaaaaaa);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0xaaaaaaaaaaaaaaaa, 0xaaaaaaaaaaaaaaaa, 0x5555555555555555, 0x5555555555555555);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x5555555555555555, 0x5555555555555555, 0x3333333333333333, 0x3333333333333333);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0x3333333333333333, 0x3333333333333333, 0xcccccccccccccccc, 0xcccccccccccccccc);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0xcccccccccccccccc, 0xcccccccccccccccc, 0x3333333333333333, 0x3333333333333333);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0x3333333333333333, 0x3333333333333333, 0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f, 0xf0f0f0f0f0f0f0f0, 0xf0f0f0f0f0f0f0f0);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0xf0f0f0f0f0f0f0f0, 0xf0f0f0f0f0f0f0f0, 0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f0f0f0f0f, 0x0f0f0f0f0f0f0f0f, 0x00ff00ff00ff00ff, 0x00ff00ff00ff00ff);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0x00ff00ff00ff00ff, 0x00ff00ff00ff00ff, 0xff00ff00ff00ff00, 0xff00ff00ff00ff00);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0xff00ff00ff00ff00, 0xff00ff00ff00ff00, 0x00ff00ff00ff00ff, 0x00ff00ff00ff00ff);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0x00ff00ff00ff00ff, 0x00ff00ff00ff00ff, 0x0000ffff0000ffff, 0x0000ffff0000ffff);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x0000ffff0000ffff, 0x0000ffff0000ffff, 0xffff0000ffff0000, 0xffff0000ffff0000);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0xffff0000ffff0000, 0xffff0000ffff0000, 0x0000ffff0000ffff, 0x0000ffff0000ffff);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0x0000ffff0000ffff, 0x0000ffff0000ffff, 0x00000000ffffffff, 0x00000000ffffffff);
			bPass &= RWUp128	 (LogHandle, StartAddr, EndAddr, 0x00000000ffffffff, 0x00000000ffffffff, 0xffffffff00000000, 0xffffffff00000000);
			bPass &= RWDown128(LogHandle, StartAddr, EndAddr, 0xffffffff00000000, 0xffffffff00000000, 0x0000000000000000, 0xffffffffffffffff);
			bPass &= RWUp128  (LogHandle, StartAddr, EndAddr, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000000);
			bPass &= RDown128 (LogHandle, StartAddr, EndAddr, 0xffffffffffffffff, 0x0000000000000000);

			// Pass Fail
			if(bPass) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "128 Bit Data: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "128 Bit Data: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// 64 bit data
		if (Width64) {
			bPass = TRUE;
			EndAddr = StartAddr + TestableMemSize - sizeof(unsigned __int64);
			xStartVariation(gbConsoleOut, LogHandle, "64 Bit Data");
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "64 Bit Data: Iteration %d: StartAddr = %p, EndAddr = %p", i, StartAddr, EndAddr);
			bPass &= WUp64	(LogHandle, StartAddr, EndAddr, 0x0000000000000000);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x0000000000000000, 0xffffffffffffffff);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0xffffffffffffffff, 0x5555555555555555);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x5555555555555555, 0xaaaaaaaaaaaaaaaa);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0xaaaaaaaaaaaaaaaa, 0x5555555555555555);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x5555555555555555, 0x3333333333333333);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0x3333333333333333, 0xcccccccccccccccc);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0xcccccccccccccccc, 0x3333333333333333);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0x3333333333333333, 0x0f0f0f0f0f0f0f0f);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f0f0f0f0f, 0xf0f0f0f0f0f0f0f0);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0xf0f0f0f0f0f0f0f0, 0x0f0f0f0f0f0f0f0f);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f0f0f0f0f, 0x00ff00ff00ff00ff);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0x00ff00ff00ff00ff, 0xff00ff00ff00ff00);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0xff00ff00ff00ff00, 0x00ff00ff00ff00ff);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0x00ff00ff00ff00ff, 0x0000ffff0000ffff);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x0000ffff0000ffff, 0xffff0000ffff0000);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0xffff0000ffff0000, 0x0000ffff0000ffff);
			bPass &= RWDown64(LogHandle, StartAddr, EndAddr, 0x0000ffff0000ffff, 0x00000000ffffffff);
			bPass &= RWUp64	(LogHandle, StartAddr, EndAddr, 0x00000000ffffffff, 0xffffffff00000000);
			bPass &= RDown64 (LogHandle, StartAddr, EndAddr, 0xffffffff00000000);

			// Pass Fail
			if(bPass) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "64 Bit Data: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "64 Bit Data: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// 32 bit data
		if (Width32) {
			bPass = TRUE;
			EndAddr = StartAddr + TestableMemSize - sizeof(unsigned __int32);
			xStartVariation(gbConsoleOut, LogHandle, "32 Bit Data");
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "32 Bit Data: Iteration %d: StartAddr = %p, EndAddr = %p", i, StartAddr, EndAddr);
			bPass &= WUp32	(LogHandle, StartAddr, EndAddr, 0x00000000);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x00000000, 0xffffffff);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0xffffffff, 0x55555555);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x55555555, 0xaaaaaaaa);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0xaaaaaaaa, 0x55555555);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x55555555, 0x33333333);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0x33333333, 0xcccccccc);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0xcccccccc, 0x33333333);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0x33333333, 0x0f0f0f0f);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f, 0xf0f0f0f0);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0xf0f0f0f0, 0x0f0f0f0f);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x0f0f0f0f, 0x00ff00ff);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0x00ff00ff, 0xff00ff00);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0xff00ff00, 0x00ff00ff);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0x00ff00ff, 0x0000ffff);
			bPass &= RWDown32(LogHandle, StartAddr, EndAddr, 0x0000ffff, 0xffff0000);
			bPass &= RWUp32	(LogHandle, StartAddr, EndAddr, 0xffff0000, 0x0000ffff);
			bPass &= RDown32	(LogHandle, StartAddr, EndAddr, 0x0000ffff);

			// Pass Fail
			if(bPass) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "32 Bit Data: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "32 Bit Data: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// 16 bit data
		if (Width16) {
			bPass = TRUE;
			EndAddr = StartAddr + TestableMemSize - sizeof(unsigned __int16);
			xStartVariation(gbConsoleOut, LogHandle, "16 Bit Data");
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "16 Bit Data: Iteration %d: StartAddr = %p, EndAddr = %p", i, StartAddr, EndAddr);
			bPass &= WUp16	(LogHandle, StartAddr, EndAddr, 0x0000);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0x0000, 0xffff);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0xffff, 0x5555);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0x5555, 0xaaaa);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0xaaaa, 0x5555);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0x5555, 0x3333);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0x3333, 0xcccc);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0xcccc, 0x3333);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0x3333, 0x0f0f);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0x0f0f, 0xf0f0);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0xf0f0, 0x0f0f);
			bPass &= RWDown16(LogHandle, StartAddr, EndAddr, 0x0f0f, 0x00ff);
			bPass &= RWUp16	(LogHandle, StartAddr, EndAddr, 0x00ff, 0xff00);
			bPass &= RDown16	(LogHandle, StartAddr, EndAddr, 0xff00);

			// Pass Fail
			if(bPass) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "16 Bit Data: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "16 Bit Data: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// 8 bit data
		if (Width8) {
			bPass = TRUE;
			EndAddr = StartAddr + TestableMemSize - sizeof(unsigned __int8);
			xStartVariation(gbConsoleOut, LogHandle, "8 Bit Data");
			xLog(gbConsoleOut, LogHandle, XLL_INFO, "8 Bit Data: Iteration %d: StartAddr = %p, EndAddr = %p", i, StartAddr, EndAddr);
			bPass &= WUp8	(LogHandle, StartAddr, EndAddr, 0x00);
			bPass &= RWDown8	(LogHandle, StartAddr, EndAddr, 0x00, 0xff);
			bPass &= RWUp8	(LogHandle, StartAddr, EndAddr, 0xff, 0x55);
			bPass &= RWDown8	(LogHandle, StartAddr, EndAddr, 0x55, 0xaa);
			bPass &= RWUp8	(LogHandle, StartAddr, EndAddr, 0xaa, 0x55);
			bPass &= RWDown8	(LogHandle, StartAddr, EndAddr, 0x55, 0x33);
			bPass &= RWUp8	(LogHandle, StartAddr, EndAddr, 0x33, 0xcc);
			bPass &= RWDown8	(LogHandle, StartAddr, EndAddr, 0xcc, 0x33);
			bPass &= RWUp8	(LogHandle, StartAddr, EndAddr, 0x33, 0x0f);
			bPass &= RWDown8	(LogHandle, StartAddr, EndAddr, 0x0f, 0xf0);
			bPass &= RWUp8	(LogHandle, StartAddr, EndAddr, 0xf0, 0x0f);
			bPass &= RDown8	(LogHandle, StartAddr, EndAddr, 0x0f);

			// Pass Fail
			if(bPass) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "8 Bit Data: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "8 Bit Data: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// Check for done
		if(TestIterations != -1) {
			if(i >= TestIterations) {
				bDone = TRUE;
			}
		}
	} while (!bDone);

	// Free memory
	XPhysicalFree(StartAddr);
}


VOID
WINAPI
MemPatEndTest(VOID) {
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	HANDLE	LogHandle = NULL;

	// Do the initialization that the harness does
	// xlog
	LogHandle = xCreateLog_W(L"t:\\mempat.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MEMPAT: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		xCreateConsole(NULL);
		xSetBackgroundImage(NULL);
		gbConsoleOut = TRUE;
	}

	// Start Test
	MemPatStartTest(LogHandle);

	// End Test
	MemPatEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("MEMPAT: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( mempat )
#pragma data_seg()

BEGIN_EXPORT_TABLE( mempat )
    EXPORT_TABLE_ENTRY( "StartTest", MemPatStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MemPatEndTest )
END_EXPORT_TABLE( mempat )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\intelsrc\code\prime\wtlib.h ===
//
// INTEL CONFIDENTIAL.  Copyright (c) 1997-2000 Intel Corp. All rights reserved.
//
#if !defined(_WTLIB_H_)
#define _WTLIB_H_

// Only the TESTLIBC library must define the TESTDLL symbol so it will
// export its DLL functions.  All other files that include WTLIB.H will
// try to link to the correct debug/release DLL and import its functions.
//
#if defined(TESTDLL)
	#define DLLEXPORT __declspec(dllexport)
#else  
	#define DLLEXPORT __declspec(dllimport)
	#if defined (WIN64)
		#if defined(_DEBUG)
			#pragma comment(lib,"wtlib64d.lib")
		#else
			#pragma comment(lib,"wtlib64c.lib")
		#endif
	#else
		#if defined(_DEBUG)
			#pragma comment(lib,"testlibd.lib")
		#else
			#pragma comment(lib,"testlibc.lib")
		#endif
	#endif
#endif

// All WinMTA modules and libraries should dynamically link to the C-runtime library.
// This check ensures the use of the correct compiler flags.
//
#if !defined(_MT) || !defined(_DLL)
	#if defined(_DEBUG)
		#error The /MDd compiler switch is required (Use debug multithreaded C-runtime DLL)
	#else
		#error The /MD compiler switch is required (Use release multithreaded C-runtime DLL)
	#endif
#endif

// If MFC is used, make sure it is the shared DLL.
//
#if defined(__AFXWIN_H__) && !defined(_AFXDLL)
	#error When MFC is used, it should be from the shared DLL, not the static library.
#endif

#define TESTLIB_VERSION "version_number=4.00 "

// return values for prompt failures
//  PROMPT_CANCEL and PROMPT_TIMEOUT are handled by the library
//  and do not need to be tested by the caller.
//
#define PROMPT_OK			1
#define PROMPT_CANCEL		0

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * service call prototypes
 */
DLLEXPORT BOOL APIENTRY DllMain(HINSTANCE hModule,DWORD dwReason,LPVOID /*lpReserved*/);
DLLEXPORT BOOL wt_initialize(int* ptestnum);
DLLEXPORT void wt_set_cleanup(void(*cleanup)());
DLLEXPORT void wt_state(int state);
DLLEXPORT void wt_progress(int progress);
DLLEXPORT void wt_done();

DLLEXPORT int  wt_advisory(LPCTSTR format_string,...);
DLLEXPORT int  wt_error(DWORD ErrorCode, LPCTSTR format_string,...);
DLLEXPORT int  wt_statistic(DWORD StatCode,LPCTSTR format_string,...);
DLLEXPORT int  wt_status(LPCTSTR format_string,...);
DLLEXPORT int  wt_info(LPCTSTR format_string,...);
DLLEXPORT int  wt_verbose(DWORD mask,LPCTSTR format_string,...);

DLLEXPORT BOOL wt_getint(LPCTSTR key,int* pvalue);
DLLEXPORT BOOL wt_getuint(LPCTSTR key,UINT* pvalue);
DLLEXPORT BOOL wt_getstring(LPCTSTR key,LPTSTR value,DWORD length);
DLLEXPORT BOOL wt_putint (LPCTSTR path, LPCTSTR key, int pvalue);
DLLEXPORT BOOL wt_putuint (LPCTSTR path, LPCTSTR key, UINT pvalue);
DLLEXPORT BOOL wt_putstring (LPCTSTR path, LPCTSTR key, LPCTSTR value);

DLLEXPORT BOOL wt_remove_group(LPCTSTR path);
DLLEXPORT BOOL wt_copy_group(LPCTSTR path,LPCTSTR name,LPTSTR newPath,int length);
DLLEXPORT BOOL wt_remove_subtest(LPCTSTR path,int testNumber);
DLLEXPORT BOOL wt_disable_subtest(LPCTSTR path,int testNumber);

DLLEXPORT int  wt_prompt_list(int *choice,int count,const LPCTSTR* list,LPCTSTR prompt);
DLLEXPORT int  wt_prompt_string(LPTSTR buffer, int length, LPCTSTR prompt);
DLLEXPORT int  wt_prompt_confirm(BOOL *yesno, LPCTSTR prompt);
DLLEXPORT int  wt_wait_keypress(UINT* scancode, UCHAR* keycode);

#ifdef __cplusplus
}
#endif

#endif /* _WTLIB_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\memtest\memtest.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    memtest.c

Abstract:

    Routines to test memory

Environment:

    Xbox

Revision History:

Dev Notes:
	Data Checking:
		Write/Read/Verify 0x00, 0x55, 0xaa, 0xff

	Address Checking:
		Write address as value to each memory location.
		Read and verify contents.

	Walk ones:

	Walk zeros:

--*/

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

#define PAGE_SIZE 0x1000

//
// Prototypes and Typedefs from mm.h ke.h
//
extern "C" {
	ULONG_PTR
	WINAPI
	MmGetPhysicalAddress (
		IN PVOID BaseAddress
		);
}

struct MyInt128 {
	unsigned __int64 LowPart;
	unsigned __int64 HighPart;
};


//
// Function:	DataTest(...)
// Purpose:		Test memory data storage by writing and verifying the following data values
//				0x00, 0x55, 0xaa, 0xff
// Params:		
//				LogHandle	Handle for xLog
//				StartAddr	Pointer to starting address of memory to test
//				EndAddr		Pointer to ending address of memory to test
// Notes:		
//
BOOL
DataTest(HANDLE LogHandle, MyInt128 *StartAddr, MyInt128 *EndAddr) {
	MyInt128 *Addr, Value[4], R_Value;
	int i;
	BOOL bPass = TRUE;

	// Init Value Array
	Value[0].HighPart = 0x0000000000000000;
	Value[0].LowPart  = 0x0000000000000000;
	Value[1].HighPart = 0x5555555555555555;
	Value[1].LowPart  = 0x5555555555555555;
	Value[2].HighPart = 0xaaaaaaaaaaaaaaaa;
	Value[2].LowPart  = 0xaaaaaaaaaaaaaaaa;
	Value[3].HighPart = 0xffffffffffffffff;
	Value[3].LowPart  = 0xffffffffffffffff;

	Addr = StartAddr;
	do {
		// Check each value
		for(i = 0; i < 4; i++) {
			// Write memory location
			memcpy((void *)Addr, &Value[i], sizeof(MyInt128));

			// Read memory location
			memcpy(&R_Value, (void *)Addr, sizeof(MyInt128));

			// Test value
			if(memcmp(&R_Value, &Value[i], sizeof(MyInt128)) != 0) {
				bPass = FALSE;
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
						"DataTest FAILED at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
						Addr, MmGetPhysicalAddress(Addr), Value[i].HighPart, Value[i].LowPart, R_Value.HighPart, R_Value.LowPart);
				break;
			}
		}
		// Increment Address
		Addr++;

	} while((Addr <= EndAddr) & bPass);
	return bPass;
}
  

//
// Function:	AddressTest(...)
// Purpose:		Test memory addressing by writing and verifying the value of the address
//				to each location.

BOOL
AddressTest(HANDLE LogHandle, MyInt128 *StartAddr, MyInt128 *EndAddr) {
	MyInt128 *Addr, Value, R_Value;
	__int32 *ValueAddr;
	BOOL bPass = TRUE;

	// Write the address as the value
	for(Addr = StartAddr; Addr <= EndAddr; Addr++){
		// Fill Value with address
		ValueAddr = (__int32 *)&Value;
		*(ValueAddr) = (__int32)Addr;
		*(ValueAddr + 1) = (__int32)Addr;
		*(ValueAddr + 2) = (__int32)Addr;
		*(ValueAddr + 3) = (__int32)Addr;

		// Write Value
		memcpy((void *)Addr, &Value, sizeof(MyInt128));
	}

	// Read and Verify contents
	for(Addr = StartAddr; Addr <= EndAddr; Addr++){
		// Fill Value with address
		ValueAddr = (__int32 *)&Value;
		*(ValueAddr) = (__int32)Addr;
		*(ValueAddr + 1) = (__int32)Addr;
		*(ValueAddr + 2) = (__int32)Addr;
		*(ValueAddr + 3) = (__int32)Addr;

		// Read Value
		memcpy(&R_Value, (void *)Addr, sizeof(MyInt128));

		// Verify Value
		if(memcmp(&R_Value, &Value, sizeof(MyInt128)) != 0) {
			bPass = FALSE;
			xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
					"AddressTest FAILED at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
						Addr, MmGetPhysicalAddress(Addr), Value.HighPart, Value.LowPart, R_Value.HighPart, R_Value.LowPart);
			break;
		}
	}
	return bPass;
}


//
// Function:	WalkOnes(...)
// Purpose:		Test memory addressing by walking a "1" through a memory location
//				Only test 8 locations
//
BOOL
WalkOnes(HANDLE LogHandle, MyInt128 *StartAddr, MyInt128 *EndAddr) {
	MyInt128 *Addr, Value, R_Value;
	int i, j, iNumAddr;
	BOOL bPass = TRUE;

	// Number of MyInt128s
	iNumAddr = EndAddr - StartAddr + 1;
	iNumAddr /= 8;

	Value.HighPart = (unsigned __int64)0;
	Value.LowPart = (unsigned __int64)0;

	for(i = 0; i <= 8; i++) {
		// Set Address
		Addr = StartAddr + i*iNumAddr;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "WalkOnes at %p (physical = %p)", Addr, MmGetPhysicalAddress(Addr));
		for(j = 0; j < 128; j++) {
			// Shift the "1"
			if(j == 0) {
				Value.HighPart = (unsigned __int64)0;
				Value.LowPart = (unsigned __int64)1;
			} else if((j > 0) & (j < 64)) {
				Value.HighPart = (unsigned __int64)0;
				Value.LowPart <<= (unsigned __int64)1;
			} else if(j == 64) {
				Value.HighPart = (unsigned __int64)1;
				Value.LowPart = (unsigned __int64)0;
			} else {			
				Value.HighPart <<= (unsigned __int64)1;
				Value.LowPart = (unsigned __int64)0;
			}

			// Write Value
			memcpy((void *)Addr, &Value, sizeof(MyInt128));

			// Read Value
			memcpy(&R_Value, (void *)Addr, sizeof(MyInt128));
			
			/*
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"WalkOnes at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
							Addr, MmGetPhysicalAddress(Addr), Value.HighPart, Value.LowPart, R_Value.HighPart, R_Value.LowPart);
			*/

			// Verify Value
			if(memcmp(&R_Value, &Value, sizeof(MyInt128)) != 0) {
				bPass = FALSE;
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
					"WalkOnes FAILED at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
							Addr, MmGetPhysicalAddress(Addr), Value.HighPart, Value.LowPart, R_Value.HighPart, R_Value.LowPart);
				break;
			}
		}
	}
	return bPass;
}


//
// Function:	WalkZeros()
// Purpose:		Test memory addressing by walking a "0" through a memory location
//				Only test 8 locations
//
BOOL
WalkZeros(HANDLE LogHandle, MyInt128 *StartAddr, MyInt128 *EndAddr) {
	MyInt128 *Addr, Value, R_Value;
	int i, j, iNumAddr;
	BOOL bPass = TRUE;

	// Number of MyInt128s
	iNumAddr = EndAddr - StartAddr + 1;
	iNumAddr /= 8;

	Value.HighPart = (unsigned __int64)0;
	Value.LowPart = (unsigned __int64)0;

	for(i = 0; i <= 8; i++) {
		// Set Address
		Addr = StartAddr + i*iNumAddr;
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "WalkZeros at %p (physical = %p)", Addr, MmGetPhysicalAddress(Addr));
		for(j = 0; j < 128; j++) {
			// Shift the "0"
			if(j == 0) {
				Value.HighPart = (unsigned __int64)~(0);
				Value.LowPart = (unsigned __int64)~(1);
			} else if((j > 0) & (j < 64)) {
				Value.HighPart = (unsigned __int64)~(0);
				Value.LowPart = (unsigned __int64)~(~(Value.LowPart)<<1);
			} else if(j == 64) {
				Value.HighPart = (unsigned __int64)~(1);
				Value.LowPart = (unsigned __int64)~(0);
			} else {			
				Value.HighPart = (unsigned __int64)~(~(Value.HighPart)<<1);
				Value.LowPart = (unsigned __int64)~(0);
			}

			// Write Value
			memcpy((void *)Addr, &Value, sizeof(MyInt128));

			// Read Value
			memcpy(&R_Value, (void *)Addr, sizeof(MyInt128));

			/*
			xLog(gbConsoleOut, LogHandle, XLL_INFO, 
				"WalkZeros at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
							Addr, MmGetPhysicalAddress(Addr), Value.HighPart, Value.LowPart, R_Value.HighPart, R_Value.LowPart);
			*/

			// Verify Value
			if(memcmp(&R_Value, &Value, sizeof(MyInt128)) != 0) {
				bPass = FALSE;
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, 
					"WalkZeros FAILED at %p (physical = %p), Wrote: %#.16I64x%.16I64x, Read: %#.16I64x%.16I64x",
							Addr, MmGetPhysicalAddress(Addr), Value.HighPart, Value.LowPart, R_Value.HighPart, R_Value.LowPart);
				break;
			}
		}
	}
	return bPass;
}


VOID
WINAPI
MemTestStartTest(HANDLE LogHandle) {
    SIZE_T TestableMemSize, PercentAvail;
    MEMORYSTATUS ms;
	MyInt128 *StartAddr, *EndAddr;
	BOOL DoDataTest, DoAddressTest, DoWalkOnes, DoWalkZeros, UseWriteCombine, bDone;
	ULONG PhysicalAddress, Alignment;
	DWORD Protect;
	int TestIterations, i;

	// Initialize
	i = 0;
	bDone = FALSE;

	DoDataTest = GetProfileInt(TEXT("memtest"), TEXT("DataTest"), 1);
	DoAddressTest = GetProfileInt(TEXT("memtest"), TEXT("AddressTest"), 1);
	DoWalkOnes = GetProfileInt(TEXT("memtest"), TEXT("WalkOnes"), 1);
	DoWalkZeros = GetProfileInt(TEXT("memtest"), TEXT("WalkZeros"), 1);
	TestIterations = GetProfileInt(TEXT("memtest"), TEXT("TestIterations"), 1);
	PercentAvail = GetProfileInt(TEXT("memtest"), TEXT("PercentAvail"), 80);
	UseWriteCombine = GetProfileInt(TEXT("memtest"), TEXT("UseWriteCombine"), 0);

	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetComponent(LogHandle, "Hardware", "MemTest");
    xSetFunctionName(LogHandle, "MemTest");
	xStartVariation( gbConsoleOut, LogHandle, "Initialization" );

	// Query global memory status
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus( &ms );

	xLog(gbConsoleOut, LogHandle, XLL_INFO, 
		"MEMTEST: GlobalMemoryStatus returned %u bytes of %u bytes available", 
		ms.dwAvailPhys, ms.dwTotalPhys);

	// Allocate specified % of available memory
	TestableMemSize = (SIZE_T)((double)ms.dwAvailPhys*(double)PercentAvail/100.0);

	// Round to neareast int128
	TestableMemSize -= TestableMemSize%(sizeof(MyInt128));

	// Start at any physical address
	PhysicalAddress = MAXULONG_PTR;

	// Default alignment (PAGE)
	Alignment = 0;

	// Memory Protection
	if(UseWriteCombine) {
		Protect = PAGE_READWRITE | PAGE_WRITECOMBINE;
	} else {
		Protect = PAGE_READWRITE | PAGE_NOCACHE;
	}

	// Reduce TestableMemSize a page at a time until memory can be allocated
    for (;;) {
		StartAddr = (MyInt128 *)XPhysicalAlloc(TestableMemSize, PhysicalAddress, Alignment, Protect);
        if ( StartAddr ) {
            break;
        }
        if ( TestableMemSize <= PAGE_SIZE ) {
            break;
        }
        TestableMemSize -= PAGE_SIZE;
    }

    if ( !StartAddr ) {
        xLog(gbConsoleOut, LogHandle, XLL_BLOCK, "MemTest: unable to allocate memory (size=%lu, error=%s)",
            TestableMemSize, WinErrorSymbolicName(GetLastError()));
        return;
    }

	EndAddr = StartAddr + TestableMemSize/sizeof(MyInt128) - sizeof(MyInt128);

	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemTest: %lu bytes allocated as %s", 
		TestableMemSize, UseWriteCombine ? "PAGE_WRITECOMBINE" : "PAGE_NOCACHE");
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemTest: Starting Address %p (physical %p)",
		StartAddr, MmGetPhysicalAddress(StartAddr));
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemTest: Ending Address %p (physical %p)",
		EndAddr, MmGetPhysicalAddress(EndAddr));

	xEndVariation(LogHandle);

	do {
		// Increment iteration counter
		i++;

		// DataTest
		if(DoDataTest) {
			xStartVariation(gbConsoleOut, LogHandle, "DataTest");
			if(DataTest(LogHandle, StartAddr, EndAddr)) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "MemTest: DataTest: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemTest: DataTest: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// AddressTest
		if(DoAddressTest) {
			xStartVariation(gbConsoleOut, LogHandle, "AddressTest");
			if(AddressTest(LogHandle, StartAddr, EndAddr)) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "MemTest: AddressTest: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemTest: AddressTest: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// WalkOnes
		if(DoWalkOnes) {
			xStartVariation(gbConsoleOut, LogHandle, "WalkOnes");
			if(WalkOnes(LogHandle, StartAddr, EndAddr)) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "MemTest: WalkOnes: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemTest: WalkOnes: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		// WalkZeros
		if (DoWalkZeros) {
			xStartVariation(gbConsoleOut, LogHandle, "WalkZeros");
			if(WalkZeros(LogHandle, StartAddr, EndAddr)) {
				xLog(gbConsoleOut, LogHandle, XLL_PASS, "MemTest: WalkZeros: PASSED Iteration %d", i);
			} else {
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemTest: WalkZeros: FAILED Iteration %d", i);
				break;
			}
			xEndVariation(LogHandle);
		}

		
		// Check for done
		if(TestIterations != -1) {
			if(i >= TestIterations) {
				bDone = TRUE;
			}
		}
	} while (!bDone);
    

	// Free memory
 	XPhysicalFree(StartAddr);
}


VOID
WINAPI
MemTestEndTest() {
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	HANDLE	LogHandle;
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\memtest.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if (LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MEMTEST: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		xCreateConsole(NULL);
		xSetBackgroundImage(NULL);
		gbConsoleOut = TRUE;
	}

	// Start Test
	MemTestStartTest(LogHandle);

	// End Test
	MemTestEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("MemTest: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( memtest )
#pragma data_seg()

BEGIN_EXPORT_TABLE( memtest )
    EXPORT_TABLE_ENTRY( "StartTest", MemTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MemTestEndTest )
END_EXPORT_TABLE( memtest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\memval\memval.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    memval.cpp

Abstract:

    Read and write the specified value to the specified address

Environment:

    Xbox

Revision History:

--*/

#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

//
// 128 bit value
struct MEMBUS {
	DWORD DWord0;
	DWORD DWord1;
	DWORD DWord2;
	DWORD DWord3;
};

VOID
WINAPI
MemValStartTest(HANDLE LogHandle) {
	MEMBUS *Val, RVal, WAVal, WBVal;
	ULONG_PTR Address;
	BOOL bARO, bAWO, bBRO, bBWO, bUseWriteCombine, bDone, bPass;
	DWORD Protect;
	int TestIterations, i;

	// Initialize
	i = 0;
	bDone = FALSE;
	bPass = TRUE;

	// Get physical address from testini.ini, default MAXULONG_PTR causes system to determine address
	Address = (ULONG_PTR)GetProfileInt(TEXT("memval"), TEXT("Address"), MAXULONG_PTR);

	// Get A value from testini.ini
	WAVal.DWord0 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("AVal0"), 0x00000000);
	WAVal.DWord1 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("AVal1"), 0x55555555);
	WAVal.DWord2 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("AVal2"), 0xaaaaaaaa);
	WAVal.DWord3 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("AVal3"), 0xffffffff);
	bARO = GetProfileInt(TEXT("memval"), TEXT("ARO"), 1);
	bAWO = GetProfileInt(TEXT("memval"), TEXT("AWO"), 1);

	// Get B value from testini.ini
	WBVal.DWord0 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("BVal0"), 0xffffffff);
	WBVal.DWord1 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("BVal1"), 0xaaaaaaaa);
	WBVal.DWord2 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("BVal2"), 0x55555555);
	WBVal.DWord3 = (DWORD)GetProfileInt(TEXT("memval"), TEXT("BVal3"), 0x00000000);
	bBRO = GetProfileInt(TEXT("memval"), TEXT("BRO"), 1);
	bBWO = GetProfileInt(TEXT("memval"), TEXT("BWO"), 1);

	// Get number of iterations from testini.ini
	TestIterations = GetProfileInt(TEXT("memval"), TEXT("TestIterations"), 1);

	// Memory Protection
	bUseWriteCombine = GetProfileInt(TEXT("memval"), TEXT("UseWriteCombine"), 0);
	if(bUseWriteCombine) {
		Protect = PAGE_READWRITE | PAGE_WRITECOMBINE;
	} else {
		Protect = PAGE_READWRITE | PAGE_NOCACHE;
	}

	// Set xLog info
    xSetOwnerAlias(LogHandle, "a-emebac");
	xSetComponent(LogHandle, "Hardware", "MemVal");
	xSetFunctionName(LogHandle, "MemVal");

	// Allocate 128 bits at address
	Val = (MEMBUS *)XPhysicalAlloc(sizeof(WAVal), Address, 0,  Protect);
    if(Val == NULL) {
        xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemVal: XPhysicalAlloc() %u bytes at %p FAILED: %s",
				sizeof(WAVal), Address, WinErrorSymbolicName(GetLastError()));
        return;
    }

	// Log memory allocation
	xLog(gbConsoleOut, LogHandle, XLL_INFO, "MemVal: Virtural Address: %p, Physical Address: %p", Val, Address);

	// Log Value A
	if(bARO && bAWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read/Write Value A: %#.8x%.8x%.8x%.8x",
			WAVal.DWord3, WAVal.DWord2, WAVal.DWord1, WAVal.DWord0);
	} else if(bARO && !bAWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read Only Value A: %#.8x%.8x%.8x%.8x",
			WAVal.DWord3, WAVal.DWord2, WAVal.DWord1, WAVal.DWord0);
	} else if(!bARO && bAWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Write Only Value A: %#.8x%.8x%.8x%.8x",
			WAVal.DWord3, WAVal.DWord2, WAVal.DWord1, WAVal.DWord0);
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Value A Not Used");
	}

	// Log Value B
	if(bBRO && bBWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read/Write Value B: %#.8x%.8x%.8x%.8x",
			WBVal.DWord3, WBVal.DWord2, WBVal.DWord1, WBVal.DWord0);
	} else if(bBRO && !bBWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Read Only Value B: %#.8x%.8x%.8x%.8x",
			WBVal.DWord3, WBVal.DWord2, WBVal.DWord1, WBVal.DWord0);
	} else if(!bBRO && bBWO) {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Write Only Value B: %#.8x%.8x%.8x%.8x",
			WBVal.DWord3, WBVal.DWord2, WBVal.DWord1, WBVal.DWord0);
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_INFO, "Value B Not Used");
	}

	// Do first write to memory
	if(!bARO && !bAWO && (bBRO || bBWO)) {
		// First write should be B value
		memcpy(Val, &WBVal, sizeof(WBVal));
	} else {
		// First write should be A value
		memcpy(Val, &WAVal, sizeof(WAVal));
	}

	do {
		// Increment iteration counter
		i++;

		// Read A value
		if(bARO) {
			memcpy(&RVal, Val, sizeof(WAVal));

			// Compare value
			if(memcmp(&RVal, &WAVal, sizeof(WAVal)) != 0) {
				bPass = FALSE;
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemVal: Iteration %d: Read Value A (%#.8x%.8x%.8x%.8x) != Write Value A (%#.8x%.8x%.8x%.8x)",
					i, RVal.DWord3, RVal.DWord2, RVal.DWord1, RVal.DWord0, 
					WAVal.DWord3, WAVal.DWord2, WAVal.DWord1, WAVal.DWord0);
				break;
			}
		}

		// Write B value
		if(bBWO) {
			memcpy(Val, &WBVal, sizeof(WBVal));
		}

		// Read B value
		if(bBRO) {
			memcpy(&RVal, Val, sizeof(WBVal));

			// Compare value
			if(memcmp(&RVal, &WBVal, sizeof(WBVal)) != 0) {
				bPass = FALSE;
				xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemVal: Iteration %d: Read Value B (%#.8x%.8x%.8x%.8x) != Write Value B (%#.8x%.8x%.8x%.8x)",
					i, RVal.DWord3, RVal.DWord2, RVal.DWord1, RVal.DWord0, 
					WBVal.DWord3, WBVal.DWord2, WBVal.DWord1, WBVal.DWord0);
				break;
			}
		}

		// Write A value
		if(bAWO) {
			memcpy(Val, &WAVal, sizeof(WAVal));
		}

		// Check for done
		if(TestIterations != -1) {
			if(i >= TestIterations) {
				bDone = TRUE;
			}
		}
	} while(!bDone);

	// Pass/Fail
	if(bPass) {
		xLog(gbConsoleOut, LogHandle, XLL_PASS, "MemVal: PASSED %i Iterations", i);
	} else {
		xLog(gbConsoleOut, LogHandle, XLL_FAIL, "MemVal: FAILED %i Iteration", i);
	}

	// Free memory
	XPhysicalFree(Val);
}


VOID
WINAPI
MemValEndTest(VOID) {
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	HANDLE	LogHandle = NULL;

	// Do the initialization that the harness does
	// xlog
	LogHandle = xCreateLog_W(L"t:\\memval.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if(LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MEMVAL: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		xCreateConsole(NULL);
		xSetBackgroundImage(NULL);
		gbConsoleOut = TRUE;
	}

	// Start Test
	MemValStartTest(LogHandle);

	// End Test
	MemValEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("MEMVAL: End - Waiting for reboot...\n");
	Sleep(INFINITE);

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	// xlog
	xCloseLog(LogHandle);

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( memval )
#pragma data_seg()

BEGIN_EXPORT_TABLE( memval )
    EXPORT_TABLE_ENTRY( "StartTest", MemValStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MemValEndTest )
END_EXPORT_TABLE( memval )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\memsize\memsize.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    memsize.c

Abstract:

    Routines to get memory size from various APIs

Environment:

    Xbox

Revision History:

	Added console output via dxconio.lib

--*/
#include <xtl.h>
#include <xtestlib.h>
#include <xlog.h>
#include <dxconio.h>
#include <xlogconio.h>

VOID
WINAPI
MemSizeStartTest(HANDLE LogHandle) {
    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus( &ms );

	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetComponent(LogHandle, "Hardware", "memsize");
    xSetFunctionName(LogHandle, "GlobalMemoryStatus");
    xStartVariation(gbConsoleOut, LogHandle, "MEMSIZE: GlobalMemoryStatus");
    xLog( gbConsoleOut, LogHandle, XLL_PASS, "MEMSIZE: GlobalMemoryStatus returns total memory = %lu bytes", ms.dwTotalPhys );
    xEndVariation( LogHandle );
}


VOID
WINAPI
MemSizeEndTest(VOID) {
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	BOOL RunForever = TRUE;
	HANDLE	LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\memsize.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if (LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MEMSIZE: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		gbConsoleOut = TRUE;
	}

	// Start Test
	MemSizeStartTest(LogHandle);

	// End Test
	MemSizeEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("MEMSIZE: End - Waiting for reboot...\n");
	while (RunForever) {
	}

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif
//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( memsize )
#pragma data_seg()

BEGIN_EXPORT_TABLE( memsize )
    EXPORT_TABLE_ENTRY( "StartTest", MemSizeStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MemSizeEndTest )
END_EXPORT_TABLE( memsize )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\demo\demo.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    demo.cpp

Abstract:

    Sample manufacturing test application. This is a regular PE image created
    by Xbox development kit. Note that we will use only PE images, the MTLDR
    will not load XBE image.

--*/

#include "demop.h"

void __cdecl main( void )
/*++

Routine Description:

    This is a main entry point of manufacturing test application.

Arguments:

    None

Return Value:

    None

--*/
{
    WSADATA wsa;

    XnetInitialize( NULL, TRUE );
    WSAStartup( MAKEWORD(2, 2), &wsa );
    OutputDebugString( TEXT("hello world!\n") );
    WSACleanup();
    XnetCleanup();

    Sleep( INFINITE );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\demo\demop.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    demop.h

Abstract:

    Pre-compile header file	for sample manufacturing test application

--*/

#include <xtl.h>
#include <winsockx.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\debug.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    debug.cpp

Abstract:

    This module contains various debugging macros used by mtldr

--*/

#include "mtldrp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\inc\sysload.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    sysload.h

Abstract:

    Prototypes  of routines used to load EXEs into the system portion of
    the address space and calls the EXE at its initialization entry point.

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MTLDR_SYSLOAD

#define _MTLDR_SYSLOAD

#ifdef __cplusplus
extern "C" {
#endif

VOID
NTAPI
LdrInitializeSystemLoader(
    PVOID KernelLoaderBlock
    );

ULONG
NTAPI
LdrLoadSystemImage(
    IN PVOID ImageBuffer,
    IN PCSTR ImageFileName
    );

#define ALIGN_DOWN_POINTER(address, type) \
    ((PVOID)((ULONG_PTR)(address) & ~((ULONG_PTR)sizeof(type) - 1)))

#define ALIGN_UP_POINTER(address, type) \
    (ALIGN_DOWN_POINTER(((ULONG_PTR)(address) + sizeof(type) - 1), type))

#ifdef __cplusplus
}
#endif

#endif  // _MTLDR_SYSLOAD
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\mtldr.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mtldr.cpp

Abstract:

    This is a main module of manufacturing test boot-loader (mtldr). Mtldr
    is used for downloading external test application, which is an unsigned,
    uncertified, from a test server and execute the test application.

    Binary format of test application is regular Win32 portable executable (PE)
    format created by Xbox software development kit (XDK). However only .EXE
    will be loaded by the mtldr, we don't support loading .DLL format because
    XDK won't produce .DLL image

--*/

#include "mtldrp.h"

EXTERN_C
DWORD
WINAPI
MtLdrDownloadFileToMemory(
    IN  LPCSTR pszDownloadUrl,
    OUT PVOID  *Buffer
    );

//
// The URL is hard-coded to "http://xboxostestsql/demo.exe"
//

const CHAR *HttpServer  = "schanbai0";
const CHAR *HttpFileUrl = "/demo.exe";

ULONG
HttpGetServerAddress(
    VOID
    )
/*++

Routine Description:

    This routine looks up the address of global server name specified by
    global variable "HttpServer" above.

Arguments:

    None

Return Value:

    IPv4 address of the server or INADDR_NONE, call WSAGetLastError to
    see the error information.

--*/
{
    HOSTENT *h = gethostbyname( HttpServer );

    if ( h ) {
        return *(PULONG)h->h_addr_list[0];
    }

    return INADDR_NONE;
}

BOOL
HttpSendRequest(
    IN  PCSTR  Request,
    OUT PSTR   Response,
    IN  SIZE_T ResponseSize
    )
/*++

Routine Description:

    Helper routine that sends request to HTTP server and receives response
    back.  The HTTP response code will NOT be checked on behalf of the caller.

Arguments:

    Request - HTTP request line, including headers

    Response - Buffer to receive HTTP response

    ResponseSize - Size of the response buffer

Return Value:

    TRUE if operation success. FALSE if error occurred, call WSAGetLastError
    for more information.

--*/
{
    INT err;
    SOCKET s;
    ULONG ServerIP;
    SOCKADDR_IN si;
    BOOL b = FALSE;
    SIZE_T BytesReceived;

    ServerIP = HttpGetServerAddress();

    if ( ServerIP == INADDR_NONE ) {
        return FALSE;
    }

    s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

    if ( s == INVALID_SOCKET ) {
        return FALSE;
    }

    ZeroMemory( &si, sizeof(si) );
    si.sin_family = AF_INET;
    si.sin_port = htons( 80 );
    si.sin_addr.s_addr = ServerIP;

    err = connect( s, (SOCKADDR *)&si, sizeof(si) );

    if ( err == SOCKET_ERROR ) {
        goto cleanup;
    }

    //
    // Assuming size of data to be sent is small enough to send successfully
    // in one call
    //

    err = send( s, Request, strlen(Request), 0 );

    if ( err == SOCKET_ERROR ) {
        goto cleanup;
    }

    //
    // Loop until we couldn't get any more data
    //

    BytesReceived = 0;
    do {
        err = recv( s, Response+BytesReceived, ResponseSize-BytesReceived, 0 );
        BytesReceived += err;
    } while ( err != SOCKET_ERROR && err != 0 && BytesReceived < ResponseSize);

    if ( err == SOCKET_ERROR) {
        goto cleanup;
    }

    if ( err != 0 ) {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        goto cleanup;
    }

    b = TRUE;

cleanup:
    closesocket( s );
    return b;
}

LPVOID
MtldrDownloadFileToMemory(
    VOID
    )
/*++

Routine Description:

    This routine connects to the http server specified by global HttpServer
    variable and downloads the content of the image specified by global
    HttpFileUrl variable to memory

Arguments:

    None

Return Value:

    Pointer to memory that contains downloaded image or NULL.  Call
    GetLastError to get more information on error in case the routine
    returns NULL

--*/
{
    BOOL b;
    INT len;
    PCHAR ImageBuffer = NULL;
    PCHAR p, Buffer = NULL;
    SIZE_T FileSize, Size;
    const SIZE_T BufferLen = 4096;

    Buffer = (PCHAR)LocalAlloc( LPTR, BufferLen );

    if ( !Buffer ) {
        return NULL;
    }

    len = sprintf( Buffer, "HEAD %s HTTP/1.0\r\n\r\n", HttpFileUrl );
    b = HttpSendRequest( Buffer, Buffer, BufferLen );

    if ( !b ) {
        goto cleanup;
    }

    p = strstr( Buffer, "200 OK" );

    if ( p ) {
        p = strstr( Buffer, "Content-Length:" );
    }

    if ( !p ) {
        SetLastError( ERROR_FILE_NOT_FOUND );
        goto cleanup;
    }

    p += sizeof("Content-Length:") - 1;
    FileSize = atol( p );

    if ( !FileSize ) {
        SetLastError( WSAEINVAL );
        goto cleanup;
    }

    Size = FileSize + 4096;
    ImageBuffer = (PCHAR)LocalAlloc( LMEM_FIXED, Size );

    if ( !ImageBuffer ) {
        goto cleanup;
    }

    len = sprintf( Buffer, "GET %s HTTP/1.0\r\n\r\n", HttpFileUrl );
    b = HttpSendRequest( Buffer, ImageBuffer, Size );

    if ( b ) {

        p = strstr( ImageBuffer, "\r\n\r\n" );

        if ( p ) {

            p += sizeof("\r\n\r\n") - 1;
            if ( *(PWORD)p != IMAGE_DOS_SIGNATURE ) {
                SetLastError( ERROR_BAD_EXE_FORMAT );
            } else {
                RtlMoveMemory( ImageBuffer, p, FileSize );
                goto cleanup;
            }
        }
    }

    LocalFree( ImageBuffer );
    ImageBuffer = NULL;

cleanup:
    LocalFree( Buffer );
    return ImageBuffer;
}

int __cdecl main( void )
{
    INT err;
    DWORD Error;
    WSADATA wsa;
    PVOID ImageBuffer;

    //
    // Load and initialize Xnet/socket library
    //

    err = XnetInitialize( NULL, TRUE );

    if ( err != NO_ERROR ) {
        MtDbgPrint(( "MTLDR: XnetInitialize failed (%lu)\n", err ));
        return err;
    }

    ZeroMemory( &wsa, sizeof(wsa) );

    err = WSAStartup( MAKEWORD(2, 2), &wsa );

    if ( err != NO_ERROR ) {
        MtDbgPrint(( "MTLDR: WSAStartup failed (%lu)\n", err ));
        XnetCleanup();
        return err;
    }

    ImageBuffer = MtldrDownloadFileToMemory();

    //
    // Unload socket library so that the application can use it
    //

    WSACleanup();
    XnetCleanup();

    if ( !ImageBuffer ) {
        MtDbgPrint(( "MTLDR: unable to download http://%s%s (%lu)\n",
                     HttpServer, HttpFileUrl, GetLastError() ));
    } else {
        //
        // Let the loader fix up and snap import table
        //
        Error = LdrLoadSystemImage( ImageBuffer, HttpFileUrl+1 );

        if ( Error != ERROR_SUCCESS ) {
            MtDbgPrint(( "MTLDR: unable to load system image (%lu)\n", Error ));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\mtldrp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    mtldrp.h

Abstract:

    Pre-compile header file     for manufacturing test loader

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#include <xtl.h>
#include <stdio.h>
#include "debug.h"
#include "sysload.h"

#ifndef EXTERN_C

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif

#endif // EXTERN_C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\msr\msr.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    msr.c

Abstract:

    msr test

by:

    Jason Gould (jgould) 5 sept 2000

Environment:

    XBox

Revision History:

--*/

#include <xtl.h>
#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>
#include <dxconio.h>
#include <xlogconio.h>

VOID
WINAPI
MsrStartTest(HANDLE LogHandle)
/*++

Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

--*/

{
 //   HANDLE atapt;

    int num;
    BOOL write;
    __int64 outval;
    int low;
    int high;
    int dobool;
    __int64 inval;
    int i;

    char buf[128];

    num = GetProfileInt(TEXT("msr"), TEXT("MsrNumber"), 0x2a);
    write = GetProfileInt(TEXT("msr"), TEXT("MsrWrite"), 0);

    *(((int*)&outval)    ) = GetProfileInt(TEXT("msr"), TEXT("MsrWriteValLow"), 0);   //low byte
    *(((int*)&outval) + 1) = GetProfileInt(TEXT("msr"), TEXT("MsrWriteValHigh"), 0);  //high byte

    low = GetProfileInt(TEXT("msr"), TEXT("MsrRangeLow"), 22);
    high = GetProfileInt(TEXT("msr"), TEXT("MsrRangeHigh"), 25);
    dobool = GetProfileInt(TEXT("msr"), TEXT("MsrBool"), 1);

	xSetOwnerAlias(LogHandle, "a-emebac");
    xSetComponent( LogHandle, "msr", "msr" );
    xSetFunctionName(LogHandle, "StartTest" );

    xStartVariation( gbConsoleOut, LogHandle, "ProcInfo" );

    if(write) {
	    xStartVariation(gbConsoleOut, LogHandle, "MSR: Write");

        __try{
            __asm {
                mov ecx, [num];
                rdmsr;
                mov dword ptr [inval], eax;
                mov dword ptr [inval+4], edx;
            }
        } __except (1) {
            xLog(gbConsoleOut, LogHandle, XLL_INFO, "MSR: could not read msr 0x%x", num);
            goto done;
        }

        inval  &= ~(((1i64 >> (high + 1 - low)) - 1) << low);   //clear bits we will change
        outval &= (1i64 >> (high + 1 - low)) - 1;               //remove "noise" from the outval
        outval <<= low;                                     //shift outval to fit in the hole in inval
        inval |= outval;                                    //merge

        __try{
            __asm {
                mov ecx, [num];
                mov eax, dword ptr [inval];
                mov edx, dword ptr [inval+4];
                wrmsr;
            }
        } __except (1) {
            xLog(gbConsoleOut, LogHandle, XLL_INFO, "MSR: could not write to msr 0x%x", num);
            goto done;
        }
		xEndVariation( LogHandle );
    }

	xStartVariation( gbConsoleOut, LogHandle, "MSR: Read");
    __try{
        __asm {
            mov ecx, [num];
            rdmsr;
            mov dword ptr [inval], eax;
            mov dword ptr [inval+4], edx;
        }
    } __except (1) {
        xLog(gbConsoleOut, LogHandle, XLL_INFO, "MSR: could not read msr 0x%x", num);
        goto done;
    }

    xLog(gbConsoleOut, LogHandle, XLL_INFO, "MSR: read of MSR 0x%x succeeded", num);

    if(dobool) {
        sprintf(buf, "Whole MSR: ");
        for(i = 63; i >= 0; i--) {
            strcat(buf, (inval & (1i64 << i)) ? "1" : "0");
        }
        xLog(gbConsoleOut, LogHandle, XLL_INFO, buf);

        if(low != 0 || high != 63) {
            sprintf(buf, "Partial MSR:");
            for(i = high; i >= low; i--) {
                strcat(buf, (inval & (1i64 << i)) ? "1" : "0");
            }
            xLog(gbConsoleOut, LogHandle, XLL_INFO, buf);
        }

    } else {
        xLog(gbConsoleOut, LogHandle, XLL_INFO, "Whole MSR: %016I64x", inval);

        if(low != 0 || high != 63) {
            xLog(gbConsoleOut, LogHandle, XLL_INFO, "Partial MSR: 0x%I64x", (inval >> low) & ((1 << (high + 1 - low)) - 1));
        }
    }

done:
    xEndVariation( LogHandle );
    return;
}


VOID
WINAPI
MsrEndTest(VOID)

/*++

Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

--*/
{
}

#if !defined(HARNESSLIB)
/*************************************************************************************
Function:	main (...)
Purpose:	XBE Entry point
Params:
Notes:		
*************************************************************************************/
int __cdecl main() {
	BOOL RunForever = TRUE;
	HANDLE	LogHandle;


	// Do the initialization that the harness does
	// dxconio
	xCreateConsole(NULL);
	xSetBackgroundImage(NULL);
	
	// xlog
	LogHandle = xCreateLog_W(L"t:\\msr.log",
                            NULL,
                            INVALID_SOCKET,
                            XLL_LOGALL,
                            XLO_REFRESH | XLO_STATE | XLO_CONFIG | XLO_DEBUG);
	if (LogHandle == INVALID_HANDLE_VALUE ) {
		xDebugStringA("MSR: couldn't create log (%s)\n", WinErrorSymbolicName(GetLastError()));
		return 0;
    }

	// Get test configuration from ini file
	if (GetProfileInt(TEXT("GeneralSettings"), TEXT("StressTestMode"), 0) ||
		GetProfileInt(TEXT("GeneralSettings"), TEXT("ParallelTestMode"), 0)) {
		gbConsoleOut = FALSE;
	} else {
		gbConsoleOut = TRUE;
	}

	// Start Test
	MsrStartTest(LogHandle);

	// End Test
	MsrEndTest();

	// xlog
	xCloseLog(LogHandle);
	
	// Wait forever, must reboot xbox
	// Future: add wait for game control input to go back to dash 
	xDebugStringA("MSR: End - Waiting for reboot...\n");
	while (RunForever) {
	}

	// Do the de-initialize that the harness does
	// dxconio
	xReleaseConsole();

	return 0;
}
#endif

//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( msr )
#pragma data_seg()

BEGIN_EXPORT_TABLE( msr )
    EXPORT_TABLE_ENTRY( "StartTest", MsrStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", MsrEndTest )
END_EXPORT_TABLE( msr )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldr\debug.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    debug.h

Abstract:

    This module contains various debugging macros used by mtldr

--*/

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _MTLDR_DEBUG

#define _MTLDR_DEBUG

#ifdef __cplusplus
extern "C" {
#endif

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );

#if defined(DBG) || defined(_DEBUG)

#define MtDbgPrint(_x_)     DbgPrint _x_
#define MtDbgBreak()        __asm int 3

#else   // DBG

#define MtDbgPrint(_x_)
#define MtDbgBreak()

#endif  // DBG

#if defined(DBG) && !defined(_DEBUG)
#define _DEBUG
#endif

#ifdef __cplusplus
}
#endif

#endif  // _MTLDR_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\random.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Random.c

Abstract:

    This module implements a simple random number generator

Environment:

    Pure utility routine

Revision History:

--*/

#include "mtldrp.h"

#define Multiplier ((ULONG)(0x80000000ul - 19)) // 2**31 - 19
#define Increment  ((ULONG)(0x80000000ul - 61)) // 2**31 - 61
#define Modulus    ((ULONG)(0x80000000ul - 1))  // 2**31 - 1

ULONG RtlpRandomConstantVector[128] = {
    0x4c8bc0aa, 0x4c022957, 0x2232827a, 0x2f1e7626, 0x7f8bdafb, 0x5c37d02a, 0x0ab48f72, 0x2f0c4ffa,
    0x290e1954, 0x6b635f23, 0x5d3885c0, 0x74b49ff8, 0x5155fa54, 0x6214ad3f, 0x111e9c29, 0x242a3a09,
    0x75932ae1, 0x40ac432e, 0x54f7ba7a, 0x585ccbd5, 0x6df5c727, 0x0374dad1, 0x7112b3f1, 0x735fc311,
    0x404331a9, 0x74d97781, 0x64495118, 0x323e04be, 0x5974b425, 0x4862e393, 0x62389c1d, 0x28a68b82,
    0x0f95da37, 0x7a50bbc6, 0x09b0091c, 0x22cdb7b4, 0x4faaed26, 0x66417ccd, 0x189e4bfa, 0x1ce4e8dd,
    0x5274c742, 0x3bdcf4dc, 0x2d94e907, 0x32eac016, 0x26d33ca3, 0x60415a8a, 0x31f57880, 0x68c8aa52,
    0x23eb16da, 0x6204f4a1, 0x373927c1, 0x0d24eb7c, 0x06dd7379, 0x2b3be507, 0x0f9c55b1, 0x2c7925eb,
    0x36d67c9a, 0x42f831d9, 0x5e3961cb, 0x65d637a8, 0x24bb3820, 0x4d08e33d, 0x2188754f, 0x147e409e,
    0x6a9620a0, 0x62e26657, 0x7bd8ce81, 0x11da0abb, 0x5f9e7b50, 0x23e444b6, 0x25920c78, 0x5fc894f0,
    0x5e338cbb, 0x404237fd, 0x1d60f80f, 0x320a1743, 0x76013d2b, 0x070294ee, 0x695e243b, 0x56b177fd,
    0x752492e1, 0x6decd52f, 0x125f5219, 0x139d2e78, 0x1898d11e, 0x2f7ee785, 0x4db405d8, 0x1a028a35,
    0x63f6f323, 0x1f6d0078, 0x307cfd67, 0x3f32a78a, 0x6980796c, 0x462b3d83, 0x34b639f2, 0x53fce379,
    0x74ba50f4, 0x1abc2c4b, 0x5eeaeb8d, 0x335a7a0d, 0x3973dd20, 0x0462d66b, 0x159813ff, 0x1e4643fd,
    0x06bc5c62, 0x3115e3fc, 0x09101613, 0x47af2515, 0x4f11ec54, 0x78b99911, 0x3db8dd44, 0x1ec10b9b,
    0x5b5506ca, 0x773ce092, 0x567be81a, 0x5475b975, 0x7a2cde1a, 0x494536f5, 0x34737bb4, 0x76d9750b,
    0x2a1f6232, 0x2e49644d, 0x7dddcbe7, 0x500cebdb, 0x619dab9e, 0x48c626fe, 0x1cda3193, 0x52dabe9d
    };

#if !defined(NTOS_KERNEL_RUNTIME)
ULONG
RtlUniform (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    A simple uniform random number generator, based on D.H. Lehmer's 1948
    alrogithm.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    *Seed = ((Multiplier * (*Seed)) + Increment) % Modulus;
    return *Seed;
}
#endif

#define UniformMacro(Seed) (                                 \
    *Seed = (((Multiplier * (*Seed)) + Increment) % Modulus) \
    )


ULONG
RtlRandom (
    IN OUT PULONG Seed
    )

/*++

Routine Description:

    An every better random number generator based on MacLaren and Marsaglia.

Arguments:

    Seed - Supplies a pointer to the random number generator seed.

Return Value:

    ULONG - returns a random number uniformly distributed over [0..MAXLONG]

--*/

{
    ULONG X;
    ULONG Y;
    ULONG j;
    ULONG Result;

    // RTL_PAGED_CODE();

    X = UniformMacro(Seed);
    Y = UniformMacro(Seed);

    j = Y % 128;

    Result = RtlpRandomConstantVector[j];

    RtlpRandomConstantVector[j] = X;

    return Result;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\hardware\mtldr\mtldrlib\ldrreloc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

   ldrreloc.c

Abstract:

    This module contains the code to relocate an image when
    the preferred base isn't available. This is called by the
    boot loader, device driver loader, and system loader.

Author:

    Mike O'Leary (mikeol) 03-Feb-1992

Revision History:

--*/

#include "mtldrp.h"

//
// byte swapping macros (LE/BE) used for IA64 relocations
// source != destination
//

#define SWAP_SHORT(_dst,_src)                                                  \
   ((((unsigned char *)_dst)[1] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[1]))

#define SWAP_INT(_dst,_src)                                                    \
   ((((unsigned char *)_dst)[3] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[3]))

#define SWAP_LONG_LONG(_dst,_src)                                              \
   ((((unsigned char *)_dst)[7] = ((unsigned char *)_src)[0]),                 \
    (((unsigned char *)_dst)[6] = ((unsigned char *)_src)[1]),                 \
    (((unsigned char *)_dst)[5] = ((unsigned char *)_src)[2]),                 \
    (((unsigned char *)_dst)[4] = ((unsigned char *)_src)[3]),                 \
    (((unsigned char *)_dst)[3] = ((unsigned char *)_src)[4]),                 \
    (((unsigned char *)_dst)[2] = ((unsigned char *)_src)[5]),                 \
    (((unsigned char *)_dst)[1] = ((unsigned char *)_src)[6]),                 \
    (((unsigned char *)_dst)[0] = ((unsigned char *)_src)[7]))

//
// Mark a HIGHADJ entry as needing an increment if reprocessing.
//
#define LDRP_RELOCATION_INCREMENT   0x1

//
// Mark a HIGHADJ entry as not suitable for reprocessing.
//
#define LDRP_RELOCATION_FINAL       0x2

#if defined(NTOS_KERNEL_RUNTIME)
#if defined(ALLOC_PRAGMA)

ULONG
LdrDoubleRelocateImage (
    IN PVOID NewBase,
    IN PVOID CurrentBase,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    );

PIMAGE_BASE_RELOCATION
LdrpProcessVolatileRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff,
    IN LONG_PTR OldDiff,
    IN ULONG_PTR OldBase
    );

#pragma alloc_text(PAGE,LdrRelocateImage)
#pragma alloc_text(PAGE,LdrProcessRelocationBlock)
#pragma alloc_text(INIT,LdrDoubleRelocateImage)
#pragma alloc_text(INIT,LdrpProcessVolatileRelocationBlock)
#endif
#endif

ULONG
LdrRelocateImage (
    IN PVOID NewBase,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine relocates an image file that was not loaded into memory
    at the preferred address.

Arguments:

    NewBase - Supplies a pointer to the image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    NtHeaders = RtlImageNtHeader( NewBase );
    if ( NtHeaders ) {
        OldBase = NtHeaders->OptionalHeader.ImageBase;
        }
    else {
        return Invalid;
        }

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;
        Diff = (PCHAR)NewBase - (PCHAR)OldBase;
        NextBlock = LdrProcessRelocationBlock(VA,SizeOfBlock,NextOffset,Diff);

        if ( !NextBlock ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrProcessRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff
    )
{
    PUCHAR FixupVA;
    USHORT Offset;
    LONG Temp;
    ULONGLONG Value64;
    LONGLONG Temp64;

    while (SizeOfBlock--) {

       Offset = (USHORT)(*NextOffset & (USHORT)0xfff);
       FixupVA = (PUCHAR)(VA + Offset);

       //
       // Apply the fixups.
       //

       switch ((*NextOffset) >> 12) {

            case IMAGE_REL_BASED_HIGHLOW :
                //
                // HighLow - (32-bits) relocate the high and low half
                //      of an address.
                //
                *(LONG UNALIGNED *)FixupVA += (ULONG) Diff;
                break;

            case IMAGE_REL_BASED_HIGH :
                //
                // High - (16-bits) relocate the high half of an address.
                //
                Temp = *(PUSHORT)FixupVA << 16;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);
                break;

            case IMAGE_REL_BASED_HIGHADJ :
                //
                // Adjust high - (16-bits) relocate the high half of an
                //      address and adjust for sign extension of low half.
                //

#if defined(NTOS_KERNEL_RUNTIME)
                //
                // If the address has already been relocated then don't
                // process it again now or information will be lost.
                //
                if (Offset & LDRP_RELOCATION_FINAL) {
                    ++NextOffset;
                    --SizeOfBlock;
                    break;
                }
#endif

                Temp = *(PUSHORT)FixupVA << 16;
#if defined(BLDR_KERNEL_RUNTIME)
                TempOrig = Temp;
#endif
                ++NextOffset;
                --SizeOfBlock;
                Temp += (LONG)(*(PSHORT)NextOffset);
                Temp += (ULONG) Diff;
                Temp += 0x8000;
                *(PUSHORT)FixupVA = (USHORT)(Temp >> 16);

#if defined(BLDR_KERNEL_RUNTIME)
                ActualDiff = ((((ULONG_PTR)(Temp - TempOrig)) >> 16) -
                              (((ULONG_PTR)Diff) >> 16 ));

                if (ActualDiff == 1) {
                    //
                    // Mark the relocation as needing an increment if it is
                    // relocated again.
                    //
                    *(NextOffset - 1) |= LDRP_RELOCATION_INCREMENT;
                }
                else if (ActualDiff != 0) {
                    //
                    // Mark the relocation as cannot be reprocessed.
                    //
                    *(NextOffset - 1) |= LDRP_RELOCATION_FINAL;
                }
#endif

                break;

            case IMAGE_REL_BASED_LOW :
                //
                // Low - (16-bit) relocate the low half of an address.
                //
                Temp = *(PSHORT)FixupVA;
                Temp += (ULONG) Diff;
                *(PUSHORT)FixupVA = (USHORT)Temp;
                break;

            case IMAGE_REL_BASED_IA64_IMM64:

                //
                // Align it to bundle address before fixing up the
                // 64-bit immediate value of the movl instruction.
                //

                FixupVA = (PUCHAR)((ULONG_PTR)FixupVA & ~(15));
                Value64 = (ULONGLONG)0;

                //
                // Extract the lower 32 bits of IMM64 from bundle
                //


                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X,
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X,
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X,
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X,
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                EXT_IMM64(Value64,
                        (PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X,
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);

                //
                // Update 64-bit address
                //

                Value64+=Diff;

                //
                // Insert IMM64 into bundle
                //

                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM7B_INST_WORD_X),
                        EMARCH_ENC_I17_IMM7B_SIZE_X,
                        EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM7B_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM9D_INST_WORD_X),
                        EMARCH_ENC_I17_IMM9D_SIZE_X,
                        EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM9D_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM5C_INST_WORD_X),
                        EMARCH_ENC_I17_IMM5C_SIZE_X,
                        EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM5C_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IC_INST_WORD_X),
                        EMARCH_ENC_I17_IC_SIZE_X,
                        EMARCH_ENC_I17_IC_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IC_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41a_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41a_SIZE_X,
                        EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41a_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41b_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41b_SIZE_X,
                        EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41b_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_IMM41c_INST_WORD_X),
                        EMARCH_ENC_I17_IMM41c_SIZE_X,
                        EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X,
                        EMARCH_ENC_I17_IMM41c_VAL_POS_X);
                INS_IMM64(Value64,
                        ((PULONG)FixupVA + EMARCH_ENC_I17_SIGN_INST_WORD_X),
                        EMARCH_ENC_I17_SIGN_SIZE_X,
                        EMARCH_ENC_I17_SIGN_INST_WORD_POS_X,
                        EMARCH_ENC_I17_SIGN_VAL_POS_X);
                break;

            case IMAGE_REL_BASED_DIR64:

                *(ULONG_PTR UNALIGNED *)FixupVA += Diff;

                break;

            case IMAGE_REL_BASED_MIPS_JMPADDR :
                //
                // JumpAddress - (32-bits) relocate a MIPS jump address.
                //
                Temp = (*(PULONG)FixupVA & 0x3ffffff) << 2;
                Temp += (ULONG) Diff;
                *(PULONG)FixupVA = (*(PULONG)FixupVA & ~0x3ffffff) |
                                                ((Temp >> 2) & 0x3ffffff);

                break;

            case IMAGE_REL_BASED_ABSOLUTE :
                //
                // Absolute - no fixup required.
                //
                break;

            case IMAGE_REL_BASED_SECTION :
                //
                // Section Relative reloc.  Ignore for now.
                //
                break;

            case IMAGE_REL_BASED_REL32 :
                //
                // Relative intrasection. Ignore for now.
                //
                break;

           case IMAGE_REL_BASED_HIGH3ADJ :
               //
               // Similar to HIGHADJ except this is the third word.
               //  Adjust low half of high dword of an address and adjust for
               //   sign extension of the low dword.
               //

               Temp64 = *(PUSHORT)FixupVA << 16;
               ++NextOffset;
               --SizeOfBlock;
               Temp64 += (LONG)((SHORT)NextOffset[1]);
               Temp64 <<= 16;
               Temp64 += (LONG)((USHORT)NextOffset[0]);
               Temp64 += Diff;
               Temp64 += 0x8000;
               Temp64 >>=16;
               Temp64 += 0x8000;
               *(PUSHORT)FixupVA = (USHORT)(Temp64 >> 16);
               ++NextOffset;
               --SizeOfBlock;
               break;

            default :
                //
                // Illegal - illegal relocation type.
                //

                return (PIMAGE_BASE_RELOCATION)NULL;
       }
       ++NextOffset;
    }
    return (PIMAGE_BASE_RELOCATION)NextOffset;
}

#if defined(NTOS_KERNEL_RUNTIME)

ULONG
LdrDoubleRelocateImage (
    IN PVOID NewBase,
    IN PVOID CurrentBase,
    IN PUCHAR LoaderName,
    IN ULONG Success,
    IN ULONG Conflict,
    IN ULONG Invalid
    )

/*++

Routine Description:

    This routine handles the volatile relocations that cannot be easily repeated
    on an image file that has already been relocated at least once.

    Since this only needs to be done once (at kernel startup time), the
    decision was made to split this into a separate routine so as not to
    impact the mainline code.

    N.B. This function is for use by memory management ONLY.

Arguments:

    NewBase - Supplies a pointer to the new (second relocated) image base.

    CurrentBase - Supplies a pointer to the first relocated image base.

    LoaderName - Indicates which loader routine is being called from.

    Success - Value to return if relocation successful.

    Conflict - Value to return if can't relocate.

    Invalid - Value to return if relocations are invalid.

Return Value:

    Success if image is relocated.
    Conflict if image can't be relocated.
    Invalid if image contains invalid fixups.

--*/

{
    LONG_PTR Diff;
    LONG_PTR OldDiff;
    ULONG TotalCountBytes;
    ULONG_PTR VA;
    ULONG_PTR OldBase;
    ULONG SizeOfBlock;
    PUCHAR FixupVA;
    USHORT Offset;
    PUSHORT NextOffset;
    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_BASE_RELOCATION NextBlock;

    RTL_PAGED_CODE();

    NtHeaders = RtlImageNtHeader( NewBase );

    OldBase = NtHeaders->OptionalHeader.ImageBase;
    OldDiff = (PCHAR)CurrentBase - (PCHAR)OldBase;

    //
    // Locate the relocation section.
    //

    NextBlock = (PIMAGE_BASE_RELOCATION)RtlImageDirectoryEntryToData(
            NewBase, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &TotalCountBytes);

    if (!NextBlock || !TotalCountBytes) {

        //
        // The image does not contain a relocation table, and therefore
        // cannot be relocated.
        //
#if DBG
        DbgPrint("%s: Image can't be relocated, no fixup information.\n", LoaderName);
#endif // DBG
        return Conflict;
    }

    //
    // If the image has a relocation table, then apply the specified fixup
    // information to the image.
    //

    Diff = (PCHAR)NewBase - (PCHAR)OldBase;

    while (TotalCountBytes) {
        SizeOfBlock = NextBlock->SizeOfBlock;
        TotalCountBytes -= SizeOfBlock;
        SizeOfBlock -= sizeof(IMAGE_BASE_RELOCATION);
        SizeOfBlock /= sizeof(USHORT);
        NextOffset = (PUSHORT)((PCHAR)NextBlock + sizeof(IMAGE_BASE_RELOCATION));

        VA = (ULONG_PTR)NewBase + NextBlock->VirtualAddress;

        if ( !(NextBlock = LdrpProcessVolatileRelocationBlock(VA,SizeOfBlock,NextOffset,Diff, OldDiff, OldBase)) ) {
#if DBG
            DbgPrint("%s: Unknown base relocation type\n", LoaderName);
#endif
            return Invalid;
        }
    }

    return Success;
}

PIMAGE_BASE_RELOCATION
LdrpProcessVolatileRelocationBlock(
    IN ULONG_PTR VA,
    IN ULONG SizeOfBlock,
    IN PUSHORT NextOffset,
    IN LONG_PTR Diff,
    IN LONG_PTR OldDiff,
    IN ULONG_PTR OldBase
    )

/*++

Routine Description:

    This routine handles the volatile relocations that cannot be easily repeated
    on an image file that has already been relocated at least once.

    Since this only needs to be done once (at kernel startup time), the
    decision was made to spli