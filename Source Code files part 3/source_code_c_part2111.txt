tion Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonRichEditCtrl;
class CMFCRibbonSpinButtonCtrl;

class CMFCRibbonEdit : public CMFCRibbonButton
{
	friend class CMFCRibbonRichEditCtrl;

	DECLARE_DYNCREATE(CMFCRibbonEdit)

// Construction:
public:
	CMFCRibbonEdit(UINT nID, int nWidth, LPCTSTR lpszLabel = NULL, int nImage = -1);
	virtual ~CMFCRibbonEdit();

protected:
	CMFCRibbonEdit();

// Attributes:
public:
	CString GetEditText() const { return m_strEdit; };

	void SetEditText(CString strText);

	void EnableSpinButtons(int nMin, int nMax);

	void SetTextAlign(int nAlign); // ES_LEFT, ES_CENTER or ES_RIGHT
	int GetTextAlign() const { return m_nAlign; }

	int GetWidth(BOOL bInFloatyMode = FALSE) const { return bInFloatyMode ? m_nWidthFloaty : m_nWidth; }
	void SetWidth(int nWidth, BOOL bInFloatyMode = FALSE);

// Overrides
public:
	virtual BOOL HasLargeMode() const { return FALSE; }
	virtual BOOL HasCompactMode() const { return TRUE; }

	virtual CSize GetIntermediateSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC);

	virtual void Redraw();
	virtual void OnHighlight(BOOL bHighlight);
	virtual void OnSetFocus(BOOL bSet);
	virtual BOOL PreLMouseDown(CPoint point);

	virtual BOOL IsHighlighted() const { return m_bIsHighlighted || m_bIsEditFocused; }
	virtual BOOL HasFocus() const { return m_bIsEditFocused; }
	virtual BOOL HasSpinButtons() const { return m_bHasSpinButtons; }

	virtual int GetRangeMin() const { return m_nMin; }
	virtual int GetRangeMax() const { return m_nMax; }

	virtual void OnDraw(CDC* pDC);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual void OnDrawLabelAndImage(CDC* pDC);

	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint point);

	virtual void CopyFrom(const CMFCRibbonBaseElement& src);

	virtual BOOL CanBeStretched() { return FALSE; }

	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnShow(BOOL bShow);

	virtual CMFCRibbonRichEditCtrl* CreateEdit(CWnd* pWndParent, DWORD dwEditStyle);

	virtual void OnEnable(BOOL bEnable);
	virtual void DropDownList() {}
	virtual BOOL OnKey(BOOL bIsMenuKey);

	virtual void OnRTLChanged(BOOL bIsRTL);
	virtual void DestroyCtrl();

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

// Operations:
protected:
	BOOL CreateSpinButton(CMFCRibbonRichEditCtrl* pWndEdit, CWnd* pWndParent);
	void CommonInit();
	void RepositionRibbonEditCtrl();


// Attributes:
protected:
	int  m_nWidth;
	int  m_nWidthFloaty;
	int  m_nMin;
	int  m_nMax;
	int  m_nAlign;
	int  m_nLabelImageWidth;

	BOOL m_bHasDropDownList;
	BOOL m_bHasSpinButtons;
	BOOL m_bIsEditFocused;
	BOOL m_bNotifyCommand;

	CString m_strEdit;
	CMFCRibbonRichEditCtrl* m_pWndEdit;
	CMFCRibbonSpinButtonCtrl* m_pWndSpin;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonRichEditCtrl

class CMFCRibbonRichEditCtrl : public CRichEditCtrl
{
	friend class CMFCRibbonEdit;

	DECLARE_DYNAMIC(CMFCRibbonRichEditCtrl)

// Construction
public:
	CMFCRibbonRichEditCtrl(CMFCRibbonEdit& edit);

// Attributes
public:
	CMFCRibbonEdit& GetOwnerRibbonEdit()
	{
		return m_edit;
	}

protected:
	CMFCRibbonEdit& m_edit;
	BOOL m_bTracked;
	BOOL m_bIsHighlighted;
	BOOL m_bIsContextMenu;
	CString m_strOldText;

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCRibbonRichEditCtrl();

protected:
	//{{AFX_MSG(CMFCRibbonRichEditCtrl)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnPaint();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg void OnChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL ProcessClipboardAccelerators(UINT nChar);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonconstructor.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribboninfo.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonBar;

class CMFCRibbonConstructor
{
public:
	CMFCRibbonConstructor(const CMFCRibbonInfo& info);
	virtual ~CMFCRibbonConstructor();

public:
	virtual void ConstructRibbonBar(CMFCRibbonBar& bar) const;

protected:
	virtual CMFCRibbonBaseElement* CreateElement(const CMFCRibbonInfo::XElement& info) const;
	virtual CMFCRibbonPanel* CreatePanel(CMFCRibbonCategory& category, const CMFCRibbonInfo::XPanel& info) const;
	virtual CMFCRibbonCategory* CreateCategory(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategory& info) const;
	virtual CMFCRibbonCategory* CreateCategoryContext(CMFCRibbonBar& bar, const CMFCRibbonInfo::XContext& infoContext, const CMFCRibbonInfo::XCategory& info) const;
	virtual CMFCRibbonMainPanel* CreateCategoryMain(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategoryMain& info) const;
	virtual CMFCRibbonApplicationButton* CreateApplicationButton(CMFCRibbonBar& bar) const;

	virtual void SetID(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XID& info) const;
	virtual void SetIcon(CMFCRibbonButton& element, CMFCRibbonBaseElement::RibbonImageType type, const CMFCToolBarImages& images, BOOL bLargeIcon = FALSE) const;
	virtual void ConstructBaseElement(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XElement& info) const;
	virtual void ConstructElement(CMFCRibbonBaseElement& element, const CMFCRibbonInfo::XElement& info) const;
	virtual void ConstructQATElements(CMFCRibbonBar& bar, const CMFCRibbonInfo::XRibbonBar& info) const;
	virtual void ConstructTabElements(CMFCRibbonBar& bar, const CMFCRibbonInfo::XRibbonBar& info) const;
	virtual void ConstructPanel(CMFCRibbonPanel& panel, const CMFCRibbonInfo::XPanel& info) const;
	virtual void ConstructCategory(CMFCRibbonCategory& category, const CMFCRibbonInfo::XCategory& info) const;
	virtual void ConstructCategoryMain(CMFCRibbonBar& bar, const CMFCRibbonInfo::XCategoryMain& info) const;

	const CMFCRibbonInfo& GetInfo() const { return m_Info; }

private:
	const CMFCRibbonInfo&   m_Info;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboninfoloader.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribboninfo.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef RT_RIBBON
#define RT_RIBBON MAKEINTRESOURCE(28)
#endif

class CMFCRibbonInfoLoader  
{
public:
    CMFCRibbonInfoLoader(CMFCRibbonInfo& info);
    virtual ~CMFCRibbonInfoLoader();

    BOOL Load(UINT uiResID, LPCTSTR lpszResType = RT_RIBBON, HINSTANCE hInstance = NULL);
    BOOL Load(LPCTSTR lpszResID, LPCTSTR lpszResType = RT_RIBBON, HINSTANCE hInstance = NULL);

    virtual BOOL LoadFromBuffer(LPCTSTR lpszBuffer);
    virtual BOOL LoadFromBuffer(LPBYTE lpBuffer, UINT nSize);

    virtual BOOL LoadImage(CMFCRibbonInfo::XImage& image, BOOL bSingle);

protected:
    virtual BOOL LoadImage(const CMFCRibbonInfo::XID& id, CMFCToolBarImages& image, BOOL bSingle);

private:
    CMFCRibbonInfo& m_Info;
    HINSTANCE       m_hInstance;
};


#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonlabel.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonLabel : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonLabel)

// Construction:
public:
	CMFCRibbonLabel(LPCTSTR lpszText, BOOL bIsMultiLine = FALSE);
	virtual ~CMFCRibbonLabel();

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	CMFCRibbonLabel();

// Overrides
protected:
	virtual void OnDraw(CDC* pDC);
	virtual void OnCalcTextSize(CDC* pDC);
	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnLButtonUp(CPoint /*point*/) {}
	virtual CSize GetIntermediateSize(CDC* pDC);
	
	virtual CSize GetRegularSize(CDC* pDC) { return GetIntermediateSize(pDC); }
	virtual CSize GetCompactSize(CDC* pDC) { return GetIntermediateSize(pDC); }

	virtual BOOL IsTabStop() const { return FALSE; }
	virtual BOOL CanBeAddedToQuickAccessToolBar() const { return FALSE; }
	virtual int AddToListBox(CMFCRibbonCommandsListBox* /*pWndListBox*/, BOOL /*bDeep*/) { return -1; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonkeyboardcustomizedialog.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdialogex.h"
#include "afxribbonres.h"
#include "afxacceleratorkeyassignctrl.h"
#include "afxribboncommandslistbox.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonBaseElement;
class CMFCRibbonBar;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyboardCustomizeDialog dialog

class CMFCRibbonKeyboardCustomizeDialog : public CDialogEx
{
// Construction
public:
	CMFCRibbonKeyboardCustomizeDialog(CMFCRibbonBar* pRibbonBar, CWnd* pParent = NULL);   // standard constructor
	virtual ~CMFCRibbonKeyboardCustomizeDialog();

// Dialog Data
	//{{AFX_DATA(CMFCRibbonKeyboardCustomizeDialog)
	enum { IDD = IDD_AFXBARRES_RIBBON_KEYBOARD_DLG };
	CString    m_strDescription;
	CString    m_strAssignedTo;
	CStatic    m_wndAssignedToTitle;
	CStatic    m_wndViewIcon;
	CButton    m_wndRemoveButton;
	CButton    m_wndAssignButton;
	CListBox   m_wndCurrentKeysList;
	CListBox   m_wndCategoryList;
	CComboBox  m_wndViewTypeList;
	CMFCAcceleratorKeyAssignCtrl m_wndNewKey;
	CMFCRibbonCommandsListBox m_wndCommandsList;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCRibbonKeyboardCustomizeDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnAssign();
	afx_msg void OnSelchangeCategory();
	afx_msg void OnSelchangeCommandsList();
	afx_msg void OnSelchangeCurrentKeysList();
	afx_msg void OnRemove();
	afx_msg void OnResetAll();
	afx_msg void OnSelchangeViewType();
	afx_msg void OnUpdateNewShortcutKey();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Operations:
protected:
	void AddKeyEntry(LPACCEL pEntry);

// Attributes:
protected:
	HACCEL  m_hAccelTable;
	LPACCEL m_lpAccel;
	LPACCEL m_pSelEntry;
	int     m_nAccelSize;
	BOOL    m_bAutoSet;

	CFrameWnd*          m_pParentFrame;
	CMFCRibbonBar*         m_pRibbonBar;
	CMultiDocTemplate*  m_pSelTemplate;
	CMFCRibbonBaseElement* m_pSelButton;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribboninfo.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxtoolbarimages.h"
#include "afxribbonbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonInfo
{
public:
	enum XImages
	{
		e_ImagesFirst   = 0,
		e_ImagesSmall   = e_ImagesFirst,
		e_ImagesLarge   = 1,
		e_ImagesLast    = e_ImagesLarge
	};

	enum XElementType
	{
		e_TypeFirst              = -1,
		e_TypeUnknown            =  e_TypeFirst,
		e_TypeButton             =  0,
		e_TypeButton_Check       =  1,
		e_TypeButton_Color       =  2,
		e_TypeButton_Undo        =  3,
		e_TypeButton_Gallery     =  4,
		e_TypeButton_LinkCtrl    =  5,
		e_TypeButton_Application =  6,
		e_TypeButton_MainPanel   =  7,
		e_TypeButton_Launch      =  8,
		e_TypeLabel              =  9,
		e_TypeEdit               = 10,
		e_TypeComboBox           = 11,
		e_TypeComboBox_Font      = 12,
		e_TypeSlider             = 13,
		e_TypeProgress           = 14,
		e_TypeSeparator          = 15,
		e_TypeGroup              = 16,
		e_TypePanel              = 17,
		e_TypeCategory           = 18,
		e_TypeContext            = 19,
		e_TypeCategoryMain       = 20,
		e_TypeQAT                = 21,
		e_TypeRibbonBar          = 22,
		e_TypeLast               = e_TypeRibbonBar
	};

public:
	class XRibbonInfoParserCollection;

	class XInfoError
	{
	public:
		enum XError
		{
			e_ErrorFirst         = 0,
			e_ErrorNone          =  e_ErrorFirst,       // none
			e_ErrorFile          = 1,                   // parsing error, use GetDescription();
			e_ErrorInvalidRoot   = 2,                   // root element is invalid or missing
			e_ErrorInvalidHeader = 3,                   // header element is invalid or missing
			e_ErrorInvalidRibbon = 4,                   // ribbon element is invalid or missing
			e_ErrorLast          = e_ErrorInvalidRibbon
		};

	public:
		XInfoError();
		~XInfoError();

		void Empty();
		void SetError(XError error, const CString& strDescription = CString(), long nLine = -1, long nLinePos = -1);

		XError GetError() const { return m_Error; }
		const CString& GetDescription() const { return m_strDescription; }
		long GetLine() const { return m_nLine; }
		long GetLinePos() const { return m_nLinePos; }

	protected:
		XError  m_Error;
		CString m_strDescription;
		long    m_nLine;
		long    m_nLinePos;
	};

	class XRibbonInfoParser
	{
	protected:
		XRibbonInfoParser();

	public:
		virtual ~XRibbonInfoParser();

		virtual BOOL Add(const CString& strName, XRibbonInfoParser** val) = 0;

		virtual BOOL Read(const CString& strName, XRibbonInfoParser** val) = 0;
		virtual BOOL ReadCollection(const CString& strName, XRibbonInfoParserCollection** val) = 0;

		virtual BOOL ReadString(const CString& strName, CString& val) = 0;
		virtual BOOL ReadColor(const CString& strName, COLORREF& val);
		virtual BOOL ReadBool(const CString& strName, BOOL& val);
		virtual BOOL ReadSize(const CString& strName, CSize& val);
		virtual BOOL ReadInt(const CString& strName, int& val);
		virtual BOOL ReadUInt(const CString& strName, UINT& val);
		virtual BOOL ReadValue(CString& val) = 0;

		virtual BOOL WriteString(const CString& strName, const CString& val, const CString& valDefault = CString()) = 0;
		virtual BOOL WriteColor(const CString& strName, COLORREF val, COLORREF valDefault);
		virtual BOOL WriteBool(const CString& strName, BOOL val, BOOL valDefault);
		virtual BOOL WriteSize(const CString& strName, const CSize& val, const CSize& valDefault);
		virtual BOOL WriteInt(const CString& strName, int val, int valDefault);
		virtual BOOL WriteUInt(const CString& strName, UINT val, UINT valDefault);
	};

	class XRibbonInfoParserCollection
	{
	protected:
		XRibbonInfoParserCollection();

	public:
		virtual ~XRibbonInfoParserCollection();

		virtual UINT GetCount() const = 0;
		virtual XRibbonInfoParser* GetItem(UINT nIndex) = 0;
	};

	class XRibbonInfoParserRoot
	{
	protected:
		XRibbonInfoParserRoot();

	public:
		virtual ~XRibbonInfoParserRoot();

		virtual BOOL GetRoot(const CString& strName, XRibbonInfoParser** pParser) = 0;
		virtual BOOL Load(LPBYTE lpBuffer, UINT size) = 0;
		virtual BOOL Save(LPBYTE* lpBuffer, UINT& size) = 0;
	};

public:
	class XID
	{
	public:
		XID();
		~XID();

		BOOL IsEmpty() const { return m_Name.IsEmpty() && m_Value == 0; }

		BOOL Read(XRibbonInfoParser& rParser);
		BOOL Write(XRibbonInfoParser& rParser);

	public:
		CString m_Name;
		UINT    m_Value;
	};

	class XImage
	{
	public:
		XImage();
		~XImage();

		BOOL IsEmpty() const { return m_ID.IsEmpty() || !m_Image.IsValid(); }

		BOOL Read(XRibbonInfoParser& rParser);
		BOOL Write(XRibbonInfoParser& rParser);

	public:
		XID                 m_ID;
		XID                 m_ID_HDPI;
		CMFCToolBarImages   m_Image;
	};
	typedef CArray<XImage*, XImage*> XArrayImages;

	class XBase
	{
	protected:
		XBase(XElementType type);

	public:
		virtual ~XBase();

		static XBase* __stdcall CreateFromType(XElementType type);
		static XBase* __stdcall CreateFromTag(XRibbonInfoParser& rParser);

		virtual BOOL Read(XRibbonInfoParser& rParser) = 0;
		virtual BOOL Write(XRibbonInfoParser& rParser);

		XElementType GetElementType() const { return m_ElementType; }

	private:
		XElementType            m_ElementType;
	};

	class XElement: public XBase
	{
	protected:
		XElement(XElementType type);

	public:
		virtual ~XElement();

		static XElement* __stdcall CreateFromType(XElementType type);

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		XID      m_ID;
		CString  m_strText;
		CString  m_strToolTip;
		CString  m_strDescription;
		CString  m_strKeys;
		CString  m_strMenuKeys;
		BOOL     m_bIsOnPaletteTop;
		BOOL     m_bIsAlwaysLarge;
	};
	typedef CArray<XElement*, XElement*> XArrayElement;

	class XElementSeparator: public XElement
	{
	public:
		XElementSeparator();
		virtual ~XElementSeparator();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

		BOOL     m_bIsHoriz;
	};

	class XElementGroup: public XElement
	{
	public:
		XElementGroup();
		virtual ~XElementGroup();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		XImage          m_Images;
		XArrayElement   m_arButtons;
	};

	class XElementButton: public XElement
	{
	protected:
		XElementButton(XElementType type);

	public:
		XElementButton();
		virtual ~XElementButton();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		int             m_nSmallImageIndex;
		int             m_nLargeImageIndex;
		BOOL            m_bIsDefaultCommand;
		BOOL            m_bIsAlwaysShowDescription;
		XArrayElement   m_arSubItems;
	};

	class XElementLabel: public XElementButton
	{
	public:
		XElementLabel();
		virtual ~XElementLabel();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);
	};

	class XElementButtonCheck: public XElementButton
	{
	public:
		XElementButtonCheck();
		virtual ~XElementButtonCheck();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);
	};

	class XElementButtonLinkCtrl: public XElementButton
	{
	public:
		XElementButtonLinkCtrl();
		virtual ~XElementButtonLinkCtrl();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		CString  m_strLink;
	};

	class XElementEdit: public XElementButton
	{
	protected:
		XElementEdit(XElementType type);

	public:
		XElementEdit();
		virtual ~XElementEdit();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		int   m_nWidth;
		int   m_nWidthFloaty;
		BOOL  m_bHasSpinButtons;
		int   m_nMin;
		int   m_nMax;
		CString m_strValue;
	};

	class XElementComboBox: public XElementEdit
	{
	protected:
		XElementComboBox(XElementType type);

	public:
		XElementComboBox();
		virtual ~XElementComboBox();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		BOOL            m_bHasEditBox;
		BOOL            m_bHasDropDownList;
		BOOL            m_bResizeDropDownList;
		CStringArray    m_arItems;
		CString m_strValue;
	};

	class XElementFontComboBox: public XElementComboBox
	{
	public:
		XElementFontComboBox();
		virtual ~XElementFontComboBox();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		int   m_nFontType;
		BYTE  m_nCharSet;
		BYTE  m_nPitchAndFamily;
	};

	class XElementButtonGallery: public XElementButton
	{
	public:
		class XGalleryGroup
		{
		public:
			XGalleryGroup();
			~XGalleryGroup();

			BOOL Read(XRibbonInfoParser& rParser);
			BOOL Write(XRibbonInfoParser& rParser);

		public:
			CString      m_strName;
			int          m_nItems;
		};
		typedef CArray<XGalleryGroup*, XGalleryGroup*> XArrayGalleryGroup;

	protected:
		XElementButtonGallery(XElementType type);

	public:
		XElementButtonGallery();
		virtual ~XElementButtonGallery();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		BOOL               m_bIsButtonMode;
		BOOL               m_bEnableMenuResize;
		BOOL               m_bMenuResizeVertical;
		int                m_nIconsInRow;
		CSize              m_sizeIcon;
		XImage             m_Images;
		XArrayGalleryGroup m_arGroups;
	};

	class XElementButtonColor: public XElementButtonGallery
	{
	public:
		XElementButtonColor();
		virtual ~XElementButtonColor();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		COLORREF  m_clrColor;
		BOOL      m_bSimpleButtonLook;

		CString   m_strAutomaticBtnLabel;
		CString   m_strAutomaticBtnToolTip;
		COLORREF  m_clrAutomaticBtnColor;
		BOOL      m_bAutomaticBtnOnTop;
		BOOL      m_bAutomaticBtnBorder;

		CString   m_strOtherBtnLabel;
		CString   m_strOtherBtnToolTip;
	};

	class XElementButtonUndo: public XElementButtonGallery
	{
	public:
		XElementButtonUndo();
		virtual ~XElementButtonUndo();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);
	};

	class XElementButtonLaunch: public XElementButton
	{
	public:
		XElementButtonLaunch();
		virtual ~XElementButtonLaunch();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);
	};

	class XElementButtonApplication: public XElementButton
	{
	public:
		XElementButtonApplication();
		virtual ~XElementButtonApplication();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		XImage  m_Image;
	};

	class XElementButtonMainPanel: public XElementButton
	{
	public:
		XElementButtonMainPanel();
		virtual ~XElementButtonMainPanel();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);
	};

	class XElementSlider: public XElement
	{
	public:
		XElementSlider();
		virtual ~XElementSlider();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		DWORD  m_dwStyle;
		int    m_nWidth;
		int    m_nMin;
		int    m_nMax;
		int    m_nPos;
		BOOL   m_bZoomButtons;
	};

	class XElementProgressBar: public XElement
	{
	public:
		XElementProgressBar();
		virtual ~XElementProgressBar();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		int    m_nWidth;
		int    m_nHeight;
		int    m_nMin;
		int    m_nMax;
		int    m_nPos;
		BOOL   m_bInfinite;
	};

	class XPanel: public XBase
	{
	public:
		XPanel();
		virtual ~XPanel();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		CString              m_strName;
		CString              m_strKeys;
		int                  m_nImageIndex;
		BOOL                 m_bJustifyColumns;
		BOOL                 m_bCenterColumnVert;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
		XElementButtonLaunch m_btnLaunch;
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
		XArrayElement        m_arElements;
	};
	typedef CArray<XPanel*, XPanel*> XArrayPanel;

	class XCategory: public XBase
	{
	public:
		XCategory();
		virtual ~XCategory();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		CString        m_strName;
		CString        m_strKeys;
		XImage         m_SmallImages;
		XImage         m_LargeImages;
		XArrayPanel    m_arPanels;
		XArrayElement  m_arElements;
	};
	typedef CArray<XCategory*, XCategory*> XArrayCategory;

	class XContext: public XBase
	{
	public:
		XContext();
		virtual ~XContext();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		XID                     m_ID;
		CString                 m_strText;
		AFX_RibbonCategoryColor m_Color;
		XArrayCategory          m_arCategories;
	};
	typedef CArray<XContext*, XContext*> XArrayContext;

	class XCategoryMain: public XBase
	{
	public:
		XCategoryMain();
		virtual ~XCategoryMain();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		CString        m_strName;
		XImage         m_SmallImages;
		XImage         m_LargeImages;
		XArrayElement  m_arElements;
		BOOL           m_bRecentListEnable;
		CString        m_strRecentListLabel;
		int            m_nRecentListWidth;
	};

	class XQAT: public XBase
	{
	public:
		class XQATItem
		{
		public:
			XQATItem();
			~XQATItem();

			BOOL Read(XRibbonInfoParser& rParser);
			BOOL Write(XRibbonInfoParser& rParser);

		public:
			XID     m_ID;
			BOOL    m_bVisible;
		};
		typedef CArray<XQATItem, XQATItem> XArrayQATItem;

	public:
		XQAT();
		virtual ~XQAT();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

		INT_PTR AddItem(const XQATItem& rItem);

	public:
		XArrayQATItem   m_arItems;
		BOOL            m_bOnTop;
	};

	class XRibbonBar: public XBase
	{
	public:
		XRibbonBar();
		virtual ~XRibbonBar();

		virtual BOOL Read(XRibbonInfoParser& rParser);
		virtual BOOL Write(XRibbonInfoParser& rParser);

	public:
		BOOL  m_bToolTip;
		BOOL  m_bToolTipDescr;
		BOOL  m_bKeyTips;
		BOOL  m_bPrintPreview;
		BOOL  m_bDrawUsingFont;

		XImage          m_Images;
		XCategoryMain*  m_MainCategory;
		XQAT            m_QAT;
		XElementGroup   m_TabElements;
		XArrayCategory  m_arCategories;
		XArrayContext   m_arContexts;

		XElementButtonApplication*  m_btnMain;
	};

public:
	CMFCRibbonInfo();
	virtual ~CMFCRibbonInfo();

	static LPCTSTR __stdcall ElementNameFromType(XElementType type);
	static XElementType __stdcall ElementTypeFromName(const CString& name);

	virtual BOOL Read(IStream* pStream);
	virtual BOOL Read(LPBYTE lpBuffer, UINT nSize);
	virtual BOOL Write(IStream* pStream);
	virtual BOOL Write(LPBYTE* lpBuffer, UINT& nSize);

	void GetArrayImages(XArrayImages& images);

	CSize& GetImageSize(XImages image)
	{
		ASSERT(e_ImagesFirst <= image && image <= e_ImagesLast);

		return m_sizeImage[image];
	}
	const CSize& GetImageSize(XImages image) const
	{
		ASSERT(e_ImagesFirst <= image && image <= e_ImagesLast);

		return m_sizeImage[image];
	}

	DWORD GetVersion() const { return m_dwVersion; }
	XRibbonBar& GetRibbonBar() { return m_RibbonBar; }
	const XRibbonBar& GetRibbonBar() const { return m_RibbonBar; }

	const XInfoError& GetError() const { return m_Error; };

protected:
	virtual BOOL Read(XRibbonInfoParser& rParser);
	virtual BOOL Write(XRibbonInfoParser& rParser);

	void AddElementImages(XElement& info, XArrayImages& images);

private:
	CSize       m_sizeImage[e_ImagesLast + 1];
	XRibbonBar  m_RibbonBar;
	DWORD       m_dwVersion;
	XInfoError  m_Error;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonkeytip.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonKeyTip window

class CMFCRibbonBaseElement;

class CMFCRibbonKeyTip : public CWnd
{
// Construction
public:
	CMFCRibbonKeyTip(CMFCRibbonBaseElement* pElement, BOOL bIsMenu = FALSE);

// Attributes
public:
	CMFCRibbonBaseElement* GetElement() const { return m_pElement; }
	BOOL IsMenuKey() const { return m_bIsMenu; }

protected:
	CMFCRibbonBaseElement* m_pElement;
	CRect m_rectScreen;
	BOOL  m_bIsMenu;

	AFX_IMPORT_DATA static CString m_strClassName;

// Operations
public:
	BOOL Show(BOOL bRepos);
	void Hide();

protected:
	void UpdateMenuShadow();

// Implementation
public:
	virtual ~CMFCRibbonKeyTip();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCRibbonKeyTip)
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDestroy();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonlinkctrl.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonLinkCtrl : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonLinkCtrl)

// Construction:
public:
	CMFCRibbonLinkCtrl();
	CMFCRibbonLinkCtrl(UINT nID, LPCTSTR lpszText, LPCTSTR lpszLink);

	virtual ~CMFCRibbonLinkCtrl();

// Operations:
public:
	BOOL OpenLink();

// Overrides
public:
	virtual CSize GetRegularSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC);
	virtual void OnDraw(CDC* pDC);
	virtual BOOL OnDrawMenuImage(CDC* /*pDC*/, CRect /*rect*/) { return FALSE; }
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual CString GetToolTipText() const { return GetLink(); }

	virtual void OnMouseMove(CPoint point);

	virtual void OnSetIcon();
	virtual BOOL IsDrawTooltipImage() const { return FALSE; }
	
	LPCTSTR GetLink() const { return m_strLink; }
	void SetLink(LPCTSTR lpszLink);

// Attributes:
protected:
	CString m_strLink;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonmainpanel.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonpanel.h"
#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonMainPanelButton;

class CMFCRibbonMainPanel : public CMFCRibbonPanel
{
	friend class CMFCRibbonApplicationButton;
	friend class CMFCRibbonCollector;

	DECLARE_DYNCREATE(CMFCRibbonMainPanel)

// Construction
public:
	CMFCRibbonMainPanel();
	virtual ~CMFCRibbonMainPanel();

// Operations
public:
	virtual void Add(CMFCRibbonBaseElement* pElem);
	void AddToBottom(CMFCRibbonMainPanelButton* pElem);

	void AddRecentFilesList(LPCTSTR lpszLabel, int nWidth = 300);
	void AddToRight(CMFCRibbonBaseElement* pElem, int nWidth = 300);

protected:
	int GetMenuElements() const;
	void DrawApplicationButton(CDC* pDC, CWnd* pWnd);

// Overrides
protected:

	virtual void RecalcWidths(CDC* pDC, int nHeight);
	virtual void Reposition(CDC* pDC, const CRect& rect);
	virtual void DoPaint(CDC* pDC);

	virtual BOOL IsFixedSize() const { return TRUE; }

	virtual void CopyFrom(CMFCRibbonPanel& src);
	virtual BOOL GetPreferedMenuLocation(CRect& rect);

	virtual BOOL IsMainPanel() const { return TRUE; }

	virtual void OnDrawMenuBorder(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar);
	virtual CMFCRibbonBaseElement* MouseButtonDown(CPoint point);

// Attributes:
public:
	CRect GetCommandsFrame() const;

protected:
	int   m_nBottomElementsNum;
	int   m_nTopMargin;
	int   m_nRightPaneWidth;
	CRect m_rectMenuElements;

	CMFCRibbonApplicationButton*  m_pMainButton;
	CMFCRibbonBaseElement* m_pElemOnRight;
};

class CMFCRibbonMainPanelButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonMainPanelButton)

// Construction
public:
	CMFCRibbonMainPanelButton();

	CMFCRibbonMainPanelButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex);
	CMFCRibbonMainPanelButton(UINT nID, LPCTSTR lpszText, HICON hIcon);

	virtual ~CMFCRibbonMainPanelButton();

// Overrides
protected:
	virtual COLORREF OnFillBackground(CDC* pDC);
	virtual void OnDrawBorder(CDC* pDC);
};

class CMFCRibbonRecentFilesList : public CMFCRibbonButtonsGroup
{
	DECLARE_DYNCREATE(CMFCRibbonRecentFilesList)

public:
	CMFCRibbonRecentFilesList(LPCTSTR lpszLabel = NULL)
	{
		SetText(lpszLabel == NULL ? _T("") : lpszLabel);
	}

	void FillList();

protected:
	virtual void OnAfterChangeRect(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual void OnDraw(CDC* pDC);
	virtual BOOL OnMenuKey(UINT nUpperChar);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonminitoolbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonpanelmenu.h"
#include "afxribbonpanel.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonMiniToolBar window

class CMFCRibbonMiniToolBar : public CMFCRibbonPanelMenu
{
	DECLARE_DYNCREATE(CMFCRibbonMiniToolBar)

	friend class CMFCPopupMenu;

// Construction
public:
	CMFCRibbonMiniToolBar();

// Attributes
public:
	BOOL IsContextMenuMode() const { return m_bContextMenuMode; }

protected:
	AFX_IMPORT_DATA static CMFCRibbonMiniToolBar* m_pCurrent;

	BOOL m_bContextMenuMode;
	BYTE m_nTransparency;
	BOOL m_bWasHovered;
	BOOL m_bWasDroppedDown;

// Operations
public:
	void SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands);

	BOOL Show(int x, int y);
	BOOL ShowWithContextMenu(int x, int y, UINT uiMenuResID, CWnd* pWndOwner);

// Overrides
	virtual BOOL IsRibbonMiniToolBar() const { return TRUE; }

// Implementation
public:
	virtual ~CMFCRibbonMiniToolBar();

protected:
	//{{AFX_MSG(CMFCRibbonMiniToolBar)
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL UpdateTransparency();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonpanelmenu.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpopupmenu.h"
#include "afxpopupmenubar.h"
#include "afxribbonpanel.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonButton;
class CMFCRibbonGallery;
class CMFCRibbonCategory;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonPanelMenuBar window

class CMFCRibbonPanelMenuBar : public CMFCPopupMenuBar
{
	DECLARE_DYNAMIC(CMFCRibbonPanelMenuBar)

	friend class CMFCRibbonBaseElement;
	friend class CMFCRibbonPanelMenu;
	friend class CMFCRibbonMiniToolBar;
	friend class CMFCRibbonQuickAccessCustomizeButton;

// Construction
public:
	CMFCRibbonPanelMenuBar(CMFCRibbonPanel* pPanel);
	CMFCRibbonPanelMenuBar(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons, BOOL bIsFloatyMode = FALSE);
	CMFCRibbonPanelMenuBar(CMFCRibbonGallery* pPaletteButton);
	CMFCRibbonPanelMenuBar(CMFCRibbonCategory* pCategory, CSize size);

protected:
	CMFCRibbonPanelMenuBar();
	void CommonInit();

// Attributes
public:
	CMFCRibbonBar* GetTopLevelRibbonBar() const;
	CMFCRibbonPanel* GetPanel() { return m_pPanel; }
	CMFCRibbonCategory* GetCategory() { return m_pCategory; }

	void SetMenuMode(BOOL bIsMenuMode = TRUE) { m_bIsMenuMode = bIsMenuMode; }
	BOOL IsMenuMode() const { return m_bIsMenuMode; }

	void SetDefaultMenuLook(BOOL bIsDefaultMenuLook = TRUE) { m_bIsDefaultMenuLook = bIsDefaultMenuLook; }
	BOOL IsDefaultMenuLook() const { return m_bIsDefaultMenuLook; }

	BOOL IsMainPanel() const { return m_pPanel != NULL && m_pPanel->IsMainPanel(); }
	BOOL IsQATPopup() const { return m_bIsQATPopup; }
	BOOL IsRibbonMiniToolBar() const { return m_bIsFloaty; }
	BOOL IsCategoryPopup() const { return m_pCategory != NULL; }

	CMFCRibbonButton* GetDroppedDown() const;
	CMFCRibbonBaseElement* HitTest(CPoint point) const;
	int HitTestEx(CPoint point) const;
	/// <summary>
	/// Returns a focused element. </summary>
	/// <returns> A pointer to a focused element or NULL.</returns>
	CMFCRibbonBaseElement* GetFocused() const;

protected:
	BOOL m_bTracked;
	BOOL m_bSimpleMode;
	BOOL m_bIsMenuMode;
	BOOL m_bIsDefaultMenuLook;
	BOOL m_bIsQATPopup;
	BOOL m_bCustomizeMenu;
	BOOL m_bIsFloaty;
	BOOL m_bHasKeyTips;
	BOOL m_bSetKeyTips;
	BOOL m_bAutoCommandTimer;

	CSize  m_sizePrefered;
	CSize  m_sizeCategory;
	CRect  m_rectAutoCommand;
	CPoint m_ptStartMenu;

	CScrollBar          m_wndScrollBarVert;
	CMFCRibbonBar*         m_pRibbonBar;
	CMFCRibbonPanel*       m_pPanel;
	CMFCRibbonPanel*       m_pPanelOrigin;
	CMFCRibbonButton*      m_pDelayedCloseButton;
	CMFCRibbonButton*      m_pDelayedButton;
	CMFCRibbonCategory*    m_pCategory;
	CMFCRibbonBaseElement* m_pPressed;

// Operations
public:
	void PopTooltip();
	void SetActive(BOOL bIsActive);

	CMFCRibbonBaseElement* FindByOrigin(CMFCRibbonBaseElement* pOrigin) const;

// Overrides
	virtual void OnClickButton(CMFCRibbonButton* pButton, CPoint point);
	virtual void OnChangeHighlighted(CMFCRibbonBaseElement* pHighlighted);

	virtual void AdjustLocations();
	virtual CSize CalcSize(BOOL bVertDock);
	virtual void DoPaint(CDC* pDC);

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void CloseDelayedSubMenu();
	virtual void RestoreDelayedSubMenu();

	virtual BOOL OnKey(UINT nChar);
	virtual BOOL OnSetAccData(long lVal);

	virtual BOOL IsRibbonPanel() const { return TRUE; }
	virtual BOOL IsRibbonPanelInRegularMode() const { return !m_bIsMenuMode && !IsMainPanel(); }

protected:
	virtual void OnDrawMenuBorder(CDC* pDC);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCRibbonPanelMenuBar();

protected:
	//{{AFX_MSG(CMFCRibbonPanelMenuBar)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void AddButtons(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>&	arButtons, BOOL bFloatyMode);
	void SetPreferedSize(CSize size);
};

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonPanelMenu window

class CMFCRibbonPanelMenu : public CMFCPopupMenu
{
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonPanel;

	DECLARE_DYNAMIC(CMFCRibbonPanelMenu)

// Construction
public:
	CMFCRibbonPanelMenu(CMFCRibbonPanel* pPanel);
	CMFCRibbonPanelMenu(CMFCRibbonBar* pRibbonBar, const CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons, BOOL bIsFloatyMode = FALSE);
	CMFCRibbonPanelMenu(CMFCRibbonGallery* pPaletteButton);
	CMFCRibbonPanelMenu(CMFCRibbonCategory* pCategory, CSize size);

protected:
	CMFCRibbonPanelMenu();

// Attributes
public:
	void SetMenuMode(BOOL bIsMenuMode = TRUE) { m_wndRibbonBar.SetMenuMode(bIsMenuMode); }
	BOOL IsMenuMode() const { return m_wndRibbonBar.IsMenuMode(); }

	void SetDefaultMenuLook(BOOL bIsDefaultMenuLook = TRUE) { m_wndRibbonBar.SetDefaultMenuLook(bIsDefaultMenuLook); }
	BOOL IsDefaultMenuLook() const { return m_wndRibbonBar.IsDefaultMenuLook(); }

	CMFCRibbonPanel* GetPanel() const { return m_wndRibbonBar.m_pPanel; }
	CMFCRibbonCategory* GetCategory() const { return m_wndRibbonBar.m_pCategory; }
	void SetPreferedSize(CSize size) { m_wndRibbonBar.SetPreferedSize(size); }

	CMFCRibbonPanelMenuBar* GetParentRibbonMenuBar() const;

	void EnableCustomizeMenu(BOOL bEnable = TRUE) { m_wndRibbonBar.m_bCustomizeMenu = bEnable; }
	BOOL IsCustomizeMenu() const { return m_wndRibbonBar.m_bCustomizeMenu; }

protected:
	CMFCRibbonPanelMenuBar	m_wndRibbonBar;
	BOOL				m_bForceClose;

// Operations
public:
	virtual void SetActive(BOOL /*bIsActive*/) {}

	virtual CMFCPopupMenuBar* GetMenuBar() { return &m_wndRibbonBar; }

	virtual BOOL IsAlwaysClose() const;

	CMFCRibbonBaseElement* FindByOrigin(CMFCRibbonBaseElement* pOrigin) const { return m_wndRibbonBar.FindByOrigin(pOrigin); }

	virtual BOOL IsScrollUpAvailable();
	virtual BOOL IsScrollDnAvailable();

	virtual BOOL DefaultMouseClickOnClose() const { return m_wndRibbonBar.IsRibbonMiniToolBar() && !m_wndRibbonBar.IsQATPopup(); }

protected:
	virtual void DoPaint(CDC* pPaintDC);
	virtual int GetBorderSize() const;

// Implementation
public:
	virtual ~CMFCRibbonPanelMenu();

protected:
	//{{AFX_MSG(CMFCRibbonPanelMenu)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonpalettegallery.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonbutton.h"
#include "afxtoolbarimages.h"
#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonGalleryIcon;
class CMFCPopupMenu;

class CMFCRibbonGallery : public CMFCRibbonButton
{
	friend class CMFCRibbonGalleryIcon;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonGalleryMenuButton;
	friend class CMFCRibbonCollector;
	friend class CMFCRibbonConstructor;

	DECLARE_DYNCREATE(CMFCRibbonGallery)

// Construction
public:
	CMFCRibbonGallery();
	CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, CMFCToolBarImages& imagesPalette);
	CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, UINT uiImagesPaletteResID = 0, int cxPaletteImage = 0);

	// Owner-draw icons constructor:
	CMFCRibbonGallery(UINT nID, LPCTSTR lpszText, int nSmallImageIndex, int nLargeImageIndex, CSize sizeIcon,
		int nIconsNum,					// If 0 - you should call AddGroup later
		BOOL bDefaultButtonStyle = TRUE);// If FALSE - you need to implement your own border/content drawing

	virtual ~CMFCRibbonGallery();

// Attributes
public:
	void SetPaletteID(UINT nID) { m_nPaletteID = nID; }
	int GetPaletteID() const { return m_nPaletteID; }

	void SetButtonMode(BOOL bSet = TRUE) { m_bIsButtonMode = bSet; }
	BOOL IsButtonMode() const { return m_bIsButtonMode; }

	void SelectItem(int nItemIndex);
	int GetSelectedItem() const { return m_nSelected; }

	void EnableMenuResize(BOOL bEnable = TRUE, BOOL bVerticalOnly = FALSE)
	{
		m_bEnableMenuResize = bEnable;
		m_bMenuResizeVertical = bVerticalOnly;
	}

	BOOL IsMenuResizeEnabled() const { return m_bEnableMenuResize; }
	BOOL IsMenuResizeVertical() const { return m_bMenuResizeVertical; }

	void SetIconsInRow(int nIconsInRow) { m_nIconsInRow = nIconsInRow; }
	int GetIconsInRow() const { return m_nIconsInRow; }

	void SetItemToolTip(int nItemIndex, LPCTSTR lpszToolTip);
	LPCTSTR GetItemToolTip(int nItemIndex) const;
	void RemoveItemToolTips();

	static int __stdcall GetLastSelectedItem(UINT uiCmdID);

	BOOL IsMenuSideBar() const { return m_bMenuSideBar; }
	void EnableMenuSideBar(BOOL bEnable = TRUE) { m_bMenuSideBar = bEnable; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data)
	{
		CMFCRibbonButton::SetACCData(pParent, data);
		data.m_nAccRole = IsCommandAreaHighlighted() ? ROLE_SYSTEM_SPLITBUTTON : ROLE_SYSTEM_BUTTONDROPDOWNGRID;
		return TRUE;
	}

// Operations:
public:
	void AddGroup(LPCTSTR lpszGroupName, UINT uiImagesPaletteResID, int cxPaletteImage);
	void AddGroup(LPCTSTR lpszGroupName, CMFCToolBarImages& imagesGroup);

	// For user-defined icons only!
	void AddGroup(LPCTSTR lpszGroupName, int nIconsNum);

	void SetGroupName(int nGroupIndex, LPCTSTR lpszGroupName);
	LPCTSTR GetGroupName(int nGroupIndex) const;

	void SetPalette(CMFCToolBarImages& imagesPalette);
	void SetPalette(UINT uiImagesPaletteResID, int cxPaletteImage);

	virtual void Clear();
	void RedrawIcons();

	void AddSubItem(CMFCRibbonBaseElement* pSubItem, int nIndex = -1, BOOL bOnTop = FALSE);

protected:
	void CommonInit();
	void CreateIcons();
	void RemoveAll();
	void RebuildIconLocations();
	
	BOOL IsButtonLook() const
	{
		return	m_bQuickAccessMode || m_bFloatyMode || m_bIsButtonMode || m_bIsCollapsed || m_pParentGroup != NULL || m_nIcons == 0;
	}

	virtual void OnClickPaletteIcon(CMFCRibbonGalleryIcon* pIcon);
	void GetMenuItems(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arButtons);

	virtual CMFCRibbonBaseElement* HitTest(CPoint point);
	virtual CMFCRibbonBaseElement* GetPressed();
	virtual CMFCRibbonBaseElement* GetHighlighted();

	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void SetParentCategory(CMFCRibbonCategory* pParent);

	virtual void OnShowPopupMenu();

	int GetMenuRowHeight() const;

	virtual UINT GetNotifyID()
	{
		if (m_bNotifyPaletteID)
		{
			SetNotifyParentID(FALSE);
			return m_nPaletteID;
		}
		else
		{
			return m_nID;
		}
	}

	virtual BOOL OnKey(BOOL bIsMenuKey);
	virtual CRect GetKeyTipRect(CDC* pDC, BOOL bIsMenu);

	virtual CSize GetIconSize() const;

	virtual CString GetIconToolTip(const CMFCRibbonGalleryIcon* pIcon) const;
	virtual CString GetIconDescription(const CMFCRibbonGalleryIcon* pIcon) const;

	virtual BOOL CanBeStretchedHorizontally()
	{
		return !IsButtonMode() && !m_bIsCollapsed;
	}

	virtual void SetInitialMode(BOOL bOneRow = FALSE)
	{
		CMFCRibbonButton::SetInitialMode(bOneRow);

		m_bResetColumns = TRUE;
		m_bIsCollapsed = FALSE;
	}

	virtual void StretchHorizontally()
	{
		if (m_bSmallIcons || m_nPanelColumns <= 3)
		{
			m_bIsCollapsed = TRUE;
		}
		else
		{
			m_nPanelColumns--;
		}
	}

	virtual BOOL OnClickPaletteSubItem(CMFCRibbonButton* /*pButton*/, CMFCRibbonPanelMenuBar* /*pMenuBar*/) { return FALSE; }
	virtual BOOL IsItemMenuLook() const { return FALSE; }

// Overrides
public:
	virtual void OnDraw(CDC* pDC);

	virtual CSize GetRegularSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC);

	virtual void OnAfterChangeRect(CDC* pDC);

	virtual BOOL HasMenu() const { return m_nIcons > 0; }

	virtual CMFCRibbonBaseElement* GetDroppedDown();
	virtual void OnEnable(BOOL bEnable);

	virtual void OnRTLChanged(BOOL bIsRTL);

	virtual int GetGroupOffset() const { return 0; }

	virtual void OnSetFocus(BOOL bSet);

protected:
	virtual void OnDrawPaletteIcon(CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* pIcon, COLORREF clrText);

// Attributes
protected:
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arIcons;

	CStringArray    m_arGroupNames;
	CArray<int,int> m_arGroupLen;
	CMFCToolBarImages  m_imagesPalette;
	CStringArray    m_arToolTips;

	UINT m_nPaletteID;

	int m_nImagesInRow;
	int m_nPanelColumns;
	int m_nImagesInColumn;
	int m_nScrollOffset;
	int m_nScrollTotal;
	int m_nSelected;
	int m_nIconsInRow;
	int m_nIcons;

	BOOL m_bIsButtonMode;
	BOOL m_bNotifyPaletteID;
	BOOL m_bSmallIcons;
	BOOL m_bEnableMenuResize;
	BOOL m_bMenuResizeVertical;
	BOOL m_bIsOwnerDraw;
	BOOL m_bDefaultButtonStyle;
	BOOL m_bMenuSideBar;
	BOOL m_bIsCollapsed;
	BOOL m_bResetColumns;

	AFX_IMPORT_DATA static CMap<UINT,UINT,int,int> m_mapSelectedItems;

	void SetNotifyParentID(BOOL bSet);
};

////////////////////////////////////////////
// CMFCRibbonGalleryIcon

class CMFCRibbonGalleryIcon : public CMFCRibbonButton
{
	friend class CMFCRibbonGallery;
	friend class CMFCRibbonPanel;
	friend class CMFCRibbonUndoButton;

	DECLARE_DYNCREATE(CMFCRibbonGalleryIcon)

public:
	CMFCRibbonGalleryIcon(CMFCRibbonGallery* pOwner = NULL,
		int nIndex = 0);

public:
	BOOL IsFirst() const;
	BOOL IsLast() const;

	int GetIndex() const { return m_nIndex; }

	BOOL IsFirstInRow() const { return m_bIsFirstInRow; }
	BOOL IsLastInRow() const { return m_bIsLastInRow; }

	BOOL IsFirstInColumn() const { return m_bIsFirstInColumn; }
	BOOL IsLastInColumn() const { return m_bIsLastInColumn; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	virtual void OnDraw(CDC* pDC);
	virtual void OnClick(CPoint point);
	virtual void OnLButtonDown(CPoint point);
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual CSize GetCompactSize(CDC* pDC);
	virtual BOOL IsAutoRepeatMode(int& nDelay /* ms */) const;
	virtual BOOL OnAutoRepeat();
	virtual BOOL CanBeAddedToQuickAccessToolBar() const { return TRUE; }
	virtual BOOL OnAddToQAToolbar(CMFCRibbonQuickAccessToolBar& qat);

	virtual UINT GetQuickAccessToolBarID() const
	{
		if (m_pOwner != NULL)
		{
			ASSERT_VALID(m_pOwner);
			return m_pOwner->GetID();
		}

		return m_nID;
	}

	virtual CString GetToolTipText() const;
	virtual CString GetDescription() const;
	virtual void OnHighlight(BOOL bHighlight);

	virtual CWnd* GetParentWnd() const
	{
		ASSERT_VALID(this);

		if (m_pOwner != NULL)
		{
			ASSERT_VALID(m_pOwner);
			return m_pOwner->GetParentWnd();
		}

		return CMFCRibbonButton::GetParentWnd();
	}

	virtual BOOL IsGalleryIcon() const
	{
		ASSERT_VALID(this);

		if (m_pOwner != NULL)
		{
			ASSERT_VALID(m_pOwner);
			return !m_pOwner->IsItemMenuLook();
		}

		return TRUE;
	}

	CMFCRibbonGallery*	m_pOwner;

	int  m_nIndex;
	BOOL m_bIsFirstInRow;
	BOOL m_bIsLastInRow;
	BOOL m_bIsFirstInColumn;
	BOOL m_bIsLastInColumn;
};

////////////////////////////////////////////////
// CMFCRibbonGalleryMenuButton

class CMFCRibbonGalleryMenuButton : public CMFCToolBarMenuButton
{
	DECLARE_DYNCREATE(CMFCRibbonGalleryMenuButton)

// Construction
protected:
	CMFCRibbonGalleryMenuButton();

public:
	CMFCRibbonGalleryMenuButton(UINT uiID, int iImage, LPCTSTR lpszText, CMFCToolBarImages& imagesPalette);
	CMFCRibbonGalleryMenuButton(UINT uiID, int iImage, LPCTSTR lpszText, UINT uiImagesPaletteResID = 0, int cxPaletteImage = 0);

	virtual ~CMFCRibbonGalleryMenuButton();

protected:
	void CommonInit();

// Attributes:
public:
	CMFCRibbonGallery& GetPalette() { return m_paletteButton; }

protected:
	CMFCRibbonGallery m_paletteButton;

// Overrides:
public:
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual CMFCPopupMenu* CreatePopupMenu();
	virtual BOOL IsEmptyMenuAllowed() const { return TRUE; }
	virtual BOOL HasButton() const { return TRUE; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonslider.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbaseribbonelement.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonSlider : public CMFCRibbonBaseElement
{
	DECLARE_DYNCREATE(CMFCRibbonSlider)

// Construction
public:
	CMFCRibbonSlider();
	CMFCRibbonSlider(UINT nID, int nWidth = 100);

	virtual ~CMFCRibbonSlider();

// Attributes
public:
	void SetRange(int nMin, int nMax);

	int GetRangeMin() const { return m_nMin; }
	int GetRangeMax() const { return m_nMax; }

	int GetWidth() const { return m_nWidth; }

	void SetPos(int nPos, BOOL bRedraw = TRUE);

	int GetPos() const { return m_nPos; }

	int GetZoomIncrement() const { return m_nZoomIncrement; }
	void SetZoomIncrement(int nZoomIncrement);

	void SetZoomButtons(BOOL bSet = TRUE);
	BOOL HasZoomButtons() const { return m_bZoomButtons; }

// Operations
protected:
	void CommonInit();
	void SetThumbRect();
	int GetPosFromPoint(int x);
	int GetHitTest(CPoint point) const;

	void NotifyCommand();

// Overrides
public:
	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);

protected:
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnAfterChangeRect(CDC* pDC);

	virtual void OnLButtonDown(CPoint point);
	virtual void OnLButtonUp(CPoint point);
	virtual void OnMouseMove(CPoint point);

	virtual BOOL IsAutoRepeatMode(int& nDelay /* ms */) const;
	virtual BOOL OnAutoRepeat();

	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

// Attributes
protected:
	int  m_nMin;
	int  m_nMax;
	int  m_nPos;
	int  m_nZoomIncrement;
	int  m_nWidth;
	int  m_nHighlighted;	// -1 - none, 0 - thumb, 1 -Zoom In, 2 - Zoom Out
	int  m_nPressed;		// -1 - none, 0 - thumb, 1 -Zoom In, 2 - Zoom Out
	BOOL m_bZoomButtons;

	CRect m_rectZoomOut;
	CRect m_rectZoomIn;
	CRect m_rectSlider;
	CRect m_rectThumb;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRIBBONRES_H__
#define __AFXRIBBONRES_H__

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define IDP_AFXBARRES_IMAGE_IS_REQUIRED 16001
#define IDP_AFXBARRES_TEXT_IS_REQUIRED  16002
#define IDC_AFXBARRES_CLEAR             16003
#define IDP_AFXBARRES_CANNT_CREATE_IMAGE 16003
#define IDC_AFXBARRES_COPY              16004
#define IDP_AFXBARRES_CANT_PASTE_BITMAP 16004
#define IDC_AFXBARRES_PASTE             16005
#define IDS_AFXBARRES_WRONG_IMAGE_SIZE  16005
#define IDS_AFXBARRES_MENU_BAR_TITLE    16006
#define IDS_AFXBARRES_NO_MENUBAR        16007
#define IDP_AFXBARRES_INTERLAL_ERROR    16008
#define IDP_AFXBARRES_UNASSIGNED        16009
#define IDP_AFXBARRES_CANT_COPY_BITMAP  16010
#define IDS_AFXBARRES_HIDE_BAR          16011
#define IDS_AFXBARRES_EXPAND_BAR        16012
#define IDS_AFXBARRES_CONTRACT_BAR      16013
#define IDS_AFXBARRES_NEW_MENU          16014
#define IDS_AFXBARRES_FILE              16015
#define IDS_AFXBARRES_FOLDER            16016
#define IDS_AFXBARRES_NEW               16017
#define IDS_AFXBARRES_EXISTING          16018
#define IDS_AFXBARRES_RECENT            16019
#define IDS_AFXBARRES_DELETE            16020
#define IDS_AFXBARRES_MOVEUP            16021
#define IDS_AFXBARRES_MOVEDN            16022
#define IDS_AFXBARRES_CMD_FILTER        16023
#define IDS_AFXBARRES_TOO_MANY_TOOLS_FMT 16024
#define IDS_AFXBARRES_EXPAND_FMT        16025
#define IDS_AFXBARRES_MORE_BUTTONS      16026
#define IDS_AFXBARRES_NEW_FILE          16027
#define IDS_AFX_TEAR_OFF                16028
#define IDS_AFXBARRES_COMMAND           16029
#define IDS_AFXBARRES_KEYS              16030
#define IDS_AFXBARRES_DESCRIPTION       16031
#define IDS_AFXBARRES_CLOSEBAR          16032
#define IDS_AFXBARRES_AUTOHIDEBAR       16033
#define IDP_AFXBARRES_SCROLL_LEFT       16034
#define IDP_AFXBARRES_SCROLL_RIGHT      16035
#define IDS_AFXBARRES_AUTOHIDE_ALL      16036
#define IDR_AFXBARRES_POPUP_AFXTOOL_BAR 16102
#define IDS_AFXBARRES_PROPSHT_CAPTION   16103
#define IDD_AFXBARRES_PROPPAGE1         16104
#define IDS_AFXBARRES_UNTITLED_TOOLBAR  16104
#define IDD_AFXBARRES_PROPPAGE2         16105
#define IDS_AFXBARRES_CLOSE             16105
#define IDS_AFXBARRES_DEFUALT_MENU      16106
#define IDS_AFXBARRES_DEFAULT_MENU_DESCR 16107
#define IDS_AFXBARRES_NO_CONTEXT        16108
#define IDS_AFXBARRES_DELETE_TOOLBAR_FMT 16109
#define IDS_AFXBARRES_ALL_COMMANDS      16110
#define IDS_AFXBARRES_RESET_TOOLBAR_FMT 16111
#define IDS_AFXBARRES_RESET_ALL_TOOLBARS 16112
#define IDS_AFXBARRES_RESET_MENU_FMT    16113
#define IDS_AFXBARRES_DEFAULT_VIEW      16114
#define IDS_AFXBARRES_RESET_KEYBOARD    16115
#define IDB_AFXBARRES_MENU_IMAGES       16129
#define IDD_AFXBARRES_TOOLBAR_NAME      16130
#define IDB_AFXBARRES_HELP              16131
#define IDD_AFXBARRES_BUTTON_PROPS      16132
#define IDC_AFXBARRES_DELETE            16133
#define IDD_AFXBARRES_IMAGE_EDITOR      16133
#define IDD_AFXBARRES_PROPPAGE3         16134
#define IDD_AFXBARRES_PROPPAGE4         16135
#define IDD_AFXBARRES_PROPPAGE5         16136
#define IDD_AFXBARRES_PROPPAGE6         16137
#define IDR_AFXRES_PALETTE              16138
#define IDR_AFXRES_PALETTE32            16139
#define IDC_AFXBARRES_RECT              16140
#define IDC_AFXBARRES_ELLIPSE           16141
#define IDC_AFXBARRES_FILL              16142
#define IDC_AFXBARRES_LINE              16143
#define IDC_AFXBARRES_PEN               16144
#define IDC_AFXBARRES_COLOR             16145
#define IDC_AFXBARRES_MOVE              16146
#define IDS_AFXBARRES_TOO_MANY_TOOLBARS_FMT 16243
#define IDS_AFXBARRES_RESET_USAGE_WARNING 16244
#define IDS_AFXBARRES_RESET_TOOLBAR     16300
#define IDC_AFXBARRES_BUTTON_TEXT       16500
#define IDC_AFXBARRES_BUTTONS_LIST      16504
#define IDC_AFXBARRES_IMAGE             16505
#define IDC_AFXBARRES_TEXT              16506
#define IDC_AFXBARRES_MENU_DESCRIPTION  16506
#define IDC_AFXBARRES_IMAGE_TEXT        16507
#define IDC_AFXBARRES_TEMPL_ICON        16507
#define IDC_AFXBARRES_IMAGE_LIST        16508
#define IDC_AFXBARRES_CONTEXT_MENU_CAPTION 16508
#define IDC_AFXBARRES_ADD_IMAGE         16509
#define IDC_AFXBARRES_EDIT_IMAGE        16510
#define IDC_AFXBARRES_DRAW_AREA         16513
#define IDC_AFXBARRES_COMMAND_DESCRIPTION 16514
#define IDC_AFXBARRES_COLORS            16516
#define IDC_AFXBARRES_TOOLBAR_NAME      16516
#define IDC_AFXBARRES_PREVIEW_AREA      16519
#define IDC_AFXBARRES_CONTEXT_HINT      16519
#define IDC_AFXBARRES_CONTEXT_FRAME     16520
#define IDC_AFXBARRES_VIEW_ICON         16526
#define IDC_AFXBARRES_ASSIGNED_TO       16527
#define IDC_AFXBARRES_ASSIGNED_TO_TITLE 16528
#define IDC_AFXBARRES_USER_IMAGE        16529
#define IDC_AFXBARRES_DEFAULT_IMAGE     16530
#define IDC_AFXBARRES_DEFAULT_IMAGE_AREA 16531
#define IDC_AFXBARRES_PALETTE           16533
#define IDC_AFX_RU_MENUS_TITLE          16538
#define IDC_AFX_RU_MENUS_LINE           16539
#define IDC_AFXBARRES_MENU_ANIMATION_LABEL 16543
#define IDC_AFXBARRES_CATEGORY          16601
#define IDC_AFXBARRES_USER_TOOLS        16602
#define IDC_AFXBARRES_BUTTON_DESCR      16603
#define IDC_AFXBARRES_TOOLBAR_LIST      16611
#define IDC_AFXBARRES_TEXT_LABELS       16612
#define IDC_AFXBARRES_RESET             16613
#define IDC_AFXBARRES_RESET_ALL         16614
#define IDC_AFXBARRES_NEW_TOOLBAR       16615
#define IDC_AFXBARRES_RENAME_TOOLBAR    16616
#define IDC_AFXBARRES_DELETE_TOOLBAR    16617
#define IDC_AFXBARRES_MENU_LIST         16621
#define IDC_AFXBARRES_CONTEXT_MENU_LIST 16622
#define IDC_AFXBARRES_RESET_MENU        16623
#define IDC_AFXBARRES_RESET_FRAME_MENU  16624
#define IDC_AFXBARRES_MENU_ANIMATION    16625
#define IDC_AFXBARRES_MENU_SHADOWS      16626
#define IDC_AFXBARRES_LIST_VIEWS        16631
#define IDC_AFXBARRES_NO_DBLCLIICK      16632
#define IDC_AFXBARRES_USE_DBLCLIICK     16633
#define IDC_AFXBARRES_LIST_OF_COMMANDS  16634
#define IDC_AFXBARRES_COMMANDS_LIST     16641
#define IDC_AFXBARRES_VIEW_TYPE         16642
#define IDC_AFXBARRES_CURRENT_KEYS_LIST 16643
#define IDC_AFXBARRES_NEW_SHORTCUT_KEY  16644
#define IDC_AFXBARRES_ASSIGN            16645
#define IDC_AFXBARRES_REMOVE            16646
#define IDC_AFXBARRES_RESET_SHORTCUTS   16647
#define IDC_AFXBARRES_SHOW_TOOLTIPS     16651
#define IDC_AFXBARRES_SHOW_TOOLTIPS_WITH_KEYS 16652
#define IDC_AFXBARRES_LARGE_ICONS       16653
#define IDC_AFXBARRES_SHOW_RECENTLY_USED_MENUS 16655
#define IDC_AFXBARRES_SHOW_MENUS_DELAY  16656
#define IDC_AFXBARRES_RESET_USAGE_DATA  16657
#define IDD_AFXBAR_RES_PRINT_PREVIEW    16658
#define IDC_AFXBARRES_COLOURPLACEHOLDER 16662
#define ID_AFX_TOOL_FILL                16901
#define ID_AFX_TOOL_PEN                 16902
#define ID_AFX_TOOL_PICK                16903
#define ID_AFX_TOOL_LINE                16904
#define ID_AFX_TOOL_RECT                16905
#define ID_AFX_TOOL_ELLIPSE             16906
#define ID_AFX_TOOL_COPY                16907
#define ID_AFX_TOOL_PASTE               16908
#define ID_AFX_TOOL_CLEAR               16909
#define ID_AFXBARRES_TOOLBAR_RESET      16910
#define ID_AFXBARRES_COPY_IMAGE         16911
#define ID_AFXBARRES_TOOLBAR_DELETE     16912
#define ID_AFXBARRES_TOOLBAR_APPEARANCE 16913
#define ID_AFXBARRES_TOOLBAR_IMAGE      16914
#define ID_AFXBARRES_TOOLBAR_TEXT       16915
#define ID_AFXBARRES_TOOLBAR_IMAGE_AND_TEXT 16916
#define ID_AFXBARRES_TOOLBAR_START_GROUP 16917
#define ID_AFXBARRES_TOOLBAR_NEW_MENU   16918
#define IDC_AFXBARRES_HAND              16919
#define IDC_AFXBARRES_ACTIVATE          16920
#define IDC_AFXBARRES_SAVE              16921
#define IDD_AFXBARRES_COMMANDS_LIST     16921
#define IDC_AFXBARRES_CLOSE             16922
#define IDD_AFXBARRES_COMMAND           16922
#define IDC_AFXBARRES_LIST              16923
#define IDD_AFXBARRES_BROWSE_COMMAND    16923
#define IDC_AFXBARRES_TILEHORZ          16924
#define IDD_AFXBARRES_ARGUMENTS         16924
#define IDC_AFXBARRES_MINIMIZE          16925
#define IDD_AFXBARRES_INITIAL_DIRECTORY 16925
#define IDC_AFXBARRES_CASCADE           16926
#define IDD_AFXBARRES_WINDOWS_DLG       16927
#define IDC_AFXBARRES_TILEVERT          16928
#define IDD_AFXBARRES_PROPPAGE7         16928
#define IDB_AFXBARRES_NEW               16929
#define IDB_AFXBARRES_DELETE            16930
#define IDB_AFXBARRES_UP                16931
#define IDI_AFXRES_TOOL                 16931
#define IDB_AFXBARRES_DOWN              16932
#define IDR_AFXRES_PRINT_PREVIEW32      16957
#define ID_AFXRES_TWO_PAGES_DUMMY       16959
#define IDR_AFXRES_PRINT_PREVIEW        16960
#define IDD_AFXBARRES_COLOR_DLG         16961
#define IDD_AFXBARRES_COLOR_PAGE_ONE    16962
#define IDD_AFXBARRES_COLORPAGE_TWO     16963
#define IDC_AFXBARRES_R                 16964
#define IDC_AFXBARRES_G                 16965
#define IDC_AFXBARRES_B                 16966
#define IDC_AFXBARRES_L                 16967
#define IDC_AFXBARRES_S                 16968
#define IDC_AFXBARRES_H                 16969
#define IDC_AFXBARRES_STATICPLACEHOLDER 16970
#define IDC_AFXBARRES_GREYSCALEPLACEHOLDER 16972
#define IDC_AFXBARRES_LUMINANCEPLACEHOLDER 16973
#define IDC_AFXBARRES_HEXPLACEHOLDER    16974
#define IDC_AFXBARRES_SPIN1             16976
#define IDC_AFXBARRES_SPIN2             16977
#define IDC_AFXBARRES_SPIN3             16978
#define IDC_AFXBARRES_SPIN4             16979
#define IDC_AFXBARRES_SPIN5             16980
#define IDC_AFXBARRES_SPIN6             16981
#define IDD_AFXBARRES_KEYMAP            16982
#define IDD_AFXBARRES_MENU_ARGUMENTS    16989
#define IDC_AFXBARRES_PRINT_KEYMAP      16990
#define IDC_AFXBARRES_COPY_KEYMAP       16991
#define IDC_AFXBARRES_KEYLIST           16992
#define IDB_AFXBARRES_PRINT             16993
#define IDB_AFXBARRES_COPY              16994
#define IDI_AFXBARRES_HELP              16995
#define IDC_AFXBARRES_ACCEL_LABEL       16996
#define IDD_AFXBARRES_MENU_INITIAL_DIRECTORY 16997
#define IDB_AFXBARRES_FONT              17000
#define IDD_AFXBARRES_OUTLOOKBAR_OPTIONS 17004
#define IDC_AFXBARRES_APPLY             17008
#define ID_AFXBARRES_TOOLBAR_RESET_PROMT 17016
#define IDS_AFXBARRES_TOOLBAR_OPTIONS   17017
#define IDS_AFXBARRES_ADD_REMOVE_BTNS   17018
#define IDB_AFXBARRES_TASKPANE          17019
#define IDS_AFXBARRES_TASKPANE          17019
#define ID_AFXBARRES_TASKPANE_BACK      17020
#define ID_AFXBARRES_TASKPANE_FORWARD   17021
#define ID_AFXBARRES_TASKPANE_HOME      17022
#define ID_AFXBARRES_TASKPANE_CLOSE     17023
#define ID_AFXBARRES_TASKPANE_OTHER     17024
#define IDS_AFXBARRES_FULLSCREEN_CLOSE  17025
#define IDC_AFXBARRES_MOVEUP            17025
#define IDS_AFXBARRES_FULLSCREEN        17026
#define IDC_AFXBARRES_MOVEDOWN          17026
#define IDS_AFXBARRES_SHOWONEROW        17027
#define IDS_AFXBARRES_SHOWTWOROWS       17028
#define IDS_AFXBARRES_SHOW_MORE_BUTTONS 17029
#define IDS_AFXBARRES_SHOW_FEWER_BUTTONS 17030
#define IDS_AFXBARRES_NAV_PANE_OPTIONS  17031
#define IDB_AFXBARRES_BROWSE            17032
#define IDB_AFXBARRES_SD_TOP            17033
#define IDB_AFXBARRES_SD_BOTTOM         17034
#define IDB_AFXBARRES_SD_LEFT           17035
#define IDB_AFXBARRES_SD_MIDDLE         17036
#define IDB_AFXBARRES_SD_RIGHT          17037
#define IDS_AFXBARRES_MENU              17038
#define IDS_AFXBARRES_FLOATING          17039
#define IDS_AFXBARRES_DOCKING           17040
#define IDS_AFXBARRES_AUTOHIDE          17041
#define IDS_AFXBARRES_HIDE              17042
#define IDS_AFXBARRES_OPENED_DOCS       17043
#define IDC_AFXBARRES_COLOR_SELECT      17045
#define IDB_AFXBARRES_COLOR_PICKER      17046
#define IDC_AFXBARRES_MOVE_TAB          17047
#define IDC_AFXBARRES_NO_MOVE_TAB       17048
#define IDB_AFXBARRES_BROWSE32          17049
#define IDB_AFXBARRES_PRINT32           17050
#define IDB_AFXBARRES_COPY32            17051
#define IDB_AFXBARRES_TASKPANE32        17052
#define IDB_AFXBARRES_NEW32             17053
#define IDB_AFXBARRES_DELETE32          17054
#define IDB_AFXBARRES_UP32              17055
#define IDI_AFXRES_TOOL32               17056
#define IDB_AFXBARRES_DOWN32            17057
#define IDD_AFXBARRES_POPUP_DLG         17058
#define IDB_AFXBARRES_HELP32            17067
#define IDD_AFXBARRES_PROPPAGE8         17074
#define IDS_AFXBARRES_ADD               17075
#define IDD_AFXBARRES_RIBBON_KEYBOARD_DLG 17076
#define IDC_AFXBARRES_QAT_COMMANDS_LIST 17077
#define IDC_AFXBARRES_QAT_ON_BOTTOM     17078
#define IDC_AFXBARRES_KEYBOARD          17079
#define IDB_AFXBARRES_MENU_IMAGES24     17080
#define IDS_AFXBARRES_PLACE_QAT_BELOW_RIBBON 17081
#define IDS_AFXBARRES_PLACE_QAT_ABOVE_RIBBON 17082
#define IDS_AFXBARRES_ADD_TO_QAT        17083
#define IDS_AFXBARRES_REMOVE_FROM_QAT   17084
#define IDS_AFXBARRES_CUSTOMIZE_QAT     17085
#define IDS_AFXBARRES_MINIMIZE_RIBBON   17086
#define IDS_AFXBARRES_STATBAR_CUSTOMIZE 17087
#define IDS_AFXBARRES_TABBED            17088
#define IDB_AFXBARRES_RIBBON_PRINT_LARGE 17089
#define IDB_AFXBARRES_RIBBON_PRINT_SMALL 17090
#define IDS_AFXBARRES_PRINT_PREVIEW     17091
#define IDS_AFXBARRES_PRINT             17092
#define IDS_AFXBARRES_ZOOM              17093
#define IDS_AFXBARRES_PREVIEW           17094
#define IDS_AFXBARRES_QAT_SEPARATOR     17095
#define IDS_AFXBARRES_CUSTOMIZE_QAT_TOOLTIP 17096
#define IDS_AFXBARRES_MORE_COMMANDS     17097
#define IDS_AFXBARRES_PLACE_BELOW_RIBBON 17098
#define IDS_AFXBARRES_PLACE_ABOVE_RIBBON 17099
#define IDI_AFXRES_LINK                 17100
#define IDS_AFXBARRES_CANCEL            17101
#define IDS_AFXBARRES_UNDO_FMT          17102
#define IDS_AFXBARRES_UNDO_ONE          17103
#define IDI_AFXRES_COLORS               17105
#define IDS_AFXBARRES_MORE              17107
#define IDS_AFXBARRES_GALLERY_ROW1_FMT  17108
#define IDS_AFXBARRES_GALLERY_ROW2_FMT  17109
#define IDS_AFXBARRES_MENU_ANIMATION_NONE    17110
#define IDS_AFXBARRES_MENU_ANIMATION_UNFOLD  17111
#define IDS_AFXBARRES_MENU_ANIMATION_SLIDE   17112
#define IDS_AFXBARRES_MENU_ANIMATION_FADE    17113
#define IDS_AFXBARRES_MENU_ANIMATION_DEFAULT 17114
#define IDS_AFXBARRES_GALLERY_ROW_UP	17115
#define IDS_AFXBARRES_GALLERY_ROW_DOWN  17116
#define IDB_AFXBARRES_SD2008_TOP        17117
#define IDB_AFXBARRES_SD2008_BOTTOM     17118
#define IDB_AFXBARRES_SD2008_LEFT       17119
#define IDB_AFXBARRES_SD2008_MIDDLE     17120
#define IDB_AFXBARRES_SD2008_RIGHT      17121
#define IDB_AFXBARRES_SD2008_TOP_HOT	17122
#define IDB_AFXBARRES_SD2008_BOTTOM_HOT 17123
#define IDB_AFXBARRES_SD2008_LEFT_HOT   17124
#define IDB_AFXBARRES_SD2008_MIDDLE_HOT 17125
#define IDB_AFXBARRES_SD2008_RIGHT_HOT  17126
#define IDB_AFXBARRES_SD2008_BASE       17127
#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRIBBONRES_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonpanel.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxglobals.h"
#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonCategory;
class CMFCRibbonBaseElement;
class CMFCRibbonPanel;
class CMFCRibbonGallery;

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON

//////////////////////////////////////////////////////////////////////
// CMFCRibbonLaunchButton

class CMFCRibbonLaunchButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonLaunchButton)

	CMFCRibbonLaunchButton();

	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);
	virtual void OnClick(CPoint point);
	virtual CRect GetKeyTipRect(CDC* pDC, BOOL bIsMenu);
	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	CMFCRibbonPanel* m_pParentPanel;
};

#endif // ENABLE_RIBBON_LAUNCH_BUTTON

//////////////////////////////////////////////////////////////////////
// CMFCRibbonDefaultPanelButton

class CMFCRibbonDefaultPanelButton : public CMFCRibbonButton
{
	DECLARE_DYNCREATE(CMFCRibbonDefaultPanelButton)

	friend class CMFCRibbonCategory;

	CMFCRibbonDefaultPanelButton(CMFCRibbonPanel* pPanel = NULL);

	virtual void OnDraw(CDC* pDC);
	virtual void OnLButtonDown(CPoint point);
	virtual void OnShowPopupMenu();
	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	virtual CString GetToolTipText() const { return m_rect.IsRectEmpty() ? CString() : m_strText; }
	virtual void OnClick(CPoint /*point*/) { OnShowPopupMenu(); }

	virtual CSize GetImageSize(RibbonImageType /*type*/) const
	{
		CSize sizeIcon(16, 16);

		if (afxGlobalData.GetRibbonImageScale() != 1.)
		{
			sizeIcon.cx = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cx);
			sizeIcon.cy = (int)(.5 + afxGlobalData.GetRibbonImageScale() * sizeIcon.cy);
		}

		return sizeIcon;
	}

	virtual BOOL IsDefaultPanelButton() const { return TRUE; }

	virtual void DrawImage(CDC* pDC, RibbonImageType type, CRect rectImage);
	virtual BOOL CanBeAddedToQuickAccessToolBar() const { return TRUE; }

	virtual void CopyFrom(const CMFCRibbonBaseElement& s);
	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);
	virtual BOOL OnKey(BOOL bIsMenuKey);
	virtual CMFCRibbonPanel* GetParentPanel() const { return m_pPanel; }

	HICON         m_hIcon;
	CMFCRibbonPanel* m_pPanel;
};

//////////////////////////////////////////////////////////////////////
// CMFCRibbonPanel

class CMFCRibbonPanel : public CObject  
{
	DECLARE_DYNCREATE(CMFCRibbonPanel)

	friend class CMFCRibbonCategory;
	friend class CMFCRibbonPanelMenuBar;
	friend class CMFCRibbonPanelMenu;
	friend class CMFCRibbonBar;
	friend class CMFCRibbonConstructor;

// Construction
protected:
	CMFCRibbonPanel(LPCTSTR lpszName = NULL, HICON hIcon = NULL);
	CMFCRibbonPanel(CMFCRibbonGallery* pPaletteButton);

	virtual void CopyFrom(CMFCRibbonPanel& src);

	void CommonInit(LPCTSTR lpszName = NULL, HICON hIcon = NULL);

public:
	virtual ~CMFCRibbonPanel();

// Attributes:
public:
	LPCTSTR GetName() const { return m_strName; }
	CMFCRibbonButton& GetDefaultButton() { return m_btnDefault; }

#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	void EnableLaunchButton(UINT uiCmdID, int nIconIndex = -1, LPCTSTR lpszKeys = NULL);
	CMFCRibbonButton& GetLaunchButton() { return m_btnLaunch; }
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	BOOL IsHighlighted() const { return m_bIsHighlighted; }
	BOOL IsCollapsed() const; 	BOOL IsMenuMode() const { return m_bMenuMode; }
	virtual BOOL IsMainPanel() const { return FALSE; }
	const CRect& GetRect() const { return m_rect; }

	DWORD_PTR GetData() const { return m_dwData; }
	void SetData(DWORD_PTR dwData) { m_dwData = dwData; }

	CMFCRibbonCategory* GetParentCategory() const { return m_pParent; }
	CMFCRibbonPanelMenuBar* GetParentMenuBar() const { return m_pParentMenuBar; }
	CMFCRibbonBaseElement* GetParentButton() const;

	BOOL IsJustifyColumns() const { return m_bJustifyColumns; }
	void SetJustifyColumns(BOOL bSet = TRUE) { m_bJustifyColumns = bSet; }

	void SetKeys(LPCTSTR lpszKeys);
	int GetCaptionHeight() const { return m_rectCaption.Height(); }

	BOOL IsCenterColumnVert() const { return m_bCenterColumnVert; }
	void SetCenterColumnVert(BOOL bSet = TRUE) { m_bCenterColumnVert = bSet; }

	/// <summary>
	/// Indicates whether the parent ribbon has Windows 7-style look (small rectangular application button)</summary>
	/// <returns> 
	/// TRUE if the parent ribbon has Windows 7-style look; otherwise FALSE.</returns>
	BOOL IsWindows7Look() const;

// Operations
public:
	virtual CMFCRibbonBaseElement* HitTest(CPoint point, BOOL bCheckPanelCaption = FALSE);
	virtual int HitTestEx(CPoint point) const;
	virtual int GetIndex(CMFCRibbonBaseElement* pElem) const;
	virtual BOOL GetPreferedMenuLocation(CRect& /*rect*/) { return FALSE; }

	BOOL HasElement(const CMFCRibbonBaseElement* pElem) const;

	virtual void RecalcWidths(CDC* pDC, int nHeight);

	virtual void Add(CMFCRibbonBaseElement* pElem);
	virtual void AddSeparator();

	virtual BOOL Insert(CMFCRibbonBaseElement* pElem, int nIndex);
	virtual BOOL InsertSeparator(int nIndex);

	CMFCRibbonButtonsGroup* AddToolBar(UINT uiToolbarResID, UINT uiColdResID = 0, UINT uiHotResID = 0, UINT uiDisabledResID = 0);

	CMFCRibbonBaseElement* GetElement(int nIndex) const;
	CMFCRibbonBaseElement* FindByID(UINT uiCmdID) const;
	CMFCRibbonBaseElement* FindByData(DWORD_PTR dwData) const;

	BOOL SetElementMenu(UINT uiCmdID, HMENU hMenu, BOOL bIsDefautCommand = FALSE, BOOL bRightAlign = FALSE);
	BOOL SetElementMenu(UINT uiCmdID, UINT uiMenuResID, BOOL bIsDefautCommand = FALSE, BOOL bRightAlign = FALSE);

	BOOL Replace(int nIndex, CMFCRibbonBaseElement* pElem);
	BOOL ReplaceByID(UINT uiCmdID, CMFCRibbonBaseElement* pElem);

	CMFCRibbonBaseElement* SetElementRTC(int nIndex, CRuntimeClass* pRTC);
	CMFCRibbonBaseElement* SetElementRTCByID(UINT uiCmdID, CRuntimeClass* pRTC);

	int GetCount() const;

	BOOL Remove(int nIndex, BOOL bDelete = TRUE);
	void RemoveAll();

	void GetElements(CArray <CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);
	void GetItemIDsList(CList<UINT,UINT>& lstItems) const;
	void GetElementsByID(UINT uiCmdID, CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);
	/// <summary>
	/// Obtains an array of visible elements.</summary>
	/// <param name="arElements"> When the function returns this parameter contains an array of visible elements.</param>
	void GetVisibleElements(CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>& arElements);

	CMFCRibbonBaseElement* GetDroppedDown() const;
	CMFCRibbonBaseElement* GetHighlighted() const;
	CMFCRibbonBaseElement* GetPressed() const;
	/// <summary>
	/// Returns a focused element. </summary>
	/// <returns> A pointer to a focused element or NULL.</returns>
	CMFCRibbonBaseElement* GetFocused() const;

	/// <summary>
	/// Sets focus to the specified Ribbon element.</summary>
	/// <param name="pNewFocus"> A pointer to a Ribbon element that receives focus.</param>
	void SetFocused(CMFCRibbonBaseElement* pNewFocus);

	CMFCRibbonPanelMenu* ShowPopup(CMFCRibbonDefaultPanelButton* pButton = NULL);

	/// <summary> 
	/// Scrolls the gallery to make the specified Ribbon element visible.</summary>
	/// <param name="pItem"> A pointer to a Ribbon element to show.</param>
	void MakeGalleryItemVisible(CMFCRibbonBaseElement* pItem);
	/// <summary> 
	/// Returns a bounding rectangle of Gallery element.</summary> 
	/// <returns> Size and position of Gallery element within this panel.</returns>
	CRect GetGalleryRect();

// Overrides
public:
	virtual BOOL OnKey(UINT nChar);

protected:
	virtual int GetHeight(CDC* pDC) const;

	virtual BOOL IsFixedSize() const { return FALSE; }

	virtual void DoPaint(CDC* pDC);
	virtual void Reposition(CDC* pDC, const CRect& rect);
	virtual void RepositionMenu(CDC* pDC, const CRect& rect);
	virtual void ReposPalette(CDC* pDC, const CRect& rect);
	virtual void OnUpdateCmdUI(CMFCRibbonCmdUI* pCmdUI, CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual BOOL NotifyControlCommand(BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam);
	virtual void OnAfterChangeRect(CDC* pDC);
	virtual void OnShow(BOOL bShow);
	virtual void RedrawElement(CMFCRibbonBaseElement* pElem);
	virtual void OnDrawMenuBorder(CDC* /*pDC*/, CMFCRibbonPanelMenuBar* /*pMenuBar*/) {}
	virtual void OnRTLChanged(BOOL bIsRTL);

// Operations
protected:
	int GetMinWidth(CDC* pDC);
	void CenterElementsInColumn(int nFirstInColumnIndex, int nLastInColumnIndex, int nCaptionHeight);
	void JustifyElementsInColumn(int nFirstInColumnIndex, int nLastInColumnIndex);

	CSize GetCaptionSize(CDC* pDC) const;
	int CalcTotalWidth();

	void ShowDefaultButton(CDC* pDC);

	virtual void Highlight(BOOL bHighlight, CPoint point);
	virtual CMFCRibbonBaseElement* MouseButtonDown(CPoint point);
	virtual void MouseButtonUp(CPoint point);
	void CancelMode();

	CWnd* GetParentWnd() const;

	CMFCRibbonBaseElement* GetFirstTabStop() const;
	CMFCRibbonBaseElement* GetLastTabStop() const;

	void CleanUpSizes();
	void OnDrawPaletteMenu(CDC* pDC);
	void ScrollPalette(int nScrollOffset, BOOL bIsDelta = FALSE);
	CSize GetPaltteMinSize() const;

// Attributes
protected:
	BOOL m_bShowCaption;
	BOOL m_bForceCollpapse;
	BOOL m_bIsHighlighted;
	BOOL m_bIsCalcWidth;
	BOOL m_bAlignByColumn;
	BOOL m_bCenterColumnVert;
	BOOL m_bMenuMode;
	BOOL m_bIsDefaultMenuLook;
	BOOL m_bFloatyMode;
	BOOL m_bIsQATPopup;
	BOOL m_bIsFirst;
	BOOL m_bIsLast;
	BOOL m_bJustifyColumns;
	BOOL m_bSizeIsLocked;
	BOOL m_bScrollDnAvailable;
	BOOL m_bTruncateCaption;

	int m_nCurrWidthIndex; // Index of the current width
	int m_nFullWidth;      // Full width
	int m_nRows;           // Rows number (m_bAlignByColumn == FALSE)
	int m_nXMargin;
	int m_nYMargin;
	int m_nScrollOffset;

	CRect m_rectCaption;
	CRect m_rect;          // Panel location
	CRect m_rectMenuAreaTop;
	CRect m_rectMenuAreaBottom;

	CString   m_strName;   // Panel name
	DWORD_PTR m_dwData;    // User-defined data

	CScrollBar*               m_pScrollBar;
	CMFCRibbonCategory*          m_pParent;        // Parent category
	CMFCRibbonPanelMenuBar*      m_pParentMenuBar; // Parent menu bar
	CMFCRibbonGallery*     m_pPaletteButton;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	CMFCRibbonLaunchButton       m_btnLaunch;
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	CMFCRibbonBaseElement*       m_pHighlighted;   // Highlighted 
	CMFCRibbonDefaultPanelButton m_btnDefault;     // Default panel button

	CMap<int,int,int,int> m_mapNonOptWidths; // Optimized Width <-> Full Width
	CArray<int,int>       m_arWidths;        // All possible widths
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arElements;

	AFX_IMPORT_DATA static UINT m_nNextPanelID;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonquickaccesstoolbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonbuttonsgroup.h"
#include "afxribbonbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

////////////////////////////////////////////////////////
// CMFCRibbonQuickAccessToolBar class

class CMFCRibbonQuickAccessCustomizeButton;

class CMFCRibbonQuickAccessToolBarDefaultState
{
	friend class CMFCRibbonQuickAccessToolBar;
	friend class CMFCRibbonBar;
	friend class CMFCRibbonCollector;

public:
	CMFCRibbonQuickAccessToolBarDefaultState();

	void AddCommand(UINT uiCmd, BOOL bIsVisible = TRUE);
	void RemoveAll();

	void CopyFrom(const CMFCRibbonQuickAccessToolBarDefaultState& src);

protected:
	CArray<UINT,UINT> m_arCommands;
	CArray<BOOL,BOOL> m_arVisibleState;
};

class CMFCRibbonQuickAccessToolBar : public CMFCRibbonButtonsGroup
{
	DECLARE_DYNCREATE(CMFCRibbonQuickAccessToolBar)

	friend class CMFCRibbonBar;
	friend class CMFCRibbonBaseElement;
	friend class CMFCRibbonCustomizePropertyPage;
	friend class CMFCRibbonCollector;

public:
	CMFCRibbonQuickAccessToolBar();
	virtual ~CMFCRibbonQuickAccessToolBar();

protected:
	void SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands, LPCTSTR lpszToolTip);
	void SetCommands(CMFCRibbonBar* pRibbonBar, const CList<UINT,UINT>& lstCommands, CMFCRibbonQuickAccessCustomizeButton* pCustButton);

	void GetCommands(CList<UINT,UINT>& lstCommands);
	void GetDefaultCommands(CList<UINT,UINT>& lstCommands);
	void ReplaceCommands(const CList<UINT,UINT>& lstCommands);
	void ResetCommands();

	int GetActualWidth() const;

	virtual CSize GetRegularSize(CDC* pDC);
	virtual void OnAfterChangeRect(CDC* pDC);

	virtual BOOL IsQuickAccessToolBar() const { return TRUE; }

	void Add(CMFCRibbonBaseElement* pElem);
	void Remove(CMFCRibbonBaseElement* pElem);

	void RebuildHiddenItems();
	CRect GetCommandsRect() const { return m_rectCommands; }
	void RebuildKeys();

protected:
	CMFCRibbonQuickAccessToolBarDefaultState m_DefaultState;
	CRect                  m_rectCommands;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonprogressbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbaseribbonelement.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonProgressBar : public CMFCRibbonBaseElement
{
	DECLARE_DYNCREATE(CMFCRibbonProgressBar)

public:
	CMFCRibbonProgressBar();
	CMFCRibbonProgressBar(UINT nID, int nWidth = 90, int nHeight = 22);

	virtual ~CMFCRibbonProgressBar();

// Attributes
public:
	void SetRange(int nMin, int nMax);

	int GetRangeMin() const { return m_nMin; }
	int GetRangeMax() const { return m_nMax; }

	int GetWidth() const { return m_nWidth; }
	int GetHeight() const { return m_nHeight; }

	void SetPos(int nPos, BOOL bRedraw = TRUE);
	int GetPos() const { return m_nPos; }

	void SetInfiniteMode(BOOL bSet = TRUE);
	BOOL IsInfiniteMode() const { return m_bInfiniteMode; }

// Operations
protected:
	void CommonInit();

// Overrides
public:
	virtual void OnDraw(CDC* pDC);
	virtual CSize GetRegularSize(CDC* pDC);

protected:
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);

	virtual BOOL CanBeStretched() { return FALSE; }

	virtual void OnDrawOnList(CDC* pDC, CString strText, int nTextOffset, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

// Attributes
protected:
	int  m_nMin;
	int  m_nMax;
	int  m_nPos;
	int  m_nWidth;
	int  m_nHeight;
	BOOL m_bInfiniteMode;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonstatusbar.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonBaseElement;

/////////////////////////////////////////////////////////////////////////////
// CMFCRibbonStatusBar window

class CMFCRibbonStatusBar : public CMFCRibbonBar
{
	friend class CFrameImpl;

	DECLARE_DYNAMIC(CMFCRibbonStatusBar)

// Construction
public:
	CMFCRibbonStatusBar();

	BOOL Create(CWnd* pParentWnd,DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, UINT nID = AFX_IDW_STATUS_BAR);
	BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, UINT nID = AFX_IDW_STATUS_BAR);

// Attributes
public:
	virtual BOOL GetExtendedArea(CRect& rect) const;

	// Returns a free space for dynamic panes
	int GetSpace() const { return m_cxFree; }

	BOOL IsBottomFrame() const { return m_bBottomFrame; }

protected:
	int   m_cxSizeBox;
	int   m_cxFree;
	CRect m_rectSizeBox;
	CRect m_rectResizeBottom;
	CRect m_rectInfo;
	BOOL  m_bBottomFrame;

	CString      m_strInfo;
	CStringArray m_arElementLabels;
	CStringArray m_arExElementLabels;

	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arElements;
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arExElements;
	CArray<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*> m_arCustomizeItems;
	CList<CMFCRibbonBaseElement*, CMFCRibbonBaseElement*>  m_lstDynElements;

// Operations
public:
	void AddElement(CMFCRibbonBaseElement* pElement, LPCTSTR lpszLabel, BOOL bIsVisible = TRUE);
	void AddExtendedElement(CMFCRibbonBaseElement* pElement, LPCTSTR lpszLabel, BOOL bIsVisible = TRUE);
	void AddSeparator();

	void SetInformation(LPCTSTR lpszInfo); // lpszInfo == NULL - remove information
	BOOL IsInformationMode() const { return !m_strInfo.IsEmpty(); }

	void AddDynamicElement(CMFCRibbonBaseElement* pElement);

	BOOL RemoveElement(UINT uiID);
	void RemoveAll();

	int GetCount() const;
	int GetExCount() const;

	CMFCRibbonBaseElement* GetElement(int nIndex);
	CMFCRibbonBaseElement* GetExElement(int nIndex);

	CMFCRibbonBaseElement* FindByID(UINT uiCmdID, BOOL /*bVisibleOnly*/ = TRUE) { return FindElement(uiCmdID); }
	CMFCRibbonBaseElement* FindElement(UINT uiID);

	BOOL IsExtendedElement(CMFCRibbonBaseElement* pElement) const;

// Overrides
public:
	virtual void RecalcLayout();

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual BOOL IsMainRibbonBar() const { return FALSE; }
	virtual BOOL IsShowGroupBorder(CMFCRibbonButtonsGroup* /*pGroup*/) const { return TRUE; }

	virtual CMFCRibbonBaseElement* HitTest(CPoint point, BOOL bCheckActiveCategory = FALSE, BOOL bCheckPanelCaption = FALSE);
	virtual CMFCRibbonBaseElement* GetDroppedDown();

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void OnPaneContextMenu(CWnd* pParentFrame, CPoint point);

	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);

	virtual void OnRTLChanged(BOOL bIsRTL);
	virtual void OnDrawInformation(CDC* pDC, CString& strInfo, CRect rectInfo);

// Implementation
public:
	virtual ~CMFCRibbonStatusBar();

protected:
	//{{AFX_MSG(CMFCRibbonStatusBar)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnUpdateShadows(WPARAM,LPARAM);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void CleanUpCustomizeItems();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsettingsstore.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include <winreg.h>
#include <atlbase.h>

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CSettingsStore : public CObject
{
	friend class CSettingsStoreSP;
	DECLARE_DYNCREATE(CSettingsStore)

// Construction
public:
	CSettingsStore(BOOL bAdmin, BOOL bReadOnly);
	virtual ~CSettingsStore();

protected:
	CSettingsStore();

// Operations
public:
	virtual BOOL CreateKey(LPCTSTR lpszPath);
	virtual BOOL Open(LPCTSTR lpszPath);
	virtual void Close();

	virtual BOOL DeleteValue(LPCTSTR lpszValue);
	virtual BOOL DeleteKey(LPCTSTR lpszPath, BOOL bAdmin = FALSE);

	virtual BOOL Write(LPCTSTR lpszValueName, int nValue);
	virtual BOOL Write(LPCTSTR lpszValueName, DWORD dwVal);
	virtual BOOL Write(LPCTSTR lpszValueName, LPCTSTR lpszVal);
	virtual BOOL Write(LPCTSTR lpszValueName, const CRect& rect);
	virtual BOOL Write(LPCTSTR lpszValueName, LPBYTE pData, UINT nBytes);
	virtual BOOL Write(LPCTSTR lpszValueName, CObject& obj);
	virtual BOOL Write(LPCTSTR lpszValueName, CObject* pObj);

	virtual BOOL Read(LPCTSTR lpszValueName, int& nValue);
	virtual BOOL Read(LPCTSTR lpszValueName, DWORD& dwValue);
	virtual BOOL Read(LPCTSTR lpszValueName, CString& strValue);
	virtual BOOL Read(LPCTSTR lpszValueName, CRect& rect);
	virtual BOOL Read(LPCTSTR lpszValueName, BYTE** ppData, UINT* pcbData);
	virtual BOOL Read(LPCTSTR lpszValueName, CObject& obj);
	virtual BOOL Read(LPCTSTR lpszValueName, CObject*& pObj);

protected:
	ATL::CRegKey m_reg;
	CString m_strPath;
	BOOL    m_bReadOnly;
	BOOL    m_bAdmin;
	DWORD   m_dwUserData;
};

//////////////////////////////////////////////////////////////////////////////
// CSettingsStoreSP - Helper class that manages "safe" CSettingsStore pointer

class CSettingsStoreSP
{
public:
	static BOOL __stdcall SetRuntimeClass(CRuntimeClass* pRTI);

	CSettingsStoreSP(DWORD dwUserData = 0) : m_pRegistry(NULL), m_dwUserData(dwUserData)
	{
	}

	~CSettingsStoreSP()
	{
		if (m_pRegistry != NULL)
		{
			ASSERT_VALID(m_pRegistry);
			delete m_pRegistry;
		}
	}

	CSettingsStore& Create(BOOL bAdmin, BOOL bReadOnly);

protected:
	CSettingsStore* m_pRegistry;
	DWORD      m_dwUserData;

	AFX_IMPORT_DATA static CRuntimeClass* m_pRTIDefault;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonstatusbarpane.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonbutton.h"
#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonStatusBarPane : public CMFCRibbonButton  
{
	friend class CMFCRibbonStatusBar;

	DECLARE_DYNCREATE(CMFCRibbonStatusBarPane)

// Construction
public:
	CMFCRibbonStatusBarPane();

	CMFCRibbonStatusBarPane(
		UINT     nCmdID,                     // Pane command id
		LPCTSTR  lpszText,                   // Pane label
		BOOL     bIsStatic = FALSE,          // Pane is static (non-clickable)
		HICON    hIcon = NULL,               // Pane icon
		LPCTSTR  lpszAlmostLargeText = NULL);// The almost large text in pane

	CMFCRibbonStatusBarPane(
		UINT     nCmdID,                    // Pane command id
		LPCTSTR  lpszText,                  // Pane label
		HBITMAP  hBmpAnimationList,         // Pane animation list
		int      cxAnimation = 16,          // Animation frame width
		COLORREF clrTrnsp= RGB(192,192,192),// Transparent color
		HICON    hIcon = NULL,              // Pane icon
		BOOL     bIsStatic = FALSE);        // Pane is static (non-clickable)

	CMFCRibbonStatusBarPane(
		UINT     nCmdID,                    // Pane command id
		LPCTSTR  lpszText,                  // Pane label
		UINT     uiAnimationListResID,      // Pane animation list
		int      cxAnimation = 16,          // Animation frame width
		COLORREF clrTrnsp= RGB(192,192,192),// Transparent color
		HICON    hIcon = NULL,              // Pane icon
		BOOL     bIsStatic = FALSE);        // Pane is static (non-clickable)

	virtual ~CMFCRibbonStatusBarPane();

// Attributes
public:
	// Is located on status bar extended (right) area?
	BOOL IsExtended() const { return m_bIsExtended; }

	LPCTSTR GetAlmostLargeText() const { return m_strAlmostLargeText; }
	void SetAlmostLargeText(LPCTSTR lpszAlmostLargeText)
	{
		m_strAlmostLargeText = (lpszAlmostLargeText == NULL) ? _T("") : lpszAlmostLargeText;
		CleanUpSizes();
	}

	int GetTextAlign() const { return m_nTextAlign; }
	void SetTextAlign(int nAlign) { m_nTextAlign = nAlign; }
	BOOL IsAnimation() const { return m_nAnimTimerID != 0; }

protected:
	BOOL m_bIsStatic;             // Pane is static (non-clickable)
	BOOL m_bIsExtended;           // Is located on status bar extended (right) area
	BOOL m_bIsTextTruncated;      // Is text truncated?
	int  m_nTextAlign;            // TA_LEFT, TA_CENTER or TA_RIGHT
	int  m_nAnimationIndex;       // Current animation frame number
	UINT m_nAnimTimerID;          // Animation timer ID
	UINT m_nAnimationDuration;    // Animation duaration
	DWORD m_dwAnimationStartTime; // Animation start time
	CString m_strAlmostLargeText; // The almost large text in pane
	CMFCToolBarImages m_AnimImages;  // List of animation frames

	static CMap<UINT,UINT,CMFCRibbonStatusBarPane*,CMFCRibbonStatusBarPane*> m_mapAnimations;
	static CCriticalSection m_CriticalSection; // For multi-theard applications

// Operations
public:
	void SetAnimationList(	HBITMAP hBmpAnimationList, int cxAnimation = 16, COLORREF clrTransp = RGB(192, 192, 192));
	BOOL SetAnimationList(	UINT uiAnimationListResID, int cxAnimation = 16, COLORREF clrTransp = RGB(192, 192, 192));

	void StartAnimation(UINT nFrameDelay = 500, UINT nDuration = -1); // ms
	void StopAnimation();

protected:
	void CommonInit();

	static VOID CALLBACK AnimTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

// Overrides
public:
	virtual COLORREF OnFillBackground(CDC* pDC);
	virtual void OnDrawBorder(CDC* /*pDC*/) {}

protected:
	virtual int GetTextOffset() const { return m_szMargin.cx / 2; }
	virtual void OnCalcTextSize(CDC* pDC);
	virtual int DrawRibbonText(CDC* pDC, const CString& strText, CRect rectText, UINT uiDTFlags, COLORREF clrText = (COLORREF)-1);
	virtual CSize GetIntermediateSize(CDC* pDC);
	virtual void OnDraw(CDC* pDC);

	virtual CString GetToolTipText() const;

	virtual BOOL CanBeStretched() { return TRUE; }

	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnFinishAnimation() {}

	virtual void OnRTLChanged(BOOL bIsRTL);

	virtual BOOL IsDrawTooltipImage() const { return m_AnimImages.GetCount() <= 0; }
	virtual void SetMargin(const CSize& /*sizeMargin*/) { m_szMargin = CSize(9, 0); }

	virtual BOOL HasLargeMode() const { return FALSE; }
	virtual BOOL HasIntermediateMode() const { return TRUE; }
	virtual BOOL HasCompactMode() const { return FALSE; }
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxribbonundobutton.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxribbonpalettegallery.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCRibbonUndoButton : public CMFCRibbonGallery  
{
	DECLARE_DYNCREATE(CMFCRibbonUndoButton)

// Construction
public:
	CMFCRibbonUndoButton();
	CMFCRibbonUndoButton(UINT nID, LPCTSTR lpszText, int nSmallImageIndex = -1, int nLargeImageIndex = -1);
	CMFCRibbonUndoButton(UINT nID, LPCTSTR lpszText, HICON hIcon);

	virtual ~CMFCRibbonUndoButton();

// Attributes
public:
	virtual BOOL HasMenu() const { return TRUE; }
	int GetActionNumber() const { return m_nActionNumber; }

protected:
	int          m_nActionNumber;
	CSize        m_sizeMaxText;
	CString      m_strCancel;
	CString      m_strUndoOne;
	CString      m_strUndoFmt;
	CStringArray m_arLabels;

// Overrides:
protected:
	virtual void CopyFrom(const CMFCRibbonBaseElement& src);
	virtual void OnClick(CPoint point);
	virtual CSize GetIconSize() const;
	virtual void OnDrawPaletteIcon(CDC* pDC, CRect rectIcon, int nIconIndex, CMFCRibbonGalleryIcon* pIcon, COLORREF clrText);
	virtual void NotifyHighlightListItem(int nIndex);
	virtual BOOL OnClickPaletteSubItem(CMFCRibbonButton* pButton, CMFCRibbonPanelMenuBar* pMenuBar);
	virtual void OnShowPopupMenu();

	void CommonInit();

// Operations
public:
	void AddUndoAction(LPCTSTR lpszLabel);
	void CleanUpUndoList();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxrich.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRICH_H__
#define __AFXRICH_H__

#ifdef _AFX_NO_RICHEDIT_SUPPORT
	#error Windows RichEdit classes not supported in this library variant.
#endif

#pragma once

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif
#ifndef __AFXDLGS_H__
	#include <afxdlgs.h>
#endif
#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif
#ifndef _RICHEDIT_
	#include <richedit.h>
#endif
#ifndef _RICHOLE_
	#include <richole.h>
	#define _RICHOLE_
#endif
#ifndef __AFXCMN_H__
	#include <afxcmn.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXRICH - MFC RichEdit classes

// Classes declared in this file

//CObject
	//CCmdTarget;
		//CWnd
			//CView
				//CCtrlView
					class CRichEditView;// rich text editor view

		//CDocument
			//COleDocument
				class CRichEditDoc;
		//CDocItem
			//COleClientItem
				class CRichEditCntrItem;

#undef AFX_DATA
#define AFX_DATA AFX_OLE_DATA

/////////////////////////////////////////////////////////////////////////////
// CRichEditView

class _AFX_RICHEDIT_STATE;  // private to implementation

class CRichEditView : public CCtrlView
{
	DECLARE_DYNCREATE(CRichEditView)

// Construction
public:
	CRichEditView();

// Attributes
public:
	enum WordWrapType
	{
		WrapNone = 0,
		WrapToWindow = 1,
		WrapToTargetDevice = 2
	};
	int m_nWordWrap;
	int m_nBulletIndent;

	void SetPaperSize(CSize sizePaper);
	CSize GetPaperSize() const;
	void SetMargins(const CRect& rectMargin);
	CRect GetMargins() const;
	int GetPrintWidth() const;
	CRect GetPrintRect() const;
	CRect GetPageRect() const;

	//formatting
	CHARFORMAT2& GetCharFormatSelection();
	PARAFORMAT2& GetParaFormatSelection();
	void SetCharFormat(CHARFORMAT2 cf);
	BOOL SetParaFormat(PARAFORMAT2& pf);
	CRichEditCntrItem* GetSelectedItem() const;
	CRichEditCntrItem* GetInPlaceActiveItem() const;

	// CEdit control access
	CRichEditCtrl& GetRichEditCtrl() const;
	CRichEditDoc* GetDocument() const;

	// other attributes
	long GetTextLength() const;
	long GetTextLengthEx(DWORD dwFlags, UINT uCodePage = -1) const;

	static BOOL AFX_CDECL IsRichEditFormat(CLIPFORMAT cf);
	BOOL CanPaste() const;

// Operations
public:
	void AdjustDialogPosition(CDialog* pDlg);
	HRESULT InsertItem(CRichEditCntrItem* pItem);
	void InsertFileAsObject(LPCTSTR lpszFileName);
	BOOL FindText(LPCTSTR lpszFind, BOOL bCase = TRUE, BOOL bWord = TRUE,
		BOOL bNext = TRUE);
	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bCase = TRUE,
		BOOL bWord = TRUE, BOOL bNext = TRUE);
	long PrintInsideRect(CDC* pDC, RECT& rectLayout, long nIndexStart,
		long nIndexStop, BOOL bOutput);
	long PrintPage(CDC* pDC, long nIndexStart, long nIndexStop);
	void DoPaste(COleDataObject& dataobj, CLIPFORMAT cf,
		HMETAFILEPICT hMetaPict);

// Helpers
	void OnCharEffect(DWORD dwMask, DWORD dwEffect);
	void OnUpdateCharEffect(CCmdUI* pCmdUI, DWORD dwMask, DWORD dwEffect) ;
	void OnParaAlign(WORD wAlign);
	void OnUpdateParaAlign(CCmdUI* pCmdUI, WORD wAlign);

// Overrideables
protected:
	virtual BOOL IsSelected(const CObject* pDocItem) const;
	virtual void OnInitialUpdate();
	virtual void OnFindNext(LPCTSTR lpszFind, BOOL bNext, BOOL bCase, BOOL bWord);
	virtual void OnReplaceSel(LPCTSTR lpszFind, BOOL bNext, BOOL bCase,
		BOOL bWord, LPCTSTR lpszReplace);
	virtual void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace,
		BOOL bCase, BOOL bWord);
	virtual void OnTextNotFound(LPCTSTR lpszFind);
	virtual void OnPrinterChanged(const CDC& dcPrinter);
	virtual void WrapChanged();
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

// Advanced
	virtual BOOL OnPasteNativeObject(LPSTORAGE lpStg);
	virtual HMENU GetContextMenu(WORD, LPOLEOBJECT, CHARRANGE* );
	virtual HRESULT GetClipboardData(CHARRANGE* lpchrg, DWORD dwReco,
		LPDATAOBJECT lpRichDataObj, LPDATAOBJECT* lplpdataobj);
	virtual HRESULT QueryAcceptData(LPDATAOBJECT, CLIPFORMAT*, DWORD,
		BOOL, HGLOBAL);

// Implementation
public:
	LPRICHEDITOLE m_lpRichEditOle;
	CDC m_dcTarget;
	long m_lInitialSearchPos;
	UINT m_nPasteType;
	BOOL m_bFirstSearch;
	BOOL m_bChangeFindRange;

	void TextNotFound(LPCTSTR lpszFind);
	BOOL FindText(_AFX_RICHEDIT_STATE* pEditState);
	BOOL FindTextSimple(_AFX_RICHEDIT_STATE* pEditState);
	long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft);
	void Stream(CArchive& ar, BOOL bSelection);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT ShowContainerUI(BOOL b);
	static DWORD CALLBACK EditStreamCallBack(DWORD_PTR dwCookie,
		LPBYTE pbBuff, LONG cb, LONG *pcb);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual void Serialize(CArchive& ar);
	virtual void DeleteContents();
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo);

	static AFX_DATA ULONG lMaxSize; // maximum number of characters supported

protected:
	CRect m_rectMargin;
	CSize m_sizePaper;
	CDWordArray m_aPageStart;    // array of starting pages
	PARAFORMAT2 m_paraformat;
	CHARFORMAT2 m_charformat;
	BOOL m_bSyncCharFormat;
	BOOL m_bSyncParaFormat;

	// construction
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// printing support
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo = NULL);
	BOOL PaginateTo(CDC* pDC, CPrintInfo* pInfo);

	// find & replace support
	void OnEditFindReplace(BOOL bFindOnly);
	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bCase, BOOL bWord);

	// special overrides for implementation

	//{{AFX_MSG(CRichEditView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnUpdateNeedSel(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedClip(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedText(CCmdUI* pCmdUI);
	afx_msg void OnUpdateNeedFind(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
	afx_msg void OnUpdateEditRedo(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnEditCopy();
	afx_msg void OnEditPaste();
	afx_msg void OnEditClear();
	afx_msg void OnEditUndo();
	afx_msg void OnEditRedo();
	afx_msg void OnEditSelectAll();
	afx_msg void OnEditFind();
	afx_msg void OnEditReplace();
	afx_msg void OnEditRepeat();
	afx_msg void OnDestroy();
	afx_msg void OnEditProperties();
	afx_msg void OnUpdateEditProperties(CCmdUI* pCmdUI);
	afx_msg void OnInsertObject();
	afx_msg void OnCancelEditCntr();
	afx_msg void OnCharBold();
	afx_msg void OnUpdateCharBold(CCmdUI* pCmdUI);
	afx_msg void OnCharItalic();
	afx_msg void OnUpdateCharItalic(CCmdUI* pCmdUI);
	afx_msg void OnCharUnderline();
	afx_msg void OnUpdateCharUnderline(CCmdUI* pCmdUI);
	afx_msg void OnParaCenter();
	afx_msg void OnUpdateParaCenter(CCmdUI* pCmdUI);
	afx_msg void OnParaLeft();
	afx_msg void OnUpdateParaLeft(CCmdUI* pCmdUI);
	afx_msg void OnParaRight();
	afx_msg void OnUpdateParaRight(CCmdUI* pCmdUI);
	afx_msg void OnBullet();
	afx_msg void OnUpdateBullet(CCmdUI* pCmdUI);
	afx_msg void OnFormatFont();
	afx_msg void OnColorPick(COLORREF cr);
	afx_msg void OnColorDefault();
	afx_msg void OnEditPasteSpecial();
	afx_msg void OnUpdateEditPasteSpecial(CCmdUI* pCmdUI);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnDevModeChange(_In_z_ LPTSTR lpDeviceName);
	//}}AFX_MSG
	afx_msg LRESULT OnFindReplaceCmd(WPARAM, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);

	DECLARE_MESSAGE_MAP()

// Interface Map
public:
	BEGIN_INTERFACE_PART(RichEditOleCallback, IRichEditOleCallback)
		INIT_INTERFACE_PART(CRichEditView, RichEditOleCallback)
		STDMETHOD(GetNewStorage) (LPSTORAGE*);
		STDMETHOD(GetInPlaceContext) (LPOLEINPLACEFRAME*,
									  LPOLEINPLACEUIWINDOW*,
									  LPOLEINPLACEFRAMEINFO);
		STDMETHOD(ShowContainerUI) (BOOL);
		STDMETHOD(QueryInsertObject) (LPCLSID, LPSTORAGE, LONG);
		STDMETHOD(DeleteObject) (LPOLEOBJECT);
		STDMETHOD(QueryAcceptData) (LPDATAOBJECT, CLIPFORMAT*, DWORD,BOOL, HGLOBAL);
		STDMETHOD(ContextSensitiveHelp) (BOOL);
		STDMETHOD(GetClipboardData) (CHARRANGE*, DWORD, LPDATAOBJECT*);
		STDMETHOD(GetDragDropEffect) (BOOL, DWORD, LPDWORD);
		STDMETHOD(GetContextMenu) (WORD, LPOLEOBJECT, CHARRANGE*, HMENU*);
	END_INTERFACE_PART(RichEditOleCallback)

	DECLARE_INTERFACE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CRichEditDoc

class AFX_NOVTABLE CRichEditDoc : public COleServerDoc
{
protected: // create from serialization only
	CRichEditDoc();
	DECLARE_DYNAMIC(CRichEditDoc)

// Attributes
public:
	BOOL m_bRTF; // TRUE when formatted, FALSE when plain text

	virtual CRichEditCntrItem* CreateClientItem(REOBJECT* preo = NULL) const = 0;

	virtual CRichEditView* GetView() const;
	int GetStreamFormat() const;

// Implementation
protected:
	virtual COleServerItem* OnGetEmbeddedItem();
	void MarkItemsClear() const;
	void DeleteUnmarkedItems() const;
	void UpdateObjectCache();
public:
	virtual ~CRichEditDoc() = 0 { }
	BOOL m_bUpdateObjectCache;
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU);
	virtual void SetTitle(LPCTSTR lpszTitle);
	virtual COleClientItem* GetPrimarySelectedItem(CView* pView);
	virtual void DeleteContents();
	virtual POSITION GetStartPosition() const;
	virtual void PreCloseFrame(CFrameWnd* pFrameWnd);
	virtual void UpdateModifiedFlag();
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);
	virtual COleClientItem* GetInPlaceActiveItem(CWnd* pWnd);
	CRichEditCntrItem* LookupItem(LPOLEOBJECT lpobj) const;
	void InvalidateObjectCache();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CRichEditCntrItem

class CRichEditCntrItem : public COleClientItem
{
	DECLARE_SERIAL(CRichEditCntrItem)

// Constructors
public:
	/* explicit */ CRichEditCntrItem(REOBJECT* preo = NULL, CRichEditDoc* pContainer = NULL);
		// Note: pContainer is allowed to be NULL to enable IMPLEMENT_SERIAL.
		//  IMPLEMENT_SERIAL requires the class have a constructor with
		//  zero arguments.  Normally, OLE items are constructed with a
		//  non-NULL document pointer.

// Operations
	void SyncToRichEditObject(REOBJECT& reo);

// Implementation
public:
	~CRichEditCntrItem();
	LPOLECLIENTSITE m_lpClientSite;
	BOOL m_bMark;
	BOOL m_bLock;   // lock it during creation to avoid deletion
	void Mark(BOOL b);
	BOOL IsMarked();
	CRichEditDoc* GetDocument();
	CRichEditView* GetActiveView();
	HRESULT ShowContainerUI(BOOL b);
	HRESULT GetWindowContext(LPOLEINPLACEFRAME* lplpFrame,
		LPOLEINPLACEUIWINDOW* lplpDoc, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	virtual LPOLECLIENTSITE GetClientSite();
	virtual BOOL ConvertTo(REFCLSID clsidNew);
	virtual BOOL ActivateAs(LPCTSTR lpszUserType, REFCLSID clsidOld,
		REFCLSID clsidNew);
	virtual void SetDrawAspect(DVASPECT nDrawAspect);
	virtual void OnDeactivateUI(BOOL bUndoable);
	virtual BOOL CanActivate();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual BOOL OnChangeItemPosition(const CRect& rectPos);
};

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXRICH_INLINE AFX_INLINE
#include <afxrich.inl>
#endif

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRICH_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxshellmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef _SHLOBJ_H_
#include <shlobj.h>
#endif

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

typedef struct _AFX_SHELLITEMINFO
{
	LPSHELLFOLDER  pParentFolder;
	LPITEMIDLIST   pidlFQ;
	LPITEMIDLIST   pidlRel;

	_AFX_SHELLITEMINFO()
	{
		pParentFolder = NULL;
		pidlFQ = NULL;
		pidlRel = NULL;
	}
}
AFX_SHELLITEMINFO, FAR *LPAFX_SHELLITEMINFO;

class CShellManager : public CObject
{
	friend class CMFCShellListCtrl;

// Construction
public:
	CShellManager();
	virtual ~CShellManager();

// Operations
public:
	BOOL BrowseForFolder(CString& strOutFolder, CWnd* pWndParent = NULL, LPCTSTR lplszInitialFolder = NULL,
		LPCTSTR lpszTitle = NULL, UINT ulFlags = BIF_RETURNONLYFSDIRS, LPINT piFolderImage = NULL);

	LPITEMIDLIST CreateItem(UINT cbSize);
	void FreeItem(LPITEMIDLIST pidl);

	UINT GetItemCount(LPCITEMIDLIST pidl);
	UINT GetItemSize(LPCITEMIDLIST pidl);

	LPITEMIDLIST ConcatenateItem(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
	LPITEMIDLIST CopyItem(LPCITEMIDLIST pidlSource);

	LPITEMIDLIST GetNextItem(LPCITEMIDLIST pidl);
	int GetParentItem(LPCITEMIDLIST lpidl, LPITEMIDLIST& lpidlParent);

	HRESULT ItemFromPath(LPCTSTR lpszPath, LPITEMIDLIST& pidl);

protected:
	static int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

// Attributes
protected:
	LPMALLOC m_pMalloc;
	LPCTSTR  m_lpszInitialPath; // Valid in BrowseForFolder only
};

extern CShellManager* afxShellManager;

extern AFX_IMPORT_DATA UINT AFX_WM_ON_AFTER_SHELL_COMMAND;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxrich.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXRICH.H

#pragma once

#ifdef _AFXRICH_INLINE

// CRichEditView
// NOTE: The cast in GetRichEditCtrl is ugly, but must be preserved for compatibility.
// CRichEditCtrl is not related to CRichEditView by inheritance so we must be careful to ensure 
// that CRichEditCtrl remains a binary compatible subset of CRichEditView.
_AFXRICH_INLINE CRichEditCtrl& CRichEditView::GetRichEditCtrl() const
	{ return *(CRichEditCtrl*)this; }
int _AFXRICH_INLINE CRichEditView::GetPrintWidth() const
	{ return m_sizePaper.cx - m_rectMargin.left - m_rectMargin.right;}
CRect _AFXRICH_INLINE CRichEditView::GetPrintRect() const
	{ return CRect(m_rectMargin.left, m_rectMargin.top, m_sizePaper.cx - m_rectMargin.right, m_sizePaper.cy - m_rectMargin.bottom); }
CRect _AFXRICH_INLINE CRichEditView::GetPageRect() const
	{ return CRect(CPoint(0,0), m_sizePaper); }
void _AFXRICH_INLINE CRichEditView::SetPaperSize(CSize sizePaper)
	{ m_sizePaper = sizePaper; }
CSize _AFXRICH_INLINE CRichEditView::GetPaperSize() const
	{ return m_sizePaper; }
void _AFXRICH_INLINE CRichEditView::SetMargins(const CRect& rectMargin)
	{ m_rectMargin = rectMargin; }
CRect _AFXRICH_INLINE CRichEditView::GetMargins() const
	{ return m_rectMargin; }

_AFXRICH_INLINE long CRichEditView::GetTextLength() const
	{ return GetRichEditCtrl().GetTextLength(); }

_AFXRICH_INLINE	long CRichEditView::GetTextLengthEx(DWORD dwFlags, UINT uCodePage) const
	{ return GetRichEditCtrl().GetTextLengthEx(dwFlags, uCodePage); }

_AFXRICH_INLINE CRichEditDoc* CRichEditView::GetDocument() const
{
	AFXASSUME(m_pDocument != NULL);
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CRichEditDoc)));
	return (CRichEditDoc*)m_pDocument;
}
_AFXRICH_INLINE int CRichEditDoc::GetStreamFormat() const
	{ return m_bRTF ? SF_RTF : SF_TEXT; }
_AFXRICH_INLINE void CRichEditDoc::InvalidateObjectCache()
	{ m_bUpdateObjectCache = TRUE; }

_AFXRICH_INLINE void CRichEditCntrItem::Mark(BOOL b)
	{ m_bMark = b; }
_AFXRICH_INLINE BOOL CRichEditCntrItem::IsMarked()
	{ return m_bMark||m_bLock; }
_AFXRICH_INLINE CRichEditDoc* CRichEditCntrItem::GetDocument()
	{ return (CRichEditDoc*)COleClientItem::GetDocument(); }
_AFXRICH_INLINE CRichEditView* CRichEditCntrItem::GetActiveView()
	{ return (CRichEditView*)COleClientItem::GetActiveView(); }
#endif //_AFXRICH_INLINE

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxshelllistctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#include "afxshellmanager.h"
#include "afxlistctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCShellTreeCtrl;

/////////////////////////////////////////////////////////////////////////////
// CMFCShellListCtrl window

class CMFCShellListCtrl : public CMFCListCtrl
{
	friend class CMFCShellTreeCtrl;

	DECLARE_DYNAMIC(CMFCShellListCtrl)

// Construction
public:
	CMFCShellListCtrl();

// Attributes
public:
	enum
	{
		AFX_ShellList_ColumnName = 0,
		AFX_ShellList_ColumnSize = 1,
		AFX_ShellList_ColumnType = 2,
		AFX_ShellList_ColumnModified = 3,
	}
	AFX_ShellListColumns;

	const IShellFolder* GetCurrentShellFolder() const { return m_psfCurFolder; }
	LPITEMIDLIST GetCurrentItemIdList() const { return m_pidlCurFQ; }
	BOOL IsDesktop() const { return m_bIsDesktop; }

protected:
	IShellFolder* m_psfCurFolder;
	LPITEMIDLIST  m_pidlCurFQ;
	SHCONTF       m_nTypes;

	HWND m_hwndRelatedTree;
	BOOL m_bContextMenu;
	BOOL m_bIsDesktop;
	BOOL m_bNoNotify;

	AFX_IMPORT_DATA static IContextMenu2* m_pContextMenu2;

// Operations
public:
	BOOL GetItemPath(CString& strPath, int iItem) const;
	BOOL GetCurrentFolder(CString& strPath) const;
	BOOL GetCurrentFolderName(CString& strName) const;

	virtual HRESULT Refresh();
	virtual HRESULT DisplayFolder(LPCTSTR lpszPath);
	virtual HRESULT DisplayFolder(LPAFX_SHELLITEMINFO lpItemInfo);
	virtual HRESULT DisplayParentFolder();

	void SetItemTypes(SHCONTF nTypes);
	SHCONTF GetItemTypes() const { return m_nTypes; }

	void EnableShellContextMenu(BOOL bEnable = TRUE);

// Overrides
	virtual void OnSetColumns();
	virtual CString OnGetItemText(int iItem, int iColumn, LPAFX_SHELLITEMINFO pItem);
	virtual int OnGetItemIcon(int iItem, LPAFX_SHELLITEMINFO pItem);

	virtual void OnFormatFileSize(__int64 lFileSize, CString& str);
	virtual void OnFormatFileDate(const CTime& tmFile, CString& str);

	virtual int OnCompareItems(LPARAM lParam1, LPARAM lParam2, int iColumn);

protected:
	virtual void PreSubclassWindow();
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CMFCShellListCtrl();

protected:
	//{{AFX_MSG(CMFCShellListCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblClk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnReturn(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	HIMAGELIST GetShellImageList(BOOL bLarge);
	HRESULT LockCurrentFolder(LPAFX_SHELLITEMINFO pItemInfo);
	void ReleaseCurrFolder();

	virtual HRESULT EnumObjects(LPSHELLFOLDER pParentFolder, LPITEMIDLIST pidlParent);
	virtual void DoDefault(int iItem);

	BOOL InitList();
	CMFCShellTreeCtrl* GetRelatedTree() const;
};

extern AFX_IMPORT_DATA UINT AFX_WM_CHANGE_CURRENT_FOLDER;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsmartdockinghighlighterwnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CSmartDockingHighlighterWnd window

class CSmartDockingHighlighterWnd : public CWnd
{
	friend class CSmartDockingManager;

	// Construction
public:
	CSmartDockingHighlighterWnd();
	void Create(CWnd* pwndOwner);

	void SetDockingWnd(CWnd* pDockingWnd)
	{
		m_pDockingWnd = pDockingWnd;
	}

	void ShowAt(CRect rect);
	void ShowTabbedAt(CRect rect, CRect rectTab);
	void Hide();

	// Attributes
protected:
	CWnd* m_pWndOwner;
	CWnd* m_pDockingWnd;
	CRect m_rectLast;
	CRect m_rectTab;
	BOOL  m_bTabbed;
	BOOL  m_bShown;
	BOOL  m_bUseThemeColorInShading;

	// Implementation
public:
	virtual ~CSmartDockingHighlighterWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CSmartDockingHighlighterWnd)
	afx_msg void OnPaint();
	afx_msg void OnClose();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsmartdockingguide.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CSmartDockingInfo;

class CSmartDockingStandaloneGuideWnd : public CWnd
{
// Construction
public:
	CSmartDockingStandaloneGuideWnd();
	virtual ~CSmartDockingStandaloneGuideWnd();

	BOOL Create(LPRECT pWndRect, HBITMAP hbmpFace, HRGN hrgnShape, CWnd* pwndOwner, BOOL bIsDefaultImage, BOOL bIsVert);
	BOOL Assign(HBITMAP hbmpFace, BOOL bRedraw);
	void Highlight(BOOL bSet);
	void UpdateLayered();

// Attributes
protected:
	HBITMAP  m_hbmpFace;
	COLORREF m_clrFrame;
	BOOL     m_bIsDefaultImage;
	BOOL     m_bIsHighlighted;
	BOOL     m_bIsVert;

// Overrides
protected:
	//{{AFX_MSG(CSmartDockingStandaloneGuideWnd)
	afx_msg void OnPaint();
	afx_msg void OnClose();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CSmartDockingStandaloneGuide : public CObject
{
public:
	enum SDMarkerPlace
	{
		sdNONE = -1,

		sdLEFT,
		sdRIGHT,
		sdTOP,
		sdBOTTOM,

		sdCLEFT,
		sdCRIGHT,
		sdCTOP,
		sdCBOTTOM,
		sdCMIDDLE,
	};

	CSmartDockingStandaloneGuide();
	virtual ~CSmartDockingStandaloneGuide();

	virtual void Create(SDMarkerPlace nSideNo, CWnd* pwndOwner);
	virtual void Destroy();

	virtual void Show(BOOL bShow = TRUE);        // show or hide marker
	virtual void AdjustPos(CRect rcHost);        // adjust marker position to the host rectangle (in screen coords)
	virtual void Highlight(BOOL bHiLite = TRUE); // highlight the marker
	virtual BOOL IsPtIn(CPoint point) const;     // discover if a point (in screen coords) lies within marker

protected:
	virtual void InitImages(CSmartDockingInfo& params);

	SDMarkerPlace  m_nSideNo;
	CSmartDockingStandaloneGuideWnd  m_wndBmp;
	CMFCToolBarImages m_Image;
	CMFCToolBarImages m_ImageHot;

	CRgn m_Rgn;
	int  m_cx;
	int  m_cy;
	BOOL m_bHiLited;
	BOOL m_bLayered;
	BOOL m_bIsDefaultImage;

	AFX_IMPORT_DATA static const int m_nLeftOffsetX;
	AFX_IMPORT_DATA static const int m_nRightOffsetX;
	AFX_IMPORT_DATA static const int m_nTopOffsetY;
	AFX_IMPORT_DATA static const int m_nBottomOffsetY;

	DECLARE_DYNCREATE(CSmartDockingStandaloneGuide)
};

class CSmartDockingGroupGuidesManager;

class CSmartDockingGroupGuidesWnd : public CWnd
{
	friend class CSmartDockingGroupGuidesManager;

protected:
	CSmartDockingGroupGuidesWnd();

public:
	void Update ();

	afx_msg void OnPaint();
	afx_msg void OnClose();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	DECLARE_MESSAGE_MAP()

protected:
	CSmartDockingGroupGuidesManager* m_pCentralGroup;
	CBrush m_brBaseBackground;
	CBrush m_brBaseBorder;
};

class CSmartDockingGroupGuide : public CSmartDockingStandaloneGuide
{
public:
	CSmartDockingGroupGuide();
	virtual ~CSmartDockingGroupGuide();

	virtual void Create(SDMarkerPlace nSideNo, CWnd* pwndOwner);
	virtual void Destroy();

	virtual void Show(BOOL bShow = TRUE);        // show or hide marker
	virtual void AdjustPos(CRect rcHost);        // adjust marker position to the host rectangle (in screen coords)
	virtual void Highlight(BOOL bHiLite = TRUE); // highlight the marker
	virtual BOOL IsPtIn(CPoint point) const;     // discover if a point (in screen coords) lies within marker

	void SetVisible(BOOL bVisible = TRUE, BOOL bRedraw = TRUE);
	BOOL IsVisible() const { return m_bVisible; }

protected:
	virtual void Create(SDMarkerPlace nSideNo, CSmartDockingGroupGuidesManager* pCentralGroup);
	virtual void DestroyImages();

	virtual void Draw(CDC& dc, BOOL bAlpha = FALSE);

	CSmartDockingGroupGuidesManager* m_pCentralGroup;
	COLORREF m_clrFrame;
	CPen m_penFrame;
	CPen m_penHighlight;
	int  m_nOffsetX;
	int  m_nOffsetY;
	BOOL m_bVisible;

	friend class CSmartDockingGroupGuidesManager;
};

class CSmartDockingGroupGuidesManager : public CObject
{
public:
	CSmartDockingGroupGuidesManager();
	virtual ~CSmartDockingGroupGuidesManager();

	virtual void Create(CWnd* pwndOwner);
	virtual void Destroy();
	virtual void Show(BOOL bShow = TRUE);   // show or hide group

	// adjust group position to the host rectangle (in screen coords)
	// middle marker: nMiddleIsOn == -1 no change, 0 off, 1 on
	virtual BOOL AdjustPos(CRect rcHost, int nMiddleIsOn = -1);

	void ShowGuide(CSmartDockingStandaloneGuide::SDMarkerPlace nMarkerNo, BOOL bShow = TRUE, BOOL bRedraw = TRUE);

	// fetch markers' interfaces (0 - left, 1 - right, 2 - top, 3 - bottom, 4 - middle)
	virtual CSmartDockingGroupGuide* GetGuide(CSmartDockingStandaloneGuide::SDMarkerPlace nMarkerNo)
	{
		if (nMarkerNo < CSmartDockingStandaloneGuide::sdCLEFT || nMarkerNo > CSmartDockingStandaloneGuide::sdCMIDDLE)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return &m_arMarkers [nMarkerNo - CSmartDockingStandaloneGuide::sdCLEFT];
	}

	void GetWindowRect(CRect& rect);

	DECLARE_DYNCREATE(CSmartDockingGroupGuidesManager)

protected:
	CSmartDockingGroupGuidesWnd m_Wnd;

	CSmartDockingGroupGuide m_arMarkers [5];

	CMFCToolBarImages m_Image;

	CRgn m_rgnBase;
	BOOL m_bCreated;
	BOOL m_bMiddleIsOn;
	BOOL m_bLayered;

	friend class CSmartDockingGroupGuidesWnd;
	friend class CSmartDockingGroupGuide;
	friend class CSmartDockingManager;

	void DrawCentralGroupGuides(CDC& dc, CBrush& brBaseBackground, CBrush& brBaseBorder, CRect rectClient);
};

// provide window class name for specified class style
template <DWORD WndStyle>
LPCTSTR GetSmartDockingWndClassName()
{
	static CString strSDWndClassName;
	if (strSDWndClassName.IsEmpty ())
	{
		strSDWndClassName = AfxRegisterWndClass(WndStyle);
	}

	return strSDWndClassName;
}

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxshowallbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCShowAllButton : public  CMFCToolBarMenuButton
{
	DECLARE_DYNCREATE(CMFCShowAllButton)

public:
	CMFCShowAllButton();
	virtual ~CMFCShowAllButton();

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual BOOL OpenPopupMenu(CWnd* pWnd = NULL);
	virtual BOOL OnToolHitTest(const CWnd* pWnd, TOOLINFO* pTI);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxshelltreectrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxshellmanager.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCShellListCtrl;

/////////////////////////////////////////////////////////////////////////////
// CMFCShellTreeCtrl window

class CMFCShellTreeCtrl : public CTreeCtrl
{
	friend class CMFCShellListCtrl;

	DECLARE_DYNAMIC(CMFCShellTreeCtrl)

// Construction
public:
	CMFCShellTreeCtrl();

// Attributes
public:
	BOOL GetItemPath(CString& strPath, HTREEITEM htreeItem = NULL /* NULL - selected */) const;
	CMFCShellListCtrl* GetRelatedList() const;

	// Flags are same as in IShellFolder::EnumObjects
	DWORD GetFlags() const { return m_dwFlags; }
	void SetFlags(DWORD dwFlags, BOOL bRefresh = TRUE);

// Operations
public:
	void Refresh();
	BOOL SelectPath(LPCTSTR lpszPath);
	BOOL SelectPath(LPCITEMIDLIST lpidl);

	void EnableShellContextMenu(BOOL bEnable = TRUE);

	void SetRelatedList(CMFCShellListCtrl* pShellList);

// Overrides
public:
	virtual CString OnGetItemText(LPAFX_SHELLITEMINFO pItem);
	virtual int OnGetItemIcon(LPAFX_SHELLITEMINFO pItem, BOOL bSelected);

public:
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);

protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCShellTreeCtrl();

protected:
	//{{AFX_MSG(CMFCShellTreeCtrl)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnItemexpanding(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

	BOOL GetRootItems();
	BOOL GetChildItems(HTREEITEM hParentItem);
	virtual HRESULT EnumObjects(HTREEITEM hParentItem, LPSHELLFOLDER pParentFolder, LPITEMIDLIST pidlParent);
	void OnShowContextMenu(CPoint point);
	void InitTree();

	static int CALLBACK CompareProc(LPARAM, LPARAM, LPARAM);

	AFX_IMPORT_DATA static IContextMenu2* m_pContextMenu2;

	BOOL  m_bContextMenu;
	BOOL  m_bNoNotify;
	HWND  m_hwndRelatedList;
	DWORD m_dwFlags;  // Flags for IShellFolder::EnumObjects
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsmartdockingmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxsmartdockingguide.h"
#include "afxsmartdockinghighlighterwnd.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CSmartDockingManager : public CObject
{
public:
	CSmartDockingManager();
	virtual ~CSmartDockingManager();

	// create/destroy the manager
	void Create(CWnd* pwndOwner, CRuntimeClass* prtMarker = NULL, CRuntimeClass* prtCentralGroup = NULL);
	void Destroy();

	// start/stop smart-docking action
	void Start(CWnd* pDockingWnd);
	void Stop();

	// show/hide smart-docking markers (typically while Ctrl-key is held)
	void Show(BOOL bShow = TRUE);

	// get currently highlighted marker number
	CSmartDockingStandaloneGuide::SDMarkerPlace GetHighlightedGuideNo() const { return m_nHiliteSideNo; }

	BOOL IsStarted() { return m_bCreated && m_bStarted; }

	// react to mouse move
	void OnMouseMove(CPoint point);

	// react to mainframe's position change
	void OnPosChange();

	// set owner's outer docking rectangle (in screen coords)
	void SetOuterRect(CRect rcOuter);

	// move central group to new position
	// middle marker: nMiddleIsOn == -1 no change, 0 off, 1 on
	void MoveCentralGroup(CRect rect, int nMiddleIsOn = -1, DWORD dwEnabledAlignment = CBRS_ALIGN_ANY);
	void ShowCentralGroup(BOOL bShow = TRUE, DWORD dwEnabledAlignment = CBRS_ALIGN_ANY);

	// marker place
	void ShowPlaceAt(CRect rect);
	void HidePlace();
	void ShowTabbedPlaceAt(CRect rect, int nTabXOffset, int nTabWidth, int nTabHeight);

	CWnd* GetOwner() const { return m_pwndOwner; };

	void CauseCancelMode();

protected:
	// state flags
	BOOL   m_bStarted;
	BOOL   m_bCreated;
	BOOL   m_bShown;
	BOOL   m_bCentralGroupShown;
	CWnd*  m_pwndOwner;          // mainframe
	CWnd*  m_pDockingWnd;        // miniframe being docked
	DWORD  m_dwEnabledAlignment; // enabled alignment of embedded docking bar
	CRect  m_rcOuter;            // outer rectangle

	CSmartDockingHighlighterWnd m_wndPlaceMarker; // place marker
	CSmartDockingStandaloneGuide*        m_arMarkers [9];
	CSmartDockingGroupGuidesManager*  m_pCentralGroup;

	CSmartDockingStandaloneGuide::SDMarkerPlace m_nHiliteSideNo; // currently highlighted marker
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsock.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXSOCK.H

#pragma once

#ifdef _AFXSOCK_INLINE

_AFXSOCK_INLINE CAsyncSocket::operator SOCKET() const
	{ return m_hSocket; }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
	{ return (SOCKET_ERROR != getpeername(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
	{ return (SOCKET_ERROR != getsockname(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel)
	{ return (SOCKET_ERROR != setsockopt(m_hSocket, nLevel, nOptionName, (LPCSTR)lpOptionValue, nOptionLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel)
	{ return (SOCKET_ERROR != getsockopt(m_hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen)); }
_AFXSOCK_INLINE CAsyncSocket* PASCAL CAsyncSocket::FromHandle(SOCKET hSocket)
	{ return CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE int PASCAL CAsyncSocket::GetLastError()
	{ return WSAGetLastError(); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen)
	{ return (SOCKET_ERROR != bind(m_hSocket, lpSockAddr, nSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
	{ return ConnectHelper(lpSockAddr, nSockAddrLen); }
_AFXSOCK_INLINE BOOL CAsyncSocket::IOCtl(long lCommand, DWORD* lpArgument)
	{ return (SOCKET_ERROR != ioctlsocket(m_hSocket, lCommand, lpArgument)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Listen(int nConnectionBacklog)
	{ return (SOCKET_ERROR != listen(m_hSocket, nConnectionBacklog)); }
_AFXSOCK_INLINE int CAsyncSocket::ReceiveFrom(void* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
	{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }
_AFXSOCK_INLINE BOOL CAsyncSocket::ShutDown(int nHow)
	{ return (SOCKET_ERROR != shutdown(m_hSocket,nHow)); }
_AFXSOCK_INLINE int CAsyncSocket::SendTo(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
	{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }

_AFXSOCK_INLINE BOOL CSocket::Create(UINT nSocketPort, int nSocketType, LPCTSTR lpszSocketAddress)
	{ return CAsyncSocket::Create(nSocketPort, nSocketType, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE, lpszSocketAddress); }
_AFXSOCK_INLINE BOOL CSocket::IsBlocking()
	{ return (m_pbBlocking != NULL); }
_AFXSOCK_INLINE CSocket* PASCAL CSocket::FromHandle(SOCKET hSocket)
	{ return (CSocket*)CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE BOOL CSocket::Attach(SOCKET hSocket)
		{ return CAsyncSocket::Attach(hSocket); }

#endif //_AFXSOCK_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsound.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_SOUND_NOT_STARTED  (-2)
#define AFX_SOUND_TERMINATE    (-1)
#define AFX_SOUND_IDLE           0
#define AFX_SOUND_MENU_COMMAND   1
#define AFX_SOUND_MENU_POPUP     2

void AFXPlaySystemSound(int nSound);

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsock.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXSOCK_H__
#define __AFXSOCK_H__

#pragma once

#ifdef _AFX_NO_SOCKET_SUPPORT
	#error Windows Sockets classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#if _WIN32_WINNT >= 0x0502
	#include <atlsocket.h>
#else
    #include <winsock2.h>
    #include <mswsock.h>
#endif  // _WIN32_WINNT

#ifndef _WINSOCK2API_
#ifdef _WINSOCKAPI_
	#error MFC requires use of Winsock2.h
#endif


#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef _AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "wsock32.lib")

#endif //!_AFX_NOFORCE_LIBS

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

/////////////////////////////////////////////////////////////////////////////
// AFXSOCK - MFC support for Windows Sockets

// Classes declared in this file

	// CObject
		class CAsyncSocket; // Async Socket implementation and
							// base class for Synchronous Socket
			class CSocket;  // Synchronous Socket

	// CFile
		class CSocketFile; // Used with CSocket and CArchive for
						   // streaming objects on sockets.

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFX_DATA
#define AFX_DATA AFX_NET_DATA

/////////////////////////////////////////////////////////////////////////////
// CSocketWnd -- internal use only
//  Implementation for sockets notification callbacks.
//  Future versions of MFC may or may not include this exact class.

class CSocketWnd : public CWnd
{
// Construction
public:
	CSocketWnd();

protected:
	//{{AFX_MSG(CSocketWnd)
	LRESULT OnSocketNotify(WPARAM wParam, LPARAM lParam);
	LRESULT OnSocketDead(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket

class CAsyncSocket : public CObject
{
	DECLARE_DYNAMIC(CAsyncSocket);
private:
	CAsyncSocket(const CAsyncSocket& rSrc);    // no implementation
	void operator=(const CAsyncSocket& rSrc);  // no implementation

// Construction
public:
	CAsyncSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		LPCTSTR lpszSocketAddress = NULL);

#if _WIN32_WINNT >= 0x0502
	BOOL CreateEx(ADDRINFOT* pAI, 
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
#endif  // _WIN32_WINNT

// Attributes
public:
	SOCKET m_hSocket;

	operator SOCKET() const;
	BOOL Attach(SOCKET hSocket, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
	SOCKET Detach();

	BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
#if _WIN32_WINNT >= 0x0502
	BOOL GetPeerNameEx(CString& rPeerAddress, UINT& rPeerPort);	
#endif  // _WIN32_WINNT

	BOOL GetSockName(CString& rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
#if _WIN32_WINNT >= 0x0502
	BOOL GetSockNameEx(CString& rSocketAddress, UINT& rSocketPort);
#endif  // _WIN32_WINNT

	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue,
		int nOptionLen, int nLevel = SOL_SOCKET);
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue,
		int* lpOptionLen, int nLevel = SOL_SOCKET);

	static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket);
	static int PASCAL GetLastError();

// Operations
public:

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress = NULL);
	BOOL Bind (const SOCKADDR* lpSockAddr, int nSockAddrLen);
#if _WIN32_WINNT >= 0x0502
	BOOL BindEx(ADDRINFOT* pAI);
#endif  // _WIN32_WINNT

	virtual void Close();

	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);
#if _WIN32_WINNT >= 0x0502
	BOOL ConnectEx(ADDRINFOT* pAI);
#endif  // _WIN32_WINNT

	BOOL IOCtl(long lCommand, DWORD* lpArgument);

	BOOL Listen(int nConnectionBacklog=5);

	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	int ReceiveFrom(void* lpBuf, int nBufLen,
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0);
#if _WIN32_WINNT >= 0x0502
	int ReceiveFromEx(void* lpBuf, int nBufLen,
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
#endif  // _WIN32_WINNT

	enum { receives = 0, sends = 1, both = 2 };
	BOOL ShutDown(int nHow = sends);

	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendTo(const void* lpBuf, int nBufLen,
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0);
#if _WIN32_WINNT >= 0x0502
	int SendToEx(const void* lpBuf, int nBufLen,
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
#endif  // _WIN32_WINNT

	BOOL AsyncSelect(long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

// Overridable callbacks
protected:
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);
	virtual void OnOutOfBandData(int nErrorCode);
	virtual void OnAccept(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnClose(int nErrorCode);

// Implementation
public:
	virtual ~CAsyncSocket();

	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead = FALSE);
	static void PASCAL DetachHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL KillSocket(SOCKET hSocket, CAsyncSocket* pSocket);
	static void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);

	BOOL Socket(int nSocketType=SOCK_STREAM, long lEvent =
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		int nProtocolType = 0, int nAddressFormat = PF_INET);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	friend class CSocketWnd;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
};

/////////////////////////////////////////////////////////////////////////////
// CSocket

class CSocket : public CAsyncSocket
{
	DECLARE_DYNAMIC(CSocket);
private:
	CSocket(const CSocket& rSrc);         // no implementation
	void operator=(const CSocket& rSrc);  // no implementation

// Construction
public:
	CSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM,
		LPCTSTR lpszSocketAddress = NULL);

// Attributes
public:
	BOOL IsBlocking();
	static CSocket* PASCAL FromHandle(SOCKET hSocket);
	BOOL Attach(SOCKET hSocket);

// Operations
public:
	void CancelBlockingCall();

// Overridable callbacks
protected:
	virtual BOOL OnMessagePending();

// Implementation
public:
	int m_nTimeOut;

	virtual ~CSocket();

	static int PASCAL ProcessAuxQueue();

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	int SendChunk(const void* lpBuf, int nBufLen, int nFlags);

protected:
	friend class CSocketWnd;

	BOOL* m_pbBlocking;
	int m_nConnectError;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);

	static void PASCAL AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam);

	virtual BOOL PumpMessages(UINT uStopFlag);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSocketFile

class CSocketFile : public CFile
{
	DECLARE_DYNAMIC(CSocketFile)
public:
//Constructors
	explicit CSocketFile(CSocket* pSocket, BOOL bArchiveCompatible = TRUE);

// Implementation
public:
	CSocket* m_pSocket;
	BOOL m_bArchiveCompatible;

	virtual ~CSocketFile();

	virtual UINT GetBufferPtr(UINT nCommand, UINT nCount, void** ppBufStart,
		void** ppBufMax);
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual UINT Read(void* lpBuf, UINT nCount);
	virtual void Write(const void* lpBuf, UINT nCount);
	virtual void Close();

// Unsupported APIs
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL);
	virtual CFile* Duplicate() const;
	virtual ULONGLONG GetPosition() const;
	virtual ULONGLONG Seek(LONGLONG lOff, UINT nFrom);
	virtual void SetLength(ULONGLONG dwNewLen);
	virtual ULONGLONG GetLength() const;
	virtual void LockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void UnlockRange(ULONGLONG dwPos, ULONGLONG dwCount);
	virtual void Flush();
	virtual void Abort();
};

/////////////////////////////////////////////////////////////////////////////
// Global functions

BOOL AFXAPI AfxSocketInit(WSADATA* lpwsaData = NULL);
void AFXAPI AfxSocketTerm();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_ENABLE_INLINES
#define _AFXSOCK_INLINE AFX_INLINE
#include <afxsock.inl>
#undef _AFXSOCK_INLINE
#endif

#if _WIN32_WINNT >= 0x0502

inline BOOL CAsyncSocket::CreateEx(ADDRINFOT* pAI, long lEvent)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Socket(pAI->ai_socktype, lEvent, pAI->ai_protocol, pAI->ai_family);
}

inline BOOL CAsyncSocket::BindEx(ADDRINFOT* pAI)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Bind((SOCKADDR*)pAI->ai_addr, (int)pAI->ai_addrlen);
}

inline BOOL CAsyncSocket::ConnectEx(ADDRINFOT* pAI)
{
	if (pAI == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return FALSE;
	}
	return Connect((SOCKADDR*)pAI->ai_addr, (int)pAI->ai_addrlen);
}

inline BOOL CAsyncSocket::GetPeerNameEx(CString& rPeerAddress, UINT& rPeerPort)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetPeerName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		char szName[NI_MAXHOST];
		bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rPeerAddress = szName;
			rPeerPort = ntohs(SS_PORT(&sockAddr));
			bResult = TRUE;
		}
		else
		{
			bResult = FALSE;
		}
	}
	return bResult;
}

inline BOOL CAsyncSocket::GetSockNameEx(CString& rSocketAddress, UINT& rSocketPort)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetSockName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		char szName[NI_MAXHOST];
		bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rSocketAddress = szName;
			rSocketPort = ntohs(SS_PORT(&sockAddr));
		}
	}
	return bResult;
}

inline int CAsyncSocket::ReceiveFromEx(void* lpBuf, int nBufLen, CString& rSocketAddress, UINT& rSocketPort, int nFlags)
{
	SOCKADDR_STORAGE sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	int nResult = ReceiveFrom(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, &nSockAddrLen, nFlags);
	if(nResult != SOCKET_ERROR)
	{
		char szName[NI_MAXHOST];
		BOOL bResult = getnameinfo(
			(SOCKADDR*)&sockAddr, nSockAddrLen, szName, NI_MAXHOST, NULL, 0, 0);
		if (!bResult)
		{
			rSocketAddress = szName;
			rSocketPort = ntohs(SS_PORT(&sockAddr));
		}
	}
	return nResult;
}

inline int CAsyncSocket::SendToEx(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress, int nFlags)
{
	if (lpszHostAddress == NULL)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;
	}
	
	SOCKADDR_STORAGE sockAddrSelf;
	memset(&sockAddrSelf, 0, sizeof(sockAddrSelf));

	int nSockAddrSelfLen = sizeof(sockAddrSelf);

	BOOL bResult = GetSockName((SOCKADDR*)&sockAddrSelf, &nSockAddrSelfLen);
	if (!bResult)
	{
		WSASetLastError(WSAEINVAL);
		return SOCKET_ERROR;		
	}
	
	int nSocketType;
	int nSocketTypeLen = int(sizeof(int));
	if (!GetSockOpt(SO_TYPE, &nSocketType, &nSocketTypeLen))
	{
		return SOCKET_ERROR;
	}

	ATL::CSocketAddr sockAddr;
	int nRet = sockAddr.FindAddr(lpszHostAddress, nHostPort, 0, sockAddrSelf.ss_family, nSocketType, 0);
	if (nRet != 0)
	{
		WSASetLastError(nRet);
		return SOCKET_ERROR;
	}
	
	ADDRINFOT *p = sockAddr.GetAddrInfo();

	return SendTo(lpBuf, nBufLen, p->ai_addr, (int)p->ai_addrlen, nFlags);
}

#endif  // _WIN32_WINNT

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif // __AFXSOCK_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxstandardcolorspropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcolorpickerctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCColorDialog;

/////////////////////////////////////////////////////////////////////////////
// CMFCStandardColorsPropertyPage dialog

class CMFCStandardColorsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCStandardColorsPropertyPage)

// Construction
public:
	CMFCStandardColorsPropertyPage();

	CMFCColorDialog* m_pDialog;

// Dialog Data
	//{{AFX_DATA(CMFCStandardColorsPropertyPage)
	enum { IDD = IDD_AFXBARRES_COLOR_PAGE_ONE };
	CMFCColorPickerCtrl m_hexpicker;
	CMFCColorPickerCtrl m_hexpicker_greyscale;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	friend void hexfunc(COLORREF ref,DWORD ClientData);
	friend void hexfunc(COLORREF ref,void *ClientData);
	
	friend void hexgreyscalefunc(COLORREF ref,DWORD ClientData);
	friend void hexgreyscalefunc(COLORREF ref,void *ClientData);

	// Generated message map functions
	//{{AFX_MSG(CMFCStandardColorsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnGreyscale();
	afx_msg void OnHexColor();
	afx_msg void OnDoubleClickedColor();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	void AdjustControlWidth (CMFCColorPickerCtrl* pControl, int cx);
	int	m_nColorPickerOffset;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxspinbuttonctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCSpinButtonCtrl window

class CMFCSpinButtonCtrl : public CSpinButtonCtrl
{
// Construction
public:
	CMFCSpinButtonCtrl();

// Attributes
protected:
	BOOL m_bIsButtonPressedUp;
	BOOL m_bIsButtonPressedDown;
	BOOL m_bIsButtonHighligtedUp;
	BOOL m_bIsButtonHighligtedDown;
	BOOL m_bTracked;

// Overrides
public:
	virtual void OnDraw(CDC* pDC);

// Implementation
public:
	virtual ~CMFCSpinButtonCtrl();

protected:
	//{{AFX_MSG(CMFCSpinButtonCtrl)
	afx_msg void OnPaint();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxsplitterwndex.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

//
// CSplitterWndEx window

class CSplitterWndEx : public CSplitterWnd
{
	DECLARE_DYNAMIC(CSplitterWndEx)

// Construction
public:
	CSplitterWndEx();

// Overrides
	virtual void OnDrawSplitter(CDC* pDC, ESplitType nType, const CRect& rect);

// Implementation
public:
	virtual ~CSplitterWndEx();

protected:
	//{{AFX_MSG(CSplitterWndEx)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxstat_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXSTATE_H__
#define __AFXSTATE_H__

#pragma once


#ifndef __ATLTYPES_H__
#include <atltypes.h>
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef __AFXTLS_H__
	#include <afxtls_.h>
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// _AFX_DEBUG_STATE

#ifdef _DEBUG

class _AFX_DEBUG_STATE : public CNoTrackObject
{
public:
	_AFX_DEBUG_STATE();
	virtual ~_AFX_DEBUG_STATE();
};

EXTERN_PROCESS_LOCAL(_AFX_DEBUG_STATE, afxDebugState)

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// _AFX_WIN_STATE

#undef AFX_DATA
#define AFX_DATA

class _AFX_WIN_STATE : public CNoTrackObject
{
public:
	// printing abort
	BOOL m_bUserAbort;
};

EXTERN_PROCESS_LOCAL(_AFX_WIN_STATE, _afxWinState)

/////////////////////////////////////////////////////////////////////////////
// Type library cache - AFX_INTERNAL

#ifndef _AFX_NO_OLE_SUPPORT

struct ITypeInfo;
typedef ITypeInfo* LPTYPEINFO;

struct ITypeLib;
typedef ITypeLib* LPTYPELIB;

typedef struct _GUID GUID;
#ifndef _REFCLSID_DEFINED
#define REFGUID const GUID &
#endif

class CTypeLibCache
{
public:
	CTypeLibCache() : m_cRef(0), m_lcid((LCID)-1), m_ptlib(NULL), m_ptinfo(NULL) {}
	void Lock();
	void Unlock();
	BOOL Lookup(LCID lcid, LPTYPELIB* pptlib);
	void Cache(LCID lcid, LPTYPELIB ptlib);
	BOOL LookupTypeInfo(LCID lcid, REFGUID guid, LPTYPEINFO* pptinfo);
	void CacheTypeInfo(LCID lcid, REFGUID guid, LPTYPEINFO ptinfo);
	const GUID* m_pTypeLibID;

protected:
	LCID m_lcid;
	LPTYPELIB m_ptlib;
	GUID m_guidInfo;
	LPTYPEINFO m_ptinfo;
	long m_cRef;
};

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// AFX_MODULE_STATE : portion of state that is pushed/popped

// forward references required for AFX_MODULE_THREAD_STATE definition
class CWinThread;
class CHandleMap;
class CFrameWnd;
class CToolTipCtrl;
class CControlBar;
class CWnd;

#ifndef _PNH_DEFINED
typedef int (__cdecl * _PNH)( size_t );
#define _PNH_DEFINED
#endif

template<class TYPE> 
class CEmbeddedButActsLikePtr
{
public:
	AFX_INLINE TYPE* operator->() { return &m_data; }
	AFX_INLINE operator TYPE*() { return &m_data; }
	TYPE m_data;
};

// AFX_MODULE_THREAD_STATE (local to thread *and* module)
class AFX_MODULE_THREAD_STATE : public CNoTrackObject
{
public:
	AFX_MODULE_THREAD_STATE();
	virtual ~AFX_MODULE_THREAD_STATE();

	// current CWinThread pointer
	CWinThread* m_pCurrentWinThread;

	// list of CFrameWnd objects for thread
	CTypedSimpleList<CFrameWnd*> m_frameList;

	// temporary/permanent map state
	DWORD m_nTempMapLock;           // if not 0, temp maps locked
	CHandleMap* m_pmapHWND;
	CHandleMap* m_pmapHMENU;
	CHandleMap* m_pmapHDC;
	CHandleMap* m_pmapHGDIOBJ;
	CHandleMap* m_pmapHIMAGELIST;

	// thread-local MFC new handler (separate from C-runtime)
	_PNH m_pfnNewHandler;

#ifndef _AFX_NO_SOCKET_SUPPORT
	// WinSock specific thread state
	HWND m_hSocketWindow;
#ifdef _AFXDLL
	CEmbeddedButActsLikePtr<CMapPtrToPtr> m_pmapSocketHandle;
	CEmbeddedButActsLikePtr<CMapPtrToPtr> m_pmapDeadSockets;
	CEmbeddedButActsLikePtr<CPtrList> m_plistSocketNotifications;
#else
	CMapPtrToPtr* m_pmapSocketHandle;
	CMapPtrToPtr* m_pmapDeadSockets;
	CPtrList* m_plistSocketNotifications;
#endif
#endif

	// common controls thread state
	CToolTipCtrl* m_pToolTip;
	CWnd* m_pLastHit;       // last window to own tooltip
	INT_PTR m_nLastHit;         // last hittest code
	TOOLINFO* m_pLastInfo;    // last TOOLINFO structure
	INT_PTR m_nLastStatus;      // last flyby status message
	CControlBar* m_pLastStatus; // last flyby status control bar
};

// forward references required for AFX_MODULE_STATE definition
class CWinApp;
class COleObjectFactory;

class CWnd;

#ifdef _AFXDLL
class CDynLinkLibrary;
#endif

#ifndef _AFX_NO_OCC_SUPPORT
class COccManager;
class COleControlLock;
#endif

#ifndef _AFX_NO_DAO_SUPPORT
class _AFX_DAO_STATE;
#endif

class CDllIsolationWrapperBase;
#ifndef _AFX_NO_AFXCMN_SUPPORT
class CComCtlWrapper;
#endif
class CCommDlgWrapper;

class CTypeLibCacheMap : public CMapPtrToPtr
{
public:
	virtual void RemoveAll(void* pExcept);
};


// AFX_MODULE_STATE (global data for a module)
class AFX_MODULE_STATE : public CNoTrackObject
{
public:
#ifdef _AFXDLL
	AFX_MODULE_STATE(BOOL bDLL, WNDPROC pfnAfxWndProc, DWORD dwVersion,
		BOOL bSystem = FALSE);
#else
	explicit AFX_MODULE_STATE(BOOL bDLL);
#endif
	~AFX_MODULE_STATE();

	CWinApp* m_pCurrentWinApp;
	HINSTANCE m_hCurrentInstanceHandle;
	HINSTANCE m_hCurrentResourceHandle;
	LPCTSTR m_lpszCurrentAppName;
	BYTE m_bDLL;    // TRUE if module is a DLL, FALSE if it is an EXE
	BYTE m_bSystem; // TRUE if module is a "system" module, FALSE if not
	BYTE m_bReserved[2]; // padding

	DWORD m_fRegisteredClasses; // flags for registered window classes

	// runtime class data
#ifdef _AFXDLL
	CRuntimeClass* m_pClassInit;
#endif
	CTypedSimpleList<CRuntimeClass*> m_classList;

	// OLE object factories
#ifndef _AFX_NO_OLE_SUPPORT
#ifdef _AFXDLL
	COleObjectFactory* m_pFactoryInit;
#endif
	CTypedSimpleList<COleObjectFactory*> m_factoryList;
#endif
	// number of locked OLE objects
	long m_nObjectCount;
	BOOL m_bUserCtrl;

	// AfxRegisterClass and AfxRegisterWndClass data

	CString m_strUnregisterList;

#ifdef _AFXDLL
	WNDPROC m_pfnAfxWndProc;
	DWORD m_dwVersion;  // version that module linked against
#endif

	// variables related to a given process in a module
	//  (used to be AFX_MODULE_PROCESS_STATE)
	void (PASCAL *m_pfnFilterToolTipMessage)(MSG*, CWnd*);

#ifdef _AFXDLL
	// CDynLinkLibrary objects (for resource chain)
	CTypedSimpleList<CDynLinkLibrary*> m_libraryList;

	// special case for MFCXXLLL.DLL (localized MFC resources)
	HINSTANCE m_appLangDLL;
#endif

#ifndef _AFX_NO_OCC_SUPPORT
	// OLE control container manager
	COccManager* m_pOccManager;
	// locked OLE controls
	CTypedSimpleList<COleControlLock*> m_lockList;
#endif

#ifndef _AFX_NO_DAO_SUPPORT
	_AFX_DAO_STATE* m_pDaoState;
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// Type library caches
	CTypeLibCache m_typeLibCache;
	CTypeLibCacheMap* m_pTypeLibCacheMap;
#endif

	// define thread local portions of module state
	CThreadLocal<AFX_MODULE_THREAD_STATE> m_thread;

	//Fusion: declare pointer to array of pointers to isolation aware dll wrappers (ex: comctl32).
	CDllIsolationWrapperBase** m_pDllIsolationWrappers;
	//Defaults to TRUE. When FALSE - MFC will not activate context in AFX_MAINTAIN_STATE2 (used by AFX_MANAGE_STATE).
	BOOL	m_bSetAmbientActCtx;
	//Handle of the module context.
	HANDLE	m_hActCtx;
	void CreateActivationContext();

	// bool indicating the return value of InitNetworkAddressControl() (from shell32.dll) 
	BOOL m_bInitNetworkAddressControl;
	// bool indicating whether or not InitNetworkAddressControl() (from shell32.dll) have been called for CNetAddressCtrl
	BOOL m_bInitNetworkAddressControlCalled;
};

AFX_MODULE_STATE* AFXAPI AfxGetAppModuleState();
#ifdef _AFXDLL
AFX_MODULE_STATE* AFXAPI AfxSetModuleState(AFX_MODULE_STATE* pNewState) throw();
#endif
AFX_MODULE_STATE* AFXAPI AfxGetModuleState();
BOOL AFXAPI AfxIsModuleDll();
BOOL AFXAPI AfxInitCurrentStateApp();
AFX_MODULE_STATE* AFXAPI AfxGetStaticModuleState();
HINSTANCE AFXAPI AfxGetInstanceHandleHelper();

AFX_MODULE_THREAD_STATE* AFXAPI AfxGetModuleThreadState();

#ifdef _AFXDLL
#define _AFX_CMDTARGET_GETSTATE() (m_pModuleState)
#else
#define _AFX_CMDTARGET_GETSTATE() (AfxGetModuleState())
#endif

/////////////////////////////////////////////////////////////////////////////
// macros & classes to manage pushing/popping the module state

#ifdef _AFXDLL
struct AFX_MAINTAIN_STATE
{
	explicit AFX_MAINTAIN_STATE(AFX_MODULE_STATE* pModuleState) throw();
	~AFX_MAINTAIN_STATE();

protected:
	AFX_MODULE_STATE* m_pPrevModuleState;
};
#endif

class _AFX_THREAD_STATE;
struct AFX_MAINTAIN_STATE2
{
	explicit AFX_MAINTAIN_STATE2(AFX_MODULE_STATE* pModuleState) throw();
	~AFX_MAINTAIN_STATE2();

protected:
#ifdef _AFXDLL
	AFX_MODULE_STATE* m_pPrevModuleState;
	_AFX_THREAD_STATE* m_pThreadState;
#endif

	ULONG_PTR m_ulActCtxCookie;
	BOOL m_bValidActCtxCookie;
};
#define AFX_MANAGE_STATE_NO_INIT_MANAGED(p) AFX_MAINTAIN_STATE2 _ctlState(p);
#define AFX_MANAGE_STATE(p) _AfxInitManaged(); AFX_MANAGE_STATE_NO_INIT_MANAGED(p)

/////////////////////////////////////////////////////////////////////////////
// Thread global state

// forward references required for _AFX_THREAD_STATE definition
class CView;
class CToolTipCtrl;
class CControlBar;
class CPushRoutingFrame;
class CPushRoutingView;

#define _AFX_TEMP_CLASS_NAME_SIZE 96
class _AFX_THREAD_STATE : public CNoTrackObject
{
public:
	_AFX_THREAD_STATE();
	virtual ~_AFX_THREAD_STATE();

	// override for m_pModuleState in _AFX_APP_STATE
	AFX_MODULE_STATE* m_pModuleState;
	AFX_MODULE_STATE* m_pPrevModuleState;

	// memory safety pool for temp maps
	void* m_pSafetyPoolBuffer;    // current buffer

	// thread local exception context
	AFX_EXCEPTION_CONTEXT m_exceptionContext;

	// CWnd create, gray dialog hook, and other hook data
	CWnd* m_pWndInit;
	CWnd* m_pAlternateWndInit;      // special case commdlg hooking
	DWORD m_dwPropStyle;
	DWORD m_dwPropExStyle;
	HWND m_hWndInit;
	HHOOK m_hHookOldCbtFilter;
	HHOOK m_hHookOldMsgFilter;

	// message pump for Run
	MSG m_msgCur;                   // current message
	CPoint m_ptCursorLast;          // last mouse position
	UINT m_nMsgLast;                // last mouse message

#ifdef _DEBUG
		int m_nDisablePumpCount; // Diagnostic trap to detect illegal re-entrancy
#endif

	// other CWnd modal data
	MSG m_lastSentMsg;              // see CWnd::WindowProc
	HWND m_hTrackingWindow;         // see CWnd::TrackPopupMenu
	HMENU m_hTrackingMenu;
	TCHAR m_szTempClassName[_AFX_TEMP_CLASS_NAME_SIZE];    // see AfxRegisterWndClass
	HWND m_hLockoutNotifyWindow;    // see CWnd::OnCommand
	BOOL m_bInMsgFilter;

	// other framework modal data
	CView* m_pRoutingView;          // see CCmdTarget::GetRoutingView
   CPushRoutingView* m_pPushRoutingView;
	CFrameWnd* m_pRoutingFrame;     // see CCmdTarget::GetRoutingFrame
   CPushRoutingFrame* m_pPushRoutingFrame;

	// MFC/DB thread-local data
	BOOL m_bWaitForDataSource;

	// OLE control thread-local data
	CWnd* m_pWndPark;       // "parking space" window
	long m_nCtrlRef;        // reference count on parking window
	BOOL m_bNeedTerm;       // TRUE if OleUninitialize needs to be called
};

EXTERN_THREAD_LOCAL(_AFX_THREAD_STATE, _afxThreadState)

_AFX_THREAD_STATE* AFXAPI AfxGetThreadState();

/////////////////////////////////////////////////////////////////////////////

void AFXAPI AfxSetPerUserRegistration(BOOL bEnable);

BOOL AFXAPI AfxGetPerUserRegistration(void);

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#endif //__AFXSTATE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxstatusbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpane.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////

class CMFCStatusBarPaneInfo
{
public:	
	RECT        rect;          // pane rectangle
	UINT        nID;           // IDC of indicator: 0 => normal text area
	UINT        nStyle;        // style flags (SBPS_*)
	int         cxText;        // width of string area in pixels (on both sides there is a 1 pixel gap and a one pixel border, making a pane 4 pixels wider)
	int         cxIcon;        // width of icon area
	int         cyIcon;        // height of icon area
	COLORREF    clrText;       // text color
	COLORREF    clrBackground; // background color
	LPCTSTR     lpszText;      // text in the pane
	LPCTSTR     lpszToolTip;   // pane tooltip
	HIMAGELIST  hImage;        // pane icon or animation

	// Animation parameters
	int         nFrameCount;   // Number of animation frames
	int         nCurrFrame;    // Current frame

	// Progress bar properties
	long        nProgressCurr; // Current progress value
	long        nProgressTotal;// Total progress value (-1 - no progress bar)
	BOOL        bProgressText; // Display text: "x%"
	COLORREF    clrProgressBar;
	COLORREF    clrProgressBarDest;
	COLORREF    clrProgressText;

	CMFCStatusBarPaneInfo()
	{
		nID = 0;
		nStyle = 0;
		lpszText = NULL;
		lpszToolTip = NULL;
		clrText = (COLORREF)-1;
		clrBackground = (COLORREF)-1;
		hImage = NULL;
		cxIcon = 0;
		cyIcon = 0;
		rect = CRect(0, 0, 0, 0);
		nFrameCount = 0;
		nCurrFrame = 0;
		nProgressCurr = 0;
		nProgressTotal = -1;
		clrProgressBar = (COLORREF)-1;
		clrProgressBarDest = (COLORREF)-1;
		clrProgressText = (COLORREF)-1;
		bProgressText = FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCStatusBar window

class CMFCStatusBar : public CPane
{
	DECLARE_DYNAMIC(CMFCStatusBar)

// Construction
public:
	CMFCStatusBar();
	BOOL Create(CWnd* pParentWnd, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, UINT nID = AFX_IDW_STATUS_BAR);
	BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = 0, DWORD dwStyle = WS_CHILD | WS_VISIBLE | CBRS_BOTTOM, UINT nID = AFX_IDW_STATUS_BAR);
	BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);

// Attributes
public: 
	virtual BOOL DoesAllowDynInsertBefore() const { return FALSE; }

	// standard control bar things
	int CommandToIndex(UINT nIDFind) const;
	UINT GetItemID(int nIndex) const;
	void GetItemRect(int nIndex, LPRECT lpRect) const;

	// specific to CStatusBar
	void GetPaneText(int nIndex, CString& s) const;
	CString GetPaneText(int nIndex) const;
	
	virtual BOOL SetPaneText(int nIndex, LPCTSTR lpszNewText, BOOL bUpdate = TRUE);

	void GetPaneInfo(int nIndex, UINT& nID, UINT& nStyle, int& cxWidth) const;
	void SetPaneInfo(int nIndex, UINT nID, UINT nStyle, int cxWidth);
	UINT GetPaneStyle(int nIndex) const;
	void SetPaneStyle(int nIndex, UINT nStyle);
	CString GetTipText(int nIndex) const;
	void SetTipText(int nIndex, LPCTSTR pszTipText);

	int GetCount() const { return m_nCount; }

	// specific to CMFCStatusBar
	int GetPaneWidth(int nIndex) const;
	void SetPaneWidth(int nIndex, int cx);

	void SetPaneIcon(int nIndex, HICON hIcon, BOOL bUpdate = TRUE);
	void SetPaneIcon(int nIndex, HBITMAP hBmp, COLORREF clrTransparent = RGB(255, 0, 255), BOOL bUpdate = TRUE);
	void SetPaneAnimation(int nIndex, HIMAGELIST hImageList, UINT nFrameRate = 500 /* ms */, BOOL bUpdate = TRUE);
	void SetPaneTextColor(int nIndex, COLORREF clrText = (COLORREF)-1 /* Default */, BOOL bUpdate = TRUE);
	void SetPaneBackgroundColor(int nIndex, COLORREF clrBackground = (COLORREF)-1 /* Default */, BOOL bUpdate = TRUE);

	void EnablePaneProgressBar(int nIndex, long nTotal = 100 /* -1 - disable */, BOOL bDisplayText = FALSE, /* display "x%" */
		COLORREF clrBar = -1, COLORREF clrBarDest = -1 /* for gradient fill */, COLORREF clrProgressText = -1);
	void SetPaneProgress(int nIndex, long nCurr, BOOL bUpdate = TRUE);
	long GetPaneProgress(int nIndex) const;

	void InvalidatePaneContent(int nIndex);
	void EnablePaneDoubleClick(BOOL bEnable = TRUE);

	virtual BOOL GetExtendedArea(CRect& rect) const;

	void SetDrawExtendedArea(BOOL bSet = TRUE) { m_bDrawExtendedArea = bSet; }
	BOOL GetDrawExtendedArea() const { return m_bDrawExtendedArea; }

// Implementation
public:
	virtual ~CMFCStatusBar();
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	HFONT m_hFont;
	int   m_cxSizeBox;        // style size box in corner
	CRect m_rectSizeBox;
	BOOL  m_bPaneDoubleClick;
	BOOL  m_bDrawExtendedArea;

	inline CMFCStatusBarPaneInfo* _GetPanePtr(int nIndex) const;
	void RecalcLayout();
	CMFCStatusBarPaneInfo* HitTest(CPoint pt) const;

	HFONT GetCurrentFont() const;

// Overrides:
protected:
	virtual void OnDrawPane(CDC* pDC, CMFCStatusBarPaneInfo* pPane);
	virtual void DoPaint(CDC* pDC);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }
	virtual BOOL HideInPrintPreviewMode() const { return FALSE; }

	//{{AFX_MSG(CMFCStatusBar)
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetTextLength(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg void OnDestroy();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnStyleChanged(WPARAM wp, LPARAM lp);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxstr.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// AFXSTR.H - Framework-independent, templateable string class

#ifndef __AFXSTR_H__
#define __AFXSTR_H__

#pragma once

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef _AFX
#error afxstr.h can only be used in MFC projects.  Use atlstr.h
#endif

#include <mbstring.h>

HINSTANCE AFXAPI AfxGetResourceHandle();
HINSTANCE AFXAPI AfxFindStringResourceHandle(UINT nID);

UINT_PTR AFXAPI AfxReadStringLength(CArchive& ar, int& nCharSize);
void AFXAPI AfxWriteStringLength(CArchive& ar, UINT_PTR nLength, BOOL bUnicode);

#include <atlcore.h>
#include <cstringt.h>

ATL::IAtlStringMgr* AFXAPI AfxGetStringManager();

template< typename _CharType = char, class StringIterator = ATL::ChTraitsCRT< _CharType > >
class StrTraitMFC : 
	public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance( UINT nID ) throw()
	{
		return( AfxFindStringResourceHandle( nID ) );
	}

	static ATL::IAtlStringMgr* GetDefaultManager() throw()
	{
		return( AfxGetStringManager() );
	}
};

template< typename _CharType, class StringIterator>
class StrTraitMFC_DLL : public StringIterator
{
public:
	static HINSTANCE FindStringResourceInstance( UINT nID ) throw()
	{
		return( AfxFindStringResourceHandle( nID ) );
	}

	static ATL::IAtlStringMgr* GetDefaultManager() throw()
	{
		return( AfxGetStringManager() );
	}
};

// MFC-enabled compilation. Use MFC memory management and exceptions;
// also, use MFC module state.

// Don't import when MFC dll is being built
#if defined(_AFXDLL)

#if defined(_MFC_DLL_BLD)

template class ATL::CSimpleStringT< char, true >;
template class ATL::CStringT< char, StrTraitMFC_DLL< char > >;
template class ATL::CSimpleStringT< wchar_t, true >;
template class ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > >;

#else

template class __declspec(dllimport) ATL::CSimpleStringT< char, true >;
template class __declspec(dllimport) ATL::CStringT< char, StrTraitMFC_DLL< char > >;
template class __declspec(dllimport) ATL::CSimpleStringT< wchar_t, true >;
template class __declspec(dllimport) ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > >;
#if defined(_NATIVE_WCHAR_T)
template class __declspec(dllimport) ATL::CSimpleStringT< unsigned short, true >;
template class __declspec(dllimport) ATL::CStringT< unsigned short, StrTraitMFC_DLL< unsigned short > >;
#endif	// _NATIVE_WCHAR_T

#endif	// _MFC_DLL_BLD

typedef ATL::CStringT< wchar_t, StrTraitMFC_DLL< wchar_t > > CStringW;
typedef ATL::CStringT< char, StrTraitMFC_DLL< char > > CStringA;
typedef ATL::CStringT< TCHAR, StrTraitMFC_DLL< TCHAR > > CString;

#else

typedef ATL::CStringT< wchar_t, StrTraitMFC< wchar_t > > CStringW;
typedef ATL::CStringT< char, StrTraitMFC< char > > CStringA;
typedef ATL::CStringT< TCHAR, StrTraitMFC< TCHAR > > CString;

#endif	// !_WIN64 && _AFXDLL

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif	// __AFXSTR_H__ (whole file)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtabbedpane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbasetabbedpane.h"
#include "afxtabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabbedPane window

class CTabbedPane : public CBaseTabbedPane
{
	DECLARE_SERIAL(CTabbedPane)

// Construction
public:
	CTabbedPane(BOOL bAutoDestroy = FALSE);

// Attributes
public:
	virtual void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const;
	virtual BOOL IsTabLocationBottom() const;

	CMFCTabCtrl* GetTabWnd() const
	{
		ASSERT_KINDOF(CMFCTabCtrl, m_pTabWnd);
		return DYNAMIC_DOWNCAST(CMFCTabCtrl, m_pTabWnd);
	}

	virtual BOOL HasAutoHideMode() const { return TRUE; }

	AFX_IMPORT_DATA static CMFCTabCtrl::Style m_StyleTabWnd;
	AFX_IMPORT_DATA static BOOL m_bTabsAlwaysTop;
	AFX_IMPORT_DATA static CRuntimeClass* m_pTabWndRTC;

	static void __stdcall EnableTabAutoColor(BOOL bEnable = TRUE);
	static void __stdcall SetTabAutoColors(const CArray<COLORREF, COLORREF>& arColors);
	static void __stdcall ResetTabs();

// Operations
public:
	virtual BOOL FloatTab(CWnd* pBar, int nTabID, AFX_DOCK_METHOD dockMethod, BOOL bHide = FALSE);
	virtual BOOL DetachPane(CWnd* pBar, BOOL bHide = FALSE);

// Implementation
public:
	virtual ~CTabbedPane();

protected:
	virtual BOOL CheckTabbedBarAlignment();
	virtual void OnPressCloseButton();

protected:
	//{{AFX_MSG(CTabbedPane)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Tab Auto-colors support
	AFX_IMPORT_DATA static CArray<COLORREF, COLORREF> m_arTabsAutoColors;
	AFX_IMPORT_DATA static BOOL m_bIsTabsAutoColor;
	AFX_IMPORT_DATA static CList<HWND,HWND> m_lstTabbedControlBars;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtabctrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef NO_TAB_WND_INFO

#include "afxcontrolbarutil.h"
#include "afxbasepane.h"
#include "afxbasetabctrl.h"
#include "afxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCTabCtrl window

class CMFCTabInfo;

extern AFX_IMPORT_DATA UINT AFX_WM_GETDRAGBOUNDS;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_DRAGCOMPLETE;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_TABGROUPMOUSEMOVE;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_CANCELTABMOVE;
extern AFX_IMPORT_DATA UINT AFX_WM_ON_MOVETABCOMPLETE;

class CMFCTabButton : public CMFCButton
{
	virtual void OnFillBackground(CDC* pDC, const CRect& rectClient);
	virtual void OnDrawBorder(CDC* pDC, CRect& rectClient, UINT uiState);

public:
	void SetPressed(BOOL bOn)
	{
		m_bPushed = bOn;
		m_bHighlighted = bOn;
		RedrawWindow();
	}
};

class CMFCTabCtrl : public CMFCBaseTabCtrl
{
	friend class CMDIClientAreaWnd;

	DECLARE_DYNCREATE(CMFCTabCtrl)

// Construction
public:
	CMFCTabCtrl();

	enum Style
	{
		STYLE_3D                      = 0,
		STYLE_FLAT                    = 1,
		STYLE_FLAT_SHARED_HORZ_SCROLL = 2,
		STYLE_3D_SCROLLED             = 3,
		STYLE_3D_ONENOTE              = 4,
		STYLE_3D_VS2005               = 5,
		STYLE_3D_ROUNDED              = 6,
		STYLE_3D_ROUNDED_SCROLL       = 7,
	};

	enum ResizeMode
	{
		RESIZE_NO    = 0,
		RESIZE_VERT  = 1,
		RESIZE_HORIZ = 2,
	};

// Operations
public:
	// Create methods:
	BOOL Create(Style style, const RECT& rect, CWnd* pParentWnd, UINT nID, Location location = LOCATION_BOTTOM, BOOL bCloseBtn = FALSE);
	virtual BOOL SetImageList(UINT uiID, int cx = 15, COLORREF clrTransp = RGB(255, 0, 255));
	virtual BOOL SetImageList(HIMAGELIST hImageList);

	BOOL ModifyTabStyle(Style style);

	virtual void RecalcLayout();

	void EnableActiveTabCloseButton(BOOL bEnable = TRUE);
	virtual BOOL IsActiveTabCloseButton() const { return m_bActiveTabCloseButton; }
	
	void EnableTabDocumentsMenu(BOOL bEnable = TRUE);
	BOOL IsTabDocumentsMenu() const { return m_bTabDocumentsMenu; }

	virtual void EnableInPlaceEdit(BOOL bEnable);
	virtual void CalcRectEdit(CRect& rectEdit)
	{
		ASSERT_VALID(this);
		rectEdit.DeflateRect(m_nTabsHeight / 2, 1);
	}

	virtual BOOL SetActiveTab(int iTab);
	virtual BOOL EnsureVisible(int iTab);

	// Scrolling methods:
	BOOL SynchronizeScrollBar(SCROLLINFO* pScrollInfo = NULL);
	CScrollBar* GetScrollBar() { return m_bSharedScroll ? &m_wndScrollWnd : NULL; }

	virtual void HideSingleTab(BOOL bHide = TRUE);
	void HideActiveWindowHorzScrollBar();

	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

	static HICON __stdcall GetDocumentIcon(UINT nCmdID);

protected:
	virtual CWnd* FindTargetWnd(const CPoint& pt);

	virtual void AdjustTabs();
	virtual void AdjustTabsScroll();
	virtual void AdjustWndScroll();

	void RelayEvent(UINT message, WPARAM wParam, LPARAM lParam);
	void SetTabsHeight();
	void ReposButtons(CPoint pt, CSize sizeButton, BOOL bHide, int nButtonMargin);

	void UpdateScrollButtonsState();
	void SetScrollButtons();

// Attributes
public:
	virtual BOOL IsPtInTabArea(CPoint point) const;
	virtual BOOL AllowDestroyEmptyTabbedPane() const {return TRUE;}
	virtual int GetTabFromPoint(CPoint& pt) const;

	void SetFlatFrame(BOOL bFlat = TRUE, BOOL bRepaint = TRUE)
	{
		if (m_bFlatFrame != bFlat)
		{
			m_bFlatFrame = bFlat;
			if (bRepaint && GetSafeHwnd() != NULL)
			{
				Invalidate();
				UpdateWindow();
			}
		}
	}

	BOOL IsFlatFrame() const { return m_bFlatFrame; }
	void HideInactiveWindow(BOOL bHide = TRUE) { m_bHideInactiveWnd = bHide; }
	void AutoSizeWindow(BOOL bAutoSize = TRUE) { m_bAutoSizeWindow = bAutoSize; }
	void GetWndArea(CRect& rect) const { rect = m_rectWndArea; }

	void GetTabArea(CRect& rectTabAreaTop, CRect& rectTabAreaBottom) const
	{
		rectTabAreaTop.SetRectEmpty();
		rectTabAreaBottom.SetRectEmpty();
		(m_location == LOCATION_TOP) ? rectTabAreaTop = m_rectTabsArea : rectTabAreaBottom = m_rectTabsArea;
	}

	virtual void GetTabsRect(CRect& rect) const { rect = m_rectTabsArea; }

	virtual int GetTabsHeight() const
	{
		if (!m_bSharedScroll)
		{
			int nVisibleTabs = GetVisibleTabsNum();
			if ((m_bHideSingleTab && nVisibleTabs <= 1) || (m_bHideNoTabs && nVisibleTabs == 0))
			{
				return 0;
			}
		}
		return m_nTabsHeight;
	}

	BOOL IsSharedScroll() const { return m_bSharedScroll; }

	virtual BOOL IsFlatTab() const { return m_bFlat; }
	virtual BOOL IsVS2005Style() const { return m_bIsVS2005Style; }
	virtual BOOL IsOneNoteStyle() const { return m_bIsOneNoteStyle; }
	virtual BOOL IsLeftRightRounded() const { return m_bLeftRightRounded; }

	void HideNoTabs(BOOL bHide = TRUE);

	void SetActiveTabBoldFont(BOOL bIsBold = TRUE);
	BOOL IsActiveTabBoldFont() const { return m_bIsActiveTabBold; }

	void SetDrawFrame(BOOL bDraw = TRUE);
	BOOL IsDrawFrame() const { return m_bDrawFrame; }

	AFX_IMPORT_DATA static BOOL m_bEnableActivate;

	virtual int GetFirstVisibleTabNum() const
	{
		return m_nFirstVisibleTab;	// For m_bIsOneNoteStyle only!
	}

	virtual void SwapTabs(int nFisrtTabID, int nSecondTabID);
	virtual void MoveTab(int nSource, int nDest);

	virtual void OnShowTabDocumentsMenu(CPoint point);

	void SetTabMaxWidth(int nTabMaxWidth);
	int GetTabMaxWidth() const { return m_nTabMaxWidth; }

	void SetResizeMode(ResizeMode resizeMode);
	ResizeMode GetResizeMode() const { return m_ResizeMode; }

	void StopResize(BOOL bCancel);
	virtual BOOL IsMDITabGroup() const;
	void ActivateMDITab(int nTab = -1);
	void SetActiveInMDITabGroup(BOOL bActive)  {m_bIsActiveInMDITabGroup = bActive;}
	BOOL IsActiveInMDITabGroup() const {return m_bIsActiveInMDITabGroup;}

protected:
	BOOL m_bFlat;                 // Is flat (Excel-like) mode
	BOOL m_bIsOneNoteStyle;       // Is OneNote-like mode
	BOOL m_bIsVS2005Style;        // Is VS.NET 2005 MDI-like mode
	BOOL m_bLeftRightRounded;     // Is VS.NET 2005 two-side rounded tab
	BOOL m_bSharedScroll;         // Have a scrollbar shared with active window
	BOOL m_bScroll;               // Scroll buttons
	BOOL m_bCloseBtn;             // Close button
	BOOL m_bTrackSplitter;        // Is splitter tracked?
	BOOL m_bFlatFrame;            // Is frame flat?
	BOOL m_bAutoSizeWindow;       // Auto-resize tab widnows
	BOOL m_bTransparent;
	BOOL m_bTopEdge;
	BOOL m_bDrawFrame;            // Draw frame around window area
	BOOL m_bHideNoTabs;           // Hide tabs are when no tabs are available
	BOOL m_bIsActiveTabBold;      // Active tab text is drawing bold
	BOOL m_bActiveTabCloseButton; // Draw "Close" button on the active tab
	BOOL m_bTabDocumentsMenu;
	BOOL m_bHiddenDocuments;
	BOOL m_bIsActiveInMDITabGroup;
	BOOL m_bResize;

	int m_nScrollBarRight;  // Scrollbar right side
	int m_nTabsHorzOffset;
	int m_nTabsHorzOffsetMax;
	int m_nTabsTotalWidth;
	int m_nFirstVisibleTab;
	int m_nHorzScrollWidth; // Shared scrollbar width
	int m_nTabMaxWidth;

	CRect m_rectTabSplitter; // Splitter between tabs and scrollbar
	CRect m_rectCurrClip;
	CRect m_rectTabsArea;    // Tabs area
	CRect m_rectWndArea;     // Child window area
	CRect m_rectResize;
	CRect m_rectResizeDrag;
	CRect m_rectResizeBounds;

	CScrollBar m_wndScrollWnd; // Active window horizontal scroll bar
	CMFCTabButton m_btnScrollLeft;
	CMFCTabButton m_btnScrollRight;
	CMFCTabButton m_btnScrollFirst;
	CMFCTabButton m_btnScrollLast;
	CMFCTabButton m_btnClose;
	ResizeMode m_ResizeMode;

	CList<HWND, HWND> m_lstButtons;

	AFX_IMPORT_DATA static CMap<UINT,UINT,HICON,HICON> m_mapDocIcons;

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM, LPARAM lParam, LRESULT* pResult);
	virtual void Draw3DTab(CDC* pDC, CMFCTabInfo* pTab, BOOL bActive);
	virtual void DrawFlatTab(CDC* pDC, CMFCTabInfo* pTab, BOOL bActive);
	virtual void DrawResizeDragRect(CRect& rectNew, CRect& rectOld);

// Implementation
public:
	virtual ~CMFCTabCtrl();

protected:
	//{{AFX_MSG(CMFCTabCtrl)
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnSysColorChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CMFCTabCtrl notification messages:
extern AFX_IMPORT_DATA UINT AFX_WM_ON_HSCROLL;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif // NO_TAB_WND_INFO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtabview.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtabctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CTabView view

class CTabView : public CView
{
protected:
	CTabView(); // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CTabView)

// Attributes
public:
	CMFCTabCtrl& GetTabControl() { return m_wndTabs; }

protected:
	CMFCTabCtrl m_wndTabs;
	BOOL    m_bIsReady;
	int     m_nFirstActiveTab;

// Operations
public:
	int AddView(CRuntimeClass* pViewClass, const CString& strViewLabel, int iIndex = -1, CCreateContext* pContext = NULL);
	int FindTab(HWND hWndView) const;

	BOOL RemoveView(int iTabNum);
	BOOL SetActiveView(int iTabNum);
	CView* GetActiveView() const; // active view or NULL

// Overrides
public:
	virtual void OnInitialUpdate();

protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view

	virtual void OnActivateView(CView* /*pView*/) {}
	virtual BOOL IsScrollBar() const { return FALSE; }

// Implementation
protected:
	virtual ~CTabView();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	//{{AFX_MSG(CTabView)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnChangeActiveTab(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtagmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarImages;
class CMFCControlRendererInfo;
class CMFCControlRenderer;
class CMFCToolTipInfo;

class CTagManager : public CObject
{
// Construction
public:
	CTagManager(LPCTSTR lpszBuffer = NULL);
	virtual ~CTagManager();

// Attributes:
public:
	LPCTSTR GetBuffer() const
	{
		return m_strBuffer;
	}

	void SetBuffer(LPCTSTR lpszBuffer);

	BOOL IsEmpty() const
	{
		return m_strBuffer.IsEmpty();
	}

// Operations:
public:
	BOOL LoadFromResource(UINT uiResID, LPCTSTR lpszResType);
	BOOL LoadFromResource(LPCTSTR lpszResID, LPCTSTR lpszResType);
	BOOL LoadFromFile(LPCTSTR lpszFileName);

	BOOL ExcludeTag(LPCTSTR lpszTag, CString& strTag, BOOL bIsCharsList = FALSE);

// Global helpers:
	static BOOL __stdcall ParseString(const CString& str, const CString& sep, CStringArray& sa, BOOL bTrim, BOOL bIncludeEmpty);
	static BOOL __stdcall ParseColor(const CString& strItem, COLORREF& value);
	static BOOL __stdcall ParseColorHEX(const CString& strItem, COLORREF& value);
	static BOOL __stdcall ParsePoint(const CString& strItem, CPoint& value);
	static BOOL __stdcall ParseSize(const CString& strItem, CSize& value);
	static BOOL __stdcall ParseRect(const CString& strItem, CRect& value);
	static BOOL __stdcall ParseFont(const CString& strItem, LOGFONT& value);
	static BOOL __stdcall ParseToolBarImages(const CString& strItem, CMFCToolBarImages& value, UINT ID);
	static BOOL __stdcall ParseToolBarImages(const CString& strItem, CMFCToolBarImages& value, LPCTSTR lpszID);
	static BOOL __stdcall ParseControlRendererInfo(const CString& strItem, CMFCControlRendererInfo& value);
	static BOOL __stdcall ParseControlRenderer(const CString& strItem, CMFCControlRenderer& value, UINT ID);
	static BOOL __stdcall ParseControlRenderer(const CString& strItem, CMFCControlRenderer& value, LPCTSTR lpszID);
	static BOOL __stdcall ParseToolTipInfo(const CString& strItem, CMFCToolTipInfo& value);

	// Read tag methods:
	BOOL ReadBool(const CString& strValue, BOOL& value);
	BOOL ReadInt(const CString& strValue, int& value);
	BOOL ReadPoint(const CString& strValue, CPoint& value);
	BOOL ReadSize(const CString& strValue, CSize& value);
	BOOL ReadRect(const CString& strValue, CRect& value);
	BOOL ReadColor(const CString& strValue, COLORREF& value);
	BOOL ReadFont(const CString& strValue, LOGFONT& value);
	BOOL ReadToolBarImages(const CString& strValue, CMFCToolBarImages& value, UINT ID);
	BOOL ReadToolBarImages(const CString& strValue, CMFCToolBarImages& value, LPCTSTR lpszID);
	BOOL ReadControlRendererInfo(const CString& strValue, CMFCControlRendererInfo& value);
	BOOL ReadControlRenderer(const CString& strValue, CMFCControlRenderer& value, UINT ID);
	BOOL ReadControlRenderer(const CString& strValue, CMFCControlRenderer& value, LPCTSTR lpszID);
	BOOL ReadToolTipInfo(const CString& strValue, CMFCToolTipInfo& value);

protected:
	CString m_strBuffer;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\AfxThemeHelper.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_THEMEHELPER_H__
#define __AFX_THEMEHELPER_H__

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
class CThemeHelper
{
	typedef BOOL(__stdcall *PFNISAPPTHEMED)();
	typedef HTHEME(__stdcall *PFNOPENTHEMEDATA)(HWND hwnd, LPCWSTR pszClassList);
	typedef HRESULT(__stdcall *PFNCLOSETHEMEDATA)(HTHEME hTheme);
	typedef HRESULT(__stdcall *PFNDRAWTHEMEBACKGROUND)(HTHEME hTheme, HDC hdc, 
		int nPartId, int nStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);
	typedef HRESULT(__stdcall *PFNGETTHEMEPARTSIZE)(HTHEME hTheme, HDC hdc, 
		int nPartId, int nStateId, RECT * pRect, enum THEMESIZE eSize, OUT SIZE *psz);
	typedef BOOL(__stdcall *PFNISTHEMEBACKGROUNDPARTIALLYTRANSPARENT)(HTHEME hTheme,
		int nPartId, int nStateId);
	typedef HRESULT (__stdcall *PFNDRAWTHEMEPARENTBACKGROUND)(HWND hwnd, HDC hdc, 
		RECT *prc);
	typedef BOOL (__stdcall *PFNISTHEMEPARTDEFINED)(HTHEME hTheme, int nPartId, 
		int nStateId);

	static void* GetProc(LPCSTR szProc, void* pfnFail);
	static BOOL IsAppThemedFail();
	static HTHEME OpenThemeDataFail(HWND , LPCWSTR );
	static HRESULT CloseThemeDataFail(HTHEME);
	static HRESULT DrawThemeBackgroundFail(HTHEME, HDC, int, int, const RECT *, const RECT *);
	static HRESULT GetThemePartSizeFail(HTHEME, HDC, int, int, RECT *, enum THEMESIZE, SIZE *);
	static BOOL IsThemeBackgroundPartiallyTransparentFail(HTHEME , int , int );
	static HRESULT DrawThemeParentBackgroundFail(HWND , HDC , RECT *);
	static BOOL IsThemePartDefinedFail(HTHEME , int , int );

public:
	static BOOL IsAppThemed();
	static HTHEME OpenThemeData(HWND hwnd, LPCWSTR pszClassList);
	static HRESULT CloseThemeData(HTHEME hTheme);
	static HRESULT DrawThemeBackground(HTHEME hTheme, HDC hdc, 
		int nPartId, int nStateId, const RECT *pRect, const RECT *pClipRect);
	static HRESULT GetThemePartSize(HTHEME hTheme, HDC hdc, 
		int nPartId, int nStateId, RECT * pRect, enum THEMESIZE eSize, SIZE *psz);
	static BOOL IsThemeBackgroundPartiallyTransparent(HTHEME hTheme, int nPartId, int nStateId);
	static HRESULT DrawThemeParentBackground(HWND hwnd, HDC hdc, RECT *prc);
	static BOOL IsThemePartDefined(HTHEME hTheme, int nPartId, int nStateId);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#endif // __AFX_THEMEHELPER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtempl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTEMPL_H__
#define __AFXTEMPL_H__

#ifndef __AFXPLEX_H__
	#include <afxplex_.h>
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif 

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _DEBUG
#endif

#pragma warning( push )
#pragma warning( disable: 4505 4127 )

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)

#pragma push_macro("new")

#ifndef _INC_NEW
	#include <new.h>
#endif

namespace ATL
{
	class CComBSTR;
}
using ATL::CComBSTR;

// the two functions below are deprecated.  Use a constructor/destructor instead.
#pragma deprecated( DestructElements )
#pragma deprecated( ConstructElements )

template<class TYPE>
AFX_INLINE void AFXAPI CopyElements(TYPE* pDest, const TYPE* pSrc, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pDest != 0 && pSrc != 0);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pDest, (size_t)nCount * sizeof(TYPE)));
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pSrc, (size_t)nCount * sizeof(TYPE)));

	// default is element-copy using assignment
	while (nCount--)
		*pDest++ = *pSrc++;
}

template<class TYPE>
void AFXAPI SerializeElements(CArchive& ar, TYPE* pElements, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE)));

	// default is bit-wise read/write
	if (ar.IsStoring())
	{
		TYPE* pData;
		UINT_PTR nElementsLeft;

		nElementsLeft = nCount;
		pData = pElements;
		while( nElementsLeft > 0 )
		{
			UINT nElementsToWrite;

			nElementsToWrite = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));
			ar.Write(pData, nElementsToWrite*sizeof(TYPE));
			nElementsLeft -= nElementsToWrite;
			pData += nElementsToWrite;
		}
	}
	else
	{
		TYPE* pData;
		UINT_PTR nElementsLeft;

		nElementsLeft = nCount;
		pData = pElements;
		while( nElementsLeft > 0 )
		{
			UINT nElementsToRead;

			nElementsToRead = UINT(__min(nElementsLeft, INT_MAX/sizeof(TYPE)));
			ar.EnsureRead(pData, nElementsToRead*sizeof(TYPE));
			nElementsLeft -= nElementsToRead;
			pData += nElementsToRead;
		}
	}
}

template<class TYPE>
void AFXAPI SerializeElementsInsertExtract(CArchive& ar, TYPE* pElements, 
	INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT((nCount == 0) || 
		(AfxIsValidAddress(pElements, nCount*sizeof(TYPE))));

	if (nCount == 0 || pElements == NULL)
	{
		return;
	}

	if (ar.IsStoring())
	{
		for (; nCount--; ++pElements)
			ar << *pElements;
	}
	else
	{
		for (; nCount--; ++pElements)
			ar >> *pElements;
	}
}

#ifdef _DEBUG
template<class TYPE>
void AFXAPI DumpElements(CDumpContext& dc, const TYPE* pElements, INT_PTR nCount)
{
	ENSURE(nCount == 0 || pElements != NULL);
	ASSERT(nCount == 0 ||
		AfxIsValidAddress(pElements, (size_t)nCount * sizeof(TYPE), FALSE));
	UNREFERENCED_PARAMETER(dc); // not used
	UNREFERENCED_PARAMETER(pElements);  // not used
	UNREFERENCED_PARAMETER(nCount); // not used

	// default does nothing
}
#endif

template<class TYPE, class ARG_TYPE>
BOOL AFXAPI CompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
	ENSURE(pElement1 != NULL && pElement2 != NULL);
	ASSERT(AfxIsValidAddress(pElement1, sizeof(TYPE), FALSE));
	ASSERT(AfxIsValidAddress(pElement2, sizeof(ARG_TYPE), FALSE));

	return *pElement1 == *pElement2;
}

template<class ARG_KEY>
AFX_INLINE UINT AFXAPI HashKey(ARG_KEY key)
{
	// (algorithm copied from STL hash in xfunctional)
	ldiv_t HashVal = ldiv((long)(ARG_KEY)key, 127773);
	HashVal.rem = 16807 * HashVal.rem - 2836 * HashVal.quot;
	if (HashVal.rem < 0)
		HashVal.rem += 2147483647;
	return ((UINT)HashVal.rem);
}

template<> AFX_INLINE UINT AFXAPI HashKey<__int64>(__int64 key)
{
	// (algorithm copied from STL hash in xfunctional)
	return (HashKey<DWORD>((DWORD)(key & 0xffffffffUL)) ^ HashKey<DWORD>((DWORD)(key >> 32)));
}

// special versions for CString
template<> void AFXAPI SerializeElements<CStringA> (CArchive& ar, CStringA* pElements, INT_PTR nCount);
template<> void AFXAPI SerializeElements<CStringW> (CArchive& ar, CStringW* pElements, INT_PTR nCount);
template<> UINT AFXAPI HashKey<LPCWSTR> (LPCWSTR key);
template<> UINT AFXAPI HashKey<LPCSTR> (LPCSTR key);

// special versions for CComBSTR
template<> void AFXAPI SerializeElements<CComBSTR> (CArchive& ar, CComBSTR* pElements, INT_PTR nCount);
template<> UINT AFXAPI HashKey<CComBSTR> (CComBSTR key);

// forward declarations
class COleVariant;
struct tagVARIANT;

// special versions for COleVariant
template<> void AFXAPI CopyElements<COleVariant> (COleVariant* pDest, const COleVariant* pSrc, INT_PTR nCount);
template<> void AFXAPI SerializeElements<COleVariant> (CArchive& ar, COleVariant* pElements, INT_PTR nCount);
#ifdef _DEBUG
template<> void AFXAPI DumpElements<COleVariant> (CDumpContext& dc, const COleVariant* pElements, INT_PTR nCount);
#endif
template<> UINT AFXAPI HashKey<const struct tagVARIANT&> (const struct tagVARIANT& var);

#define new DEBUG_NEW

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE = const TYPE&>
class CArray : public CObject
{
public:
// Construction
	CArray();

// Attributes
	INT_PTR GetSize() const;
	INT_PTR GetCount() const;
	BOOL IsEmpty() const;
	INT_PTR GetUpperBound() const;
	void SetSize(INT_PTR nNewSize, INT_PTR nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	const TYPE& GetAt(INT_PTR nIndex) const;
	TYPE& GetAt(INT_PTR nIndex);
	void SetAt(INT_PTR nIndex, ARG_TYPE newElement);
	const TYPE& ElementAt(INT_PTR nIndex) const;
	TYPE& ElementAt(INT_PTR nIndex);

	// Direct Access to the element data (may return NULL)
	const TYPE* GetData() const;
	TYPE* GetData();

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement);
	INT_PTR Add(ARG_TYPE newElement);
	INT_PTR Append(const CArray& src);
	void Copy(const CArray& src);

	// overloaded operator helpers
	const TYPE& operator[](INT_PTR nIndex) const;
	TYPE& operator[](INT_PTR nIndex);

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount = 1);
	void RemoveAt(INT_PTR nIndex, INT_PTR nCount = 1);
	void InsertAt(INT_PTR nStartIndex, CArray* pNewArray);

// Implementation
protected:
	TYPE* m_pData;   // the actual array of data
	INT_PTR m_nSize;     // # of elements (upperBound - 1)
	INT_PTR m_nMaxSize;  // max allocated
	INT_PTR m_nGrowBy;   // grow amount

public:
	~CArray();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nSize; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE BOOL CArray<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nSize == 0; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::GetUpperBound() const
	{ return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::RemoveAll()
	{ SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::GetAt(INT_PTR nIndex) const
{
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CArray<TYPE, ARG_TYPE>::SetAt(INT_PTR nIndex, ARG_TYPE newElement)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		m_pData[nIndex] = newElement; 
	else
		AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex) const
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
{ 
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex]; 
	AfxThrowInvalidArgException();		
}
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE* CArray<TYPE, ARG_TYPE>::GetData() const
	{ return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE* CArray<TYPE, ARG_TYPE>::GetData()
	{ return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
	{ INT_PTR nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex) const
	{ return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::operator[](INT_PTR nIndex)
	{ return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::CArray()
{
	m_pData = NULL;
	m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CArray<TYPE, ARG_TYPE>::~CArray()
{
	ASSERT_VALID(this);

	if (m_pData != NULL)
	{
		for( int i = 0; i < m_nSize; i++ )
			(m_pData + i)->~TYPE();
		delete[] (BYTE*)m_pData;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetSize(INT_PTR nNewSize, INT_PTR nGrowBy)
{
	ASSERT_VALID(this);
	ASSERT(nNewSize >= 0);

	if(nNewSize < 0 )
		AfxThrowInvalidArgException();

	if (nGrowBy >= 0)
		m_nGrowBy = nGrowBy;  // set new size

	if (nNewSize == 0)
	{
		// shrink to nothing
		if (m_pData != NULL)
		{
			for( int i = 0; i < m_nSize; i++ )
				(m_pData + i)->~TYPE();
			delete[] (BYTE*)m_pData;
			m_pData = NULL;
		}
		m_nSize = m_nMaxSize = 0;
	}
	else if (m_pData == NULL)
	{
		// create buffer big enough to hold number of requested elements or
		// m_nGrowBy elements, whichever is larger.
#ifdef SIZE_T_MAX
		ASSERT(nNewSize <= SIZE_T_MAX/sizeof(TYPE));    // no overflow
#endif
		size_t nAllocSize = __max(nNewSize, m_nGrowBy);
		m_pData = (TYPE*) new BYTE[(size_t)nAllocSize * sizeof(TYPE)];
		memset((void*)m_pData, 0, (size_t)nAllocSize * sizeof(TYPE));
		for( int i = 0; i < nNewSize; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( m_pData + i ) ) TYPE;
#pragma pop_macro("new")
		m_nSize = nNewSize;
		m_nMaxSize = nAllocSize;
	}
	else if (nNewSize <= m_nMaxSize)
	{
		// it fits
		if (nNewSize > m_nSize)
		{
			// initialize the new elements
			memset((void*)(m_pData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
			for( int i = 0; i < nNewSize-m_nSize; i++ )
#pragma push_macro("new")
#undef new
				::new( (void*)( m_pData + m_nSize + i ) ) TYPE;
#pragma pop_macro("new")
		}
		else if (m_nSize > nNewSize)
		{
			// destroy the old elements
			for( int i = 0; i < m_nSize-nNewSize; i++ )
				(m_pData + nNewSize + i)->~TYPE();
		}
		m_nSize = nNewSize;
	}
	else
	{
		// otherwise, grow array
		nGrowBy = m_nGrowBy;
		if (nGrowBy == 0)
		{
			// heuristically determine growth when nGrowBy == 0
			//  (this avoids heap fragmentation in many situations)
			nGrowBy = m_nSize / 8;
			nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
		}
		INT_PTR nNewMax;
		if (nNewSize < m_nMaxSize + nGrowBy)
			nNewMax = m_nMaxSize + nGrowBy;  // granularity
		else
			nNewMax = nNewSize;  // no slush

		ASSERT(nNewMax >= m_nMaxSize);  // no wrap around
		
		if(nNewMax  < m_nMaxSize)
			AfxThrowInvalidArgException();

#ifdef SIZE_T_MAX
		ASSERT(nNewMax <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = (TYPE*) new BYTE[(size_t)nNewMax * sizeof(TYPE)];

		// copy new data from old
		::ATL::Checked::memcpy_s(pNewData, (size_t)nNewMax * sizeof(TYPE),
			m_pData, (size_t)m_nSize * sizeof(TYPE));

		// construct remaining elements
		ASSERT(nNewSize > m_nSize);
		memset((void*)(pNewData + m_nSize), 0, (size_t)(nNewSize-m_nSize) * sizeof(TYPE));
		for( int i = 0; i < nNewSize-m_nSize; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( pNewData + m_nSize + i ) ) TYPE;
#pragma pop_macro("new")

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nSize = nNewSize;
		m_nMaxSize = nNewMax;
	}
}

template<class TYPE, class ARG_TYPE>
INT_PTR CArray<TYPE, ARG_TYPE>::Append(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself
	
	if(this == &src)
		AfxThrowInvalidArgException();

	INT_PTR nOldSize = m_nSize;
	SetSize(m_nSize + src.m_nSize);
	CopyElements<TYPE>(m_pData + nOldSize, src.m_pData, src.m_nSize);
	return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Copy(const CArray& src)
{
	ASSERT_VALID(this);
	ASSERT(this != &src);   // cannot append to itself

	if(this != &src)
	{
		SetSize(src.m_nSize);
		CopyElements<TYPE>(m_pData, src.m_pData, src.m_nSize);
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::FreeExtra()
{
	ASSERT_VALID(this);

	if (m_nSize != m_nMaxSize)
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ASSERT(m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
		TYPE* pNewData = NULL;
		if (m_nSize != 0)
		{
			pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
			// copy new data from old
			::ATL::Checked::memcpy_s(pNewData, m_nSize * sizeof(TYPE),
				m_pData, m_nSize * sizeof(TYPE));
		}

		// get rid of old stuff (note: no destructors called)
		delete[] (BYTE*)m_pData;
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::SetAtGrow(INT_PTR nIndex, ARG_TYPE newElement)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	
	if(nIndex < 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
		SetSize(nIndex+1, -1);
	m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nIndex, ARG_TYPE newElement, INT_PTR nCount /*=1*/)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);    // will expand to meet need
	ASSERT(nCount > 0);     // zero or negative size not allowed

	if(nIndex < 0 || nCount <= 0)
		AfxThrowInvalidArgException();

	if (nIndex >= m_nSize)
	{
		// adding after the end of the array
		SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		INT_PTR nOldSize = m_nSize;
		SetSize(m_nSize + nCount, -1);  // grow it to new size
		// destroy intial data before copying over it
		for( int i = 0; i < nCount; i++ )
			(m_pData + nOldSize + i)->~TYPE();
		// shift old data up to fill gap
		::ATL::Checked::memmove_s(m_pData + nIndex + nCount, (nOldSize-nIndex) * sizeof(TYPE),
			m_pData + nIndex, (nOldSize-nIndex) * sizeof(TYPE));

		// re-init slots we copied from
		memset((void*)(m_pData + nIndex), 0, (size_t)nCount * sizeof(TYPE));
		for( int i = 0; i < nCount; i++ )
#pragma push_macro("new")
#undef new
			::new( (void*)( m_pData + nIndex + i ) ) TYPE;
#pragma pop_macro("new")
	}

	// insert new value in the gap
	ASSERT(nIndex + nCount <= m_nSize);
	while (nCount--)
		m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::RemoveAt(INT_PTR nIndex, INT_PTR nCount)
{
	ASSERT_VALID(this);
	ASSERT(nIndex >= 0);
	ASSERT(nCount >= 0);
	INT_PTR nUpperBound = nIndex + nCount;
	ASSERT(nUpperBound <= m_nSize && nUpperBound >= nIndex && nUpperBound >= nCount);

	if(nIndex < 0 || nCount < 0 || (nUpperBound > m_nSize) || (nUpperBound < nIndex) || (nUpperBound < nCount))
		AfxThrowInvalidArgException();

	// just remove a range
	INT_PTR nMoveCount = m_nSize - (nUpperBound);
	for( int i = 0; i < nCount; i++ )
		(m_pData + nIndex + i)->~TYPE();
	if (nMoveCount)
	{
		::ATL::Checked::memmove_s(m_pData + nIndex, (size_t)nMoveCount * sizeof(TYPE),
			m_pData + nUpperBound, (size_t)nMoveCount * sizeof(TYPE));
	}
	m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::InsertAt(INT_PTR nStartIndex, CArray* pNewArray)
{
	ASSERT_VALID(this);
	ASSERT(pNewArray != NULL);
	ASSERT_VALID(pNewArray);
	ASSERT(nStartIndex >= 0);

	if(pNewArray == NULL || nStartIndex < 0)
		AfxThrowInvalidArgException();

	if (pNewArray->GetSize() > 0)
	{
		InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
		for (INT_PTR i = 0; i < pNewArray->GetSize(); i++)
			SetAt(nStartIndex + i, pNewArray->GetAt(i));
	}
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);
	if (ar.IsStoring())
	{
		ar.WriteCount(m_nSize);
	}
	else
	{
		DWORD_PTR nOldSize = ar.ReadCount();
		SetSize(nOldSize, -1);
	}
	SerializeElements<TYPE>(ar, m_pData, m_nSize);
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nSize << " elements";
	if (dc.GetDepth() > 0)
	{
		dc << "\n";
		DumpElements<TYPE>(dc, m_pData, m_nSize);
	}

	dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CArray<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_pData == NULL)
	{
		ASSERT(m_nSize == 0);
		ASSERT(m_nMaxSize == 0);
	}
	else
	{
		ASSERT(m_nSize >= 0);
		ASSERT(m_nMaxSize >= 0);
		ASSERT(m_nSize <= m_nMaxSize);
		ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE = const TYPE&>
class CList : public CObject
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		TYPE data;
	};
public:
// Construction
	/* explicit */ CList(INT_PTR nBlockSize = 10);

// Attributes (head and tail)
	// count of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	TYPE& GetHead();
	const TYPE& GetHead() const;
	TYPE& GetTail();
	const TYPE& GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	TYPE RemoveHead();
	TYPE RemoveTail();

	// add before head or after tail
	POSITION AddHead(ARG_TYPE newElement);
	POSITION AddTail(ARG_TYPE newElement);

	// add another list of elements before head or after tail
	void AddHead(CList* pNewList);
	void AddTail(CList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	TYPE& GetNext(POSITION& rPosition); // return *Position++
	const TYPE& GetNext(POSITION& rPosition) const; // return *Position++
	TYPE& GetPrev(POSITION& rPosition); // return *Position--
	const TYPE& GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position);
	const TYPE& GetAt(POSITION position) const;
	void SetAt(POSITION pos, ARG_TYPE newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, ARG_TYPE newElement);
	POSITION InsertAfter(POSITION position, ARG_TYPE newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(ARG_TYPE searchValue, POSITION startAfter = NULL) const;
		// defaults to starting at the HEAD, return NULL if not found
	POSITION FindIndex(INT_PTR nIndex) const;
		// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	INT_PTR m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CList();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetCount() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE INT_PTR CList<TYPE, ARG_TYPE>::GetSize() const
	{ return m_nCount; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE BOOL CList<TYPE, ARG_TYPE>::IsEmpty() const
	{ return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetHead()
	{ ENSURE(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetHead() const
	{ ENSURE(m_pNodeHead != NULL);
		return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetTail()
	{ ENSURE(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetTail() const
	{ ENSURE(m_pNodeTail != NULL);
		return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE POSITION CList<TYPE, ARG_TYPE>::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE const TYPE& CList<TYPE, ARG_TYPE>::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		return pNode->data; }
template<class TYPE, class ARG_TYPE>
AFX_INLINE void CList<TYPE, ARG_TYPE>::SetAt(POSITION pos, ARG_TYPE newElement)
	{ CNode* pNode = (CNode*) pos;
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode->data = newElement; }

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::CList(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAll()
{
	ASSERT_VALID(this);

	// destroy elements
	CNode* pNode;
	for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		pNode->data.~TYPE();

	m_nCount = 0;
	m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CList<TYPE, ARG_TYPE>::~CList()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CList<TYPE, ARG_TYPE>::CNode*
CList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
	if (m_pNodeFree == NULL)
	{
		// add another block
		CPlex* pNewBlock = CPlex::Create(m_pBlocks, m_nBlockSize,
				 sizeof(CNode));

		// chain them into free list
		CNode* pNode = (CNode*) pNewBlock->data();
		// free in reverse order to make it easier to debug
		pNode += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pNode--)
		{
			pNode->pNext = m_pNodeFree;
			m_pNodeFree = pNode;
		}
	}
	ENSURE(m_pNodeFree != NULL);  // we must have something

	CList::CNode* pNode = m_pNodeFree;
	m_pNodeFree = m_pNodeFree->pNext;
	pNode->pPrev = pPrev;
	pNode->pNext = pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow

#pragma push_macro("new")
#undef new
	::new( (void*)( &pNode->data ) ) TYPE;
#pragma pop_macro("new")
	return pNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
	pNode->data.~TYPE();
	pNode->pNext = m_pNodeFree;
	m_pNodeFree = pNode;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(NULL, m_pNodeHead);
	pNewNode->data = newElement;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = pNewNode;
	else
		m_pNodeTail = pNewNode;
	m_pNodeHead = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	CNode* pNewNode = NewNode(m_pNodeTail, NULL);
	pNewNode->data = newElement;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = pNewNode;
	else
		m_pNodeHead = pNewNode;
	m_pNodeTail = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddHead(CList* pNewList)
{
	ASSERT_VALID(this);

	ENSURE(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements to head (maintain order)
	POSITION pos = pNewList->GetTailPosition();
	while (pos != NULL)
		AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AddTail(CList* pNewList)
{
	ASSERT_VALID(this);
	ENSURE(pNewList != NULL);
	ASSERT_VALID(pNewList);

	// add a list of same elements
	POSITION pos = pNewList->GetHeadPosition();
	while (pos != NULL)
		AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveHead()
{
	ASSERT_VALID(this);
	ENSURE(m_pNodeHead != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));

	CNode* pOldNode = m_pNodeHead;
	TYPE returnValue = pOldNode->data;

	m_pNodeHead = pOldNode->pNext;
	if (m_pNodeHead != NULL)
		m_pNodeHead->pPrev = NULL;
	else
		m_pNodeTail = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CList<TYPE, ARG_TYPE>::RemoveTail()
{
	ASSERT_VALID(this);
	ENSURE(m_pNodeTail != NULL);  // don't call on empty list !!!
	ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));

	CNode* pOldNode = m_pNodeTail;
	TYPE returnValue = pOldNode->data;

	m_pNodeTail = pOldNode->pPrev;
	if (m_pNodeTail != NULL)
		m_pNodeTail->pNext = NULL;
	else
		m_pNodeHead = NULL;
	FreeNode(pOldNode);
	return returnValue;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertBefore(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddHead(newElement); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
	pNewNode->data = newElement;

	if (pOldNode->pPrev != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeHead);
		m_pNodeHead = pNewNode;
	}
	pOldNode->pPrev = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::InsertAfter(POSITION position, ARG_TYPE newElement)
{
	ASSERT_VALID(this);

	if (position == NULL)
		return AddTail(newElement); // insert after nothing -> tail of the list

	// Insert it before position
	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));
	CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
	pNewNode->data = newElement;

	if (pOldNode->pNext != NULL)
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pNewNode;
	}
	else
	{
		ASSERT(pOldNode == m_pNodeTail);
		m_pNodeTail = pNewNode;
	}
	pOldNode->pNext = pNewNode;
	return (POSITION) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::RemoveAt(POSITION position)
{
	ASSERT_VALID(this);

	CNode* pOldNode = (CNode*) position;
	ASSERT(AfxIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if (pOldNode == m_pNodeHead)
	{
		m_pNodeHead = pOldNode->pNext;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pPrev, sizeof(CNode)));
		pOldNode->pPrev->pNext = pOldNode->pNext;
	}
	if (pOldNode == m_pNodeTail)
	{
		m_pNodeTail = pOldNode->pPrev;
	}
	else
	{
		ASSERT(AfxIsValidAddress(pOldNode->pNext, sizeof(CNode)));
		pOldNode->pNext->pPrev = pOldNode->pPrev;
	}
	FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::FindIndex(INT_PTR nIndex) const
{
	ASSERT_VALID(this);

	if (nIndex >= m_nCount || nIndex < 0)
		return NULL;  // went too far

	CNode* pNode = m_pNodeHead;
	while (nIndex--)
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;
	}
	return (POSITION) pNode;
}

template<class TYPE, class ARG_TYPE>
POSITION CList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, POSITION startAfter) const
{
	ASSERT_VALID(this);

	CNode* pNode = (CNode*) startAfter;
	if (pNode == NULL)
	{
		pNode = m_pNodeHead;  // start at head
	}
	else
	{
		ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->pNext;  // start after the one specified
	}

	for (; pNode != NULL; pNode = pNode->pNext)
		if (CompareElements<TYPE>(&pNode->data, &searchValue))
			return (POSITION)pNode;
	return NULL;
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		for (CNode* pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
		{
			ASSERT(AfxIsValidAddress(pNode, sizeof(CNode)));
			TYPE* pData;
			/* 
			 * in some cases the & operator might be overloaded, and we cannot use it to obtain
			 * the address of a given object.  We then use the following trick to get the address
			 */
			pData = reinterpret_cast< TYPE* >( &reinterpret_cast< int& >( static_cast< TYPE& >( pNode->data ) ) );
			SerializeElements<TYPE>(ar, pData, 1);
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		while (nNewCount--)
		{
			TYPE newData[1];
			SerializeElements<TYPE>(ar, newData, 1);
			AddTail(newData[0]);
		}
	}
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		POSITION pos = GetHeadPosition();
		while (pos != NULL)
		{
			TYPE temp[1];
			temp[0] = ((CList*)this)->GetNext(pos);
			dc << "\n";
			DumpElements<TYPE>(dc, temp, 1);
		}
	}

	dc << "\n";
}

template<class TYPE, class ARG_TYPE>
void CList<TYPE, ARG_TYPE>::AssertValid() const
{
	CObject::AssertValid();

	if (m_nCount == 0)
	{
		// empty list
		ASSERT(m_pNodeHead == NULL);
		ASSERT(m_pNodeTail == NULL);
	}
	else
	{
		// non-empty list
		ASSERT(AfxIsValidAddress(m_pNodeHead, sizeof(CNode)));
		ASSERT(AfxIsValidAddress(m_pNodeTail, sizeof(CNode)));
	}
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CMap : public CObject
{
public:
	// CPair
	struct CPair
	{
		const KEY key;
		VALUE value;
	protected:
		CPair( ARG_KEY keyval ) : key( keyval )	{}
	};

protected:
	// Association
	class CAssoc : public CPair
	{
		friend class CMap<KEY,ARG_KEY,VALUE,ARG_VALUE>;
		CAssoc* pNext;
		UINT nHashValue;  // needed for efficient iteration
	public:
		CAssoc( ARG_KEY key ) : CPair( key ) {}
	};

public:
// Construction
	/* explicit */ CMap(INT_PTR nBlockSize = 10);

// Attributes
	// number of elements
	INT_PTR GetCount() const;
	INT_PTR GetSize() const;
	BOOL IsEmpty() const;

	// Lookup
	BOOL Lookup(ARG_KEY key, VALUE& rValue) const;
	const CPair *PLookup(ARG_KEY key) const;
	CPair *PLookup(ARG_KEY key);

// Operations
	// Lookup and add if not there
	VALUE& operator[](ARG_KEY key);

	// add a new (key, value) pair
	void SetAt(ARG_KEY key, ARG_VALUE newValue);

	// removing existing (key, ?) pair
	BOOL RemoveKey(ARG_KEY key);
	void RemoveAll();

	// iterating all (key, value) pairs
	POSITION GetStartPosition() const;

	const CPair *PGetFirstAssoc() const;
	CPair *PGetFirstAssoc();

	void GetNextAssoc(POSITION& rNextPosition, KEY& rKey, VALUE& rValue) const;

	const CPair *PGetNextAssoc(const CPair *pAssocRet) const;
	CPair *PGetNextAssoc(const CPair *pAssocRet);

	// advanced features for derived classes
	UINT GetHashTableSize() const;
	void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
	CAssoc** m_pHashTable;
	UINT m_nHashTableSize;
	INT_PTR m_nCount;
	CAssoc* m_pFreeList;
	struct CPlex* m_pBlocks;
	INT_PTR m_nBlockSize;

	CAssoc* NewAssoc(ARG_KEY key);
	void FreeAssoc(CAssoc*);
	CAssoc* GetAssocAt(ARG_KEY, UINT&, UINT&) const;

public:
	~CMap();
	void Serialize(CArchive&);
#ifdef _DEBUG
	void Dump(CDumpContext&) const;
	void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
	{ return m_nCount; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE INT_PTR CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetSize() const
	{ return m_nCount; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
	{ return m_nCount == 0; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
	{ (*this)[key] = newValue; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE POSITION CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
	{ return (m_nCount == 0) ? NULL : BEFORE_START_POSITION; }

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc() const
{ 
	ASSERT_VALID(this);
	if(m_nCount == 0) return NULL;

	AFXASSUME(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetFirstAssoc()
{ 
	ASSERT_VALID(this);
	if(m_nCount == 0) return NULL;

	AFXASSUME(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)BEFORE_START_POSITION;

	// find the first association
	for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			break;
	ASSERT(pAssocRet != NULL);  // must find something

	return pAssocRet;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
AFX_INLINE UINT CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
	{ return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CMap(INT_PTR nBlockSize)
{
	ASSERT(nBlockSize > 0);

	m_pHashTable = NULL;
	m_nHashTableSize = 17;  // default size
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks = NULL;
	m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
	UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
	ASSERT_VALID(this);
	ASSERT(m_nCount == 0);
	ASSERT(nHashSize > 0);

	if (m_pHashTable != NULL)
	{
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}

	if (bAllocNow)
	{
		m_pHashTable = new CAssoc* [nHashSize];
		ENSURE(m_pHashTable != NULL);
		memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
	}
	m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
	ASSERT_VALID(this);

	if (m_pHashTable != NULL)
	{
		// destroy elements (values and keys)
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				pAssoc->CAssoc::~CAssoc();
				//DestructElements<VALUE>(&pAssoc->value, 1);
				//DestructElements<KEY>((KEY*)&pAssoc->key, 1);
			}
		}
		
		// free hash table
		delete[] m_pHashTable;
		m_pHashTable = NULL;
	}
	
	m_nCount = 0;
	m_pFreeList = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CMap()
{
	RemoveAll();
	ASSERT(m_nCount == 0);
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc(ARG_KEY key)
{
	if (m_pFreeList == NULL)
	{
		// add another block
		CPlex* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CMap::CAssoc));
		// chain them into free list
		CMap::CAssoc* pAssoc = (CMap::CAssoc*) newBlock->data();
		// free in reverse order to make it easier to debug
		pAssoc += m_nBlockSize - 1;
		for (INT_PTR i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
		{
			pAssoc->pNext = m_pFreeList;
			m_pFreeList = pAssoc;
		}
	}
	ENSURE(m_pFreeList != NULL);  // we must have something

	CMap::CAssoc* pAssoc = m_pFreeList;

	// zero the memory
	CMap::CAssoc* pTemp = pAssoc->pNext;
	memset( pAssoc, 0, sizeof(CMap::CAssoc) );
	pAssoc->pNext = pTemp;

	m_pFreeList = m_pFreeList->pNext;
	m_nCount++;
	ASSERT(m_nCount > 0);  // make sure we don't overflow
#pragma push_macro("new")
#undef new
	::new(pAssoc) CMap::CAssoc(key);
#pragma pop_macro("new")
//	ConstructElements<KEY>(&pAssoc->key, 1);
//	ConstructElements<VALUE>(&pAssoc->value, 1);   // special construct values
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
	pAssoc->CAssoc::~CAssoc();
//	DestructElements<VALUE>(&pAssoc->value, 1);
//	DestructElements<KEY>(&pAssoc->key, 1);
	pAssoc->pNext = m_pFreeList;
	m_pFreeList = pAssoc;
	m_nCount--;
	ASSERT(m_nCount >= 0);  // make sure we don't underflow

	// if no more elements, cleanup completely
	if (m_nCount == 0)
		RemoveAll();
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHashBucket, UINT& nHashValue) const
// find association (or return NULL)
{
	nHashValue = HashKey<ARG_KEY>(key);
	nHashBucket = nHashValue % m_nHashTableSize;

	if (m_pHashTable == NULL)
		return NULL;

	// see if it exists
	CAssoc* pAssoc;
	for (pAssoc = m_pHashTable[nHashBucket]; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if (pAssoc->nHashValue == nHashValue && CompareElements(&pAssoc->key, &key))
			return pAssoc;
	}
	return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	if (pAssoc == NULL)
		return FALSE;  // not in map

	rValue = pAssoc->value;
	return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PLookup(ARG_KEY key) const
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PLookup(ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc = GetAssocAt(key, nHashBucket, nHashValue);
	return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
	ASSERT_VALID(this);

	UINT nHashBucket, nHashValue;
	CAssoc* pAssoc;
	if ((pAssoc = GetAssocAt(key, nHashBucket, nHashValue)) == NULL)
	{
		if (m_pHashTable == NULL)
			InitHashTable(m_nHashTableSize);

		ENSURE(m_pHashTable);
		// it doesn't exist, add a new Association
		pAssoc = NewAssoc(key);
		pAssoc->nHashValue = nHashValue;
		//'pAssoc->value' is a constructed object, nothing more

		// put into hash table
		pAssoc->pNext = m_pHashTable[nHashBucket];
		m_pHashTable[nHashBucket] = pAssoc;
	}
	return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
	ASSERT_VALID(this);

	if (m_pHashTable == NULL)
		return FALSE;  // nothing in the table

	UINT nHashValue;
	CAssoc** ppAssocPrev;
	nHashValue = HashKey<ARG_KEY>(key);
	ppAssocPrev = &m_pHashTable[nHashValue%m_nHashTableSize];

	CAssoc* pAssoc;
	for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
	{
		if ((pAssoc->nHashValue == nHashValue) && CompareElements(&pAssoc->key, &key))
		{
			// remove it
			*ppAssocPrev = pAssoc->pNext;  // remove from list
			FreeAssoc(pAssoc);
			return TRUE;
		}
		ppAssocPrev = &pAssoc->pNext;
	}
	return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(POSITION& rNextPosition,
	KEY& rKey, VALUE& rValue) const
{
	ASSERT_VALID(this);
	ENSURE(m_pHashTable != NULL);  // never call on empty map

	CAssoc* pAssocRet = (CAssoc*)rNextPosition;
	ENSURE(pAssocRet != NULL);

	if (pAssocRet == (CAssoc*) BEFORE_START_POSITION)
	{
		// find the first association
		for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
		{
			if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
			{
				break;
			}
		}
		ENSURE(pAssocRet != NULL);  // must find something
	}

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	rNextPosition = (POSITION) pAssocNext;

	// fill in return data
	rKey = pAssocRet->key;
	rValue = pAssocRet->value;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetNextAssoc(const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* pPairRet) const
{
	ASSERT_VALID(this);

	CAssoc* pAssocRet = (CAssoc*)pPairRet;

	ASSERT(m_pHashTable != NULL);  // never call on empty map
	ASSERT(pAssocRet != NULL);
	
	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
		
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION);

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair*
CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::PGetNextAssoc(const typename CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CPair* pPairRet)
{
	ASSERT_VALID(this);

	CAssoc* pAssocRet = (CAssoc*)pPairRet;

	ASSERT(m_pHashTable != NULL);  // never call on empty map
	ASSERT(pAssocRet != NULL);
	
	if(m_pHashTable == NULL || pAssocRet == NULL)
		return NULL;
		
	ASSERT(pAssocRet != (CAssoc*)BEFORE_START_POSITION);

	// find next association
	ASSERT(AfxIsValidAddress(pAssocRet, sizeof(CAssoc)));
	CAssoc* pAssocNext;
	if ((pAssocNext = pAssocRet->pNext) == NULL)
	{
		// go to next bucket
		for (UINT nBucket = (pAssocRet->nHashValue % m_nHashTableSize) + 1;
		  nBucket < m_nHashTableSize; nBucket++)
			if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
				break;
	}

	return pAssocNext;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Serialize(CArchive& ar)
{
	ASSERT_VALID(this);

	CObject::Serialize(ar);

	if (ar.IsStoring())
	{
		ar.WriteCount(m_nCount);
		if (m_nCount == 0)
			return;  // nothing more to do

		ASSERT(m_pHashTable != NULL);
		for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
		{
			CAssoc* pAssoc;
			for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
			  pAssoc = pAssoc->pNext)
			{
				KEY* pKey;
				VALUE* pValue;
				/* 
				 * in some cases the & operator might be overloaded, and we cannot use it to 
				 * obtain the address of a given object.  We then use the following trick to 
				 * get the address
				 */
				pKey = reinterpret_cast< KEY* >( &reinterpret_cast< int& >( const_cast< KEY& > ( static_cast< const KEY& >( pAssoc->key ) ) ) );
				pValue = reinterpret_cast< VALUE* >( &reinterpret_cast< int& >( static_cast< VALUE& >( pAssoc->value ) ) );
				SerializeElements<KEY>(ar, pKey, 1);
				SerializeElements<VALUE>(ar, pValue, 1);
			}
		}
	}
	else
	{
		DWORD_PTR nNewCount = ar.ReadCount();
		while (nNewCount--)
		{
			KEY newKey[1];
			VALUE newValue[1];
			SerializeElements<KEY>(ar, newKey, 1);
			SerializeElements<VALUE>(ar, newValue, 1);
			SetAt(newKey[0], newValue[0]);
		}
	}
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Dump(CDumpContext& dc) const
{
	CObject::Dump(dc);

	dc << "with " << m_nCount << " elements";
	if (dc.GetDepth() > 0)
	{
		// Dump in format "[key] -> value"
		KEY key[1];
		VALUE val[1];

		POSITION pos = GetStartPosition();
		while (pos != NULL)
		{
			GetNextAssoc(pos, key[0], val[0]);
			dc << "\n\t[";
			DumpElements<KEY>(dc, key, 1);
			dc << "] = ";
			DumpElements<VALUE>(dc, val, 1);
		}
	}

	dc << "\n";
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
	CObject::AssertValid();

	ASSERT(m_nHashTableSize > 0);
	ASSERT(m_nCount == 0 || m_pHashTable != NULL);
		// non-empty map should have hash table
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrArray<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class CTypedPtrArray : public BASE_CLASS
{
public:
	// Accessing elements
	TYPE GetAt(INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::GetAt(nIndex); }
	TYPE& ElementAt(INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::ElementAt(nIndex); }
	void SetAt(INT_PTR nIndex, TYPE ptr)
		{ BASE_CLASS::SetAt(nIndex, ptr); }

	// Potentially growing the array
	void SetAtGrow(INT_PTR nIndex, TYPE newElement)
		{ BASE_CLASS::SetAtGrow(nIndex, newElement); }
	INT_PTR Add(TYPE newElement)
		{ return BASE_CLASS::Add(newElement); }
	INT_PTR Append(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ return BASE_CLASS::Append(src); }
	void Copy(const CTypedPtrArray<BASE_CLASS, TYPE>& src)
		{ BASE_CLASS::Copy(src); }

	// Operations that move elements around
	void InsertAt(INT_PTR nIndex, TYPE newElement, INT_PTR nCount = 1)
		{ BASE_CLASS::InsertAt(nIndex, newElement, nCount); }
	void InsertAt(INT_PTR nStartIndex, CTypedPtrArray<BASE_CLASS, TYPE>* pNewArray)
		{ BASE_CLASS::InsertAt(nStartIndex, pNewArray); }

	// overloaded operator helpers
	TYPE operator[](INT_PTR nIndex) const
		{ return (TYPE)BASE_CLASS::operator[](nIndex); }
	TYPE& operator[](INT_PTR nIndex)
		{ return (TYPE&)BASE_CLASS::operator[](nIndex); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrList<BASE_CLASS, TYPE>

template<class BASE_CLASS, class TYPE>
class _CTypedPtrList : public BASE_CLASS
{
public:
// Construction
	_CTypedPtrList(INT_PTR nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// peek at head or tail
	TYPE& GetHead()
		{ return (TYPE&)BASE_CLASS::GetHead(); }
	TYPE GetHead() const
		{ return (TYPE)BASE_CLASS::GetHead(); }
	TYPE& GetTail()
		{ return (TYPE&)BASE_CLASS::GetTail(); }
	TYPE GetTail() const
		{ return (TYPE)BASE_CLASS::GetTail(); }

	// get head or tail (and remove it) - don't call on empty list!
	TYPE RemoveHead()
		{ return (TYPE)BASE_CLASS::RemoveHead(); }
	TYPE RemoveTail()
		{ return (TYPE)BASE_CLASS::RemoveTail(); }

	// iteration
	TYPE& GetNext(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetNext(rPosition); }
	TYPE GetNext(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetNext(rPosition); }
	TYPE& GetPrev(POSITION& rPosition)
		{ return (TYPE&)BASE_CLASS::GetPrev(rPosition); }
	TYPE GetPrev(POSITION& rPosition) const
		{ return (TYPE)BASE_CLASS::GetPrev(rPosition); }

	// getting/modifying an element at a given position
	TYPE& GetAt(POSITION position)
		{ return (TYPE&)BASE_CLASS::GetAt(position); }
	TYPE GetAt(POSITION position) const
		{ return (TYPE)BASE_CLASS::GetAt(position); }
	void SetAt(POSITION pos, TYPE newElement)
		{ BASE_CLASS::SetAt(pos, newElement); }

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, TYPE newElement)
		{ return BASE_CLASS::InsertBefore(position, newElement); }
	POSITION InsertAfter(POSITION position, TYPE newElement)
		{ return BASE_CLASS::InsertAfter(position, newElement); }

	// transfer before or after a given position
	// Transfer semantics ensure no leakage by deleting the element in the case of an exception
	POSITION TransferInsertBefore(POSITION position, TYPE newElement)
	{
		try
		{
			return BASE_CLASS::InsertBefore(position, newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}

	POSITION TransferInsertAfter(POSITION position, TYPE newElement)
	{
		try
		{
			return BASE_CLASS::InsertAfter(position, newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}
};

template<class BASE_CLASS, class TYPE>
class CTypedPtrList : public _CTypedPtrList<BASE_CLASS, TYPE>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<BASE_CLASS, TYPE>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(TYPE newElement)
		{ return BASE_CLASS::AddHead(newElement); }
	POSITION AddTail(TYPE newElement)
		{ return BASE_CLASS::AddTail(newElement); }

	// transfer add before head or tail
	POSITION TransferAddHead(TYPE newElement)
	{ 
		try
		{
			return BASE_CLASS::AddHead(newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}
	POSITION TransferAddTail(TYPE newElement)
	{ 
		try
		{
			return BASE_CLASS::AddTail(newElement); 
		}
		catch(...)
		{
			delete newElement;
			throw;
		}
	}

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddHead(pNewList); }
	void AddTail(CTypedPtrList<BASE_CLASS, TYPE>* pNewList)
		{ BASE_CLASS::AddTail(pNewList); }
};

// need specialized version for CObList because of AddHead/Tail ambiguity
template<> class CTypedPtrList<CObList, CObList*>
	: public _CTypedPtrList<CObList, CObList*>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<CObList, CObList*>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(CObList* newElement)
		{ return _CTypedPtrList<CObList, CObList*>::AddHead((CObject*)newElement); }
	POSITION AddTail(CObList* newElement)
		{ return _CTypedPtrList<CObList, CObList*>::AddTail((CObject*)newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<CObList, CObList*>* pNewList)
		{ _CTypedPtrList<CObList, CObList*>::AddHead(pNewList); }
	void AddTail(CTypedPtrList<CObList, CObList*>* pNewList)
		{ _CTypedPtrList<CObList, CObList*>::AddTail(pNewList); }
};

// need specialized version for CPtrList because of AddHead/Tail ambiguity
template<> class CTypedPtrList<CPtrList, CPtrList*>
	: public _CTypedPtrList<CPtrList, CPtrList*>
{
public:
// Construction
	CTypedPtrList(INT_PTR nBlockSize = 10)
		: _CTypedPtrList<CPtrList, CPtrList*>(nBlockSize) { }

	// add before head or after tail
	POSITION AddHead(CPtrList* newElement)
		{ return _CTypedPtrList<CPtrList, CPtrList*>::AddHead((void*)newElement); }
	POSITION AddTail(CPtrList* newElement)
		{ return _CTypedPtrList<CPtrList, CPtrList*>::AddTail((void*)newElement); }

	// add another list of elements before head or after tail
	void AddHead(CTypedPtrList<CPtrList, CPtrList*>* pNewList)
		{ _CTypedPtrList<CPtrList, CPtrList*>::AddHead(pNewList); }
	void AddTail(CTypedPtrList<CPtrList, CPtrList*>* pNewList)
		{ _CTypedPtrList<CPtrList, CPtrList*>::AddTail(pNewList); }
};

/////////////////////////////////////////////////////////////////////////////
// CTypedPtrMap<BASE_CLASS, KEY, VALUE>

template<class BASE_CLASS, class KEY, class VALUE>
class CTypedPtrMap : public BASE_CLASS
{
public:

// Construction
	CTypedPtrMap(INT_PTR nBlockSize = 10)
		: BASE_CLASS(nBlockSize) { }

	// Lookup
	BOOL Lookup(typename BASE_CLASS::BASE_ARG_KEY key, VALUE& rValue) const
		{ return BASE_CLASS::Lookup(key, (BASE_CLASS::BASE_VALUE&)rValue); }

	// Lookup and add if not there
	VALUE& operator[](typename BASE_CLASS::BASE_ARG_KEY key)
		{ return (VALUE&)BASE_CLASS::operator[](key); }

	// add a new key (key, value) pair
	void SetAt(KEY key, VALUE newValue)
		{ BASE_CLASS::SetAt(key, newValue); }

	// removing existing (key, ?) pair
	BOOL RemoveKey(KEY key)
		{ return BASE_CLASS::RemoveKey(key); }

	// iteration
	void GetNextAssoc(POSITION& rPosition, KEY& rKey, VALUE& rValue) const
		{ BASE_CLASS::GetNextAssoc(rPosition, (BASE_CLASS::BASE_KEY&)rKey,
			(BASE_CLASS::BASE_VALUE&)rValue); }
};

/////////////////////////////////////////////////////////////////////////////

#undef THIS_FILE
#define THIS_FILE __FILE__

#pragma pop_macro("new")

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#pragma warning( pop )

#endif //__AFXTEMPL_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtaskspaneframewnd.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxpaneframewnd.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_CAPTION_BTN_LEFT   0x10
#define AFX_CAPTION_BTN_RIGHT  0x20
#define AFX_CAPTION_BTN_TPMENU 0x40

class CMFCTasksPaneFrameWnd : public CPaneFrameWnd
{
	DECLARE_SERIAL(CMFCTasksPaneFrameWnd)
public:
	CMFCTasksPaneFrameWnd();
	virtual ~CMFCTasksPaneFrameWnd();

// Operations
public:
	virtual void SetCaptionButtons(DWORD dwButtons);
	void SetTaskPaneCaptionButtons();

	virtual void CalcBorderSize(CRect& rectBorderSize) const;

protected:
	//{{AFX_MSG(CMFCTasksPaneFrameWnd)
	afx_msg void OnNcPaint();
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	virtual void AddButton(UINT nHit);
	virtual void OnTrackCaptionButtons(CPoint point);
	virtual void StopCaptionButtonsTracking();

	virtual void OnDrawBorder(CDC* pDC);
	virtual void OnDrawCaptionButtons(CDC* pDC);
	virtual void OnPressButtons(UINT nHit);
	
	BOOL m_bMenuBtnPressed;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtaskspane.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxdockablepane.h"
#include "afxcaptionmenubutton.h"
#include "afxtoolbar.h"
#include "afxtaskspaneframewnd.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane additional classes

class CMFCTasksPane;

class CMFCTasksPanePropertyPage : public CObject
{
public:
	CMFCTasksPanePropertyPage(LPCTSTR lpszName, CMFCTasksPane *pTaskPane)
	{
		m_strName = lpszName;
		m_pTaskPane = pTaskPane;
	}

	virtual ~CMFCTasksPanePropertyPage()
	{
		m_pTaskPane = NULL;
	}

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	CString     m_strName;
	CMFCTasksPane* m_pTaskPane;
};

class CMFCTasksPaneTaskGroup : public CObject
{
public:
	CMFCTasksPaneTaskGroup(LPCTSTR lpszName, BOOL bIsBottom, BOOL bIsSpecial = FALSE, BOOL bIsCollapsed = FALSE, CMFCTasksPanePropertyPage* pPage = NULL, HICON hIcon = NULL)
	{
		m_pPage = pPage;
		m_strName =  lpszName;
		m_bIsBottom = bIsBottom;
		m_bIsSpecial = bIsSpecial;
		m_rect.SetRectEmpty();
		m_rectGroup.SetRectEmpty();
		m_bIsCollapsed = bIsCollapsed;
		m_hIcon = hIcon;
		m_sizeIcon = CSize(0, 0);

		m_clrText    = (COLORREF)-1;
		m_clrTextHot = (COLORREF)-1;

		ICONINFO iconInfo;
		::ZeroMemory(&iconInfo, sizeof(iconInfo));
		::GetIconInfo(m_hIcon, &iconInfo);
		
		BITMAP bm;
		::ZeroMemory(&bm, sizeof(bm));
		::GetObject(iconInfo.hbmColor, sizeof(BITMAP), &bm);

		m_sizeIcon = CSize(bm.bmWidth, bm.bmHeight);

		::DeleteObject(iconInfo.hbmColor);
		::DeleteObject(iconInfo.hbmMask);
	}

	virtual ~CMFCTasksPaneTaskGroup()
	{
		while (!m_lstTasks.IsEmpty())
		{
			delete m_lstTasks.RemoveHead();
		}
		m_pPage = NULL;
	}

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	CMFCTasksPanePropertyPage* m_pPage;
	CString  m_strName;
	CObList  m_lstTasks;
	BOOL     m_bIsBottom;
	BOOL     m_bIsSpecial;
	BOOL     m_bIsCollapsed;
	CRect    m_rect;
	CRect    m_rectGroup;
	CSize    m_sizeIcon;
	HICON    m_hIcon;
	COLORREF m_clrText;
	COLORREF m_clrTextHot;
};

class CMFCTasksPaneTask : public CObject
{
public:
	CMFCTasksPaneTask(CMFCTasksPaneTaskGroup* pGroup, LPCTSTR lpszName, int nIcon, UINT uiCommandID, DWORD dwUserData = 0, HWND hwndTask = NULL, BOOL bAutoDestroyWindow = FALSE, int nWindowHeight = 0)
	{
		m_pGroup = pGroup;
		m_strName = lpszName == NULL ? _T("") : lpszName;
		m_nIcon = nIcon;
		m_uiCommandID = uiCommandID;
		m_dwUserData = dwUserData;
		m_hwndTask = hwndTask;
		m_bAutoDestroyWindow = bAutoDestroyWindow;
		m_nWindowHeight = nWindowHeight;
		m_bVisible = TRUE;
		m_bEnabled = TRUE;
		m_bIsSeparator = lpszName == NULL;
		m_clrText = (COLORREF)-1;
		m_clrTextHot = (COLORREF)-1;
		m_bIsBold = FALSE;

		m_rect.SetRectEmpty();
	}

	virtual ~CMFCTasksPaneTask()
	{
		if (m_hwndTask != NULL && m_bAutoDestroyWindow)
		{
			CWnd* pWnd = CWnd::FromHandlePermanent(m_hwndTask);
			if (pWnd != NULL)
			{
				pWnd->DestroyWindow();
				delete pWnd;
			}
			else
			{
				::DestroyWindow(m_hwndTask);
			}
		}
		m_pGroup = NULL;
	}

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	CMFCTasksPaneTaskGroup* m_pGroup;
	CString  m_strName;
	CRect    m_rect;
	int      m_nIcon;
	int      m_nWindowHeight;
	UINT     m_uiCommandID;
	DWORD    m_dwUserData;
	HWND     m_hwndTask;
	BOOL     m_bAutoDestroyWindow;
	BOOL     m_bVisible;
	BOOL     m_bEnabled;
	BOOL     m_bIsSeparator;
	BOOL     m_bIsBold; // For labels only
	COLORREF m_clrText;
	COLORREF m_clrTextHot;
};

class CMFCTasksPaneToolBar : public CMFCToolBar
{
	friend class CMFCTasksPane;

	DECLARE_SERIAL(CMFCTasksPaneToolBar)

// Overrides
public:
	CMFCTasksPaneToolBar()
	{
		m_pBtnBack = NULL;
		m_pBtnForward = NULL;
	}

	virtual BOOL AllowShowOnList() const { return FALSE; }
	virtual BOOL AllowShowOnPaneMenu() const { return FALSE; }
	virtual BOOL IsButtonExtraSizeAvailable() const { return FALSE; }

	void UpdateMenuButtonText(const CString& str);
	void UpdateButtons();

protected:
	virtual void AdjustLayout();
	virtual void AdjustLocations();
	virtual BOOL OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const;

	//{{AFX_MSG(CMFCTasksPaneToolBar)
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCToolBarMenuButton* m_pBtnBack;
	CMFCToolBarMenuButton* m_pBtnForward;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCTasksPane window

class CMFCTasksPane : public CDockablePane
{
	DECLARE_SERIAL(CMFCTasksPane);

// Construction
public:
	CMFCTasksPane();

// Attributes
protected:
	BOOL m_bCanCollapse;
	BOOL m_bUseNavigationToolbar;
	BOOL m_bHistoryMenuButtons;
	BOOL m_bUseScrollButtons;
	BOOL m_bAnimationEnabled;
	BOOL m_bOffsetCustomControls;
	BOOL m_bMenuBtnPressed;
	BOOL m_bWrapTasks;
	BOOL m_bWrapLabels;

	int m_iActivePage;
	int m_iScrollMode;   // -1 - Up, 0 - None, 1 - Down
	int m_iScrollBtnHeight;
	int m_nVertScrollOffset;
	int m_nVertScrollTotal;
	int m_nVertScrollPage;
	int m_nRowHeight;
	int m_nAnimGroupExtraHeight;
	int m_nVertMargin;
	int m_nHorzMargin;
	int m_nGroupVertOffset;
	int m_nGroupCaptionHeight;
	int m_nGroupCaptionHorzOffset;
	int m_nGroupCaptionVertOffset;
	int m_nTasksHorzOffset;
	int m_nTasksIconHorzOffset;
	int m_nTasksIconVertOffset;

	const int m_nMaxHistory;
	UINT      m_uiToolbarBmpRes;

	HFONT  m_hFont;
	CFont  m_fontBold;
	CFont  m_fontBoldUnderline;
	CFont  m_fontUnderline;
	CSize  m_sizeIcon;
	CSize  m_sizeToolbarImage;
	CSize  m_sizeToolbarButton;
	CSize  m_sizeAnim;
	CRect  m_rectToolbar;
	CRect  m_rectScrollUp;
	CRect  m_rectScrollDn;
	CRect  m_rectTasks;
	CMenu  m_menuOther;
	CMFCTasksPaneTask* m_pHotTask;
	CMFCTasksPaneTask* m_pClickedTask;

	CObList m_lstTasksPanes;
	CObList m_lstTaskGroups;
	CString m_strCaption;

	CScrollBar m_wndScrollVert; // Vertical scroll bar
	CImageList m_lstIcons;

	CArray<int, int> m_arrHistoryStack;

	CMFCTasksPaneTaskGroup* m_pHotGroupCaption;
	CMFCTasksPaneTaskGroup* m_pClickedGroupCaption;
	CMFCTasksPaneTaskGroup* m_pAnimatedGroup;

	CMFCTasksPaneToolBar m_wndToolBar;

	AFX_IMPORT_DATA static clock_t m_nLastAnimTime;
	AFX_IMPORT_DATA static const int m_nAnimTimerDuration;
	AFX_IMPORT_DATA static const int m_nScrollTimerDuration;

// Operations
public:
	BOOL SetIconsList(UINT uiImageListResID, int cx, COLORREF clrTransparent = RGB(255, 0, 255));
	void SetIconsList(HIMAGELIST hIcons);

	void RecalcLayout(BOOL bRedraw = TRUE);

	// --------------
	// Pages support:
	// --------------
	int AddPage(LPCTSTR lpszPageLabel);
	void RemovePage(int nPageIdx);
	void RemoveAllPages();

	int GetPagesCount() const { return (int) m_lstTasksPanes.GetCount(); }

	void SetActivePage(int nPageIdx);
	int GetActivePage() const { return m_arrHistoryStack[m_iActivePage]; }

	void GetPreviousPages(CStringList& lstPrevPages) const;
	void GetNextPages(CStringList&  lstNextPages) const;

	void SetCaption(LPCTSTR lpszName);
	void SetPageCaption(int nPageIdx, LPCTSTR lpszName);

	BOOL GetPageByGroup(int nGroup, int &nPage) const;

	virtual void OnPressBackButton();
	virtual void OnPressForwardButton();
	virtual void OnPressHomeButton();
	virtual void OnPressOtherButton(CMFCCaptionMenuButton* pbtn, CWnd* pWndOwner);
	BOOL IsBackButtonEnabled() const { return m_iActivePage > 0; }
	BOOL IsForwardButtonEnabled() const { return m_iActivePage < m_arrHistoryStack.GetUpperBound(); }

	virtual BOOL IsAccessibilityCompatible() { return TRUE; }
	virtual BOOL OnSetAccData(long lVal);

	// --------------
	// Group support:
	// --------------
	int AddGroup(int nPageIdx, LPCTSTR lpszGroupName, BOOL bBottomLocation = FALSE, BOOL bSpecial = FALSE, HICON hIcon = NULL);
	int AddGroup(LPCTSTR lpszGroupName, BOOL bBottomLocation = FALSE, BOOL bSpecial = FALSE, HICON hIcon = NULL)
	{
		return AddGroup(0, lpszGroupName, bBottomLocation, bSpecial, hIcon);
	}
	void RemoveGroup(int nGroup);
	void RemoveAllGroups(int nPageIdx = 0);

	BOOL SetGroupName(int nGroup, LPCTSTR lpszGroupName);
	BOOL SetGroupTextColor(int nGroup, COLORREF color, COLORREF colorHot = (COLORREF)-1);
	BOOL CollapseGroup(CMFCTasksPaneTaskGroup* pGroup, BOOL bCollapse = TRUE);

	BOOL CollapseGroup(int nGroup, BOOL bCollapse = TRUE) { return CollapseGroup(GetTaskGroup(nGroup), bCollapse); }

	void CollapseAllGroups(BOOL bCollapse = TRUE);
	void CollapseAllGroups(int nPageIdx, BOOL bCollapse);

	void EnableGroupCollapse(BOOL bEnable)
	{
		if (!bEnable)
		{
			CollapseAllGroups(FALSE);
		}
		m_bCanCollapse = bEnable;
	}
	BOOL IsGroupCollapseEnabled() const { return m_bCanCollapse; }

	CMFCTasksPaneTaskGroup* GetTaskGroup(int nGroup) const;
	BOOL GetGroupLocation(CMFCTasksPaneTaskGroup* pGroup, int &nGroup) const;
	int GetGroupCount() const { return (int) m_lstTaskGroups.GetCount(); }

	// -------------
	// Task support:
	// -------------
	int AddTask(int nGroup, LPCTSTR lpszTaskName, int nTaskIcon = -1, UINT uiCommandID = 0, DWORD dwUserData = 0);
	int AddSeparator(int nGroup) { return AddTask(nGroup, NULL); }

	BOOL SetTaskName(int nGroup, int nTask, LPCTSTR lpszTaskName);
	BOOL SetTaskTextColor(int nGroup, int nTask, COLORREF color, COLORREF colorHot = (COLORREF)-1);
	BOOL ShowTask(int nGroup, int nTask, BOOL bShow = TRUE, BOOL bRedraw = TRUE);
	BOOL ShowTaskByCmdId(UINT uiCommandID, BOOL bShow = TRUE, BOOL bRedraw = TRUE);
	BOOL RemoveTask(int nGroup, int nTask, BOOL bRedraw = TRUE);
	void RemoveAllTasks(int nGroup);
	BOOL GetTaskLocation(UINT uiCommandID, int& nGroup, int& nTask) const;
	BOOL GetTaskLocation(HWND hwndTask, int& nGroup, int& nTask) const;
	CMFCTasksPaneTask* GetTask(int nGroup, int nTask) const;
	BOOL GetTaskLocation(CMFCTasksPaneTask* pTask, int &nGroup, int& nTask) const;

	int GetTaskCount(int nGroup) const
	{
		ASSERT(nGroup >= 0);
		ASSERT(nGroup < m_lstTaskGroups.GetCount());
		CMFCTasksPaneTaskGroup* pGroup = GetTaskGroup(nGroup);
		ASSERT_VALID(pGroup);
		return (int) pGroup->m_lstTasks.GetCount();
	}
	
	int AddWindow(int nGroup, HWND hwndTask, int nWndHeight, BOOL bAutoDestroyWindow = FALSE, DWORD dwUserData = 0);
	BOOL SetWindowHeight(int nGroup, HWND hwndTask, int nWndHeight);
	BOOL SetWindowHeight(HWND hwndTask, int nWndHeight);

	int AddLabel(int nGroup, LPCTSTR lpszLabelName, int nTaskIcon = -1, BOOL bIsBold = FALSE)
	{
		int nTask = AddTask(nGroup, lpszLabelName, nTaskIcon);
		if (nTask == -1 || !bIsBold)
		{
			return nTask;
		}

		POSITION pos = m_lstTaskGroups.FindIndex(nGroup);
		if (pos == NULL)
		{
			ASSERT(FALSE);
			return -1;
		}

		CMFCTasksPaneTaskGroup* pGroup = (CMFCTasksPaneTaskGroup*) m_lstTaskGroups.GetAt(pos);
		ASSERT_VALID(pGroup);

		CMFCTasksPaneTask* pTask = (CMFCTasksPaneTask*)pGroup->m_lstTasks.GetTail();
		if (pTask != NULL)
		{
			pTask->m_bIsBold = bIsBold;
		}

		return nTask;
	}

	int AddMRUFilesList(int nGroup, int nMaxFiles = 4);

	// --------
	// Margins:
	// --------
	int GetVertMargin() const { return m_nVertMargin; }
	void SetVertMargin(int n = -1)
	{
		ASSERT(n >= -1);
		m_nVertMargin = n;
	}

	int GetHorzMargin() const { return m_nHorzMargin; }
	void SetHorzMargin(int n = -1)
	{
		ASSERT(n >= -1);
		m_nHorzMargin = n;
	}

	int GetGroupVertOffset() const { return m_nGroupVertOffset; }
	void SetGroupVertOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nGroupVertOffset = n;
	}

	int GetGroupCaptionHeight() const { return m_nGroupCaptionHeight; }
	void SetGroupCaptionHeight(int n = -1)
	{
		ASSERT(n >= -1);
		m_nGroupCaptionHeight = n;
	}

	int GetGroupCaptionHorzOffset() const { return m_nGroupCaptionHorzOffset; }
	void SetGroupCaptionHorzOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nGroupCaptionHorzOffset = n;
	}

	int GetGroupCaptionVertOffset() const { return m_nGroupCaptionVertOffset; }
	void SetGroupCaptionVertOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nGroupCaptionVertOffset = n;
	}

	int GetTasksHorzOffset() const { return m_nTasksHorzOffset; }
	void SetTasksHorzOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nTasksHorzOffset = n;
	}

	int GetTasksIconHorzOffset() const { return m_nTasksIconHorzOffset; }
	void SetTasksIconHorzOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nTasksIconHorzOffset = n;
	}

	int GetTasksIconVertOffset() const { return m_nTasksIconVertOffset; }
	void SetTasksIconVertOffset(int n = -1)
	{
		ASSERT(n >= -1);
		m_nTasksIconVertOffset = n;
	}

	void EnableOffsetCustomControls(BOOL bEnable) { m_bOffsetCustomControls = bEnable; }

	// ---------
	// Behavior:
	// ---------
	void EnableScrollButtons(BOOL bEnable = TRUE) { m_bUseScrollButtons = bEnable; }

	void EnableNavigationToolbar(BOOL bEnable = TRUE, UINT uiToolbarBmpRes = 0, CSize sizeToolbarImage = CSize(0, 0), CSize sizeToolbarButton = CSize(0, 0));
	BOOL IsNavigationToolbarEnabled() const { return m_bUseNavigationToolbar; }

	void EnableAnimation(BOOL bEnable = TRUE) { m_bAnimationEnabled = bEnable; }
	BOOL IsAnimationEnabled() const { return m_bAnimationEnabled; }

	void EnableHistoryMenuButtons(BOOL bEnable = TRUE);
	BOOL IsHistoryMenuButtonsEnabled() const { return m_bHistoryMenuButtons; }

	void EnableWrapTasks(BOOL bEnable = TRUE) { m_bWrapTasks = bEnable; }
	BOOL IsWrapTasksEnabled() const { return m_bWrapTasks; }

	void EnableWrapLabels(BOOL bEnable = TRUE) { m_bWrapLabels = bEnable; }
	BOOL IsWrapLabelsEnabled() const { return m_bWrapLabels; }

// Overrides
public:
	virtual void OnClickTask(int nGroupNumber, int nTaskNumber, UINT uiCommandID, DWORD dwUserData);

public:
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
	virtual void Serialize(CArchive& ar);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual CPaneFrameWnd* CreateDefaultMiniframe(CRect rectInitial);

	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	virtual void ShowCommandMessageString(UINT uiCmdId);

	virtual void Update();
	virtual BOOL IsToolBox() const { return FALSE; }

protected:
	virtual void OnFillBackground(CDC* pDC, CRect rectFill);
	virtual void OnDrawTasks(CDC* pDC, CRect rectWorkArea);
	virtual void OnActivateTasksPanePage() {}
	virtual void SetCaptionButtons();
	virtual void DrawCaption(CDC* pDC, CRect rectCaption);
	virtual void OnPressButtons(UINT nHit);

	virtual void OnTrackCaptionButtons(CPoint point);
	virtual void StopCaptionButtonsTracking();

	virtual BOOL GetMRUFileName(CRecentFileList* pRecentFileList, int nIndex, CString &strName);
	virtual CSize GetTasksGroupBorders() const;

	virtual void ScrollChild(HWND /*hwndTask*/, int /*nScrollValue*/) {}

// Implementation
public:
	virtual ~CMFCTasksPane();

	HMENU CreateMenu() const;

protected:
	//{{AFX_MSG(CMFCTasksPane)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnDestroy();
	afx_msg void OnTimer(UINT_PTR nIDEvent);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg LRESULT OnSetFont(WPARAM, LPARAM);
	afx_msg LRESULT OnGetFont(WPARAM, LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg void OnBack();
	afx_msg void OnForward();
	afx_msg void OnHome();
	afx_msg void OnClose();
	afx_msg void OnOther();
	afx_msg void OnUpdateBack(CCmdUI* pCmdUI);
	afx_msg void OnUpdateForward(CCmdUI* pCmdUI);
	afx_msg void OnUpdateClose(CCmdUI* pCmdUI);
	afx_msg LRESULT OnSetText(WPARAM, LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void DoPaint(CDC* pDC);
	virtual int ReposTasks(BOOL bCalcHeightOnly = FALSE);
	void CreateFonts();
	HFONT SetFont(CDC* pDC);
	void SetScrollSizes();
	void AdjustScroll();
	void RebuildMenu();
	void ChangeActivePage(int nNewPageHistoryIdx, int nOldPageHistoryIdx);
	void SaveHistory(int nPageIdx);
	BOOL CreateNavigationToolbar();
	void UpdateCaption();

	BOOL IsScrollUpAvailable() { return m_nVertScrollOffset > 0; }

	BOOL IsScrollDnAvailable() { return m_nVertScrollOffset <= m_nVertScrollTotal - m_nVertScrollPage && m_nVertScrollTotal > 0; }

	BOOL ForceShowNavToolbar() const
	{
		BOOL bIsAttached = GetParentTabbedPane() != NULL;
		CPaneFrameWnd* pMiniFrame = GetParentMiniFrame(TRUE);
		BOOL bNonTasksPaneMiniFrame = pMiniFrame != NULL && !pMiniFrame->IsKindOf( RUNTIME_CLASS(CMFCTasksPaneFrameWnd));
		return bIsAttached || bNonTasksPaneMiniFrame;
	}

	CMFCTasksPaneTask* TaskHitTest(CPoint pt) const;
	virtual CMFCTasksPaneTaskGroup* GroupCaptionHitTest(CPoint pt) const;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbar.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbardroptarget.h"
#include "afxtoolbardropsource.h"
#include "afxtoolbarimages.h"
#include "afxtoolbarbutton.h"
#include "afxcontrolbarimpl.h"
#include "afxcmdusagecount.h"
#include "afxcommandmanager.h"
#include "afxvisualmanager.h"
#include "afxglobals.h"

#include "afxbasetoolbar.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButton;
class CMFCCustomizeButton;
class CSettingsStore;

//-----------------------------------------------
// CMFCToolBar LoadBitmap/LoadToolbar parameters:
//-----------------------------------------------
class CMFCToolBarInfo
{
public:
	CMFCToolBarInfo();

	UINT m_uiColdResID;          // Toolbar regular images
	UINT m_uiHotResID;           // Toolbar "hot" images
	UINT m_uiDisabledResID;      // Toolbar disabled images
	UINT m_uiLargeColdResID;     // Toolbar large regular images
	UINT m_uiLargeHotResID;      // Toolbar large "hot" images
	UINT m_uiLargeDisabledResID; // Toolbar large disabled images
	UINT m_uiMenuResID;          // Menu images
	UINT m_uiMenuDisabledResID;  // Menu disabled images
};

//----------------------------------
// Toolbar notification messages:
//----------------------------------
extern AFX_IMPORT_DATA UINT AFX_WM_TOOLBARMENU;
extern AFX_IMPORT_DATA UINT AFX_WM_CUSTOMIZETOOLBAR;
extern AFX_IMPORT_DATA UINT AFX_WM_CREATETOOLBAR;
extern AFX_IMPORT_DATA UINT AFX_WM_DELETETOOLBAR;
extern AFX_IMPORT_DATA UINT AFX_WM_CUSTOMIZEHELP;
extern AFX_IMPORT_DATA UINT AFX_WM_RESETTOOLBAR;
extern AFX_IMPORT_DATA UINT AFX_WM_RESETMENU;
extern AFX_IMPORT_DATA UINT AFX_WM_SHOWREGULARMENU;
extern AFX_IMPORT_DATA UINT AFX_WM_RESETCONTEXTMENU;
extern AFX_IMPORT_DATA UINT AFX_WM_RESETKEYBOARD;
extern AFX_IMPORT_DATA UINT AFX_WM_RESETRPROMPT;

extern const UINT AFX_ACCELERATOR_TIMER_DELAY;
extern const UINT AFX_ACCELERATOR_NOTIFY_EVENT;

#define AFX_TOOLBAR_LINE_OFFSET 5

class CMFCToolBar : public CMFCBaseToolBar
{
	friend class CMFCToolBarDropTarget;
	friend class CMFCToolBarsListPropertyPage;
	friend class CMFCToolBarsCommandsListBox;
	friend class CMFCCustomizeButton;
	friend class CMFCCustomizeMenuButton;
	friend class CMFCToolTipCtrl;

	DECLARE_SERIAL(CMFCToolBar)

	//--------------
	// Construction:
	//--------------
public:
	CMFCToolBar();
	virtual BOOL Create(CWnd* pParentWnd, DWORD dwStyle = AFX_DEFAULT_TOOLBAR_STYLE, UINT nID = AFX_IDW_TOOLBAR);
	virtual BOOL CreateEx(CWnd* pParentWnd, DWORD dwCtrlStyle = TBSTYLE_FLAT, DWORD dwStyle = AFX_DEFAULT_TOOLBAR_STYLE,
		CRect rcBorders = CRect(1, 1, 1, 1), UINT nID = AFX_IDW_TOOLBAR);

	//----------------------------------------------------------------
	// Set toolbar buttons image resources.
	// You should use SINGLE CMFCToolBarImages for ALL your toolbars!
	//----------------------------------------------------------------
	static BOOL __stdcall SetUserImages(CMFCToolBarImages* pUserImages);
	virtual void ResetImages();	// Reset all toolbar images exept user-derfined to the default

	//------------------------------
	// Clear all images except user:
	//------------------------------
	static void __stdcall ResetAllImages();

	//--------------------------------
	// Dimension manipulation methods:
	//--------------------------------
	static void __stdcall SetSizes(SIZE sizeButton, SIZE sizeImage);
	static void __stdcall SetMenuSizes(SIZE sizeButton, SIZE sizeImage);
	static CSize __stdcall GetMenuImageSize();
	static CSize __stdcall GetMenuButtonSize();

	/// <summary>
	/// Sets the sizes of locked buttons and locked images on the toolbar. </summary>
	/// <param name="sizeButton">Specifies the size of locked toolbar buttons. </param>
	/// <param name="sizeImage">Specifies the size of locked toolbar images. </param>
	/// <param name="bDontScale">Specifies whether to scale or not locked toolbar images in high DPI mode.</param>
	void SetLockedSizes(SIZE sizeButton, SIZE sizeImage, BOOL bDontScale = FALSE);
	void SetHeight(int cyHeight);

	//-----------------
	// Toolbar context:
	//-----------------
	virtual BOOL LoadBitmap(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL bLocked = FALSE, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0);
	virtual BOOL LoadToolBar(UINT uiResID, UINT uiColdResID = 0, UINT uiMenuResID = 0, BOOL bLocked = FALSE,
		UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0,  UINT uiHotResID = 0);
	virtual BOOL LoadBitmapEx(CMFCToolBarInfo& params, BOOL bLocked = FALSE);
	virtual BOOL LoadToolBarEx(UINT uiToolbarResID, CMFCToolBarInfo& params, BOOL bLocked = FALSE);

	//----------------------------
	// Toolbar buttons add/remove:
	//----------------------------
	virtual BOOL SetButtons(const UINT* lpIDArray, int nIDCount, BOOL bRemapImages = TRUE);

	virtual int InsertButton(const CMFCToolBarButton& button, INT_PTR iInsertAt = -1);
	virtual int InsertSeparator(INT_PTR iInsertAt = -1);

	int ReplaceButton(UINT uiCmd, const CMFCToolBarButton& button, BOOL bAll = FALSE);
	
	virtual BOOL RemoveButton(int iIndex);
	virtual void RemoveAllButtons();

	static BOOL __stdcall IsLastCommandFromButton(CMFCToolBarButton* pButton);
	static BOOL __stdcall AddToolBarForImageCollection(UINT uiResID, UINT uiBmpResID = 0, UINT uiColdResID = 0,
		UINT uiMenuResID = 0, UINT uiDisabledResID = 0, UINT uiMenuDisabledResID = 0);

	static void __stdcall SetNonPermittedCommands(CList<UINT, UINT>& lstCommands);
	static BOOL __stdcall IsCommandPermitted(UINT uiCmd) { return m_lstUnpermittedCommands.Find(uiCmd) == NULL; }

	static void __stdcall SetBasicCommands(CList<UINT, UINT>& lstCommands);
	static void __stdcall AddBasicCommand(UINT uiCmd);
	
	static BOOL __stdcall IsBasicCommand(UINT uiCmd) { return m_lstBasicCommands.Find(uiCmd) != NULL; }
	static const CList<UINT, UINT>& __stdcall GetBasicCommands() { return m_lstBasicCommands; }

	static BOOL __stdcall IsCommandRarelyUsed(UINT uiCmd);

	static void __stdcall AddCommandUsage(UINT uiCommand);
	static BOOL __stdcall SetCommandUsageOptions(UINT nStartCount, UINT nMinUsagePercentage = 5);

	virtual int GetRowHeight() const
	{
		if (m_bDrawTextLabels)
		{
			ASSERT(m_nMaxBtnHeight > 0);
			return m_nMaxBtnHeight;
		}
		return max(afxGlobalData.GetTextHeight(m_dwStyle & CBRS_ORIENT_HORZ), (m_bMenuMode ? (m_sizeMenuButton.cy > 0 ? m_sizeMenuButton.cy : m_sizeButton.cy) : GetButtonSize().cy));
	}

	virtual int GetColumnWidth() const
	{
		return m_bMenuMode ? m_sizeMenuButton.cx > 0 ? m_sizeMenuButton.cx : m_sizeButton.cx : GetButtonSize().cx;
	}

	virtual BOOL IsButtonExtraSizeAvailable() const { return TRUE; }

	static void __stdcall SetHelpMode(BOOL bOn = TRUE);
	virtual void Deactivate();
	virtual void RestoreFocus();

	void SetToolBarBtnText(UINT nBtnIndex, LPCTSTR szText = NULL, BOOL bShowText = TRUE, BOOL bShowImage = TRUE);

	virtual BOOL CanFocus() const { return FALSE; }

	void EnableLargeIcons(BOOL bEnable);

	static void __stdcall SetLargeIcons(BOOL bLargeIcons = TRUE);
	static BOOL __stdcall IsLargeIcons() { return m_bLargeIcons; }

	static void __stdcall AutoGrayInactiveImages(BOOL bEnable = TRUE, int nGrayImagePercentage = 0, BOOL bRedrawAllToolbars = TRUE);
	static BOOL __stdcall IsAutoGrayInactiveImages() { return m_bAutoGrayInactiveImages; }

	CSize GetButtonSize() const
	{
		CSize size = m_bLocked ? (m_bLargeIconsAreEnbaled ? m_sizeCurButtonLocked : m_sizeButtonLocked) : (m_bLargeIconsAreEnbaled ? m_sizeCurButton : m_sizeButton);
		if (IsButtonExtraSizeAvailable())
		{
			size += CMFCVisualManager::GetInstance()->GetButtonExtraBorder();
		}
		return size;
	}

	CSize GetImageSize() const
	{
		return m_bLocked ? m_bLargeIconsAreEnbaled ? m_sizeCurImageLocked : m_sizeImageLocked : m_bLargeIconsAreEnbaled ? m_sizeCurImage : m_sizeImage;
	}

	CSize GetLockedImageSize() const
	{
		if (!m_bLocked)
		{
			ASSERT(FALSE);
			return CSize(0, 0);
		}
		return m_sizeImageLocked;
	}

	BOOL IsButtonHighlighted(int iButton) const;

	//------------
	// Attributes:
	//------------
public: 
	BOOL IsLocked() const { return m_bLocked; }
	UINT GetResourceID() const { return m_uiOriginalResID; }
	virtual BOOL IsResourceChanged() const { return m_bResourceWasChanged; }
	virtual BOOL IsFloating() const { return m_bFloating; }

	static const CObList& __stdcall GetAllToolbars();

	// standard control bar things
	int CommandToIndex(UINT nIDFind, int iIndexFirst = 0) const;
	UINT GetItemID(int nIndex) const;
	
	virtual void GetItemRect(int nIndex, LPRECT lpRect) const;
	virtual void GetInvalidateItemRect(int nIndex, LPRECT lpRect) const;

	UINT GetButtonStyle(int nIndex) const;
	virtual void SetButtonStyle(int nIndex, UINT nStyle);

	int GetCount() const;
	int ButtonToIndex(const CMFCToolBarButton* pButton) const;
	CMFCToolBarButton* GetButton(int iIndex) const;

	const CObList& GetAllButtons() const { return m_Buttons; }
	const CObList& GetOrigButtons() const { return m_OrigButtons; }
	const CObList& GetOrigResetButtons() const { return m_OrigResetButtons; }

	void SetOrigButtons(const CObList& lstOrigButtons);

	// Find all buttons specified by the given command ID from the all toolbars:
	static int __stdcall GetCommandButtons(UINT uiCmd, CObList& listButtons);
	
	static BOOL __stdcall SetCustomizeMode(BOOL bSet = TRUE);
	static BOOL __stdcall IsCustomizeMode() { return m_bCustomizeMode; }

	static BOOL __stdcall IsAltCustomizeMode() { return m_bAltCustomizeMode; }

	BOOL IsUserDefined() const;

	static CMFCToolBar* __stdcall FromHandlePermanent(HWND hwnd);

	static CMFCToolBarImages* __stdcall GetImages() { return &m_Images; }
	static CMFCToolBarImages* __stdcall GetColdImages() { return &m_ColdImages; }
	static CMFCToolBarImages* __stdcall GetDisabledImages() { return &m_DisabledImages; }
	static CMFCToolBarImages* __stdcall GetLargeImages() { return &m_LargeImages; }
	static CMFCToolBarImages* __stdcall GetLargeColdImages() { return &m_LargeColdImages; }
	static CMFCToolBarImages* __stdcall GetLargeDisabledImages() { return &m_LargeDisabledImages; }
	static CMFCToolBarImages* __stdcall GetMenuImages() { return &m_MenuImages; }
	static CMFCToolBarImages* __stdcall GetDisabledMenuImages() { return &m_DisabledMenuImages; }
	static CMFCToolBarImages* __stdcall GetUserImages() { return m_pUserImages; }

	CMFCToolBarImages* GetLockedImages()
	{
		if (!m_bLocked)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return &m_ImagesLocked;
	}

	CMFCToolBarImages* GetLockedColdImages()
	{
		if (!m_bLocked)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return &m_ColdImagesLocked;
	}

	CMFCToolBarImages* GetLockedDisabledImages()
	{
		if (!m_bLocked)
		{
			ASSERT(FALSE);
			return NULL;
		}
		return &m_DisabledImagesLocked;
	}
	
	CMFCToolBarImages* GetLockedMenuImages()
	{
		if (!m_bLocked)
		{
			ASSERT(FALSE);
			return NULL;
		}

		if (m_MenuImagesLocked.GetCount() > 0)
		{
			return &m_MenuImagesLocked;
		}

		if (m_ImagesLocked.GetCount() > 0)
		{
			return &m_ImagesLocked;
		}

		return NULL;
	}

	static int __stdcall GetDefaultImage(UINT uiID)
	{
		int iImage;
		if (m_DefaultImages.Lookup(uiID, iImage))
		{
			return iImage;
		}
		return -1;
	}

	int GetImagesOffset() const { return m_iImagesOffset; }

	CMFCToolBarButton* GetHighlightedButton() const;

	static void __stdcall SetHotTextColor(COLORREF clrText);
	static COLORREF __stdcall GetHotTextColor();

	void SetHotBorder(BOOL bShowHotBorder) { m_bShowHotBorder = bShowHotBorder; }
	BOOL GetHotBorder() const { return m_bShowHotBorder; }

	void SetGrayDisabledButtons(BOOL bGrayDisabledButtons) { m_bGrayDisabledButtons = bGrayDisabledButtons; }
	BOOL GetGrayDisabledButtons() const { return m_bGrayDisabledButtons; }

	//------------------------------------------------------
	// Enable/disable quick customization mode ("Alt+drag"):
	//------------------------------------------------------
	static void __stdcall EnableQuickCustomization(BOOL bEnable = TRUE) { m_bAltCustomization = bEnable; }

	virtual void EnableDocking(DWORD dwAlignment); 
	
	void EnableCustomizeButton(BOOL bEnable, int iCustomizeCmd, const CString& strCustomizeText, BOOL bQuickCustomize = TRUE);
	void EnableCustomizeButton(BOOL bEnable, int iCustomizeCmd, UINT uiCustomizeTextResId, BOOL bQuickCustomize = TRUE);

	BOOL IsExistCustomizeButton()
	{
		if(m_pCustomizeBtn == NULL)
		{
			return FALSE;
		}
		return TRUE;
	}

	CMFCCustomizeButton* GetCustomizeButton() { return m_pCustomizeBtn; }

	void EnableTextLabels(BOOL bEnable = TRUE);
	virtual BOOL AllowChangeTextLabels() const { return TRUE; }
	BOOL AreTextLabels() const { return m_bTextLabels; }

	virtual BOOL OnBeforeRemoveButton(CMFCToolBarButton* /*pButton*/, DROPEFFECT /*dropEffect*/) { return TRUE; }

	void SetMaskMode(BOOL bMasked) { m_bMasked = bMasked; }
	void SetPermament(BOOL bPermament = TRUE) { m_bPermament = bPermament; }

	BOOL GetIgnoreSetText() const { return m_bIgnoreSetText; }
	void SetIgnoreSetText(BOOL bValue) { m_bIgnoreSetText = bValue; }

	BOOL GetRouteCommandsViaFrame() { return m_bRouteCommandsViaFrame; }
	void SetRouteCommandsViaFrame(BOOL bValue) { m_bRouteCommandsViaFrame = bValue; }

	BOOL IsAddRemoveQuickCustomize() { return m_bQuickCustomize; }

	BOOL IsSibling() { return m_bHasBrother; }
	CMFCToolBar* GetSiblingToolBar() { return m_pBrotherToolBar; }

	void SetSiblingToolBar(CMFCToolBar* pBrotherToolbar);
	BOOL IsOneRowWithSibling();
	void SetOneRowWithSibling();
	void SetTwoRowsWithSibling();
	BOOL CanHandleSiblings();

	void EnableReflections(BOOL bEnable = TRUE) { m_bAllowReflections = bEnable; }

	static BOOL __stdcall GetShowTooltips() { return m_bShowTooltips; }
	static void __stdcall SetShowTooltips(BOOL bValue) { m_bShowTooltips = bValue; }

	HWND GetHwndLastFocus() const { return m_hwndLastFocus; }

	AFX_IMPORT_DATA static BOOL m_bDisableLabelsEdit;

public:
	// for changing button info
	void GetButtonInfo(int nIndex, UINT& nID, UINT& nStyle, int& iImage) const;
	void SetButtonInfo(int nIndex, UINT nID, UINT nStyle, int iImage);

	BOOL SetButtonText(int nIndex, LPCTSTR lpszText);
	CString GetButtonText( int nIndex ) const;
	void GetButtonText( int nIndex, CString& rString ) const;

	// Save/load toolbar state + buttons:
	void Serialize(CArchive& ar);
	virtual BOOL LoadState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL SaveState(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	virtual BOOL RemoveStateFromRegistry(LPCTSTR lpszProfileName = NULL, int nIndex = -1, UINT uiID = (UINT) -1);
	static BOOL __stdcall LoadParameters(LPCTSTR lpszProfileName = NULL);
	static BOOL __stdcall SaveParameters(LPCTSTR lpszProfileName = NULL);
	static BOOL __stdcall LoadLargeIconsState(LPCTSTR lpszProfileName = NULL);

	virtual BOOL CanBeRestored() const;
	virtual BOOL CanBeClosed() const { return !m_bPermament; }

	virtual BOOL RestoreOriginalstate();
	virtual void OnReset() {}

	static void __stdcall ResetAll();
	static void __stdcall RedrawUnderlines();

	virtual void AdjustLayout();
	virtual int HitTest(CPoint point);
	virtual BOOL TranslateChar(UINT nChar);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	virtual BOOL PrevMenu();
	virtual BOOL NextMenu();
	BOOL ProcessCommand(CMFCToolBarButton* pButton);
	CMFCToolBarMenuButton* GetDroppedDownMenu(int* pIndex = NULL) const;

	BOOL SetHot(CMFCToolBarButton *pMenuButton);

	virtual BOOL OnSetDefaultButtonText(CMFCToolBarButton* pButton);

	BOOL IsDragButton(const CMFCToolBarButton* pButton) const { return pButton == m_pDragButton; }

	virtual void  OnFillBackground(CDC* /*pDC*/) {}
	virtual void OnGlobalFontsChanged();

	AFX_IMPORT_DATA static BOOL   m_bExtCharTranslation;
	AFX_IMPORT_DATA static double m_dblLargeImageRatio;  // large image stretch ratio (default: * 2)
	/// <summary> Specifies whether to scale or not toolbar images in high DPI mode.</summary>
	AFX_IMPORT_DATA static BOOL   m_bDontScaleImages;    // don't scale shared images in high DPI mode

	static void __stdcall CMFCToolBar::CleanUpImages();
	void CleanUpLockedImages();

	void AdjustSize();

	virtual BOOL OnUserToolTip(CMFCToolBarButton* pButton, CString& strTTText) const;
	virtual BOOL OnSetAccData(long lVal);

// Implementation
public:
	virtual ~CMFCToolBar();

	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);

	virtual CSize CalcSize(BOOL bVertDock);
	int WrapToolBar(int nWidth, int nHeight = 32767, CDC* pDC = NULL, int nColumnWidth = -1, int nRowHeight = -1);

	virtual void OnChangeHot(int iHot);

	virtual CSize StretchPane(int nLength, BOOL bVert);

	CMFCToolBarButton* InvalidateButton(int nIndex);
	void UpdateButton(int nIndex);

	virtual void OnChangeVisualManager();

protected:
	virtual CSize CalcLayout(DWORD dwMode, int nLength = -1);
	void  SizeToolBar(int nLength, BOOL bVert = FALSE);

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	virtual int InsertButton(CMFCToolBarButton* pButton, int iInsertAt = -1);

	virtual BOOL DrawButton(CDC* pDC, CMFCToolBarButton* pButton, CMFCToolBarImages* pImages, BOOL bHighlighted, BOOL bDrawDisabledImages);
	virtual void DrawDragCursor(CDC* pDC);
	CMFCToolBarImages* GetImageList(CMFCToolBarImages& images, CMFCToolBarImages& imagesLocked, CMFCToolBarImages& largeImages, CMFCToolBarImages& largeImagesLocked) const;

	void RebuildAccelerationKeys();
	virtual CWnd* GetCommandTarget() const
	{
		// determine target of command update
		CFrameWnd* pTarget = (CFrameWnd*) GetOwner();
		if (pTarget == NULL || (m_bRouteCommandsViaFrame && !pTarget->IsFrameWnd()))
		{
			pTarget = AFXGetParentFrame(this);
		}

		return pTarget;
	}

	void UpdateTooltips();

	virtual void OnAfterFloat();
	virtual void OnAfterDock(CBasePane* /*pBar*/, LPCRECT /*lpRect*/, AFX_DOCK_METHOD /*dockMethod*/);
	virtual void OnBeforeChangeParent(CWnd* pWndNewParent, BOOL bDelay = FALSE);

	virtual void AccNotifyObjectFocusEvent(int iButton);

protected:
	friend class CWinAppEx;

	AFX_IMPORT_DATA static CMFCToolBar* m_pSelToolbar;        // "Selected" toolbar in the customization mode

	AFX_IMPORT_DATA static CMFCToolBarImages m_Images;              // Shared toolbar images
	AFX_IMPORT_DATA static CMFCToolBarImages m_ColdImages;          // Shared toolbar "cold" images
	AFX_IMPORT_DATA static CMFCToolBarImages m_DisabledImages;      // Shared disabled images

	AFX_IMPORT_DATA static CMFCToolBarImages m_LargeImages;         // Shared toolbar large "hot" images
	AFX_IMPORT_DATA static CMFCToolBarImages m_LargeColdImages;     // Shared toolbar large "cold" images
	AFX_IMPORT_DATA static CMFCToolBarImages m_LargeDisabledImages; // Shared disabled large images

	AFX_IMPORT_DATA static CMFCToolBarImages m_MenuImages;
	AFX_IMPORT_DATA static CMFCToolBarImages m_DisabledMenuImages;

	AFX_IMPORT_DATA static BOOL m_bAutoGrayInactiveImages;
	AFX_IMPORT_DATA static int m_nGrayImagePercentage;

	AFX_IMPORT_DATA static CMFCToolBarImages* m_pUserImages;        // Shared user-defined images

	CMFCToolBarImages m_ImagesLocked;              // "Locked" toolbar images
	CMFCToolBarImages m_ColdImagesLocked;          // "Locked" toolbar "cold" images
	CMFCToolBarImages m_DisabledImagesLocked;      // "Locked" toolbar disabled images
	CMFCToolBarImages m_LargeImagesLocked;         // "Locked" toolbar large images
	CMFCToolBarImages m_LargeColdImagesLocked;     // "Locked" toolbar large "cold" images
	CMFCToolBarImages m_LargeDisabledImagesLocked; // "Locked" toolbar large disabled images
	CMFCToolBarImages m_MenuImagesLocked;          // "Locked" toolbar menu images
	CMFCToolBarImages m_DisabledMenuImagesLocked;  // "Locked" toolbar menu disabled images

	BOOL m_bLocked;
	BOOL m_bLargeIconsAreEnbaled;
	BOOL m_bMasked;
	BOOL m_bPermament;          // Can't be closed
	BOOL m_bTextLabels;         // Text labels below the image are available
	BOOL m_bDrawTextLabels;
	BOOL m_bResourceWasChanged; // Resource was changed since last session
	BOOL m_bLeaveFocus;         // Don't remove selection in the focused bars.
	BOOL m_bFloating;
	BOOL m_bNoDropTarget;
	BOOL m_bIsDragCopy;
	BOOL m_bStretchButton;
	BOOL m_bTracked;
	BOOL m_bMenuMode;
	BOOL m_bDisableControlsIfNoHandler;
	BOOL m_bRouteCommandsViaFrame;
	BOOL m_bDisableCustomize;
	BOOL m_bShowHotBorder;
	BOOL m_bGrayDisabledButtons;
	BOOL m_bIgnoreSetText;
	BOOL m_bQuickCustomize;
	BOOL m_bHasBrother;
	BOOL m_bElderBrother;
	BOOL m_bAllowReflections;
	BOOL m_bRoundShape;
	BOOL m_bInUpdateShadow;

	CMFCControlBarImpl m_Impl;

	int m_nMaxBtnHeight;  // Actual only if m_bTextLabels is TRUE
	int m_iButtonCapture; // index of button with capture (-1 => none)
	int m_iHighlighted;   // highlighted button index
	int m_iSelected;      // selected button index
	int m_iHot;
	int m_nTooltipsCount;
	int m_iDragIndex;
	int m_iImagesOffset;
	int m_nMaxLen;
	int m_iAccHotItem;

	AFX_IMPORT_DATA static CMap<UINT, UINT, int, int> m_DefaultImages;

	AFX_IMPORT_DATA static CSize m_sizeButton;      // original size of button
	AFX_IMPORT_DATA static CSize m_sizeImage;       // original size of glyph
	AFX_IMPORT_DATA static CSize m_sizeMenuButton;  // size of button on the menu
	AFX_IMPORT_DATA static CSize m_sizeMenuImage;   // size of image on the menu
	AFX_IMPORT_DATA static CSize m_sizeCurButton;   // size of button
	AFX_IMPORT_DATA static CSize m_sizeCurImage;    // size of glyph

	CSize m_sizeButtonLocked;    // original size of button of the locked toolbars
	CSize m_sizeImageLocked;     // original size of glyph of the locked toolbars
	CSize m_sizeCurButtonLocked; // size of button
	CSize m_sizeCurImageLocked;  // size of glyph

	BOOL m_bDontScaleLocked;     // don't scale locked images in high DPI mode
	CSize m_sizeLast;

	CObList m_Buttons;
	CObList m_OrigButtons;      // Original (not customized) items
	CObList m_OrigResetButtons; // Original (not customized) items after reset

	CMFCToolBarDropTarget	m_DropTarget;
	AFX_IMPORT_DATA static CMFCToolBarDropSource m_DropSource;

	CRect  m_rectDrag;
	CRect  m_rectTrack;
	CPen   m_penDrag;
	CPoint m_ptStartDrag;
	CPoint m_ptLastMouse;
	CWnd*  m_pWndLastCapture;

	CToolTipCtrl*     m_pToolTip;
	CMFCToolBarButton*   m_pDragButton;
	CMFCToolBar*   m_pBrotherToolBar;
	CMFCCustomizeButton* m_pCustomizeBtn;

	UINT m_uiOriginalResID; // Toolbar resource ID
	HWND m_hwndLastFocus;

	AFX_IMPORT_DATA static COLORREF m_clrTextHot;
	
	AFX_IMPORT_DATA static HHOOK m_hookMouseHelp; // Mouse hook for the help mode
	AFX_IMPORT_DATA static CMFCToolBar* m_pLastHookedToolbar;

	CMap<UINT, UINT&, CMFCToolBarButton*, CMFCToolBarButton*&> m_AccelKeys; // Keyboard acceleration keys

	AFX_IMPORT_DATA static BOOL m_bCustomizeMode;
	AFX_IMPORT_DATA static BOOL m_bAltCustomizeMode;
	AFX_IMPORT_DATA static BOOL m_bShowTooltips;
	AFX_IMPORT_DATA static BOOL m_bShowShortcutKeys;
	AFX_IMPORT_DATA static BOOL m_bLargeIcons;
	AFX_IMPORT_DATA static BOOL m_bAltCustomization;

	AFX_IMPORT_DATA static CList<UINT, UINT> m_lstUnpermittedCommands;
	AFX_IMPORT_DATA static CList<UINT, UINT> m_lstBasicCommands;

	AFX_IMPORT_DATA static CMFCCmdUsageCount m_UsageCount;

	virtual BOOL OnDrop(COleDataObject* pDataObject, DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave();
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);

	virtual void DoPaint(CDC* pDC);
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	virtual BOOL NotifyControlCommand(CMFCToolBarButton* pButton, BOOL bAccelerator, int nNotifyCode, WPARAM wParam, LPARAM lParam);

	virtual int FindDropIndex(const CPoint point, CRect& rectDrag) const;
	virtual void AdjustLocations();

	virtual BOOL OnSendCommand(const CMFCToolBarButton* /*pButton*/) { return FALSE; }

	virtual BOOL AllowSelectDisabled() const { return FALSE; }
	virtual BOOL AllowShowOnList() const { return TRUE; }
	virtual BOOL AlwaysSaveSelection() const { return FALSE; }

	virtual void DrawSeparator(CDC* pDC, const CRect& rect, BOOL bHorz);
	virtual CMFCToolBarButton* CreateDroppedButton(COleDataObject* pDataObject);
	virtual BOOL OnKey(UINT /*nChar*/) { return FALSE; }
	virtual void OnCustomizeMode(BOOL bSet);

	virtual BOOL EnableContextMenuItems(CMFCToolBarButton* pButton, CMenu* pPopup);
	virtual BOOL IsPureMenuButton(CMFCToolBarButton* /*pButton*/) const { return m_bMenuMode; }

	virtual void OnCalcSeparatorRect(CMFCToolBarButton* pButton, CRect& rectSeparator, BOOL bHorz);

	virtual void AddRemoveSeparator(const CMFCToolBarButton* pButton, const CPoint& ptStart, const CPoint& ptDrop);
	virtual void ShowCommandMessageString(UINT uiCmdId);

	static LRESULT CALLBACK ToolBarMouseHookProc(int nCode, WPARAM wParam, LPARAM lParam);

	BOOL DropDownMenu(CMFCToolBarButton* pButton);

	virtual int CalcMaxButtonHeight();

	virtual BOOL AllowAltCustomization() const { return TRUE; }
	virtual void OnAfterButtonDelete();

	void SetRoundedRgn();
	void RedrawCustomizeButton();

	void UpdateImagesColor();

	// SmartUpdate methods:
	virtual void SaveOriginalState(CSettingsStore& reg);
	virtual BOOL LoadLastOriginalState(CSettingsStore& reg);
	virtual BOOL SmartUpdate(const CObList& lstPrevButtons);

	void SaveResetOriginalState(CSettingsStore& reg);
	BOOL LoadResetOriginalState(CSettingsStore& reg);

	BOOL RemoveResetStateButton(UINT uiCmdId);
	int  InsertResetStateButton(const CMFCToolBarButton& button, int iInsertAt);

	//{{AFX_MSG(CMFCToolBar)
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnCancelMode();
	afx_msg void OnSysColorChange();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnToolbarAppearance();
	afx_msg void OnToolbarDelete();
	afx_msg void OnToolbarImage();
	afx_msg void OnToolbarImageAndText();
	afx_msg void OnToolbarStartGroup();
	afx_msg void OnToolbarText();
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnToolbarReset();
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnNcPaint();
	afx_msg void OnCopyImage();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnToolbarNewMenu();
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnContextMenu(CWnd*, CPoint point);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	afx_msg LRESULT OnHelpHitTest(WPARAM,LPARAM);
	afx_msg LRESULT OnGetButtonCount(WPARAM,LPARAM);
	afx_msg LRESULT OnGetItemRect(WPARAM,LPARAM);
	afx_msg LRESULT OnGetButton(WPARAM,LPARAM);
	afx_msg LRESULT OnGetButtonText(WPARAM,LPARAM);
	afx_msg BOOL OnNeedTipText(UINT id, NMHDR* pNMH, LRESULT* pResult);
	afx_msg LRESULT OnPromptReset(WPARAM, LPARAM);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg LRESULT OnUpdateToolTips(WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()
	//}}AFX_MSG
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtaskdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#if !defined(_UNICODE) // Unicode required
#error CTaskDialog requires _UNICODE to be defined.
#endif

#if (NTDDI_VERSION < NTDDI_VISTA) // min Windows Vista required
#error CTaskDialog is not supported on Windows versions prior to Vista.
#endif

#include <commctrl.h>
#include <afxtempl.h>

class CTaskDialog : public CObject
{
	DECLARE_DYNAMIC(CTaskDialog);

public:
	enum
	{
		PROGRESS_BAR_MIN = 0,
		PROGRESS_BAR_MAX = 100
	};

	CTaskDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle,
		_In_ int nCommonButtons = TDCBF_OK_BUTTON | TDCBF_CANCEL_BUTTON, _In_ int nTaskDialogOptions = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS,
		_In_ const CString& strFooter = CString());

	CTaskDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle,
		_In_ int nIDCommandControlsFirst, _In_ int nIDCommandControlsLast, _In_ int nCommonButtons,
		_In_ int nTaskDialogOptions = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS, _In_ const CString& strFooter = CString());

	virtual ~CTaskDialog();

	void LoadCommandControls(_In_ int nIDCommandControlsFirst, _In_ int nIDCommandControlsLast);
	void LoadRadioButtons(_In_ int nIDRadioButtonsFirst, _In_ int nIDRadioButtonsLast);

	void SetWindowTitle(_In_ const CString& strWindowTitle);
	void SetMainInstruction(_In_ const CString& strInstructions);
	void SetContent(_In_ const CString& strContent);
	void SetFooterText(_In_ const CString& strFooterText);
	void SetExpansionArea(_In_ const CString& strExpandedInformation, _In_ const CString& strCollapsedLabel = CString(), _In_ const CString& strExpandedLabel = CString());

	void SetMainIcon(_In_ HICON hMainIcon);
	void SetFooterIcon(_In_ HICON hFooterIcon);

	void SetMainIcon(_In_ LPCWSTR lpszMainIcon);
	void SetFooterIcon(_In_ LPCWSTR lpszFooterIcon);

	void SetDialogWidth(_In_ int nWidth = 0);

	void SetOptions(_In_ int nOptionFlag);
	int GetOptions() const;

	void SetCommonButtons(_In_ int nButtonMask, _In_ int nDisabledButtonMask = 0, _In_ int nElevationButtonMask = 0);
	void SetCommonButtonOptions(_In_ int nDisabledButtonMask, _In_ int nElevationButtonMask = 0);

	void AddCommandControl(_In_ int nCommandControlID, _In_ const CString& strCaption, _In_ BOOL bEnabled = TRUE, _In_ BOOL bRequiresElevation = FALSE);
	void SetCommandControlOptions(_In_ int nCommandControlID, _In_ BOOL bEnabled, _In_ BOOL bRequiresElevation = FALSE);
	int GetSelectedCommandControlID() const;
	BOOL IsCommandControlEnabled(_In_ int nCommandControlID) const;
	void SetDefaultCommandControl(_In_ int nCommandControlID);
	void RemoveAllCommandControls();

	void AddRadioButton(_In_ int nRadioButtonID, _In_ const CString& strCaption, _In_ BOOL bEnabled = TRUE);
	void SetRadioButtonOptions(_In_ int nRadioButtonID, _In_ BOOL bEnabled);
	int GetSelectedRadioButtonID() const;
	BOOL IsRadioButtonEnabled(_In_ int nRadioButtonID) const;
	void SetDefaultRadioButton(_In_ int nRadioButtonID);
	void RemoveAllRadioButtons();

	void SetVerificationCheckboxText(_In_ const CString& strVerificationText);
	void SetVerificationCheckbox(_In_ BOOL bChecked);
	BOOL GetVerificationCheckboxState() const;

	void SetProgressBarRange(_In_ int nRangeMin, _In_ int nRangeMax);
	void SetProgressBarPosition(_In_ int nProgressPos);
	void SetProgressBarState(_In_ int nState = PBST_NORMAL);
	void SetProgressBarMarquee(_In_ BOOL bEnabled = TRUE, _In_ int nMarqueeSpeed = 0);

	INT_PTR DoModal(_In_ HWND hParent = ::GetActiveWindow());

	static BOOL IsSupported();
	static INT_PTR ShowDialog(_In_ const CString& strContent, _In_ const CString& strMainInstruction, _In_ const CString& strTitle, _In_ int nIDCommandControlsFirst, _In_ int nIDCommandControlsLast,
		_In_ int nCommonButtons = TDCBF_YES_BUTTON | TDCBF_NO_BUTTON, _In_ int nTaskDialogOptions = TDF_ENABLE_HYPERLINKS | TDF_USE_COMMAND_LINKS, _In_ const CString& strFooter = CString());

	friend HRESULT CALLBACK TaskDialogCallback(_In_ HWND hwnd, _In_ UINT uNotification, _In_ WPARAM wParam, _In_ LPARAM lParam, _In_ LONG_PTR dwRefData);

protected:
	void ClickRadioButton(_In_ int nRadioButtonID) const;
	void ClickCommandControl(_In_ int nCommandControlID) const;
	void NavigateTo(_In_ CTaskDialog& oTaskDialog) const;

	virtual HRESULT OnCreate();
	virtual HRESULT OnInit();
	virtual HRESULT OnDestroy();
	virtual HRESULT OnCommandControlClick(_In_ int nCommandControlID);
	virtual HRESULT OnRadioButtonClick(_In_ int nRadioButtonID);
	virtual HRESULT OnVerificationCheckboxClick(_In_ BOOL bChecked);
	virtual HRESULT OnExpandButtonClick(_In_ BOOL bExpanded);
	virtual HRESULT OnHyperlinkClick(_In_ const CString& strHref);
	virtual HRESULT OnHelp();
	virtual HRESULT OnTimer(_In_ long lTime);
	virtual HRESULT OnNavigatePage();

	virtual int GetCommonButtonId(_In_ int nFlag) const;
	virtual int GetCommonButtonFlag(_In_ int nButtonId) const;
	virtual int GetCommonButtonCount() const;

private:
	CTaskDialog& operator=(const CTaskDialog&);

	enum
	{
			BUTTON_ENABLED = 0x01,
			BUTTON_ELEVATION = 0x02
	};

	typedef struct _CTaskDialogButton
	{
		int nId;
		CString strCaption;
		unsigned char cState;

		_CTaskDialogButton(_In_ int nIdp = 0, _In_ const CString& strCaptionParam = CString(), _In_ unsigned char cStateParam = 0)
			: nId ( nIdp )
			, strCaption ( strCaptionParam )
			, cState ( cStateParam )
		{}

	} CTaskDialogButton;

	typedef union
	{
		HICON hIcon;
		PCWSTR pszIcon;
	} CTaskDialogIcon;

	typedef CArray<CTaskDialogButton> CTaskDialogButtonArray;
	typedef HRESULT (WINAPI *CTaskDialogIndirectFunc)(const TASKDIALOGCONFIG *pTaskConfig, int *pnButton, int *pnRadioButton, BOOL *pfVerificationFlagChecked);

	TASKDIALOG_BUTTON* GetButtonData(_In_ const CTaskDialogButtonArray& oButtonArr) const;
	INT_PTR GetButtonIndex(_In_ int nId, _In_ const CTaskDialogButtonArray& oButtonArr) const;
	void Notify(_In_ UINT uMsg, _In_ WPARAM wParam, _In_ LPARAM lParam) const;
	void FillStruct(_Inout_ TASKDIALOGCONFIG &configTaskDialog);
	void FreeStruct(_Inout_ TASKDIALOGCONFIG &configTaskDialog);

	HWND m_hWnd;

	int m_nCommonButton;
	int m_nButtonDisabled;
	int m_nButtonElevation;

	int m_nFlags;
	int m_nWidth;
	int m_nDefaultCommandControl;
	int m_nDefaultRadioButton;

	CTaskDialogIcon m_mainIcon;
	CTaskDialogIcon m_footerIcon;

	CTaskDialogButtonArray m_aButtons;
	CTaskDialogButtonArray m_aRadioButtons;

	CString m_strContent;
	CString m_strMainInstruction;
	CString m_strTitle;
	CString m_strFooter;
	CString m_strVerification;
	CString m_strInformation;
	CString m_strExpand;
	CString m_strCollapse;

	int m_nProgressRangeMin;
	int m_nProgressRangeMax;
	int m_nProgressState; //ProgressBar or Marquee state
	int m_nProgressPos;   //ProgressBar pos or Marquee speed

	BOOL m_bVerified;
	int m_nRadioId;
	int m_nButtonId;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarbuttonslistbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarButton;
class CMFCToolBarImages;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonsListButton window

class CMFCToolBarButtonsListButton : public CButton
{
// Construction
public:
	CMFCToolBarButtonsListButton();

// Operations
public:
	void SetImages(CMFCToolBarImages* pImages);
	void AddButton(CMFCToolBarButton* pButton);
	void RemoveButtons();

	CMFCToolBarButton* GetSelectedButton() const
	{
		return m_pSelButton;
	}

	BOOL SelectButton(int iImage);
	void EnableDragFromList(BOOL bEnable = TRUE)
	{
		m_bEnableDragFromList = bEnable;
	}

protected:
	CMFCToolBarButton* HitTest(POINT point) const;
	void SelectButton(CMFCToolBarButton* pButton);
	void RebuildLocations();
	void RedrawSelection();

// Attributes
protected:
	CObList         m_Buttons;    // CMFCToolBarButton list
	CMFCToolBarImages* m_pImages;
	CSize           m_sizeButton;
	CScrollBar      m_wndScrollBar;
	CMFCToolBarButton* m_pSelButton;
	int             m_iScrollOffset;
	int             m_iScrollTotal;
	int             m_iScrollPage;
	BOOL            m_bInited;
	BOOL            m_bEnableDragFromList;

// Overrides
public:
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDIS);

// Implementation
public:
	virtual ~CMFCToolBarButtonsListButton();

protected:
	//{{AFX_MSG(CMFCToolBarButtonsListButton)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnSysColorChange();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg UINT OnGetDlgCode();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarbuttoncustomizedialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarbuttonslistbutton.h"
#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarImages;
class CUserTool;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarButtonCustomizeDialog dialog

class CMFCToolBarButtonCustomizeDialog : public CDialog
{
// Construction
public:
	CMFCToolBarButtonCustomizeDialog(CMFCToolBarButton* pButton, CMFCToolBarImages* pImages, CWnd* pParent = NULL, int iStartImage = 0, BOOL bMenuMode = FALSE); // standard constructor
	virtual ~CMFCToolBarButtonCustomizeDialog();

// Dialog Data
	//{{AFX_DATA(CMFCToolBarButtonCustomizeDialog)
	enum { IDD = IDD_AFXBARRES_BUTTON_PROPS };
	CButton      m_wndDefautImageBtn;
	CButton      m_wndUserImageBtn;
	CStatic      m_wndDefaultImageArea;
	CEdit        m_wndButtonText;
	CButton      m_wndAddImage;
	CMFCToolBarButtonsListButton m_wndButtonList;
	CButton      m_wndEditImage;
	CString      m_strButtonText;
	CString      m_strButtonDescr;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarButtonCustomizeDialog)
	afx_msg void OnAddImage();
	afx_msg void OnEditImage();
	afx_msg void OnImageList();
	afx_msg void OnImage();
	afx_msg void OnImageText();
	afx_msg void OnText();
	afx_msg void OnUserImage();
	afx_msg void OnDefaultImage();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnOK();
	virtual BOOL OnInitDialog();

// Operations:
protected:
	void RebuildImageList();
	void EnableControls();

// Attributes:
protected:
	CMFCToolBarButton* m_pButton;
	CMFCToolBarImages* m_pImages;

	int m_iStartImage;
	int m_iSelImage;

	BOOL m_bImage;
	BOOL m_bText;
	BOOL m_bMenuMode;
	BOOL m_bUserButton;

	CObList    m_Buttons;
	CRect      m_rectDefaultImage;
	CString    m_strAccel;
	CUserTool* m_pUserTool;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXOLE_H__
	#include <afxole.h>
#endif

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_TBBS_BREAK 0x20000000

class CAccessibilityData;
class CMFCToolBar;
class CMFCToolBarImages;
class CMFCToolBarMenuButton;

class CMFCToolBarButton : public CObject
{
	friend class CMFCToolBarButtonsListButton;
	DECLARE_SERIAL(CMFCToolBarButton)

public:
	CMFCToolBarButton();
	CMFCToolBarButton(UINT uiID, int iImage, LPCTSTR lpszText = NULL, BOOL bUserButton = FALSE, BOOL bLocked = FALSE);
	virtual ~CMFCToolBarButton();

// Operations:
public:
	//--------------------
	// Drag and drop stuff:
	//--------------------
	static CLIPFORMAT __stdcall GetClipboardFormat();
	static CMFCToolBarButton* __stdcall CreateFromOleData(COleDataObject* pDataObject);
	virtual BOOL PrepareDrag(COleDataSource& srcItem);

	//-----------------------------------------------------
	// Optional: if you want, that user may drag buttons 
	// between different applications, set your own format:
	//-----------------------------------------------------
	static void __stdcall SetClipboardFormatName(LPCTSTR lpszName);
	virtual BOOL CanBeDropped(CMFCToolBar* /*pToolbar*/) { return TRUE; }

	//-----------------------------------------------------------------
	//	Protected commands support. 
	//	Protected buttons will disabled in customization mode, so user 
	//	will be unable to drag/drop/change them.
	//-----------------------------------------------------------------
	static void __stdcall SetProtectedCommands(const CList<UINT, UINT>& lstCmds);
	static const CList<UINT, UINT>& __stdcall GetProtectedCommands() { return m_lstProtectedCommands; }

// Overrides:
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* /* pWnd */, BOOL /* bDelay = TRUE */) { return FALSE; }
	virtual BOOL OnClickUp() { return FALSE; }

	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual BOOL ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const;
	virtual void OnMove() {}
	virtual void OnSize(int /*iSize*/) {}
	virtual HWND GetHwnd() { return NULL; }
	virtual BOOL CanBeStretched() const { return FALSE; }
	virtual BOOL NotifyCommand(int /*iNotifyCode*/) { return FALSE; }
	virtual void OnAddToCustomizePage() {}
	virtual HBRUSH OnCtlColor(CDC* /*pDC*/, UINT /*nCtlColor*/) { return NULL; }
	virtual void OnDblClk(CWnd* /*pWnd*/) {}
	virtual BOOL CanBeStored() const { return TRUE; }
	virtual BOOL HaveHotBorder() const { return TRUE; }
	virtual void OnCancelMode() {}
	virtual void OnGlobalFontsChanged() {}
	virtual BOOL IsEditable() const { return !IsStandardCommand(m_nID) && (m_lstProtectedCommands.Find(m_nID) == NULL); }

	virtual BOOL OnContextHelp(CWnd* /* pWnd */) { return FALSE; }
	virtual BOOL OnCustomizeMenu(CMenu* /*pMenu*/) { return FALSE; }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);

	virtual BOOL IsDroppedDown() const { return FALSE; }
	virtual BOOL OnBeforeDrag() const { return TRUE; } // Drag is possible
	virtual BOOL OnBeforeDrop(CMFCToolBar* /*pTarget*/) { return TRUE; } // Drop is possible

	virtual BOOL OnToolHitTest(const CWnd* pWnd, TOOLINFO* pTI);
	virtual void SaveBarState() {}

	virtual void OnShow(BOOL /*bShow*/) {}

	virtual const CRect GetInvalidateRect() const { return m_rect; }
	virtual void SetStyle(UINT nStyle) { m_nStyle = nStyle; }

	virtual void ResetImageToDefault();
	virtual BOOL CompareWith(const CMFCToolBarButton& other) const;

	virtual void EnableWindow(BOOL bEnable = TRUE)
	{
		if (GetHwnd() != NULL)
		{
			::EnableWindow(GetHwnd(), bEnable);
		}
	}

	virtual BOOL IsWindowVisible()
	{
		CWnd* pWnd = GetHwnd() != NULL ? CWnd::FromHandle(GetHwnd()) : NULL;
		return (pWnd != NULL &&(pWnd->GetStyle() & WS_VISIBLE));
	}

	virtual BOOL IsOwnerOf(HWND hwnd)
	{
		return	GetHwnd() != NULL && (GetHwnd() == hwnd || ::IsChild(GetHwnd(), hwnd));
	}

	virtual BOOL HasFocus() const
	{
		HWND hwndBtn = ((CMFCToolBarButton*)this)->GetHwnd();
		return hwndBtn != NULL && (hwndBtn == ::GetFocus() || ::IsChild(hwndBtn, ::GetFocus()));
	}

	virtual BOOL OnGetCustomToolTipText(CString& /*strToolTip*/) { return FALSE; }

	virtual BOOL OnUpdateToolTip(CWnd* /*pWndParent*/, int /*iButtonIndex*/, CToolTipCtrl& /*wndToolTip*/, CString& /*str*/) { return FALSE; }

	virtual BOOL IsFirstInGroup() const;
	virtual BOOL IsLastInGroup() const;

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	void Initialize();
	void FillInterior(CDC* pDC, const CRect& rect, BOOL bHighlight, BOOL bMenuImage = FALSE);

// Attributes:
public:
	BOOL IsDrawText() const { return m_bText && !m_strText.IsEmpty(); }
	BOOL IsDrawImage() const { return m_bImage && GetImage() >= 0; }
	int GetImage() const { return m_bUserButton ? m_iUserImage : m_iImage; }

	virtual void SetImage(int iImage);
	virtual void SetRadio() {}

	BOOL IsLocked() const { return m_bLocked; }

	void SetRect(const CRect rect)
	{
		m_rect = rect;
		OnMove();
	}

	const CRect& Rect() const { return m_rect; }

	void Show(BOOL bShow)
	{
		if (m_bIsHidden != !bShow)
		{
			m_bIsHidden = !bShow;
			OnShow(bShow);
		}
	}

	BOOL IsHidden() const { return m_bIsHidden; }

	BOOL IsVisible() const { return m_bVisible; }
	void SetVisible(BOOL bShow = TRUE) { m_bVisible = bShow; }

	virtual BOOL IsExtraSize() const { return m_bExtraSize; }
	SIZE GetTextSize() const { return m_sizeText; } // Actual only if m_bTextBelow is TRUE
	BOOL IsHorizontal() const { return m_bHorz; }
	CWnd* GetParentWnd() const { return m_pWndParent; }

	BOOL    m_bUserButton;   // Is user-defined tool button?
	BOOL    m_bText;         // Draw text label
	BOOL    m_bImage;        // Draw image
	BOOL    m_bWrap;         // Wrap toolbar
	BOOL    m_bWholeText;    // Is whole text printed?
	BOOL    m_bTextBelow;    // Is text below image?
	BOOL    m_bDragFromCollection; // Button is dragged from collection
	UINT    m_nID;           // Command ID that this button sends
	UINT    m_nStyle;        // TBBS_ styles
	DWORD   m_dwdItemData;   // User-defined data
	CString m_strText;       // Button text (for user-defined buttons only!)
	CString m_strTextCustom; // Text appear on the customization list

	// Run-time properties:
	AFX_IMPORT_DATA static CLIPFORMAT m_cFormat;
	AFX_IMPORT_DATA static CString    m_strClipboardFormatName;

	AFX_IMPORT_DATA static BOOL m_bWrapText; // Is toolbar text may be multi-lined?
	AFX_IMPORT_DATA static BOOL m_bUpdateImages;

protected:
	int m_iImage;        // index into bitmap of this button's picture
	int m_iUserImage;    // index into user's bitmap of this button's picture

	BOOL m_bLocked;      // Is buttons placed on the "locked" toolbar
	BOOL m_bIsHidden;    // Button rectangle is out of bar
	BOOL m_bDisableFill; // Disable interior fill
	BOOL m_bExtraSize;   // Is Visual Manager's extra size used?
	BOOL m_bHorz;        // Is located on the horizontal toolbar?
	BOOL m_bVisible;     // Is button  visible 

	CRect m_rect;        // Button location
	CSize m_sizeText;    // Actual only if m_bTextBelow is TRUE
	CWnd* m_pWndParent;  // Parent window

	AFX_IMPORT_DATA static CList<UINT, UINT> m_lstProtectedCommands; // Buttons are disabled in customization mode

// Diagnostics:
public:

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtls_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXTLS_H__
#define __AFXTLS_H__

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

// Classes declared in this file

class CSimpleList;
class CThreadSlotData;                  // for manipulationg thread local storage
class CThreadLocalObject;               // for storing thread local data
class CProcessLocalObject;              // for storing thread local data
class CNoTrackObject;

// template class CTypedSimpleList<>
// template class CThreadLocal<>
// template class CProcessLocal<>

/////////////////////////////////////////////////////////////////////////////
// CSimpleList (simple/small subset of CList)

class CSimpleList
{
public:
	CSimpleList(int nNextOffset = 0);
	void Construct(int nNextOffset);

// Operations
	BOOL IsEmpty() const;
	void AddHead(void* p);
	void RemoveAll();
	void* GetHead() const;
	void* GetNext(void* p) const;
	BOOL Remove(void* p);

// Implementation
	void* m_pHead;
	size_t m_nNextOffset;

	void** GetNextPtr(void* p) const;   // somewhat trusting...
};

AFX_INLINE CSimpleList::CSimpleList(int nNextOffset)
	{ m_pHead = NULL; m_nNextOffset = nNextOffset; }
AFX_INLINE void CSimpleList::Construct(int nNextOffset)
	{ ASSERT(m_pHead == NULL); m_nNextOffset = nNextOffset; }
AFX_INLINE BOOL CSimpleList::IsEmpty() const
	{ return m_pHead == NULL; }
AFX_INLINE void** CSimpleList::GetNextPtr(void* p) const
	{ ENSURE_ARG(p != NULL); return (void**)((BYTE*)p+m_nNextOffset); }
AFX_INLINE void CSimpleList::RemoveAll()
	{ m_pHead = NULL; }
AFX_INLINE void* CSimpleList::GetHead() const
	{ return m_pHead; }
AFX_INLINE void* CSimpleList::GetNext(void* prevElement) const
	{ return *GetNextPtr(prevElement); }

template<class TYPE>
class CTypedSimpleList : public CSimpleList
{
public:
	CTypedSimpleList(int nNextOffset = 0)
		: CSimpleList(nNextOffset) { }
	void AddHead(TYPE p)
		{ CSimpleList::AddHead(p); }
	TYPE GetHead()
		{ return (TYPE)CSimpleList::GetHead(); }
	TYPE GetNext(TYPE p)
		{ return (TYPE)CSimpleList::GetNext(p); }
	BOOL Remove(TYPE p)
		{ return CSimpleList::Remove((TYPE)p); }
	operator TYPE();		
};
template<class TYPE>
inline CTypedSimpleList<TYPE>::operator TYPE()
{ 
	return (TYPE)CSimpleList::GetHead(); 
}
/////////////////////////////////////////////////////////////////////////////
// CThreadSlotData - manages owned array of "slots" for thread local storage

struct CThreadData; // private to implementation
struct CSlotData;   // private to implementation

class CThreadSlotData
{
public:
	CThreadSlotData();

// Operations
	int AllocSlot();
	void FreeSlot(int nSlot);	
	void SetValue(int nSlot, void* pValue);
	// delete all values in process/thread
	void DeleteValues(HINSTANCE hInst, BOOL bAll = FALSE);
	// assign instance handle to just constructed slots
	void AssignInstance(HINSTANCE hInst);

// Implementation
	DWORD m_tlsIndex;   // used to access system thread-local storage

	int m_nAlloc;       // number of slots allocated (in UINTs)
	int m_nRover;       // (optimization) for quick finding of free slots
	int m_nMax;         // size of slot table below (in bits)
	CSlotData* m_pSlotData; // state of each slot (allocated or not)
	CTypedSimpleList<CThreadData*> m_list;  // list of CThreadData structures
	CRITICAL_SECTION m_sect;

	void* GetThreadValue(int nSlot); // special version for threads only!
	void* PASCAL operator new(size_t, void* p)
		{ return p; }
	void DeleteValues(CThreadData* pData, HINSTANCE hInst);
	~CThreadSlotData();
};

class AFX_NOVTABLE CNoTrackObject
{
public:
	void* PASCAL operator new(size_t nSize);
	void PASCAL operator delete(void*);

#if defined(_DEBUG) && !defined(_AFX_NO_DEBUG_CRT)
	void* PASCAL operator new(size_t nSize, LPCSTR, int);
	void PASCAL operator delete(void* pObject, LPCSTR, int);
#endif
    virtual ~CNoTrackObject() {};
};

class AFX_NOVTABLE CThreadLocalObject
{
public:
// Attributes
	CNoTrackObject* GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)());
	CNoTrackObject* GetDataNA();

// Implementation
	int m_nSlot;
	~CThreadLocalObject();
};

class AFX_NOVTABLE CProcessLocalObject
{
public:
// Attributes
	CNoTrackObject* GetData(CNoTrackObject* (AFXAPI* pfnCreateObject)());

// Implementation
	CNoTrackObject* volatile m_pObject;
	~CProcessLocalObject();
};

template<class TYPE>
class CThreadLocal : public CThreadLocalObject
{
// Attributes
public:
	AFX_INLINE TYPE* GetData()
	{
		TYPE* pData = (TYPE*)CThreadLocalObject::GetData(&CreateObject);
		ENSURE(pData != NULL);
		return pData;
	}
	AFX_INLINE TYPE* GetDataNA()
	{
		TYPE* pData = (TYPE*)CThreadLocalObject::GetDataNA();
		return pData;
	}
	AFX_INLINE operator TYPE*()
	{ 
		return GetData(); 
	}
	AFX_INLINE TYPE* operator->()
	{ 
		return GetData(); 
	}

// Implementation
public:
	static CNoTrackObject* AFXAPI CreateObject()
		{ return new TYPE; }
};

#define THREAD_LOCAL(class_name, ident_name) \
	AFX_COMDAT CThreadLocal<class_name> ident_name;
#define EXTERN_THREAD_LOCAL(class_name, ident_name) \
	extern CThreadLocal<class_name> ident_name;

template<class TYPE>
class CProcessLocal : public CProcessLocalObject
{
// Attributes
public:
	AFX_INLINE TYPE* GetData()
	{
		TYPE* pData = (TYPE*)CProcessLocalObject::GetData(&CreateObject);
		ENSURE(pData != NULL);
		return pData;
	}
	AFX_INLINE TYPE* GetDataNA()
		{ return (TYPE*)m_pObject; }
	AFX_INLINE operator TYPE*()
		{ return GetData(); }
	AFX_INLINE TYPE* operator->()
		{ return GetData(); }

// Implementation
public:
	static CNoTrackObject* AFXAPI CreateObject()
		{ return new TYPE; }
};

#define PROCESS_LOCAL(class_name, ident_name) \
	AFX_COMDAT CProcessLocal<class_name> ident_name;
#define EXTERN_PROCESS_LOCAL(class_name, ident_name) \
	extern CProcessLocal<class_name> ident_name;

/////////////////////////////////////////////////////////////////////////////

void AFXAPI AfxInitLocalData(HINSTANCE hInstInit);
void AFXAPI AfxTermLocalData(HINSTANCE hInstTerm, BOOL bAll = FALSE);
void AFXAPI AfxTlsAddRef();
void AFXAPI AfxTlsRelease();

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#undef AFX_DATA
#define AFX_DATA

#endif //__AFXTLS_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarcomboboxbutton.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButton;
class CMFCToolBarComboBoxEdit;

class CMFCToolBarComboBoxButton : public CMFCToolBarButton
{
	friend class CMFCToolBarComboBoxEdit;
	friend class CMFCRibbonComboBox;

	DECLARE_SERIAL(CMFCToolBarComboBoxButton)

public:
	CMFCToolBarComboBoxButton();
	CMFCToolBarComboBoxButton(UINT uiID, int iImage, DWORD dwStyle = CBS_DROPDOWNLIST, int iWidth = 0);
	virtual ~CMFCToolBarComboBoxButton();

// Operations:
	virtual INT_PTR AddItem(LPCTSTR lpszItem, DWORD_PTR dwData = 0);
	virtual INT_PTR AddSortedItem(LPCTSTR lpszItem, DWORD_PTR dwData = 0);

	INT_PTR GetCount() const;
	LPCTSTR GetItem(int iIndex = -1) const;
	DWORD_PTR GetItemData(int iIndex = -1) const;
	int GetCurSel() const { return m_iSelIndex; }
	void RemoveAllItems();
	BOOL SelectItem(int iIndex, BOOL bNotify = TRUE);
	BOOL SelectItem(DWORD_PTR dwData);
	BOOL SelectItem(LPCTSTR lpszText);

	BOOL DeleteItem(int iIndex);
	BOOL DeleteItem(DWORD_PTR dwData);
	BOOL DeleteItem(LPCTSTR lpszText);

	int FindItem(LPCTSTR lpszText) const;
	void SetDropDownHeight(int nHeight);

// Overrides:
	virtual CComboBox* CreateCombo(CWnd* pWndParent, const CRect& rect);
	virtual CMFCToolBarComboBoxEdit* CreateEdit(CWnd* pWndParent, const CRect& rect, DWORD dwEditStyle);

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void OnMove();
	virtual void OnSize(int iSize);
	virtual HWND GetHwnd() { return m_pWndCombo->GetSafeHwnd(); }
	virtual CEdit* GetEditCtrl() { return m_pWndEdit; }

	virtual void EnableWindow(BOOL bEnable = TRUE)
	{
		if (m_pWndCombo->GetSafeHwnd() != NULL)
		{
			m_pWndCombo->EnableWindow(bEnable);
		}

		if (m_pWndEdit->GetSafeHwnd() != NULL)
		{
			m_pWndEdit->EnableWindow(bEnable);
		}
	}

	virtual BOOL IsWindowVisible()
	{
		return ((m_pWndCombo->GetSafeHwnd() != NULL && m_pWndCombo->GetStyle() & WS_VISIBLE) || (m_pWndEdit->GetSafeHwnd() != NULL && m_pWndEdit->GetStyle() & WS_VISIBLE));
	}

	virtual BOOL IsOwnerOf(HWND hwnd)
	{
		if (m_pWndCombo->GetSafeHwnd() != NULL && (m_pWndCombo->GetSafeHwnd() == hwnd || ::IsChild(m_pWndCombo->GetSafeHwnd(), hwnd)))
		{
			return TRUE;
		}

		if (m_pWndEdit->GetSafeHwnd() != NULL && (m_pWndEdit->GetSafeHwnd() == hwnd || ::IsChild(m_pWndEdit->GetSafeHwnd(), hwnd)))
		{
			return TRUE;
		}

		return FALSE;
	}

	virtual BOOL NotifyCommand(int iNotifyCode);
	
	virtual BOOL CanBeStretched() const { return TRUE; }
	virtual void OnAddToCustomizePage();
	virtual HBRUSH OnCtlColor(CDC* pDC, UINT nCtlColor);
	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);

	virtual void DuplicateData() {}
	virtual void ClearData() {}

	virtual void OnShow(BOOL bShow);
	virtual BOOL ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const;

	virtual void SetStyle(UINT nStyle);

	virtual int Compare(LPCTSTR lpszItem1, LPCTSTR lpszItem2);
	virtual void OnGlobalFontsChanged();

	virtual BOOL OnUpdateToolTip(CWnd* pWndParent, int iButtonIndex, CToolTipCtrl& wndToolTip, CString& str);

	virtual CString GetPrompt() const { return CString(); }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	void Initialize();
	void AdjustRect();
	void SetHotEdit(BOOL bHot = TRUE);

// Attributes:
public:
	static void __stdcall SetFlatMode(BOOL bFlat = TRUE) { m_bFlat = bFlat; }
	static BOOL __stdcall IsFlatMode() { return m_bFlat; }

	static void __stdcall SetCenterVert(BOOL bCenterVert = TRUE) { m_bCenterVert = bCenterVert; }
	static BOOL __stdcall IsCenterVert() { return m_bCenterVert; }

	CComboBox* GetComboBox() const { return m_pWndCombo; }

	LPCTSTR GetText() const { return m_strEdit; }
	void SetText(LPCTSTR lpszText);

	void SetContextMenuID(UINT uiResID) { m_uiMenuResID = uiResID; }
	UINT GetContextMenuID() { return m_uiMenuResID; }

	static CMFCToolBarComboBoxButton* __stdcall GetByCmd(UINT uiCmd, BOOL bIsFocus = FALSE);
	static BOOL __stdcall SelectItemAll(UINT uiCmd, int iIndex);
	static BOOL __stdcall SelectItemAll(UINT uiCmd, DWORD_PTR dwData);
	static BOOL __stdcall SelectItemAll(UINT uiCmd, LPCTSTR lpszText);
	static int __stdcall GetCountAll(UINT uiCmd);
	static int __stdcall GetCurSelAll(UINT uiCmd);
	static LPCTSTR __stdcall GetItemAll(UINT uiCmd, int iIndex = -1);
	static DWORD_PTR __stdcall GetItemDataAll(UINT uiCmd, int iIndex = -1);
	static void* __stdcall GetItemDataPtrAll(UINT uiCmd, int iIndex = -1);
	static LPCTSTR __stdcall GetTextAll(UINT uiCmd);

	virtual BOOL HasFocus() const;

	BOOL IsRibbonButton() const { return m_bIsRibbon; }

protected:
	int   m_iWidth;
	int   m_iSelIndex;
	int   m_nDropDownHeight;
	BOOL  m_bHorz;
	BOOL  m_bIsHotEdit;
	BOOL  m_bIsRibbon;
	UINT  m_uiMenuResID;
	DWORD m_dwStyle;
	CRect m_rectCombo;
	CRect m_rectButton;

	CEdit*     m_pWndEdit;
	CComboBox* m_pWndCombo;
	CString    m_strEdit;
	CStringList m_lstItems;
	CList<DWORD_PTR, DWORD_PTR> m_lstItemData;

	AFX_IMPORT_DATA static BOOL m_bFlat;
	AFX_IMPORT_DATA static BOOL m_bCenterVert;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarComboBoxEdit

class CMFCToolBarComboBoxEdit : public CEdit
{
// Construction
public:
	CMFCToolBarComboBoxEdit(CMFCToolBarComboBoxButton& combo);

// Attributes
protected:
	CMFCToolBarComboBoxButton& m_combo;
	BOOL m_bTracked;

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCToolBarComboBoxEdit();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCToolBarComboBoxEdit)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnChange();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnPaint();
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbardatetimectrl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include <afxdtctl.h>
#include "afxcontrolbarutil.h"
#include "afxtoolbarbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarDateTimeCtrlImpl : public CDateTimeCtrl
{
public:
	CMFCToolBarDateTimeCtrlImpl() : m_bMonthCtrlDisplayed(false) {}

	// Generated message map functions
protected:
	//{{AFX_MSG(CMFCToolBarDateTimeCtrlImpl)
	afx_msg void OnDateTimeChange(NMHDR* pNotifyStruct, LRESULT* pResult);
	afx_msg void OnDateTimeDropDown(NMHDR* pNotifyStruct, LRESULT* pResult);
	afx_msg void OnDateTimeCloseUp(NMHDR* pNotifyStruct, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	bool m_bMonthCtrlDisplayed;
};

class CMFCToolBarDateTimeCtrl : public CMFCToolBarButton
{
	DECLARE_SERIAL(CMFCToolBarDateTimeCtrl)

public:
	CMFCToolBarDateTimeCtrl();
	CMFCToolBarDateTimeCtrl(UINT uiID, int iImage, DWORD dwStyle = 0, int iWidth = 0);
	virtual ~CMFCToolBarDateTimeCtrl();

// Overrides:
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void OnMove();
	virtual void OnSize(int iSize);
	virtual HWND GetHwnd() { return m_pWndDateTime->GetSafeHwnd(); }
	virtual BOOL NotifyCommand(int iNotifyCode);
	
	virtual BOOL CanBeStretched() const { return TRUE; }
	virtual void OnAddToCustomizePage();
	virtual HBRUSH OnCtlColor(CDC* pDC, UINT nCtlColor);

	virtual BOOL HaveHotBorder() const { return m_pWndDateTime->GetSafeHwnd() == NULL || (m_pWndDateTime->GetStyle() & WS_VISIBLE) == 0; }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);
	virtual void DuplicateData() {}
	virtual void OnShow(BOOL bShow);
	virtual BOOL ExportToMenuButton(CMFCToolBarMenuButton& menuButton) const;

	virtual void SetStyle(UINT nStyle);
	virtual BOOL OnUpdateToolTip(CWnd* pWndParent, int iButtonIndex, CToolTipCtrl& wndToolTip, CString& str);
	virtual void OnGlobalFontsChanged();

protected:
	void Initialize();
	void AdjustRect();

	virtual CMFCToolBarDateTimeCtrlImpl* CreateDateTimeCtrl(CWnd* pWndParent, const CRect& rect);

// Attributes:
public:
	CDateTimeCtrl* GetDateTimeCtrl() const { return m_pWndDateTime; }

	BOOL SetTime(LPSYSTEMTIME pTimeNew = NULL);
	BOOL SetTime(const COleDateTime& timeNew);
	BOOL SetTime(const CTime* timeNew);
	DWORD GetTime(LPSYSTEMTIME pTimeDest) const {return m_pWndDateTime->GetTime(pTimeDest);}
	BOOL GetTime(COleDateTime& timeDest) const {return m_pWndDateTime->GetTime(timeDest);}
	DWORD GetTime(CTime& timeDest) const {return m_pWndDateTime->GetTime(timeDest);}

	static CMFCToolBarDateTimeCtrl* __stdcall GetByCmd(UINT uiCmd);
	static BOOL __stdcall SetTimeAll(UINT uiCmd, LPSYSTEMTIME pTimeNew = NULL);
	static BOOL __stdcall SetTimeAll(UINT uiCmd, const COleDateTime& timeNew);
	static BOOL __stdcall SetTimeAll(UINT uiCmd, const CTime* pTimeNew);
	static DWORD __stdcall GetTimeAll(UINT uiCmd, LPSYSTEMTIME pTimeDest);
	static BOOL __stdcall GetTimeAll(UINT uiCmd, COleDateTime& timeDest);
	static DWORD __stdcall GetTimeAll(UINT uiCmd, CTime& timeDest);

protected:
	CMFCToolBarDateTimeCtrlImpl* m_pWndDateTime;
	DWORD m_dwStyle;
	DWORD m_dwTimeStatus;
	int   m_iWidth;
	BOOL  m_bHorz;
	CTime m_time;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbardropsource.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXOLE_H__
#include <afxole.h>
#endif

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropSource command target

class CMFCToolBarDropSource : public COleDropSource
{
public:
	CMFCToolBarDropSource();
	virtual ~CMFCToolBarDropSource();

// Attributes
public:
	BOOL    m_bDeleteOnDrop;
	BOOL    m_bEscapePressed;
	BOOL    m_bDragStarted;
	HCURSOR m_hcurDelete;
	HCURSOR m_hcurMove;
	HCURSOR m_hcurCopy;

// Overrides
public:
	virtual SCODE GiveFeedback(DROPEFFECT dropEffect);
	virtual SCODE QueryContinueDrag(BOOL bEscapePressed, DWORD dwKeyState);
	virtual BOOL OnBeginDrag(CWnd* pWnd);

// Implementation
protected:
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbardroptarget.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifndef __AFXOLE_H__
#include <afxole.h>
#endif

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarDropTarget command target

class CMFCToolBarDropTarget : public COleDropTarget
{
public:
	CMFCToolBarDropTarget();
	virtual ~CMFCToolBarDropTarget();

// Attributes
protected:
	CMFCToolBar* m_pOwner;

// Operations
public:
	BOOL Register(CMFCToolBar *pOwner);

// Overrides
	public:
	virtual DROPEFFECT OnDragEnter(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave(CWnd* pWnd);
	virtual DROPEFFECT OnDragOver(CWnd* pWnd, COleDataObject* pDataObject, DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDropEx(CWnd* pWnd, COleDataObject* pDataObject, DROPEFFECT dropEffect, DROPEFFECT dropList, CPoint point);

// Implementation
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarimages.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifndef __AFXMT_H__
	#include <afxmt.h>
#endif

#ifndef __ATLIMAGE_H__
	#include "atlimage.h"
#endif

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

// for custom drawing
typedef struct tagAFXDrawState
{
	HBITMAP hbmMono;
	HBITMAP hbmMonoOld;
	HBITMAP hbmOldGlyphs;
}
CAfxDrawState;

class CMFCToolBarImages : public CObject
{
	friend class CMFCDropDownFrame;
	friend class CMFCImageEditorDialog;
	friend class CMenuImages;
	friend class CPngImage;
	friend class CMFCRibbonCollector;

public:
	CMFCToolBarImages();
	virtual ~CMFCToolBarImages();

	enum ImageAlignHorz
	{
		ImageAlignHorzLeft,
		ImageAlignHorzCenter,
		ImageAlignHorzRight,
		ImageAlignHorzStretch
	};

	enum ImageAlignVert
	{
		ImageAlignVertTop,
		ImageAlignVertCenter,
		ImageAlignVertBottom,
		ImageAlignVertStretch
	};

// Operations:
public:
	static BOOL __stdcall Is32BitTransparencySupported();
	static BOOL __stdcall PreMultiplyAlpha(HBITMAP hbmp, BOOL bAutoCheckPremlt);

	BOOL IsValid() const { return (m_hbmImageWell != NULL); }
	BOOL IsReadOnly() const { return m_bReadOnly; }

	HBITMAP GetImageWell() const { return m_hbmImageWell; }
	HBITMAP GetImageWellLight() const { return m_hbmImageLight; }

	BOOL IsUserImagesList() const { return m_bUserImagesList; }

	void SetImageSize(SIZE sizeImage, BOOL bUpdateCount = FALSE)
	{
		m_sizeImage = sizeImage;
		if (bUpdateCount)
		{
			UpdateCount();
		}
	}

	SIZE GetImageSize(BOOL bDest = FALSE) const { return bDest ? m_sizeImageDest : m_sizeImage; }

	int GetCount() const { return m_iCount; }

	int GetResourceOffset(UINT uiResId) const
	{
		int iOffset = -1;
		if (m_mapOrigResOffsets.Lookup(uiResId, iOffset))
		{
			return iOffset;
		}
		return -1;
	}

	COLORREF SetTransparentColor(COLORREF clrTransparent)
	{
		COLORREF clrOld = m_clrTransparent;
		if (clrTransparent != clrOld)
		{
			m_clrTransparent = clrTransparent;
			UpdateInternalImage(0);
			UpdateInternalImage(1);
		}
		return clrOld;
	}

	COLORREF GetTransparentColor() const { return m_clrTransparent; }

	BOOL Load(UINT uiResID, HINSTANCE hinstRes = NULL, BOOL bAdd = FALSE);
	BOOL LoadStr(LPCTSTR lpszResourceName, HINSTANCE hinstRes = NULL, BOOL bAdd = FALSE);

	BOOL Load(LPCTSTR lpszBmpFileName, DWORD nMaxFileSize = 819200);
	BOOL Save(LPCTSTR lpszBmpFileName = NULL);

	void Clear();

	BOOL PrepareDrawImage(CAfxDrawState& ds, CSize sizeImageDest = CSize(0, 0), BOOL bFadeInactive = FALSE);

	BOOL Draw(CDC* pDC, int x, int y, int iImageIndex, BOOL bHilite = FALSE, BOOL bDisabled = FALSE,
		BOOL bIndeterminate = FALSE, BOOL bShadow = FALSE, BOOL bInactive = FALSE, BYTE alphaSrc = 255);

	BOOL DrawEx(CDC* pDC, CRect rect, int iImageIndex, ImageAlignHorz horzAlign = ImageAlignHorzLeft,
		ImageAlignVert vertAlign = ImageAlignVertTop, CRect rectSrc = CRect(0, 0, 0, 0), BYTE alphaSrc = 255);

	void EndDrawImage(CAfxDrawState& ds);

	int AddImage(HBITMAP hbmp, BOOL bSetBitPerPixel = FALSE);
	int AddImage(const CMFCToolBarImages& imageList, int nIndex);
	int AddIcon(HICON hIcon, BOOL bAlphaBlend = FALSE);
	BOOL UpdateImage(int iImage, HBITMAP hbmp);
	BOOL DeleteImage(int iImage);

	/// <summary> Returns current resolution of underlined images.</summary>
	/// <returns> An integer value representing the current resolution of underlined images, in bits per pixel (bpp).</returns>
	int GetBitsPerPixel() const
	{
		return m_nBitsPerPixel;
	}

	HICON ExtractIcon(int nIndex);

	BOOL CreateFromImageList(const CImageList& imageList);

	BOOL CopyTo(CMFCToolBarImages& imageList);
	BOOL CopyImageToClipboard(int iImage);

	BOOL GrayImages(int nGrayImageLuminancePercentage);

	HBITMAP GetMask(int iImage);

	void OnSysColorChange();

	BOOL MapTo3dColors(BOOL bUseRGBQUAD = TRUE, COLORREF clrSrc = (COLORREF)-1, COLORREF clrDest = (COLORREF)-1);
	static COLORREF __stdcall MapToSysColorAlpha(COLORREF color);
	static COLORREF __stdcall MapToSysColor(COLORREF color, BOOL bUseRGBQUAD = TRUE);
	static COLORREF __stdcall MapFromSysColor(COLORREF color, BOOL bUseRGBQUAD = TRUE);
	static void __stdcall FillDitheredRect(CDC* pDC, const CRect& rect);

	static void __stdcall CleanUp();

	static void __stdcall SetDisabledImageAlpha(BYTE nValue)
	{
		ASSERT(nValue > 0);
		ASSERT(nValue <= 255);
		m_nDisabledImageAlpha = nValue;
	}
	static BYTE __stdcall GetDisabledImageAlpha() { return m_nDisabledImageAlpha; }

	static void __stdcall SetFadedImageAlpha(BYTE nValue)
	{
		ASSERT(nValue > 0);
		ASSERT(nValue <= 255);
		m_nFadedImageAlpha = nValue;
	}
	static BYTE __stdcall GetFadedImageAlpha() { return m_nFadedImageAlpha; }

	void SetLightPercentage(int nValue) { m_nLightPercentage = nValue; }
	int GetLightPercentage() const { return m_nLightPercentage; }

	void SetPreMultiplyAutoCheck(BOOL bAuto = TRUE) { m_bAutoCheckPremlt = bAuto; }
	BOOL IsPreMultiplyAutoCheck() const { return m_bAutoCheckPremlt; }

	// RTL support:
	static void __stdcall EnableRTL(BOOL bIsRTL = TRUE);
	static BOOL __stdcall IsRTL() { return m_bIsRTL; }

	BOOL Mirror();
	static BOOL __stdcall MirrorBitmap(HBITMAP& hbmp, int cxImage);

	BOOL MirrorVert();
	static BOOL __stdcall MirrorBitmapVert(HBITMAP& hbmp, int cyImage);

	static HRGN __stdcall CreateRegionFromImage(HBITMAP bmp, COLORREF clrTransparent);

	void AdaptColors(COLORREF clrBase, COLORREF clrTone);
	void SetSingleImage();

	BOOL GetMapTo3DColors() const { return m_bMapTo3DColors; }
	void SetMapTo3DColors(BOOL bMapTo3DColors) { m_bMapTo3DColors = bMapTo3DColors; }

	BOOL GetAlwaysLight() const { return m_bAlwaysLight; }
	void SetAlwaysLight(BOOL bAlwaysLight = TRUE) { m_bAlwaysLight = bAlwaysLight; }

	CRect GetLastImageRect() const { return m_rectLastDraw; }

	static HBITMAP __stdcall Copy(HBITMAP hbmpSrc);

	/// <summary> 
	/// Smoothly resizes underlined images.</summary>
	/// <param name="dblScale"> Scale ratio.</param>
	/// <retruns> TRUE if resize succeeds; otherwise FALSE.</returns>
	BOOL SmoothResize(double dblImageScale);

	/// <summary>
	/// Returns current scale ratio of underlined images.</summary>
	/// <returns> A value representing current scale ratio.</returns>
	double GetScale() const
	{
		return m_dblScale;
	}

	/// <summary>
	/// Tells whether the underlined images are scaled or not.</summary>
	/// <returns> TRUE if underlined images are scaled; otherwise FALSE.</returns>
	BOOL IsScaled () const
	{
		return GetScale() != 1.0;
	}

	/// <summary>
	/// Converts underlined bitmaps to 32 bpp images.</summary> 
	/// <returns> TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="clrTransparent">Specifies transparent color of underlined bitmaps.</param>
	BOOL ConvertTo32Bits(COLORREF clrTransparent = (COLORREF)-1);

protected:
	static void __stdcall TransparentBlt(HDC hdcDest, int nXDest, int nYDest, int nWidth, int nHeight, CDC* pDcSrc,
		int nXSrc, int nYSrc, COLORREF colorTransparent, int nWidthDest = -1, int nHeightDest = -1);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	void CreateMask(int iImage, BOOL bHilite, BOOL bHiliteShadow);
	static HBITMAP __stdcall CreateDitherBitmap();
	void UpdateCount();
	BOOL UpdateInternalImage(int nIndex);

	BOOL PreMultiplyAlpha(HBITMAP hbmp);
	void CopyTemp(CMFCToolBarImages& imagesDest);

	static BOOL __stdcall MapBmpTo3dColors(HBITMAP& hBmp, BOOL bUseRGBQUAD = TRUE, COLORREF clrSrc = (COLORREF)-1, COLORREF clrDest = (COLORREF)-1);

// Attributes:
public:
	AFX_IMPORT_DATA static BOOL    m_bDisableTrueColorAlpha;
	AFX_IMPORT_DATA static BOOL    m_bMultiThreaded; // Set to TRUE if images are used in different threads
	AFX_IMPORT_DATA static BOOL    m_bIsDrawOnGlass; // Draw image on Vista Glass area
	AFX_IMPORT_DATA static CString m_strPngResType;  // "PNG" by default

protected:
	int m_iCount;           // image counter
	int m_nBitsPerPixel;    // Bitmap color depth
	int m_nGrayImageLuminancePercentage;  // Grayed image brightness
	int m_nLightPercentage; // Light image percentage value

	BOOL m_bUserImagesList;  // is user-defined images list?
	BOOL m_bModified;        // is image modified?
	BOOL m_bStretch;         // stretch images
	BOOL m_bReadOnly;        // Loaded from read-only file
	BOOL m_bIsTemporary;     // Temporary copy of another image
	BOOL m_bFadeInactive;    // Inactive image will be drawn with the "fading" effect
	BOOL m_bIsGray;          // Image is grayed
	BOOL m_bMapTo3DColors;   // Map image colors to system
	BOOL m_bAlwaysLight;     // Always use light image in all color resolutions
	BOOL m_bAutoCheckPremlt; // Auto-check for 32 bpp images
	BOOL m_bCreateMonoDC;    // Create mono DC in CAfxDrawState

	CDC      m_dcMem;          // DC for the drawing in memory
	CSize    m_sizeImage;      // size of glyph
	CSize    m_sizeImageOriginal;
	CSize    m_sizeImageDest;  // destination size glyph
	CRect    m_rectLastDraw;   // Last drawn image location
	CRect    m_rectSubImage;   // The part of drawn image
	HBITMAP  m_hbmImageWell;   // glyphs only
	HBITMAP  m_hbmImageLight;  // "faded" version (hi-color only)
	HBITMAP  m_hbmImageShadow; // "shadow" version
	CString  m_strUDLPath;     // user-defined images path
	CBitmap  m_bmpMem;         // bitmap for the drawing in memory
	CBitmap* m_pBmpOriginal;
	COLORREF m_clrTransparent; // Transparent color
	COLORREF m_clrTransparentOriginal;
	COLORREF m_clrImageShadow; // Color of the shadow
	double   m_dblScale;

	CList<UINT, UINT>           m_lstOrigResIds;       // original resource ids
	CList<HINSTANCE, HINSTANCE> m_lstOrigResInstances; // original resource instances
	CMap<UINT, UINT, int, int>  m_mapOrigResOffsets;   // original resource offsets

	AFX_IMPORT_DATA static BYTE      m_nDisabledImageAlpha; // Used in the alpha-blending only
	AFX_IMPORT_DATA static BYTE      m_nFadedImageAlpha;    // Used in the alpha-blending only
	AFX_IMPORT_DATA static BOOL      m_bIsRTL;              // RTL languages support

	static CCriticalSection m_CriticalSection; // For multi-thread applications
};

class CPngImage : public CBitmap  
{
// Construction/Destruction
public:
	CPngImage();
	virtual ~CPngImage();

// Attributes:
protected:
	static ATL::CImage* m_pImage;

// Operations:
public:
	BOOL Load (UINT uiResID, HINSTANCE hinstRes = NULL);
	BOOL Load (LPCTSTR lpszResourceName, HINSTANCE hinstRes = NULL);

	BOOL LoadFromFile (LPCTSTR lpszPath);
	BOOL LoadFromBuffer (LPBYTE lpBuffer, UINT uiSize);

	static void __stdcall CleanUp ()
	{
		if (m_pImage != NULL)
		{
			delete m_pImage;
			m_pImage = NULL;
		}
	}
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarmenubuttonsbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarMenuButtonsButton : public CMFCToolBarButton
{
	DECLARE_DYNCREATE(CMFCToolBarMenuButtonsButton)

public:
	CMFCToolBarMenuButtonsButton();
	CMFCToolBarMenuButtonsButton(UINT uiCmdId);
	virtual ~CMFCToolBarMenuButtonsButton();

// Overrides:
	virtual void Serialize(CArchive& /*ar*/) { ASSERT(FALSE); }

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);

	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL CanBeStored() const { return FALSE; }
	virtual BOOL HaveHotBorder() const { return FALSE; }
	virtual void CopyFrom(const CMFCToolBarButton& src);

// Attributes:
public:
	UINT m_uiSystemCommand;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarnamedialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarNameDialog dialog

class CMFCToolBarNameDialog : public CDialog
{
// Construction
public:
	CMFCToolBarNameDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	enum { IDD = IDD_AFXBARRES_TOOLBAR_NAME };
	CButton m_btnOk;
	CString m_strToolbarName;

// Overrides
protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarNameDialog)
	afx_msg void OnUpdateToolbarName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarfontcombobox.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarcomboboxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCFontInfo : public CObject
{
public:
	CMFCFontInfo(LPCTSTR lpszName, LPCTSTR lpszScript, BYTE nCharSet, BYTE nPitchAndFamily, int nType) :
		m_strName(lpszName), m_strScript(lpszScript), m_nCharSet(nCharSet), m_nPitchAndFamily(nPitchAndFamily), m_nType(nType)
	{
	}

	CMFCFontInfo(const CMFCFontInfo& src) :
		m_strName(src.m_strName), m_strScript(src.m_strScript), m_nCharSet(src.m_nCharSet), m_nPitchAndFamily(src.m_nPitchAndFamily), m_nType(src.m_nType)
	{
	}

	const CString m_strName;
	const CString m_strScript;
	const BYTE    m_nCharSet;
	const BYTE    m_nPitchAndFamily;
	const int     m_nType;  // DEVICE_FONTTYPE, RASTER_FONTTYPE or TRUETYPE_FONTTYPE

	CString GetFullName() const
	{
		CString str = m_strName;
		if (!m_strScript.IsEmpty())
		{
			str += _T(" (") + m_strScript + _T(")");
		}

		return str;
	}

	bool operator == (const CMFCFontInfo& other)
	{
		return (m_strName == other.m_strName && m_strScript == other.m_strScript && m_nCharSet == other.m_nCharSet &&
			m_nPitchAndFamily == other.m_nPitchAndFamily && m_nType == other.m_nType);
	}

};

#pragma warning( disable : 4312)

//////////////////////////////////////////
//
class CMFCToolBarFontComboBox : public CMFCToolBarComboBoxButton
{
	friend class CMFCRibbonFontComboBox;

	DECLARE_SERIAL(CMFCToolBarFontComboBox)

// Construction/Destruction
public:
	CMFCToolBarFontComboBox(UINT uiID, int iImage, int nFontType = DEVICE_FONTTYPE | RASTER_FONTTYPE | TRUETYPE_FONTTYPE,
		BYTE nCharSet = DEFAULT_CHARSET, DWORD dwStyle = CBS_DROPDOWN, int iWidth = 0, BYTE nPitchAndFamily = DEFAULT_PITCH);
	virtual ~CMFCToolBarFontComboBox();

protected:
	CMFCToolBarFontComboBox(CObList* pLstFontsExternal, int nFontType, BYTE nCharSet, BYTE nPitchAndFamily);
	CMFCToolBarFontComboBox();

// Oprerations:
public:
	BOOL SetFont(LPCTSTR lpszName, BYTE nCharSet = DEFAULT_CHARSET, BOOL bExact = FALSE);
	const CMFCFontInfo* GetFontDesc(int iIndex = -1) const { return(CMFCFontInfo*) GetItemData(iIndex); }

protected:
	void SetContext();
	void RebuildFonts();
	static void __stdcall ClearFonts();
	static int __stdcall GetFontsCount(LPCTSTR lpszName);

// Overrides:
protected:
	virtual CComboBox* CreateCombo(CWnd* pWndParent, const CRect& rect);
	virtual BOOL AddFont(ENUMLOGFONT* pelf, int nType, LPCTSTR lpszScript);
	virtual void Serialize(CArchive& ar);

	static BOOL CALLBACK AFX_EXPORT EnumFamScreenCallBackEx(ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis);
	static BOOL CALLBACK AFX_EXPORT EnumFamPrinterCallBackEx(ENUMLOGFONTEX* pelf, NEWTEXTMETRICEX* /*lpntm*/, int FontType, LPVOID pThis);

	virtual void CopyFrom(const CMFCToolBarButton& s);

// Attributes:
public:
	AFX_IMPORT_DATA static int m_nFontHeight;

protected:
	int  m_nFontType;// Combination of DEVICE_FONTTYPE, RASTER_FONTTYPE and TRUETYPE_FONTTYPE
	BYTE m_nCharSet;
	BYTE m_nPitchAndFamily;

	CObList* m_pLstFontsExternal;

	AFX_IMPORT_DATA static CObList  m_lstFonts;
	AFX_IMPORT_DATA static int      m_nCount;   // CMFCToolBarFontComboBox count
};

#pragma warning( default : 4312)

////////////////////////////////////////
// 
class CMFCToolBarFontSizeComboBox : public CMFCToolBarComboBoxButton  
{
	DECLARE_SERIAL(CMFCToolBarFontSizeComboBox)

// Construction/Destruction
public:
	CMFCToolBarFontSizeComboBox(UINT uiID, int iImage, DWORD dwStyle = CBS_DROPDOWN, int iWidth = 0);
	virtual ~CMFCToolBarFontSizeComboBox();

protected:
	CMFCToolBarFontSizeComboBox();

protected:
	int m_nLogVert;

// Operations:
public:
	void RebuildFontSizes(const CString& strFontName);

	void SetTwipSize(int nSize);
	int GetTwipSize() const;

protected:
	CString TwipsToPointString(int nTwips);
	void InsertSize(int nSize);
	static BOOL FAR PASCAL EnumSizeCallBack(LOGFONT FAR* lplf, LPNEWTEXTMETRIC lpntm,int FontType, LPVOID lpv);

// Overrides:
protected:
	virtual CComboBox* CreateCombo(CWnd* pWndParent, const CRect& rect);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarmenubutton.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarbutton.h"
#include "afxpopupmenu.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

static const int AFX_TEXT_MARGIN = 3;
static const int AFX_MENU_IMAGE_MARGIN = 2;

static const int AFX_MENU_GROUP_ID = ((UINT)-1) - 1;

class CMFCToolBarMenuButton : public CMFCToolBarButton
{
	friend class CMFCPopupMenu;
	friend class CMFCPopupMenuBar;
	friend class CMFCToolBar;
	friend class CMFCMenuBar;
	friend class CMFCRibbonStatusBarCustomizeButton;
	friend class CMFCRibbonButton;

	DECLARE_SERIAL(CMFCToolBarMenuButton)

public:
	CMFCToolBarMenuButton();
	CMFCToolBarMenuButton(const CMFCToolBarMenuButton& src);
	CMFCToolBarMenuButton(UINT uiID, HMENU hMenu, int iImage, LPCTSTR lpszText = NULL, BOOL bUserButton = FALSE);
	virtual ~CMFCToolBarMenuButton();

// Operations:
protected:
	void Initialize();
	void Initialize(UINT uiID, HMENU hMenu, int iImage, LPCTSTR lpszText = NULL, BOOL bUserButton = FALSE);
	void DrawMenuItem(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bCustomizeMode, BOOL bHighlight, BOOL bGrayDisabledButtons, BOOL bContentOnly = FALSE);
	void DrawDocumentIcon(CDC* pDC, const CRect& rectImage, HICON hIcon);

	static void __stdcall GetTextHorzOffsets(int& xOffsetLeft, int& xOffsetRight);

public:
	virtual BOOL OpenPopupMenu(CWnd* pWnd = NULL);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);

	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void CreateFromMenu(HMENU hMenu);
	virtual HMENU CreateMenu() const;
	virtual BOOL HaveHotBorder() const { return FALSE; }
	virtual void OnCancelMode();
	virtual BOOL OnContextHelp(CWnd* pWnd) { return OnClick(pWnd, FALSE); }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);
	virtual BOOL IsDroppedDown() const { return m_pPopupMenu != NULL; }

	virtual CMFCPopupMenu* CreatePopupMenu() { return new CMFCPopupMenu; }
	virtual void OnAfterCreatePopupMenu() {}

	virtual BOOL IsEmptyMenuAllowed() const { return FALSE; }

	virtual BOOL OnBeforeDrag() const;
	virtual void SaveBarState();

	void GetImageRect(CRect& rectImage);
	
	virtual void SetRadio();
	virtual void ResetImageToDefault();
	virtual BOOL CompareWith(const CMFCToolBarButton& other) const;

	virtual BOOL IsBorder() const { return TRUE; }

	virtual BOOL OnClickMenuItem() { return FALSE; } // Return TRUE for the custom process
	virtual BOOL IsExclusive() const { return FALSE; }
	virtual BOOL HasButton() const { return FALSE; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

// Attributes:
public:
	const CObList& GetCommands() const { return m_listCommands; }
	CMFCPopupMenu* GetPopupMenu() const { return m_pPopupMenu; }

	void SetMenuOnly(BOOL bMenuOnly) { m_bMenuOnly = bMenuOnly; }
	virtual BOOL IsTearOffMenu() const { return m_uiTearOffBarID != 0; }
	virtual void SetTearOff(UINT uiBarID);

	// CMainFrame::OnDrawMenuImage will be called  even after default image was drawn
	AFX_IMPORT_DATA static BOOL m_bAlwaysCallOwnerDraw;

	void SetMessageWnd(CWnd* pWndMessage) { m_pWndMessage = pWndMessage; }

	void SetMenuPaletteMode(BOOL bMenuPaletteMode = TRUE, int nPaletteRows = 1);
	BOOL IsMenuPaletteMode() const { return m_bMenuPaletteMode; }

	int GetPaletteRows() const { return m_nPaletteRows; }

	void EnableQuickCustomize() { m_bQuickCustomMode = TRUE; }
	BOOL IsQuickMode() { return m_bQuickCustomMode; }
	BOOL IsClickedOnMenu() const { return m_bClickedOnMenu; }

protected:
	CObList     m_listCommands; // List of CMFCToolBarButton
	CMFCPopupMenu* m_pPopupMenu;

	BOOL m_bDrawDownArrow;
	BOOL m_bMenuMode;
	BOOL m_bDefault;
	BOOL m_bClickedOnMenu;
	BOOL m_bHorz;
	BOOL m_bToBeClosed;
	BOOL m_bMenuOnly; //JRG
	BOOL m_bIsRadio;
	BOOL m_bMenuPaletteMode;
	BOOL m_bQuickCustomMode;
	BOOL m_bShowAtRightSide;
	UINT m_uiTearOffBarID;
	int  m_nPaletteRows;

	CWnd* m_pWndMessage;
	CRect m_rectArrow;
	CRect m_rectButton;

public:

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbareditboxbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarbutton.h"
#include "afxeditbrowsectrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarEditBoxButton : public CMFCToolBarButton
{
	friend class CMFCToolBarEditCtrl;

	DECLARE_SERIAL(CMFCToolBarEditBoxButton)

public:
	CMFCToolBarEditBoxButton();
	CMFCToolBarEditBoxButton(UINT uiID, int iImage, DWORD dwStyle = ES_AUTOHSCROLL, int iWidth = 0);
	virtual ~CMFCToolBarEditBoxButton();

// Overrides:
	virtual CEdit* CreateEdit(CWnd* pWndParent, const CRect& rect);

	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual BOOL OnClick(CWnd* pWnd, BOOL bDelay = TRUE);
	virtual void OnChangeParentWnd(CWnd* pWndParent);
	virtual void OnMove();
	virtual void OnSize(int iSize);
	virtual HWND GetHwnd() { return m_pWndEdit->GetSafeHwnd(); }
	virtual BOOL NotifyCommand(int iNotifyCode);
	
	virtual BOOL CanBeStretched() const { return TRUE; }
	virtual void OnAddToCustomizePage();
	virtual HBRUSH OnCtlColor(CDC* pDC, UINT nCtlColor);
	virtual BOOL HaveHotBorder() const { return m_pWndEdit->GetSafeHwnd() == NULL || (m_pWndEdit->GetStyle() & WS_VISIBLE) == 0; }

	virtual int OnDrawOnCustomizeList(CDC* pDC, const CRect& rect, BOOL bSelected);

	virtual void OnShow(BOOL bShow);
	virtual void SetContents(const CString& sContents);

	virtual const CRect GetInvalidateRect() const;
	virtual void SetStyle(UINT nStyle);

	virtual void GetEditBorder(CRect& rectBorder);

	virtual BOOL OnUpdateToolTip(CWnd* pWndParent, int iButtonIndex, CToolTipCtrl& wndToolTip, CString& str);

	virtual void OnGlobalFontsChanged();

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

	static void __stdcall SetFlatMode(BOOL bFlat = TRUE) { m_bFlat = bFlat; }
	static BOOL __stdcall IsFlatMode() { return m_bFlat; }

protected:
	void Initialize();
	void SetHotEdit(BOOL bHot);

	virtual void OnShowEditbox(BOOL /*bShow*/) {}

// Attributes:
public:
	CEdit* GetEditBox() const { return m_pWndEdit; }

	void SetContextMenuID(UINT uiResID) { m_uiMenuResID = uiResID; }
	UINT GetContextMenuID() { return m_uiMenuResID; }

	static CMFCToolBarEditBoxButton* __stdcall GetByCmd(UINT uiCmd);
	static BOOL __stdcall SetContentsAll(UINT uiCmd, const CString& strContents);
	static CString __stdcall GetContentsAll(UINT uiCmd);

protected:
	int     m_iWidth;
	DWORD   m_dwStyle;
	CEdit*  m_pWndEdit;
	CString m_strContents;
	BOOL    m_bChangingText;
	BOOL    m_bHorz;
	BOOL    m_bIsHotEdit;
	UINT    m_uiMenuResID;

	AFX_IMPORT_DATA static BOOL m_bFlat;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarEditCtrl

class CMFCToolBarEditCtrl : public CMFCEditBrowseCtrl
{
// Construction
public:
	CMFCToolBarEditCtrl(CMFCToolBarEditBoxButton& edit);

// Attributes
protected:
	CMFCToolBarEditBoxButton& m_buttonEdit;
	BOOL m_bTracked;

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CMFCToolBarEditCtrl();

protected:
	//{{AFX_MSG(CMFCToolBarEditCtrl)
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg LRESULT OnMouseLeave(WPARAM,LPARAM);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarscommandslistbox.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCommandsListBox window

class CMFCToolBarsCommandsListBox : public CListBox
{
// Construction
public:
	CMFCToolBarsCommandsListBox();

// Attributes
protected:
	CSize m_sizeButton;

// Operations
public:

// Overrides
public:
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

protected:
	virtual void PreSubclassWindow();

// Implementation
public:
	virtual ~CMFCToolBarsCommandsListBox();

protected:
	//{{AFX_MSG(CMFCToolBarsCommandsListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarscustomizedialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarslistpropertypage.h"
#include "afxtoolbarstoolspropertypage.h"
#include "afxtoolbarsmenupropertypage.h"
#include "afxmousepropertypage.h"
#include "afxtoolbarskeyboardpropertypage.h"
#include "afxtoolbarsoptionspropertypage.h"
#include "afxbutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarImages;
class CMFCToolBarButton;
class CMFCToolBar;
class CUserTool;

//---------------------
// Customization flags:
//---------------------
#define AFX_CUSTOMIZE_MENU_SHADOWS    0x0001 // Allow chnage menu shadow appearance
#define AFX_CUSTOMIZE_TEXT_LABELS     0x0002 // Allow chnage toolbar text lables below the image
#define AFX_CUSTOMIZE_MENU_ANIMATIONS 0x0004 // Allow chnage menu animations
#define AFX_CUSTOMIZE_NOHELP          0x0008 // Remove help button from the customization dialog
#define AFX_CUSTOMIZE_CONTEXT_HELP    0x0010 // Add '?' to caption and "What's This" context menu
#define AFX_CUSTOMIZE_NOTOOLS         0x0020 // Remove tools page from the customization dialog
#define AFX_CUSTOMIZE_MENUAMPERS      0x0040 // Allow buttons text contain '&'
#define AFX_CUSTOMIZE_NO_LARGE_ICONS  0x0080 // Remove "Large Icons" option from the customization dialog

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCustomizeDialog
//
// CMFCToolBarsCustomizeDialog is a modeless property sheet that is  created once and not destroyed
// until the application closes.  It is initialized and controlled from CPropertyFrame.

class CMFCToolBarsCustomizeDialog : public CPropertySheet
{
	friend class CMFCToolBar;
	friend class CMFCToolBarsToolsPropertyPage;
	friend class CMFCToolBarsKeyboardPropertyPage;
	friend class CVSToolsListBox;

	DECLARE_DYNAMIC(CMFCToolBarsCustomizeDialog)

// Construction
public:
	CMFCToolBarsCustomizeDialog(CFrameWnd* pWndParentFrame, BOOL bAutoSetFromMenus = FALSE,
		UINT uiFlags = (AFX_CUSTOMIZE_MENU_SHADOWS | AFX_CUSTOMIZE_TEXT_LABELS | AFX_CUSTOMIZE_MENU_ANIMATIONS | AFX_CUSTOMIZE_NOHELP),
		CList <CRuntimeClass*, CRuntimeClass*>* plistCustomPages = NULL);

// Attributes
public:
	UINT GetFlags() const { return m_uiFlags; }

protected:
	//------------------------------------------
	// Toolbar+menu items divided by categories:
	//------------------------------------------
	CMap<CString, LPCTSTR, CObList*, CObList*> m_ButtonsByCategory;
	CStringList m_strCategoriesList; // Need for order!
	//----------------
	// Property pages:
	//----------------
	CMFCToolBarsCommandsPropertyPage* m_pCustomizePage;
	CMFCToolBarsListPropertyPage*  m_pToolbarsPage;
	CMFCToolBarsKeyboardPropertyPage*  m_pKeyboardPage;
	CMFCToolBarsMenuPropertyPage*      m_pMenuPage;
	CMFCMousePropertyPage*     m_pMousePage;
	CMFCToolBarsOptionsPropertyPage*   m_pOptionsPage;
	CMFCToolBarsToolsPropertyPage*     m_pToolsPage;
	
	//-------------------------------------
	// Support for additional custom pages:
	//-------------------------------------
	CList<CPropertyPage*,CPropertyPage*> m_listCustomPages;
	CString    m_strAllCommands;
	CFrameWnd* m_pParentFrame;
	BOOL m_bAutoSetFromMenus;
	UINT m_uiFlags;
	BOOL m_bSaveMenuAmps;
	CMFCButton m_btnHelp;

// Operations
public:

	void AddButton(UINT uiCategoryId, const CMFCToolBarButton& button, int iInsertBefore = -1);
	void AddButton(LPCTSTR lpszCategory, const CMFCToolBarButton& button, int iInsertBefore = -1);

	int RemoveButton(UINT uiCategoryId, UINT uiCmdId);
	int RemoveButton(LPCTSTR lpszCategory, UINT uiCmdId);

	void ReplaceButton(UINT uiCmd, const CMFCToolBarButton& button);

	BOOL AddToolBar(UINT uiCategoryId, UINT uiToolbarResId);
	BOOL AddToolBar(LPCTSTR lpszCategory, UINT uiToolbarResId);
	BOOL AddMenu(UINT uiMenuResId);
	void AddMenuCommands(const CMenu* pMenu, BOOL bPopup, LPCTSTR lpszCategory = NULL, LPCTSTR lpszMenuPath = NULL /* e.g. "ViewToolbars"*/);

	BOOL RenameCategory(LPCTSTR lpszCategoryOld, LPCTSTR lpszCategoryNew);

	BOOL SetUserCategory(LPCTSTR lpszCategory);

	void EnableUserDefinedToolbars(BOOL bEnable = TRUE);
	void EnableTools(CObList* pToolsList); // List of CUserTool-derived objects

	void FillCategoriesComboBox(CComboBox& wndCategory, BOOL bAddEmpty = TRUE) const;
	void FillCategoriesListBox(CListBox& wndCategory, BOOL bAddEmpty = TRUE) const;
	
	virtual void FillAllCommandsList(CListBox& wndListOfCommands) const;

	LPCTSTR GetCommandName(UINT uiCmd) const;

	int GetCountInCategory(LPCTSTR lpszItemName, const CObList& lstCommands) const; // Return number of items with the same name

protected:
	void SetFrameCustMode(BOOL bCustMode);
	void ShowToolBar(CMFCToolBar* pToolBar, BOOL bShow);
	void SetupFromMenus();
	void AddUserTools(LPCTSTR lpszCategory);

// Overrides
public:
	virtual BOOL OnInitDialog();

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	//------------------
	// Tools page hooks:
	//------------------
	virtual void OnInitToolsPage() {}
	virtual void OnBeforeChangeTool(CUserTool* /*pSelTool*/) {}
	virtual void OnAfterChangeTool(CUserTool* /*pSelTool*/) {}
	virtual BOOL CheckToolsValidity(const CObList& /*lstTools*/) { return TRUE; }

	//---------------------
	// Keyboard page hooks:
	//---------------------
	virtual BOOL OnAssignKey(ACCEL* /*pAccel*/) { return TRUE; }

public:
	virtual BOOL Create();
	virtual BOOL OnEditToolbarMenuImage(CWnd* pWndParent, CBitmap& bitmap, int nBitsPerPixel);

// Implementation
public:
	virtual ~CMFCToolBarsCustomizeDialog();
	virtual void PostNcDestroy();

protected:
	//{{AFX_MSG(CMFCToolBarsCustomizeDialog)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarskeyboardpropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxribbonres.h"
#include "afxacceleratorkeyassignctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsKeyboardPropertyPage dialog

class CMFCToolBarsKeyboardPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCToolBarsKeyboardPropertyPage)

// Construction
public:
	CMFCToolBarsKeyboardPropertyPage(CFrameWnd* pParentFrame = NULL, BOOL bAutoSet = FALSE);
	~CMFCToolBarsKeyboardPropertyPage();

	void SetAllCategory(LPCTSTR lpszCategory);

// Dialog Data
	//{{AFX_DATA(CMFCToolBarsKeyboardPropertyPage)
	enum { IDD = IDD_AFXBARRES_PROPPAGE5 };
	CStatic    m_wndAssignedToTitle;
	CMFCAcceleratorKeyAssignCtrl m_wndNewKey;
	CComboBox  m_wndViewTypeList;
	CStatic    m_wndViewIcon;
	CButton    m_wndRemoveButton;
	CListBox   m_wndCurrentKeysList;
	CListBox   m_wndCommandsList;
	CComboBox  m_wndCategoryList;
	CButton    m_wndAssignButton;
	CString    m_strDescription;
	CString    m_strAssignedTo;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsKeyboardPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnAssign();
	afx_msg void OnSelchangeCategory();
	afx_msg void OnSelchangeCommandsList();
	afx_msg void OnSelchangeCurrentKeysList();
	afx_msg void OnRemove();
	afx_msg void OnResetAll();
	afx_msg void OnSelchangeViewType();
	afx_msg void OnUpdateNewShortcutKey();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Operations:
protected:
	void AddKeyEntry(LPACCEL pEntry);

// Attributes:
protected:
	HACCEL  m_hAccelTable;
	LPACCEL m_lpAccel;
	LPACCEL m_pSelEntry;

	int  m_nAccelSize;
	BOOL m_bAutoSet;

	CMultiDocTemplate* m_pSelTemplate;
	CMFCToolBarButton* m_pSelButton;
	CFrameWnd* m_pParentFrame;
	CString m_strAllCategory;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarslistpropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtoolbarbuttonslistbutton.h"
#include "afxtoolbarscommandslistbox.h"
#include "afxribbonres.h"
#include "afxtoolbarslistcheckbox.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsCommandsPropertyPage dialog

class CMFCToolBarButton;
class CMFCToolBarImages;
class CMFCToolBar;

class CMFCToolBarsCommandsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCToolBarsCommandsPropertyPage)

// Construction
public:
	CMFCToolBarsCommandsPropertyPage();
	~CMFCToolBarsCommandsPropertyPage();

// Operations:
	void SetUserCategory(LPCTSTR lpszCategory);
	void SetAllCategory(LPCTSTR lpszCategory);
	void OnChangeSelButton(CMFCToolBarButton* pButton);

protected:

// Dialog Data
	enum { IDD = IDD_AFXBARRES_PROPPAGE1 };
	CListBox         m_wndCategory;
	CMFCToolBarsCommandsListBox m_wndTools;
	CString          m_strButtonDescription;

// Overrides
protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsCommandsPropertyPage)
	afx_msg void OnSelchangeUserTools();
	afx_msg void OnSelchangeCategory();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
protected:
	CMFCToolBarButton* m_pSelButton;
	CString m_strUserCategory;
	CString m_strAllCategory;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsListPropertyPage dialog

class CMFCToolBarsListPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCToolBarsListPropertyPage)

// Construction
public:
	CMFCToolBarsListPropertyPage(CFrameWnd* pParentFrame = NULL);
	~CMFCToolBarsListPropertyPage();

// Dialog Data
	enum { IDD = IDD_AFXBARRES_PROPPAGE2 };
	CButton m_wndTextLabels;
	CButton m_bntRenameToolbar;
	CButton m_btnNewToolbar;
	CButton m_btnDelete;
	CButton m_btnReset;
	CMFCToolBarsListCheckBox m_wndToolbarList;
	BOOL m_bTextLabels;

// Operations:
public:
	void ShowToolBar(CMFCToolBar* pToolBar, BOOL bShow);
	void EnableUserDefinedToolbars(BOOL bEnable) { m_bUserDefinedToolbars = bEnable; }

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsListPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeToolbarList();
	afx_msg void OnDblClkToolBarList();
	afx_msg void OnResetToolbar();
	afx_msg void OnResetAllToolbars();
	afx_msg void OnDeleteToolbar();
	afx_msg void OnNewToolbar();
	afx_msg void OnRenameToolbar();
	afx_msg void OnTextLabels();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CMFCToolBar* m_pSelectedToolbar;
	BOOL            m_bUserDefinedToolbars;
	CFrameWnd*      m_pParentFrame;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarsmenupropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCMenuBar;
class CMFCPopupMenu;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsMenuPropertyPage dialog

class CMFCToolBarsMenuPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCToolBarsMenuPropertyPage)

// Construction
public:
	CMFCToolBarsMenuPropertyPage(CFrameWnd* pParentFrame = NULL, BOOL bAutoSet = FALSE);
	~CMFCToolBarsMenuPropertyPage();

// Operations
public:
	void CloseContextMenu(CMFCPopupMenu* pMenu);
	BOOL SelectMenu(CDocTemplate* pTemplate, BOOL bSaveCurr = TRUE);

// Dialog Data
	//{{AFX_DATA(CMFCToolBarsMenuPropertyPage)
	enum { IDD = IDD_AFXBARRES_PROPPAGE3 };
	CStatic   m_wndMenuAnimationsLabel;
	CStatic   m_wndContextHint;
	CStatic   m_wndContextMenuCaption;
	CStatic   m_wndIcon;
	CButton   m_wndMenuShadows;
	CButton   m_wndContextFrame;
	CButton   m_wndResetMenuButton;
	CComboBox m_wndMenuAnimations;
	CComboBox m_wndContextMenus;
	CComboBox m_wndMenuesList;
	CString   m_strMenuDescr;
	CString   m_strContextMenuName;
	CString   m_strMenuName;
	int       m_iMenuAnimationType;
	BOOL      m_bMenuShadows;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsMenuPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeMenuList();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeContextMenuList();
	afx_msg void OnResetMenu();
	afx_msg void OnResetFrameMenu();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void SaveMenu();

// Attributes:
protected:
	CMFCMenuBar*   m_pMenuBar;
	CMFCPopupMenu* m_pContextMenu;
	CFrameWnd*  m_pParentFrame;

	HMENU m_hmenuCurr;
	HMENU m_hmenuSelected;
	UINT  m_uiContextMenuResId;
	BOOL  m_bIsDefaultMDIMenu;
	BOOL  m_bAutoSet;

	AFX_IMPORT_DATA static CPoint m_ptMenuLastPos;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarslistcheckbox.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsListCheckBox window

class CMFCToolBarsListCheckBox : public CCheckListBox
{
// Construction
public:
	CMFCToolBarsListCheckBox();

// Attributes
protected:
	CArray<BOOL, BOOL> m_arCheckData;

// Operations
public:
	void EnableCheck(int nIndex, BOOL bEnable = TRUE);
	BOOL IsCheckEnabled(int nIndex) const;

// Implementation
public:
	virtual ~CMFCToolBarsListCheckBox();

protected:
	//{{AFX_MSG(CMFCToolBarsListCheckBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	LRESULT OnLBAddString(WPARAM wParam, LPARAM lParam);
	LRESULT OnLBInsertString(WPARAM wParam, LPARAM lParam);
	LRESULT OnLBResetContent(WPARAM wParam, LPARAM lParam);
	LRESULT OnLBDeleteString(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void OnNewString(int iIndex);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarspineditboxbutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbareditboxbutton.h"
#include "afxspinbuttonctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarSpinEditBoxButton : public CMFCToolBarEditBoxButton
{
	DECLARE_SERIAL(CMFCToolBarSpinEditBoxButton)

// Construction
public:
	CMFCToolBarSpinEditBoxButton();
	CMFCToolBarSpinEditBoxButton(UINT uiID, int iImage, DWORD dwStyle = ES_AUTOHSCROLL, int iWidth = 0);
	virtual ~CMFCToolBarSpinEditBoxButton();

// Operations
public:
	void SetRange(int nMin, int nMax);
	void GetRange(int& nMin, int& nMax);

	CSpinButtonCtrl* GetSpinControl() { return &m_wndSpin; }

	virtual BOOL SetACCData(CWnd* pParent, CAccessibilityData& data);

protected:
	void Init();

// Attributes
protected:
	CMFCSpinButtonCtrl m_wndSpin;
	int m_nMin;
	int m_nMax;

// Overrides
protected:
	virtual CEdit* CreateEdit(CWnd* pWndParent, const CRect& rect);
	virtual void OnMove();
	virtual void GetEditBorder(CRect& rectBorder);
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual void Serialize(CArchive& ar);
	virtual BOOL OnUpdateToolTip(CWnd* pWndParent, int iButtonIndex, CToolTipCtrl& wndToolTip, CString& str);
	virtual void OnShowEditbox(BOOL bShow);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarsoptionspropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsOptionsPropertyPage dialog

class CMFCToolBarsOptionsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CMFCToolBarsOptionsPropertyPage)

// Construction
public:
	CMFCToolBarsOptionsPropertyPage(BOOL bIsMenuBarExist = FALSE);
	~CMFCToolBarsOptionsPropertyPage();

// Dialog Data
	//{{AFX_DATA(CMFCToolBarsOptionsPropertyPage)
	enum { IDD = IDD_AFXBARRES_PROPPAGE6 };
	CButton m_wndLargeIcons;
	CButton m_wndRUMenus;
	CButton m_wndResetUsageBtn;
	CStatic m_wndRuMenusLine;
	CStatic m_wndRuMenusTitle;
	CButton m_wndShowAllMenusDelay;
	CButton m_wndShowShortcutKeys;

	BOOL    m_bShowTooltips;
	BOOL    m_bShowShortcutKeys;
	BOOL    m_bRecentlyUsedMenus;
	BOOL    m_bShowAllMenusDelay;
	BOOL    m_bLargeIcons;
	//}}AFX_DATA

// Overrides
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsOptionsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OShowTooltipsWithKeys();
	afx_msg void OnShowTooltips();
	afx_msg void OnResetUsageData();
	afx_msg void OnShowRecentlyUsedMenus();
	afx_msg void OnShowMenusDelay();
	afx_msg void OnLargeIcons();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes:
protected:
	BOOL m_bIsMenuBarExist;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarstoolspropertypage.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxvslistbox.h"
#include "afxmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarsCustomizeDialog;
class CMFCToolBarsToolsPropertyPage;
class CUserTool;

class CVSToolsListBox : public CVSListBox
{
public:
	CVSToolsListBox(CMFCToolBarsToolsPropertyPage* pParent) : m_pParent(pParent) {}

	virtual void OnSelectionChanged();
	virtual BOOL OnBeforeRemoveItem(int iItem);
	virtual void OnAfterAddItem(int iItem);
	virtual void OnAfterRenameItem(int iItem);
	virtual void OnAfterMoveItemUp(int iItem);
	virtual void OnAfterMoveItemDown(int iItem);

	CMFCToolBarsToolsPropertyPage* m_pParent;
};

/////////////////////////////////////////////////////////////////////////////
// CMFCToolBarsToolsPropertyPage dialog

class CMFCToolBarsToolsPropertyPage : public CPropertyPage
{
	friend class CVSToolsListBox;

// Construction
public:
	CMFCToolBarsToolsPropertyPage();
	~CMFCToolBarsToolsPropertyPage();

// Dialog Data
	enum { IDD = IDD_AFXBARRES_PROPPAGE7 };
	CMFCMenuButton m_wndInitialDirBtn;
	CMFCMenuButton m_wndArgumentsBtn;
	CEdit       m_wndArgumentsEdit;
	CEdit       m_wndInitialDirEdit;
	CEdit       m_wndCommandEdit;
	CButton     m_wndBrowseBtn;
	CVSToolsListBox  m_wndToolsList;
	CString     m_strCommand;
	CString     m_strArguments;
	CString     m_strInitialDirectory;

// Overrides
public:
	virtual void OnOK();
	virtual BOOL OnKillActive();

protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	//{{AFX_MSG(CMFCToolBarsToolsPropertyPage)
	afx_msg void OnBrowseCommand();
	afx_msg void OnUpdateTool();
	afx_msg void OnArgumentsOptions();
	afx_msg void OnInitialDirectoryOptions();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CUserTool* CreateNewTool();
	void EnableControls();

	CUserTool*         m_pSelTool;
	CMFCToolBarsCustomizeDialog* m_pParentSheet;

	CMenu m_menuArguments;
	CMenu m_menuInitialDir;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtrackmouse.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

BOOL AFXTrackMouse(LPTRACKMOUSEEVENT ptme);

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtooltipmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxtooltipctrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_TOOLTIP_TYPE_ALL        0xFFFF

#define AFX_TOOLTIP_TYPE_DEFAULT    0x0001
#define AFX_TOOLTIP_TYPE_TOOLBAR    0x0002
#define AFX_TOOLTIP_TYPE_TAB        0x0004
#define AFX_TOOLTIP_TYPE_MINIFRAME  0x0008
#define AFX_TOOLTIP_TYPE_DOCKBAR    0x0010
#define AFX_TOOLTIP_TYPE_EDIT       0x0020
#define	AFX_TOOLTIP_TYPE_BUTTON     0x0040
#define	AFX_TOOLTIP_TYPE_TOOLBOX    0x0080
#define AFX_TOOLTIP_TYPE_PLANNER    0x0100
#define AFX_TOOLTIP_TYPE_RIBBON     0x0200
#define	AFX_TOOLTIP_TYPE_CAPTIONBAR 0x0400

#define AFX_TOOLTIP_TYPES           11

class CTooltipManager : public CObject
{
public:

	static BOOL __stdcall CreateToolTip(CToolTipCtrl*& pToolTip, CWnd* pWndParent, UINT nType);
	static void __stdcall DeleteToolTip(CToolTipCtrl*& pToolTip);
	static void __stdcall SetTooltipText(TOOLINFO* pTI, CToolTipCtrl* pToolTip, UINT nType, const CString strText, LPCTSTR lpszDescr = NULL);

	CTooltipManager();
	virtual ~CTooltipManager();

	void SetTooltipParams(UINT nTypes, CRuntimeClass* pRTC = RUNTIME_CLASS(CMFCToolTipCtrl), CMFCToolTipInfo* pParams = NULL);
	void UpdateTooltips();

protected:
	BOOL CreateToolTipObject(CToolTipCtrl*& pToolTip, UINT nType);

	CMFCToolTipInfo    m_Params[AFX_TOOLTIP_TYPES];
	CRuntimeClass*    m_pRTC[AFX_TOOLTIP_TYPES];
	CList<HWND, HWND> m_lstOwners;
};

extern CTooltipManager* afxTooltipManager;
extern AFX_IMPORT_DATA UINT AFX_WM_UPDATETOOLTIPS;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxusertool.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CUserTool : public CObject
{
	friend class CUserToolsManager;

	DECLARE_SERIAL(CUserTool)

public:
// Construction
	CUserTool();
	virtual ~CUserTool();

// Overrides
	virtual void Serialize(CArchive& ar);
	virtual BOOL Invoke();
	virtual HICON SetToolIcon();

// Operations:
public:
	void DrawToolIcon(CDC* pDC, const CRect& rectImage);
	void SetCommand(LPCTSTR lpszCmd);
	BOOL CopyIconToClipboard();

protected:
	virtual HICON LoadDefaultIcon();
	virtual void DeleteIcon();

// Attributes:
public:
	UINT GetCommandId() const
	{
		return m_uiCmdId;
	}

	const CString& GetCommand() const
	{
		return m_strCommand;
	}

	CString m_strLabel;
	CString m_strArguments;
	CString m_strInitialDirectory;

protected:
	UINT    m_uiCmdId;
	CString m_strCommand;
	HICON   m_hIcon;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtoolbarsystemmenubutton.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxtoolbarmenubutton.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBarSystemMenuButton : public CMFCToolBarMenuButton
{
	DECLARE_SERIAL(CMFCToolBarSystemMenuButton)

public:
	CMFCToolBarSystemMenuButton();
	CMFCToolBarSystemMenuButton(HMENU hSystemMenu, HICON hSystemIcon);
	virtual ~CMFCToolBarSystemMenuButton();

// Overrides:
	virtual void CopyFrom(const CMFCToolBarButton& src);
	virtual SIZE OnCalculateSize(CDC* pDC, const CSize& sizeDefault, BOOL bHorz);
	virtual void OnDraw(CDC* pDC, const CRect& rect, CMFCToolBarImages* pImages, BOOL bHorz = TRUE, BOOL bCustomizeMode = FALSE,
		BOOL bHighlight = FALSE, BOOL bDrawBorder = TRUE, BOOL bGrayDisabledButtons = TRUE);
	virtual void OnDblClk(CWnd* pWnd);
	virtual BOOL CanBeStored() const { return FALSE; }
	virtual BOOL HaveHotBorder() const { return FALSE; }
	virtual void Serialize(CArchive& /*ar*/) { ASSERT(FALSE); }
	virtual void OnCancelMode();

	virtual void CreateFromMenu(HMENU hMenu);
	virtual HMENU CreateMenu() const;

	virtual BOOL IsBorder() const { return FALSE; }
	virtual void OnAfterCreatePopupMenu();

/// Attributes:
public:
	HICON GetSysMenuIcon() const { return m_hSysMenuIcon; }
	HMENU GetSysMenu() const { return m_hSystemMenu; }

protected:
	HICON m_hSysMenuIcon;
	HMENU m_hSystemMenu;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxtooltipctrl.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCToolBar;
class CMFCToolBarButton;
class CMFCToolBarImages;
class CMFCRibbonButton;

/////////////////////////////////////////////////////////////////////////////
// CMFCToolTipInfo

class CMFCToolTipInfo
{
public:
	BOOL m_bBalloonTooltip;
	BOOL m_bDrawIcon;
	BOOL m_bDrawDescription;
	BOOL m_bRoundedCorners;
	BOOL m_bBoldLabel;
	BOOL m_bDrawSeparator;
	BOOL m_bVislManagerTheme;
	int  m_nMaxDescrWidth;
	int  m_nGradientAngle;	// 0 - 360, -1 -default (vertical)
	COLORREF m_clrFill;
	COLORREF m_clrFillGradient;
	COLORREF m_clrText;
	COLORREF m_clrBorder;

	CMFCToolTipInfo()
	{
		m_bBalloonTooltip   = FALSE;
		m_bDrawIcon         = TRUE;
		m_bDrawDescription  = TRUE;
		m_bRoundedCorners   = FALSE;
		m_bBoldLabel        = TRUE;
		m_bDrawSeparator    = TRUE;
		m_bVislManagerTheme = FALSE;
		m_nMaxDescrWidth    = 200;
		m_nGradientAngle    = -1;
		m_clrFill           = (COLORREF)-1;
		m_clrFillGradient   = (COLORREF)-1;
		m_clrText           = (COLORREF)-1;
		m_clrBorder         = (COLORREF)-1;
	}

	CMFCToolTipInfo& operator= (CMFCToolTipInfo& src)
	{
		m_bBalloonTooltip   = src.m_bBalloonTooltip;
		m_bDrawIcon         = src.m_bDrawIcon;
		m_bDrawDescription  = src.m_bDrawDescription;
		m_bRoundedCorners   = src.m_bRoundedCorners;
		m_bBoldLabel        = src.m_bBoldLabel;
		m_bDrawSeparator    = src.m_bDrawSeparator;
		m_bVislManagerTheme = src.m_bVislManagerTheme;
		m_nMaxDescrWidth    = src.m_nMaxDescrWidth;
		m_nGradientAngle    = src.m_nGradientAngle;
		m_clrFill           = src.m_clrFill;
		m_clrFillGradient   = src.m_clrFillGradient;
		m_clrText           = src.m_clrText;
		m_clrBorder         = src.m_clrBorder;

		return *this;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMFCToolTipCtrl window

class CMFCToolTipCtrl : public CToolTipCtrl
{
	DECLARE_DYNCREATE(CMFCToolTipCtrl)

// Construction
public:
	CMFCToolTipCtrl(CMFCToolTipInfo* pParams = NULL);

// Attributes
public:
	void SetFixedWidth(int nWidthRegular, int nWidthLargeImage)
	{
		m_nFixedWidthRegular = nWidthRegular;
		m_nFixedWidthWithImage = nWidthLargeImage;
	}

protected:
	CMFCToolBar* m_pToolBar;
	CMFCToolBarImages* m_pToolBarImages;
	CMFCToolBarButton* m_pHotButton;
	CMFCRibbonButton*  m_pRibbonButton;
	CMFCToolTipInfo  m_Params;

	int     m_nRibbonImageType;
	CString m_strDescription;
	CSize   m_sizeImage;
	CPoint  m_ptMargin;
	CPoint  m_ptLocation;

	int	m_nFixedWidthRegular;
	int	m_nFixedWidthWithImage;

// Operations
public:
	void SetParams(CMFCToolTipInfo* pParams); // NULL - default params
	const CMFCToolTipInfo& GetParams() const { return m_Params; }

	void SetLocation(CPoint pt);
	void SetHotRibbonButton(CMFCRibbonButton* pRibbonButton);

// Overrides
	virtual void SetDescription(const CString strDescription);

	virtual CSize GetIconSize();
	virtual void OnFillBackground(CDC* pDC, CRect rect, COLORREF& clrText, COLORREF& clrLine);

	virtual void OnDrawBorder(CDC* pDC, CRect rect, COLORREF clrLine);
	virtual BOOL OnDrawIcon(CDC* pDC, CRect rectImage);
	virtual CSize OnDrawLabel(CDC* pDC, CRect rect, BOOL bCalcOnly);
	virtual CSize OnDrawDescription(CDC* pDC, CRect rect, BOOL bCalcOnly);
	virtual void OnDrawSeparator(CDC* pDC, int x1, int x2, int y);

// Implementation
public:
	virtual ~CMFCToolTipCtrl();

protected:
	//{{AFX_MSG(CMFCToolTipCtrl)
	afx_msg void OnPaint();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnShow(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnPop(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetHotButton();
	int GetFixedWidth ();
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxver_.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxver_.h - target version/configuration control

#pragma once

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _AFX     1      // Microsoft Application Framework Classes
#ifndef _MFC_VER
#define _MFC_VER 0x0A00 // Microsoft Foundation Classes version 10.00
#endif

#ifndef _MFC_FILENAME_VER
#define _MFC_FILENAME_VER "100"
#endif

/////////////////////////////////////////////////////////////////////////////
// turn off reference tracking for certain often used symbols

#ifndef _AFX_PORTABLE
#pragma component(browser, off, references, "ASSERT")
#pragma component(browser, off, references, "AfxAssertFailedLine")
#pragma component(browser, off, references, "AfxDebugBreak")
#pragma component(browser, off, references, "BOOL")
#pragma component(browser, off, references, "BYTE")
#pragma component(browser, off, references, "DECLSPEC_IMPORT")
#pragma component(browser, off, references, "DWORD")
#pragma component(browser, off, references, "FALSE")
#pragma component(browser, off, references, "FAR")
#pragma component(browser, off, references, "LPSTR")
#pragma component(browser, off, references, "LPTSTR")
#pragma component(browser, off, references, "LPCSTR")
#pragma component(browser, off, references, "LPCTSTR")
#pragma component(browser, off, references, "NULL")
#pragma component(browser, off, references, "PASCAL")
#pragma component(browser, off, references, "THIS_FILE")
#pragma component(browser, off, references, "TRUE")
#pragma component(browser, off, references, "UINT")
#pragma component(browser, off, references, "WINAPI")
#pragma component(browser, off, references, "WORD")
#endif  //!_AFX_PORTABLE

/////////////////////////////////////////////////////////////////////////////
// For target version (one of)
//   _CUSTOM   : for custom configurations (causes afxv_cfg.h to be included)
//
// Additional build options:
//  _DEBUG              debug versions (full diagnostics)
//  _AFXDLL             use shared MFC DLL
//  _AFXEXT             extension DLL version, implies _AFXDLL
//  _USRDLL             create regular DLL (_AFXDLL is valid too)
//

#ifndef _DEBUG
#ifndef _AFX_DISABLE_INLINES
	#define _AFX_ENABLE_INLINES
#endif
#endif

#define _AFX_NO_NESTED_DERIVATION

/////////////////////////////////////////////////////////////////////////////
// Special configurations

// _AFXEXT implies _AFXDLL
#if defined(_AFXEXT) && !defined(_AFXDLL)
	#define _AFXDLL
#endif

#if defined(_AFXDLL) && !defined(_DLL)
	#error Please use the /MD switch for _AFXDLL builds
#endif

/////////////////////////////////////////////////////////////////////////////
// special include files

#ifndef AFX_INLINE
	#define AFX_INLINE inline /*__forceinline*/
#endif

#include <afxv_w32.h>

// Include any non-Intel platform specific items
#ifndef _M_IX86
	#include <afxv_cpu.h>
#endif

#ifdef _M_IX86
	#define _AFX_MINREBUILD
#endif

#ifdef _CUSTOM
// Put any custom configuration items in afxv_cfg.h
	#include <afxv_cfg.h>
#endif

// setup default packing value
#ifndef _AFX_PACKING
	#define _AFX_PACKING    4   // default packs structs at 4 bytes
#endif

#ifdef _AFXDLL
	#include <afxv_dll.h>
#endif

// Define this virtual key for use by status bar
#ifndef VK_KANA
#define VK_KANA             0x15
#endif

/////////////////////////////////////////////////////////////////////////////
// Special AfxDebugBreak: used to break into debugger at critical times

#ifndef AfxDebugBreak
#define AfxDebugBreak() __debugbreak()
#endif

#ifndef _DEBUG
#ifdef AfxDebugBreak
#undef AfxDebugBreak
#endif
#define AfxDebugBreak()
#endif  // _DEBUG

/////////////////////////////////////////////////////////////////////////////
// Standard preprocessor symbols if not already defined
/////////////////////////////////////////////////////////////////////////////

// SIZE_T_MAX is used by the collection classes
#ifndef SIZE_T_MAX
	#define SIZE_T_MAX  UINT_MAX
#endif

// PASCAL is used for static member functions
#ifndef PASCAL
	#define PASCAL  __stdcall
#endif

// FASTCALL is used for static member functions with little or no params
#ifndef FASTCALL
	#define FASTCALL __fastcall     
#endif

// CDECL and EXPORT are defined in case WINDOWS.H doesn't
#ifndef CDECL
	#define CDECL __cdecl
#endif

#ifndef EXPORT
	#define EXPORT
#endif

// UNALIGNED is used for unaligned data access (in CArchive mostly)
#if !defined(UNALIGNED)
#if defined(_M_AMD64)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

// AFX_DEPRECATED is used for functions that should no longer be used
#ifndef AFX_DEPRECATED
#ifdef _AFX_DISABLE_DEPRECATED
	#define AFX_DEPRECATED(_Message) 
#else
	#define AFX_DEPRECATED(_Message) __declspec(deprecated(_Message))
#endif 
#endif

/* 
 * Why are these ANSI functions now deprecated?
 * 
 * AFX_ANSI_DEPRECATED is used to bring MFC into line with what messages and 
 * modes Windows supports for its controls.
 * 
 * Historically, all core controls could be created ANSI (CreateWindowA) or 
 * UNICODE (CreateWindowW). /DUNICODE builds of MFC used CreateWindowW and 
 * hence got UNICODE controls. But the set of functions and messages available 
 * for the controls wasnt different between the two modes.
 * 
 * [Side note: There are some exceptions to this rule, both in MFC and Win32].
 * 
 * Windows XP came along and added comctrl version 6, which was not intended 
 * to be binary or behaviour compatible with previous versions. One of these 
 * incompatibilities was that the new controls are UNICODE from the ground up 
 * and do not support ANSI mode. These controls also have the new (at the time)
 * Windows XP "themed" look and feel applied to them, which made them very 
 * appealing to developers who wanted their apps to look up to date
 * 
 * To ensure that the new controls didnt break existing apps, you have to opt 
 * in to using comctrl version 6 (via a dependency entry in your Win32 XML 
 * manifest). 
 * 
 * Unfortunately, even though these controls are not supported or documented 
 * to work in ANSI mode, they do have some limited functionality in ANSI mode 
 * (to support various complicated compatibility scenarios where controls are 
 * mixed in a process by addins). 
 * 
 * As a result, after Windows XP shipped, some people took existing ANSI apps 
 * (that call CreateWindowA) and applied XML manifests to them. This should 
 * not have worked (and is not documented to work), but sometimes does 
 * actually work. 
 * 
 * To further muddy the waters, VC7.0 applied the manifest indiscriminately 
 * to all newly-created MFC apps (even ANSI ones), furthering the impression 
 * that ANSI apps could use the themed controls. This was the source of quite 
 * a few bugs in VC7.0. VC7.1 fixed this problem -- the manifest was only 
 * applied to newly created projects when compiled Unicode (via a #ifdef in 
 * the .rc file), and VC8 made it a bit simpler by using the new manifest 
 * generation scheme.
 * 
 * Another mistake we made in VC7 was to provide wrappers for the new 
 * controls new messages that were available in ANSI builds. This again 
 * allowed you to call some of these new methods on ANSI controls even though 
 * several of them wouldnt even work.
 * 
 * In VC9 we are fixing this issue and bringing our projects and wrappers into 
 * line with the supported OS behaviour for Windows XP and Windows Vista. 
 * 
 * Messages and functions that are only supposed to work on UNICODE controls 
 * are now only available on UNICODE controls. You will see a deprecation 
 * message if you use one of these unsupported messages. If you want to use 
 * the new control features that have been added since Windows XP, youll need 
 * to compile your MFC-based project as UNICODE, and set appropriate values 
 * for the OS minimum version control macros (_WIN32_WINNT, _WIN32_IE, 
 * _NTDDI_VERSION, etc).
 * 
 */
#ifndef AFX_ANSI_DEPRECATED
#ifdef UNICODE
	#define AFX_ANSI_DEPRECATED
#else
	#define AFX_ANSI_DEPRECATED AFX_DEPRECATED( \
			"This MFC feature requires /DUNICODE to work correctly, because the underlying Windows control is only supported for UNICODE builds. " \
			"Previous versions of MFC incorrectly enabled this in ANSI/MBCS builds. " \
			"Please compile with /DUNICODE to use this feature. See product documentation for more information." \
			)
#endif
#endif


#if defined(_AFX_SECURE_NO_DEPRECATE) && !defined(_AFX_SECURE_NO_WARNINGS)
#define _AFX_SECURE_NO_WARNINGS
#endif

// _AFX_INSECURE_DEPRECATE is used for deprecated, insecure functions.
#ifndef _AFX_INSECURE_DEPRECATE
#ifdef _AFX_SECURE_NO_WARNINGS
#define _AFX_INSECURE_DEPRECATE(_Message)
#else
#define _AFX_INSECURE_DEPRECATE(_Message) __declspec(deprecated(_Message))
#endif // _AFX_SECURE_NO_WARNINGS
#endif // _AFX_INSECURE_DEPRECATE

// AFXAPI is used on global public functions
#ifndef AFXAPI
	#define AFXAPI __stdcall
#endif

// AFXOLEAPI is used for some special OLE functions
#ifndef AFXOLEAPI
	#define AFXOLEAPI __stdcall
#endif

// AFX_CDECL is used for rare functions taking variable arguments
#ifndef AFX_CDECL
	#define AFX_CDECL __cdecl
#endif

// AFX_EXPORT is used for functions which need to be exported
#ifndef AFX_EXPORT
	#define AFX_EXPORT EXPORT
#endif

#ifndef AFX_STATIC
	#define AFX_STATIC extern
	#define AFX_STATIC_DATA extern __declspec(selectany)
#endif

// The following macros are used to enable export/import
// for data
#ifndef AFX_DATA_EXPORT
	#define AFX_DATA_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_DATA_IMPORT
	#define AFX_DATA_IMPORT __declspec(dllimport)
#endif

#if !defined(_MFC_BLD) && defined(_AFXDLL)
	#define AFX_IMPORT_DATA __declspec(dllimport)
#else
	#define AFX_IMPORT_DATA
#endif

// for classes
#ifndef AFX_CLASS_EXPORT
	#define AFX_CLASS_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_CLASS_IMPORT
	#define AFX_CLASS_IMPORT __declspec(dllimport)
#endif

// for global APIs
#ifndef AFX_API_EXPORT
	#define AFX_API_EXPORT __declspec(dllexport)
#endif
#ifndef AFX_API_IMPORT
	#define AFX_API_IMPORT __declspec(dllimport)
#endif

// This macro is used to reduce size requirements of some classes
#ifndef AFX_ALWAYS_VTABLE
#ifndef AFX_NOVTABLE
#if !defined(_DEBUG)
#define AFX_NOVTABLE __declspec(novtable)
#else
#define AFX_NOVTABLE
#endif
#endif
#endif

// for global data that should be in COMDATs (packaged data)
#ifndef AFX_COMDAT
#define AFX_COMDAT __declspec(selectany)
#endif

// The following macros are used on data declarations/definitions
//  (they are redefined for extension DLLs and the shared MFC DLL)
#define AFX_DATA
#define AFX_DATADEF
#define AFX_API

// used when building the "core" MFCXX.DLL
#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA
	#define AFX_CORE_DATADEF
#endif

// used when building the MFC/OLE support MFCOXX.DLL
#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA
	#define AFX_OLE_DATADEF
#endif

// used when building the MFC/DB support MFCDXX.DLL
#ifndef AFX_DB_DATA
	#define AFX_DB_DATA
	#define AFX_DB_DATADEF
#endif

// used when building the MFC/NET support MFCNXX.DLL
#ifndef AFX_NET_DATA
	#define AFX_NET_DATA
	#define AFX_NET_DATADEF
#endif

// used when building extension DLLs
#ifndef AFX_EXT_DATA
	#define AFX_EXT_DATA
	#define AFX_EXT_DATADEF
	#define AFX_EXT_CLASS
	#define AFX_EXT_API
#endif

// BASED_XXXX macros are provided for backward compatibility
#ifndef BASED_CODE
	#define BASED_CODE
#endif

#ifndef BASED_DEBUG
	#define BASED_DEBUG
#endif

#ifndef BASED_STACK
	#define BASED_STACK
#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxusertoolsmanager.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxusertool.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CUserToolsManager : public CObject
{
public:
	//--------------
	// Construction:
	//--------------
	CUserToolsManager();
	CUserToolsManager(	const UINT uiCmdToolsDummy, const UINT uiCmdFirst, const UINT uiCmdLast,
		CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool), UINT uArgMenuID = 0, UINT uInitDirMenuID = 0);
	virtual ~CUserToolsManager();

	//------------
	// Operations:
	//------------
	BOOL LoadState(LPCTSTR lpszProfileName = NULL);
	BOOL SaveState(LPCTSTR lpszProfileName = NULL);

	CUserTool* CreateNewTool();
	BOOL RemoveTool(CUserTool* pTool);
	
	BOOL MoveToolUp(CUserTool* pTool);
	BOOL MoveToolDown(CUserTool* pTool);

	BOOL IsUserToolCmd(UINT uiCmdId) const { return uiCmdId >= m_uiCmdFirst && uiCmdId <= m_uiCmdLast; }
	UINT GetToolsEntryCmd() const { return m_uiCmdToolsDummy; }

	BOOL InvokeTool(UINT uiCmdId);
	CUserTool* FindTool(UINT uiCmdId) const;

	//------------
	// Attributes:
	//------------
public:
	const CObList& GetUserTools() const { return m_lstUserTools; }
	int GetMaxTools() const { return m_uiCmdLast - m_uiCmdFirst + 1; }

	void SetFilter(const CString& strFilter) { m_strFilter = strFilter; }
	const CString& GetFilter() const { return m_strFilter; }

	void SetDefExt(const CString& strDefExt) { m_strDefExt = strDefExt; }
	const CString& GetDefExt() const { return m_strDefExt; }

	UINT GetArgumentsMenuID() const { return m_uiArgumentsMenuID; }
	UINT GetInitialDirMenuID() const { return m_uiInitialDirMenuID; }

protected:
	CObList             m_lstUserTools;       // List of CUserTool-derived objects
	const UINT          m_uiCmdToolsDummy;    // Will be replaced by the tools list
	const UINT          m_uiCmdFirst;         // First user tool command
	const UINT          m_uiCmdLast;          // Last user tool command
	CRuntimeClass*      m_pToolRTC;           // User tool run-time class
	CString             m_strFilter;          // "Add tool" file dilaog filter
	CString             m_strDefExt;          // Default tool file extension
	const UINT          m_uiArgumentsMenuID;  // ID for arguments popup option menu
	const UINT          m_uiInitialDirMenuID; // ID for initial dir popup option menu
};

extern AFX_IMPORT_DATA CUserToolsManager* afxUserToolsManager;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanagerofficexp.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxvisualmanager.h"
#include "afxmenuimages.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCStatusBar;
class CBasePane;

class CMFCVisualManagerOfficeXP : public CMFCVisualManager
{
	DECLARE_DYNCREATE(CMFCVisualManagerOfficeXP)

protected:
	CMFCVisualManagerOfficeXP(BOOL bIsTemporary = FALSE);

public:
	virtual ~CMFCVisualManagerOfficeXP();

protected:
	virtual void OnUpdateSystemColors();

	virtual void OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar);
	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect);
	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnDrawMenuShadow(CDC* pDC, const CRect& rectClient, const CRect& rectExclude, int nDepth,
		int iMinBrightness, int iMaxBrightness, CBitmap* pBmpSaveBottom,  CBitmap* pBmpSaveRight, BOOL bRTL);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);
	virtual COLORREF OnDrawMenuLabel(CDC* pDC, CRect rect);
	
	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnHighlightMenuItem(CDC*pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual COLORREF GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);
	virtual void OnHighlightQuickCustomizeMenuButton(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect);
	virtual BOOL IsHighlightWholeMenuItem() { return TRUE; }

	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);

	virtual void OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab);

	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);

	virtual void OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID = -1);
	virtual void OnDrawCaptionButtonIcon(CDC* pDC, CMFCCaptionButton* pButton, CMenuImages::IMAGES_IDS id, BOOL bActive, BOOL bDisabled, CPoint ptImage);

	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton);

	virtual COLORREF GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive);
	virtual void OnDrawMenuResizeBar(CDC* pDC, CRect rect, int nResizeFlags);
	virtual void OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawSpinButtons(CDC* pDC, CRect rectSpin, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* pSpinCtrl);

	virtual COLORREF OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected = FALSE);
	virtual void OnDrawMenuArrowOnCustomizeList(CDC* pDC, CRect rectCommand, BOOL bSelected);

	virtual void OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight);
	virtual void OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle);

	virtual int GetMenuImageMargin() const { return 3; }
	virtual int GetPopupMenuGap() const { return 0; }

	virtual void OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz);

	virtual COLORREF OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive);
	virtual void OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize);
	virtual void OnDrawFloatingToolbarBorder(CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize);

	virtual COLORREF GetToolbarHighlightColor() { return m_clrHighlight; }

	virtual COLORREF OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, BOOL bIsPressed,
		BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton);
	virtual void OnDrawCaptionBarButtonBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, BOOL bIsPressed,
		BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton);
	virtual void OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* pBar, CRect rect);

	virtual COLORREF GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList);
	virtual COLORREF GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList);

	// Tasks pane:
	virtual void OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);

	virtual void OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial = FALSE);
	virtual void OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial = FALSE, BOOL bNoTitle = FALSE);
	virtual void OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE);
	virtual void OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited);

	virtual void OnDrawSplitterBorder(CDC* pDC, CSplitterWndEx* pSplitterWnd, CRect rect);
	virtual void OnDrawSplitterBox(CDC* pDC, CSplitterWndEx* pSplitterWnd, CRect& rect);

	// Edit box:
	virtual BOOL OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* pEdit, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& clrText);

	virtual COLORREF GetAutoHideButtonTextColor(CMFCAutoHideButton* pButton);

	virtual void GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder);

	virtual COLORREF OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* pParent, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected);

	// Popup window:
	virtual void OnDrawPopupWindowBorder(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd);
	virtual void OnErasePopupWindowButton(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual void OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual void OnFillPopupWindowBackground(CDC* pDC, CRect rect);

	// Ribbon control:
	virtual COLORREF OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonCategoryScroll(CDC* pDC, CRibbonCategoryScroll* pScroll);
	virtual void OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect);
	virtual void OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual void OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual COLORREF OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane);

	virtual void GetRibbonSliderColors(CMFCRibbonSlider* pSlider, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled, COLORREF& clrLine, COLORREF& clrFill);
	virtual void OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* pSeparator, CRect rect);

	virtual void OnDrawRibbonColorPaletteBox(CDC* pDC, CMFCRibbonColorButton* pColorButton, CMFCRibbonGalleryIcon* pIcon,
		COLORREF color, CRect rect, BOOL bDrawTopEdge, BOOL bDrawBottomEdge, BOOL bIsHighlighted, BOOL bIsChecked, BOOL bIsDisabled);


	COLORREF m_clrBarBkgnd;            // Control bar background color (expect menu bar)
	COLORREF m_clrMenuRarelyUsed;
	COLORREF m_clrMenuLight;           // Color of the light menu area
	COLORREF m_clrInactiveTabText;
	COLORREF m_clrHighlight;           // Highlighted toolbar/menu item color
	COLORREF m_clrHighlightDn;         // Highlighted and pressed toolbar item color
	COLORREF m_clrHighlightChecked;
	COLORREF m_clrPressedButtonBorder; // Used in derived classes
	COLORREF m_clrGripper;
	COLORREF m_clrSeparator;
	COLORREF m_clrPaneBorder;          // Status bar pane border
	COLORREF m_clrMenuBorder;          // Menu border
	COLORREF m_clrMenuItemBorder;      // Highlighted menu item border

	CBrush m_brGripperHorz;
	CBrush m_brGripperVert;
	CBrush m_brBarBkgnd;
	CBrush m_brMenuRarelyUsed;
	CBrush m_brMenuLight;
	CBrush m_brTabBack;
	CBrush m_brHighlight;
	CBrush m_brHighlightDn;
	CBrush m_brHighlightChecked;
	CBrush m_brFloatToolBarBorder;     // Floating toolbar border

	CPen m_penSeparator;
	CPen m_penMenuItemBorder;

	BOOL m_bConnectMenuToParent;
	BOOL m_bShdowDroppedDownMenuButton;
	BOOL m_bDrawLastTabLine;

	virtual void CreateGripperBrush();
	virtual void ExtendMenuButton(CMFCToolBarMenuButton* pMenuButton, CRect& rect);
	virtual COLORREF GetWindowColor() const;
	virtual void OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton);
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanager.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CBasePane;
class CMFCPopupMenu;
class CMFCBaseToolBar;
class CMFCToolBar;
class CMFCToolBarButton;
class CMFCToolBarMenuButton;
class CMFCCaptionButton;
class CMFCCaptionMenuButton;
class CMFCBaseTabCtrl;
class CMFCToolBarComboBoxButton;
class CMFCStatusBar;
class CMFCStatusBarPaneInfo;
class CMFCButton;
class CPaneFrameWnd;
class CMFCCaptionBar;
class CMFCHeaderCtrl;
class CMFCToolBarEditBoxButton;
class CDockablePane;
class CMFCTasksPaneTask;
class CMFCTasksPaneTaskGroup;
class CPaneDivider;
class CSplitterWndEx;
class CMFCAutoHideButton;
class CMFCEditBrowseCtrl;
class CMFCSpinButtonCtrl;
class CMFCDesktopAlertWnd;
class CMFCDesktopAlertWndButton;
class CMFCPropertyGridCtrl;
class CMFCRibbonBar;
class CMFCRibbonCategory;
class CMFCRibbonPanel;
class CMFCRibbonButton;
class CMFCRibbonTab;
class CMFCRibbonCaptionButton;
class CMFCRibbonButtonsGroup;
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
class CMFCRibbonLaunchButton;
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
class CMFCRibbonRichEditCtrl;
class CMFCRibbonMainPanel;
class CMFCRibbonLabel;
class CMFCRibbonGallery;
class CMFCRibbonGalleryIcon;
class CMFCRibbonContextCaption;
class CMFCToolTipInfo;
enum AFX_RibbonCategoryColor;
class CMFCRibbonStatusBar;
class CMFCRibbonStatusBarPane;
class CMFCRibbonSlider;
class CMFCRibbonProgressBar;
class CMFCRibbonPanelMenuBar;
class CMFCRibbonPanelMenu;
class CMFCRibbonSeparator;
class CMFCRibbonBaseElement;
class CMFCPropertySheet;
class CMFCRibbonCheckBox;
class CMFCRibbonLinkCtrl;
class CMFCRibbonColorButton;
class CRibbonCategoryScroll;

#define	AFX_SPIN_PRESSEDUP       0x0001
#define	AFX_SPIN_PRESSEDDOWN     0x0002
#define	AFX_SPIN_HIGHLIGHTEDUP   0x0004
#define	AFX_SPIN_HIGHLIGHTEDDOWN 0x0008
#define	AFX_SPIN_DISABLED        0x0010

#ifndef _UXTHEME_H_

// From uxtheme.h:
typedef HANDLE HTHEME;          // handle to a section of theme data for class

#endif // THEMEAPI

typedef HTHEME (__stdcall * OPENTHEMEDATA)(HWND hwnd, LPCWSTR pszClassList);
typedef HRESULT (__stdcall * CLOSETHEMEDATA)(HTHEME hTheme);
typedef HRESULT (__stdcall * DRAWTHEMEBACKGROUND)(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);
typedef HRESULT (__stdcall * GETTHEMECOLOR)(HTHEME hTheme, int iPartId, int iStateId, int iPropId, OUT COLORREF *pColor);
typedef COLORREF (__stdcall * GETTHEMESYSCOLOR)(HTHEME hTheme, int iColorId);

typedef HRESULT (__stdcall * GETCURRENTTHEMENAME)(OUT LPWSTR pszThemeFileName, int cchMaxNameChars, OUT OPTIONAL LPWSTR pszColorBuff,
	int cchMaxColorChars, OUT OPTIONAL LPWSTR pszSizeBuff, int cchMaxSizeChars);

typedef HTHEME (__stdcall * GETWINDOWTHEME)(HWND hWnd);

class CMFCBaseVisualManager : public CObject
{
public:
	CMFCBaseVisualManager();
	virtual ~CMFCBaseVisualManager();

	enum WinXpTheme
	{
		WinXpTheme_None = -1,
		WinXpTheme_NonStandard,
		WinXpTheme_Blue,
		WinXpTheme_Olive,
		WinXpTheme_Silver
	};

	virtual BOOL DrawPushButton(CDC* pDC, CRect rect, CMFCButton* pButton, UINT uiState);

	virtual BOOL DrawStatusBarProgress(CDC* pDC, CMFCStatusBar* pStatusBar, CRect rectProgress, int nProgressTotal, int nProgressCurr,
		COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText);

	virtual BOOL DrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted);
	virtual BOOL DrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted);

	virtual void FillReBarPane(CDC* pDC, CBasePane* pBar, CRect rectClient);

	virtual BOOL DrawCheckBox(CDC *pDC, CRect rect, BOOL bHighlighted, int nState, BOOL bEnabled, BOOL bPressed);
	virtual BOOL DrawRadioButton(CDC *pDC, CRect rect, BOOL bHighlighted, BOOL bChecked, BOOL bEnabled, BOOL bPressed);

	virtual WinXpTheme GetStandardWindowsTheme();

protected:
	void UpdateSystemColors();
	void CleanUpThemes();

	HTHEME m_hThemeWindow;
	HTHEME m_hThemeToolBar;
	HTHEME m_hThemeRebar;
	HTHEME m_hThemeButton;
	HTHEME m_hThemeStatusBar;
	HTHEME m_hThemeComboBox;
	HTHEME m_hThemeProgress;
	HTHEME m_hThemeHeader;
	HTHEME m_hThemeScrollBar;
	HTHEME m_hThemeExplorerBar;
	HTHEME m_hThemeTree;
	HTHEME m_hThemeStartPanel;
	HTHEME m_hThemeTaskBand;
	HTHEME m_hThemeTaskBar;
	HTHEME m_hThemeSpin;
	HTHEME m_hThemeTab;
	HTHEME m_hThemeTrack;
	HTHEME m_hThemeMenu;

	HINSTANCE           m_hinstUXDLL;
	OPENTHEMEDATA       m_pfOpenThemeData;
	CLOSETHEMEDATA      m_pfCloseThemeData;
	DRAWTHEMEBACKGROUND m_pfDrawThemeBackground;
	GETTHEMECOLOR       m_pfGetThemeColor;
	GETTHEMESYSCOLOR    m_pfGetThemeSysColor;
	GETCURRENTTHEMENAME m_pfGetCurrentThemeName;
	GETWINDOWTHEME      m_pfGetWindowTheme;
};

class CMFCVisualManager : public CMFCBaseVisualManager
{
	friend struct AFX_GLOBAL_DATA;

	DECLARE_DYNCREATE(CMFCVisualManager)

public:
	CMFCVisualManager(BOOL bTemporary = FALSE);
	virtual ~CMFCVisualManager();

	static void __stdcall SetDefaultManager(CRuntimeClass* pRTI);

	virtual BOOL IsWindowsThemingSupported() const { return FALSE; }
	static void __stdcall DestroyInstance(BOOL bAutoDestroyOnly = FALSE);

// Operations:
public:
	static void __stdcall RedrawAll();
	static void __stdcall AdjustToolbars();
	static void __stdcall AdjustFrames();

// Overrides:
public:
	virtual void OnUpdateSystemColors();

	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect);
	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnDrawMenuShadow(CDC* pDC, const CRect& rectClient, const CRect& rectExclude, int nDepth,
		int iMinBrightness, int iMaxBrightness, CBitmap* pBmpSaveBottom, CBitmap* pBmpSaveRight, BOOL bRTL);
	virtual void OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);
	virtual COLORREF OnDrawMenuLabel(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);
	virtual void OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID = -1);
	virtual void OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight);
	virtual void OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle);
	virtual COLORREF GetStatusBarPaneTextColor(CMFCStatusBar* pStatusBar, CMFCStatusBarPaneInfo* pPane);

	virtual void OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* /*pStatusBar*/, CRect rectProgress, int nProgressTotal,
		int nProgressCurr, COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText);
	virtual void OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox);

	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton);
	virtual void OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive);

	virtual void OnDrawMenuResizeBar(CDC* pDC, CRect rect, int nResizeFlags);
	virtual void OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL bIsPressed, BOOL bIsDisabled);

	enum AFX_BUTTON_STATE
	{
		ButtonsIsRegular,
		ButtonsIsPressed,
		ButtonsIsHighlighted,
	};

	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz);

	virtual void OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual COLORREF GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton);
	virtual BOOL IsHighlightWholeMenuItem() { return FALSE; }
	
	virtual COLORREF GetMenuItemTextColor(CMFCToolBarMenuButton* pButton, BOOL bHighlighted, BOOL bDisabled);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);

	virtual void OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, BOOL bHighlight, BOOL bIsRadio);
	virtual void OnDrawMenuItemButton(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rectButton, BOOL bHighlight, BOOL bDisabled);

	virtual void OnFillMenuImageRect(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state) { OnFillButtonInterior(pDC, pButton, rect, state); }

	virtual BOOL IsOwnerDrawMenuCheck() { return FALSE; }

	virtual COLORREF GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual COLORREF GetToolbarDisabledColor() const { return (COLORREF)-1; }

	virtual BOOL IsToolbarRoundShape(CMFCToolBar* /*pToolBar*/) { return FALSE; }

	virtual COLORREF GetToolbarHighlightColor();
	virtual COLORREF GetToolbarDisabledTextColor();

	virtual int GetDockingPaneCaptionExtraHeight() const { return 0; }

	// Caption bar:
	virtual COLORREF GetCaptionBarTextColor(CMFCCaptionBar* pBar);
	virtual void OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* pBar, CRect rect);
	virtual void OnDrawCaptionBarBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, COLORREF clrBarBorder, BOOL bFlatBorder);
	virtual COLORREF OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, BOOL bIsPressed,
		BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton);
	virtual void OnDrawCaptionBarButtonBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, BOOL bIsPressed,
		BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton);

	// Outlook bar:
	virtual void OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText);
	virtual void OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed);
	virtual void OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter);
	virtual void OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText);

	// Tab overrides:
	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTabContent(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd, COLORREF clrText);
	virtual void OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab);
	virtual void GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
		COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack);
	virtual BOOL OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual BOOL IsHighlightOneNoteTabs() const { return FALSE; }
	virtual BOOL AlwaysHighlight3DTabs() const { return FALSE; }
	virtual COLORREF GetTabTextColor(const CMFCBaseTabCtrl* /*pTabWnd*/, int /*iTab*/, BOOL /*bIsActive*/) { return (COLORREF)-1; }
	virtual int GetTabHorzMargin(const CMFCBaseTabCtrl* /*pTabWnd*/) { return 0; }
	virtual void OnDrawTabResizeBar(CDC* pDC, CMFCBaseTabCtrl* pWndTab, BOOL bIsVert, CRect rect, CBrush* pbrFace, CPen* pPen);

	virtual int GetMDITabsBordersSize() { return -1; /* Default */ }
	virtual int GetDockingTabsBordersSize() { return -1; /* Default */ }
	virtual BOOL IsDockingTabHasBorder() { return TRUE; }

	// Customization dialog:
	virtual COLORREF OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected = FALSE);
	virtual void OnDrawMenuArrowOnCustomizeList(CDC* pDC, CRect rectCommand, BOOL bSelected);

	virtual CSize GetButtonExtraBorder() const { return CSize(0, 0); }
	virtual CSize GetCaptionButtonExtraBorder() const { return CSize(0, 0); }

	virtual COLORREF OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive);
	virtual void OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize);
	virtual void OnDrawFloatingToolbarBorder(	CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize);

	// Header control:
	virtual void OnFillHeaderCtrlBackground(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect rect);
	virtual void OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted);
	virtual void OnDrawHeaderCtrlSortArrow(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsUp);
	void DoDrawHeaderSortArrow(CDC* pDC, CRect rect, BOOL bIsUp, BOOL bDlgCtrl);

	virtual COLORREF OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* pParent, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected);

	// Tasks pane:
	virtual void OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea);

	virtual void OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);
	virtual void OnDrawTasksGroupIcon(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, int nIconHOffset = 5, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);

	virtual void OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial = FALSE);
	virtual void OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial = FALSE, BOOL bNoTitle = FALSE);
	virtual void OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE);

	virtual void OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited);
	virtual void OnDrawToolBoxFrame(CDC* pDC, const CRect& rect);

	// Slider
	virtual void OnDrawPaneDivider(CDC* pDC, CPaneDivider* pSlider, CRect rect, BOOL bAutoHideMode);

	// Property list:
	virtual void OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox);
	virtual COLORREF GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList);
	virtual COLORREF GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList);

	// Splitter:
	virtual void OnDrawSplitterBorder(CDC* pDC, CSplitterWndEx* pSplitterWnd, CRect rect);
	virtual void OnDrawSplitterBox(CDC* pDC, CSplitterWndEx* pSplitterWnd, CRect& rect);
	virtual void OnFillSplitterBackground(CDC* pDC, CSplitterWndEx* pSplitterWnd, CRect rect);

	virtual void OnDrawCheckBox(CDC *pDC, CRect rect, BOOL bHighlighted, BOOL bChecked,BOOL bEnabled);
	virtual void OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled);
	virtual void OnDrawControlBorder(CWnd* pWndCtrl);

	// Auto-hide buttons:
	virtual BOOL HasOverlappedAutoHideButtons() const { return FALSE; }

	virtual void OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* pButton);
	virtual void OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* pButton);
	virtual COLORREF GetAutoHideButtonTextColor(CMFCAutoHideButton* pButton);

	// Edit box:
	virtual BOOL OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* pEdit, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& clrText);

	// Spin control:
	virtual void OnDrawSpinButtons(CDC* pDC, CRect rectSpin, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* pSpinCtrl);

	// Windows XP drawing methods:
	virtual BOOL DrawPushButtonWinXP(CDC* /*pDC*/, CRect /*rect*/, CMFCButton* /*pButton*/, UINT /*uiState*/) { return FALSE; }
	virtual BOOL DrawComboDropButtonWinXP(CDC* /*pDC*/, CRect /*rect*/, BOOL /*bDisabled*/, BOOL /*bIsDropped*/, BOOL /*bIsHighlighted*/) { return FALSE; }
	virtual BOOL DrawComboBorderWinXP(CDC* /*pDC*/, CRect /*rect*/, BOOL /*bDisabled*/, BOOL /*bIsDropped*/, BOOL /*bIsHighlighted*/) { return FALSE; }

	// Smart docking marker colors:
	virtual void GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder);
	virtual COLORREF GetSmartDockingHighlightToneColor();
	virtual AFX_SMARTDOCK_THEME GetSmartDockingTheme() { return AFX_SDT_VS2005; }

	// Popup window:
	virtual void OnFillPopupWindowBackground(CDC* pDC, CRect rect);
	virtual void OnDrawPopupWindowBorder(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd);
	virtual void OnErasePopupWindowButton(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual void OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual BOOL IsDefaultWinXPPopupButton(CMFCDesktopAlertWndButton* /*pButton*/) const { return FALSE; }

	// Window apperance:
	virtual BOOL IsOwnerDrawCaption() { return FALSE; }
	virtual BOOL OnSetWindowRegion(CWnd* pWnd, CSize sizeWindow);
	virtual void OnActivateApp(CWnd* pWnd, BOOL bActive);
	virtual BOOL OnNcPaint(CWnd* pWnd, const CObList& lstSysButtons, CRect rectRedraw);
	virtual BOOL OnNcActivate(CWnd* pWnd, BOOL bActive);
	virtual CSize GetNcBtnSize(BOOL bSmall) const;

	// Ribbon control:
	virtual COLORREF OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* pWndRibbonBar, CRect rectTab);
	virtual void OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory);
	virtual COLORREF OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive);
	virtual void OnDrawRibbonCategoryScroll(CDC* pDC, CRibbonCategoryScroll* pScroll);
	virtual COLORREF OnDrawRibbonPanel(CDC* pDC,CMFCRibbonPanel* pPanel, CRect rectPanel, CRect rectCaption);
	virtual void OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	virtual void OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON
	virtual void OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonDefaultPaneButtonContext(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonDefaultPaneButtonIndicator(CDC* pDC, CMFCRibbonButton* pButton, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual COLORREF OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnFillRibbonEdit(CDC* pDC, CMFCRibbonRichEditCtrl* pEdit, CRect rect, BOOL bIsHighlighted,
		BOOL bIsPaneHighlighted, BOOL bIsDisabled, COLORREF& clrText, COLORREF& clrSelBackground, COLORREF& clrSelText);

	virtual void OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect);

	virtual COLORREF OnFillRibbonMainPanelButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnDrawRibbonMainPanelButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rect,CRect rectText);

	virtual int GetRibbonQuickAccessToolBarChevronOffset() { return 0; }
	virtual int GetRibbonQuickAccessToolBarRightMargin() { return 0; }
	virtual COLORREF GetRibbonQuickAccessToolBarTextColor(BOOL bDisabled = FALSE) { return bDisabled ? GetToolbarDisabledTextColor() : (COLORREF)-1; }

	virtual void OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton);
	virtual COLORREF OnDrawRibbonButtonsGroup(CDC* pDC, CMFCRibbonButtonsGroup* pGroup, CRect rectGroup);
	virtual void OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled = FALSE, BOOL bIsPressed = FALSE, BOOL bIsHighlighted = FALSE);
	virtual void OnDrawRibbonMainPanelFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);

	virtual void OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);

	virtual void OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual void OnDrawRibbonLabel(CDC* pDC, CMFCRibbonLabel* pLabel,CRect rect);
	virtual void OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton);
	virtual void OnDrawRibbonGalleryBorder(CDC* pDC, CMFCRibbonGallery* pButton, CRect rectBorder);

	virtual COLORREF RibbonCategoryColorToRGB(AFX_RibbonCategoryColor color);

	virtual COLORREF OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption);
	virtual COLORREF OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane);

	virtual void GetRibbonSliderColors(CMFCRibbonSlider* pSlider, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled, COLORREF& clrLine, COLORREF& clrFill);

	virtual void OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);

	virtual void OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect);
	virtual void OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode);

	virtual void OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar, CRect rect);

	virtual int GetRibbonPopupBorderSize(const CMFCRibbonPanelMenu* /*pPopup*/) const { return m_nMenuBorderSize; }

	virtual void OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* pSeparator, CRect rect);

	virtual BOOL IsLayeredRibbonKeyTip() const { return FALSE; }
	virtual void OnDrawRibbonKeyTip(CDC* pDC, CMFCRibbonBaseElement* pElement, CRect rect, CString str);

	virtual void OnDrawRibbonCheckBoxOnList(CDC* pDC, CMFCRibbonCheckBox* pCheckBox, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual COLORREF GetRibbonHyperlinkTextColor(CMFCRibbonLinkCtrl* pHyperLink);
	virtual COLORREF GetRibbonStatusBarTextColor(CMFCRibbonStatusBar* pStatusBar);

	virtual COLORREF GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* pEdit, BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled);

	virtual void OnDrawRibbonColorPaletteBox(CDC* pDC, CMFCRibbonColorButton* pColorButton, CMFCRibbonGalleryIcon* pIcon,
		COLORREF color, CRect rect, BOOL bDrawTopEdge, BOOL bDrawBottomEdge, BOOL bIsHighlighted, BOOL bIsChecked, BOOL bIsDisabled);

	const CPoint& GetRibbonMainImageOffset() const { return m_ptRibbonMainImageOffset; }

	// Vista support:
	virtual BOOL DrawTextOnGlass(CDC* pDC, CString strText, CRect rect, DWORD dwFlags, int nGlowSize = 0, COLORREF clrText = (COLORREF)-1);

	// MDI Client area
	virtual BOOL OnEraseMDIClientArea(CDC* pDC, CRect rectClient);

	// ToolTip
	virtual BOOL GetToolTipInfo(CMFCToolTipInfo& params, UINT nType = (UINT)(-1));

// Attributes:
public:

	void SetMenuShadowDepth(int nDepth) { m_nMenuShadowDepth = nDepth; }
	int GetMenuShadowDepth() const { return m_nMenuShadowDepth; }
	
	static CMFCVisualManager* __stdcall GetInstance()
	{
		if (m_pVisManager != NULL)
		{
			ASSERT_VALID(m_pVisManager);
			return m_pVisManager;
		}

		if (m_pRTIDefault == NULL)
		{
			m_pVisManager = new CMFCVisualManager;
		}
		else
		{
			m_pVisManager = (CMFCVisualManager*) m_pRTIDefault->CreateObject();
			ASSERT_VALID(m_pVisManager);
		}

		m_pVisManager->m_bAutoDestroy = TRUE;
		m_pVisManager->OnUpdateSystemColors();

		return m_pVisManager;
	}

	BOOL IsMenuFlatLook() const { return m_bMenuFlatLook; }
	void SetMenuFlatLook(BOOL bMenuFlatLook = TRUE)
	{
		m_bMenuFlatLook = bMenuFlatLook;
		RedrawAll();
	}

	BOOL IsAutoDestroy() const { return m_bAutoDestroy; }

	void SetShadowHighlightedImage(BOOL bShadow = TRUE) { m_bShadowHighlightedImage = bShadow; }
	BOOL IsShadowHighlightedImage() const { return m_bShadowHighlightedImage; }

	void EnableToolbarButtonFill(BOOL bEnable = TRUE) { m_bEnableToolbarButtonFill = bEnable; }
	BOOL IsToolbarButtonFillEnabled() const { return m_bEnableToolbarButtonFill; }

	BOOL IsEmbossDisabledImage() const { return m_bEmbossDisabledImage; }
	void SetEmbossDisabledImage(BOOL bEmboss = TRUE) { m_bEmbossDisabledImage = bEmboss; }

	BOOL IsFadeInactiveImage() const { return m_bFadeInactiveImage; }
	void SetFadeInactiveImage(BOOL bFade = TRUE) { m_bFadeInactiveImage = bFade; }

	virtual int GetMenuImageMargin() const { return 2; }
	virtual int GetPopupMenuGap() const { return 1; }
	virtual CRect GetMenuImageFrameOffset() const { return CRect (2, 1, 0, 2); }

	// TasksPane:
	int GetTasksPaneVertMargin() const { return m_nVertMargin; }
	int GetTasksPaneHorzMargin() const { return m_nHorzMargin; }
	int GetTasksPaneGroupVertOffset() const { return m_nGroupVertOffset; }
	int GetTasksPaneGroupCaptionHeight() const { return m_nGroupCaptionHeight; }

	int GetTasksPaneGroupCaptionHorzOffset() const { return m_nGroupCaptionHorzOffset; }
	int GetTasksPaneGroupCaptionVertOffset() const { return m_nGroupCaptionVertOffset; }

	int GetTasksPaneTaskHorzOffset() const { return m_nTasksHorzOffset; }

	int GetTasksPaneIconHorzOffset() const { return m_nTasksIconHorzOffset; }
	int GetTasksPaneIconVertOffset() const { return m_nTasksIconVertOffset; }

	virtual int GetToolBarCustomizeButtonMargin() const { return 2; }
	virtual BOOL IsOffsetPressedButton() const { return TRUE; }
	virtual BOOL IsOfficeXPStyleMenus() const { return m_bOfficeXPStyleMenus; }
	virtual int GetPopupMenuBorderSize() const { return m_nMenuBorderSize; }

	BOOL IsFrameMenuCheckedItems() const { return m_bFrameMenuCheckedItems; }

	// "Show all menu items" methods:
	virtual int GetShowAllMenuItemsHeight(CDC* pDC, const CSize& sizeDefault);
	virtual void OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

protected:
	static CMFCVisualManager* __stdcall CreateVisualManager(CRuntimeClass* pVisualManager);

// Attributes:
protected:
	AFX_IMPORT_DATA static CRuntimeClass*  m_pRTIDefault;
	AFX_IMPORT_DATA static CMFCVisualManager* m_pVisManager;

	BOOL m_bMenuFlatLook; // Menu item is always still unpressed
	BOOL m_bShadowHighlightedImage;
	BOOL m_bEmbossDisabledImage;
	BOOL m_bFadeInactiveImage;
	BOOL m_bEnableToolbarButtonFill;
	BOOL m_bFrameMenuCheckedItems;
	BOOL m_bIsTemporary;
	BOOL m_bActiveCaptions;
	BOOL m_bOfficeXPStyleMenus;
	BOOL m_bAlwaysFillTab;
	BOOL m_b3DTabWideBorder;

	int m_nMenuShadowDepth;
	int m_nVertMargin;
	int m_nHorzMargin;
	int m_nGroupVertOffset;
	int m_nGroupCaptionHeight;
	int m_nGroupCaptionHorzOffset;
	int m_nGroupCaptionVertOffset;
	int m_nTasksHorzOffset;
	int m_nTasksIconHorzOffset;
	int m_nTasksIconVertOffset;
	int m_nMenuBorderSize;

	COLORREF m_clrMenuShadowBase;

	CPoint m_ptRibbonMainImageOffset;

private:
	BOOL m_bAutoDestroy;
};

extern AFX_IMPORT_DATA UINT AFX_WM_CHANGEVISUALMANAGER;

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanagervs2005.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxvisualmanageroffice2003.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCVisualManagerVS2005 : public CMFCVisualManagerOffice2003
{
	DECLARE_DYNCREATE(CMFCVisualManagerVS2005)

public:
	CMFCVisualManagerVS2005();
	virtual ~CMFCVisualManagerVS2005();

	virtual void OnUpdateSystemColors();
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);
	virtual void OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID = -1);

	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);

	virtual BOOL HasOverlappedAutoHideButtons() const { return m_bRoundedAutohideButtons; }

	virtual void OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* pButton);
	virtual void OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* pButton);

	virtual void GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
		COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);
	virtual void OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton);

	virtual int GetMDITabsBordersSize() { return 1; }
	virtual int GetDockingTabsBordersSize();

	virtual COLORREF GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList);

	virtual void OnDrawToolBoxFrame(CDC* pDC, const CRect& rect);

	virtual COLORREF OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive);
	AFX_IMPORT_DATA static BOOL m_bRoundedAutohideButtons;

protected:
	int CreateAutoHideButtonRegion(CRect rect, DWORD dwAlignment, LPPOINT& points);

	COLORREF   m_colorActiveTabBorder;
	CPen       m_penActiveTabBorder;
	CBrush     m_brMenuButtonDroppedDown;
	CBrush     m_brMenuItemCheckedHighlight;
	WinXpTheme m_CurrAppTheme;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanagervs2008.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxvisualmanagervs2005.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCVisualManagerVS2008 : public CMFCVisualManagerVS2005
{
	DECLARE_DYNCREATE(CMFCVisualManagerVS2008)

public:
	CMFCVisualManagerVS2008();
	virtual ~CMFCVisualManagerVS2008();

	virtual void OnUpdateSystemColors();
	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);
	virtual void OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);

	virtual CRect GetMenuImageFrameOffset() const { return CRect(4, 2, 0, 2); }

	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	// Tabs support:
	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual BOOL OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);

	virtual int GetMDITabsBordersSize()			{	return 4;		}
	virtual BOOL IsMDITabsTopEdge()				{	return FALSE;	}
	virtual BOOL AlwaysHighlight3DTabs() const	{	return TRUE;	}

	virtual void GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack, COLORREF& clrHighlight,
		COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack);

	virtual void OnDrawTabResizeBar(CDC* pDC, CMFCBaseTabCtrl* pWndTab, BOOL bIsVert, CRect rect, CBrush* pbrFace, CPen* pPen);

	// Auto-hide buttons:
	virtual void OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* pButton);

	virtual COLORREF OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected = FALSE);

	virtual AFX_SMARTDOCK_THEME GetSmartDockingTheme();

protected:
	BOOL m_bOSColors;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanageroffice2007.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxvisualmanageroffice2003.h"
#include "afxtoolbarimages.h"
#include "afxcontrolrenderer.h"
#include "afxtooltipctrl.h"
#include "afxglobals.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_RIBBON_CATEGORY_COLOR_COUNT 7

class CMFCVisualManagerBitmapCache
{
public:
	class CMFCVisualManagerBitmapCacheItem
	{
	public:

		CMFCVisualManagerBitmapCacheItem();
		virtual ~CMFCVisualManagerBitmapCacheItem();

		void AddImage(HBITMAP hBmp);
		void Cache(const CSize& size, CMFCControlRenderer& renderer);

		void Draw(CDC* pDC, CRect rect, int iImageIndex = 0, BYTE alphaSrc = 255);
		void DrawY(CDC* pDC, CRect rect, CSize sides, int iImageIndex = 0, BYTE alphaSrc = 255);

	protected:
		CMFCToolBarImages m_Images;
		BOOL m_bMirror;
	};

	typedef CArray<CMFCVisualManagerBitmapCacheItem*, CMFCVisualManagerBitmapCacheItem*> XCache;
	typedef CArray<CSize, CSize> XSizes;

public:

	CMFCVisualManagerBitmapCache();
	virtual ~CMFCVisualManagerBitmapCache();

	void Clear();

	int Cache(const CSize& size, CMFCControlRenderer& renderer);
	int CacheY(int height, CMFCControlRenderer& renderer);
	BOOL IsCached(const CSize& size) const;

	int FindIndex(const CSize& size) const;

	CMFCVisualManagerBitmapCacheItem* Get(const CSize& size);
	CMFCVisualManagerBitmapCacheItem* Get(int nIndex);

protected:
	XCache m_Cache;
	XSizes m_Sizes;
};

class CMFCVisualManagerOffice2007 : public CMFCVisualManagerOffice2003
{
	DECLARE_DYNCREATE(CMFCVisualManagerOffice2007)

protected:
	CMFCVisualManagerOffice2007();
	virtual ~CMFCVisualManagerOffice2007();

public:
	enum Style
	{
		Office2007_LunaBlue,
		Office2007_ObsidianBlack,
		Office2007_Aqua,
		Office2007_Silver
	};

	static BOOL __stdcall SetStyle(Style style, LPCTSTR lpszPath = NULL);
	static Style __stdcall GetStyle();
	static void __stdcall SetResourceHandle(HINSTANCE hinstRes);
	static void __stdcall CleanStyle();

	virtual void OnUpdateSystemColors();

	BOOL IsRibbonPresent(CWnd* pWnd) const;
	CMFCRibbonBar*	GetRibbonBar(CWnd* pWnd) const;

	virtual BOOL IsOwnerDrawCaption() { return CanDrawImage() && !afxGlobalData.DwmIsCompositionEnabled(); }

	virtual BOOL OnNcActivate(CWnd* pWnd, BOOL bActive);
	virtual BOOL OnNcPaint(CWnd* pWnd, const CObList& lstSysButtons, CRect rectRedraw);
	virtual BOOL OnSetWindowRegion(CWnd* pWnd, CSize sizeWindow);

	virtual CSize GetNcBtnSize(BOOL bSmall) const;

public:
	virtual BOOL IsOwnerDrawMenuCheck();
	virtual BOOL IsHighlightWholeMenuItem();

	virtual COLORREF GetStatusBarPaneTextColor(CMFCStatusBar* pStatusBar, CMFCStatusBarPaneInfo* pPane);
	virtual COLORREF GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual COLORREF GetMenuItemTextColor(CMFCToolBarMenuButton* pButton, BOOL bHighlighted, BOOL bDisabled);
	virtual COLORREF GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton);

public:
	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton);
	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);
	virtual COLORREF OnDrawMenuLabel(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);
	virtual COLORREF OnFillCaptionBarButton(CDC* pDC, CMFCCaptionBar* pBar, CRect rect,
		BOOL bIsPressed, BOOL bIsHighlighted, BOOL bIsDisabled, BOOL bHasDropDownArrow, BOOL bIsSysButton);

	virtual int GetShowAllMenuItemsHeight(CDC* pDC, const CSize& sizeDefault);
	virtual void OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle);
	virtual void OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox);

	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton);
	virtual void OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive);
	virtual void OnDrawMenuResizeBar(CDC* pDC, CRect rect, int nResizeFlags);
	virtual void OnDrawMenuScrollButton(CDC* pDC, CRect rect, BOOL bIsScrollDown, BOOL bIsHighlited, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight);	

	virtual COLORREF OnDrawPropertySheetListItem(CDC* pDC, CMFCPropertySheet* pParent, CRect rect, BOOL bIsHighlihted, BOOL bIsSelected);

	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz);

	virtual void OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);
	virtual void OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, BOOL bHighlight, BOOL bIsRadio);
	
	virtual void OnDrawMenuItemButton(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rectButton, BOOL bHighlight, BOOL bDisabled);

	// MiniFrame:
	virtual COLORREF OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive);
	virtual void OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize);
	virtual void OnDrawFloatingToolbarBorder(	CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize);

	// tabs
	virtual void GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack,
		COLORREF& clrHighlight, COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack);
	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual BOOL OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual BOOL AlwaysHighlight3DTabs() const { return CanDrawImage() ? TRUE : CMFCVisualManagerOffice2003::AlwaysHighlight3DTabs(); }
	virtual COLORREF GetTabTextColor(const CMFCBaseTabCtrl* pTabWnd, int iTab, BOOL bIsActive);
	virtual int GetTabHorzMargin(const CMFCBaseTabCtrl* pTabWnd);

	virtual void OnDrawCaptionBarInfoArea(CDC* pDC, CMFCCaptionBar* pBar, CRect rect);
	virtual COLORREF GetCaptionBarTextColor(CMFCCaptionBar* pBar);
	
	// Outlook bar:
	virtual void OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText);
	virtual void OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed);
	virtual void OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter);
	virtual void OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText);

	virtual COLORREF GetToolbarDisabledTextColor()
	{
		return CanDrawImage() ? m_clrToolBarBtnTextDisabled : CMFCVisualManagerOffice2003::GetToolbarDisabledTextColor();
	}

	virtual void OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);
	virtual void OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE);
	virtual void OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize,int iImage, BOOL bHilited);
	virtual void OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted);
	virtual void OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed,BOOL bEnabled);
	
	// Ribbon control:
	virtual COLORREF OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* pWndRibbonBar, CRect rectTab);
	
	virtual void OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory);

	virtual COLORREF OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive);
	virtual COLORREF OnDrawRibbonPanel(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectPanel, CRect rectCaption);
	virtual void OnDrawRibbonCategoryScroll(CDC* pDC, CRibbonCategoryScroll* pScroll);

	virtual void OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	virtual void OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	virtual COLORREF OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnFillRibbonEdit(CDC* pDC, CMFCRibbonRichEditCtrl* pEdit, CRect rect,
		BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled, COLORREF& clrText, COLORREF& clrSelBackground, COLORREF& clrSelText);
	virtual void OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect);
	virtual void OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonDefaultPaneButtonIndicator(CDC* pDC, CMFCRibbonButton* pButton, CRect rect, BOOL bIsSelected, BOOL bHighlighted);
	virtual void OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rectCaption, CRect rectText);

	virtual int GetRibbonQuickAccessToolBarChevronOffset() { return IsBeta1() ? 0 : 13; }
	virtual int GetRibbonQuickAccessToolBarRightMargin();

	virtual COLORREF GetRibbonQuickAccessToolBarTextColor(BOOL bDisabled = FALSE) { return bDisabled ? m_clrRibbonCategoryTextDisabled : m_clrRibbonCategoryText; }

	virtual void OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton);

	virtual COLORREF OnDrawRibbonButtonsGroup(CDC* pDC, CMFCRibbonButtonsGroup* pGroup, CRect rectGroup);

	virtual void OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled = FALSE, BOOL bIsPressed = FALSE, BOOL bIsHighlighted = FALSE);
	virtual void OnDrawRibbonMainPanelFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual void OnFillRibbonMenuFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual void OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);

	virtual COLORREF OnFillRibbonMainPanelButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnDrawRibbonMainPanelButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual void OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton);
	virtual void OnDrawRibbonGalleryBorder(CDC* pDC, CMFCRibbonGallery* pButton, CRect rectBorder);

	virtual COLORREF OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption);
	virtual COLORREF OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane);
	
	virtual void OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect);
	virtual void OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode);
	virtual void OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar, CRect rect);

	virtual int GetRibbonPopupBorderSize(const CMFCRibbonPanelMenu* pPopup) const;
	virtual BOOL IsLayeredRibbonKeyTip() const { return CanDrawImage(); }

	virtual void OnDrawRibbonKeyTip(CDC* pDC, CMFCRibbonBaseElement* pElement, CRect rect, CString str);
	virtual void OnDrawRibbonCheckBoxOnList(CDC* pDC, CMFCRibbonCheckBox* pCheckBox, CRect rect, BOOL bIsSelected, BOOL bHighlighted);

	virtual COLORREF GetRibbonHyperlinkTextColor(CMFCRibbonLinkCtrl* pHyperLink);
	virtual COLORREF GetRibbonStatusBarTextColor(CMFCRibbonStatusBar* pStatusBar);

	virtual COLORREF GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* pEdit, BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled);

	virtual void OnFillPopupWindowBackground(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd);
	virtual BOOL OnEraseMDIClientArea(CDC* pDC, CRect rectClient);

	// ToolTip
	virtual BOOL GetToolTipInfo(CMFCToolTipInfo& params, UINT nType = (UINT)(-1));

	virtual AFX_SMARTDOCK_THEME GetSmartDockingTheme();

protected:
	BOOL CanDrawImage() const
	{
		return afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode() && m_bLoaded;
	}

	static CString __stdcall MakeResourceID(LPCTSTR lpszID);
	static CString __stdcall GetStyleResourceID(Style style);

	virtual void CleanUp();

	void DrawSeparator(CDC* pDC, const CRect& rect, BOOL bHorz);
	void DrawSeparator(CDC* pDC, const CRect& rect, CPen& pen1, CPen& pen2, BOOL bHorz);
	void DrawNcBtn(CDC* pDC, const CRect& rect, UINT nButton, AFX_BUTTON_STATE state, BOOL bSmall, BOOL bActive, BOOL bMDI = FALSE);
	void DrawNcText(CDC* pDC, CRect& rect, const CString& strTitle, const CString& strDocument, BOOL bPrefix,
		BOOL bActive, BOOL bIsRTL, BOOL bTextCenter, BOOL bGlass = FALSE, int nGlassGlowSize = 0, COLORREF clrGlassText = (COLORREF)-1);
	void DrawNcCaption(CDC* pDC, CRect rectCaption, DWORD dwStyle, DWORD dwStyleEx, const CString& strTitle,
		const CString& strDocument, HICON hIcon, BOOL bPrefix, BOOL bActive, BOOL bTextCenter, const CObList& lstSysButtons);

	BOOL m_bLoaded;
	BOOL m_bNcTextCenter;
	BOOL m_bPlannerBlack;
	BOOL m_bToolTipParams;

	CSize m_szNcBtnSize[2];

	CMFCToolBarImages m_ToolBarGripper;
	CMFCToolBarImages m_ToolBarTear;
	CMFCToolBarImages m_StatusBarPaneBorder;
	CMFCToolBarImages m_StatusBarSizeBox;
	CMFCToolBarImages m_SysBtnClose[2];
	CMFCToolBarImages m_SysBtnRestore[2];
	CMFCToolBarImages m_SysBtnMaximize[2];
	CMFCToolBarImages m_SysBtnMinimize[2];
	CMFCToolBarImages m_PopupResizeBar_HV;
	CMFCToolBarImages m_PopupResizeBar_HVT;
	CMFCToolBarImages m_PopupResizeBar_V;
	CMFCToolBarImages m_MenuItemMarkerC;
	CMFCToolBarImages m_MenuItemMarkerR;
	CMFCToolBarImages m_RibbonPanelSeparator;
	CMFCToolBarImages m_RibbonBtnLaunchIcon;
	CMFCToolBarImages m_RibbonBtnDefaultImage;

	CMFCControlRenderer m_ctrlToolBarBorder;
	CMFCControlRenderer m_ctrlStatusBarBack;
	CMFCControlRenderer m_ctrlStatusBarBack_Ext;
	CMFCControlRenderer m_SysBtnBack[2];
	CMFCControlRenderer m_ctrlComboBoxBtn;
	CMFCControlRenderer m_ctrlMainBorder;
	CMFCControlRenderer m_ctrlMDIChildBorder;
	CMFCControlRenderer m_ctrlMainBorderCaption;
	CMFCControlRenderer m_ctrlPopupBorder;
	CMFCControlRenderer m_ctrlPopupResizeBar;
	CMFCControlRenderer m_ctrlMenuBarBtn;
	CMFCControlRenderer m_ctrlMenuItemBack;
	CMFCControlRenderer m_ctrlMenuItemShowAll;
	CMFCControlRenderer m_ctrlMenuHighlighted[2];
	CMFCControlRenderer m_ctrlMenuButtonBorder;
	CMFCControlRenderer m_ctrlMenuScrollBtn[2];
	CMFCControlRenderer m_ctrlToolBarBtn;
	CMFCControlRenderer m_ctrlTaskScrollBtn;
	CMFCControlRenderer m_ctrlTab3D[2];
	CMFCControlRenderer m_ctrlTabFlat[2];
	CMFCControlRenderer m_ctrlOutlookWndBar;
	CMFCControlRenderer m_ctrlOutlookWndPageBtn;
	CMFCControlRenderer m_ctrlRibbonCaptionQA;
	CMFCControlRenderer m_ctrlRibbonCaptionQA_Glass;
	CMFCControlRenderer m_ctrlRibbonCategoryBack;
	CMFCControlRenderer m_ctrlRibbonCategoryTab;
	CMFCControlRenderer m_ctrlRibbonCategoryTabSep;
	CMFCControlRenderer m_ctrlRibbonCategoryBtnPage[2];
	CMFCControlRenderer m_ctrlRibbonPanelBack_T;
	CMFCControlRenderer m_ctrlRibbonPanelBack_B;
	CMFCControlRenderer m_ctrlRibbonPanelQAT;
	CMFCControlRenderer m_ctrlRibbonMainPanel;
	CMFCControlRenderer m_ctrlRibbonMainPanelBorder;
	CMFCControlRenderer m_ctrlRibbonBtnMainPanel;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_S;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_F;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_M;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_L;
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_F[2];
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_M[2];
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_L[2];
	CMFCControlRenderer m_ctrlRibbonBtn[2];
	CMFCControlRenderer m_ctrlRibbonBtnMenuH[2];
	CMFCControlRenderer m_ctrlRibbonBtnMenuV[2];
	CMFCControlRenderer m_ctrlRibbonBtnLaunch;
	CMFCControlRenderer m_RibbonBtnMain;
	CMFCControlRenderer m_ctrlRibbonBtnDefault;
	CMFCControlRenderer m_ctrlRibbonBtnDefaultIcon;
	CMFCControlRenderer m_ctrlRibbonBtnDefaultQATIcon;
	CMFCControlRenderer m_ctrlRibbonBtnDefaultQAT;
	CMFCControlRenderer m_ctrlRibbonBtnCheck;
	CMFCControlRenderer m_ctrlRibbonBtnPalette[3];
	CMFCControlRenderer m_ctrlRibbonBtnStatusPane;
	CMFCControlRenderer m_ctrlRibbonSliderThumb;
	CMFCControlRenderer m_ctrlRibbonSliderBtnPlus;
	CMFCControlRenderer m_ctrlRibbonSliderBtnMinus;
	CMFCControlRenderer m_ctrlRibbonProgressBack;
	CMFCControlRenderer m_ctrlRibbonProgressNormal;
	CMFCControlRenderer m_ctrlRibbonProgressNormalExt;
	CMFCControlRenderer m_ctrlRibbonProgressInfinity;
	CMFCControlRenderer m_ctrlRibbonBorder_QAT;
	CMFCControlRenderer m_ctrlRibbonBorder_Floaty;
	CMFCControlRenderer m_ctrlRibbonKeyTip;
	CMFCControlRenderer m_ctrlRibbonComboBoxBtn;
	CMFCControlRenderer m_ctrlRibbonContextPanelBack_T;
	CMFCControlRenderer m_ctrlRibbonContextPanelBack_B;
	CMFCControlRenderer m_ctrlRibbonContextSeparator;

	CPen   m_penTabFlatInner[2];
	CPen   m_penTabFlatOuter[2];
	CPen   m_penSeparator2;
	CPen   m_penSeparatorDark;
	CFont  m_AppCaptionFont;
	CBrush m_brMainClientArea;
	CBrush m_brGroupBackground;

	COLORREF m_clrAppCaptionActiveStart;
	COLORREF m_clrAppCaptionActiveFinish;
	COLORREF m_clrAppCaptionInactiveStart;
	COLORREF m_clrAppCaptionInactiveFinish;
	COLORREF m_clrAppCaptionActiveText;
	COLORREF m_clrAppCaptionInactiveText;
	COLORREF m_clrAppCaptionActiveTitleText;
	COLORREF m_clrAppCaptionInactiveTitleText;
	COLORREF m_clrMainClientArea;
	COLORREF m_clrMenuBarGradientLight;
	COLORREF m_clrMenuBarGradientDark;
	COLORREF m_clrMenuBarGradientVertLight;
	COLORREF m_clrMenuBarGradientVertDark;
	COLORREF m_clrMenuBarBtnText;
	COLORREF m_clrMenuBarBtnTextHighlighted;
	COLORREF m_clrMenuBarBtnTextDisabled;
	COLORREF m_clrToolBarBtnText;
	COLORREF m_clrToolBarBtnTextHighlighted;
	COLORREF m_clrToolBarBtnTextDisabled;
	COLORREF m_clrMenuText;
	COLORREF m_clrMenuTextHighlighted;
	COLORREF m_clrMenuTextDisabled;
	COLORREF m_clrStatusBarText;
	COLORREF m_clrStatusBarTextDisabled;
	COLORREF m_clrExtenedStatusBarTextDisabled;
	COLORREF m_clrEditBorder;
	COLORREF m_clrEditBorderDisabled;
	COLORREF m_clrEditBorderHighlighted;
	COLORREF m_clrEditSelection;
	COLORREF m_clrComboBorder;
	COLORREF m_clrComboBorderDisabled;
	COLORREF m_clrComboBorderPressed;
	COLORREF m_clrComboBorderHighlighted;
	COLORREF m_clrComboBtnStart;
	COLORREF m_clrComboBtnFinish;
	COLORREF m_clrComboBtnBorder;
	COLORREF m_clrComboBtnDisabledStart;
	COLORREF m_clrComboBtnDisabledFinish;
	COLORREF m_clrComboBtnBorderDisabled;
	COLORREF m_clrComboBtnPressedStart;
	COLORREF m_clrComboBtnPressedFinish;
	COLORREF m_clrComboBtnBorderPressed;
	COLORREF m_clrComboBtnHighlightedStart;
	COLORREF m_clrComboBtnHighlightedFinish;
	COLORREF m_clrComboBtnBorderHighlighted;
	COLORREF m_clrComboSelection;
	COLORREF m_clrHeaderNormalStart;
	COLORREF m_clrHeaderNormalFinish;
	COLORREF m_clrHeaderNormalBorder;
	COLORREF m_clrHeaderHighlightedStart;
	COLORREF m_clrHeaderHighlightedFinish;
	COLORREF m_clrHeaderHighlightedBorder;
	COLORREF m_clrHeaderPressedStart;
	COLORREF m_clrHeaderPressedFinish;
	COLORREF m_clrHeaderPressedBorder;
	COLORREF m_clrBarCaption;
	COLORREF m_clrMiniFrameCaption;
	COLORREF m_clrSeparator1;
	COLORREF m_clrSeparator2;
	COLORREF m_clrGroupText;
	COLORREF m_clrCaptionBarText;
	COLORREF m_clrTaskPaneGroupCaptionHighDark;
	COLORREF m_clrTaskPaneGroupCaptionHighLight;
	COLORREF m_clrTaskPaneGroupCaptionHighSpecDark;
	COLORREF m_clrTaskPaneGroupCaptionHighSpecLight;
	COLORREF m_clrTaskPaneGroupCaptionTextSpec;
	COLORREF m_clrTaskPaneGroupCaptionTextHighSpec;
	COLORREF m_clrTaskPaneGroupCaptionText;
	COLORREF m_clrTaskPaneGroupCaptionTextHigh;
	COLORREF m_clrTabFlatBlack;
	COLORREF m_clrTabFlatHighlight;
	COLORREF m_clrTabTextActive;
	COLORREF m_clrTabTextInactive;
	COLORREF m_clrOutlookPageTextNormal;
	COLORREF m_clrOutlookPageTextHighlighted;
	COLORREF m_clrOutlookPageTextPressed;
	COLORREF m_clrOutlookCaptionTextNormal;
	COLORREF m_clrRibbonCategoryText;
	COLORREF m_clrRibbonCategoryTextHighlighted;
	COLORREF m_clrRibbonCategoryTextDisabled;
	COLORREF m_clrRibbonPanelText;
	COLORREF m_clrRibbonPanelTextHighlighted;
	COLORREF m_clrRibbonPanelCaptionText;
	COLORREF m_clrRibbonPanelCaptionTextHighlighted;
	COLORREF m_clrRibbonKeyTipTextNormal;
	COLORREF m_clrRibbonKeyTipTextDisabled;
	COLORREF m_clrRibbonEdit;
	COLORREF m_clrRibbonEditDisabled;
	COLORREF m_clrRibbonEditHighlighted;
	COLORREF m_clrRibbonEditPressed;
	COLORREF m_clrRibbonEditBorder;
	COLORREF m_clrRibbonEditBorderDisabled;
	COLORREF m_clrRibbonEditBorderHighlighted;
	COLORREF m_clrRibbonEditBorderPressed;
	COLORREF m_clrRibbonEditSelection;
	COLORREF m_clrRibbonComboBtnStart;
	COLORREF m_clrRibbonComboBtnFinish;
	COLORREF m_clrRibbonComboBtnBorder;
	COLORREF m_clrRibbonComboBtnDisabledStart;
	COLORREF m_clrRibbonComboBtnDisabledFinish;
	COLORREF m_clrRibbonComboBtnBorderDisabled;
	COLORREF m_clrRibbonComboBtnPressedStart;
	COLORREF m_clrRibbonComboBtnPressedFinish;
	COLORREF m_clrRibbonComboBtnBorderPressed;
	COLORREF m_clrRibbonComboBtnHighlightedStart;
	COLORREF m_clrRibbonComboBtnHighlightedFinish;
	COLORREF m_clrRibbonComboBtnBorderHighlighted;
	COLORREF m_clrRibbonContextPanelText;
	COLORREF m_clrRibbonContextPanelTextHighlighted;
	COLORREF m_clrRibbonContextPanelCaptionText;
	COLORREF m_clrRibbonContextPanelCaptionTextHighlighted;
	COLORREF m_clrPlannerTodayCaption[4];
	COLORREF m_clrPlannerTodayBorder;
	COLORREF m_clrPlannerNcArea;
	COLORREF m_clrPlannerNcLine;
	COLORREF m_clrPlannerNcText;
	COLORREF m_clrPopupGradientLight;
	COLORREF m_clrPopupGradientDark;
	COLORREF m_clrRibbonHyperlinkInactive;
	COLORREF m_clrRibbonHyperlinkActive;
	COLORREF m_clrRibbonStatusbarHyperlinkInactive;
	COLORREF m_clrRibbonStatusbarHyperlinkActive;

	struct CMFCRibbonContextCategory
	{
		CMFCControlRenderer m_ctrlCaption;
		CMFCControlRenderer m_ctrlBack;
		CMFCControlRenderer m_ctrlTab;
		CMFCControlRenderer m_ctrlBtnDefault;
		COLORREF m_clrCaptionText;
		COLORREF m_clrText;
		COLORREF m_clrTextHighlighted;
		CMFCVisualManagerBitmapCache m_cacheBack;
		CMFCVisualManagerBitmapCache m_cacheBtnDefault;

		void CleanUp()
		{
			m_ctrlCaption.CleanUp();
			m_ctrlBack.CleanUp();
			m_ctrlTab.CleanUp();
			m_ctrlBtnDefault.CleanUp();
			m_cacheBack.Clear();
			m_cacheBtnDefault.Clear();
		}
	};

	CMFCRibbonContextCategory  m_ctrlRibbonContextCategory[AFX_RIBBON_CATEGORY_COLOR_COUNT];

	CMFCVisualManagerBitmapCache m_cacheRibbonContextPanelBack_T;
	CMFCVisualManagerBitmapCache m_cacheRibbonContextPanelBack_B;
	CMFCVisualManagerBitmapCache m_cacheRibbonCategoryBack;
	CMFCVisualManagerBitmapCache m_cacheRibbonPanelBack_T;
	CMFCVisualManagerBitmapCache m_cacheRibbonPanelBack_B;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnDefault;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_S;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_F;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_M;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_L;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_F[2];
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_M[2];
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_L[2];

	int m_nType;

	CMFCToolTipInfo m_ToolTipParams;

	CMap<HWND, HWND, BOOL, BOOL> m_ActivateFlag;

	AFX_IMPORT_DATA static Style     m_Style;
	AFX_IMPORT_DATA static CString   m_strStylePrefix;
	AFX_IMPORT_DATA static HINSTANCE m_hinstRes;
	AFX_IMPORT_DATA static BOOL      m_bAutoFreeRes;

	BOOL IsBeta1() const { return m_nType == 10; }
	BOOL IsBeta() const { return m_nType < 20; }
	BOOL IsWindowActive(CWnd* pWnd) const;
	CSize GetSystemBorders(BOOL bRibbonPresent) const;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanageroffice2003.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxvisualmanagerofficexp.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCVisualManagerOffice2003 : public CMFCVisualManagerOfficeXP
{
	DECLARE_DYNCREATE(CMFCVisualManagerOffice2003)

public:
	CMFCVisualManagerOffice2003();
	virtual ~CMFCVisualManagerOffice2003();

	static void __stdcall SetUseGlobalTheme(BOOL bUseGlobalTheme = TRUE);
	static BOOL __stdcall IsUseGlobalTheme() { return m_bUseGlobalTheme; }

	virtual BOOL IsWindowsThemingSupported() const { return m_hThemeWindow != NULL; }

	static void __stdcall SetStatusBarOfficeXPLook(BOOL bStatusBarOfficeXPLook = TRUE);
	static BOOL __stdcall IsStatusBarOfficeXPLook() { return m_bStatusBarOfficeXPLook; }

	static void __stdcall SetDefaultWinXPColors(BOOL bDefaultWinXPColors = TRUE);
	static BOOL __stdcall IsDefaultWinXPColorsEnabled() { return m_bDefaultWinXPColors; }

	virtual COLORREF GetBaseThemeColor();

	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect);
	virtual void OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar);
	virtual void OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnFillOutlookPageButton(CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText);
	virtual void OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed);
	virtual void OnDrawOutlookBarSplitter(CDC* pDC, CRect rectSplitter);
	virtual void OnFillOutlookBarCaption(CDC* pDC, CRect rectCaption, COLORREF& clrText);
	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);

	virtual int GetToolBarCustomizeButtonMargin() const { return 1; }
	virtual COLORREF GetToolbarDisabledColor() const { return m_clrToolbarDisabled; }

	virtual BOOL IsToolbarRoundShape(CMFCToolBar* pToolBar);

	virtual void OnHighlightQuickCustomizeMenuButton(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect);
	virtual COLORREF OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected = FALSE);

	virtual void DrawCustomizeButton(CDC* pDC, CRect rect, BOOL bIsHorz, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bIsCustomize, BOOL bIsMoreButtons);

	virtual void OnUpdateSystemColors();
	virtual void OnFillHighlightedArea(CDC* pDC, CRect rect, CBrush* pBrush, CMFCToolBarButton* pButton);

	virtual BOOL IsOffsetPressedButton() const { return FALSE; }

	virtual int GetShowAllMenuItemsHeight(CDC* pDC, const CSize& sizeDefault);
	virtual void OnDrawShowAllMenuItems(CDC* pDC, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawCaptionBarBorder(CDC* pDC, CMFCCaptionBar* pBar, CRect rect, COLORREF clrBarBorder, BOOL bFlatBorder);
	virtual void OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive);

	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);

	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual BOOL OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnFillTab(CDC* pDC, CRect rectFill, CBrush* pbrFill, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void GetTabFrameColors(const CMFCBaseTabCtrl* pTabWnd, COLORREF& clrDark, COLORREF& clrBlack,
		COLORREF& clrHighlight, COLORREF& clrFace, COLORREF& clrDarkShadow, COLORREF& clrLight, CBrush*& pbrFace, CBrush*& pbrBlack);
	virtual BOOL IsHighlightOneNoteTabs() const { return TRUE; }
	virtual BOOL IsDockingTabHasBorder() { return FALSE; }

	virtual COLORREF GetPropertyGridGroupColor(CMFCPropertyGridCtrl* pPropList);
	virtual COLORREF GetPropertyGridGroupTextColor(CMFCPropertyGridCtrl* pPropList);

	// Tasks pane:
	virtual void OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea);

	virtual void OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);

	virtual void OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial = FALSE);
	virtual void OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial = FALSE, BOOL bNoTitle = FALSE);
	virtual void OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE);

	virtual void OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited);

	virtual void OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* pStatusBar, CRect rectProgress, int nProgressTotal, int nProgressCurr,
		COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText);
	virtual void OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle);

	virtual void OnFillHeaderCtrlBackground(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);

	// Auto-hide buttons:
	virtual void OnFillAutoHideButtonBackground(CDC* pDC, CRect rect, CMFCAutoHideButton* pButton);
	virtual void OnDrawAutoHideButtonBorder(CDC* pDC, CRect rectBounds, CRect rectBorderSize, CMFCAutoHideButton* pButton);

	virtual BOOL DrawPushButtonWinXP(CDC* pDC, CRect rect, CMFCButton* pButton, UINT uiState)
	{
		return DrawPushButton(pDC, rect, pButton, uiState);
	}

	virtual BOOL DrawComboDropButtonWinXP(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted)
	{
		return DrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted);
	}

	virtual BOOL DrawComboBorderWinXP(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted)
	{
		return DrawComboBorder(pDC, rect, bDisabled, bIsDropped, bIsHighlighted);
	}

	// Edit box:
	virtual BOOL OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* pEdit, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& clrText);
	virtual void OnDrawControlBorder(CWnd* pWndCtrl);
	virtual void OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox);

	virtual void GetSmartDockingBaseGuideColors(COLORREF& clrBaseGroupBackground, COLORREF& clrBaseGroupBorder);
	virtual COLORREF GetSmartDockingHighlightToneColor();

	virtual void OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox);
	virtual void OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted);

	// Popup window:
	virtual void OnFillPopupWindowBackground(CDC* pDC, CRect rect);
	virtual void OnDrawPopupWindowBorder(CDC* pDC, CRect rect);
	virtual COLORREF OnDrawPopupWindowCaption(CDC* pDC, CRect rectCaption, CMFCDesktopAlertWnd* pPopupWnd);
	virtual void OnErasePopupWindowButton(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual void OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);

	virtual COLORREF GetHighlightMenuItemColor() const { return m_clrHighlightMenuItem; }

	virtual void OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled);
	virtual BOOL GetToolTipInfo(CMFCToolTipInfo& params, UINT nType = (UINT)(-1));

	// Ribbon control:
	virtual COLORREF OnDrawRibbonCategoryTab(CDC* pDC,  CMFCRibbonTab* pTab, BOOL bIsActive);
	virtual COLORREF OnDrawRibbonButtonsGroup(CDC* pDC, CMFCRibbonButtonsGroup* pGroup, CRect rectGroup);
	virtual COLORREF OnDrawRibbonCategoryCaption(CDC* pDC, CMFCRibbonContextCaption* pContextCaption);
	virtual COLORREF OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane);
	virtual void OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect);
	virtual void OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode);
	virtual void OnDrawRibbonQuickAccessToolBarSeparator(CDC* pDC, CMFCRibbonSeparator* pSeparator, CRect rect);

protected:
	WinXpTheme m_WinXPTheme;

	COLORREF m_clrBarGradientDark;
	COLORREF m_clrBarGradientLight;
	COLORREF m_clrToolBarGradientDark;
	COLORREF m_clrToolBarGradientLight;
	COLORREF m_clrToolbarDisabled;
	COLORREF m_clrToolBarGradientVertLight;
	COLORREF m_clrToolBarGradientVertDark;
	COLORREF m_clrCustomizeButtonGradientDark;
	COLORREF m_clrCustomizeButtonGradientLight;
	COLORREF m_clrToolBarBottomLine;
	COLORREF m_colorToolBarCornerTop;
	COLORREF m_colorToolBarCornerBottom;
	COLORREF m_clrHighlightMenuItem;
	COLORREF m_clrHighlightGradientLight;
	COLORREF m_clrHighlightGradientDark;
	COLORREF m_clrHighlightDnGradientLight;
	COLORREF m_clrHighlightDnGradientDark;
	COLORREF m_clrHighlightCheckedGradientLight;
	COLORREF m_clrHighlightCheckedGradientDark;
	COLORREF m_clrGripper;
	COLORREF m_clrCaptionBarGradientLight;
	COLORREF m_clrCaptionBarGradientDark;
	COLORREF m_clrTaskPaneGradientDark;
	COLORREF m_clrTaskPaneGradientLight;
	COLORREF m_clrTaskPaneGroupCaptionDark;
	COLORREF m_clrTaskPaneGroupCaptionLight;
	COLORREF m_clrTaskPaneGroupCaptionSpecDark;
	COLORREF m_clrTaskPaneGroupCaptionSpecLight;
	COLORREF m_clrTaskPaneGroupAreaLight;
	COLORREF m_clrTaskPaneGroupAreaDark;
	COLORREF m_clrTaskPaneGroupAreaSpecLight;
	COLORREF m_clrTaskPaneGroupAreaSpecDark;
	COLORREF m_clrTaskPaneGroupBorder;

	CPen   m_penBottomLine;
	CPen   m_penSeparatorLight;
	CPen   m_penTaskPaneGroupBorder;

	CBrush m_brTearOffCaption;
	CBrush m_brFace;

	BOOL   m_bIsStandardWinXPTheme;

	AFX_IMPORT_DATA static BOOL m_bUseGlobalTheme;
	AFX_IMPORT_DATA static BOOL m_bStatusBarOfficeXPLook;
	AFX_IMPORT_DATA static BOOL m_bDefaultWinXPColors;

	COLORREF GetThemeColor(HTHEME hTheme, int nIndex) const;

	virtual void ModifyGlobalColors();
	virtual COLORREF GetWindowColor() const;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanagerwindows.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxvisualmanagerofficexp.h"
#include "afxglobals.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCButton;

class CMFCVisualManagerWindows : public CMFCVisualManagerOfficeXP
{
	DECLARE_DYNCREATE(CMFCVisualManagerWindows)

public:
	CMFCVisualManagerWindows(BOOL bIsTemporary = FALSE);
	virtual ~CMFCVisualManagerWindows();

	static BOOL __stdcall IsWinXPThemeAvailable();

	void SetOfficeStyleMenus(BOOL bOn = TRUE);
	BOOL IsOfficeStyleMenus() const { return m_bOfficeStyleMenus; }

	AFX_IMPORT_DATA static BOOL m_b3DTabsXPTheme;

	virtual BOOL IsWindowsThemingSupported() const { return m_hThemeWindow != NULL; }

	virtual void OnUpdateSystemColors();

	virtual int GetPopupMenuGap() const { return m_bOfficeStyleMenus ? 0 : 1; }

	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);
	virtual void OnDrawPaneBorder(CDC* pDC, CBasePane* pBar, CRect& rect);
	virtual void OnDrawBarGripper(CDC* pDC, CRect rectGripper, BOOL bHorz, CBasePane* pBar);
	virtual void OnDrawSeparator(CDC* pDC, CBasePane* pBar, CRect rect, BOOL bIsHoriz);
	virtual void OnDrawCaptionButton(CDC* pDC, CMFCCaptionButton* pButton, BOOL bActive, BOOL bHorz, BOOL bMaximized, BOOL bDisabled, int nImageID = -1);
	virtual COLORREF OnDrawPaneCaption(CDC* pDC, CDockablePane* pBar, BOOL bActive, CRect rectCaption, CRect rectButtons);
	virtual void OnFillMenuImageRect(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawCaptionButtonIcon(CDC* pDC, CMFCCaptionButton* pButton, CMenuImages::IMAGES_IDS id, BOOL bActive, BOOL bDisabled, CPoint ptImage);
	virtual void OnDrawMenuSystemButton(CDC* pDC, CRect rect, UINT uiSystemCommand, UINT nStyle, BOOL bHighlight);
	virtual void OnDrawStatusBarPaneBorder(CDC* pDC, CMFCStatusBar* pBar, CRect rectPane, UINT uiID, UINT nStyle);

	virtual void OnDrawStatusBarProgress(CDC* pDC, CMFCStatusBar* pStatusBar, CRect rectProgress, int nProgressTotal, int nProgressCurr,
		COLORREF clrBar, COLORREF clrProgressBarDest, COLORREF clrProgressText, BOOL bProgressText);
	virtual void OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox);

	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawComboBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);
	virtual void OnDrawEditBorder(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsHighlighted, CMFCToolBarEditBoxButton* pButton);
	virtual void OnDrawTearOffCaption(CDC* pDC, CRect rect, BOOL bIsActive);

	virtual COLORREF GetToolbarButtonTextColor(CMFCToolBarButton* pButton, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonSeparator(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state, BOOL bHorz);

	virtual void OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual COLORREF GetHighlightedMenuItemTextColor(CMFCToolBarMenuButton* pButton);
	virtual void OnHighlightRarelyUsedMenuItems(CDC* pDC, CRect rectRarelyUsed);
	virtual BOOL IsHighlightWholeMenuItem()	{	return m_bOfficeStyleMenus || m_hThemeMenu != NULL;	}

	// Tab control:
	virtual void OnDrawTab(CDC* pDC, CRect rectTab, int iTab, BOOL bIsActive, const CMFCBaseTabCtrl* pTabWnd);
	virtual void OnDrawTabCloseButton(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnEraseTabsButton(CDC* pDC, CRect rect, CMFCButton* pButton, CMFCBaseTabCtrl* pWndTab);
	virtual void OnDrawTabsButtonBorder(CDC* pDC, CRect& rect, CMFCButton* pButton, UINT uiState, CMFCBaseTabCtrl* pWndTab);

	virtual BOOL AlwaysHighlight3DTabs() const { return m_hThemeTab != NULL; }

	virtual void OnEraseTabsArea(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);
	virtual BOOL OnEraseTabsFrame(CDC* pDC, CRect rect, const CMFCBaseTabCtrl* pTabWnd);

	// Miniframe
	virtual COLORREF OnFillMiniFrameCaption(CDC* pDC, CRect rectCaption, CPaneFrameWnd* pFrameWnd, BOOL bActive);
	virtual void OnDrawMiniFrameBorder(CDC* pDC, CPaneFrameWnd* pFrameWnd, CRect rectBorder, CRect rectBorderSize);

	virtual void OnDrawFloatingToolbarBorder(CDC* pDC, CMFCBaseToolBar* pToolBar, CRect rectBorder, CRect rectBorderSize);
	virtual int GetDockingPaneCaptionExtraHeight() const { return afxGlobalData.bIsWindowsVista ? 0 : 3; }

	// Outlook bar page buttons:
	virtual void OnFillOutlookPageButton(	CDC* pDC, const CRect& rect, BOOL bIsHighlighted, BOOL bIsPressed, COLORREF& clrText);
	virtual void OnDrawOutlookPageButtonBorder(CDC* pDC, CRect& rectBtn, BOOL bIsHighlighted, BOOL bIsPressed);

	// Customization dialog:
	virtual COLORREF OnFillCommandsListBackground(CDC* pDC, CRect rect, BOOL bIsSelected = FALSE);

	virtual CSize GetButtonExtraBorder() const;
	virtual CSize GetCaptionButtonExtraBorder() const;

	virtual void OnDrawHeaderCtrlBorder(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsPressed, BOOL bIsHighlighted);
	virtual void OnDrawHeaderCtrlSortArrow(CMFCHeaderCtrl* pCtrl, CDC* pDC, CRect& rect, BOOL bIsUp);

	// Tasks pane:
	virtual void OnFillTasksPaneBackground(CDC* pDC, CRect rectWorkArea);

	virtual void OnDrawTasksGroupCaption(CDC* pDC, CMFCTasksPaneTaskGroup* pGroup, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE, BOOL bCanCollapse = FALSE);

	virtual void OnFillTasksGroupInterior(CDC* pDC, CRect rect, BOOL bSpecial = FALSE);
	virtual void OnDrawTasksGroupAreaBorder(CDC* pDC, CRect rect, BOOL bSpecial = FALSE, BOOL bNoTitle = FALSE);
	virtual void OnDrawTask(CDC* pDC, CMFCTasksPaneTask* pTask, CImageList* pIcons, BOOL bIsHighlighted = FALSE, BOOL bIsSelected = FALSE);
	
	virtual void OnDrawScrollButtons(CDC* pDC, const CRect& rect, const int nBorderSize, int iImage, BOOL bHilited);
	virtual void OnDrawExpandingBox(CDC* pDC, CRect rect, BOOL bIsOpened, COLORREF colorBox);
	virtual void OnDrawControlBorder(CWnd* pWndCtrl);
	virtual void OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled);

	virtual BOOL IsOfficeXPStyleMenus() const { return m_bOfficeStyleMenus; }

	virtual BOOL DrawPushButtonWinXP(CDC* pDC, CRect rect, CMFCButton* pButton, UINT uiState)
	{
		return DrawPushButton(pDC, rect, pButton, uiState);
	}

	virtual BOOL DrawComboDropButtonWinXP(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted)
	{
		return DrawComboDropButton(pDC, rect, bDisabled, bIsDropped, bIsHighlighted);
	}

	virtual BOOL DrawComboBorderWinXP(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted)
	{
		return DrawComboBorder(pDC, rect, bDisabled, bIsDropped, bIsHighlighted);
	}

	// Edit box:
	virtual BOOL OnDrawBrowseButton(CDC* pDC, CRect rect, CMFCEditBrowseCtrl* pEdit, CMFCVisualManager::AFX_BUTTON_STATE state, COLORREF& clrText);
	virtual void OnDrawSpinButtons(CDC* pDC, CRect rectSpin, int nState, BOOL bOrientation, CMFCSpinButtonCtrl* pSpinCtrl);

	// Popup window:
	virtual void OnErasePopupWindowButton(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual void OnDrawPopupWindowButtonBorder(CDC* pDC, CRect rectClient, CMFCDesktopAlertWndButton* pButton);
	virtual BOOL IsDefaultWinXPPopupButton(CMFCDesktopAlertWndButton* pButton) const;

protected:
	BOOL m_bOfficeStyleMenus;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxv_cpu.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxv_cpu.h - target version/configuration control for various CPUs

/////////////////////////////////////////////////////////////////////////////

#ifdef _MIPS_
// specific overrides for MIPS...
#define _AFX_PACKING    8       // default MIPS alignment (required)
#endif //_MIPS_

/////////////////////////////////////////////////////////////////////////////
#ifdef _AMD64_
// specific overrides for AMD64...
#define _AFX_PACKING    8
#endif //_AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvslistbox.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxbutton.h"
#include "afxeditbrowsectrl.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define AFX_VSLISTBOX_BTN_NEW    0x0001
#define AFX_VSLISTBOX_BTN_DELETE 0x0002
#define AFX_VSLISTBOX_BTN_UP     0x0004
#define AFX_VSLISTBOX_BTN_DOWN   0x0008

#define AFX_VSLISTBOX_BTN_NEW_ID    (UINT)(-11)
#define AFX_VSLISTBOX_BTN_DELETE_ID (UINT)(-12)
#define AFX_VSLISTBOX_BTN_UP_ID     (UINT)(-13)
#define AFX_VSLISTBOX_BTN_DOWN_ID   (UINT)(-14)

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxBase window - edit list control abstract base class
// 

class CVSListBoxBase : public CStatic
{
// Construction
protected:
	CVSListBoxBase();

	CList<CMFCButton*, CMFCButton*> m_lstButtons;
	CList<DWORD, DWORD>     m_lstKeyAccell;
	CMap<int,int,UINT,UINT> m_mapButtonIDs;
	UINT m_uiStandardBtns;
	BOOL m_bNewItem;
	BOOL m_bIsActualDelete;	// Indicated that Items is really deletd, not moved
	BOOL m_bBrowseButton;
	BOOL m_bGrayDisabledButtons;
	BOOL m_bDefaultCaption;
	CSize m_sizeButton;
	CRect m_rectCaption;
	CFont m_font;
	CString m_strCaption;

// Operations
public:
	BOOL SetStandardButtons(UINT uiBtns = AFX_VSLISTBOX_BTN_NEW | AFX_VSLISTBOX_BTN_DELETE | AFX_VSLISTBOX_BTN_UP | AFX_VSLISTBOX_BTN_DOWN);
	BOOL AddButton(UINT uiImageResId, LPCTSTR lpszTooltip = NULL, WORD wKeyAccelerator = 0, BYTE fVirt = 0, UINT uiButtonID = 0);
	BOOL EnableButton(int iButtonNum, BOOL bEnable = TRUE);

	int GetButtonsCount() const { return(int) m_lstButtons.GetCount(); }
	BOOL IsCreatingNewItem() const { return m_bNewItem; }

	UINT GetButtonID(int iButtonNum) const;
	int GetButtonNum(UINT uiID) const;

	// Enable/disable "Browse" button (appear right of edit control)
	void EnableBrowseButton(BOOL bEnable = TRUE);
	BOOL IsBrowseButton() const { return m_bBrowseButton; }

	// Allow to draw disabled button grayed. By default, the disabled button will be drawn with the regular look
	void SetGrayDisabledButtons(BOOL bOn = TRUE);
	BOOL IsGrayDisabledButtons() const { return m_bGrayDisabledButtons; }

	// These methods should be implemented in the actual edit list:
	virtual int AddItem(const CString& strIext, DWORD_PTR dwData = 0, int iIndex = -1) = 0;
	virtual BOOL RemoveItem(int iIndex) = 0;
	virtual int GetCount() const = 0;
	virtual int GetSelItem() const = 0;
	virtual BOOL SelectItem(int iItem) = 0;
	virtual CString GetItemText(int iIndex) const = 0;
	virtual void SetItemText(int iIndex, const CString& strText) = 0;
	virtual DWORD_PTR GetItemData(int iIndex) const = 0;
	virtual void SetItemData(int iIndex, DWORD_PTR dwData) = 0;
	virtual BOOL EditItem(int iIndex) = 0;

protected:
	void Init();
	int GetStdButtonNum(UINT uiStdBtn) const;
	void AdjustLayout();

// Overrides
public:
	virtual void OnClickButton(int iButton);
	virtual void OnKey(WORD wKey, BYTE fFlags);
	virtual void OnEndEditLabel(LPCTSTR lpszLabel);
	virtual int OnGetImage(LV_ITEM* /*pItem*/) { return -1; }
	
	virtual void OnSelectionChanged() {}

	// "Standard" action overrides
	virtual BOOL OnBeforeRemoveItem(int /*iItem*/) { return TRUE; }
	virtual void OnAfterAddItem(int /*iItem*/) {}
	virtual void OnAfterRenameItem(int /*iItem*/) {}
	virtual void OnAfterMoveItemUp(int /*iItem*/) {}
	virtual void OnAfterMoveItemDown(int /*iItem*/) {}

	virtual void OnBrowse() {}

protected:
	virtual void CreateNewItem();

	virtual HWND GetListHwnd() const = 0;
	virtual CWnd* OnCreateList() = 0;
	virtual void OnSizeList() = 0;

	virtual void PreSubclassWindow();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

// Implementation
public:
	virtual ~CVSListBoxBase();

protected:
	//{{AFX_MSG(CVSListBoxBase)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg UINT OnGetDlgCode();
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetText(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CVSListBoxEditCtrl window

class CVSListBoxEditCtrl : public CMFCEditBrowseCtrl
{
// Construction
public:
	CVSListBoxEditCtrl();

// Attributes
protected:
	BOOL m_bLocked;
	CVSListBoxBase* m_pParentList;

// Operations
public:
	void LockSize(CVSListBoxBase* pParent, BOOL bLock = TRUE);

// Implementation
public:
	virtual ~CVSListBoxEditCtrl();

protected:
	//{{AFX_MSG(CVSListBoxEditCtrl)
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	virtual void OnBrowse()
	{
		if (m_pParentList != NULL)
		{
			HWND hwndParentList = m_pParentList->GetSafeHwnd();
			m_pParentList->OnBrowse();

			if (::IsWindow(hwndParentList))
			{
				::SetFocus(hwndParentList);
			}
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVSListBox window

class CVSListBox : public CVSListBoxBase
{
// Construction
public:
	CVSListBox();

// Attributes
public:
	CListCtrl* m_pWndList; // Embedded list control

protected:
	CPoint        m_ptClick;
	CVSListBoxEditCtrl m_wndEdit;

// Operations
public:
	virtual int AddItem(const CString& strIext, DWORD_PTR dwData = 0, int iIndex = -1);
	virtual BOOL RemoveItem(int iIndex);
	virtual int GetCount() const;

	virtual int GetSelItem() const;
	virtual BOOL SelectItem(int iItem);

	virtual CString GetItemText(int iIndex) const;
	virtual DWORD_PTR GetItemData(int iIndex) const;
	virtual void SetItemData(int iIndex, DWORD_PTR dwData);

	virtual BOOL EditItem(int iIndex);

protected:
	virtual HWND GetListHwnd() const { return m_pWndList->GetSafeHwnd(); }

	virtual CWnd* OnCreateList();
	virtual void OnSizeList();
	virtual void SetItemText(int iIndex, const CString& strText);

// Overrides
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);

// Implementation
public:
	virtual ~CVSListBox();

protected:
	//{{AFX_MSG(CVSListBox)
	afx_msg void OnKeyDown(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndLabelEdit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnInitControl(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxvisualmanagerwindows7.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxvisualmanagerwindows.h"
#include "afxvisualmanageroffice2007.h"
#include "afxtoolbarimages.h"
#include "afxcontrolrenderer.h"
#include "afxtooltipctrl.h"
#include "afxglobals.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMFCVisualManagerWindows7 : public CMFCVisualManagerWindows
{
	DECLARE_DYNCREATE(CMFCVisualManagerWindows7)

public:
	static BOOL __stdcall SetStyle(LPCTSTR lpszPath = NULL);
	static void __stdcall SetResourceHandle(HINSTANCE hinstRes);
	static void __stdcall CleanStyle();

protected:
	static CString __stdcall MakeResourceID(LPCTSTR lpszID);
	static CString __stdcall GetStyleResourceID();

	BOOL CanDrawImage() const
	{
		return afxGlobalData.m_nBitsPerPixel > 8 && !afxGlobalData.IsHighContrastMode() && m_bLoaded;
	}

public:
	CMFCVisualManagerWindows7();
	virtual ~CMFCVisualManagerWindows7();

	virtual BOOL IsOwnerDrawMenuCheck();
	virtual BOOL IsHighlightWholeMenuItem();

	virtual BOOL OnNcActivate(CWnd* pWnd, BOOL bActive);
	virtual BOOL OnNcPaint(CWnd* pWnd, const CObList& lstSysButtons, CRect rectRedraw);

	BOOL IsRibbonPresent(CWnd* pWnd) const;
	CMFCRibbonBar*	GetRibbonBar(CWnd* pWnd) const;

	virtual void DrawSeparator(CDC* pDC, const CRect& rect, CPen& pen1, CPen& pen2, BOOL bHorz);
    virtual void DrawNcBtn(CDC* pDC, const CRect& rect, UINT nButton, AFX_BUTTON_STATE state, BOOL bSmall, BOOL bActive, BOOL bMDI = FALSE);
	virtual void DrawNcText(CDC* pDC, CRect& rect, const CString& strTitle, BOOL bActive, BOOL bIsRTL, BOOL bTextCenter, BOOL bGlass = FALSE, int nGlassGlowSize = 0, COLORREF clrGlassText = (COLORREF)-1);

	virtual void OnUpdateSystemColors();
	virtual void CleanUp();

	virtual void OnHighlightMenuItem(CDC *pDC, CMFCToolBarMenuButton* pButton, CRect rect, COLORREF& clrText);
	virtual void OnDrawMenuBorder(CDC* pDC, CMFCPopupMenu* pMenu, CRect rect);
	virtual void OnDrawMenuCheck(CDC* pDC, CMFCToolBarMenuButton* pButton, CRect rect, BOOL bHighlight, BOOL bIsRadio);
	virtual void OnFillMenuImageRect(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual COLORREF OnDrawMenuLabel(CDC* pDC, CRect rect);

	virtual void OnFillButtonInterior(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);
	virtual void OnDrawButtonBorder(CDC* pDC, CMFCToolBarButton* pButton, CRect rect, CMFCVisualManager::AFX_BUTTON_STATE state);

	virtual void OnDrawRibbonCaption(CDC* pDC, CMFCRibbonBar* pBar, CRect rectCaption, CRect rectText);
    virtual void OnDrawRibbonCaptionButton(CDC* pDC, CMFCRibbonCaptionButton* pButton);

	virtual void OnDrawRibbonCategory(CDC* pDC, CMFCRibbonCategory* pCategory, CRect rectCategory);

	virtual void OnDrawRibbonGalleryButton(CDC* pDC, CMFCRibbonGalleryIcon* pButton);
	virtual COLORREF OnDrawRibbonStatusBarPane(CDC* pDC, CMFCRibbonStatusBar* pBar, CMFCRibbonStatusBarPane* pPane);

	virtual COLORREF OnDrawRibbonCategoryTab(CDC* pDC, CMFCRibbonTab* pTab, BOOL bIsActive);
	virtual COLORREF OnDrawRibbonPanel(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectPanel, CRect rectCaption);

	virtual void OnDrawRibbonPanelCaption(CDC* pDC, CMFCRibbonPanel* pPanel, CRect rectCaption);
#ifdef ENABLE_RIBBON_LAUNCH_BUTTON
	virtual void OnDrawRibbonLaunchButton(CDC* pDC, CMFCRibbonLaunchButton* pButton, CMFCRibbonPanel* pPanel);
#endif // ENABLE_RIBBON_LAUNCH_BUTTON

	virtual COLORREF OnDrawRibbonTabsFrame(CDC* pDC, CMFCRibbonBar* pWndRibbonBar, CRect rectTab);
	virtual void OnDrawRibbonSliderZoomButton(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsZoomOut, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonSliderChannel(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect);
	virtual void OnDrawRibbonSliderThumb(CDC* pDC, CMFCRibbonSlider* pSlider, CRect rect, BOOL bIsHighlighted, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void OnDrawRibbonProgressBar(CDC* pDC, CMFCRibbonProgressBar* pProgress, CRect rectProgress, CRect rectChunk, BOOL bInfiniteMode);

	virtual void OnDrawDefaultRibbonImage(CDC* pDC, CRect rectImage, BOOL bIsDisabled = FALSE, BOOL bIsPressed = FALSE, BOOL bIsHighlighted = FALSE);
	virtual void OnDrawRibbonApplicationButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnFillBarBackground(CDC* pDC, CBasePane* pBar, CRect rectClient, CRect rectClip, BOOL bNCArea = FALSE);

	virtual void OnDrawStatusBarSizeBox(CDC* pDC, CMFCStatusBar* pStatBar, CRect rectSizeBox);
	virtual void OnDrawCheckBoxEx(CDC *pDC, CRect rect, int nState, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled);
	virtual void OnDrawRadioButton(CDC *pDC, CRect rect, BOOL bOn, BOOL bHighlighted, BOOL bPressed, BOOL bEnabled);

	virtual void OnDrawRibbonButtonBorder(CDC* pDC, CMFCRibbonButton* pButton);
	virtual COLORREF OnFillRibbonButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnDrawRibbonMenuCheckFrame(CDC* pDC, CMFCRibbonButton* pButton, CRect rect);
	virtual void OnDrawRibbonDefaultPaneButton(CDC* pDC, CMFCRibbonButton* pButton);

	virtual void OnFillRibbonQuickAccessToolBarPopup(CDC* pDC, CMFCRibbonPanelMenuBar* pMenuBar, CRect rect);

	virtual void OnDrawRibbonRecentFilesFrame(CDC* pDC, CMFCRibbonMainPanel* pPanel, CRect rect);
	virtual void OnDrawComboDropButton(CDC* pDC, CRect rect, BOOL bDisabled, BOOL bIsDropped, BOOL bIsHighlighted, CMFCToolBarComboBoxButton* pButton);

	virtual int GetRibbonQuickAccessToolBarChevronOffset() { return 13; }
	virtual int GetRibbonQuickAccessToolBarRightMargin() { return 0; }
	virtual int GetRibbonPopupBorderSize(const CMFCRibbonPanelMenu* pPopup) const;
	virtual COLORREF GetRibbonEditBackgroundColor(CMFCRibbonRichEditCtrl* pEdit, BOOL bIsHighlighted, BOOL bIsPaneHighlighted, BOOL bIsDisabled);

protected:
	CFont	m_AppCaptionFont;
	CPen	m_penSeparatorDark;
	CPen	m_penSeparatorLight;

	BOOL	m_bLoaded;

	COLORREF m_clrRibbonBarBkgnd;
	CBrush   m_brRibbonBarBkgnd;
    COLORREF m_clrRibbonBarGradientLight;
    COLORREF m_clrRibbonBarGradientDark;

	COLORREF m_clrRibbonPanelCaptionText;
	COLORREF m_clrRibbonPanelCaptionTextHighlighted;

	COLORREF m_clrRibbonEdit;
	COLORREF m_clrRibbonEditDisabled;
	COLORREF m_clrRibbonEditHighlighted;
	COLORREF m_clrRibbonEditPressed;
	COLORREF m_clrRibbonEditBorder;
	COLORREF m_clrRibbonEditBorderDisabled;
	COLORREF m_clrRibbonEditBorderHighlighted;
	COLORREF m_clrRibbonEditBorderPressed;
	COLORREF m_clrRibbonEditSelection;

	CMFCControlRenderer m_ctrlRibbonComboBoxBtn;
	CMFCControlRenderer m_ctrlMenuItemBack;
    CMFCToolBarImages   m_MenuItemMarkerC;
    CMFCToolBarImages   m_MenuItemMarkerR;
	CMFCControlRenderer m_ctrlMenuHighlighted[2];

	CMFCControlRenderer m_ctrlRibbonCaptionQA;
	CMFCControlRenderer m_ctrlRibbonCategoryBack;
	CMFCControlRenderer m_ctrlRibbonCategoryTab;
	CMFCControlRenderer m_ctrlRibbonCategoryTabSep;
	CMFCControlRenderer m_ctrlRibbonPanelBackSep;
	CMFCControlRenderer m_ctrlRibbonMainPanel;
	CMFCControlRenderer m_ctrlRibbonBtnMainPanel;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_S;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_F;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_M;
	CMFCControlRenderer m_ctrlRibbonBtnGroup_L;
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_F[2];
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_M[2];
	CMFCControlRenderer m_ctrlRibbonBtnGroupMenu_L[2];
	CMFCControlRenderer m_ctrlRibbonBtn[2];
	CMFCControlRenderer m_ctrlRibbonBtnMenuH[2];
	CMFCControlRenderer m_ctrlRibbonBtnMenuV[2];
	CMFCControlRenderer m_ctrlRibbonBtnLaunch;
	CMFCToolBarImages m_RibbonBtnLaunchIcon;
	CMFCControlRenderer m_ctrlRibbonBtnMain;
	CMFCControlRenderer m_ctrlRibbonSliderBtnPlus;
	CMFCControlRenderer m_ctrlRibbonSliderBtnMinus;
	CMFCToolBarImages	 m_RibbonBtnDefaultImage;
	CMFCControlRenderer m_ctrlRibbonBtnDefault;
	CMFCControlRenderer m_ctrlRibbonBtnDefaultIcon;
	CMFCControlRenderer m_ctrlRibbonBtnDefaultQAT;
	CMFCControlRenderer m_ctrlRibbonBtnStatusPane;
	CMFCControlRenderer m_ctrlRibbonBtnPalette[3];

	CMFCControlRenderer m_ctrlRibbonBorder_QAT;

	CMFCVisualManagerBitmapCache m_cacheRibbonCategoryBack;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_S;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_F;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_M;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroup_L;
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_F[2];
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_M[2];
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnGroupMenu_L[2];
	CMFCVisualManagerBitmapCache m_cacheRibbonBtnDefault;

	AFX_IMPORT_DATA static CString   m_strStylePrefix;
	AFX_IMPORT_DATA static HINSTANCE m_hinstRes;
	AFX_IMPORT_DATA static BOOL      m_bAutoFreeRes;

	CMap<HWND, HWND, BOOL, BOOL> m_ActivateFlag;

	BOOL IsWindowActive(CWnd* pWnd) const;
	CSize GetSystemBorders(BOOL bRibbonPresent) const;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxv_cfg.h ===
// afxv_cfg.h - target configuration control for non-Microsoft compilers
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// You can define _AFX_PORTABLE in order to keep the library from using
//  certain Microsoft extensions that are not commonly implemented by
//  other compilers.

#define _AFX_PORTABLE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxv_dll.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// special header for _AFXDLL variant.

// default AFX_XXX_DATA and AFX_XXX_DATADEF macros for using MFC DLLs

#ifndef AFX_CORE_DATA
	#define AFX_CORE_DATA       AFX_DATA_IMPORT
	#define AFX_CORE_DATADEF
#endif

#ifndef AFX_OLE_DATA
	#define AFX_OLE_DATA        AFX_DATA_IMPORT
	#define AFX_OLE_DATADEF
#endif

#ifndef AFX_DB_DATA
	#define AFX_DB_DATA         AFX_DATA_IMPORT
	#define AFX_DB_DATADEF
#endif

#ifndef AFX_NET_DATA
	#define AFX_NET_DATA        AFX_DATA_IMPORT
	#define AFX_NET_DATADEF
#endif

// default AFX_EXT_DATA and AFX_EXT_DATADEF macros for using or
//  creating MFC extension DLLs, depending on _AFX_EXT_IMPL
// AFX_EXT_CLASS can be used to import or export entire classes
//  in an extension DLL without the hassle of creating a .DEF file
//  with decorated names.

#ifndef AFX_EXT_DATA
	#ifdef _AFXEXT
		#define AFX_EXT_CLASS       AFX_CLASS_EXPORT
		#define AFX_EXT_API         AFX_API_EXPORT
		#define AFX_EXT_DATA        AFX_DATA_EXPORT
		#define AFX_EXT_DATADEF
	#else
		#define AFX_EXT_CLASS       AFX_CLASS_IMPORT
		#define AFX_EXT_API         AFX_API_IMPORT
		#define AFX_EXT_DATA        AFX_DATA_IMPORT
		#define AFX_EXT_DATADEF
	#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxv_w32.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// afxv_w32.h - target version/configuration control for Win32

#pragma once

#ifdef _WINDOWS_
	#error WINDOWS.H already included.  MFC apps must not #include <windows.h>
#endif

// STRICT is the only supported option (NOSTRICT is no longer supported)
#ifndef STRICT
#define STRICT 1
#endif

// WinSDKVer.h contains the definition for _WIN32_WINNT_MAXVER (and other maximums).
#include <winsdkver.h>

#ifndef _WIN32_WINNT
#ifdef WINVER
#define _WIN32_WINNT WINVER
#else
#pragma message("_WIN32_WINNT not defined. Defaulting to _WIN32_WINNT_MAXVER (see WinSDKVer.h)")
#define _WIN32_WINNT _WIN32_WINNT_MAXVER
#endif
#else
#if _WIN32_WINNT < 0x0400
#error MFC requires _WIN32_WINNT to be #defined to 0x0400 or greater
#endif
#endif

// SDKDDKVer.h will set any of WINVER, NTDDI_VERSION and _WIN32_IE that are yet unset.
#include <sdkddkver.h>

// certain parts of WINDOWS.H are necessary
#undef NOKERNEL
#undef NOGDI
#undef NOUSER
#undef NODRIVERS
#undef NOLOGERROR
#undef NOPROFILER
#undef NOMEMMGR
#undef NOLFILEIO
#undef NOOPENFILE
#undef NORESOURCE
#undef NOATOM
#undef NOLANGUAGE
#undef NOLSTRING
#undef NODBCS
#undef NOKEYBOARDINFO
#undef NOGDICAPMASKS
#undef NOCOLOR
#undef NOGDIOBJ
#undef NODRAWTEXT
#undef NOTEXTMETRIC
#undef NOSCALABLEFONT
#undef NOBITMAP
#undef NORASTEROPS
#undef NOMETAFILE
#undef NOSYSMETRICS
#undef NOSYSTEMPARAMSINFO
#undef NOMSG
#undef NOWINSTYLES
#undef NOWINOFFSETS
#undef NOSHOWWINDOW
#undef NODEFERWINDOWPOS
#undef NOVIRTUALKEYCODES
#undef NOKEYSTATES
#undef NOWH
#undef NOMENUS
#undef NOSCROLL
#undef NOCLIPBOARD
#undef NOICONS
#undef NOMB
#undef NOSYSCOMMANDS
#undef NOMDI
#undef NOCTLMGR
#undef NOWINMESSAGES

#ifndef WIN32
#define WIN32
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef VC_EXTRALEAN
#define NOSERVICE
#define NOMCX
#define NOIME
#define NOSOUND
#define NOCOMM
#define NORPC

#ifndef NO_ANSIUNI_ONLY
#ifdef _UNICODE
#define UNICODE_ONLY
#else
#define ANSI_ONLY
#endif
#endif //!NO_ANSIUNI_ONLY

#endif //VC_EXTRALEAN

/////////////////////////////////////////////////////////////////////////////
// Turn off warnings for /W4
// To resume any of these warning: #pragma warning(default: 4xxx)
// which should be placed after the AFX include files

#pragma warning(push)
#pragma warning(disable: 4311 4312)
#pragma warning(disable: 4201)  // winnt.h uses nameless structs

// Don't include winsock.h
#pragma push_macro("_WINSOCKAPI_")
#ifndef _WINSOCKAPI_
#define _WINSOCKAPI_
#endif

#include <windows.h>

#pragma pop_macro("_WINSOCKAPI_")

#pragma warning(pop)

// Mouse message MFC is interested in
#ifndef AFX_WM_MOUSELAST
#define AFX_WM_MOUSELAST 0x0209
#endif

#include <zmouse.h>

struct HKEY__;
typedef struct HKEY__ *HKEY;

#ifndef _INC_COMMCTRL
	#include <commctrl.h>

	// Note: We must avoid using TB_ADDBUTTONW and TB_INSERTBUTTONW
	//       in the Unicode build or else MFCXXU.DLL will not be
	//       compatible with pre-IE4 versions of COMCTL32.DLL.
	#ifdef TB_ADDBUTTONSA
		#undef TB_ADDBUTTONS
		#define TB_ADDBUTTONS TB_ADDBUTTONSA
	#endif

	#ifdef TB_INSERTBUTTONA
		#undef TB_INSERTBUTTON
		#define TB_INSERTBUTTON TB_INSERTBUTTONA
	#endif
#endif

#ifndef EXPORT
#define EXPORT
#endif

#ifndef _INC_TCHAR
	#include <tchar.h>      // used for ANSI v.s. UNICODE abstraction
#endif
#ifdef _MBCS
#ifndef _INC_MBCTYPE
	#include <mbctype.h>
#endif
#ifndef _INC_MBSTRING
	#include <mbstring.h>
#endif
#endif

#ifdef _WIN64
#define _AFX_NO_CTL3D_SUPPORT
#endif

/////////////////////////////////////////////////////////////////////////////
// Now for the Windows API specific parts

// WM_CTLCOLOR for 16 bit API compatability
#define WM_CTLCOLOR     0x0019

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetWindowTask
#undef GetWindowTask
AFX_INLINE HTASK GetWindowTask(HWND hWnd)
	{ return (HTASK)(DWORD_PTR)::GetWindowThreadProcessId(hWnd, NULL); }
#endif

// Win32 uses macros with parameters for this, which breaks C++ code.
#ifdef GetNextWindow
#undef GetNextWindow
AFX_INLINE HWND GetNextWindow(HWND hWnd, UINT nDirection)
	{ return ::GetWindow(hWnd, nDirection); }
#endif

// Avoid mapping CToolBar::DrawState to DrawState[A/W]
#ifdef DrawState
#undef DrawState
AFX_INLINE BOOL WINAPI DrawState(HDC hdc, HBRUSH hbr, DRAWSTATEPROC lpOutputFunc,
	LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT fuFlags)
#ifdef UNICODE
	{ return ::DrawStateW(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#else
	{ return ::DrawStateA(hdc, hbr, lpOutputFunc, lData, wData, x, y, cx, cy,
		fuFlags); }
#endif
#endif

// Avoid mapping CStatusBar::DrawStatusText to DrawStatusText[A/W]
#ifdef DrawStatusText
#undef DrawStatusText
AFX_INLINE void WINAPI AfxDrawStatusTextA(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags);
AFX_INLINE void WINAPI AfxDrawStatusTextW(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags);
AFX_INLINE void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCTSTR szText,
	UINT uFlags) 
#ifdef UNICODE
	{ ::AfxDrawStatusTextW(hDC, lprc, szText, uFlags); }
#else
	{ ::AfxDrawStatusTextA(hDC, lprc, szText, uFlags); }
#endif
#endif

// FreeResource is not required on Win32 platforms
#undef FreeResource
AFX_INLINE BOOL WINAPI FreeResource(HGLOBAL) { return TRUE; }
// UnlockResource is not required on Win32 platforms
#undef UnlockResource
AFX_INLINE int WINAPI UnlockResource(HGLOBAL) { return 0; }

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwin.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXWIN_H__
#ifndef RC_INVOKED
#define __AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
// Make sure 'afx.h' is included first

#ifndef __AFX_H__
	#include <afx.h>
#endif

// Note: WINDOWS.H already included from AFXV_W32.H
#ifndef NTDDI_LONGHORN
#define NTDDI_LONGHORN 0x06000000
#if (WINVER >= 0x0600) || (_WIN32_WINNT >= 0x0600)
#error Your version of the Windows SDK is earlier than 6.0. Try setting the 'WINVER' and '_WIN32_WINNT' definitions in your project to less than 0x0600.
#endif
#endif

#ifndef _INC_SHELLAPI
	#include <shellapi.h>
#endif

#ifndef __AFXRES_H__
	#include <afxres.h>     // standard resource IDs
#endif

#ifndef __AFXCOLL_H__
	#include <afxcoll.h>    // standard collections
#endif

#ifndef _OBJBASE_H_
	#include <objbase.h> //needed for commdlg.h (STDMETHOD)
#endif

#ifndef _INC_COMMDLG
	#include <commdlg.h>    // common dialog APIs
#endif

#include <afxctrlcontainer.h>

#if WINVER >= 0x0600
#ifndef _WIN32_IE
#define _WIN32_IE 0x0700
#else
#undef _WIN32_IE
#define _WIN32_IE 0x0700
#endif

#ifndef __shobjidl_h__
	#include <shobjidl.h>    // for IPreviewHandler, IPreviewHandlerVisuals
#endif

#ifndef __IThumbnailProvider_INTERFACE_DEFINED__
	#include <thumbcache.h>  // for IThumbnailProvider
#endif
#endif 

#ifndef __ATL_SO__
	#include <atlhandler.h> // for IFilterChunkValue and IDocument
#endif

#if (_WIN32_WINNT >= 0x601)
#ifndef __tpcshrd_h__
	#include <tpcshrd.h>	// for touch and gesture features
#endif
#endif

// Avoid mapping GetFileTitle to GetFileTitle[A/W]
#ifdef GetFileTitle
#undef GetFileTitle
AFX_INLINE short APIENTRY GetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
#ifdef UNICODE
	{ return ::GetFileTitleW(lpszFile, lpszTitle, cbBuf); }
#else
	{ return ::GetFileTitleA(lpszFile, lpszTitle, cbBuf); }
#endif
#endif

#ifndef _AFX_NO_AFXCMN_SUPPORT
#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif
#include <afxcomctl32.h>
#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
#endif

#if (_WIN32_WINNT >= 0x501)

#if ((NTDDI_VERSION >= NTDDI_LONGHORN || defined(__VSSYM32_H__)) && !defined(SCHEMA_VERIFY_VSSYM32))
#include <vssym32.h>
#else
#include <tmschema.h>
#endif
#endif	// (_WIN32_WINNT >= 0x501)

#if (_WIN32_WINNT >= 0x600)
#ifndef _WINSOCK2API_
#ifdef _WINSOCKAPI_
	#error MFC requires use of Winsock2.h
#endif
	#include <winsock2.h>
#endif

#ifndef _WS2IPDEF_
	#include <ws2ipdef.h>
#endif

#ifndef _WINDNS_INCLUDED_
	#include <windns.h>
#endif

#ifndef __IPHLPAPI_H__
	#include <iphlpapi.h>
#endif
#endif	// (_WIN32_WINNT >= 0x600)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifndef _AFX_NOFORCE_LIBS
#pragma comment(lib, "uuid.lib")
#endif

#ifdef _INC_WINDOWSX
// The following names from WINDOWSX.H collide with names in this header
#undef SubclassWindow
#undef CopyRgn
#endif

#include <htmlhelp.h>

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#pragma warning( push )
#pragma warning( disable: 4121 )

using ATL::CAtlTransactionManager;

/////////////////////////////////////////////////////////////////////////////
// Classes declared in this file

//CObject
	//CException
		//CSimpleException
			class CResourceException;// Win resource failure exception
			class CUserException;    // Message Box alert and stop operation

	class CGdiObject;            // CDC drawing tool
		class CPen;              // a pen / HPEN wrapper
		class CBrush;            // a brush / HBRUSH wrapper
		class CFont;             // a font / HFONT wrapper
		class CBitmap;           // a bitmap / HBITMAP wrapper
		class CPalette;          // a palette / HPALLETE wrapper
		class CRgn;              // a region / HRGN wrapper

	class CDC;                   // a Display Context / HDC wrapper
		class CClientDC;         // CDC for client of window
		class CWindowDC;         // CDC for entire window
		class CPaintDC;          // embeddable BeginPaint struct helper

	class CImageList;            // an image list / HIMAGELIST wrapper

	class CMenu;                 // a menu / HMENU wrapper

	class CCmdTarget;            // a target for user commands
		class CWnd;                 // a window / HWND wrapper
			class CDialog;          // a dialog

			// standard windows controls
			class CStatic;          // Static control
			class CButton;          // Button control
			class CListBox;         // ListBox control
				class CCheckListBox;// special listbox with checks
			class CComboBox;        // ComboBox control
			class CEdit;            // Edit control
			class CScrollBar;       // ScrollBar control

			class CMFCPreviewCtrlImpl; // helper window for DLL implementation of Rich Preview

			// frame windows
			class CFrameWnd;        // standard SDI frame
				class CMDIFrameWnd; // standard MDI frame
				class CMDIChildWnd; // standard MDI child
				class CMiniFrameWnd;// half-height caption frame wnd

			// views on a document
			class CView;            // a view on a document
				class CScrollView;  // a scrolling view

		class CWinThread;           // thread base class
			class CWinApp;          // application base class

		class CDocTemplate;         // template for document creation
			class CSingleDocTemplate;// SDI support
			class CMultiDocTemplate; // MDI support

		class CDocument;            // main document abstraction
		class CMFCFilterChunkValueImpl; // search/organize/preview/thumbnail support - filter chunk value implementation


// Helper classes
class CCmdUI;           // Menu/button enabling
class CDataExchange;    // Data exchange and validation context
class CCommandLineInfo; // CommandLine parsing helper
class CDocManager;      // CDocTemplate manager object

struct COleControlSiteOrWnd; // ActiveX dialog control helper


class CControlCreationInfo; //Used in CWnd::CreateControl overloads.

class CVariantBoolConverter;

/////////////////////////////////////////////////////////////////////////////

enum AFX_HELP_TYPE
{
	afxWinHelp = 0,
	afxHTMLHelp = 1
};

// Type modifier for message handlers
#ifndef afx_msg
#define afx_msg         // intentional placeholder
#endif

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA


#ifndef __ATLTYPES_H__
#include <atltypes.h>
#endif

#ifdef _DEBUG
// Diagnostic Output
CDumpContext& AFXAPI operator<<(CDumpContext& dc, SIZE size);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, POINT point);
CDumpContext& AFXAPI operator<<(CDumpContext& dc, const RECT& rect);
#endif //_DEBUG

// Serialization
CArchive& AFXAPI operator<<(CArchive& ar, SIZE size);
CArchive& AFXAPI operator<<(CArchive& ar, POINT point);
CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect);
CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size);
CArchive& AFXAPI operator>>(CArchive& ar, POINT& point);
CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect);

// macro to be used in ATL search/organize/preview/thumbnail handlers with MFC document support 
#define DECLARE_DOCUMENT(classDocument)\
protected:\
	virtual IDocument* CreateDocument()\
	{\
		CRuntimeClass* pDocRTC = RUNTIME_CLASS(classDocument);\
		if (pDocRTC == NULL)\
		{\
			TRACE("Document class does not support dynamic creation."); \
			return NULL;\
		}\
		classDocument* pDoc = DYNAMIC_DOWNCAST(classDocument, pDocRTC->CreateObject());\
		ASSERT_VALID(pDoc);\
		return pDoc->GetAdapter();\
	}



/////////////////////////////////////////////////////////////////////////////
// Standard exceptions

class CResourceException : public CSimpleException    // resource failure
{
	DECLARE_DYNAMIC(CResourceException)
public:
	CResourceException();

// Implementation
public:
	explicit CResourceException(BOOL bAutoDelete);
	CResourceException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CResourceException();
};

class CUserException : public CSimpleException   // general user visible alert
{
	DECLARE_DYNAMIC(CUserException)
public:
	CUserException();

// Implementation
public:
	explicit CUserException(BOOL bAutoDelete);
	CUserException(BOOL bAutoDelete, UINT nResourceID);
	virtual ~CUserException();
};

void AFXAPI AfxThrowResourceException();
void AFXAPI AfxThrowUserException();

void AFXAPI AfxGetGrayBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF crBackground);
void AFXAPI AfxDrawGrayBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF crBackground);
void AFXAPI AfxGetDitheredBitmap(const CBitmap &rSrc, CBitmap *pDest, COLORREF cr1, COLORREF cr2);
void AFXAPI AfxDrawDitheredBitmap(CDC *pDC, int x, int y, const CBitmap &rSrc, COLORREF cr1, COLORREF cr2);

/////////////////////////////////////////////////////////////////////////////
// CGdiObject abstract class for CDC SelectObject

class CGdiObject : public CObject
{
	DECLARE_DYNCREATE(CGdiObject)
public:

// Attributes
	HGDIOBJ m_hObject;                  // must be first data member
	operator HGDIOBJ() const;
	HGDIOBJ GetSafeHandle() const;

	static CGdiObject* PASCAL FromHandle(HGDIOBJ hObject);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HGDIOBJ hObject);
	HGDIOBJ Detach();

// Constructors
	CGdiObject(); // must Create a derived class object
	BOOL DeleteObject();

// Operations
#pragma push_macro("GetObject")
#undef GetObject
	int _AFX_FUNCNAME(GetObject)(int nCount, LPVOID lpObject) const;
	int GetObject(int nCount, LPVOID lpObject) const;
#pragma pop_macro("GetObject")
	UINT GetObjectType() const;
	BOOL CreateStockObject(int nIndex);
	BOOL UnrealizeObject();
	BOOL operator==(const CGdiObject& obj) const;
	BOOL operator!=(const CGdiObject& obj) const;

// Implementation
public:
	virtual ~CGdiObject();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CGdiObject subclasses (drawing tools)

class CPen : public CGdiObject
{
	DECLARE_DYNAMIC(CPen)

public:
	static CPen* PASCAL FromHandle(HPEN hPen);

// Constructors
	CPen();
	CPen(int nPenStyle, int nWidth, COLORREF crColor);
	CPen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount = 0, const DWORD* lpStyle = NULL);
	BOOL CreatePen(int nPenStyle, int nWidth, COLORREF crColor);
	BOOL CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount = 0, const DWORD* lpStyle = NULL);
	BOOL CreatePenIndirect(LPLOGPEN lpLogPen);

// Attributes
	operator HPEN() const;
	int GetLogPen(LOGPEN* pLogPen);
	int GetExtLogPen(EXTLOGPEN* pLogPen);

// Implementation
public:
	virtual ~CPen();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CBrush : public CGdiObject
{
	DECLARE_DYNAMIC(CBrush)

public:
	static CBrush* PASCAL FromHandle(HBRUSH hBrush);

// Constructors
	CBrush();
	CBrush(COLORREF crColor);             // CreateSolidBrush
	CBrush(int nIndex, COLORREF crColor); // CreateHatchBrush
	explicit CBrush(CBitmap* pBitmap);          // CreatePatternBrush

	BOOL CreateSolidBrush(COLORREF crColor);
	BOOL CreateHatchBrush(int nIndex, COLORREF crColor);
	BOOL CreateBrushIndirect(const LOGBRUSH* lpLogBrush);
	BOOL CreatePatternBrush(CBitmap* pBitmap);
	BOOL CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage);
	BOOL CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage);
	BOOL CreateSysColorBrush(int nIndex);

// Attributes
	operator HBRUSH() const;
	int GetLogBrush(LOGBRUSH* pLogBrush);

// Implementation
public:
	virtual ~CBrush();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CFont : public CGdiObject
{
	DECLARE_DYNAMIC(CFont)

public:
	static CFont* PASCAL FromHandle(HFONT hFont);

// Constructors
	CFont();
	BOOL CreateFontIndirect(const LOGFONT* lpLogFont);
	BOOL CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename);
	BOOL CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, CDC* pDC = NULL);
	BOOL CreatePointFontIndirect(const LOGFONT* lpLogFont, CDC* pDC = NULL);

// Attributes
	operator HFONT() const;
	int GetLogFont(LOGFONT* pLogFont);

// Implementation
public:
	virtual ~CFont();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CBitmap : public CGdiObject
{
	DECLARE_DYNAMIC(CBitmap)

public:
	static CBitmap* PASCAL FromHandle(HBITMAP hBitmap);

// Constructors
	CBitmap();

	BOOL LoadBitmap(LPCTSTR lpszResourceName);
	BOOL LoadBitmap(UINT nIDResource);
	BOOL LoadOEMBitmap(UINT nIDBitmap); // for OBM_/OCR_/OIC_
#ifndef _AFX_NO_AFXCMN_SUPPORT
	BOOL LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0,
		LPCOLORMAP lpColorMap = NULL, int nMapSize = 0);
#endif
	BOOL CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount,
			const void* lpBits);
	BOOL CreateBitmapIndirect(LPBITMAP lpBitmap);
	BOOL CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight);
	BOOL CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight);

// Attributes
	operator HBITMAP() const;
	int GetBitmap(BITMAP* pBitMap);

// Operations
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits);
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const;
	CSize SetBitmapDimension(int nWidth, int nHeight);
	CSize GetBitmapDimension() const;

// Implementation
public:
	virtual ~CBitmap();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CPalette : public CGdiObject
{
	DECLARE_DYNAMIC(CPalette)

public:
	static CPalette* PASCAL FromHandle(HPALETTE hPalette);

// Constructors
	CPalette();
	BOOL CreatePalette(LPLOGPALETTE lpLogPalette);
	BOOL CreateHalftonePalette(CDC* pDC);

// Attributes
	operator HPALETTE() const;
	int GetEntryCount();
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors) const;
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors);

// Operations
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries,
			LPPALETTEENTRY lpPaletteColors);
	UINT GetNearestPaletteIndex(COLORREF crColor) const;
	BOOL ResizePalette(UINT nNumEntries);

// Implementation
	virtual ~CPalette();
};

class CRgn : public CGdiObject
{
	DECLARE_DYNAMIC(CRgn)

public:
	static CRgn* PASCAL FromHandle(HRGN hRgn);
	operator HRGN() const;

// Constructors
	CRgn();
	BOOL CreateRectRgn(int x1, int y1, int x2, int y2);
	BOOL CreateRectRgnIndirect(LPCRECT lpRect);
	BOOL CreateEllipticRgn(int x1, int y1, int x2, int y2);
	BOOL CreateEllipticRgnIndirect(LPCRECT lpRect);
	BOOL CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode);
	BOOL CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts,
			int nCount, int nPolyFillMode);
	BOOL CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3);
	BOOL CreateFromPath(CDC* pDC);
	BOOL CreateFromData(const XFORM* lpXForm, int nCount,
		const RGNDATA* pRgnData);

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2);
	void SetRectRgn(LPCRECT lpRect);
	int CombineRgn(const CRgn* pRgn1, const CRgn* pRgn2, int nCombineMode);
	int CopyRgn(const CRgn* pRgnSrc);
	BOOL EqualRgn(const CRgn* pRgn) const;
	int OffsetRgn(int x, int y);
	int OffsetRgn(POINT point);
	int GetRgnBox(LPRECT lpRect) const;
	BOOL PtInRegion(int x, int y) const;
	BOOL PtInRegion(POINT point) const;
	BOOL RectInRegion(LPCRECT lpRect) const;
	int GetRegionData(LPRGNDATA lpRgnData, int nCount) const;

// Implementation
	virtual ~CRgn();
};

/////////////////////////////////////////////////////////////////////////////
// The device context

class CDC : public CObject
{
	DECLARE_DYNCREATE(CDC)
public:

// Attributes
	HDC m_hDC;          // The output DC (must be first data member)
	HDC m_hAttribDC;    // The Attribute DC
	operator HDC() const;
	HDC GetSafeHdc() const; // Always returns the Output DC
	CWnd* GetWindow() const;

	static CDC* PASCAL FromHandle(HDC hDC);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HDC hDC);   // Attach/Detach affects only the Output DC
	HDC Detach();

	virtual void SetAttribDC(HDC hDC);  // Set the Attribute DC
	virtual void SetOutputDC(HDC hDC);  // Set the Output DC
	virtual void ReleaseAttribDC();     // Release the Attribute DC
	virtual void ReleaseOutputDC();     // Release the Output DC

	BOOL IsPrinting() const;            // TRUE if being used for printing

	CPen* GetCurrentPen() const;
	CBrush* GetCurrentBrush() const;
	CPalette* GetCurrentPalette() const;
	CFont* GetCurrentFont() const;
	CBitmap* GetCurrentBitmap() const;

	// for bidi and mirrored localization
	DWORD GetLayout() const;
	DWORD SetLayout(DWORD dwLayout);

// Constructors
	CDC();
	BOOL CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const void* lpInitData);
	BOOL CreateIC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const void* lpInitData);
	BOOL CreateCompatibleDC(CDC* pDC);

	BOOL DeleteDC();

// Device-Context Functions
	virtual int SaveDC();
	virtual BOOL RestoreDC(int nSavedDC);
	int GetDeviceCaps(int nIndex) const;
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags);
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags);
	BOOL ResetDC(const DEVMODE* lpDevMode);

// Drawing-Tool Functions
	CPoint GetBrushOrg() const;
	CPoint SetBrushOrg(int x, int y);
	CPoint SetBrushOrg(POINT point);
	int EnumObjects(int nObjectType,
			int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData);

// Type-safe selection helpers
public:
	virtual CGdiObject* SelectStockObject(int nIndex);
	CPen* SelectObject(CPen* pPen);
	CBrush* SelectObject(CBrush* pBrush);
	virtual CFont* SelectObject(CFont* pFont);
	CBitmap* SelectObject(CBitmap* pBitmap);
	int SelectObject(CRgn* pRgn);       // special return for regions
	CGdiObject* SelectObject(CGdiObject* pObject);
		// CGdiObject* provided so compiler doesn't use SelectObject(HGDIOBJ)

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const;
	CPalette* SelectPalette(CPalette* pPalette, BOOL bForceBackground);
	UINT RealizePalette();
	void UpdateColors();

// Drawing-Attribute Functions
	COLORREF GetBkColor() const;
	int GetBkMode() const;
	int GetPolyFillMode() const;
	int GetROP2() const;
	int GetStretchBltMode() const;
	COLORREF GetTextColor() const;

	virtual COLORREF SetBkColor(COLORREF crColor);
	int SetBkMode(int nBkMode);
	int SetPolyFillMode(int nPolyFillMode);
	int SetROP2(int nDrawMode);
	int SetStretchBltMode(int nStretchMode);
	virtual COLORREF SetTextColor(COLORREF crColor);

	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const;
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust);

#if (_WIN32_WINNT >= 0x0500)

	COLORREF GetDCBrushColor() const;
	COLORREF SetDCBrushColor(COLORREF crColor);

	COLORREF GetDCPenColor() const;
	COLORREF SetDCPenColor(COLORREF crColor);

#endif

	// Graphics mode
	int SetGraphicsMode(int iMode);
	int GetGraphicsMode() const;

	// World transform
	BOOL SetWorldTransform(const XFORM* pXform);
	BOOL ModifyWorldTransform(const XFORM* pXform,DWORD iMode);
	BOOL GetWorldTransform(XFORM* pXform) const;

	// Mapping Functions
	int GetMapMode() const;
	CPoint GetViewportOrg() const;
	virtual int SetMapMode(int nMapMode);
	// Viewport Origin
	virtual CPoint SetViewportOrg(int x, int y);
			CPoint SetViewportOrg(POINT point);
	virtual CPoint OffsetViewportOrg(int nWidth, int nHeight);

	// Viewport Extent
	CSize GetViewportExt() const;
	virtual CSize SetViewportExt(int cx, int cy);
			CSize SetViewportExt(SIZE size);
	virtual CSize ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom);

	// Window Origin
	CPoint GetWindowOrg() const;
	CPoint SetWindowOrg(int x, int y);
	CPoint SetWindowOrg(POINT point);
	CPoint OffsetWindowOrg(int nWidth, int nHeight);

	// Window extent
	CSize GetWindowExt() const;
	virtual CSize SetWindowExt(int cx, int cy);
			CSize SetWindowExt(SIZE size);
	virtual CSize ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom);

// Coordinate Functions
	void DPtoLP(LPPOINT lpPoints, int nCount = 1) const;
	void DPtoLP(LPRECT lpRect) const;
	void DPtoLP(LPSIZE lpSize) const;
	void LPtoDP(LPPOINT lpPoints, int nCount = 1) const;
	void LPtoDP(LPRECT lpRect) const;
	void LPtoDP(LPSIZE lpSize) const;

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	void DPtoHIMETRIC(LPSIZE lpSize) const;
	void LPtoHIMETRIC(LPSIZE lpSize) const;
	void HIMETRICtoDP(LPSIZE lpSize) const;
	void HIMETRICtoLP(LPSIZE lpSize) const;

// Region Functions
	BOOL FillRgn(CRgn* pRgn, CBrush* pBrush);
	BOOL FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight);
	BOOL InvertRgn(CRgn* pRgn);
	BOOL PaintRgn(CRgn* pRgn);

// Clipping Functions
	virtual int GetClipBox(LPRECT lpRect) const;
	virtual BOOL PtVisible(int x, int y) const;
			BOOL PtVisible(POINT point) const;
	virtual BOOL RectVisible(LPCRECT lpRect) const;
			int SelectClipRgn(CRgn* pRgn);
			int ExcludeClipRect(int x1, int y1, int x2, int y2);
			int ExcludeClipRect(LPCRECT lpRect);
			int ExcludeUpdateRgn(CWnd* pWnd);
			int IntersectClipRect(int x1, int y1, int x2, int y2);
			int IntersectClipRect(LPCRECT lpRect);
			int OffsetClipRgn(int x, int y);
			int OffsetClipRgn(SIZE size);
	int SelectClipRgn(CRgn* pRgn, int nMode);

// Line-Output Functions
	CPoint GetCurrentPosition() const;
	CPoint MoveTo(int x, int y);
	CPoint MoveTo(POINT point);
	BOOL LineTo(int x, int y);
	BOOL LineTo(POINT point);
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
	BOOL Polyline(const POINT* lpPoints, int nCount);

	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle);
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
	int GetArcDirection() const;
	int SetArcDirection(int nArcDirection);

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount);
	BOOL PolylineTo(const POINT* lpPoints, int nCount);
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount);

	BOOL PolyBezier(const POINT* lpPoints, int nCount);
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount);

// Simple Drawing Functions
	void FillRect(LPCRECT lpRect, CBrush* pBrush);
	void FrameRect(LPCRECT lpRect, CBrush* pBrush);
	void InvertRect(LPCRECT lpRect);
	BOOL DrawIcon(int x, int y, HICON hIcon);
	BOOL DrawIcon(POINT point, HICON hIcon);
	BOOL DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags,
		HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags,
		CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
		HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags,
		CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, CBrush* pBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL);
	BOOL DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, CBrush* pBrush = NULL);

// Ellipse and Polygon Functions
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3,
		int x4, int y4);
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
	void DrawFocusRect(LPCRECT lpRect);
	BOOL Ellipse(int x1, int y1, int x2, int y2);
	BOOL Ellipse(LPCRECT lpRect);
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd);
	BOOL Polygon(const POINT* lpPoints, int nCount);	
	BOOL PolyPolygon(const POINT* lpPoints, const INT* lpPolyCounts, int nCount);
	BOOL Rectangle(int x1, int y1, int x2, int y2);
	BOOL Rectangle(LPCRECT lpRect);
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3);
	BOOL RoundRect(LPCRECT lpRect, POINT point);

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop);
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, DWORD dwRop);
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop);
	COLORREF GetPixel(int x, int y) const;
	COLORREF GetPixel(POINT point) const;
	COLORREF SetPixel(int x, int y, COLORREF crColor);
	COLORREF SetPixel(POINT point, COLORREF crColor);
	BOOL FloodFill(int x, int y, COLORREF crColor);
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType);
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask,
		DWORD dwRop);
	BOOL PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask);
	BOOL SetPixelV(int x, int y, COLORREF crColor);
	BOOL SetPixelV(POINT point, COLORREF crColor);
   BOOL GradientFill(TRIVERTEX* pVertices, ULONG nVertices, 
	  void* pMesh, ULONG nMeshElements, DWORD dwMode);
   BOOL TransparentBlt(int xDest, int yDest, int nDestWidth, int nDestHeight,
	  CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
	  UINT clrTransparent);
   BOOL AlphaBlend(int xDest, int yDest, int nDestWidth, int nDestHeight,
	  CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, 
	  BLENDFUNCTION blend);

// Text Functions
	virtual BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount);
			BOOL TextOut(int x, int y, const CString& str);
	virtual BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths);
			BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				const CString& str, LPINT lpDxWidths);
	virtual CSize TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);
			CSize TabbedTextOut(int x, int y, const CString& str,
				int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin);

#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
	virtual int _AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int _AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat);

	virtual int _AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int _AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);

			int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat);
			int DrawText(const CString& str, LPRECT lpRect, UINT nFormat);

			int DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect,
				UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
			int DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams);
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

	CSize GetTextExtent(LPCTSTR lpszString, int nCount) const;
	CSize GetTextExtent(const CString& str) const;
	CSize GetOutputTextExtent(LPCTSTR lpszString, int nCount) const;
	CSize GetOutputTextExtent(const CString& str) const;
	CSize GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	CSize GetOutputTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const;
	virtual BOOL GrayString(CBrush* pBrush,
		BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
			int nCount, int x, int y, int nWidth, int nHeight);
	UINT GetTextAlign() const;
	UINT SetTextAlign(UINT nFlags);
	int GetTextFace(_In_ int nCount, _Out_z_cap_post_count_(nCount, return) LPTSTR lpszFacename) const;
	int GetTextFace(CString& rString) const;
#pragma push_macro("GetTextMetrics")
#undef GetTextMetrics
	BOOL _AFX_FUNCNAME(GetTextMetrics)(LPTEXTMETRIC lpMetrics) const;
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const;
#pragma pop_macro("GetTextMetrics")
	BOOL GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const;
	int SetTextJustification(int nBreakExtra, int nBreakCount);
	int GetTextCharacterExtra() const;
	int SetTextCharacterExtra(int nCharExtra);

	DWORD GetCharacterPlacement(LPCTSTR lpString, int nCount, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const;
	DWORD GetCharacterPlacement(CString& str, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const;

#if (_WIN32_WINNT >= 0x0500)

	BOOL GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, _Out_opt_ LPSIZE lpSize) const;
	BOOL GetTextExtentPointI(LPWORD pgiIn, int cgi, _Out_opt_ LPSIZE lpSize) const;

#endif



// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags);
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState);

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
		CRgn* pRgnUpdate, LPRECT lpRectUpdate);

// Font Functions
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
	BOOL GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const;
	DWORD SetMapperFlags(DWORD dwFlag);
	CSize GetAspectRatioFilter() const;

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const;
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const;
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const;
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const;
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const;

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const;
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const;

	DWORD GetFontLanguageInfo() const;

#if (_WIN32_WINNT >= 0x0500)

	BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const;
	BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const;

#endif

// Printer/Device Escape Functions
	virtual int Escape(_In_ int nEscape, _In_ int nCount,
		_In_bytecount_(nCount) LPCSTR lpszInData, _In_ LPVOID lpOutData);
	int Escape(_In_ int nEscape, _In_ int nInputSize, _In_bytecount_(nInputSize) LPCSTR lpszInputData,
		_In_ int nOutputSize, _Out_bytecap_(nOutputSize) LPSTR lpszOutputData);
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData);

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName);  // old Win3.0 version
	int StartDoc(LPDOCINFO lpDocInfo);
	int StartPage();
	int EndPage();
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int));
	int AbortDoc();
	int EndDoc();

// MetaFile Functions
	BOOL PlayMetaFile(HMETAFILE hMF);
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds);
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData);
		// can be used for enhanced metafiles only

// Path Functions
	BOOL AbortPath();
	BOOL BeginPath();
	BOOL CloseFigure();
	BOOL EndPath();
	BOOL FillPath();
	BOOL FlattenPath();
	BOOL StrokeAndFillPath();
	BOOL StrokePath();
	BOOL WidenPath();
	float GetMiterLimit() const;
	BOOL SetMiterLimit(float fMiterLimit);
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const;
	BOOL SelectClipPath(int nMode);

// Misc Helper Functions
	static CBrush* PASCAL GetHalftoneBrush();
	void DrawDragRect(LPCRECT lpRect, SIZE size,
		LPCRECT lpRectLast, SIZE sizeLast,
		CBrush* pBrush = NULL, CBrush* pBrushLast = NULL);
	void FillSolidRect(LPCRECT lpRect, COLORREF clr);
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr);
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight);
	void Draw3dRect(int x, int y, int cx, int cy,
		COLORREF clrTopLeft, COLORREF clrBottomRight);

// Implementation
public:
	virtual ~CDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// advanced use and implementation
	BOOL m_bPrinting;
	HGDIOBJ SelectObject(HGDIOBJ);      // do not use for regions

protected:
	// used for implementation of non-virtual SelectObject calls
	static CGdiObject* PASCAL SelectGdiObject(HDC hDC, HGDIOBJ h);
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
	DECLARE_DYNAMIC(CPaintDC)

// Constructors
public:
	explicit CPaintDC(CWnd* pWnd);   // BeginPaint

// Attributes
protected:
	HWND m_hWnd;
public:
	PAINTSTRUCT m_ps;       // actual paint struct!

// Implementation
public:
	virtual ~CPaintDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CClientDC : public CDC
{
	DECLARE_DYNAMIC(CClientDC)

// Constructors
public:
	explicit CClientDC(CWnd* pWnd);

// Attributes
protected:
	HWND m_hWnd;

// Implementation
public:
	virtual ~CClientDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

class CWindowDC : public CDC
{
	DECLARE_DYNAMIC(CWindowDC)

// Constructors
public:
	explicit CWindowDC(CWnd* pWnd);

// Attributes
protected:
	HWND m_hWnd;

// Implementation
public:
	virtual ~CWindowDC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CImageList

class CImageList : public CObject
{
	DECLARE_DYNCREATE(CImageList)

// Constructors
public:
	CImageList();
	BOOL Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow);
	BOOL Create(UINT nBitmapID, int cx, int nGrow, COLORREF crMask);
	BOOL Create(LPCTSTR lpszBitmapID, int cx, int nGrow, COLORREF crMask);
	BOOL Create(CImageList& imagelist1, int nImage1, CImageList& imagelist2,
		int nImage2, int dx, int dy);
	BOOL Create(CImageList* pImageList);

// Attributes
	HIMAGELIST m_hImageList;            // must be first data member
	operator HIMAGELIST() const;
	HIMAGELIST GetSafeHandle() const;

	static CImageList* PASCAL FromHandle(HIMAGELIST hImageList);
	static CImageList* PASCAL FromHandlePermanent(HIMAGELIST hImageList);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HIMAGELIST hImageList);
	HIMAGELIST Detach();

	int GetImageCount() const;
	COLORREF SetBkColor(COLORREF cr);
	COLORREF GetBkColor() const;
	BOOL GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const;

// Operations
	BOOL DeleteImageList();
	BOOL SetImageCount(UINT uNewCount);

	int Add(CBitmap* pbmImage, CBitmap* pbmMask);
	int Add(CBitmap* pbmImage, COLORREF crMask);
	BOOL Remove(int nImage);
	BOOL Replace(int nImage, CBitmap* pbmImage, CBitmap* pbmMask);
	int Add(HICON hIcon);
	int Replace(int nImage, HICON hIcon);
	HICON ExtractIcon(int nImage);
	BOOL Draw(CDC* pDC, int nImage, POINT pt, UINT nStyle);
	BOOL DrawEx(CDC* pDC, int nImage, POINT pt, SIZE sz, COLORREF clrBk, COLORREF clrFg, UINT nStyle);
	BOOL SetOverlayImage(int nImage, int nOverlay);
	BOOL Copy(int iDst, int iSrc, UINT uFlags = ILCF_MOVE);
	BOOL Copy(int iDst, CImageList* pSrc, int iSrc, UINT uFlags = ILCF_MOVE);
	BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
	BOOL DrawIndirect(CDC* pDC, int nImage, POINT pt, SIZE sz, POINT ptOrigin,
			UINT fStyle = ILD_NORMAL, DWORD dwRop = SRCCOPY,
			COLORREF rgbBack = CLR_DEFAULT, COLORREF rgbFore = CLR_DEFAULT,
			DWORD fState = ILS_NORMAL, DWORD Frame = 0, COLORREF crEffect = CLR_DEFAULT);

#ifndef _AFX_NO_OLE_SUPPORT
	BOOL Read(CArchive* pArchive);
	BOOL Write(CArchive* pArchive);
#endif

// Drag APIs
	BOOL BeginDrag(int nImage, CPoint ptHotSpot);
	static void PASCAL EndDrag();
	static BOOL PASCAL DragMove(CPoint pt);
	BOOL SetDragCursorImage(int nDrag, CPoint ptHotSpot);
	static BOOL PASCAL DragShowNolock(BOOL bShow);
	static CImageList* PASCAL GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot);
	static BOOL PASCAL DragEnter(CWnd* pWndLock, CPoint point);
	static BOOL PASCAL DragLeave(CWnd* pWndLock);

// Implementation
public:
	virtual ~CImageList();
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu : public CObject
{
	DECLARE_DYNCREATE(CMenu)
public:

// Constructors
	CMenu();

	BOOL CreateMenu();
	BOOL CreatePopupMenu();
	BOOL LoadMenu(LPCTSTR lpszResourceName);
	BOOL LoadMenu(UINT nIDResource);
	BOOL LoadMenuIndirect(const void* lpMenuTemplate);
	BOOL DestroyMenu();

// Attributes
	HMENU m_hMenu;          // must be first data member
	HMENU GetSafeHmenu() const;
	operator HMENU() const;

	static CMenu* PASCAL FromHandle(HMENU hMenu);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HMENU hMenu);
	HMENU Detach();

// CMenu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags);
	BOOL TrackPopupMenu(UINT nFlags, int x, int y,
						CWnd* pWnd, LPCRECT lpRect = 0);
	BOOL TrackPopupMenuEx(UINT fuFlags, int x, int y, CWnd* pWnd, LPTPMPARAMS lptpm);

#if(WINVER >= 0x0500)

	BOOL SetMenuInfo(LPCMENUINFO lpcmi);
	BOOL GetMenuInfo(LPMENUINFO lpcmi) const;

#endif

	BOOL operator==(const CMenu& menu) const;
	BOOL operator!=(const CMenu& menu) const;

// CMenuItem Operations
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp);
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck);
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable);
	int GetMenuItemCount() const;
	UINT GetMenuItemID(int nPos) const;
	UINT GetMenuState(UINT nID, UINT nFlags) const;
	int GetMenuString(_In_ UINT nIDItem, _Out_z_cap_(nMaxCount) LPTSTR lpString, _In_ int nMaxCount,
					_In_ UINT nFlags) const;
	int GetMenuString(UINT nIDItem, CString& rString, UINT nFlags) const;
	BOOL GetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
	BOOL SetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
	CMenu* GetSubMenu(int nPos) const;
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
					const CBitmap* pBmp);
	BOOL InsertMenuItem(UINT uItem, LPMENUITEMINFO lpMenuItemInfo,
					BOOL fByPos = FALSE);
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0,
					LPCTSTR lpszNewItem = NULL);
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
					const CBitmap* pBmp);
	BOOL RemoveMenu(UINT nPosition, UINT nFlags);
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
					const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked);
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags);
	BOOL SetDefaultItem(UINT uItem, BOOL fByPos = FALSE);
	UINT GetDefaultItem(UINT gmdiFlags, BOOL fByPos = FALSE);

// Context Help Functions
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId);
	DWORD GetMenuContextHelpId() const;

// Overridables (must override draw and measure for owner-draw menu items)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
public:
	virtual ~CMenu();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	static CMenu* PASCAL CMenu::FromHandlePermanent(HMENU hMenu);
};

/////////////////////////////////////////////////////////////////////////////
// Window message map handling

struct AFX_MSGMAP_ENTRY;       // declared below after CWnd

struct AFX_MSGMAP
{
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
	const AFX_MSGMAP_ENTRY* lpEntries;
};


#define DECLARE_MESSAGE_MAP() \
protected: \
	static const AFX_MSGMAP* PASCAL GetThisMessageMap(); \
	virtual const AFX_MSGMAP* GetMessageMap() const; \

#define BEGIN_TEMPLATE_MESSAGE_MAP(theClass, type_name, baseClass)			\
	PTM_WARNING_DISABLE														\
	template < typename type_name >											\
	const AFX_MSGMAP* theClass< type_name >::GetMessageMap() const			\
		{ return GetThisMessageMap(); }										\
	template < typename type_name >											\
	const AFX_MSGMAP* PASCAL theClass< type_name >::GetThisMessageMap()		\
	{																		\
		typedef theClass< type_name > ThisClass;							\
		typedef baseClass TheBaseClass;										\
		static const AFX_MSGMAP_ENTRY _messageEntries[] =					\
		{

#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
	PTM_WARNING_DISABLE \
	const AFX_MSGMAP* theClass::GetMessageMap() const \
		{ return GetThisMessageMap(); } \
	const AFX_MSGMAP* PASCAL theClass::GetThisMessageMap() \
	{ \
		typedef theClass ThisClass;						   \
		typedef baseClass TheBaseClass;					   \
		static const AFX_MSGMAP_ENTRY _messageEntries[] =  \
		{

#define END_MESSAGE_MAP() \
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
	}; \
		static const AFX_MSGMAP messageMap = \
		{ &TheBaseClass::GetThisMessageMap, &_messageEntries[0] }; \
		return &messageMap; \
	}								  \
	PTM_WARNING_RESTORE


// Message map signature values and macros in separate header
#include <afxmsg_.h>

/////////////////////////////////////////////////////////////////////////////
// Dialog data exchange (DDX_) and validation (DDV_)

class COleControlSite;

// CDataExchange - for data exchange and validation
class CDataExchange
{
// Attributes
public:
	BOOL m_bSaveAndValidate;   // TRUE => save and validate data
	CWnd* m_pDlgWnd;           // container usually a dialog

// Operations (for implementors of DDX and DDV procs)
	HWND PrepareCtrl(int nIDC);     
	HWND PrepareEditCtrl(int nIDC); 
	void Fail();                    // will throw exception

	CDataExchange(CWnd* pDlgWnd, BOOL bSaveAndValidate);

#ifndef _AFX_NO_OCC_SUPPORT
	COleControlSite* PrepareOleCtrl(int nIDC); // for OLE controls in dialog
#endif

// Implementation
   UINT m_idLastControl;      // last control used (for validation)
	BOOL m_bEditLastControl;   // last control was an edit item
};

#include <afxdd_.h>     // standard DDX_ and DDV_ routines

/////////////////////////////////////////////////////////////////////////////
// OLE types

typedef LONG HRESULT;

struct IUnknown;
typedef IUnknown* LPUNKNOWN;

struct IDispatch;
typedef IDispatch* LPDISPATCH;

struct IConnectionPoint;
typedef IConnectionPoint* LPCONNECTIONPOINT;

struct IEnumOLEVERB;
typedef IEnumOLEVERB* LPENUMOLEVERB;

typedef struct _GUID GUID;
typedef GUID IID;
typedef GUID CLSID;
#ifndef _REFCLSID_DEFINED
#define REFCLSID const CLSID &
#endif

typedef long DISPID;
typedef unsigned short VARTYPE;
typedef long SCODE;

typedef WCHAR OLECHAR;
typedef OLECHAR* BSTR;

struct tagDISPPARAMS;
typedef tagDISPPARAMS DISPPARAMS;

struct tagVARIANT;
typedef tagVARIANT VARIANT;

struct ITypeInfo;
typedef ITypeInfo* LPTYPEINFO;

struct ITypeLib;
typedef ITypeLib* LPTYPELIB;

struct IAccessible;
struct IAccessibleProxy;
struct IAccessibleServer;
struct IEnumVARIANT;

struct tagEXCEPINFO;
typedef tagEXCEPINFO EXCEPINFO;


/////////////////////////////////////////////////////////////////////////////
// CCmdTarget

// private structures
struct AFX_CMDHANDLERINFO;  // info about where the command is handled
struct AFX_EVENT;           // info about an event
class CTypeLibCache;        // cache for OLE type libraries

/////////////////////////////////////////////////////////////////////////////
// OLE interface map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_INTERFACEMAP_ENTRY
{
	const void* piid;       // the interface id (IID) (NULL for aggregate)
	size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_INTERFACEMAP
{
#ifdef _AFXDLL
	const AFX_INTERFACEMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
	const AFX_INTERFACEMAP* pBaseMap;
#endif
	const AFX_INTERFACEMAP_ENTRY* pEntry; // map for this class
};


#ifdef _AFXDLL
#define DECLARE_INTERFACE_MAP() \
private: \
	static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
	static const AFX_INTERFACEMAP interfaceMap; \
	static const AFX_INTERFACEMAP* PASCAL GetThisInterfaceMap(); \
	virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#else
#define DECLARE_INTERFACE_MAP() \
private: \
	static const AFX_INTERFACEMAP_ENTRY _interfaceEntries[]; \
protected: \
	static const AFX_INTERFACEMAP interfaceMap; \
	virtual const AFX_INTERFACEMAP* GetInterfaceMap() const; \

#endif

/////////////////////////////////////////////////////////////////////////////
// OLE COM (Component Object Model) implementation infrastructure
//      - data driven QueryInterface
//      - standard implementation of aggregate AddRef and Release
// (see CCmdTarget in AFXWIN.H for more information)

#define METHOD_PROLOGUE(theClass, localClass) \
	theClass* pThis = \
		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
	AFX_MANAGE_STATE(pThis->m_pModuleState) \
	pThis; // avoid warning from compiler \

#define METHOD_PROLOGUE_(theClass, localClass) \
	theClass* pThis = \
		((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
	pThis; // avoid warning from compiler \

#ifndef _AFX_NO_NESTED_DERIVATION
#define METHOD_PROLOGUE_EX(theClass, localClass) \
	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
	AFX_MANAGE_STATE(pThis->m_pModuleState) \
	pThis; // avoid warning from compiler \

#define METHOD_PROLOGUE_EX_(theClass, localClass) \
	theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
	pThis; // avoid warning from compiler \

#else
#define METHOD_PROLOGUE_EX(theClass, localClass) \
	METHOD_PROLOGUE(theClass, localClass) \

#define METHOD_PROLOGUE_EX_(theClass, localClass) \
	METHOD_PROLOGUE_(theClass, localClass) \

#endif

// Provided only for compatibility with CDK 1.x
#define METHOD_MANAGE_STATE(theClass, localClass) \
	METHOD_PROLOGUE_EX(theClass, localClass) \

#define BEGIN_INTERFACE_PART(localClass, baseClass) \
	class X##localClass : public baseClass \
	{ \
	public: \
		STDMETHOD_(ULONG, AddRef)(); \
		STDMETHOD_(ULONG, Release)(); \
		STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj); \

#ifndef _AFX_NO_NESTED_DERIVATION
#define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
	class X##localClass : public baseClass \
	{ \
	public: \

#else
#define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
	BEGIN_INTERFACE_PART(localClass, baseClass) \

#endif

#ifndef _AFX_NO_NESTED_DERIVATION
#define INIT_INTERFACE_PART(theClass, localClass) \
		size_t m_nOffset; \
		INIT_INTERFACE_PART_DERIVE(theClass, localClass) \

#define INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
		X##localClass() \
			{ m_nOffset = offsetof(theClass, m_x##localClass); } \

#else
#define INIT_INTERFACE_PART(theClass, localClass)
#define INIT_INTERFACE_PART_DERIVE(theClass, localClass)

#endif

// Note: Inserts the rest of OLE functionality between these two macros,
//  depending upon the interface that is being implemented.  It is not
//  necessary to include AddRef, Release, and QueryInterface since those
//  member functions are declared by the macro.

#define END_INTERFACE_PART(localClass) \
	} m_x##localClass; \
	friend class X##localClass; \

struct CInterfacePlaceHolder
{
	DWORD_PTR m_vtbl;   // filled in with USE_INTERFACE_PART
	CInterfacePlaceHolder() { m_vtbl = 0; }
};

#define END_INTERFACE_PART_OPTIONAL(localClass) \
	}; \
	CInterfacePlaceHolder m_x##localClass; \
	friend class X##localClass; \

#ifdef _AFXDLL
#define END_INTERFACE_PART_STATIC END_INTERFACE_PART
#else
#define END_INTERFACE_PART_STATIC END_INTERFACE_PART
#endif

#define USE_INTERFACE_PART(localClass) \
	m_x##localClass.m_vtbl = *(DWORD_PTR*)&X##localClass(); \

// To avoid C4238.
#define USE_INTERFACE_PART_STD(localClass) \
	X##localClass tmp##localClass; \
	m_x##localClass.m_vtbl = *(DWORD_PTR*)&tmp##localClass;

#ifdef _AFXDLL
#define BEGIN_INTERFACE_MAP(theClass, theBase) \
	const AFX_INTERFACEMAP* PASCAL theClass::GetThisInterfaceMap() \
		{ return &theClass::interfaceMap; } \
	const AFX_INTERFACEMAP* theClass::GetInterfaceMap() const \
		{ return &theClass::interfaceMap; } \
	AFX_COMDAT const AFX_INTERFACEMAP theClass::interfaceMap = \
		{ &theBase::GetThisInterfaceMap, &theClass::_interfaceEntries[0], }; \
	AFX_COMDAT const AFX_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
	{ \

#else
#define BEGIN_INTERFACE_MAP(theClass, theBase) \
	const AFX_INTERFACEMAP* theClass::GetInterfaceMap() const \
		{ return &theClass::interfaceMap; } \
	AFX_COMDAT const AFX_INTERFACEMAP theClass::interfaceMap = \
		{ &theBase::interfaceMap, &theClass::_interfaceEntries[0], }; \
	AFX_COMDAT const AFX_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
	{ \

#endif

#define INTERFACE_PART(theClass, iid, localClass) \
		{ &iid, offsetof(theClass, m_x##localClass) }, \

#define INTERFACE_AGGREGATE(theClass, theAggr) \
		{ NULL, offsetof(theClass, theAggr) }, \

#define END_INTERFACE_MAP() \
		{ NULL, (size_t)-1 } \
	}; \


#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE dispatch map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_DISPMAP_ENTRY;

struct AFX_DISPMAP
{
#ifdef _AFXDLL
	const AFX_DISPMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_DISPMAP* pBaseMap;
#endif
	const AFX_DISPMAP_ENTRY* lpEntries;
	UINT* lpEntryCount;
	DWORD* lpStockPropMask;
};

#ifdef _AFXDLL
#define DECLARE_DISPATCH_MAP() \
private: \
	static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
	static UINT _dispatchEntryCount; \
	static DWORD _dwStockPropMask; \
protected: \
	static const AFX_DISPMAP dispatchMap; \
	static const AFX_DISPMAP* PASCAL GetThisDispatchMap(); \
	virtual const AFX_DISPMAP* GetDispatchMap() const; \

#else
#define DECLARE_DISPATCH_MAP() \
private: \
	static const AFX_DISPMAP_ENTRY _dispatchEntries[]; \
	static UINT _dispatchEntryCount; \
	static DWORD _dwStockPropMask; \
protected: \
	static const AFX_DISPMAP dispatchMap; \
	virtual const AFX_DISPMAP* GetDispatchMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE Document Object command target handling

#ifndef _AFX_NO_DOCOBJECT_SUPPORT

struct AFX_OLECMDMAP_ENTRY
{
   const GUID* pguid;   // id of the command group
   ULONG       cmdID;   // OLECMD ID
   UINT        nID;     // corresponding WM_COMMAND message ID
};

struct AFX_OLECMDMAP
{
#ifdef _AFXDLL
	const AFX_OLECMDMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_OLECMDMAP* pBaseMap;
#endif
	const AFX_OLECMDMAP_ENTRY* lpEntries;
};

#ifdef _AFXDLL
#define DECLARE_OLECMD_MAP() \
private: \
	static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
	static const AFX_OLECMDMAP commandMap; \
	static const AFX_OLECMDMAP* PASCAL GetThisCommandMap(); \
	virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#else
#define DECLARE_OLECMD_MAP() \
private: \
	static const AFX_OLECMDMAP_ENTRY _commandEntries[]; \
protected: \
	static const AFX_OLECMDMAP commandMap; \
	virtual const AFX_OLECMDMAP* GetCommandMap() const; \

#endif

#ifdef _AFXDLL
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
	const AFX_OLECMDMAP* PASCAL theClass::GetThisCommandMap() \
		{ return &theClass::commandMap; } \
	const AFX_OLECMDMAP* theClass::GetCommandMap() const \
		{ return &theClass::commandMap; } \
	AFX_COMDAT const AFX_OLECMDMAP theClass::commandMap = \
	{ &baseClass::GetThisCommandMap, &theClass::_commandEntries[0] }; \
	AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
	{ \

#else
#define BEGIN_OLECMD_MAP(theClass, baseClass) \
	const AFX_OLECMDMAP* theClass::GetCommandMap() const \
		{ return &theClass::commandMap; } \
	AFX_COMDAT const AFX_OLECMDMAP theClass::commandMap = \
	{ &baseClass::commandMap, &theClass::_commandEntries[0] }; \
	AFX_COMDAT const AFX_OLECMDMAP_ENTRY theClass::_commandEntries[] = \
	{ \

#endif

#define END_OLECMD_MAP() \
		{NULL, 0, 0} \
	}; \

class COleCmdUI;

#endif //!_AFX_NO_DOCOBJECT_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE event sink map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OCC_SUPPORT

struct AFX_EVENTSINKMAP_ENTRY;

struct AFX_EVENTSINKMAP
{
#ifdef _AFXDLL
	const AFX_EVENTSINKMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_EVENTSINKMAP* pBaseMap;
#endif
	const AFX_EVENTSINKMAP_ENTRY* lpEntries;
	UINT* lpEntryCount;
};

#ifdef _AFXDLL
#define DECLARE_EVENTSINK_MAP() \
private: \
	static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
	static UINT _eventsinkEntryCount; \
protected: \
	static const AFX_EVENTSINKMAP eventsinkMap; \
	static const AFX_EVENTSINKMAP* PASCAL GetThisEventSinkMap(); \
	virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#else
#define DECLARE_EVENTSINK_MAP() \
private: \
	static const AFX_EVENTSINKMAP_ENTRY _eventsinkEntries[]; \
	static UINT _eventsinkEntryCount; \
protected: \
	static const AFX_EVENTSINKMAP eventsinkMap; \
	virtual const AFX_EVENTSINKMAP* GetEventSinkMap() const; \

#endif

#endif //!_AFX_NO_OCC_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// OLE connection map handling (more in AFXDISP.H)

#ifndef _AFX_NO_OLE_SUPPORT

struct AFX_CONNECTIONMAP_ENTRY
{
	const void* piid;   // the interface id (IID)
	size_t nOffset;         // offset of the interface vtable from m_unknown
};

struct AFX_CONNECTIONMAP
{
#ifdef _AFXDLL
	const AFX_CONNECTIONMAP* (PASCAL* pfnGetBaseMap)(); // NULL is root class
#else
	const AFX_CONNECTIONMAP* pBaseMap;
#endif
	const AFX_CONNECTIONMAP_ENTRY* pEntry; // map for this class
};

#ifdef _AFXDLL
#define DECLARE_CONNECTION_MAP() \
private: \
	static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
	static const AFX_CONNECTIONMAP connectionMap; \
	static const AFX_CONNECTIONMAP* PASCAL GetThisConnectionMap(); \
	virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#else
#define DECLARE_CONNECTION_MAP() \
private: \
	static const AFX_CONNECTIONMAP_ENTRY _connectionEntries[]; \
protected: \
	static const AFX_CONNECTIONMAP connectionMap; \
	virtual const AFX_CONNECTIONMAP* GetConnectionMap() const; \

#endif

#endif //!_AFX_NO_OLE_SUPPORT

/////////////////////////////////////////////////////////////////////////////
// CCmdTarget proper

#ifndef _AFX_NO_OCC_SUPPORT
class COccManager;      // forward reference (see ..\src\occimpl.h)
#endif

class AFX_NOVTABLE CCmdTarget : public CObject
{
	DECLARE_DYNAMIC(CCmdTarget)
protected:

public:
// Constructors
	CCmdTarget();

// Attributes
	LPDISPATCH GetIDispatch(BOOL bAddRef);
		// retrieve IDispatch part of CCmdTarget
	static CCmdTarget* PASCAL FromIDispatch(LPDISPATCH lpDispatch);
		// map LPDISPATCH back to CCmdTarget* (inverse of GetIDispatch)
	BOOL IsResultExpected();
		// returns TRUE if automation function should return a value

// Operations
	void EnableAutomation();
		// call in constructor to wire up IDispatch
	void EnableConnections();
		// call in constructor to wire up IConnectionPointContainer

	void BeginWaitCursor();
	void EndWaitCursor();
	void RestoreWaitCursor();       // call after messagebox

#ifndef _AFX_NO_OLE_SUPPORT
	// dispatch OLE verbs through the message map
	BOOL EnumOleVerbs(LPENUMOLEVERB* ppenumOleVerb);
	BOOL DoOleVerb(LONG iVerb, LPMSG lpMsg, HWND hWndParent, LPCRECT lpRect);
#endif

// Overridables
	// route and dispatch standard command message types
	//   (more sophisticated than OnCommand)
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

#ifndef _AFX_NO_OLE_SUPPORT
	// called when last OLE reference is released
	virtual void OnFinalRelease();
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// called before dispatching to an automation handler function
	virtual BOOL IsInvokeAllowed(DISPID dispid);
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	// support for OLE type libraries
	void EnableTypeLib();
	HRESULT GetTypeInfoOfGuid(LCID lcid, const GUID& guid,
		LPTYPEINFO* ppTypeInfo);
	virtual BOOL GetDispatchIID(IID* pIID);
	virtual UINT GetTypeInfoCount();
	virtual CTypeLibCache* GetTypeLibCache();
	virtual HRESULT GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib);
#endif

// Implementation
public:
	virtual ~CCmdTarget() = 0;
#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#endif
#ifndef _AFX_NO_OLE_SUPPORT
	void GetNotSupported();
	void SetNotSupported();
#endif

protected:
	friend class CView;

	CView* GetRoutingView();
	CFrameWnd* GetRoutingFrame();
	static CView* PASCAL GetRoutingView_();
	static CFrameWnd* PASCAL GetRoutingFrame_();
	DECLARE_MESSAGE_MAP()       // base class - no {{ }} macros

#ifndef _AFX_NO_DOCOBJECT_SUPPORT
	DECLARE_OLECMD_MAP()
	friend class COleCmdUI;
#endif

#ifndef _AFX_NO_OLE_SUPPORT
	DECLARE_DISPATCH_MAP()
	DECLARE_CONNECTION_MAP()
	DECLARE_INTERFACE_MAP()

#ifndef _AFX_NO_OCC_SUPPORT
	DECLARE_EVENTSINK_MAP()
#endif // !_AFX_NO_OCC_SUPPORT

	// OLE interface map implementation
public:
	// data used when CCmdTarget is made OLE aware
	long m_dwRef;
	LPUNKNOWN m_pOuterUnknown;  // external controlling unknown if != NULL
	DWORD_PTR m_xInnerUnknown;  // place-holder for inner controlling unknown

public:
	// advanced operations
	void EnableAggregation();       // call to enable aggregation
	void ExternalDisconnect();      // forcibly disconnect
	LPUNKNOWN GetControllingUnknown();
		// get controlling IUnknown for aggregate creation

	// these versions do not delegate to m_pOuterUnknown
	DWORD InternalQueryInterface(const void*, LPVOID* ppvObj);
	DWORD InternalAddRef();
	DWORD InternalRelease();
	// these versions delegate to m_pOuterUnknown
	DWORD ExternalQueryInterface(const void*, LPVOID* ppvObj);
	DWORD ExternalAddRef();
	DWORD ExternalRelease();

	// implementation helpers
	LPUNKNOWN GetInterface(const void*);
	LPUNKNOWN QueryAggregates(const void*);

	// advanced overrideables for implementation
	virtual BOOL OnCreateAggregates();
	virtual LPUNKNOWN GetInterfaceHook(const void*);

	// OLE automation implementation
protected:
	struct XDispatch
	{
		DWORD_PTR m_vtbl;   // place-holder for IDispatch vtable
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
#endif
	} m_xDispatch;
	BOOL m_bResultExpected;

	// member variable-based properties
	void GetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
		VARIANT* pvarResult, UINT* puArgErr);
	SCODE SetStandardProp(const AFX_DISPMAP_ENTRY* pEntry,
		DISPPARAMS* pDispParams, UINT* puArgErr);

	// DISPID to dispatch map lookup
	static UINT PASCAL GetEntryCount(const AFX_DISPMAP* pDispMap);
	const AFX_DISPMAP_ENTRY* PASCAL GetDispEntry(LONG memid);
	static LONG PASCAL MemberIDFromName(const AFX_DISPMAP* pDispMap, LPCTSTR lpszName);

	// helpers for member function calling implementation
	static UINT PASCAL GetStackSize(const BYTE* pbParams, VARTYPE vtResult);
#ifdef _SHADOW_DOUBLES
	SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
		void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
		UINT* puArgErr, VARIANT* rgTempVars, UINT nSizeArgs,CVariantBoolConverter* pTempStackArgs = NULL);
#else
	SCODE PushStackArgs(BYTE* pStack, const BYTE* pbParams,
		void* pResult, VARTYPE vtResult, DISPPARAMS* pDispParams,
		UINT* puArgErr, VARIANT* rgTempVars,CVariantBoolConverter* pTempStackArgs = NULL);
#endif
	SCODE CallMemberFunc(const AFX_DISPMAP_ENTRY* pEntry, WORD wFlags,
		VARIANT* pvarResult, DISPPARAMS* pDispParams, UINT* puArgErr);

	friend class COleDispatchImpl;

#ifndef _AFX_NO_OCC_SUPPORT
public:
	// OLE event sink implementation
	BOOL OnEvent(UINT idCtrl, AFX_EVENT* pEvent,
		AFX_CMDHANDLERINFO* pHandlerInfo);
protected:
	const AFX_EVENTSINKMAP_ENTRY* PASCAL GetEventSinkEntry(UINT idCtrl,
		AFX_EVENT* pEvent);
#endif // !_AFX_NO_OCC_SUPPORT

	// OLE connection implementation
	struct XConnPtContainer
	{
		DWORD_PTR m_vtbl;   // place-holder for IConnectionPointContainer vtable
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
#endif
	} m_xConnPtContainer;

	AFX_MODULE_STATE* m_pModuleState;
	friend class CInnerUnknown;
	friend UINT APIENTRY _AfxThreadEntry(void* pParam);

	virtual BOOL GetExtraConnectionPoints(CPtrArray* pConnPoints);
	virtual LPCONNECTIONPOINT GetConnectionHook(const IID& iid);

	friend class COleConnPtContainer;

#endif //!_AFX_NO_OLE_SUPPORT
};

class CCmdUI        // simple helper class
{
public:
// Attributes
	UINT m_nID;
	UINT m_nIndex;          // menu item or other index

	// if a menu item
	CMenu* m_pMenu;         // NULL if not a menu
	CMenu* m_pSubMenu;      // sub containing menu item
							// if a popup sub menu - ID is for first in popup

	// if from some other window
	CWnd* m_pOther;         // NULL if a menu or not a CWnd

// Operations to do in ON_UPDATE_COMMAND_UI
	virtual void Enable(BOOL bOn = TRUE);
	virtual void SetCheck(int nCheck = 1);   // 0, 1 or 2 (indeterminate)
	virtual void SetRadio(BOOL bOn = TRUE);
	virtual void SetText(LPCTSTR lpszText);

// Advanced operation
	void ContinueRouting();

// Implementation
	CCmdUI();
	BOOL m_bEnableChanged;
	BOOL m_bContinueRouting;
	UINT m_nIndexMax;       // last + 1 for iterating m_nIndex

	CMenu* m_pParentMenu;   // NULL if parent menu not easily determined
							//  (probably a secondary popup menu)

	BOOL DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
};

// special CCmdUI derived classes are used for other UI paradigms
//  like toolbar buttons and status indicators

// pointer to afx_msg member function
#ifndef AFX_MSG_CALL
#define AFX_MSG_CALL
#endif
typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);

enum AFX_DISPMAP_FLAGS
{
	afxDispCustom = 0,
	afxDispStock = 1
};

#pragma warning( disable: 4121 )
struct AFX_DISPMAP_ENTRY
{
	LPCTSTR lpszName;       // member/property name
	long lDispID;           // DISPID (may be DISPID_UNKNOWN)
	LPCSTR lpszParams;      // member parameter description
	WORD vt;                // return value type / or type of property
	AFX_PMSG pfn;           // normal member On<membercall> or, OnGet<property>
	AFX_PMSG pfnSet;        // special member for OnSet<property>
	size_t nPropOffset;     // property offset
	AFX_DISPMAP_FLAGS flags;// flags (e.g. stock/custom)
};
#pragma warning( default: 4121 )

struct AFX_EVENTSINKMAP_ENTRY
{
	AFX_DISPMAP_ENTRY dispEntry;
	UINT nCtrlIDFirst;
	UINT nCtrlIDLast;
};

// DSC Sink state/reason codes passed to MFC user event handlers
enum DSCSTATE
{
	dscNoState = 0,
	dscOKToDo,
	dscCancelled,
	dscSyncBefore,
	dscAboutToDo,
	dscFailedToDo,
	dscSyncAfter,
	dscDidEvent
};

enum DSCREASON
{
	dscNoReason = 0,
	dscClose,
	dscCommit,
	dscDelete,
	dscEdit,
	dscInsert,
	dscModify,
	dscMove
};

/////////////////////////////////////////////////////////////////////////////
// CWnd implementation

#if (WINVER >= 0x0601)

/// <summary>
/// CGestureConfig class allows to customize Windows gesture features such as zoom, pan or rotate. This class is used in CWnd::SetGestureConfig and CWnd::GetGestureConfig methods.</summary>
class CGestureConfig : public CObject
{
	friend class CWnd;

public:
	/// <summary>
	/// CGestureConfig constructor</summary>
	CGestureConfig();

	/// <summary>
	/// CGestureConfig destructor</summary>
	virtual ~CGestureConfig();

	/// <summary>
	/// Enable/disable gesture zoom</summary>
	/// <param name="bEnable">TRUE - enable the feature. FALSE - disable it</param>
	void EnableZoom(BOOL bEnable = TRUE);

	/// <summary>
	/// Enable/disable gesture rotate</summary>
	/// <param name="bEnable">TRUE - enable the feature. FALSE - disable it</param>
	void EnableRotate(BOOL bEnable = TRUE);

	/// <summary>
	/// Enable/disable gesture 2 finger tap</summary>
	/// <param name="bEnable">TRUE - enable the feature. FALSE - disable it</param>
	void EnableTwoFingerTap(BOOL bEnable = TRUE);

	/// <summary>
	/// Enable/disable gesture press and tap</summary>
	/// <param name="bEnable">TRUE - enable the feature. FALSE - disable it</param>
	void EnablePressAndTap(BOOL bEnable = TRUE);

	/// <summary>
	/// Enable/disable gesture pan</summary>
	/// <param name="bEnable">TRUE - enable the feature. FALSE - disable it</param>
	/// <param name="dwFlags">Gesture pan flags. Can be either GC_PAN (all pan gestures) or combination of the following flags: GC_PAN_WITH_SINGLE_FINGER_VERTICALLY, GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY, GC_PAN_WITH_GUTTER and GC_PAN_WITH_INTERTIA</param>
	void EnablePan(BOOL bEnable = TRUE, DWORD dwFlags = GC_PAN_WITH_GUTTER | GC_PAN_WITH_INERTIA);

	/// <summary>
	/// Determines whether the gesture zoom feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsZoomEnabled() const { return (Get(GID_ZOOM) & GC_ZOOM) == GC_ZOOM; }

	/// <summary>
	/// Determines whether the gesture rotate feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsRotateEnabled() const { return (Get(GID_ROTATE) & GC_ROTATE) == GC_ROTATE; }

	/// <summary>
	/// Determines whether the gesture 2 finger tap feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsTwoFingerTapEnabled() const { return (Get(GID_TWOFINGERTAP) & GC_TWOFINGERTAP) == GC_TWOFINGERTAP; }

#if defined(GID_PRESSANDTAP) && defined(GC_PRESSANDTAP)
	/// <summary>
	/// Determines whether the gesture "press and tap" feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPressAndTapEnabled() const { return (Get(GID_PRESSANDTAP) & GC_PRESSANDTAP) == GC_PRESSANDTAP; }
#endif

	/// <summary>
	/// Determines whether the gesture pan feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPanAllEnabled() const { return (Get(GID_PAN) & GC_PAN) == GC_PAN; }

	/// <summary>
	/// Determines whether the gesture pan vertical feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPanVerticalEnabled() const { return (Get(GID_PAN) & GC_PAN_WITH_SINGLE_FINGER_VERTICALLY) == GC_PAN_WITH_SINGLE_FINGER_VERTICALLY; }

	/// <summary>
	/// Determines whether the gesture pan horizontal feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPanHorizontalEnabled() const { return (Get(GID_PAN) & GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY) == GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY; }

	/// <summary>
	/// Determines whether the gesture pan with gutter feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPanWithGutterEnabled() const { return (Get(GID_PAN) & GC_PAN_WITH_GUTTER) == GC_PAN_WITH_GUTTER; }

	/// <summary>
	/// Determines whether the gesture pan with inertia feature is enabled</summary>
	/// <returns> 
	/// TRUE if the feature is enabled; otherwise FALSE.</returns>
	BOOL IsPanWithInertiaEnabled() const { return (Get(GID_PAN) & GC_PAN_WITH_INERTIA) == GC_PAN_WITH_INERTIA; }

	/// <summary>
	/// Modify specific gesture touch paramaters</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="dwID">Gesture feature ID. Can be one of the following: GID_ZOOM, GID_PAN, GID_ROTATE, GID_TWOFINGERTAP or GID_PRESSANDTAP</param>
	/// <param name="dwWant">Gesture features to enable. Can be 0 or GC_ALLGESTURES for all features except GID_PAN and GC_PAN or combination of the following flags: GC_PAN_WITH_SINGLE_FINGER_VERTICALLY, GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY, GC_PAN_WITH_GUTTER and GC_PAN_WITH_INTERTIA for gesture pan</param>
	BOOL Modify(DWORD dwID, DWORD dwWant = GC_ALLGESTURES, DWORD dwBlock = 0);

	/// <summary>
	/// Obtains a specific gesture touch paramaters</summary>
	/// <returns> 
	/// Gesture features. Can be 0 or GC_ALLGESTURES for all features except GID_PAN and GC_PAN or combination of the following flags: GC_PAN_WITH_SINGLE_FINGER_VERTICALLY, GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY, GC_PAN_WITH_GUTTER and GC_PAN_WITH_INTERTIA for gesture pan</returns>
	/// <param name="dwID">Gesture feature ID. Can be one of the following: GID_ZOOM, GID_PAN, GID_ROTATE, GID_TWOFINGERTAP or GID_PRESSANDTAP</param>
	/// <param name="bWant">TRUE - the method returns the enabled features; FALSE - disabled</param>
	DWORD Get(DWORD dwID, BOOL bWant = TRUE) const;

#ifdef _DEBUG
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	PGESTURECONFIG m_pConfigs;
	int	m_nConfigs;
};
#endif


/////////////////////////////////////////////////////////////////////////////
// CWnd implementation

// structures (see afxext.h)
struct CCreateContext;      // context for creating things
struct CPrintInfo;          // print preview customization info

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT_PTR nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // routine to call (or special value)
};

/////////////////////////////////////////////////////////////////////////////
// CWnd - a Microsoft Windows application window

class COleDropTarget;   // for more information see AFXOLE.H
class COleControlContainer;
class COleControlSite;

// CWnd::m_nFlags (generic to CWnd)
#define WF_TOOLTIPS         0x0001  // window is enabled for tooltips
#define WF_TEMPHIDE         0x0002  // window is temporarily hidden
#define WF_STAYDISABLED     0x0004  // window should stay disabled
#define WF_MODALLOOP        0x0008  // currently in modal loop
#define WF_CONTINUEMODAL    0x0010  // modal loop should continue running
#define WF_OLECTLCONTAINER  0x0100  // some descendant is an OLE control
#define WF_TRACKINGTOOLTIPS 0x0400  // window is enabled for tracking tooltips

// CWnd::m_nFlags (specific to CFrameWnd)
#define WF_STAYACTIVE       0x0020  // look active even though not active
#define WF_NOPOPMSG         0x0040  // ignore WM_POPMESSAGESTRING calls
#define WF_MODALDISABLE     0x0080  // window is disabled
#define WF_KEEPMINIACTIVE   0x0200  // stay activate even though you are deactivated


#define WF_NOWIN32ISDIALOGMSG   0x0800
#define WF_ISWINFORMSVIEWWND    0x1000

// flags for CWnd::RunModalLoop
#define MLF_NOIDLEMSG       0x0001  // don't send WM_ENTERIDLE messages
#define MLF_NOKICKIDLE      0x0002  // don't send WM_KICKIDLE messages
#define MLF_SHOWONIDLE      0x0004  // show window if not visible at idle time

// extra MFC defined TTF_ flags for TOOLINFO::uFlags
#define TTF_NOTBUTTON       0x80000000L // no status help on buttondown
#define TTF_ALWAYSTIP       0x40000000L // always show the tip even if not active

#if (WINVER < 0x0601)
typedef struct tagTOUCHINPUT {
} TOUCHINPUT, *PTOUCHINPUT;
typedef struct tagGESTUREINFO {
} GESTUREINFO, *PGESTUREINFO;
#endif

class CWnd : public CCmdTarget
{
	DECLARE_DYNCREATE(CWnd)
protected:
	static const MSG* PASCAL GetCurrentMessage();

// Attributes
public:
	HWND m_hWnd;            // must be first data member
	operator HWND() const;
	BOOL operator==(const CWnd& wnd) const;
	BOOL operator!=(const CWnd& wnd) const;

	HWND GetSafeHwnd() const;
	DWORD GetStyle() const;
	DWORD GetExStyle() const;
	BOOL ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);
	BOOL ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags = 0);

	CWnd* GetOwner() const;
	void SetOwner(CWnd* pOwnerWnd);


#if(WINVER >= 0x0500)

	BOOL GetWindowInfo(PWINDOWINFO pwi) const;
	BOOL GetTitleBarInfo(PTITLEBARINFO pti) const;

#endif	// WINVER >= 0x0500

// Constructors and other creation
	CWnd();

	static CWnd* PASCAL FromHandle(HWND hWnd);
	static CWnd* PASCAL FromHandlePermanent(HWND hWnd);
	static void PASCAL DeleteTempMap();
	BOOL Attach(HWND hWndNew);
	HWND Detach();

	// subclassing/unsubclassing functions
	virtual void PreSubclassWindow();
	BOOL SubclassWindow(HWND hWnd);
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
	HWND UnsubclassWindow();

	// handling of RT_DLGINIT resource (extension to RT_DIALOG)
	BOOL ExecuteDlgInit(LPCTSTR lpszResourceName);
	BOOL ExecuteDlgInit(LPVOID lpResource);

public:
	// for child windows, views, panes etc
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);

	// advanced creation (allows access to extended styles)
	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		int x, int y, int nWidth, int nHeight,
		HWND hWndParent, HMENU nIDorHMenu, LPVOID lpParam = NULL);

	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		LPVOID lpParam = NULL);

#ifndef _AFX_NO_OCC_SUPPORT
	// for wrapping OLE controls
	BOOL CreateControl(REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
		BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);

	BOOL CreateControl(LPCTSTR pszClass, LPCTSTR pszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID, CFile* pPersist=NULL,
		BOOL bStorage=FALSE, BSTR bstrLicKey=NULL);

   // Another overload for creating controls that use default extents.
   BOOL CreateControl( REFCLSID clsid, LPCTSTR pszWindowName, DWORD dwStyle,
	  const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID,
	  CFile* pPersist = NULL, BOOL bStorage = FALSE, BSTR bstrLicKey = NULL );


   //Overload for special controls (WinForms), that require more than CLSID.
   BOOL CreateControl(const CControlCreationInfo& creationInfo, DWORD dwStyle,
	const POINT* ppt, const SIZE* psize, CWnd* pParentWnd, UINT nID);

	LPUNKNOWN GetControlUnknown();
	BOOL PaintWindowlessControls(CDC *pDC);
#endif

	virtual BOOL DestroyWindow();

	// special pre-creation and window rect adjustment hooks
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// Advanced: virtual AdjustWindowRect
	enum AdjustType { adjustBorder = 0, adjustOutside = 1 };
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

// Window tree access
	int GetDlgCtrlID() const;
	int SetDlgCtrlID(int nID);
		// get and set window ID, for child windows only
	CWnd* GetDlgItem(int nID) const;
		// get immediate child with given ID
	void GetDlgItem(int nID, HWND* phWnd) const;
		// as above, but returns HWND
	CWnd* GetDescendantWindow(int nID, BOOL bOnlyPerm = FALSE) const;
		// like GetDlgItem but recursive
	void SendMessageToDescendants(UINT message, WPARAM wParam = 0,
		LPARAM lParam = 0, BOOL bDeep = TRUE, BOOL bOnlyPerm = FALSE);
	CFrameWnd* GetParentFrame() const;
	CFrameWnd* EnsureParentFrame() const;
	CWnd* GetTopLevelParent() const;
	CWnd* EnsureTopLevelParent() const;
	CWnd* GetTopLevelOwner() const;
	CWnd* GetParentOwner() const;
	CFrameWnd* GetTopLevelFrame() const;
	static CWnd* PASCAL GetSafeOwner(CWnd* pParent = NULL, HWND* pWndTop = NULL);

#if(WINVER >= 0x0500)

	CWnd* GetAncestor(UINT gaFlags) const;

#endif	// WINVER >= 0x0500

// Message Functions
#pragma push_macro("SendMessage")
#undef SendMessage
	LRESULT _AFX_FUNCNAME(SendMessage)(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) const;
	LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0) const;
#pragma pop_macro("SendMessage")
	BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);

	BOOL SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam);
	BOOL SendChildNotifyLastMsg(LRESULT* pResult = NULL);

	BOOL DragDetect(POINT pt) const;


// Message processing for modeless dialog-like windows
	BOOL IsDialogMessage(LPMSG lpMsg);

// Window Text Functions
	void SetWindowText(LPCTSTR lpszString);
	int GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszStringBuf, _In_ int nMaxCount) const;
	void GetWindowText(CString& rString) const;
	int GetWindowTextLength() const;
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE);
	CFont* GetFont() const;

// CMenu Functions - non-Child windows only
	virtual CMenu* GetMenu() const;
	virtual BOOL SetMenu(CMenu* pMenu);
	void DrawMenuBar();
	CMenu* GetSystemMenu(BOOL bRevert) const;
	BOOL HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite);

// Window Size and Position Functions
	BOOL IsIconic() const;
	BOOL IsZoomed() const;
	void MoveWindow(int x, int y, int nWidth, int nHeight,
				BOOL bRepaint = TRUE);
	void MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE);
	int SetWindowRgn(HRGN hRgn, BOOL bRedraw);
	int GetWindowRgn(HRGN hRgn) const;

	static AFX_DATA const CWnd wndTop; // SetWindowPos's pWndInsertAfter
	static AFX_DATA const CWnd wndBottom; // SetWindowPos's pWndInsertAfter
	static AFX_DATA const CWnd wndTopMost; // SetWindowPos pWndInsertAfter
	static AFX_DATA const CWnd wndNoTopMost; // SetWindowPos pWndInsertAfter

	BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
				int cx, int cy, UINT nFlags);
	UINT ArrangeIconicWindows();
	void BringWindowToTop();
	void GetWindowRect(LPRECT lpRect) const;
	void GetClientRect(LPRECT lpRect) const;

	BOOL GetWindowPlacement(WINDOWPLACEMENT* lpwndpl) const;
	BOOL SetWindowPlacement(const WINDOWPLACEMENT* lpwndpl);

// Coordinate Mapping Functions
	void ClientToScreen(LPPOINT lpPoint) const;
	void ClientToScreen(LPRECT lpRect) const;
	void ScreenToClient(LPPOINT lpPoint) const;
	void ScreenToClient(LPRECT lpRect) const;
	void MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const;
	void MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const;

// Update/Painting Functions
	CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
	void EndPaint(LPPAINTSTRUCT lpPaint);
	CDC* GetDC();
	CDC* GetWindowDC();
	int ReleaseDC(CDC* pDC);
	void Print(CDC* pDC, DWORD dwFlags) const;
	void PrintClient(CDC* pDC, DWORD dwFlags) const;

	void UpdateWindow();
	void SetRedraw(BOOL bRedraw = TRUE);
	BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE);
	int GetUpdateRgn(CRgn* pRgn, BOOL bErase = FALSE);
	void Invalidate(BOOL bErase = TRUE);
	void InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE);
	void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
	void ValidateRect(LPCRECT lpRect);
	void ValidateRgn(CRgn* pRgn);
	BOOL ShowWindow(int nCmdShow);
	BOOL IsWindowVisible() const;
	void ShowOwnedPopups(BOOL bShow = TRUE);

	CDC* GetDCEx(CRgn* prgnClip, DWORD flags);
	BOOL LockWindowUpdate();
	void UnlockWindowUpdate();
	BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL,
		CRgn* prgnUpdate = NULL,
		UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	BOOL EnableScrollBar(int nSBFlags, UINT nArrowFlags = ESB_ENABLE_BOTH);

	BOOL DrawAnimatedRects(int idAni, CONST RECT *lprcFrom, CONST RECT *lprcTo);
	BOOL DrawCaption(CDC* pDC, LPCRECT lprc, UINT uFlags);

#if(WINVER >= 0x0500)

	BOOL AnimateWindow(DWORD dwTime, DWORD dwFlags);

#endif	// WINVER >= 0x0500

#if(_WIN32_WINNT >= 0x0501)

	BOOL PrintWindow(CDC* pDC, UINT nFlags) const;

#endif	// _WIN32_WINNT >= 0x0501

// Layered Window

#if(_WIN32_WINNT >= 0x0500)

	BOOL SetLayeredWindowAttributes(COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
	BOOL UpdateLayeredWindow(CDC* pDCDst, POINT *pptDst, SIZE *psize, 
		CDC* pDCSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags);

#endif	// _WIN32_WINNT >= 0x0500

#if(_WIN32_WINNT >= 0x0501)

	BOOL GetLayeredWindowAttributes(COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags) const;

#endif	// _WIN32_WINNT >= 0x0501


// Timer Functions
	UINT_PTR SetTimer(UINT_PTR nIDEvent, UINT nElapse,
		void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD));
	BOOL KillTimer(UINT_PTR nIDEvent);

// ToolTip Functions
	BOOL EnableToolTips(BOOL bEnable = TRUE);
	BOOL EnableTrackingToolTips(BOOL bEnable = TRUE);
	static void PASCAL CancelToolTips(BOOL bKeys = FALSE);
	void FilterToolTipMessage(MSG* pMsg);

	// for command hit testing (used for automatic tooltips)
	virtual INT_PTR OnToolHitTest(CPoint point, TOOLINFO* pTI) const;

// Window State Functions
	BOOL IsWindowEnabled() const;
	BOOL EnableWindow(BOOL bEnable = TRUE);

	// the active window applies only to top-level (frame windows)
	static CWnd* PASCAL GetActiveWindow();
	CWnd* SetActiveWindow();

	// the foreground window applies only to top-level windows (frame windows)
	BOOL SetForegroundWindow();
	static CWnd* PASCAL GetForegroundWindow();

	// capture and focus apply to all windows
	static CWnd* PASCAL GetCapture();
	CWnd* SetCapture();
	static CWnd* PASCAL GetFocus();
	CWnd* SetFocus();

	static CWnd* PASCAL GetDesktopWindow();

// Obsolete and non-portable APIs - not recommended for new code
	void CloseWindow();
	BOOL OpenIcon();

// Dialog-Box Item Functions
// (NOTE: Dialog-Box Items/Controls are not necessarily in dialog boxes!)
	void CheckDlgButton(int nIDButton, UINT nCheck);
	void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
					int nIDCheckButton);
	int GetCheckedRadioButton(int nIDFirstButton, int nIDLastButton) const;
	int DlgDirList(_Inout_z_ LPTSTR lpPathSpec, _In_ int nIDListBox,
					_In_ int nIDStaticPath, _In_ UINT nFileType);
	int DlgDirListComboBox(_Inout_z_ LPTSTR lpPathSpec, _In_ int nIDComboBox,
					_In_ int nIDStaticPath, _In_ UINT nFileType);
	AFX_DEPRECATED("CWnd::DlgDirSelect(lpszOut, nControlId) is no longer supported. Instead, use CWnd::DlgDirSelect(lpszOut, nSize, nControlId)")
		BOOL DlgDirSelect(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpString, _In_ int nIDListBox);
	BOOL DlgDirSelect(_Out_z_cap_(nSize) LPTSTR lpString, _In_ int nSize, _In_ int nIDListBox);
	AFX_DEPRECATED("CWnd::DlgDirSelectComboBox(lpszOut, nControlId) is no longer supported. Instead, use CWnd::DlgDirSelectComboBox(lpszOut, nSize, nControlId)")
		BOOL DlgDirSelectComboBox(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpString, _In_ int nIDComboBox);
	BOOL DlgDirSelectComboBox(_Out_z_cap_(nSize) LPTSTR lpString, _In_ int nSize, _In_ int nIDComboBox);

	UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL,
					BOOL bSigned = TRUE) const;
	int GetDlgItemText(_In_ int nID, _Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpStr, _In_ int nMaxCount) const;
	int GetDlgItemText(int nID, CString& rString) const;
	CWnd* GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
	COleControlSiteOrWnd* GetNextDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd = NULL) const;
	COleControlSiteOrWnd* GetPrevDlgGroupItem(COleControlSiteOrWnd *pCurSiteOrWnd = NULL) const;
	void RemoveRadioCheckFromGroup(const COleControlSiteOrWnd *pSiteOrWnd) const;
	CWnd* GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
	COleControlSiteOrWnd* GetNextDlgTabItem(COleControlSiteOrWnd *pCurSiteOrWnd, BOOL bPrevious) const;
	UINT IsDlgButtonChecked(int nIDButton) const;
	LRESULT SendDlgItemMessage(int nID, UINT message,
					WPARAM wParam = 0, LPARAM lParam = 0);
	void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE);
	void SetDlgItemText(int nID, LPCTSTR lpszString);
	POSITION FindSiteOrWnd(const COleControlSiteOrWnd *pSiteOrWnd) const;
	POSITION FindSiteOrWndWithFocus() const;

// Scrolling Functions
	int GetScrollPos(int nBar) const;
	void GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const;
	void ScrollWindow(int xAmount, int yAmount,
					LPCRECT lpRect = NULL,
					LPCRECT lpClipRect = NULL);
	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE);
	void SetScrollRange(int nBar, int nMinPos, int nMaxPos,
			BOOL bRedraw = TRUE);
	void ShowScrollBar(UINT nBar, BOOL bShow = TRUE);
	void EnableScrollBarCtrl(int nBar, BOOL bEnable = TRUE);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
			// return sibling scrollbar control (or NULL if none)

	int ScrollWindowEx(int dx, int dy,
				LPCRECT lpRectScroll, LPCRECT lpRectClip,
				CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags);
	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo,
		BOOL bRedraw = TRUE);
	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
	int GetScrollLimit(int nBar);

#if(WINVER >= 0x0500)

	BOOL GetScrollBarInfo(LONG idObject, PSCROLLBARINFO psbi) const;

#endif	// WINVER >= 0x0500

// Window Access Functions
	CWnd* ChildWindowFromPoint(POINT point) const;
	CWnd* ChildWindowFromPoint(POINT point, UINT nFlags) const;
	static CWnd* PASCAL FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName);
	static CWnd* FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow);

	CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
	CWnd* GetTopWindow() const;

	CWnd* GetWindow(UINT nCmd) const;
	CWnd* GetLastActivePopup() const;

	BOOL IsChild(const CWnd* pWnd) const;
	CWnd* GetParent() const;
	CWnd* SetParent(CWnd* pWndNewParent);
	static CWnd* PASCAL WindowFromPoint(POINT point);

// Alert Functions
	BOOL FlashWindow(BOOL bInvert);
#pragma push_macro("MessageBox")
#undef MessageBox
	int _AFX_FUNCNAME(MessageBox)(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
	int MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
			UINT nType = MB_OK);
#pragma pop_macro("MessageBox")

#if(WINVER >= 0x0500)

	BOOL FlashWindowEx(DWORD dwFlags, UINT  uCount, DWORD dwTimeout);

#endif	// WINVER >= 0x0500

// Clipboard Functions
	BOOL ChangeClipboardChain(HWND hWndNext);
	HWND SetClipboardViewer();
	BOOL OpenClipboard();
	static CWnd* PASCAL GetClipboardOwner();
	static CWnd* PASCAL GetClipboardViewer();
	static CWnd* PASCAL GetOpenClipboardWindow();

// Caret Functions
	void CreateCaret(CBitmap* pBitmap);
	void CreateSolidCaret(int nWidth, int nHeight);
	void CreateGrayCaret(int nWidth, int nHeight);
	static CPoint PASCAL GetCaretPos();
	static void PASCAL SetCaretPos(POINT point);
	void HideCaret();
	void ShowCaret();

// Shell Interaction Functions
	void DragAcceptFiles(BOOL bAccept = TRUE);

// Icon Functions
	HICON SetIcon(HICON hIcon, BOOL bBigIcon);
	HICON GetIcon(BOOL bBigIcon) const;

// Context Help Functions
	BOOL SetWindowContextHelpId(DWORD dwContextHelpId);
	DWORD GetWindowContextHelpId() const;

// Dialog Data support
public:
	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
			// data wnd must be same type as this

// Help Command Handlers
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX
	afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING
	virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual void WinHelpInternal(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);

// Layout and other functions
public:
	enum RepositionFlags
		{ reposDefault = 0, reposQuery = 1, reposExtra = 2, reposNoPosLeftOver=0x8000 };
	void RepositionBars(UINT nIDFirst, UINT nIDLast, UINT nIDLeftOver,
		UINT nFlag = reposDefault, LPRECT lpRectParam = NULL,
		LPCRECT lpRectClient = NULL, BOOL bStretch = TRUE);

	// dialog support
	void UpdateDialogControls(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
	void CenterWindow(CWnd* pAlternateOwner = NULL);
	int RunModalLoop(DWORD dwFlags = 0);
	virtual BOOL ContinueModal();
	virtual void EndModalLoop(int nResult);

#ifndef _AFX_NO_OCC_SUPPORT
// OLE control wrapper functions
   COleControlSite* GetOleControlSite(UINT idControl) const;
	void AFX_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
		VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
	void AFX_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
	void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
	IUnknown* GetDSCCursor();
	void BindDefaultProperty(DISPID dwDispID, VARTYPE vtProp, LPCTSTR szFieldName, CWnd* pDSCWnd);
	void BindProperty(DISPID dwDispId, CWnd* pWndDSC);
#endif

// Accessibility Support
public :
	void EnableActiveAccessibility();
	void NotifyWinEvent(DWORD event, LONG idObjectType, LONG idObject);

public :
	// Windows 7 taskbar Tabs support

	/// <summary>
	/// Called by the framework when it needs to obtain a bitmap to be displayed on Windows 7 tab thumbnail, 
	/// or on the client for application peek. </summary>
	/// <description>
	/// Override this method in a derived class and draw on the specified device context in order to customize thumbnail and peek.
	/// If bThumbnail is TRUE, szRequiredThumbnailSize can be ignored. In this case you should be aware 
	/// that you draw full sized bitmap (e.g. a bitmap that cover the whole client area). The device context (dc) comes with selected 32 bits bitmap. 
	/// The default implementation sends WM_PRINT to this window with PRF_CLIENT, PRF_CHILDREN and PRF_NONCLIENT flags.</description>
	/// <param name="dc"> Specifies the device context.</param>
	/// <param name="rect"> Specifies the bounding rectangle of area to render.</param>
	/// <param name="szRequiredThumbnailSize"> Specifies the size of target thumbnail. Should be ignored if bIsThumbnail is FALSE.</param>
	/// <param name="bIsThumbnail"> Specifies whether this method is called for iconic thumbnail or live preview (peek).</param>
	/// <param name="bAlphaChannelSet"> Output parameter. Set it to TRUE if your implementation initializes alpha channel of a bitmap
	/// selected in dc.</param> 
	virtual void OnDrawIconicThumbnailOrLivePreview(CDC& dc, CRect rect, CSize szRequiredThumbnailSize, BOOL bIsThumbnail, BOOL& bAlphaChannelSet);

protected :
	bool m_bEnableActiveAccessibility;
	IAccessible* m_pStdObject;
	friend BOOL AFXAPI AfxWinInit(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,
		_In_z_ LPTSTR lpCmdLine, _In_ int nCmdShow);

protected:
	IAccessibleProxy* m_pProxy;
	afx_msg LRESULT OnGetObject(WPARAM, LPARAM);

#ifndef _AFX_NO_OLE_SUPPORT
	DECLARE_INTERFACE_MAP()
#endif

	class XAccessible //: public IAccessible
	{	
	public:
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
		XAccessible()
			{ m_nOffset = offsetof(CWnd, m_xAccessible); }
#endif
		virtual ULONG __stdcall AddRef(); 
		virtual ULONG __stdcall Release(); 
		virtual HRESULT __stdcall QueryInterface(REFIID iid, LPVOID* ppvObj); 
		virtual HRESULT __stdcall Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
		virtual HRESULT __stdcall GetIDsOfNames(REFIID, LPOLESTR *, UINT, LCID, DISPID *);
		virtual HRESULT __stdcall GetTypeInfoCount(unsigned int *);
		virtual HRESULT __stdcall GetTypeInfo(unsigned int, LCID, ITypeInfo**);
		virtual HRESULT __stdcall get_accParent(IDispatch **ppdispParent);
		virtual HRESULT __stdcall get_accChildCount(long *pcountChildren);
		virtual HRESULT __stdcall get_accChild(VARIANT varChild, IDispatch **ppdispChild);
		virtual HRESULT __stdcall get_accName(VARIANT varChild, BSTR *pszName);
		virtual HRESULT __stdcall get_accValue(VARIANT varChild, BSTR *pszValue);
		virtual HRESULT __stdcall get_accDescription(VARIANT varChild, BSTR *pszDescription);
		virtual HRESULT __stdcall get_accRole(VARIANT varChild, VARIANT *pvarRole);
		virtual HRESULT __stdcall get_accState(VARIANT varChild, VARIANT *pvarState);
		virtual HRESULT __stdcall get_accHelp(VARIANT varChild, BSTR *pszHelp);
		virtual HRESULT __stdcall get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
		virtual HRESULT __stdcall get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
		virtual HRESULT __stdcall get_accFocus(VARIANT *pvarChild);
		virtual HRESULT __stdcall get_accSelection(VARIANT *pvarChildren);
		virtual HRESULT __stdcall get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
		virtual HRESULT __stdcall accSelect(long flagsSelect, VARIANT varChild);
		virtual HRESULT __stdcall accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
		virtual HRESULT __stdcall accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
		virtual HRESULT __stdcall accHitTest(long xLeft, long yTop, VARIANT *pvarChild);
		virtual HRESULT __stdcall accDoDefaultAction(VARIANT varChild);
		virtual HRESULT __stdcall put_accName(VARIANT varChild, BSTR szName);
		virtual HRESULT __stdcall put_accValue(VARIANT varChild, BSTR szValue);
	} m_xAccessible;
	friend class XAccessible; 

	class XAccessibleServer //: public IAccessibleServer
	{	
	public:
#ifndef _AFX_NO_NESTED_DERIVATION
		size_t m_nOffset;
		XAccessibleServer()
			{ m_nOffset = offsetof(CWnd, m_xAccessibleServer); }
#endif		
		virtual ULONG __stdcall AddRef(); 
		virtual ULONG __stdcall Release(); 
		virtual HRESULT __stdcall QueryInterface(REFIID iid, LPVOID* ppvObj); 
		virtual HRESULT __stdcall SetProxy(IAccessibleProxy *pProxy);
		virtual HRESULT __stdcall GetHWND(HWND *phWnd);
		virtual HRESULT __stdcall GetEnumVariant(IEnumVARIANT **ppEnumVariant);
	} m_xAccessibleServer;
	friend class XAccessibleServer;

public :
	virtual HRESULT EnsureStdObj();

	virtual HRESULT get_accParent(IDispatch **ppdispParent);
	virtual HRESULT get_accChildCount(long *pcountChildren);
	virtual HRESULT get_accChild(VARIANT varChild, IDispatch **ppdispChild);
	virtual HRESULT get_accName(VARIANT varChild, BSTR *pszName);
	virtual HRESULT get_accValue(VARIANT varChild, BSTR *pszValue);
	virtual HRESULT get_accDescription(VARIANT varChild, BSTR *pszDescription);
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accHelp(VARIANT varChild, BSTR *pszHelp);
	virtual HRESULT get_accHelpTopic(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic);
	virtual HRESULT get_accKeyboardShortcut(VARIANT varChild, BSTR *pszKeyboardShortcut);
	virtual HRESULT get_accFocus(VARIANT *pvarChild);
	virtual HRESULT get_accSelection(VARIANT *pvarChildren);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
	virtual HRESULT accSelect(long flagsSelect, VARIANT varChild);
	virtual HRESULT accLocation(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
	virtual HRESULT accNavigate(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
	virtual HRESULT accHitTest(long xLeft, long yTop, VARIANT *pvarChild);
	virtual HRESULT accDoDefaultAction(VARIANT varChild);
	//Obsolete
	virtual HRESULT put_accName(VARIANT varChild, BSTR szName);
	//Obsolete
	virtual HRESULT put_accValue(VARIANT varChild, BSTR szValue);
	virtual HRESULT SetProxy(IAccessibleProxy *pProxy);
	virtual HRESULT CreateAccessibleProxy(WPARAM wParam, LPARAM lParam, LRESULT *pResult);

	// Helpers for windows that contain windowless controls
	long GetWindowLessChildCount();
	long GetWindowedChildCount();
	long GetAccessibleChildCount();
	HRESULT GetAccessibleChild(VARIANT varChild, IDispatch** ppdispChild);
	HRESULT GetAccessibleName(VARIANT varChild, BSTR* pszName);
	HRESULT GetAccessibilityLocation(VARIANT varChild, long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight);
	HRESULT GetAccessibilityHitTest(long xLeft, long yTop, VARIANT *pvarChild);


// Window-Management message handler member functions
protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnActivateApp(BOOL bActive, DWORD dwThreadID);
	afx_msg LRESULT OnActivateTopLevel(WPARAM, LPARAM);
	afx_msg void OnCancelMode();
	afx_msg void OnChildActivate();
	afx_msg void OnClose();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint pos);
	afx_msg BOOL OnCopyData(CWnd* pWnd, COPYDATASTRUCT* pCopyDataStruct);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnDestroy();
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO* lpMMI);
	afx_msg BOOL OnHelpInfo(HELPINFO* lpHelpInfo);
	afx_msg void OnIconEraseBkgnd(CDC* pDC);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnPaint();
	afx_msg void OnSyncPaint();
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg UINT OnNotifyFormat(CWnd* pWnd, UINT nCommand);
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg BOOL OnQueryEndSession();
	afx_msg BOOL OnQueryNewPalette();
	afx_msg BOOL OnQueryOpen();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnTCard(UINT idAction, DWORD dwActionData);
	afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
	afx_msg void OnWindowPosChanged(WINDOWPOS* lpwndpos);
	afx_msg void OnSessionChange(UINT nSessionState, UINT nId);

	afx_msg void OnChangeUIState(UINT nAction, UINT nUIElement);
	afx_msg void OnUpdateUIState(UINT nAction, UINT nUIElement);
	afx_msg UINT OnQueryUIState();

// Nonclient-Area message handler member functions
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNcDestroy();
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseHover(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseLeave();
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcPaint();
	afx_msg void OnNcRButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcXButtonDown(short zHitTest, UINT nButton, CPoint point);
	afx_msg void OnNcXButtonUp(short zHitTest, UINT nButton, CPoint point);
	afx_msg void OnNcXButtonDblClk(short zHitTest, UINT nButton, CPoint point);

// System message handler member functions
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
	afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSysDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg BOOL OnAppCommand(CWnd* pWnd, UINT nCmd, UINT nDevice, UINT nKey);
#if(_WIN32_WINNT >= 0x0501)
	afx_msg void OnRawInput(UINT nInputCode, HRAWINPUT hRawInput);
#endif
	afx_msg void OnCompacting(UINT nCpuTime);
	afx_msg void OnDevModeChange(_In_z_ LPTSTR lpDeviceName);
	afx_msg void OnFontChange();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg void OnSpoolerStatus(UINT nStatus, UINT nJobs);
	afx_msg void OnSysColorChange();
	afx_msg void OnTimeChange();
	afx_msg void OnSettingChange(UINT uFlags, LPCTSTR lpszSection);
	afx_msg void OnWinIniChange(LPCTSTR lpszSection);
	afx_msg UINT OnPowerBroadcast(UINT nPowerEvent, UINT nEventData);
	afx_msg void OnUserChanged();
	afx_msg void OnInputLangChange(UINT nCharSet, UINT nLocaleId);
	afx_msg void OnInputLangChangeRequest(UINT nFlags, UINT nLocaleId);
	afx_msg void OnInputDeviceChange(unsigned short nFlags, HANDLE hDevice);

// Input message handler member functions
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnUniChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnHotKey(UINT nHotKeyId, UINT nKey1, UINT nKey2);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnXButtonDblClk(UINT nFlags, UINT nButton, CPoint point);
	afx_msg void OnXButtonDown(UINT nFlags, UINT nButton, CPoint point);
	afx_msg void OnXButtonUp(UINT nFlags, UINT nButton, CPoint point);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseHover(UINT nFlags, CPoint point);
	afx_msg void OnMouseLeave();
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnMouseHWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnTimer(UINT_PTR nIDEvent);

// Initialization message handler member functions
	afx_msg void OnInitMenu(CMenu* pMenu);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);
	afx_msg void OnUnInitMenuPopup(CMenu* pPopupMenu, UINT nFlags);

// Clipboard message handler member functions
	afx_msg void OnAskCbFormatName(_In_ UINT nMaxCount, _Out_z_cap_(nMaxCount) LPTSTR lpszString);
	afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
	afx_msg void OnDestroyClipboard();
	afx_msg void OnDrawClipboard();
	afx_msg void OnHScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
	afx_msg void OnPaintClipboard(CWnd* pClipAppWnd, HGLOBAL hPaintStruct);
	afx_msg void OnRenderAllFormats();
	afx_msg void OnRenderFormat(UINT nFormat);
	afx_msg void OnSizeClipboard(CWnd* pClipAppWnd, HGLOBAL hRect);
	afx_msg void OnVScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
	afx_msg void OnClipboardUpdate();

// Control message handler member functions
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);

// MDI message handler member functions
	afx_msg void OnMDIActivate(BOOL bActivate,
		CWnd* pActivateWnd, CWnd* pDeactivateWnd);

// Menu loop notification messages
	afx_msg void OnEnterMenuLoop(BOOL bIsTrackPopupMenu);
	afx_msg void OnExitMenuLoop(BOOL bIsTrackPopupMenu);
	afx_msg void OnMenuRButtonUp(UINT nPos, CMenu* pMenu);
	afx_msg UINT OnMenuDrag(UINT nPos, CMenu* pMenu);
#if(WINVER >= 0x0500)
	afx_msg UINT OnMenuGetObject(MENUGETOBJECTINFO* pMenuGetObjectInfo);
#endif
	afx_msg void OnMenuCommand(UINT nPos, CMenu* pMenu);
	afx_msg void OnNextMenu(UINT nKey, LPMDINEXTMENU lpMdiNextMenu);

// Win4 messages
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	afx_msg void OnSizing(UINT nSide, LPRECT lpRect);
	afx_msg void OnMoving(UINT nSide, LPRECT lpRect);
	afx_msg void OnEnterSizeMove();
	afx_msg void OnExitSizeMove();
	afx_msg void OnCaptureChanged(CWnd* pWnd);
	afx_msg BOOL OnDeviceChange(UINT nEventType, DWORD_PTR dwData);

// Desktop Windows Manager messages
	afx_msg void OnCompositionChanged();
	afx_msg void OnNcRenderingChanged(BOOL bIsRendering);
	afx_msg void OnColorizationColorChanged(DWORD dwColorizationColor, BOOL bOpacity);
	afx_msg void OnWindowMaximizedChange(BOOL bIsMaximized);

// touch and gesture messages:
#if (WINVER >= 0x0601)
	afx_msg LRESULT OnTouchMessage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnTabletQuerySystemGestureStatus(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnGesture(WPARAM wParam, LPARAM lParam);
#endif

// Overridables and other helpers (for implementation of derived classes)
protected:
	// for deriving from a standard control
	virtual WNDPROC* GetSuperWndProcAddr();

	// for dialog data exchange and validation
	virtual void DoDataExchange(CDataExchange* pDX);

public:
	// for modality
	virtual void BeginModalState();
	virtual void EndModalState();

	// for translating Windows messages in main message pump
	virtual BOOL PreTranslateMessage(MSG* pMsg);

#ifndef _AFX_NO_OCC_SUPPORT
	// for ambient properties exposed to contained OLE controls
	virtual BOOL OnAmbientProperty(COleControlSite* pSite, DISPID dispid,
		VARIANT* pvar);
#endif

	// for touch:

	/// <summary>
	/// Register/Unregister window Windows touch support</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="bRegister">TRUE - register Windows touch support; FALSE - otherwise.</param>
	/// <param name="ulFlags">A set of bit flags that specify optional modifications. This field may contain 0 or one of the following values: TWF_FINETOUCH; TWF_WANTPALM</param>
	BOOL RegisterTouchWindow(BOOL bRegister = TRUE, ULONG ulFlags = 0);

	/// <summary>
	/// Specifies whether CWnd has touch support</summary>
	/// <returns> 
	/// TRUE if CWnd has touch support; otherwise FALSE.</returns>
	BOOL IsTouchWindow() const;

	// gesture:
#if (WINVER >= 0x0601)
	/// <summary>
	/// Set gesture touch paramaters</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="pConfig">Pointer to CGestureConfig. Cannot be NULL.</param>
	BOOL SetGestureConfig(CGestureConfig* pConfig);

	/// <summary>
	/// Get gesture touch paramaters</summary>
	/// <returns> 
	/// TRUE if succeeds; otherwise FALSE.</returns>
	/// <param name="pConfig">Pointer to CGestureConfig. Cannot be NULL.</param>
	BOOL GetGestureConfig(CGestureConfig* pConfig);

	/// <summary>
	/// Returns the current gesture information (PGESTUREINFO)</summary>
	/// <returns> 
	/// Pointer to the current gesture info.</returns>
	const PGESTUREINFO GetCurrentGestureInfo() const
	{
		return m_pCurrentGestureInfo;
	}
#endif

protected:
	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	// for handling default processing
	LRESULT Default();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// for custom cleanup after WM_NCDESTROY
	virtual void PostNcDestroy();

	// for notifications from parent
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
		// return TRUE if parent should not process this message
	BOOL ReflectChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	static BOOL PASCAL ReflectLastMsg(HWND hWndChild, LRESULT* pResult = NULL);

	// for touch:
	BOOL m_bIsTouchWindowRegistered;
	
	/// <summary>
	/// Process inputs from Windows touch</summary>
	/// <returns> 
	/// TRUE if application processes Windows touch inputs; otherwise FALSE.</returns>
	/// <param name="nInputsCount">total number of Windows touch inputs.</param>
	/// <param name="pInputs">array of TOUCHINPUT.</param>
	virtual BOOL OnTouchInputs(UINT nInputsCount, PTOUCHINPUT pInputs);

	/// <summary>
	/// Process single input from Windows touch</summary>
	/// <returns> 
	/// TRUE if application processes Windows touch input; otherwise FALSE.</returns>
	/// <param name="pt">point where screen has been tocuhed (in the client coordinates).</param>
	/// <param name="nInputNumber">number of touch input.</param>
	/// <param name="nInputsCount">total number of touch inputs.</param>
	/// <param name="pInput">pointer to TOUCHINPUT structure.</param>
	virtual BOOL OnTouchInput(CPoint pt, int nInputNumber, int nInputsCount, PTOUCHINPUT pInput);

	/// <summary>
	/// The methods is called when the system asks a window which system gestures it would like to receive</summary>
	/// <returns> 
	/// A value indicating which system gestures the window would like to receive (TABLET_* flags, see WM_TABLET_QUERYSYSTEMGESTURESTATUS message).</returns>
	/// <param name="ptTouch">point where screen has been tocuhed (in the client coordinates).</param>
	virtual ULONG GetGestureStatus(CPoint ptTouch);

	// for gesture:
	CPoint		 m_ptGestureFrom;
	ULONGLONG	 m_ulGestureArg;
	BOOL		 m_bGestureInited;
	PGESTUREINFO m_pCurrentGestureInfo;

	/// <summary>
	/// The method is called upon gesture zoom event</summary>
	/// <returns> 
	/// TRUE if application processes this event; otherwise FALSE.</returns>
	/// <param name="ptCenter">Zoom center point. In client coordinates</param>
	/// <param name="lDelta">The distance from the center point. In pixels</param>
	virtual BOOL OnGestureZoom(CPoint ptCenter, long lDelta);

	/// <summary>
	/// The method is called upon gesture pan event</summary>
	/// <returns> 
	/// TRUE if application processes this event; otherwise FALSE.</returns>
	/// <param name="ptFrom">Pan starting point. In client coordinates</param>
	/// <param name="ptTo">Pan current point. In client coordinates</param>
	virtual BOOL OnGesturePan(CPoint ptFrom, CPoint ptTo);

	/// <summary>
	/// The method is called upon gesture rotate event</summary>
	/// <returns> 
	/// TRUE if application processes this event; otherwise FALSE.</returns>
	/// <param name="ptCenter">Rotation center point. In client coordinates</param>
	/// <param name="dblAngle">Rotation angle. In radians</param>
	virtual BOOL OnGestureRotate(CPoint ptCenter, double dblAngle);

	/// <summary>
	/// The method is called upon gesture 2 finger tap event</summary>
	/// <returns> 
	/// TRUE if application processes this event; otherwise FALSE.</returns>
	/// <param name="ptCenter">Center point between 2 fingers. In client coordinates</param>
	virtual BOOL OnGestureTwoFingerTap(CPoint ptCenter);

	/// <summary>
	/// The method is called upon gesture press and tap event</summary>
	/// <returns> 
	/// TRUE if application processes this event; otherwise FALSE.</returns>
	/// <param name="ptPress">"Pressed" point. In client coordinates</param>
	/// <param name="lDelta">The distance from the "pressed" point. In pixels</param>
	virtual BOOL OnGesturePressAndTap(CPoint ptPress, long lDelta);

// Implementation
public:
	virtual ~CWnd();
	virtual BOOL CheckAutoCenter();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	static BOOL PASCAL GrayCtlColor(HDC hDC, HWND hWnd, UINT nCtlColor,
		HBRUSH hbrGray, COLORREF clrText);

	// helper routines for implementation
	BOOL HandleFloatingSysCommand(UINT nID, LPARAM lParam);
	BOOL IsTopParentActive() const;
	void ActivateTopParent();
	static BOOL PASCAL WalkPreTranslateTree(HWND hWndStop, MSG* pMsg);
	static CWnd* PASCAL GetDescendantWindow(HWND hWnd, int nID,
		BOOL bOnlyPerm);
	static void PASCAL SendMessageToDescendants(HWND hWnd, UINT message,
		WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm);
	virtual BOOL IsFrameWnd() const; // IsKindOf(RUNTIME_CLASS(CFrameWnd)))
	virtual void OnFinalRelease();
	BOOL PreTranslateInput(LPMSG lpMsg);
	static BOOL PASCAL ModifyStyle(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
		UINT nFlags);
	static BOOL PASCAL ModifyStyleEx(HWND hWnd, DWORD dwRemove, DWORD dwAdd,
		UINT nFlags);
	static void PASCAL _FilterToolTipMessage(MSG* pMsg, CWnd* pWnd);
	BOOL _EnableToolTips(BOOL bEnable, UINT nFlag);
	static HWND PASCAL GetSafeOwner_(HWND hWnd, HWND* pWndTop);
	void PrepareForHelp();

	COleControlContainer* GetControlContainer();

public:
	HWND m_hWndOwner;   // implementation of SetOwner and GetOwner
	UINT m_nFlags;      // see WF_ flags above

protected:
	WNDPROC m_pfnSuper; // for subclassing of controls
	static const UINT m_nMsgDragList;
	int m_nModalResult; // for return values from CWnd::RunModalLoop

	COleDropTarget* m_pDropTarget;  // for automatic cleanup of drop target
	friend class COleDropTarget;
	friend class CFrameWnd;

	// for creating dialogs and dialog-like windows
	BOOL CreateDlg(LPCTSTR lpszTemplateName, CWnd* pParentWnd);
	BOOL CreateDlgIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
		HINSTANCE hInst);

#ifndef _AFX_NO_OCC_SUPPORT
	COleControlContainer* m_pCtrlCont;  // for containing OLE controls
	COleControlSite* m_pCtrlSite;       // for wrapping an OLE control
	friend class COccManager;
	friend class COleControlSite;
	friend class COleControlContainer;
	BOOL InitControlContainer(BOOL bCreateFromResource=FALSE);
	virtual BOOL CreateControlContainer(COleControlContainer** ppContainer);
	virtual BOOL CreateControlSite(COleControlContainer* pContainer, 
		COleControlSite** ppSite, UINT nID, REFCLSID clsid);
	virtual BOOL SetOccDialogInfo(struct _AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
	void AttachControlSite(CHandleMap* pMap);
public:
	void AttachControlSite(CWnd* pWndParent, UINT nIDC = 0);
	COleControlContainer* GetControlContainer() const
	{
		return m_pCtrlCont;
	}
	COleControlSite* GetControlSite() const
	{
		return m_pCtrlSite;
	}
#endif

public:
	CMFCControlContainer* GetMFCControlContainer() const
	{
		return m_pMFCCtrlContainer;
	}

protected:
	CMFCControlContainer* m_pMFCCtrlContainer;  // for containing MFC Feature Pack controls

protected:
	// implementation of message dispatch/hooking
	friend LRESULT CALLBACK _AfxSendMsgHook(int, WPARAM, LPARAM);
	friend void AFXAPI _AfxStandardSubclass(HWND);
	friend LRESULT CALLBACK _AfxCbtFilterHook(int, WPARAM, LPARAM);
	friend LRESULT AFXAPI AfxCallWndProc(CWnd*, HWND, UINT, WPARAM, LPARAM);

	// standard message implementation
	afx_msg LRESULT OnNTCtlColor(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDisplayChange(WPARAM, LPARAM);
	afx_msg LRESULT OnDragList(WPARAM, LPARAM);

	// Helper functions for retrieving Text from windows messsage / structure
	// -----------------------------------------------------------------------
	// errCode  - the errCode for the window message, uMsg
	// pszText  - buffer to grow and retrieve the text (do not allocate when calling, the function will allocate)
	// cch      - size of the buffer in TCHAR to be pass to the windows message, uMsg
	// cchBegin - initial size to allocate
	// cchEnd   - maximum size to allocate
	// uMsg     - window message 
	// lParam   - the LPARAM of the message.  This is pass by reference because it could potentially be alias of pszText/cch for some messages.
	// wParam   - the WPARAM of the message.  This is pass by reference because it could potentially be alias of pszText/cch for some messages.
	// strOut   - the CString containing the received text

	template <class TReturnType, class TCchType >
	TReturnType EnlargeBufferGetText(_In_ TReturnType errCode, LPTSTR& pszText, TCchType& cch, TCchType cchBegin, TCchType cchEnd, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
	{
		ENSURE(::IsWindow(m_hWnd));
		ENSURE(cchBegin < cchEnd);
		ENSURE(cchEnd <= INT_MAX); // CString only support up to INT_MAX
		TReturnType retCode = errCode;
		strOut = CString();
		cch = cchBegin;
		do 
		{
			pszText = strOut.GetBufferSetLength(cch);
			retCode = static_cast<TReturnType>(this->SendMessage(uMsg, wParam, lParam));
			strOut.ReleaseBuffer();
			pszText = NULL;

			if (retCode == errCode)
			{
				// error clear the string and return error
				strOut = CString();
				cch=0;
				break;
			}
			if (static_cast<TCchType>(strOut.GetLength()) < cch-1)
			{
				cch = strOut.GetLength();
				break;
			}
		}
		while( (::ATL::AtlMultiply(&cch, cch, 2) == S_OK) && (cch < cchEnd));
		return retCode;
	}


	template <class TReturnType>
	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, int& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
	{
		return EnlargeBufferGetText<TReturnType, int>(errCode, pszText, pcch, 256, INT_MAX, uMsg, wParam, lParam, strOut);
	}

	template <class TReturnType>
	inline TReturnType EnlargeBufferGetText(TReturnType errCode, LPTSTR& pszText, UINT& pcch, UINT uMsg, WPARAM& wParam, LPARAM& lParam, CString& strOut) const throw(...)
	{
		// using INT_MAX instead of UINT_MAX here because CString has a INT_MAX limit
		return EnlargeBufferGetText<TReturnType, UINT>(errCode, pszText, pcch, 256, INT_MAX, uMsg, wParam, lParam, strOut);
	}

	//{{AFX_MSG(CWnd)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CWnd(HWND hWnd);    // just for special initialization
};

// helpers for registering your own WNDCLASSes
LPCTSTR AFXAPI AfxRegisterWndClass(UINT nClassStyle,
	HCURSOR hCursor = 0, HBRUSH hbrBackground = 0, HICON hIcon = 0);

BOOL AFXAPI AfxRegisterClass(WNDCLASS* lpWndClass);

// helper to initialize rich edit 1.0 control
BOOL AFXAPI AfxInitRichEdit();
// helper to initialize rich edit 2.0 control
BOOL AFXAPI AfxInitRichEdit2();

// Implementation
LRESULT CALLBACK AfxWndProc(HWND, UINT, WPARAM, LPARAM);

WNDPROC AFXAPI AfxGetAfxWndProc();
#define AfxWndProc (*AfxGetAfxWndProc())

typedef void (AFX_MSG_CALL CWnd::*AFX_PMSGW)(void);
	// like 'AFX_PMSG' but for CWnd derived classes only

typedef void (AFX_MSG_CALL CWinThread::*AFX_PMSGT)(void);
	// like 'AFX_PMSG' but for CWinThread-derived classes only

/////////////////////////////////////////////////////////////////////////////
// CDialog - a modal or modeless dialog
class CDialog : public CWnd
{
	DECLARE_DYNAMIC(CDialog)

	// Modeless construct
public:
	CDialog();
	void Initialize();

	virtual BOOL Create(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	virtual BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	virtual BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
		void* lpDialogInit = NULL);
	virtual BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

	// Modal construct
public:
	explicit CDialog(LPCTSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	explicit CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	BOOL InitModalIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd = NULL,
		void* lpDialogInit = NULL);
	BOOL InitModalIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd = NULL);

// Attributes
public:
	void MapDialogRect(LPRECT lpRect) const;
	void SetHelpID(UINT nIDR);

// Operations
public:
	// modal processing
	virtual INT_PTR DoModal();

	// support for passing on tab control - use 'PostMessage' if needed
	void NextDlgCtrl() const;
	void PrevDlgCtrl() const;
	void GotoDlgCtrl(CWnd* pWndCtrl);

	// default button access
	void SetDefID(UINT nID);
	DWORD GetDefID() const;

	// termination
	void EndDialog(int nResult);

// Overridables (special message map entries)
	virtual BOOL OnInitDialog();
	virtual void OnSetFont(CFont* pFont);
protected:
	virtual void OnOK();
	virtual void OnCancel();

// Implementation
public:
	virtual ~CDialog();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL CheckAutoCenter();

protected:
	UINT m_nIDHelp;                 // Help ID (0 for none, see HID_BASE_RESOURCE)

	// parameters for 'DoModal'
	LPCTSTR m_lpszTemplateName;     // name or MAKEINTRESOURCE
	HGLOBAL m_hDialogTemplate;      // indirect (m_lpDialogTemplate == NULL)
	LPCDLGTEMPLATE m_lpDialogTemplate;  // indirect if (m_lpszTemplateName == NULL)
	void* m_lpDialogInit;           // DLGINIT resource data
	CWnd* m_pParentWnd;             // parent/owner window
	HWND m_hWndTop;                 // top level parent window (may be disabled)

#ifndef _AFX_NO_OCC_SUPPORT
	_AFX_OCC_DIALOG_INFO* m_pOccDialogInfo;
	virtual BOOL SetOccDialogInfo(_AFX_OCC_DIALOG_INFO* pOccDialogInfo);
	virtual _AFX_OCC_DIALOG_INFO* GetOccDialogInfo();
#endif
	virtual void PreInitDialog();

	// implementation helpers
	HWND PreModal();
	void PostModal();

	BOOL CreateIndirect(LPCDLGTEMPLATE lpDialogTemplate, CWnd* pParentWnd,
		void* lpDialogInit, HINSTANCE hInst);
	BOOL CreateIndirect(HGLOBAL hDialogTemplate, CWnd* pParentWnd,
		HINSTANCE hInst);

protected:
	//{{AFX_MSG(CDialog)
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT HandleInitDialog(WPARAM, LPARAM);
	afx_msg LRESULT HandleSetFont(WPARAM, LPARAM);
	afx_msg void OnPaint();
	afx_msg BOOL OnQueryEndSession();
	afx_msg void OnEndSession(BOOL bEnding);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// all CModalDialog functionality is now in CDialog
#define CModalDialog    CDialog

/////////////////////////////////////////////////////////////////////////////
// Standard Windows controls

class CStatic : public CWnd
{
	DECLARE_DYNAMIC(CStatic)

// Constructors
public:
	CStatic();
	virtual BOOL Create(LPCTSTR lpszText, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID = 0xffff);

// Operations
	HICON SetIcon(HICON hIcon);
	HICON GetIcon() const;

	HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile);
	HENHMETAFILE GetEnhMetaFile() const;
	HBITMAP SetBitmap(HBITMAP hBitmap);
	HBITMAP GetBitmap() const;
	HCURSOR SetCursor(HCURSOR hCursor);
	HCURSOR GetCursor();

// Overridables (for owner draw only)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CStatic();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CButton : public CWnd
{
	DECLARE_DYNAMIC(CButton)

// Constructors
public:
	CButton();
	virtual BOOL Create(LPCTSTR lpszCaption, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	UINT GetState() const;
	void SetState(BOOL bHighlight);
	int GetCheck() const;
	void SetCheck(int nCheck);
	UINT GetButtonStyle() const;
	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE);

	HICON SetIcon(HICON hIcon);
	HICON GetIcon() const;
	HBITMAP SetBitmap(HBITMAP hBitmap);
	HBITMAP GetBitmap() const;
	HCURSOR SetCursor(HCURSOR hCursor);
	HCURSOR GetCursor();

#if (_WIN32_WINNT >= 0x501)
	AFX_ANSI_DEPRECATED BOOL GetIdealSize(_Out_ LPSIZE psize) const;
	AFX_ANSI_DEPRECATED BOOL SetImageList(_In_ PBUTTON_IMAGELIST pbuttonImagelist);
	AFX_ANSI_DEPRECATED BOOL GetImageList(_In_ PBUTTON_IMAGELIST pbuttonImagelist) const;
	AFX_ANSI_DEPRECATED BOOL SetTextMargin(_In_ LPRECT pmargin);
	AFX_ANSI_DEPRECATED BOOL GetTextMargin(_Out_ LPRECT pmargin) const;
#endif  // (_WIN32_WINNT >= 0x501)

#if ( _WIN32_WINNT >= 0x0600 ) && defined(UNICODE)
	CString GetNote() const;
	_Check_return_ BOOL GetNote(_Out_z_cap_(*pcchNote) LPTSTR lpszNote, _Inout_ UINT* pcchNote) const;
	BOOL SetNote(_In_z_ LPCTSTR lpszNote);
	UINT GetNoteLength() const;
	BOOL GetSplitInfo(_Out_ PBUTTON_SPLITINFO pInfo) const;
	BOOL SetSplitInfo(_In_ PBUTTON_SPLITINFO pInfo);
	UINT GetSplitStyle() const;
	BOOL SetSplitStyle(_In_ UINT nStyle);
	BOOL GetSplitSize(_Out_ LPSIZE pSize) const;
	BOOL SetSplitSize(_In_ LPSIZE pSize);
	CImageList* GetSplitImageList() const;
	BOOL SetSplitImageList(_In_ CImageList* pSplitImageList);
	TCHAR GetSplitGlyph() const;
	BOOL SetSplitGlyph(_In_ TCHAR chGlyph);
	BOOL SetDropDownState(_In_ BOOL fDropDown);

	// Sets whether the action associated with the button requires elevated permissions.
	// If elevated permissions are required then the button should display an elevated icon.
	HICON SetShield(_In_ BOOL fElevationRequired);
#endif // ( _WIN32_WINNT >= 0x600 ) && defined(UNICODE)

// Overridables (for owner draw only)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CButton();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
class CSplitButton : public CButton
{
	DECLARE_DYNAMIC(CSplitButton)

// Constructors
public:
	CSplitButton();
	CSplitButton(UINT nMenuId, UINT nSubMenuId);
	CSplitButton(CMenu* pMenu);

	~CSplitButton();

	virtual BOOL Create(LPCTSTR lpszCaption, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID);

	void SetDropDownMenu(UINT nMenuId, UINT nSubMenuId);
	void SetDropDownMenu(CMenu* pMenu);

protected:
	DECLARE_MESSAGE_MAP()
	afx_msg void OnDropDown(NMHDR* /*pNMHDR*/, LRESULT *pResult);

	void Cleanup();

	CMenu * m_pMenu;
	UINT m_nMenuId;
	UINT m_nSubMenuId;
};

#endif // (_WIN32_WINNT >= 0x600) && defined(CSplitButton)

class CListBox : public CWnd
{
	DECLARE_DYNAMIC(CListBox)

// Constructors
public:
	CListBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes

	// for entire listbox
	int GetCount() const;
	int GetHorizontalExtent() const;
	void SetHorizontalExtent(int cxExtent);
	int GetTopIndex() const;
	int SetTopIndex(int nIndex);
	LCID GetLocale() const;
	LCID SetLocale(LCID nNewLocale);
	int InitStorage(int nItems, UINT nBytes);
	UINT ItemFromPoint(CPoint pt, BOOL& bOutside) const;

#if(WINVER >= 0x0500)
	DWORD GetListBoxInfo() const;
#endif	// WINVER >= 0x0500	

	// for single-selection listboxes
	int GetCurSel() const;
	int SetCurSel(int nSelect);

	// for multiple-selection listboxes
	int GetSel(int nIndex) const;           // also works for single-selection
	int SetSel(int nIndex, BOOL bSelect = TRUE);
	int GetSelCount() const;
	int GetSelItems(int nMaxItems, LPINT rgIndex) const;
	void SetAnchorIndex(int nIndex);
	int GetAnchorIndex() const;

	// for listbox items
	DWORD_PTR GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD_PTR dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetItemRect(int nIndex, LPRECT lpRect) const;
	int GetText(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const;
	void GetText(int nIndex, CString& rString) const;
	int GetTextLen(int nIndex) const;

	// Settable only attributes
	void SetColumnWidth(int cxWidth);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
	int GetCaretIndex() const;
	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE);

// Operations
	// manipulating listbox items
	int AddString(LPCTSTR lpszItem);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCTSTR lpszItem);
	void ResetContent();
	int Dir(UINT attr, LPCTSTR lpszWildCard);

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszItem) const;
	int SelectString(int nStartAfter, LPCTSTR lpszItem);
	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem);

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
	virtual int VKeyToItem(UINT nKey, UINT nIndex);
	virtual int CharToItem(UINT nKey, UINT nIndex);

// Implementation
public:
	virtual ~CListBox();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CCheckListBox : public CListBox
{
	DECLARE_DYNAMIC(CCheckListBox)

// Constructors
public:
	CCheckListBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	void SetCheckStyle(UINT nStyle);
	UINT GetCheckStyle();
	void SetCheck(int nIndex, int nCheck);
	int GetCheck(int nIndex);
	void Enable(int nIndex, BOOL bEnabled = TRUE);
	BOOL IsEnabled(int nIndex);

	virtual CRect OnGetCheckPosition(CRect rectItem, CRect rectCheckBox);

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);

// Implementation
protected:
	void PreDrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void PreMeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	int PreCompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	void PreDeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);
	bool PreDrawItemThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem);
	void PreDrawItemNonThemed(CDC* pDC, DRAWITEMSTRUCT &drawItem, int nCheck, int cyItem);
	void PreDrawItemHelper(LPDRAWITEMSTRUCT lpDrawItemStruct);	

	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);

   void SetSelectionCheck( int nCheck );

// Active Accessibility
	virtual HRESULT get_accRole(VARIANT varChild, VARIANT *pvarRole);
	virtual HRESULT get_accState(VARIANT varChild, VARIANT *pvarState);
	virtual HRESULT get_accDefaultAction(VARIANT varChild, BSTR *pszDefaultAction);
	virtual HRESULT accDoDefaultAction(VARIANT varChild);

#ifdef _DEBUG
	virtual void PreSubclassWindow();
#endif

	int CalcMinimumItemHeight();
	void InvalidateCheck(int nIndex);
	void InvalidateItem(int nIndex);
	int CheckFromPoint(CPoint point, BOOL& bInCheck);

	int m_cyText;
	UINT m_nStyle;

	// Message map functions
protected:
	//{{AFX_MSG(CCheckListBox)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg LRESULT OnSetFont(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBAddString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBFindString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBFindStringExact(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBGetItemData(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBGetText(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBInsertString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSelectString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSetItemData(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnLBSetItemHeight(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CComboBox : public CWnd
{
	DECLARE_DYNAMIC(CComboBox)

// Constructors
public:
	CComboBox();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	// for entire combo box
	int GetCount() const;
	int GetCurSel() const;
	int SetCurSel(int nSelect);
	LCID GetLocale() const;
	LCID SetLocale(LCID nNewLocale);
// Win4
	int GetTopIndex() const;
	int SetTopIndex(int nIndex);
	int InitStorage(int nItems, UINT nBytes);
	void SetHorizontalExtent(UINT nExtent);
	UINT GetHorizontalExtent() const;
	int SetDroppedWidth(UINT nWidth);
	int GetDroppedWidth() const;

#if(WINVER >= 0x0500)
	BOOL GetComboBoxInfo(PCOMBOBOXINFO pcbi) const;
#endif	// WINVER >= 0x0500

#if (_WIN32_WINNT >= 0x501) && defined(UNICODE)
	// Sets the minimum number of visible items in the drop-down list of the combo box.
	BOOL SetMinVisibleItems(_In_ int iMinVisible);

	// Retrieves the minimum number of visible items in the drop-down list of the combo box.
	int GetMinVisible() const;

#ifdef CB_SETCUEBANNER
	// REVIEW: Sets the cue banner text displayed in the edit control of the combo box.
	BOOL SetCueBanner(_In_z_ LPCTSTR lpszText);

	// REVIEW: Retrieves the cue banner text displayed in the edit control of the combo box.
	CString GetCueBanner() const;
	BOOL GetCueBanner(_Out_z_cap_(cchText) LPTSTR lpszText, _In_ int cchText) const;
#endif  // CB_SETCUEBANNER
#endif  // (_WIN32_WINNT >= 0x501) && defined(UNICODE)

	// for edit control
	DWORD GetEditSel() const;
	BOOL LimitText(int nMaxChars);
	BOOL SetEditSel(int nStartChar, int nEndChar);

	// for combobox item
	DWORD_PTR GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD_PTR dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetLBText(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszText) const;
	void GetLBText(int nIndex, CString& rString) const;
	int GetLBTextLen(int nIndex) const;

	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;
	int SetExtendedUI(BOOL bExtended = TRUE);
	BOOL GetExtendedUI() const;
	void GetDroppedControlRect(LPRECT lprect) const;
	BOOL GetDroppedState() const;

// Operations
	// for drop-down combo boxes
	void ShowDropDown(BOOL bShowIt = TRUE);

	// manipulating listbox items
	int AddString(LPCTSTR lpszString);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCTSTR lpszString);
	void ResetContent();
	int Dir(UINT attr, LPCTSTR lpszWildCard);

	// selection helpers
	int FindString(int nStartAfter, LPCTSTR lpszString) const;
	int SelectString(int nStartAfter, LPCTSTR lpszString);

	// Clipboard operations
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
	virtual ~CComboBox();
protected:
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

// NOTE: This class must remain a binary-compatible subset
// of CEditView. Do not add data members or virtual functions
// directly to this class.
class CEdit : public CWnd
{
	// DECLARE_DYNAMIC virtual OK - CWnd already has DECLARE_DYNAMIC
	DECLARE_DYNAMIC(CEdit)

// Constructors
public:
	CEdit();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	DWORD GetSel() const;
	void GetSel(int& nStartChar, int& nEndChar) const;
	HLOCAL GetHandle() const;
	void SetHandle(HLOCAL hBuffer);
	void SetMargins(UINT nLeft, UINT nRight);
	DWORD GetMargins() const;
	void SetLimitText(UINT nMax);
	UINT GetLimitText() const;
	CPoint PosFromChar(UINT nChar) const;
	int CharFromPos(CPoint pt) const;

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	// NOTE: may not return null character
	int GetLine(_In_ int nIndex, _Out_ LPTSTR lpszBuffer) const;
	// NOTE: may not return null character
	int GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const;

#if (_WIN32_WINNT >= 0x501)
	AFX_ANSI_DEPRECATED BOOL SetCueBanner(_In_z_ LPCWSTR lpszText, _In_ BOOL fDrawIfFocused = FALSE);
	AFX_ANSI_DEPRECATED BOOL GetCueBanner(_Out_z_cap_(cchText) LPWSTR lpszText, _In_ int cchText) const;

#if defined(UNICODE)
	CString GetCueBanner() const;

	BOOL ShowBalloonTip(_In_z_ LPCWSTR lpszTitle, _In_z_ LPCWSTR lpszText, _In_ INT ttiIcon = TTI_NONE);
	BOOL ShowBalloonTip(_In_ PEDITBALLOONTIP pEditBalloonTip);
	BOOL HideBalloonTip();
#endif  // (UNICODE)
#endif  // (_WIN32_WINNT >= 0x501)

#if (_WIN32_WINNT >= 0x0600) && defined(UNICODE)
	// REVIEW: Sets the characters in the edit control that are highlighted.
	void SetHighlight(_In_ int ichStart, _In_ int ichEnd);

	// REVIEW: Retrieves the characters in the edit control that are highlighted.
	BOOL GetHighlight(_Out_ int* pichStart, _Out_ int* pichEnd) const;
#endif  // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

// Operations
	void EmptyUndoBuffer();
	BOOL FmtLines(BOOL bAddEOL);

	void LimitText(int nChars = 0);
	int LineFromChar(int nIndex = -1) const;
	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE);
	void SetPasswordChar(TCHAR ch);
	void SetRect(LPCRECT lpRect);
	void SetRectNP(LPCRECT lpRect);
	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;
	TCHAR GetPasswordChar() const;

// Implementation
public:
	// virtual OK here - ~CWnd already virtual
	virtual ~CEdit();
};

class CScrollBar : public CWnd
{
	DECLARE_DYNAMIC(CScrollBar)

// Constructors
public:
	CScrollBar();
	virtual BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	int GetScrollPos() const;
	int SetScrollPos(int nPos, BOOL bRedraw = TRUE);
	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE);
	void ShowScrollBar(BOOL bShow = TRUE);

	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);

	BOOL SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE);
	BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask = SIF_ALL);
	int GetScrollLimit();

#if(_WIN32_WINNT >= 0x0501)
	BOOL GetScrollBarInfo(PSCROLLBARINFO pScrollInfo) const;
#endif	// _WIN32_WINNT >= 0x0501

// Implementation
public:
	virtual ~CScrollBar();
};

#define AFX_PREVIEW_VIEW_ID 1

/// <summary>
/// This class implements a window that is placed on a host window provided by the Shell 
/// for Rich Preview. </summary>
class CMFCPreviewCtrlImpl : public CWnd
{
	DECLARE_DYNAMIC(CMFCPreviewCtrlImpl)

public:
	/// <summary>
	/// Constructs a preview control object.</summary>
	CMFCPreviewCtrlImpl();
	/// <summary>
	/// Destructs a preview control object.</summary>
	virtual ~CMFCPreviewCtrlImpl();

	/// <summary>
	/// Called by preview handler to create a relationship between document implementation and 
	/// preview control.</summary>
	/// <param name="pDocument" A pointer to document implementation.</param>
	void SetDocument(ATL::IDocument* pDocument)
	{
		m_pDocument = pDocument;
	}

	/// <summary>
	/// Returns a document connected to this preview control.</summary>
	/// <returns> A pointer to a document, whose content is previewed in the control.</returns>
	ATL::IDocument* GetDocument()
	{
		return m_pDocument;
	}

	/// <summary> 
	/// Called by a Rich Preview handler to create the Windows window. </summary>
	/// <returns> TRUE if creation succeeded; otherwise FALSE.</returns>
	/// <param name="hWndParent"> A handle to the host window supplied by the Shell for Rich Preview. </param> 
	/// <param name="prc"> Specifies initial size and position of the window. </param> 
	virtual BOOL Create(HWND hWndParent, const RECT* prc);

	/// <summary> 
	/// Called by a Rich Preview handler to create the Windows window. </summary>
	/// <returns>TRUE if creation succeeded; otherwise FALSE.</returns>
	/// <param name="hWndParent"> A handle to the host window supplied by the Shell for Rich Preview. </param> 
	/// <param name="prc"> Specifies initial size and position of the window. </param> 
	/// <param name="pContext"> A pointer to a creation context.</param> 
	virtual BOOL Create(HWND hWndParent, const RECT* prc, CCreateContext* pContext);

	/// <summary> 
	/// Called by a Rich Preview handler when it needs to set visuals of rich preview content.</summary>
	/// <param name="clrBack"> Background color of preview window. </param> 
	/// <param name="clrText"> Text color of preview window. </param> 
	/// <param name="plf"> Font used to display texts in preview window. </param> 
	virtual void SetPreviewVisuals(COLORREF clrBack, COLORREF clrText, const LOGFONTW *plf);

	/// <summary> 
	/// Called by a Rich Preview handler when it needs to destroy this control.</summary>
	virtual void Destroy();

	/// <summary> 
	/// Sets a new parent for this control. </summary>
	/// <param name="hWndParent">A handle to the new parent window.</param>
	virtual void SetHost(HWND hWndParent);

	/// <summary> 
	/// Tells this control to redraw. </summary>
	virtual void Redraw();

	/// <summary> 
	/// Sets a new bounding rectangle for this control. </summary>
	/// <remarks> Usually new bounding rectangle is set when the host control is resized.</remarks>
	/// <param name="prc">Specifies the new size and position of preview control.</param>
	/// <param name="bRedraw">Specifies whether the control should be redrawn.</param>
	virtual void SetRect(const RECT* prc, BOOL bRedraw);

	/// <summary> 
	/// Sets input focus to this control. </summary>
	virtual void Focus();

protected:
	DECLARE_MESSAGE_MAP()
public:
	afx_msg void OnNcDestroy();
	afx_msg void OnPaint();
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSize(UINT nType, int cx, int cy);

protected:
	/// <summary> Called by the framework to render the preview.</summary>
	/// <param name="pDC">A pointer to a device context for painting.</param>
	virtual void DoPaint(CPaintDC* pDC);

protected:
	/// <summary> Background color of preview window. </summary> 
	COLORREF m_clrBackColor;
	/// <summary> Text color of preview window. </summary> 
	COLORREF m_clrTextColor;
	/// <summary> Font used to display texts in preview window. </summary> 
	CFont    m_font;
	/// <summary> A pointer to a document whose content is previewed in the control.</summary>
	ATL::IDocument* m_pDocument;
};

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd - base class for SDI and other frame windows

// Frame window styles
#define FWS_ADDTOTITLE  0x00008000L // modify title based on content
#define FWS_PREFIXTITLE 0x00004000L // show document name before app name
#define FWS_SNAPTOBARS  0x00002000L // snap size to size of contained bars

// Frame window menu bar visibility styles
#define AFX_MBV_KEEPVISIBLE    0x01L // always visible
#define AFX_MBV_DISPLAYONFOCUS 0x02L // toggle state on ALT
#define AFX_MBV_DISPLAYONF10   0x04L // display on F10

// Frame window menu bar visibility states
#define AFX_MBS_VISIBLE 0x01L // visible
#define AFX_MBS_HIDDEN  0x02L // hidden

struct CPrintPreviewState;  // forward reference (see afxext.h)
class CControlBar;          // forward reference (see afxext.h)
class CReBar;               // forward reference (see afxext.h)

class CDockBar;             // forward reference (see afxpriv.h)
class CMiniDockFrameWnd;    // forward reference (see afxpriv.h)
class CDockState;           // forward reference (see afxpriv.h)

class COleFrameHook;        // forward reference (see ..\src\oleimpl2.h)

class CFrameWnd : public CWnd
{
	DECLARE_DYNCREATE(CFrameWnd)

// Constructors
public:
	static AFX_DATA const CRect rectDefault;
	CFrameWnd();

	BOOL LoadAccelTable(LPCTSTR lpszResourceName);
	virtual BOOL Create(LPCTSTR lpszClassName,
				LPCTSTR lpszWindowName,
				DWORD dwStyle = WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CWnd* pParentWnd = NULL,        // != NULL for popups
				LPCTSTR lpszMenuName = NULL,
				DWORD dwExStyle = 0,
				CCreateContext* pContext = NULL);

	// dynamic creation - load frame and associated resources
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

	// special helper for view creation
	CWnd* CreateView(CCreateContext* pContext, UINT nID = AFX_IDW_PANE_FIRST);

// Attributes
	virtual CDocument* GetActiveDocument();

	// Active child view maintenance
	CView* GetActiveView() const;           // active view or NULL
	void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
		// active view or NULL, bNotify == FALSE if focus should not be set

	// Active frame (for frames within frames -- MDI)
	virtual CFrameWnd* GetActiveFrame();

	// For customizing the default messages on the status bar
	virtual void GetMessageString(UINT nID, CString& rMessage) const;

	BOOL m_bAutoMenuEnable;
		// TRUE => menu items without handlers will be disabled

	BOOL IsTracking() const;

// Operations
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void ActivateFrame(int nCmdShow = -1);
	void InitialUpdateFrame(CDocument* pDoc, BOOL bMakeVisible);
	void SetTitle(LPCTSTR lpszTitle);
	CString GetTitle() const;
	virtual CMenu* GetMenu() const;
	virtual BOOL SetMenu(CMenu* pMenu);

	// set/get menu bar visibility style
	virtual void SetMenuBarVisibility(DWORD dwStyle);
	virtual DWORD GetMenuBarVisibility() const;

	// set/get menu bar visibility state
	virtual BOOL SetMenuBarState(DWORD dwState);
	virtual DWORD GetMenuBarState() const;

#if (WINVER >= 0x0601)
	/// <summary>
	/// Sets range for Windows 7 progress bar displayed on taskbar. </summary>
	/// <param name="nRangeMin">Minimal value.</param>
	/// <param name="nRangeMax">Maximal value.</param>
	void SetProgressBarRange(int nRangeMin, int nRangeMax);
	/// <summary>
	/// Sets current position for Windows 7 progress bar displayed on taskbar.</summary>
	/// <param name="nProgressPos">Specifies the position to set. It must be within range set by SetProgressBarRange.</param>
	void SetProgressBarPosition(int nProgressPos);
	/// <summary>Sets the type and state of the progress indicator displayed on a taskbar button.</summary>
	/// <param name="tbpFlags">Flags that control the current state of the progress button. Specify only one of the following flags; all states are mutually exclusive of all others: 
	/// TBPF_NOPROGRESS, TBPF_INDETERMINATE, TBPF_NORMAL, TBPF_ERROR, TBPF_PAUSED.</param>
	void SetProgressBarState(TBPFLAG tbpFlags);
	/// <summary>
	/// Applies an overlay to a taskbar button to indicate application status or a notification to the user.</summary>
	/// <returns> TRUE if successful; FALSE if OS version is less than Windows 7 or if an error occurs setting the icon.</returns>
	/// <param name="nIDResource">Specifies Resource ID of an icon to use as the overlay. See description for hIcon for details.</param>
	/// <param name="lpcszDescr">A pointer to a string that provides an alt text version of the information conveyed by the overlay, for accessibility purposes.</param>
	BOOL SetTaskbarOverlayIcon(UINT nIDResource, LPCTSTR lpcszDescr);
	/// <summary>
	/// Applies an overlay to a taskbar button to indicate application status or a notification to the user.</summary>
	/// <returns> TRUE if successful; FALSE if OS version is less than Windows 7 or if an error occurs setting the icon.</returns>
	/// <param name="hIcon"> The handle of an icon to use as the overlay. This should be a small icon, measuring 16x16 pixels at 96 dots per inch (dpi). 
	/// If an overlay icon is already applied to the taskbar button, that existing overlay is replaced. 
	/// This value can be NULL. How a NULL value is handled depends on whether the taskbar button represents a single window or a group of windows.
	/// It is the responsibility of the calling application to free hIcon when it is no longer needed.</param>
	/// <param name="lpcszDescr">A pointer to a string that provides an alt text version of the information conveyed by the overlay, for accessibility purposes.</param>
	BOOL SetTaskbarOverlayIcon(HICON hIcon, LPCTSTR lpcszDescr);
#endif

#if WINVER >= 0x0500
	BOOL GetMenuBarInfo(LONG idObject, LONG idItem, PMENUBARINFO pmbi) const;
#endif

	/// <summary> Designates the specified view to be the active view for Rich Preview.</summary>
	/// <param name="pViewNew"> A pointer to a view that should be activated.</param>
	void SetActivePreviewView(CView* pViewNew);

	// to set text of standard status bar
	void SetMessageText(LPCTSTR lpszText);
	void SetMessageText(UINT nID);

	// control bar docking
	void EnableDocking(DWORD dwDockStyle);
	void DockControlBar(CControlBar* pBar, UINT nDockBarID = 0,
		LPCRECT lpRect = NULL);
	void FloatControlBar(CControlBar* pBar, CPoint point,
		DWORD dwStyle = CBRS_ALIGN_TOP);
	CControlBar* GetControlBar(UINT nID);

	// frame window based modality
	virtual void BeginModalState();
	virtual void EndModalState();
	BOOL InModalState() const;
	void ShowOwnedWindows(BOOL bShow);

	// saving and loading control bar state
	void LoadBarState(LPCTSTR lpszProfileName);
	void SaveBarState(LPCTSTR lpszProfileName) const;
	void ShowControlBar(CControlBar* pBar, BOOL bShow, BOOL bDelay);
	void SetDockState(const CDockState& state);
	void GetDockState(CDockState& state) const;

// Overridables
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
	virtual CWnd* GetMessageBar();

	// border space negotiation
	enum BorderCmd
		{ borderGet = 1, borderRequest = 2, borderSet = 3 };
	virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

// Command Handlers
public:
	afx_msg void OnContextHelp();   // for Shift+F1 help
	afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnBarCheck(UINT nID);

// Implementation
public:
	virtual ~CFrameWnd();
	int m_nWindow;  // general purpose window number - display as ":n"
					// -1 => unknown, 0 => only window viewing document
					// 1 => first of many windows viewing document, 2=> second

	HMENU m_hMenuDefault;       // default menu resource for this frame
	HACCEL m_hAccelTable;       // accelerator table
	DWORD m_dwPromptContext;    // current help prompt context for message box
	BOOL m_bHelpMode;           // if TRUE, then Shift+F1 help mode is active
	CFrameWnd* m_pNextFrameWnd; // next CFrameWnd in app global list
	CRect m_rectBorder;         // for OLE border space negotiation
	COleFrameHook* m_pNotifyHook;

	CPtrList m_listControlBars; // array of all control bars that have this
								// window as their dock site
	int m_nShowDelay;           // SW_ command for delay show/hide

	CMiniDockFrameWnd* CreateFloatingFrame(DWORD dwStyle);
	DWORD CanDock(CRect rect, DWORD dwDockStyle,
		CDockBar** ppDockBar = NULL); // called by CDockContext
	void AddControlBar(CControlBar *pBar);
	void RemoveControlBar(CControlBar *pBar);
	void DockControlBar(CControlBar* pBar, CDockBar* pDockBar,
		LPCRECT lpRect = NULL);
	void ReDockControlBar(CControlBar* pBar, CDockBar* pDockBar,
		LPCRECT lpRect = NULL);
	void NotifyFloatingWindows(DWORD dwFlags);
	void DestroyDockBars();

protected:
	UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)
	UINT m_nIDTracking;         // tracking command ID or string IDS
	UINT m_nIDLastMessage;      // last displayed message string IDS
	CView* m_pViewActive;       // current active view
	BOOL (CALLBACK* m_lpfnCloseProc)(CFrameWnd* pFrameWnd);
	UINT m_cModalStack;         // BeginModalState depth
	HWND* m_phWndDisable;       // windows disabled because of BeginModalState
	HMENU m_hMenuAlt;           // menu to update to (NULL means default)
	CString m_strTitle;         // default title (original)
	BOOL m_bInRecalcLayout;     // avoid recursion in RecalcLayout
	CRuntimeClass* m_pFloatingFrameClass;
	static const DWORD dwDockBarMap[4][2];
    DWORD m_dwMenuBarVisibility;      // menu bar visibility style
	DWORD m_dwMenuBarState;           // menu bar visibility state
	HMENU m_hMenu;                    // backed menu for restoring from the hidden state
	BOOL  m_bTempShowMenu;            // temporarily show the menu bar to enable menu access keys
	BOOL  m_bMouseHitMenu;            // if TRUE, the mouse is hitting the menu bar

	int m_nProgressBarRangeMin; // Win7 taskbar support - min progress range
	int m_nProgressBarRangeMax; // Win7 taskbar support - max progress range

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL IsFrameWnd() const;
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual HACCEL GetDefaultAccelerator();
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// idle update of frame user interface
	enum IdleFlags
		{ idleMenu = 1, idleTitle = 2, idleNotify = 4, idleLayout = 8 };
	UINT m_nIdleFlags;          // set of bit flags for idle processing
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	void DelayUpdateFrameTitle();
	void DelayRecalcLayout(BOOL bNotify = TRUE);

	// for Shift+F1 help support
	BOOL CanEnterHelpMode();
	virtual void ExitHelpMode();

	// implementation helpers
public:
	void UpdateFrameTitleForDocument(LPCTSTR lpszDocName);
protected:
	LPCTSTR GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();   // default to delete this.
	int OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	void BringToTop(int nCmdShow);
		// bring window to top for SW_ commands which affect z-order

	// implementation helpers for Shift+F1 help mode
	BOOL ProcessHelpMsg(MSG& msg, DWORD* pContext);
	HWND SetHelpCapture(POINT point, BOOL* pbDescendant);

	// CFrameWnd list management
	void AddFrameWnd();
	void RemoveFrameWnd();

	// called before changing the menu bar visibility state
	virtual void OnShowMenuBar();
	virtual void OnHideMenuBar();

	friend class CWnd;  // for access to m_bModalDisable
	friend class CReBar; // for access to m_bInRecalcLayout

	//{{AFX_MSG(CFrameWnd)
	// Windows messages
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnClose();
	afx_msg void OnInitMenu(CMenu*);
	afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg LRESULT OnPopMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpPromptAddr(WPARAM wParam, LPARAM lParam);
	afx_msg void OnIdleUpdateCmdUI();
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg BOOL OnQueryEndSession();
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnActivateTopLevel(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg BOOL OnQueryNewPalette();
	// standard commands
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateKeyIndicator(CCmdUI* pCmdUI);
	afx_msg void OnHelp();
	afx_msg void OnUpdateContextHelp(CCmdUI* pCmdUI);
	afx_msg BOOL OnChevronPushed(UINT id, NMHDR *pnm, LRESULT *result);
	//}}AFX_MSG
protected:
	afx_msg LRESULT OnDDEInitiate(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDEExecute(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDETerminate(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()

	friend class CWinApp;
};

/////////////////////////////////////////////////////////////////////////////
// MDI Support

class CMDIFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIFrameWnd)

public:
// Constructors
	CMDIFrameWnd();

// Operations
	void MDIActivate(CWnd* pWndActivate);
	CMDIChildWnd* MDIGetActive(BOOL* pbMaximized = NULL) const;
	void MDIIconArrange();
	void MDIMaximize(CWnd* pWnd);
	void MDINext();
	void MDIPrev();
	void MDIRestore(CWnd* pWnd);
	CMenu* MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu);
	void MDITile();
	void MDICascade();
	void MDITile(int nType);
	void MDICascade(int nType);
	CMDIChildWnd* CreateNewChild(CRuntimeClass* pClass, UINT nResource,
		HMENU hMenu = NULL, HACCEL hAccel = NULL);

// Overridables
	// MFC 1.0 backward compatible CreateClient hook (called by OnCreateClient)
	virtual BOOL CreateClient(LPCREATESTRUCT lpCreateStruct, CMenu* pWindowMenu);
	// customize if using an 'Window' menu with non-standard IDs
	virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);

// Implementation
public:
	HWND m_hWndMDIClient;       // MDI Client window handle

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	virtual CFrameWnd* GetActiveFrame();
	virtual void SetMenuBarVisibility(DWORD dwStyle);
	virtual BOOL SetMenuBarState(DWORD dwState);

protected:
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CMDIFrameWnd)
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateMDIWindowCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnMDIWindowCmd(UINT nID);
	afx_msg void OnWindowNew();
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg void OnIdleUpdateCmdUI();
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT, CMenu*);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CMDIChildWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIChildWnd)

// Constructors
public:
	CMDIChildWnd();

	virtual BOOL Create(LPCTSTR lpszClassName,
				LPCTSTR lpszWindowName,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CMDIFrameWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

// Attributes
	CMDIFrameWnd* GetMDIFrame();

// Operations
	void MDIDestroy();
	void MDIActivate();
	void MDIMaximize();
	void MDIRestore();
	void SetHandles(HMENU hMenu, HACCEL hAccel);

// Implementation
protected:
	HMENU m_hMenuShared;        // menu when we are active

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
					CWnd* pParentWnd, CCreateContext* pContext = NULL);
		// 'pParentWnd' parameter is required for MDI Child
	virtual BOOL DestroyWindow();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
		HMENU hMenuAlt);

	BOOL m_bPseudoInactive;     // TRUE if window is MDI active according to
								//  windows, but not according to MFC...

protected:
	virtual CWnd* GetMessageBar();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	BOOL UpdateClientEdge(LPRECT lpRect = NULL);

	//{{AFX_MSG(CMDIChildWnd)
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWindowPosChanging(LPWINDOWPOS lpWndPos);
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnDestroy();
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CMiniFrameWnd

// MiniFrame window styles
#define MFS_SYNCACTIVE      0x00000100L // syncronize activation w/ parent
#define MFS_4THICKFRAME     0x00000200L // thick frame all around (no tiles)
#define MFS_THICKFRAME      0x00000400L // use instead of WS_THICKFRAME
#define MFS_MOVEFRAME       0x00000800L // no sizing, just moving
#define MFS_BLOCKSYSMENU    0x00001000L // block hit testing on system menu

#pragma warning( push )

#pragma warning( disable: 4263 )
#pragma warning( disable: 4264 )
class CMiniFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMiniFrameWnd)

// Constructors
public:
	CMiniFrameWnd();
	virtual BOOL Create(LPCTSTR lpClassName, LPCTSTR lpWindowName,
		DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd = NULL, UINT nID = 0);
	virtual BOOL CreateEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName,
		DWORD dwStyle, const RECT& rect,
		CWnd* pParentWnd = NULL, UINT nID = 0);

// Implementation
public:
	~CMiniFrameWnd();

	//{{AFX_MSG(CMiniFrameWnd)
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg LRESULT OnNcHitTest(CPoint point);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO* pMMI);
	afx_msg LRESULT OnFloatStatus(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnQueryCenterWnd(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
	static void PASCAL CalcBorders(LPRECT lpClientRect,
		DWORD dwStyle = WS_THICKFRAME | WS_CAPTION, DWORD dwExStyle = 0);

protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

protected:
	BOOL m_bSysTracking;
	BOOL m_bInSys;
	BOOL m_bActive;
	CString m_strCaption;
};

#pragma warning( pop )

/////////////////////////////////////////////////////////////////////////////
// class CView is the client area UI for a document

class CPrintDialog;     // forward reference (see afxdlgs.h)
class CPreviewView;     // forward reference (see afxpriv.h)
class CSplitterWnd;     // forward reference (see afxext.h)
class COleServerDoc;    // forward reference (see afxole.h)

typedef DWORD DROPEFFECT;
class COleDataObject;   // forward reference (see afxole.h)

class AFX_NOVTABLE CView : public CWnd
{
	friend class CWinAppEx;

	DECLARE_DYNAMIC(CView)

// Constructors
protected:
	CView();

// Attributes
public:
	CDocument* GetDocument() const;

// Operations
public:
	// for standard printing setup (override OnPreparePrinting)
	BOOL DoPreparePrinting(CPrintInfo* pInfo);

// Overridables
public:
	virtual BOOL IsSelected(const CObject* pDocItem) const; // support for OLE

	// OLE scrolling support (used for drag/drop as well)
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	// OLE drag/drop support
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave();
	virtual BOOL OnDrop(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);
	virtual DROPEFFECT OnDropEx(COleDataObject* pDataObject,
		DROPEFFECT dropDefault, DROPEFFECT dropList, CPoint point);
	virtual DROPEFFECT OnDragScroll(DWORD dwKeyState, CPoint point);

	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

	virtual void OnInitialUpdate(); // called first time after construct

protected:
	// Activation
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);
	virtual void OnActivateFrame(UINT nState, CFrameWnd* pFrameWnd);

	// General drawing/updating
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual void OnDraw(CDC* pDC) = 0;

	// Printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
		// must override to enable printing and print preview

	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

	// Advanced: end print preview mode, move to point
	virtual void OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo, POINT point,
		CPreviewView* pView);

// Implementation
public:
	virtual ~CView() = 0;
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

	// Advanced: for implementing custom print preview
	BOOL DoPrintPreview(UINT nIDResource, CView* pPrintView,
			CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState);

	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
	static CSplitterWnd* PASCAL GetParentSplitter(
		const CWnd* pWnd, BOOL bAnyState);

protected:
	CDocument* m_pDocument;
	BOOL m_bInitialRedraw;

public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PostNcDestroy();

	// friend classes that call protected CView overridables
	friend class CDocument;
	friend class CDocTemplate;
	friend class CPreviewView;
	friend class CFrameWnd;
	friend class CMDIFrameWnd;
	friend class CMDIChildWnd;
	friend class CSplitterWnd;
	friend class COleServerDoc;
	friend class CDocObjectServer;

	//{{AFX_MSG(CView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);

	// Print client support: used for interaction with Windows task bar
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);

	// commands
	afx_msg void OnUpdateSplitCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnSplitCmd(UINT nID);
	afx_msg void OnUpdateNextPaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnNextPaneCmd(UINT nID);

	// not mapped commands - must be mapped in derived class
	afx_msg void OnFilePrint();
	afx_msg void OnFilePrintPreview();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CCtrlView allows almost any control to be a view

class AFX_NOVTABLE CCtrlView : public CView
{
	DECLARE_DYNCREATE(CCtrlView)

public:
	CCtrlView(LPCTSTR lpszClass, DWORD dwStyle);

// Attributes
protected:
	CString m_strClass;
	DWORD m_dwDefaultStyle;

// Overrides
	virtual void OnDraw(CDC* pDC);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

// Implementation
public:
	~CCtrlView() = 0;
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:
	afx_msg void OnPaint();
	afx_msg LRESULT OnPrintClient(WPARAM wp, LPARAM lp);

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CScrollView supports simple scrolling and scaling

class _AFX_MOUSEANCHORWND;

class CScrollView : public CView
{
	DECLARE_DYNAMIC(CScrollView)

// Constructors
protected:
	CScrollView();

public:
	static AFX_DATA const SIZE sizeDefault;
		// used to specify default calculated page and line sizes

	// in logical units - call one of the following Set routines
	void SetScaleToFitSize(SIZE sizeTotal);
	void SetScrollSizes(int nMapMode, SIZE sizeTotal,
				const SIZE& sizePage = sizeDefault,
				const SIZE& sizeLine = sizeDefault);

// Attributes
public:
	CPoint GetScrollPosition() const;       // upper corner of scrolling
	CSize GetTotalSize() const;             // logical size

	void CheckScrollBars(BOOL& bHasHorzBar, BOOL& bHasVertBar) const;

	// for device units
	CPoint GetDeviceScrollPosition() const;
	void GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
			SIZE& sizePage, SIZE& sizeLine) const;

// Operations
public:
	void ScrollToPosition(POINT pt);    // set upper left position
	void FillOutsideRect(CDC* pDC, CBrush* pBrush);
	void ResizeParentToFit(BOOL bShrinkOnly = TRUE);
	BOOL DoMouseWheel(UINT fFlags, short zDelta, CPoint point);

// Implementation
protected:
	_AFX_MOUSEANCHORWND* m_pAnchorWindow; // window for wheel mouse anchor
	friend class _AFX_MOUSEANCHORWND;
	int m_nMapMode;				 // mapping mode for window creation
	CSize m_totalLog;           // total size in logical units (no rounding)
	CSize m_totalDev;           // total size in device units
	CSize m_pageDev;            // per page scroll size in device units
	CSize m_lineDev;            // per line scroll size in device units

	BOOL m_bCenter;             // Center output if larger than total size
	BOOL m_bInsideUpdate;       // internal state for OnSize callback
	void CenterOnPoint(CPoint ptCenter);
	void ScrollToDevicePosition(POINT ptDev); // explicit scrolling no checking

protected:
	virtual void OnDraw(CDC* pDC) = 0;      // pass on pure virtual

	void UpdateBars();          // adjust scrollbars etc
	BOOL GetTrueClientSize(CSize& size, CSize& sizeSb);
		// size with no bars
	void GetScrollBarSizes(CSize& sizeSb);
	void GetScrollBarState(CSize sizeClient, CSize& needSb,
		CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient);

public:
	virtual ~CScrollView();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

	virtual CSize GetWheelScrollDistance(CSize sizeDistance,
		BOOL bHorz, BOOL bVert);

	// scrolling implementation support for OLE
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	//{{AFX_MSG(CScrollView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg BOOL OnMouseWheel(UINT fFlags, short zDelta, CPoint point);
//	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	afx_msg LRESULT HandleMButtonDown(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnPrintClient(WPARAM wParam, LPARAM lParam);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWinThread

typedef UINT (AFX_CDECL *AFX_THREADPROC)(LPVOID);

class COleMessageFilter;        // forward reference (see afxole.h)

BOOL AFXAPI AfxPumpMessage();
LRESULT AFXAPI AfxProcessWndProcException(CException*, const MSG* pMsg);
BOOL __cdecl AfxPreTranslateMessage(MSG* pMsg);
BOOL __cdecl AfxIsIdleMessage(MSG* pMsg);

class CWinThread : public CCmdTarget
{
	DECLARE_DYNAMIC(CWinThread)

	friend BOOL AfxInternalPreTranslateMessage(MSG* pMsg);

public:
// Constructors
	CWinThread();
	BOOL CreateThread(DWORD dwCreateFlags = 0, UINT nStackSize = 0,
		LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

// Attributes
	CWnd* m_pMainWnd;       // main window (usually same AfxGetApp()->m_pMainWnd)
	CWnd* m_pActiveWnd;     // active main window (may not be m_pMainWnd)
	BOOL m_bAutoDelete;     // enables 'delete this' after thread termination

	// only valid while running
	HANDLE m_hThread;       // this thread's HANDLE
	operator HANDLE() const;
	DWORD m_nThreadID;      // this thread's ID

	int GetThreadPriority();
	BOOL SetThreadPriority(int nPriority);

// Operations
	DWORD SuspendThread();
	DWORD ResumeThread();
	BOOL PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam);

// Overridables
	// thread initialization
	virtual BOOL InitInstance();

	// running and idle processing
	virtual int Run();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL PumpMessage();     // low level message pump
	virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
	virtual BOOL IsIdleMessage(MSG* pMsg);  // checks for special messages

	// thread termination
	virtual int ExitInstance(); // default will 'delete this'

	// Advanced: exception handling
	virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

	// Advanced: handling messages sent to message filter hook
	virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);

	// Advanced: virtual access to m_pMainWnd
	virtual CWnd* GetMainWnd();

// Implementation
public:
	virtual ~CWinThread();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	void CommonConstruct();
	virtual void Delete();
		// 'delete this' only if m_bAutoDelete == TRUE

public:
	// constructor used by implementation of AfxBeginThread
	CWinThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam);

	// valid after construction
	LPVOID m_pThreadParams; // generic parameters passed to starting function
	AFX_THREADPROC m_pfnThreadProc;

	// set after OLE is initialized
	void (AFXAPI* m_lpfnOleTermOrFreeLib)(BOOL, BOOL);
	COleMessageFilter* m_pMessageFilter;

protected:
	BOOL DispatchThreadMessageEx(MSG* msg);  // helper
	void DispatchThreadMessage(MSG* msg);  // obsolete
};

// global helpers for threads

CWinThread* AFXAPI AfxBeginThread(AFX_THREADPROC pfnThreadProc, LPVOID pParam,
	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);
CWinThread* AFXAPI AfxBeginThread(CRuntimeClass* pThreadClass,
	int nPriority = THREAD_PRIORITY_NORMAL, UINT nStackSize = 0,
	DWORD dwCreateFlags = 0, LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL);

CWinThread* AFXAPI AfxGetThread();
MSG* AFXAPI AfxGetCurrentMessage();

void AFXAPI AfxEndThread(UINT nExitCode, BOOL bDelete = TRUE);

void AFXAPI AfxInitThread();
void AFXAPI AfxTermThread(HINSTANCE hInstTerm = NULL);

/////////////////////////////////////////////////////////////////////////////
// Global functions for access to the one and only CWinApp

#define afxCurrentWinApp    AfxGetModuleState()->m_pCurrentWinApp
#define afxCurrentInstanceHandle    AfxGetModuleState()->m_hCurrentInstanceHandle
#define afxCurrentResourceHandle    AfxGetModuleState()->m_hCurrentResourceHandle
#define afxCurrentAppName   AfxGetModuleState()->m_lpszCurrentAppName
#define afxContextIsDLL     AfxGetModuleState()->m_bDLL
#define afxRegisteredClasses    AfxGetModuleState()->m_fRegisteredClasses
#define afxAmbientActCtx    AfxGetModuleState()->m_bSetAmbientActCtx

#ifndef _AFX_NO_OCC_SUPPORT
#define afxOccManager   AfxGetModuleState()->m_pOccManager
#endif

//Fusion: Access macros for WinSxS dynamic wrappers.
#ifndef _AFX_NO_AFXCMN_SUPPORT
#define _AFX_COMCTL32_ISOLATION_WRAPPER_INDEX 0
#define afxComCtlWrapper static_cast<CComCtlWrapper*>(AfxGetModuleState()->m_pDllIsolationWrappers[_AFX_COMCTL32_ISOLATION_WRAPPER_INDEX])
#endif

#define _AFX_COMMDLG_ISOLATION_WRAPPER_INDEX 1
#define afxCommDlgWrapper static_cast<CCommDlgWrapper*>(AfxGetModuleState()->m_pDllIsolationWrappers[_AFX_COMMDLG_ISOLATION_WRAPPER_INDEX])

#define _AFX_SHELL_ISOLATION_WRAPPER_INDEX 2
#define afxShellWrapper static_cast<CShellWrapper*>(AfxGetModuleState()->m_pDllIsolationWrappers[_AFX_SHELL_ISOLATION_WRAPPER_INDEX])

#define _AFX_ISOLATION_WRAPPER_ARRAY_SIZE 3

// Advanced initialization: for overriding default WinMain
BOOL AFXAPI AfxWinInit(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance,
	_In_z_ LPTSTR lpCmdLine, _In_ int nCmdShow);
void AFXAPI AfxWinTerm();

// Global Windows state data helper functions (inlines)
#ifdef _AFXDLL
ULONG AFXAPI AfxGetDllVersion();
#endif

CWinApp* AFXAPI AfxGetApp();
CWnd* AFXAPI AfxGetMainWnd();
HINSTANCE AFXAPI AfxGetInstanceHandle();
HINSTANCE AFXAPI AfxGetResourceHandle();
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
LPCTSTR AFXAPI AfxGetAppName();
AFX_DEPRECATED("AfxLoadLangResourceDLL(LPCTSTR pszFormat) has been deprecated, use AfxLoadLangResourceDLL(LPCTSTR pszFormat, LPCTSTR pszPath) instead")
	HINSTANCE AFXAPI AfxLoadLangResourceDLL(LPCTSTR pszFormat);
HINSTANCE AFXAPI AfxLoadLangResourceDLL(LPCTSTR pszFormat, LPCTSTR pszPath);

// Use instead of PostQuitMessage in OLE server applications
void AFXAPI AfxPostQuitMessage(int nExitCode);

// Use AfxFindResourceHandle to find resource in chain of extension DLLs
#ifndef _AFXDLL
#define AfxFindResourceHandle(lpszResource, lpszType) AfxGetResourceHandle()
#else
HINSTANCE AFXAPI AfxFindResourceHandle(LPCTSTR lpszName, LPCTSTR lpszType);
#endif

/// <summary>
/// Deletes the subkeys and values of the specified key recursively.</summary>
/// <returns> 
/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
/// <param name="hKey">A handle to an open registry key.</param>
/// <param name="lpSubKey">The name of the key to be deleted.</param>
/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
LONG AFXAPI AfxDelRegTreeHelper(HKEY hParentKey, const CString& strKeyName, CAtlTransactionManager* pTM = NULL);

class CRecentFileList;          // forward reference (see afxadv.h)
class CDataRecoveryHandler;     // forward reference (see afxdatarecovery.h)

// access to message filter in CWinApp
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();

/////////////////////////////////////////////////////////////////////////////
// CCommandLineInfo

class CCommandLineInfo : public CObject
{
public:
	// Sets default values
	CCommandLineInfo();

	// plain char* version on UNICODE for source-code backwards compatibility
	virtual void ParseParam(const TCHAR* pszParam, BOOL bFlag, BOOL bLast);
#ifdef _UNICODE
	virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
#endif

	BOOL m_bShowSplash;
	BOOL m_bRunEmbedded;
	BOOL m_bRunAutomated;
	BOOL m_bRegisterPerUser;
	enum { FileNew, FileOpen, FilePrint, FilePrintTo, FileDDE, FileDDENoShow, AppRegister,
		AppUnregister, RestartByRestartManager, FileNothing = -1 } m_nShellCommand;

	// not valid for FileNew
	CString m_strFileName;

	// valid only for FilePrintTo
	CString m_strPrinterName;
	CString m_strDriverName;
	CString m_strPortName;

	// valid only for RestartByRestartManager
	CString m_strRestartIdentifier;

	~CCommandLineInfo();
// Implementation
protected:
	void ParseParamFlag(const char* pszParam);
	void ParseParamNotFlag(const TCHAR* pszParam);
#ifdef _UNICODE
	void ParseParamNotFlag(const char* pszParam);
#endif
	void ParseLast(BOOL bLast);
};

/////////////////////////////////////////////////////////////////////////////
// CDocManager

class CDocManager : public CObject
{
	DECLARE_DYNAMIC(CDocManager)
public:

// Constructor
	CDocManager();

	//Document functions
	virtual void AddDocTemplate(CDocTemplate* pTemplate);
	virtual POSITION GetFirstDocTemplatePosition() const;
	virtual CDocTemplate* GetNextDocTemplate(POSITION& pos) const;
	virtual void RegisterShellFileTypes(BOOL bCompat);
	void UnregisterShellFileTypes();
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName); // open named file
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName, BOOL bAddToMRU); // open named file
	virtual BOOL SaveAllModified(); // save before exit
	virtual void CloseAllDocuments(BOOL bEndSession); // close documents before exiting
	virtual int GetOpenDocumentCount();
	virtual CDocTemplate* GetBestTemplate(LPCTSTR lpszFileName); // return best template named file

	// helper for standard commdlg dialogs
	virtual BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
			DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);

//Commands
	// Advanced: process async DDE request
	virtual BOOL OnDDECommand(_In_z_ LPTSTR lpszCommand);
	virtual void OnFileNew();
	virtual void OnFileOpen();

// Implementation
protected:
	CPtrList m_templateList;
	int GetDocumentCount(); // helper to count number of total documents

public:
	static CPtrList* pStaticList;       // for static CDocTemplate objects
	static BOOL bStaticInit;            // TRUE during static initialization
	static CDocManager* pStaticDocManager;  // for static CDocTemplate objects

public:
	virtual ~CDocManager();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CWinApp - the root of all Windows applications

#define _AFX_MRU_COUNT   4      // default support for 4 entries in file MRU
#define _AFX_MRU_MAX_COUNT 16   // currently allocated id range supports 16

#define _AFX_SYSPOLICY_NOTINITIALIZED			0
#define _AFX_SYSPOLICY_NORUN					1 
#define _AFX_SYSPOLICY_NODRIVES					2
#define _AFX_SYSPOLICY_RESTRICTRUN				4
#define _AFX_SYSPOLICY_NONETCONNECTDISCONNECTD	8
#define _AFX_SYSPOLICY_NOENTIRENETWORK			16
#define _AFX_SYSPOLICY_NORECENTDOCHISTORY		32
#define _AFX_SYSPOLICY_NOCLOSE					64
#define _AFX_SYSPOLICY_NOPLACESBAR				128
#define _AFX_SYSPOLICY_NOBACKBUTTON				256
#define _AFX_SYSPOLICY_NOFILEMRU				512

struct _AfxSysPolicyData
{
	LPCTSTR szPolicyName;
	DWORD dwID;
};

struct _AfxSysPolicies
{
	LPCTSTR szPolicyKey;
	_AfxSysPolicyData *pData;
};

// Restart Manager support flags
#define AFX_RESTART_MANAGER_SUPPORT_RESTART				0x01  // restart support, means application is registered via RegisterApplicationRestart
#define AFX_RESTART_MANAGER_SUPPORT_RECOVERY			0x02  // recovery support, means application is registered via RegisterApplicationRecoveryCallback
#define AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART			0x04  // auto-save support is enabled, documents will be autosaved at restart by restart manager
#define AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL		0x08  // auto-save support is enabled, documents will be autosaved periodically for crash recovery
#define AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES		0x10  // reopen of previously opened documents is enabled, on restart all previous documents will be opened
#define AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES		0x20  // restoration of auto-saved documents is enabled, on restart user will be prompted to open auto-saved documents intead of last saved
#define AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE			AFX_RESTART_MANAGER_SUPPORT_RESTART | AFX_RESTART_MANAGER_SUPPORT_RECOVERY | AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES
#define AFX_RESTART_MANAGER_SUPPORT_ALL_ASPECTS			AFX_RESTART_MANAGER_SUPPORT_NO_AUTOSAVE | AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL | AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES
#define AFX_RESTART_MANAGER_SUPPORT_RESTART_ASPECTS		AFX_RESTART_MANAGER_SUPPORT_RESTART | AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART | AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES | AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES
#define AFX_RESTART_MANAGER_SUPPORT_RECOVERY_ASPECTS	AFX_RESTART_MANAGER_SUPPORT_RECOVERY | AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL | AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES | AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES

class CWinApp : public CWinThread
{
	DECLARE_DYNAMIC(CWinApp)
public:

// Constructor
	/* explicit */ CWinApp(LPCTSTR lpszAppName = NULL);     // app name defaults to EXE name

// Attributes
	// Startup args (do not change)

	// This module's hInstance.
	HINSTANCE m_hInstance;

	// Pointer to the command-line.
	LPTSTR m_lpCmdLine;

	// Initial state of the application's window; normally,
	// this is an argument to ShowWindow().
	int m_nCmdShow;

	// Running args (can be changed in InitInstance)

	// Human-redable name of the application. Normally set in
	// constructor or retreived from AFX_IDS_APP_TITLE.
	LPCTSTR m_pszAppName;

	/// <summary>
	/// Application User Model ID.</summary>
	LPCTSTR m_pszAppID;

	// Name of registry key for this application. See
	// SetRegistryKey() member function.
	LPCTSTR m_pszRegistryKey;

	// Pointer to CDocManager used to manage document templates
	// for this application instance.
	CDocManager* m_pDocManager;

	// Support for Shift+F1 help mode.

	// TRUE if we're in SHIFT+F1 mode.
	BOOL m_bHelpMode;

public:
	// set in constructor to override default

	// Executable name (no spaces).
	LPCTSTR m_pszExeName;

	// Default based on this module's path.
	LPCTSTR m_pszHelpFilePath;

	// Default based on this application's name.
	LPCTSTR m_pszProfileName;

	// Sets and initializes usage of HtmlHelp instead of WinHelp.
	void EnableHtmlHelp();

	// Sets and initializes usage of HtmlHelp instead of WinHelp.
	void SetHelpMode( AFX_HELP_TYPE eHelpType );
	AFX_HELP_TYPE GetHelpMode();

	// help mode used by the app
	AFX_HELP_TYPE m_eHelpType;

// Initialization Operations - should be done in InitInstance
protected:
	// Load MRU file list and last preview state.
	void LoadStdProfileSettings(UINT nMaxMRU = _AFX_MRU_COUNT);

	void EnableShellOpen();

	// SetDialogBkColor is no longer supported.
	// To change dialog background and text color, handle WM_CTLCOLORDLG instead.
	AFX_DEPRECATED("CWinApp::SetDialogBkColor is no longer supported. Instead, handle WM_CTLCOLORDLG in your dialog")
			void SetDialogBkColor(COLORREF clrCtlBk = RGB(192, 192, 192), COLORREF clrCtlText = RGB(0, 0, 0));

	// Set registry key name to be used by CWinApp's
	// profile member functions; prevents writing to an INI file.
	void SetRegistryKey(LPCTSTR lpszRegistryKey);
	void SetRegistryKey(UINT nIDRegistryKey);

	/// <summary>
	/// Explicitly sets Application User Model ID for the application. This method should be called before any user interface 
	/// is presented to user (the best place is the application constructor).</summary>
	/// <param name="lpcszAppID">Specifies the Application User Model ID.</param>
	void SetAppID(LPCTSTR lpcszAppID);

	// Enable3dControls and Enable3dControlsStatic are no longer necessary.
	AFX_DEPRECATED("CWinApp::Enable3dControls is no longer needed. You should remove this call.")
			BOOL Enable3dControls();
#ifndef _AFXDLL
	AFX_DEPRECATED("CWinApp::Enable3dControlsStatic is no longer needed. You should remove this call.")
			BOOL Enable3dControlsStatic();
#endif

	void RegisterShellFileTypes(BOOL bCompat = FALSE);

	// call after all doc templates are registered
	void UnregisterShellFileTypes();

public:
	// Loads a cursor resource.
	HCURSOR LoadCursor(LPCTSTR lpszResourceName) const;
	HCURSOR LoadCursor(UINT nIDResource) const;

	// Loads a stock cursor resource; for for IDC_* values.
	HCURSOR LoadStandardCursor(LPCTSTR lpszCursorName) const;

	// Loads an OEM cursor; for all OCR_* values.
	HCURSOR LoadOEMCursor(UINT nIDCursor) const;

	// Loads an icon resource.
	HICON LoadIcon(LPCTSTR lpszResourceName) const;
	HICON LoadIcon(UINT nIDResource) const;

	// Loads an icon resource; for stock IDI_ values.
	HICON LoadStandardIcon(LPCTSTR lpszIconName) const;

	// Loads an OEM icon resource; for all OIC_* values.
	HICON LoadOEMIcon(UINT nIDIcon) const;

	// Retrieve an integer value from INI file or registry.
	virtual UINT GetProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nDefault);

	// Sets an integer value to INI file or registry.
	virtual BOOL WriteProfileInt(LPCTSTR lpszSection, LPCTSTR lpszEntry, int nValue);

	// Retrieve a string value from INI file or registry.
	virtual CString GetProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPCTSTR lpszDefault = NULL);

	// Sets a string value to INI file or registry.
	virtual BOOL WriteProfileString(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPCTSTR lpszValue);

	// Retrieve an arbitrary binary value from INI file or registry.
	virtual BOOL GetProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPBYTE* ppData, UINT* pBytes);

	// Sets an arbitrary binary value to INI file or registry.
	virtual BOOL WriteProfileBinary(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPBYTE pData, UINT nBytes);

	// Override in derived class.
	virtual void InitLibId();

	// Register
	virtual BOOL Register();

	// Unregisters everything this app was known to register.
	virtual BOOL Unregister();

	/// <summary>
	/// Deletes the subkeys and values of the specified key recursively.</summary>
	/// <returns> 
	/// If the function succeeds, the return value is ERROR_SUCCESS. If the function fails, the return value is a nonzero error code defined in Winerror.h</returns>
	/// <param name="hParentKey">A handle to an open registry key.</param>
	/// <param name="strKeyName">The name of the key to be deleted.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	LONG DelRegTree(HKEY hParentKey, const CString& strKeyName, CAtlTransactionManager* pTM = NULL);

// Running Operations - to be done on a running application
	// Dealing with document templates
	void AddDocTemplate(CDocTemplate* pTemplate);
	POSITION GetFirstDocTemplatePosition() const;
	CDocTemplate* GetNextDocTemplate(POSITION& pos) const;

	// Open named file, trying to match a regsitered
	// document template to it.
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName);
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszFileName, BOOL bAddToMRU);

	// Add a string to the recent file list. Remove oldest string,
	// if no space left.
	virtual void AddToRecentFileList(LPCTSTR lpszPathName);

	// Printer DC Setup routine, 'struct tagPD' is a PRINTDLG structure.
	void SelectPrinter(HANDLE hDevNames, HANDLE hDevMode,
		BOOL bFreeOld = TRUE);

	// Create a DC for the system default printer.
	BOOL CreatePrinterDC(CDC& dc);


	BOOL GetPrinterDeviceDefaults(PRINTDLG* pPrintDlg);

	// Run this app as an embedded object.
	BOOL RunEmbedded();

	// Run this app as an OLE automation server.
	BOOL RunAutomated();

	// Parse the command line for stock options and commands.
	void ParseCommandLine(CCommandLineInfo& rCmdInfo);

	// React to a shell-issued command line directive.
	BOOL ProcessShellCommand(CCommandLineInfo& rCmdInfo);

// Overridables

	// Hooks for your initialization code
	virtual BOOL InitApplication();

	// exiting
	virtual BOOL SaveAllModified(); // save before exit
	void HideApplication();
	void CloseAllDocuments(BOOL bEndSession); // close documents before exiting

	// Advanced: to override message boxes and other hooks
	virtual int DoMessageBox(LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
	virtual void DoWaitCursor(int nCode); // 0 => restore, 1=> begin, -1=> end

	// Advanced: process async DDE request
	virtual BOOL OnDDECommand(_In_z_ LPTSTR lpszCommand);

	// Advanced: Help support
	virtual void WinHelp(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);
	virtual void HtmlHelp(DWORD_PTR dwData, UINT nCmd = 0x000F);
	virtual void WinHelpInternal(DWORD_PTR dwData, UINT nCmd = HELP_CONTEXT);

	// Restart Manager support
	virtual HRESULT RegisterWithRestartManager(BOOL bRegisterRecoveryCallback, const CString &strRestartIdentifier);
	virtual HRESULT RegisterWithRestartManager(LPCWSTR pwzCommandLineArgs, DWORD dwRestartFlags, APPLICATION_RECOVERY_CALLBACK pRecoveryCallback, LPVOID lpvParam, DWORD dwPingInterval, DWORD dwCallbackFlags);
	virtual DWORD ApplicationRecoveryCallback(LPVOID lpvParam);

	virtual BOOL SupportsRestartManager() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_SUPPORT_RESTART; }
	virtual BOOL SupportsApplicationRecovery() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_SUPPORT_RECOVERY; }
	virtual BOOL SupportsAutosaveAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_AUTOSAVE_AT_RESTART; }
	virtual BOOL SupportsAutosaveAtInterval() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_AUTOSAVE_AT_INTERVAL; }
	virtual BOOL ReopenPreviousFilesAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_REOPEN_PREVIOUS_FILES; }
	virtual BOOL RestoreAutosavedFilesAtRestart() const { return m_dwRestartManagerSupportFlags & AFX_RESTART_MANAGER_RESTORE_AUTOSAVED_FILES; }

	virtual DWORD GetApplicationRestartFlags() { return 0; }  // Flags for RegisterApplicationRestart: default is none of RESTART_NO_CRASH/RESTART_NO_HANG/RESTART_NO_PATCH/RESTART_NO_REBOOT
	virtual LPVOID GetApplicationRecoveryParameter() { return NULL; }  // Parameter to be passed along to RegisterApplicationRecoveryCallback
	virtual DWORD GetApplicationRecoveryPingInterval() { return RECOVERY_DEFAULT_PING_INTERVAL; }  // Ping interval for RegisterApplicationRecoveryCallback

// Command Handlers
protected:
	// map to the following for file new/open
	afx_msg void OnFileNew();
	afx_msg void OnFileOpen();

	// map to the following to enable print setup
	afx_msg void OnFilePrintSetup();

	// map to the following to enable help
	afx_msg void OnContextHelp();   // shift-F1
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX
	afx_msg void OnHelpFinder();    // ID_HELP_FINDER, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING

// Implementation
protected:
	HGLOBAL m_hDevMode;             // printer Dev Mode
	HGLOBAL m_hDevNames;            // printer Device Names
	DWORD m_dwPromptContext;        // help context override for message box

	HINSTANCE m_hLangResourceDLL;  // Satellite resource DLL

	int m_nWaitCursorCount;         // for wait cursor (>0 => waiting)
	HCURSOR m_hcurWaitCursorRestore; // old cursor to restore after wait cursor

	CRecentFileList* m_pRecentFileList;
	CDataRecoveryHandler* m_pDataRecoveryHandler;

	void UpdatePrinterSelection(BOOL bForceDefaults);
	void SaveStdProfileSettings();  // save options to .INI file

public: // public for implementation access
	CCommandLineInfo* m_pCmdInfo;

	ATOM m_atomApp, m_atomSystemTopic;   // for DDE open
	UINT m_nNumPreviewPages;        // number of default printed pages

	size_t  m_nSafetyPoolSize;      // ideal size

	void (AFXAPI* m_lpfnDaoTerm)();

	void DevModeChange(_In_z_ LPTSTR lpDeviceName);
	void SetCurrentHandles();

	// Finds number of opened CDocument items owned by templates
	// registered with the doc manager.
	int GetOpenDocumentCount();

	virtual CDataRecoveryHandler *GetDataRecoveryHandler();
	/// <summary> 
	/// Tells whether Windows 7 Taskbar interaction is enabled.</summary>
	/// <returns> 
	/// Returns TRUE if EnableTaskbarInteraction has been called and Operation System is 
	/// Windows 7 or higher.</returns>
	/// <remarks> Taskbar interaction means that MDI application displays the content of MDI children 
	/// in separate tabbed thumbnails that appear when mouse pointer is over application taskbar button.</remarks>
	virtual BOOL IsTaskbarInteractionEnabled();

	/// <summary>
	/// Enables Taskbar interaction</summary>
	/// <returns> 
	/// Returns TRUE if taskbar interaction can be enabled or disabled (e.g. this method was called before creation of main window).</returns>
	/// <remarks> 
	/// This method must be called before creation of main window, otherwise it asserts and returns FALSE.</remarks>
	/// <param name="bEnable"> Specifies whether interaction with Windows 7 taskbar should be enabled (TRUE), or disabled (FALSE).</param>
	BOOL EnableTaskbarInteraction(BOOL bEnable = TRUE);

	// helpers for standard commdlg dialogs
	BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
			DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
	INT_PTR DoPrintDialog(CPrintDialog* pPD);

	void EnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

	// overrides for implementation
	virtual BOOL InitInstance();
	virtual int ExitInstance(); // return app exit code
	virtual BOOL RestartInstance(); // handle restart by Restart Manager
	virtual int Run();
	virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing
	virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);
	virtual HINSTANCE LoadAppLangResourceDLL();

    // Helper for message boxes; can work when no CWinApp can be found
	static int ShowAppMessageBox(CWinApp *pApp, LPCTSTR lpszPrompt, UINT nType, UINT nIDPrompt);
	static void DoEnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

public:
	virtual ~CWinApp();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// helpers for registration

	/// <summary>
	/// returns key for HKEY_CURRENT_USER\"Software"\RegistryKey\AppName\lpszSection.</summary>
	/// <returns> 
	/// Section key if the function succeeds, NULL - otherwise</returns>
	/// <param name="lpszSection">The name of the key to be obtained.</param>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	HKEY GetSectionKey(LPCTSTR lpszSection, CAtlTransactionManager* pTM = NULL);

	/// <summary>
	/// returns key for HKEY_CURRENT_USER\"Software"\RegistryKey\ProfileName.</summary>
	/// <returns> 
	/// Applixation key if the function succeeds, NULL - otherwise</returns>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	HKEY GetAppRegistryKey(CAtlTransactionManager* pTM = NULL);

protected:
	//{{AFX_MSG(CWinApp)
	afx_msg void OnAppExit();
	afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnOpenRecentFile(UINT nID);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public :
	// System Policy Settings
	virtual BOOL LoadSysPolicies(); // Override to load policies other than the system policies that MFC loads.
	BOOL GetSysPolicyValue(DWORD dwPolicyID, BOOL *pbValue); // returns the policy's setting in the out parameter
protected :
	BOOL _LoadSysPolicies() throw(); // Implementation helper
	DWORD m_dwPolicies;				// block for storing boolean system policies

	// Restart Manager support
	DWORD m_dwRestartManagerSupportFlags; // What aspects of restart/recovery does the application support?
	int   m_nAutosaveInterval;            // How frequently are documents autosaved? (value in milliseconds)

	BOOL m_bTaskbarInteractionEnabled;
};

/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor();
	~CWaitCursor();

// Operations
public:
	void Restore();
};

/////////////////////////////////////////////////////////////////////////////
// class CDocTemplate creates documents

class AFX_NOVTABLE CDocTemplate : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocTemplate)

// Constructors
protected:
	CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

public:
	virtual void LoadTemplate();

// Attributes
public:
	// setup for OLE containers
	void SetContainerInfo(UINT nIDOleInPlaceContainer);

	// setup for OLE servers
	void SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer = 0,
		CRuntimeClass* pOleFrameClass = NULL, CRuntimeClass* pOleViewClass = NULL);

	/// <summary> 
	/// Setups out of process preview handler. </summary>
	/// <param name="nIDPreviewFrame">Specifies a resource ID of preview frame.</param>
	/// <param name="pPreviewFrameClass">Specifies a pointer to a runtime class information of preview frame.</param>
	/// <param name="pPreviewViewClass">Specifies a pointer to a runtime class information of preview view.</param>
	void SetPreviewInfo(UINT nIDPreviewFrame, CRuntimeClass* pPreviewFrameClass = NULL, CRuntimeClass* pPreviewViewClass = NULL);

	// iterating over open documents
	virtual POSITION GetFirstDocPosition() const = 0;
	virtual CDocument* GetNextDoc(POSITION& rPos) const = 0;

// Operations
public:
	virtual void AddDocument(CDocument* pDoc);      // must override
	virtual void RemoveDocument(CDocument* pDoc);   // must override

	enum DocStringIndex
	{
		windowTitle,        // default window title
		docName,            // user visible name for default document
		fileNewName,        // user visible name for FileNew
		// for file based documents:
		filterName,         // user visible name for FileOpen
		filterExt,          // user visible extension for FileOpen
		// for file based documents with Shell open support:
		regFileTypeId,      // REGEDIT visible registered file type identifier
		regFileTypeName,    // Shell visible registered file type name
	};
	virtual BOOL GetDocString(CString& rString,
		enum DocStringIndex index) const; // get one of the info strings
	CFrameWnd* CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
		BOOL bCreateView);
	/// <summary>
	/// Creates a child frame used for Rich Preview.</summary>
	/// <returns> A valid pointer to a CFrameWnd object, or NULL if creation fails. </returns>
	/// <param name="pParentWnd"> A pointer to a parent window (usually provided by the Shell).</param>
	/// <param name="pDoc"> A pointer to a document object, whose content will be previewed. </param>
	CFrameWnd* CreatePreviewFrame(CWnd* pParentWnd, CDocument* pDoc);

// Overridables
public:
	enum Confidence
	{
		noAttempt,
		maybeAttemptForeign,
		maybeAttemptNative,
		yesAttemptForeign,
		yesAttemptNative,
		yesAlreadyOpen
	};
	virtual Confidence MatchDocType(LPCTSTR lpszPathName,
					CDocument*& rpDocMatch);
	virtual CDocument* CreateNewDocument();
	virtual CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual BOOL SaveAllModified();     // for all documents
	virtual void CloseAllDocuments(BOOL bEndSession);
	// open named file; if lpszPathName == NULL => create new file with this type
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE) = 0;
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bAddToMRU, BOOL bMakeVisible) = 0;
	virtual void SetDefaultTitle(CDocument* pDocument) = 0;

// Implementation
public:
	BOOL m_bAutoDelete;
	virtual ~CDocTemplate() = 0;

	// back pointer to OLE or other server (NULL if none or disabled)
	CObject* m_pAttachedFactory;

	// Class ID for preview handler - used for registration
	CString m_strCLSID;
	CLSID   m_clsid;

	// menu & accelerator resources for in-place container
	HMENU m_hMenuInPlace;
	HACCEL m_hAccelInPlace;

	// menu & accelerator resource for server editing embedding
	HMENU m_hMenuEmbedding;
	HACCEL m_hAccelEmbedding;

	// menu & accelerator resource for server editing in-place
	HMENU m_hMenuInPlaceServer;
	HACCEL m_hAccelInPlaceServer;

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif
	virtual void OnIdle();             // for all documents
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	UINT m_nIDResource;						// IDR_ for frame/menu/accel as well
	UINT m_nIDServerResource;				// IDR_ for OLE inplace frame/menu/accel
	UINT m_nIDEmbeddingResource;			// IDR_ for OLE open frame/menu/accel
	UINT m_nIDContainerResource;			// IDR_ for container frame/menu/accel
	UINT m_nIDPreviewResource;				// IDR_ for preview frame. Do not load menu/accel

	CRuntimeClass* m_pDocClass;				// class for creating new documents
	CRuntimeClass* m_pFrameClass;			// class for creating new frames
	CRuntimeClass* m_pViewClass;			// class for creating new views
	CRuntimeClass* m_pOleFrameClass;		// class for creating in-place frame
	CRuntimeClass* m_pOleViewClass;			// class for creating in-place view
	CRuntimeClass* m_pPreviewFrameClass;	// class for creating in-place preview frame
	CRuntimeClass* m_pPreviewViewClass;		// class for creating in-place preview view

	CString m_strDocStrings;    // '\n' separated names
		// The document names sub-strings are represented as _one_ string:
		// windowTitle\ndocName\n ... (see DocStringIndex enum)

	// need for preview handler. CDocument finds template by m_pDocClass in order to instantiate related frame/view
	friend class CDocument; 
};

// SDI support (1 document only)
class CSingleDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CSingleDocTemplate)

// Constructors
public:
	CSingleDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	virtual ~CSingleDocTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bAddToMRU, BOOL bMakeVisible);
	virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CDocument* m_pOnlyDoc;
};

// MDI support (zero or more documents)
class CMultiDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CMultiDocTemplate)

// Constructors
public:
	CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	// Menu and accel table for MDI Child windows of this type
	HMENU m_hMenuShared;
	HACCEL m_hAccelTable;

	virtual ~CMultiDocTemplate();
	virtual void LoadTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bMakeVisible = TRUE);
	virtual CDocument* OpenDocumentFile(LPCTSTR lpszPathName, BOOL bAddToMRU, BOOL bMakeVisible);
	virtual void SetDefaultTitle(CDocument* pDocument);

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CPtrList m_docList;          // open documents of this type
	UINT m_nUntitledCount;   // start at 0, for "Document1" title
};

/////////////////////////////////////////////////////////////////////////////
// class CDocument is the main document data abstraction

class AFX_NOVTABLE CDocument : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocument)

public:
// Constructors
	CDocument();

	/// <summary>
	/// This class implements IDocument interface required for Search and Organize handlers.</summary>
	/// <remarks>
	/// Search and Organize handlers are implemented in ATL DLLs, which can be MFC or not-MFC based.
	/// Internally handlers refer to IDocument interface, whose implementation in the common case should be
	/// supplied by a developer. CDocumentAdapter provides this implementation for MFC and basically calls 
	///	the appropriate methods of the parent CDocument.</remarks>
	class CDocumentAdapter : public ATL::IDocument
	{
		friend class CDocument;
	public:
		/// <summary>
		/// Constructs a CDocumentAdapter object.</summary>
		/// <param name="pParentDoc"> A pointer to a related document.</param>
		CDocumentAdapter(CDocument* pParentDoc) : m_pParentDoc(pParentDoc)
		{

		}
		/// <summary>
		/// A destructor. Also deletes a related (parent) CDocument.</summary>
		virtual ~CDocumentAdapter()
		{
			if (m_pParentDoc != NULL)
			{
				delete m_pParentDoc;
				m_pParentDoc = NULL;
			}
		}

		/// <summary>
		/// Loads document data from a stream </summary>
		/// <returns> 
		/// S_OK if succeeds; otherwise failed HRESULT.</returns>
		/// <param name="pStream">A pointer to a stream. This stream is supplied by the Shell.</param>
		/// <param name="grfMode">Access mode to the stream.</param>
		virtual HRESULT LoadFromStream(IStream* pStream, DWORD grfMode)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::LoadFromStream is called, but its CDocument is NULL.");
				return E_POINTER;
			}
			m_pParentDoc->m_bPreviewHandlerMode = TRUE;
			m_pParentDoc->m_bEmbedded = TRUE;
			m_pParentDoc->OnNewDocument();
			return m_pParentDoc->LoadDocumentFromStream(pStream, grfMode);
		}

		/// <summary>
		/// Initializes search content. </summary>
		virtual void InitializeSearchContent()
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::InitializeSearchContent is called, but its CDocument is NULL.");
				return;
			}

			m_pParentDoc->InitializeSearchContent();
		}
		/// <summary>
		/// Clears the chunk list. </summary>
		virtual void ClearChunkList()
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::ClearChunkList is called, but its CDocument is NULL.");
				return;
			}
			m_pParentDoc->ClearChunkList ();
		}
		/// <summary>
		/// Sets a chunk value. </summary>
		/// <returns> 
		/// Nonzero if succeeds. Otherwise 0.</returns>
		/// <param name="pValue"> Specifies a chunk value to set.</param>
		virtual BOOL SetChunkValue(ATL::IFilterChunkValue* pValue)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::SetChunkValue is called, but its CDocument is NULL.");
				return FALSE;
			}
			return m_pParentDoc->SetChunkValue(pValue);
		}

		/// <summary>
		/// Initializes chunk reading. </summary>
		virtual void BeginReadChunks()
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::BeginReadChunks is called, but its CDocument is NULL.");
				return;
			}
			m_pParentDoc->BeginReadChunks();
		}

		/// <summary> 
		/// Reads next chunk value. </summary>
		/// <returns> 
		/// Nonzero if succeeds. Otherwise 0.</returns>
		/// <param name="ppValue"> Output parameter. When the function returns ppValue contains the value.</param>
		virtual BOOL ReadNextChunkValue(ATL::IFilterChunkValue** ppValue)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::ReadNextChunkValue is called, but its CDocument is NULL.");
				return FALSE;
			}
			return m_pParentDoc->ReadNextChunkValue(ppValue);
		}

		/// <summary>
		/// Removes a chunk with specified GUID </summary>
		/// <param name="guid> Specifies GUID of a chunk to be removed.</param>
		/// <param name="pid> Specifies PID of a chunk to be removed.</param>
		virtual void RemoveChunk(REFCLSID guid, DWORD pid)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::RemoveChunk is called, but its CDocument is NULL.");
				return;
			}
			m_pParentDoc->RemoveChunk(guid, pid);
		}

		/// <summary>
		/// Looks for a chunk with specified GUID </summary>
		/// <returns> 
		/// Position in the internal chunk list if succeeds. Otherwise NULL.</returns>
		/// <param name="guid> Specifies GUID of a chunk to find.</param>
		/// <param name="pid> Specifies PID of a chunk to find.</param>
		virtual POSITION FindChunk(REFCLSID guid, DWORD pid)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::FindChunk is called, but its CDocument is NULL.");
				return NULL;
			}
			return m_pParentDoc->FindChunk(guid, pid);
		}

		/// <summary>
		/// Returns a pointer to a parent CDocument.</summary>
		/// <returns> Returns a pointer to a parent (container) CDocument.</returns>
		virtual LPVOID GetContainer() const
		{
			return m_pParentDoc;
		}

		/// <summary>
		/// Creates a bitmap for Thumbnail provider.</summary>
		/// <returns>Returns TRUE if a bitmap for thumbnail was created successfully; otherwise FALSE.</returns>
		/// <param name="cx">Specifies width and height of the bitmap.</param>
		/// <param name="phbmp">Should contain a handle to a bitmap, when the function returns. </param>
		/// <param name="pdwAlpha">Should contain a DWORD specifying alpha channel value, when the function returns.</param>
		virtual BOOL GetThumbnail(UINT cx, HBITMAP* phbmp, WTS_ALPHATYPE* pdwAlpha)
		{
			ASSERT_VALID(m_pParentDoc);
			if (m_pParentDoc == NULL)
			{
				TRACE0("CDocumentAdapter::GetThumbnail is called, but its CDocument is NULL.");
				return FALSE;
			}
			return m_pParentDoc->GetThumbnail(cx, phbmp, pdwAlpha); 
		}

	protected:
		/// <summary>
		/// A pointer to a parent document (container).</summary>
		CDocument* m_pParentDoc;
	};

	friend class CDocumentAdapter;
public:
	/// <summary>
	/// Returns a pointer to object implementing IDocument interface. </summary>
	/// <returns>
	/// A pointer to object implementing IDocument interface. </returns>
	virtual ATL::IDocument* GetAdapter()
	{
		if (m_pDocumentAdapter == NULL)
		{
			ATLTRY(m_pDocumentAdapter = new CDocumentAdapter(this));
		}

		if (m_pDocumentAdapter != NULL)
		{
			m_pDocumentAdapter->AddRef();
		}

		return m_pDocumentAdapter;
	}

// Attributes
public:
	const CString& GetTitle() const;
	virtual void SetTitle(LPCTSTR lpszTitle);
	const CString& GetPathName() const;
	virtual void SetPathName(LPCTSTR lpszPathName, BOOL bAddToMRU = TRUE);
	virtual void ClearPathName();

	CDocTemplate* GetDocTemplate() const;
	virtual BOOL IsModified();
	virtual void SetModifiedFlag(BOOL bModified = TRUE);

	/// <summary>
	/// Tells whether this instance of CDocument object was created for Search & Organize handler.</summary>
	/// <returns>
	/// Returns TRUE if this instance of CDocument was created for Search & Organize handler.</returns>
	/// <remarks>
	/// Currently this function returns TRUE only for Rich Preview handler implemented in out of process server.
	/// You can set the appropriate flags (m_bPreviewHandlerMode, m_bSearchMode, m_bGetThumbnailMode) at your application level
	/// to make this function returning TRUE.</remarks>
	BOOL IsSearchAndOrganizeHandler() const;

// Operations
	void AddView(CView* pView);
	void RemoveView(CView* pView);
	virtual POSITION GetFirstViewPosition() const;
	virtual CView* GetNextView(POSITION& rPosition) const;

	// Update Views (simple update - DAG only)
	void UpdateAllViews(CView* pSender, LPARAM lHint = 0L,
		CObject* pHint = NULL);

// Overridables
	// Special notifications
	virtual void OnChangedViewList(); // after Add or Remove view
	virtual void DeleteContents(); // delete doc items etc

	// File helpers
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
	virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(LPCTSTR lpszPathName,
				CException* e, BOOL bSaving, UINT nIDPDefault);
	virtual CFile* GetFile(LPCTSTR lpszFileName, UINT nOpenFlags,
		CFileException* pError);
	virtual void ReleaseFile(CFile* pFile, BOOL bAbort);

	// search/organize/preview/thumbnail notifications
	/// <summary> 
	/// Called before Rich Preview font is changed. </summary>
	virtual void OnBeforeRichPreviewFontChanged(){}
	/// <summary> 
	/// Called when Rich Preview font has changed. </summary>
	virtual void OnRichPreviewFontChanged(){}
	/// <summary> 
	/// Called when Rich Preview text color has changed. </summary>
	virtual void OnRichPreviewTextColorChanged(){}
	/// <summary> 
	/// Called when Rich Preview background color has changed. </summary>
	virtual void OnRichPreviewBackColorChanged(){}
	/// <summary> 
	/// Called when Rich Preview site has changed. </summary>
	virtual void OnRichPreviewSiteChanged(){}
	/// <summary> 
	/// Called when Rich Preview is unloaded.</summary>
	/// <remarks>
	/// OnUnloadHandler allows to take some additional on handler unload. 
	/// Overriding this method allows complete control on clean up process if you don't call the 
	/// base implementation, which releases preview handler site, destroys preview frame and 
	/// releases the stream.</remarks>
	virtual void OnRichPreviewUnload();
	
	// search/organize/preview/thumbnail helpers

	/// <summary> 
	/// Called to load document data from stream. </summary>
	/// <returns>S_OK if the load operation succeeds, otherwise HRESULT with error code.</returns>
	/// <remarks>
	/// You can override this method in a derived class to customize loading data from the stream. </remarks>
	/// <param name="pStream">A pointer to a stream. This stream is supplied by the Shell.</param>
	/// <param name="grfMode">Access mode to the stream.</param>
	virtual HRESULT LoadDocumentFromStream(IStream* pStream, DWORD dwGrfMode);

	/// <summary> 
	/// Called to create a bitmap to be used by thumbnail provider to display thumbnail. </summary>
	/// <returns>Returns TRUE if a bitmap for thumbnail was created successfully; otherwise FALSE.</returns>
	/// <param name="cx">Specifies width and height of the bitmap.</param>
	/// <param name="phbmp">Should contain a handle to a bitmap, when the function returns. </param>
	/// <param name="pdwAlpha">Should contain a DWORD specifying alpha channel value, when the function returns.</param>
	virtual BOOL GetThumbnail(UINT cx, HBITMAP* phbmp, WTS_ALPHATYPE* pdwAlpha);

	// search/organize/preview/thumbnail support - search and chunk management
	/// <summary> 
	/// Called to initialize search content for Search Handler. </summary>
	/// <remarks>
	/// You should override this method in a derived class to initialize search content. 
	/// The content should be a string with parts delimited by ';'. For example, "point; rectangle; ole item". </remarks>
	virtual void InitializeSearchContent ()
	{
		TRACE0("Override this method in a derived class to initialize chunk list for search filter.");
	}

	/// <summary> 
	/// Clears the chunk list. </summary>
	virtual void ClearChunkList ();

	/// <summary>
	/// Sets a chunk value. </summary>
	/// <returns> 
	/// Nonzero if succeeds. Otherwise 0.</returns>
	/// <param name="pValue"> Specifies a chunk value to set.</param>
	virtual BOOL SetChunkValue (ATL::IFilterChunkValue* pValue);

	/// <summary>
	/// Initializes chunk reading. </summary>
	virtual void BeginReadChunks ();

	/// <summary> 
	/// Reads next chunk value. </summary>
	/// <returns> 
	/// Nonzero if succeeds. Otherwise 0.</returns>
	/// <param name="ppValue"> Output parameter. When the function returns ppValue contains the value.</param>
	virtual BOOL ReadNextChunkValue(ATL::IFilterChunkValue** ppValue);

	/// <summary>
	/// Removes a chunk with specified GUID </summary>
	/// <param name="guid"> Specifies GUID of a chunk to be removed.</param>
	/// <param name="pid"> Specifies PID of a chunk to be removed.</param>
	virtual void RemoveChunk(REFCLSID guid, DWORD pid);

	/// <summary>
	/// Looks for a chunk with specified GUID </summary>
	/// <returns> 
	/// Position in the internal chunk list if succeeds. Otherwise NULL.</returns>
	/// <param name="guid"> Specifies GUID of a chunk to find.</param>
	/// <param name="pid"> Specifies PID of a chunk to find.</param>
	virtual POSITION FindChunk(REFCLSID guid, DWORD pid);

	// Document event notifications
	enum DocumentEvent
	{
		onAfterNewDocument = 0,
		onAfterOpenDocument = 1,
		onAfterSaveDocument = 2,
		onAfterCloseDocument = 3
	};

	virtual void OnDocumentEvent(DocumentEvent deEvent);

	// advanced overridables, closing down frame/doc, etc.
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL SaveModified(); // return TRUE if ok to continue
	virtual void PreCloseFrame(CFrameWnd* pFrame);

// Implementation
protected:
	// default implementation
	CString m_strTitle;
	CString m_strPathName;
	CDocTemplate* m_pDocTemplate;
	CPtrList m_viewList;                // list of views
	BOOL m_bModified;                   // changed since last saved
	BOOL m_bFinalRelease;               // we're in CDocument's FinalRelease
	BOOL m_bOLELocked;                  // AfxOleLockApp has been called

	// search/organize/preview/thumbnail data
	HWND m_hWndHost; // a handle to window (host) supplied by prevhost.exe
	CRect m_rectHost; // window rectangle of host. Our preview frame should fit this rectangle
	IStream* m_pStream; // stream to load the document data from
	DWORD m_grfMode; // stream opening mode
	CFrameWnd* m_pPreviewFrame; // frame to display the rich preview
	
	ATL::CComPtr<IUnknown> m_spUnkSite; // SetSite called through IObjectWithSite

	// search support
	CPtrList m_lstChunks;
	POSITION m_posReadChunk;

	/// <summary>
	/// A pointer to embedded document adapter - an object implementing IDocument interface.</summary>
	CDocumentAdapter* m_pDocumentAdapter;

public:
	BOOL m_bAutoDelete;         // TRUE => delete document when no more views
	BOOL m_bEmbedded;           // TRUE => document is being created by OLE
	/// <summary>
	/// Specifies that CDocument object was created by dllhost for thumbnails. Should be checked in CView::OnDraw.</summary>
	BOOL m_bGetThumbnailMode;   // TRUE => document was created by dllhost for thumbnails. Should be checked in CView::OnDraw
	/// <summary>
	/// Specifies that CDocument object was created by prevhost for Rich Preview. Should be checked in CView::OnDraw.</summary>
	BOOL m_bPreviewHandlerMode; // TRUE => document was created by prevhost for rich preview
	/// <summary>
	/// Specifies that CDocument object was created by indexer or other search application.</summary>
	BOOL m_bSearchMode;         // TRUE => document was created by indexer or other search application

	// rich preview visuals
	/// <summary>
	/// Specifies background color of Rich Preview window. This color is set by host.</summary>
	COLORREF m_clrRichPreviewBackColor;
	/// <summary>
	/// Specifies foreground color of Rich Preview window. This color is set by host.</summary>
	COLORREF m_clrRichPreviewTextColor;
	/// <summary>
	/// Specifies text font for Rich Preview window. This font information is set by host.</summary>
	CFont    m_lfRichPreviewFont;

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual ~CDocument() = 0;

	// implementation helpers
	virtual BOOL DoSave(LPCTSTR lpszPathName, BOOL bReplace = TRUE);
	virtual BOOL DoFileSave();
	virtual void UpdateFrameCounts();
	void DisconnectViews();
	void SendInitialUpdate();

	// overridables for implementation
	virtual HMENU GetDefaultMenu(); // get menu depending on state
	virtual HACCEL GetDefaultAccelerator();
	virtual void OnIdle();
	virtual void OnFinalRelease();

	// search/organize/preview/thumbnail overridables
	// Load document from IStream
	/// <summary>
	/// Called by the framework when it needs to load the document data from stream.</summary>
	/// <returns> S_OK if load succeeds, otherwise error code.</returns>
	/// <param name="pStream">A pointer to incoming stream.</param>
	/// <param name="grfMode">Access mode to the stream.</param>
	virtual HRESULT OnLoadDocumentFromStream(IStream* pStream, DWORD grfMode);
	/// <summary>
	/// Directs the preview handler to return the HWND from calling the GetFocus Function. </summary>
	/// <returns> Returns S_OK if successful, or an error value otherwise. </returns>
	/// <param name="phwnd"> [out] When this method returns, contains a pointer to the HWND returned from calling the GetFocus Function from the preview handler's foreground thread.</param>
	virtual HRESULT OnPreviewHandlerQueryFocus(HWND* phwnd);
	/// <summary>
	/// Directs the preview handler to handle a keystroke passed up from the message pump of the process in which the preview handler is running.</summary>
	/// <returns>If the keystroke message can be processed by the preview handler, the handler will 
	/// process it and return S_OK. If the preview handler cannot process the keystroke message, 
	/// it will offer it to the host via IPreviewHandlerFrame::TranslateAccelerator. If the host processes the message, this method will return S_OK. If the host does not process the message, 
	/// this method will return S_FALSE.</returns>
	/// <param name="pmsg">[in] A pointer to a window message.</param>
	virtual HRESULT OnPreviewHandlerTranslateAccelerator(MSG* pmsg);
	/// <summary>
	/// Called by the framework when it needs to create a preview frame for Rich Preview.</summary>
	/// <returns> Returns TRUE if the frame is created successfully; otherwise FALSE.</returns>
	virtual BOOL OnCreatePreviewFrame();
	/// <summary>
	/// Called by the framework when the preview handler is beign unloaded.</summary>
	virtual void OnUnloadHandler();

	/// <summary>
	/// Override this method in a derived class to draw content of thumbnail </summary>
	/// <param name="dc"> A reference to a device context.</param>
	/// <param name="lprcBounds"> Specifies a bounding rectangle of area where the thumbnail should be drawn.</param>
	virtual void OnDrawThumbnail(CDC& dc, LPRECT lprcBounds);

	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	friend class CDocTemplate;

protected:
	// file menu commands
	//{{AFX_MSG(CDocument)
	afx_msg void OnFileClose();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	//}}AFX_MSG
	// mail enabling
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateFileSendMail(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()

#if WINVER >= 0x0600
public:
	BEGIN_INTERFACE_PART(InitializeWithStream, IInitializeWithStream)
		INIT_INTERFACE_PART(CDocument, InitWithStream)
		STDMETHOD(Initialize)(IStream* pStream, DWORD grfMode);
	END_INTERFACE_PART(InitializeWithStream)

	BEGIN_INTERFACE_PART(PreviewHandler, IPreviewHandler)
		INIT_INTERFACE_PART(CDocument, PreviewHandler)
		STDMETHOD(SetWindow)(HWND hwnd, const RECT *prc);
		STDMETHOD(SetRect)(const RECT *prc);
		STDMETHOD(DoPreview)();
		STDMETHOD(Unload)();
		STDMETHOD(SetFocus)();
		STDMETHOD(QueryFocus)(HWND *phwnd);
		STDMETHOD(TranslateAccelerator)(MSG *pmsg);
	END_INTERFACE_PART(PreviewHandler)

	BEGIN_INTERFACE_PART(PreviewHandlerVisuals, IPreviewHandlerVisuals)
		INIT_INTERFACE_PART(CDocument, PreviewHandlerVisuals)
		STDMETHOD(SetBackgroundColor)(COLORREF color);
		STDMETHOD(SetFont)(const LOGFONTW *plf);
		STDMETHOD(SetTextColor)(COLORREF color);
	END_INTERFACE_PART(PreviewHandlerVisuals)

	BEGIN_INTERFACE_PART(ObjectWithSite, IObjectWithSite)
		INIT_INTERFACE_PART(CDocument, ObjectWithSite)
		STDMETHOD(SetSite)(IUnknown *punkSite);
		STDMETHOD(GetSite)(REFIID riid, void **ppvSite);
	END_INTERFACE_PART(ObjectWithSite)

	BEGIN_INTERFACE_PART(OleWindow, IOleWindow)
		INIT_INTERFACE_PART(CDocument, ObjectWithSite)
		STDMETHOD(GetWindow)(HWND *phwnd);
		STDMETHOD(ContextSensitiveHelp)(BOOL);
	END_INTERFACE_PART(OleWindow)

	DECLARE_INTERFACE_MAP()

protected:
	IPreviewHandlerFrame* m_pPreviewHandlerSite; // Ole frame for rich preview
#else
	BEGIN_INTERFACE_PART(InitializeWithStream, IUnknown)
	END_INTERFACE_PART_OPTIONAL(InitializeWithStream)

	BEGIN_INTERFACE_PART(PreviewHandler, IUnknown)
	END_INTERFACE_PART_OPTIONAL(PreviewHandler)

	BEGIN_INTERFACE_PART(PreviewHandlerVisuals, IUnknown)
	END_INTERFACE_PART_OPTIONAL(PreviewHandlerVisuals)

	BEGIN_INTERFACE_PART(ObjectWithSite, IUnknown)
	END_INTERFACE_PART_OPTIONAL(ObjectWithSite)

	BEGIN_INTERFACE_PART(OleWindow, IUnknown)
	END_INTERFACE_PART_OPTIONAL(OleWindow)
protected:
	IUnknown* m_pPreviewHandlerSite; // Ole frame for rich preview
#endif
};

/// <summary>
/// This is a class which simplifies both chunk and property value pair logic. </summary>
/// <remarks>
/// To use, you simply create a CMFCFilterChunkValueImpl class of the right kind
/// Example:
///      CMFCFilterChunkValueImpl chunk;
///      hr = chunk.SetBoolValue(PKEY_IsAttachment, true);
///      or
///      hr = chunk.SetFileTimeValue(PKEY_ItemDate, ftLastModified);</remarks>
class CMFCFilterChunkValueImpl : public ATL::IFilterChunkValue
{
public:
	/// <summary>
	/// Constructs the object</summary>
	CMFCFilterChunkValueImpl();
	/// <summary>
	/// Destructs the object</summary>
	virtual ~CMFCFilterChunkValueImpl();

	///<summary> 
	/// Clear the ChunkValue. </summary>
	void Clear();

	/// <summary> 
	/// Checks whether this property value valid, or not. </summary> 
	/// <returns>TRUE if the current chunk value is valid; otherwise FALSE.</returns>
	BOOL IsValid() const
	{ 
		return m_fIsValid;
	}

	/// <summary>
	/// Gets the value as an allocated propvariant. </summary>
	/// <returns>S_OK if PROPVARIANT was allocated successfully and the chunk value was successfully copied to ppPropVariant; otherwise error code.</returns>
	/// <param name="ppPropVariant">When the function returns it contains chunk value.</param>
	HRESULT GetValue(PROPVARIANT **ppPropVariant);

	/// <summary>
	/// Returns non-allocated (internal value) value. </summary>
	/// <returns>Returns the current chunk value.</returns>
	PROPVARIANT GetValueNoAlloc ()
	{
		return m_propVariant;
	}

	/// <summary> 
	/// Gets the string value. </summary>
	/// <returns> A string containing the chunk value. </returns>
	CString &GetString()
	{ 
		return m_strValue; 
	};

	/// <summary> 
	/// Initializes this chunk value from the other value. </summary>
	/// <param name="pValue"> Specifies the source value to copy from. </param>
	void CopyFrom (ATL::IFilterChunkValue* pValue);

	/// <summary> 
	/// Copies this chunk to a structure describing the characteristics of a chunk. </summary> 
	/// <param name="pStatChunk"> A pointer to destination value describing the characteristics of chunk. </param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT CopyChunk(STAT_CHUNK *pStatChunk);

	/// <summary> 
	/// Gets chunk type. </summary> 
	/// <returns> A CHUNKSTATE enumerated value, which specifies whether the current chunk is a text-type property or a value-type property</returns>
	CHUNKSTATE GetChunkType() const
	{
		return m_chunk.flags;
	}

	/// <summary> 
	/// Gets chunk GUID. </summary> 
	/// <returns> A reference to GUID identifying the chunk.</returns>
	REFGUID GetChunkGUID() const
	{
		return m_chunk.attribute.guidPropSet;
	}

	/// <summary> 
	/// Gets chunk PID (property ID). </summary> 
	/// <returns> A DWORD value containing property ID.</returns>
	DWORD GetChunkPID() const
	{
		return m_chunk.attribute.psProperty.propid;
	}

	/// <summary> 
	/// Set the property by key to a Unicode string. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="pszValue">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetTextValue(REFPROPERTYKEY pkey, LPCTSTR pszValue, CHUNKSTATE chunkType = CHUNK_VALUE, 
		LCID locale = 0, DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, 
		CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a bool. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="bVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetBoolValue(REFPROPERTYKEY pkey, BOOL bVal, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale = 0, 
		DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a variant bool. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="bVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetBoolValue(REFPROPERTYKEY pkey, VARIANT_BOOL bVal, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale = 0, 
		DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to an int. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="nVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetIntValue(REFPROPERTYKEY pkey, int nVal, CHUNKSTATE chunkType = CHUNK_VALUE, 
		LCID locale = 0, DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, 
		CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a LONG. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="lVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetLongValue(REFPROPERTYKEY pkey, long lVal, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale = 0, 
		DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a DWORD. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="dwVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetDwordValue(REFPROPERTYKEY pkey, DWORD dwVal, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale = 0, 
		DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to an int64. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="nVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetInt64Value(REFPROPERTYKEY pkey, __int64 nVal, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale = 0, 
		DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a SystemTime. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="systemTime">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetSystemTimeValue(REFPROPERTYKEY pkey, const SYSTEMTIME &systemTime, CHUNKSTATE chunkType = CHUNK_VALUE, LCID locale=0, DWORD cwcLenSource=0, DWORD cwcStartSource=0, CHUNK_BREAKTYPE chunkBreakType=CHUNK_NO_BREAK);

	/// <summary> 
	/// Set the property by key to a filetime. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="dtVal">Specifies the chunk value to set</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetFileTimeValue(REFPROPERTYKEY pkey, FILETIME dtVal, CHUNKSTATE chunkType = CHUNK_VALUE, 
		LCID locale = 0, DWORD cwcLenSource = 0, DWORD cwcStartSource = 0, 
		CHUNK_BREAKTYPE chunkBreakType = CHUNK_NO_BREAK);

protected:
	/// <summary> 
	/// A helper function that sets chunk's common properties. </summary>
	/// <param name="pkey">Specifies a property key.</param>
	/// <param name="chunkType">Flags indicate whether this chunk contains a text-type or a value-type property. Flag values are taken from the CHUNKSTATE enumeration.</param>
	/// <param name="locale">The language and sublanguage associated with a chunk of text. Chunk locale is used by document indexers to perform proper word breaking of text. If the chunk is neither text-type nor a value-type with data type VT_LPWSTR, VT_LPSTR or VT_BSTR, this field is ignored.</param>
	/// <param name="cwcLenSource">The length in characters of the source text from which the current chunk was derived. A zero value signifies character-by-character correspondence between the source text and the derived text. A nonzero value means that no such direct correspondence exists.</param>
	/// <param name="cwcStartSource">The offset from which the source text for a derived chunk starts in the source chunk. </param>
	/// <param name="chunkBreakType">The type of break that separates the previous chunk from the current chunk. Values are from the CHUNK_BREAKTYPE enumeration.</param>
	/// <returns> S_OK if success; otherwise error code.</returns>
	HRESULT SetChunk(REFPROPERTYKEY pkey, CHUNKSTATE chunkType=CHUNK_VALUE, LCID locale=0, DWORD cwcLenSource=0, DWORD cwcStartSource=0, CHUNK_BREAKTYPE chunkBreakType=CHUNK_NO_BREAK);

	// member variables
private:
	BOOL m_fIsValid;
	STAT_CHUNK  m_chunk;
	PROPVARIANT m_propVariant;
	CString m_strValue;
};


/////////////////////////////////////////////////////////////////////////////
// Extra diagnostic tracing options

#ifdef _DEBUG
extern AFX_DATA UINT afxTraceFlags;
#endif // _DEBUG

#ifdef _DEBUG
#define DECLARE_AFX_TRACE_CATEGORY( name ) extern AFX_DATA ATL::CTraceCategory name;
#else
#define DECLARE_AFX_TRACE_CATEGORY( name ) const DWORD_PTR name = 0;
#endif

DECLARE_AFX_TRACE_CATEGORY( traceAppMsg )        // main message pump trace (includes DDE)
DECLARE_AFX_TRACE_CATEGORY( traceWinMsg )        // Windows message tracing
DECLARE_AFX_TRACE_CATEGORY( traceCmdRouting )    // Windows command routing trace
DECLARE_AFX_TRACE_CATEGORY( traceOle )          // special OLE callback trace
DECLARE_AFX_TRACE_CATEGORY( traceDatabase )     // special database trace
DECLARE_AFX_TRACE_CATEGORY( traceInternet )     // special Internet client trace
DECLARE_AFX_TRACE_CATEGORY( traceDumpContext )	// traces from CDumpContext
DECLARE_AFX_TRACE_CATEGORY( traceMemory )		// generic non-kernel memory traces
DECLARE_AFX_TRACE_CATEGORY( traceHtml )			// Html traces
DECLARE_AFX_TRACE_CATEGORY( traceSocket )		// Socket traces

//////////////////////////////////////////////////////////////////////////////
// MessageBox helpers

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCTSTR lpsz1);
void AFXAPI AfxFormatString2(CString& rString, UINT nIDS,
				LPCTSTR lpsz1, LPCTSTR lpsz2);
int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
				UINT nIDHelp = 0);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType = MB_OK,
				UINT nIDHelp = (UINT)-1);

// Implementation string helpers
void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
				LPCTSTR const* rglpsz, int nString);
void AFXAPI AfxFormatStrings(CString& rString, LPCTSTR lpszFormat,
				LPCTSTR const* rglpsz, int nString);
BOOL AFXAPI AfxExtractSubString(CString& rString, LPCTSTR lpszFullString,
				int iSubString, TCHAR chSep = '\n');

/////////////////////////////////////////////////////////////////////////////
// Special target variant APIs

#ifdef _AFXDLL
	#include <afxdll_.h>
#endif

// Windows Version compatibility (obsolete)
#define AfxEnableWin30Compatibility()
#define AfxEnableWin31Compatibility()
#define AfxEnableWin40Compatibility()

// Temporary map management (locks temp map on current thread)
void AFXAPI AfxLockTempMaps();
BOOL AFXAPI AfxUnlockTempMaps(BOOL bDeleteTemps = TRUE);

/////////////////////////////////////////////////////////////////////////////
// Special OLE related functions (see OLELOCK.CPP)

void AFXAPI AfxOleOnReleaseAllObjects();
BOOL AFXAPI AfxOleCanExitApp();
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();

void AFXAPI AfxOleSetUserCtrl(BOOL bUserCtrl);
BOOL AFXAPI AfxOleGetUserCtrl();

#ifndef _AFX_NO_OCC_SUPPORT
BOOL AFXAPI AfxOleLockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleUnlockControl(REFCLSID clsid);
BOOL AFXAPI AfxOleLockControl(LPCTSTR lpszProgID);
BOOL AFXAPI AfxOleUnlockControl(LPCTSTR lpszProgID);
void AFXAPI AfxOleUnlockAllControls();
#endif

/////////////////////////////////////////////////////////////////////////////
// Use version 1.0 of the RichEdit control

#define _RICHEDIT_VER 0x0210

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifndef GET_X_LPARAM
#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#endif
#ifndef GET_Y_LPARAM
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif

#include <afxcomctl32.inl>

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#include <afxwin1.inl>
#include <afxwin2.inl>
#include <afxwin3.inl>
#endif

#include <afxwin4.inl>

#undef AFX_DATA
#define AFX_DATA

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

/////////////////////////////////////////////////////////////////////////////

#else //RC_INVOKED
#include <afxres.h>     // standard resource IDs
#endif //RC_INVOKED


#ifdef _M_CEE
    #include <atliface.h>
    #include <afxole.h>
#endif

#pragma warning( pop )

#endif //__AFXWIN_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwin3.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines that reference NT5-only DLLs 

#pragma once

#ifdef _AFXWIN_INLINE

_AFXWIN_INLINE BOOL CDC::AlphaBlend(int xDest, int yDest, int nDestWidth, int nDestHeight,
   CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, BLENDFUNCTION blend)
   { ASSERT(m_hDC != NULL); return ::AlphaBlend(m_hDC, xDest, yDest, 
	  nDestWidth, nDestHeight, pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, 
	  nSrcHeight, blend); }
_AFXWIN_INLINE BOOL CDC::TransparentBlt(int xDest, int yDest, int nDestWidth, 
   int nDestHeight, CDC* pSrcDC, int xSrc, int ySrc, int nSrcWidth, 
   int nSrcHeight, UINT crTransparent)
   { ASSERT(m_hDC != NULL); return ::TransparentBlt(m_hDC, xDest, yDest, 
	  nDestWidth, nDestHeight, pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, 
	  nSrcHeight, crTransparent); }
_AFXWIN_INLINE BOOL CDC::GradientFill(TRIVERTEX* pVertices, ULONG nVertices,
   void* pMesh, ULONG nMeshElements, DWORD dwMode)
   { ASSERT(m_hDC != NULL); return ::GradientFill(m_hDC, pVertices, nVertices,
	  pMesh, nMeshElements, dwMode); }

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwin2.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 2)

#pragma once

#ifdef _AFXWIN_INLINE

// CWnd
_AFXWIN_INLINE CWnd::operator HWND() const
	{ return this == NULL ? NULL : m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator==(const CWnd& wnd) const
	{ return ((HWND) wnd) == m_hWnd; }
_AFXWIN_INLINE BOOL CWnd::operator!=(const CWnd& wnd) const
	{ return ((HWND) wnd) != m_hWnd; }
_AFXWIN_INLINE HWND CWnd::GetSafeHwnd() const
	{ return this == NULL ? NULL : m_hWnd; }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE DWORD CWnd::GetStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_STYLE); }
_AFXWIN_INLINE DWORD CWnd::GetExStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyle(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ModifyStyle(m_hWnd, dwRemove, dwAdd, nFlags); }
_AFXWIN_INLINE BOOL CWnd::ModifyStyleEx(DWORD dwRemove, DWORD dwAdd, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ModifyStyleEx(m_hWnd, dwRemove, dwAdd, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetOwner() const
	{ return m_hWndOwner != NULL ? CWnd::FromHandle(m_hWndOwner) : GetParent(); }
_AFXWIN_INLINE void CWnd::SetOwner(CWnd* pOwnerWnd)
	{ m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }

_AFXWIN_INLINE LRESULT CWnd::_AFX_FUNCNAME(SendMessage)(UINT message, WPARAM wParam, LPARAM lParam) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, message, wParam, lParam); }
#pragma push_macro("SendMessage")
#undef SendMessage
_AFXWIN_INLINE LRESULT CWnd::SendMessage(UINT message, WPARAM wParam, LPARAM lParam) const
	{ return _AFX_FUNCNAME(SendMessage)(message, wParam, lParam); }
#pragma pop_macro("SendMessage")
_AFXWIN_INLINE BOOL CWnd::PostMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::PostMessage(m_hWnd, message, wParam, lParam); }
_AFXWIN_INLINE BOOL CWnd::DragDetect(POINT pt) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::DragDetect(m_hWnd, pt); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetWindowText(LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetWindowText(m_hWnd, lpszString); }
_AFXWIN_INLINE int CWnd::GetWindowText(_Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpszString, _In_ int nMaxCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowText(m_hWnd, lpszString, nMaxCount); }
_AFXWIN_INLINE int CWnd::GetWindowTextLength() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowTextLength(m_hWnd); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::SetFont(CFont* pFont, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }
_AFXWIN_INLINE CFont* CWnd::GetFont() const
	{ ASSERT(::IsWindow(m_hWnd)); return CFont::FromHandle(
		(HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0)); }
_AFXWIN_INLINE void CWnd::DragAcceptFiles(BOOL bAccept)
	{ ASSERT(::IsWindow(m_hWnd)); ::DragAcceptFiles(m_hWnd, bAccept); }
_AFXWIN_INLINE void CWnd::DrawMenuBar()
	{ ASSERT(::IsWindow(m_hWnd)); ::DrawMenuBar(m_hWnd); }
_AFXWIN_INLINE CMenu* CWnd::GetSystemMenu(BOOL bRevert) const
	{ ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle(::GetSystemMenu(m_hWnd, bRevert)); }
_AFXWIN_INLINE BOOL CWnd::HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite)
	{ ASSERT(::IsWindow(m_hWnd)); return ::HiliteMenuItem(m_hWnd, pMenu->m_hMenu, nIDHiliteItem, nHilite); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE int CWnd::GetDlgCtrlID() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgCtrlID(m_hWnd); }
_AFXWIN_INLINE int CWnd::SetDlgCtrlID(int nID)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SetWindowLong(m_hWnd, GWL_ID, nID); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CFrameWnd* CWnd::EnsureParentFrame() const
{
    CFrameWnd *pFrameWnd=GetParentFrame();
    ENSURE_VALID(pFrameWnd);
    return pFrameWnd;
}
_AFXWIN_INLINE CWnd* CWnd::EnsureTopLevelParent() const
{
    CWnd *pWnd=GetTopLevelParent();
    ENSURE_VALID(pWnd);
    return pWnd;
}
_AFXWIN_INLINE BOOL CWnd::IsIconic() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsIconic(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::IsZoomed() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsZoomed(m_hWnd); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint)
	{ ASSERT(::IsWindow(m_hWnd)); ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::MoveWindow(LPCRECT lpRect, BOOL bRepaint)
	{ MoveWindow(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
		lpRect->bottom - lpRect->top, bRepaint); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
		x, y, cx, cy, nFlags); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE UINT CWnd::ArrangeIconicWindows()
	{ ASSERT(::IsWindow(m_hWnd)); return ::ArrangeIconicWindows(m_hWnd); }
_AFXWIN_INLINE int CWnd::SetWindowRgn(HRGN hRgn, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowRgn(m_hWnd, hRgn, bRedraw); }
_AFXWIN_INLINE int CWnd::GetWindowRgn(HRGN hRgn) const
	{ ASSERT(::IsWindow(m_hWnd) && hRgn != NULL); return ::GetWindowRgn(m_hWnd, hRgn); }
_AFXWIN_INLINE void CWnd::BringWindowToTop()
	{ ASSERT(::IsWindow(m_hWnd)); ::BringWindowToTop(m_hWnd); }
_AFXWIN_INLINE void CWnd::GetWindowRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::GetWindowRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::GetClientRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::GetClientRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), lpPoint, nCount); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), (LPPOINT)lpRect, 2); }
_AFXWIN_INLINE void CWnd::ClientToScreen(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); ::ClientToScreen(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPPOINT lpPoint) const
	{ ASSERT(::IsWindow(m_hWnd)); ::ScreenToClient(m_hWnd, lpPoint); }
_AFXWIN_INLINE CDC* CWnd::BeginPaint(LPPAINTSTRUCT lpPaint)
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::BeginPaint(m_hWnd, lpPaint)); }
_AFXWIN_INLINE void CWnd::EndPaint(LPPAINTSTRUCT lpPaint)
	{ ASSERT(::IsWindow(m_hWnd)); ::EndPaint(m_hWnd, lpPaint); }
_AFXWIN_INLINE CDC* CWnd::GetDC()
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDC(m_hWnd)); }
_AFXWIN_INLINE CDC* CWnd::GetWindowDC()
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetWindowDC(m_hWnd)); }
_AFXWIN_INLINE int CWnd::ReleaseDC(CDC* pDC)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ReleaseDC(m_hWnd, pDC->m_hDC); }
_AFXWIN_INLINE void CWnd::UpdateWindow()
	{ ASSERT(::IsWindow(m_hWnd)); ::UpdateWindow(m_hWnd); }
_AFXWIN_INLINE void CWnd::SetRedraw(BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_SETREDRAW, bRedraw, 0); }
_AFXWIN_INLINE BOOL CWnd::GetUpdateRect(LPRECT lpRect, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE int CWnd::GetUpdateRgn(CRgn* pRgn, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetUpdateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::Invalidate(BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, NULL, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRect(LPCRECT lpRect, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRgn(CRgn* pRgn, BOOL bErase)
	{ ASSERT(::IsWindow(m_hWnd)); ::InvalidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::ValidateRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::ValidateRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::ValidateRgn(CRgn* pRgn)
	{ ASSERT(::IsWindow(m_hWnd)); ::ValidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::ShowWindow(int nCmdShow)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ShowWindow(m_hWnd, nCmdShow); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowVisible() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsWindowVisible(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowOwnedPopups(BOOL bShow)
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowOwnedPopups(m_hWnd, bShow); }
_AFXWIN_INLINE void CWnd::SendMessageToDescendants(
	UINT message, WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm)
	{ ASSERT(::IsWindow(m_hWnd)); CWnd::SendMessageToDescendants(m_hWnd, message, wParam, lParam, bDeep,
		bOnlyPerm); }
_AFXWIN_INLINE CWnd* CWnd::GetDescendantWindow(int nID, BOOL bOnlyPerm) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::GetDescendantWindow(m_hWnd, nID, bOnlyPerm); }

#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsDialogMessage(LPMSG lpMsg)
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsDialogMessage(m_hWnd, lpMsg); }
#endif

_AFXWIN_INLINE CDC* CWnd::GetDCEx(CRgn* prgnClip, DWORD flags)
	{ ASSERT(::IsWindow(m_hWnd)); return CDC::FromHandle(::GetDCEx(m_hWnd, (HRGN)prgnClip->GetSafeHandle(), flags)); }
_AFXWIN_INLINE BOOL CWnd::LockWindowUpdate()
	{ ASSERT(::IsWindow(m_hWnd)); return ::LockWindowUpdate(m_hWnd); }
_AFXWIN_INLINE void CWnd::UnlockWindowUpdate()
	{ ASSERT(::IsWindow(m_hWnd)); ::LockWindowUpdate(NULL); }
_AFXWIN_INLINE BOOL CWnd::RedrawWindow(LPCRECT lpRectUpdate, CRgn* prgnUpdate,
	UINT flags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::RedrawWindow(m_hWnd, lpRectUpdate, (HRGN)prgnUpdate->GetSafeHandle(), flags); }
_AFXWIN_INLINE BOOL CWnd::EnableScrollBar(int nSBFlags, UINT nArrowFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::EnableScrollBar(m_hWnd, nSBFlags, nArrowFlags); }
_AFXWIN_INLINE BOOL CWnd::DrawAnimatedRects(int idAni, CONST RECT *lprcFrom, CONST RECT *lprcTo)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::DrawAnimatedRects(m_hWnd, idAni, lprcFrom, lprcTo); }
_AFXWIN_INLINE BOOL CWnd::DrawCaption(CDC* pDC, LPCRECT lprc, UINT uFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::DrawCaption(m_hWnd, pDC->GetSafeHdc(), lprc, uFlags); }

_AFXWIN_INLINE UINT_PTR CWnd::SetTimer(UINT_PTR nIDEvent, UINT nElapse,
		void (CALLBACK* lpfnTimer)(HWND, UINT, UINT_PTR, DWORD))
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetTimer(m_hWnd, nIDEvent, nElapse,
		lpfnTimer); }
_AFXWIN_INLINE BOOL CWnd::KillTimer(UINT_PTR nIDEvent)
	{ ASSERT(::IsWindow(m_hWnd)); return ::KillTimer(m_hWnd, nIDEvent); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE BOOL CWnd::IsWindowEnabled() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsWindowEnabled(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::EnableWindow(BOOL bEnable)
	{ ASSERT(::IsWindow(m_hWnd)); return ::EnableWindow(m_hWnd, bEnable); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetActiveWindow()
	{ return CWnd::FromHandle(::GetActiveWindow()); }
_AFXWIN_INLINE CWnd* CWnd::SetActiveWindow()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetActiveWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetCapture()
	{ return CWnd::FromHandle(::GetCapture()); }
_AFXWIN_INLINE CWnd* CWnd::SetCapture()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetCapture(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetFocus()
	{ return CWnd::FromHandle(::GetFocus()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::SetFocus()
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetFocus(m_hWnd)); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetDesktopWindow()
	{ return CWnd::FromHandle(::GetDesktopWindow()); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE void CWnd::CheckDlgButton(int nIDButton, UINT nCheck)
	{ ASSERT(::IsWindow(m_hWnd)); ::CheckDlgButton(m_hWnd, nIDButton, nCheck); }
_AFXWIN_INLINE void CWnd::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
		int nIDCheckButton)
	{ ASSERT(::IsWindow(m_hWnd)); ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton); }
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE int CWnd::DlgDirList(_Inout_z_ LPTSTR lpPathSpec, _In_ int nIDListBox,
		_In_ int nIDStaticPath, _In_ UINT nFileType)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox,
			nIDStaticPath, nFileType); }
_AFXWIN_INLINE int CWnd::DlgDirListComboBox(_Inout_z_ LPTSTR lpPathSpec, _In_ int nIDComboBox,
		_In_ int nIDStaticPath, _In_ UINT nFileType)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirListComboBox(m_hWnd, lpPathSpec,
			nIDComboBox, nIDStaticPath, nFileType); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpString, int nIDListBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectEx(m_hWnd, lpString, _MAX_PATH, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(_Out_z_cap_(nSize) LPTSTR lpString, int nSize, int nIDListBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectEx(m_hWnd, lpString, nSize, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(_Out_z_cap_c_(_MAX_PATH) LPTSTR lpString, int nIDComboBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, _MAX_PATH, nIDComboBox);}
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(_Out_z_cap_(nSize) LPTSTR lpString, int nSize, int nIDComboBox)
	{ ASSERT(::IsWindow(m_hWnd)); return ::DlgDirSelectComboBoxEx(m_hWnd, lpString, nSize, nIDComboBox);}
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetDlgItem(int nID) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetDlgItem(m_hWnd, nID)); }
_AFXWIN_INLINE void CWnd::GetDlgItem(int nID, HWND* phWnd) const
	{ ASSERT(::IsWindow(m_hWnd)); ASSERT(phWnd != NULL); *phWnd = ::GetDlgItem(m_hWnd, nID); }
_AFXWIN_INLINE UINT CWnd::GetDlgItemInt(int nID, BOOL* lpTrans,
		BOOL bSigned) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);}
_AFXWIN_INLINE int CWnd::GetDlgItemText(_In_ int nID, _Out_z_cap_post_count_(nMaxCount, return + 1) LPTSTR lpStr, _In_ int nMaxCount) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);}
#endif //_AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgGroupItem(m_hWnd,
			pWndCtl->GetSafeHwnd(), bPrevious)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextDlgTabItem(m_hWnd,
			pWndCtl->GetSafeHwnd(), bPrevious)); }
#ifdef _AFX_NO_OCC_SUPPORT
_AFXWIN_INLINE UINT CWnd::IsDlgButtonChecked(int nIDButton) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsDlgButtonChecked(m_hWnd, nIDButton); }
_AFXWIN_INLINE LPARAM CWnd::SendDlgItemMessage(int nID, UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); }
_AFXWIN_INLINE void CWnd::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned); }
_AFXWIN_INLINE void CWnd::SetDlgItemText(int nID, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetDlgItemText(m_hWnd, nID, lpszString); }
_AFXWIN_INLINE int CWnd::ScrollWindowEx(int dx, int dy,
	LPCRECT lpRectScroll, LPCRECT lpRectClip,
	CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip,
			(HRGN)prgnUpdate->GetSafeHandle(), lpRectUpdate, flags); }
#endif //_AFX_NO_OCC_SUPPORT

_AFXWIN_INLINE void CWnd::ShowScrollBar(UINT nBar, BOOL bShow)
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, nBar, bShow); }
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPoint(m_hWnd, point)); }
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point, UINT nFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::ChildWindowFromPointEx(m_hWnd, point, nFlags)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::FindWindow(LPCTSTR lpszClassName, LPCTSTR lpszWindowName)
	{ return CWnd::FromHandle(::FindWindow(lpszClassName, lpszWindowName)); }
_AFXWIN_INLINE CWnd* CWnd::FindWindowEx(HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow)
	{ return CWnd::FromHandle(::FindWindowEx(hwndParent, hwndChildAfter, lpszClass, lpszWindow)); }

_AFXWIN_INLINE CWnd* CWnd::GetNextWindow(UINT nFlag) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetNextWindow(m_hWnd, nFlag)); }
_AFXWIN_INLINE CWnd* CWnd::GetTopWindow() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetTopWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::GetWindow(UINT nCmd) const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetWindow(m_hWnd, nCmd)); }
_AFXWIN_INLINE CWnd* CWnd::GetLastActivePopup() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetLastActivePopup(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::IsChild(const CWnd* pWnd) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::IsChild(m_hWnd, pWnd->GetSafeHwnd()); }
_AFXWIN_INLINE CWnd* CWnd::GetParent() const
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::GetParent(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::SetParent(CWnd* pWndNewParent)
	{ ASSERT(::IsWindow(m_hWnd)); return CWnd::FromHandle(::SetParent(m_hWnd,
			pWndNewParent->GetSafeHwnd())); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::WindowFromPoint(POINT point)
	{ return CWnd::FromHandle(::WindowFromPoint(point)); }
#pragma push_macro("MessageBox")
#undef MessageBox
_AFXWIN_INLINE int CWnd::MessageBox(LPCTSTR lpszText, LPCTSTR lpszCaption, UINT nType)
	{ return _AFX_FUNCNAME(MessageBox)(lpszText, lpszCaption, nType); }
#pragma pop_macro("MessageBox")
_AFXWIN_INLINE BOOL CWnd::FlashWindow(BOOL bInvert)
	{ ASSERT(::IsWindow(m_hWnd)); return ::FlashWindow(m_hWnd, bInvert); }
_AFXWIN_INLINE BOOL CWnd::ChangeClipboardChain(HWND hWndNext)
	{ ASSERT(::IsWindow(m_hWnd)); return ::ChangeClipboardChain(m_hWnd, hWndNext); }
_AFXWIN_INLINE HWND CWnd::SetClipboardViewer()
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetClipboardViewer(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenClipboard()
	{ ASSERT(::IsWindow(m_hWnd)); return ::OpenClipboard(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetOpenClipboardWindow()
	{ return CWnd::FromHandle(::GetOpenClipboardWindow()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardOwner()
	{ return CWnd::FromHandle(::GetClipboardOwner()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardViewer()
	{ return CWnd::FromHandle(::GetClipboardViewer()); }
_AFXWIN_INLINE void CWnd::CreateCaret(CBitmap* pBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)pBitmap->GetSafeHandle(), 0, 0); }
_AFXWIN_INLINE void CWnd::CreateSolidCaret(int nWidth, int nHeight)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight); }
_AFXWIN_INLINE void CWnd::CreateGrayCaret(int nWidth, int nHeight)
	{ ASSERT(::IsWindow(m_hWnd)); ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight); }
_AFXWIN_INLINE CPoint PASCAL CWnd::GetCaretPos()
	{ CPoint point; ::GetCaretPos((LPPOINT)&point); return point; }
_AFXWIN_INLINE void PASCAL CWnd::SetCaretPos(POINT point)
	{ ::SetCaretPos(point.x, point.y); }
_AFXWIN_INLINE void CWnd::HideCaret()
	{ ASSERT(::IsWindow(m_hWnd)); ::HideCaret(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowCaret()
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowCaret(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::SetForegroundWindow()
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetForegroundWindow(m_hWnd); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetForegroundWindow()
	{ return CWnd::FromHandle(::GetForegroundWindow()); }

_AFXWIN_INLINE BOOL CWnd::SendNotifyMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendNotifyMessage(m_hWnd, message, wParam, lParam); }

// Win4
_AFXWIN_INLINE HICON CWnd::SetIcon(HICON hIcon, BOOL bBigIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CWnd::GetIcon(BOOL bBigIcon) const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_GETICON, bBigIcon, 0); }
_AFXWIN_INLINE void CWnd::Print(CDC* pDC, DWORD dwFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
_AFXWIN_INLINE void CWnd::PrintClient(CDC* pDC, DWORD dwFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PRINTCLIENT, (WPARAM)pDC->GetSafeHdc(), dwFlags); }
_AFXWIN_INLINE BOOL CWnd::SetWindowContextHelpId(DWORD dwContextHelpId)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetWindowContextHelpId(m_hWnd, dwContextHelpId); }
_AFXWIN_INLINE DWORD CWnd::GetWindowContextHelpId() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowContextHelpId(m_hWnd); }

// ActiveAccessibility
_AFXWIN_INLINE void CWnd::EnableActiveAccessibility()
	{ m_bEnableActiveAccessibility = true; }
_AFXWIN_INLINE void CWnd::NotifyWinEvent(DWORD event, LONG idObjectType, LONG idObject)
	{ ASSERT(::IsWindow(m_hWnd)); ::NotifyWinEvent(event, m_hWnd, idObjectType, idObject); }

// Default message map implementations
_AFXWIN_INLINE void CWnd::OnActivateApp(BOOL, DWORD)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnActivate(UINT, CWnd*, BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnCancelMode()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnChildActivate()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnClose()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnContextMenu(CWnd*, CPoint)
	{ Default(); }
_AFXWIN_INLINE int CWnd::OnCopyData(CWnd*, COPYDATASTRUCT*)
	{ return (int)Default(); }
_AFXWIN_INLINE int CWnd::OnCreate(LPCREATESTRUCT)
	{ return (int)Default(); }
_AFXWIN_INLINE void CWnd::OnEnable(BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnEndSession(BOOL)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnEraseBkgnd(CDC*)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnGetMinMaxInfo(MINMAXINFO*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnIconEraseBkgnd(CDC*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnKillFocus(CWnd*)
	{ Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnMenuChar(UINT, UINT, CMenu*)
	{ return Default(); }
_AFXWIN_INLINE void CWnd::OnMenuSelect(UINT, UINT, HMENU)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMove(int, int)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSyncPaint()
	{ Default(); }
_AFXWIN_INLINE HCURSOR CWnd::OnQueryDragIcon()
	{ return (HCURSOR)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryEndSession()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryNewPalette()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnQueryOpen()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE BOOL CWnd::OnSetCursor(CWnd*, UINT, UINT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnShowWindow(BOOL, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSize(UINT, int, int)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnTCard(UINT, DWORD)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnWindowPosChanging(WINDOWPOS*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnWindowPosChanged(WINDOWPOS*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSessionChange(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnDropFiles(HDROP)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteIsChanging(CWnd*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcActivate(BOOL)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnNcCreate(LPCREATESTRUCT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE LRESULT CWnd::OnNcHitTest(CPoint)
	{ return Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMouseHover(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMouseLeave()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcPaint()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcXButtonDown(short, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcXButtonUp(short, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcXButtonDblClk(short, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysCommand(UINT, LPARAM)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSysKeyUp(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnAppCommand(CWnd*, UINT, UINT, UINT)
	{ return (BOOL)Default(); }
#if(_WIN32_WINNT >= 0x0501)
_AFXWIN_INLINE void CWnd::OnRawInput(UINT, HRAWINPUT)
	{ Default(); }
#endif
_AFXWIN_INLINE void CWnd::OnCompacting(UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnFontChange()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaletteChanged(CWnd*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSpoolerStatus(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnTimeChange()
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnPowerBroadcast(UINT, UINT)
	{ return (UINT) Default(); }
_AFXWIN_INLINE void CWnd::OnUserChanged()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnInputLangChange(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnInputLangChangeRequest(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnInputDeviceChange(unsigned short, HANDLE)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnUniChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnKeyUp(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnHotKey(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnXButtonDblClk(UINT, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnXButtonDown(UINT, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnXButtonUp(UINT, UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE int CWnd::OnMouseActivate(CWnd*, UINT, UINT)
	{ return (int)Default(); }
_AFXWIN_INLINE void CWnd::OnMouseHover(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMouseLeave()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMouseHWheel(UINT, short, CPoint)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnMouseWheel(UINT, short, CPoint)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnTimer(UINT_PTR)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnInitMenu(CMenu*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnInitMenuPopup(CMenu*, UINT, BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnUnInitMenuPopup(CMenu*, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnAskCbFormatName(_In_ UINT nMaxCount, _Out_z_cap_(nMaxCount) LPTSTR pszName)
{
	(nMaxCount);
	if(nMaxCount>0)
	{
		/* defwindow proc should do this for us, but to be safe, we'll do it here too */
		pszName[0]=_T('\0');
	}
	Default(); 
}
_AFXWIN_INLINE void CWnd::OnChangeCbChain(HWND, HWND)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnDestroyClipboard()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnDrawClipboard()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnHScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnPaintClipboard(CWnd*, HGLOBAL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRenderAllFormats()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnRenderFormat(UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSizeClipboard(CWnd*, HGLOBAL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnVScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnClipboardUpdate()
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnGetDlgCode()
	{ return (UINT)Default(); }
_AFXWIN_INLINE void CWnd::OnMDIActivate(BOOL, CWnd*, CWnd*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnEnterMenuLoop(BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnExitMenuLoop(BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMenuRButtonUp(UINT, CMenu*)
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnMenuDrag(UINT, CMenu*)
	{ return (UINT) Default(); }
#if(WINVER >= 0x0500)
_AFXWIN_INLINE UINT CWnd::OnMenuGetObject(MENUGETOBJECTINFO*)
	{ return (UINT) Default(); }
#endif
_AFXWIN_INLINE void CWnd::OnMenuCommand(UINT, CMenu*)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNextMenu(UINT, LPMDINEXTMENU)
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnNotifyFormat(CWnd*, UINT)
	{ return (UINT) Default(); }
// Win4 support
_AFXWIN_INLINE void CWnd::OnStyleChanged(int, LPSTYLESTRUCT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnStyleChanging(int, LPSTYLESTRUCT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnSizing(UINT, LPRECT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnMoving(UINT, LPRECT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnEnterSizeMove()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnExitSizeMove()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnCaptureChanged(CWnd*)
	{ Default(); }
_AFXWIN_INLINE BOOL CWnd::OnDeviceChange(UINT, DWORD_PTR)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE void CWnd::OnWinIniChange(LPCTSTR)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnChangeUIState(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnUpdateUIState(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE UINT CWnd::OnQueryUIState()
	{ return (UINT)Default(); }

// Desktop Windows Manager support
_AFXWIN_INLINE void CWnd::OnCompositionChanged()
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnNcRenderingChanged(BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnColorizationColorChanged(DWORD, BOOL)
	{ Default(); }
_AFXWIN_INLINE void CWnd::OnWindowMaximizedChange(BOOL)
	{ Default(); }

// CWnd dialog data support
_AFXWIN_INLINE void CWnd::DoDataExchange(CDataExchange*)
	{ } // default does nothing

// CWnd modality support
_AFXWIN_INLINE void CWnd::BeginModalState()
	{ ::EnableWindow(m_hWnd, FALSE); }
_AFXWIN_INLINE void CWnd::EndModalState()
	{ ::EnableWindow(m_hWnd, TRUE); }

// CFrameWnd
_AFXWIN_INLINE void CFrameWnd::DelayUpdateFrameTitle()
	{ m_nIdleFlags |= idleTitle; }
_AFXWIN_INLINE void CFrameWnd::DelayRecalcLayout(BOOL bNotify)
	{ m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
_AFXWIN_INLINE BOOL CFrameWnd::InModalState() const
	{ return m_cModalStack != 0; }
_AFXWIN_INLINE void CFrameWnd::AddControlBar(CControlBar *pBar)
	{ m_listControlBars.AddTail(pBar); }
_AFXWIN_INLINE void CFrameWnd::SetTitle(LPCTSTR lpszTitle)
	{ m_strTitle = lpszTitle; }
_AFXWIN_INLINE CString CFrameWnd::GetTitle() const
	{ return m_strTitle; }

// CDialog
_AFXWIN_INLINE BOOL CDialog::Create(UINT nIDTemplate, CWnd* pParentWnd)
	{ return CDialog::Create(ATL_MAKEINTRESOURCE(nIDTemplate), pParentWnd); }
_AFXWIN_INLINE void CDialog::MapDialogRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::MapDialogRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CDialog::SetHelpID(UINT nIDR)
	{ m_nIDHelp = nIDR; }
_AFXWIN_INLINE void CDialog::NextDlgCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0); }
_AFXWIN_INLINE void CDialog::PrevDlgCtrl() const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0); }
_AFXWIN_INLINE void CDialog::GotoDlgCtrl(CWnd* pWndCtrl)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)pWndCtrl->m_hWnd, 1L); }
_AFXWIN_INLINE void CDialog::SetDefID(UINT nID)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, DM_SETDEFID, nID, 0); }
_AFXWIN_INLINE DWORD CDialog::GetDefID() const
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, DM_GETDEFID, 0, 0)); }

// Window control functions
_AFXWIN_INLINE CStatic::CStatic()
	{ }
_AFXWIN_INLINE HICON CStatic::SetIcon(HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L); }
_AFXWIN_INLINE HICON CStatic::GetIcon() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L); }
_AFXWIN_INLINE HENHMETAFILE CStatic::SetEnhMetaFile(HENHMETAFILE hMetaFile)
	{ ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile); }
_AFXWIN_INLINE HENHMETAFILE CStatic::GetEnhMetaFile() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L); }
_AFXWIN_INLINE HBITMAP CStatic::SetBitmap(HBITMAP hBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CStatic::GetBitmap() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CStatic::SetCursor(HCURSOR hCursor)
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CStatic::GetCursor()
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L); }

_AFXWIN_INLINE CButton::CButton()
	{ }
_AFXWIN_INLINE UINT CButton::GetState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0); }
_AFXWIN_INLINE void CButton::SetState(BOOL bHighlight)
	{ ::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0); }
_AFXWIN_INLINE int CButton::GetCheck() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0); }
_AFXWIN_INLINE void CButton::SetCheck(int nCheck)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0); }
_AFXWIN_INLINE UINT CButton::GetButtonStyle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)GetWindowLong(m_hWnd, GWL_STYLE) & 0xFFFF; }
_AFXWIN_INLINE void CButton::SetButtonStyle(UINT nStyle, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw); }
// Win4
_AFXWIN_INLINE HICON CButton::SetIcon(HICON hIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon); }
_AFXWIN_INLINE HICON CButton::GetIcon() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L); }
_AFXWIN_INLINE HBITMAP CButton::SetBitmap(HBITMAP hBitmap)
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap); }
_AFXWIN_INLINE HBITMAP CButton::GetBitmap() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L); }
_AFXWIN_INLINE HCURSOR CButton::SetCursor(HCURSOR hCursor)
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor); }
_AFXWIN_INLINE HCURSOR CButton::GetCursor()
	{ ASSERT(::IsWindow(m_hWnd)); return (HCURSOR)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_CURSOR, 0L); }

#if (_WIN32_WINNT >= 0x600) && defined(UNICODE)
_AFXWIN_INLINE CSplitButton::CSplitButton()
	:m_pMenu(NULL), m_nMenuId((UINT)-1), m_nSubMenuId((UINT)-1)
	{ }
_AFXWIN_INLINE CSplitButton::CSplitButton(UINT nMenuId, UINT nSubMenuId)
	:m_pMenu(NULL), m_nMenuId((UINT)nMenuId), m_nSubMenuId((UINT)nSubMenuId)
	{  }
_AFXWIN_INLINE CSplitButton::CSplitButton(CMenu* pMenu)
	:m_pMenu(pMenu), m_nMenuId((UINT)-1), m_nSubMenuId((UINT)-1)
	{  }
#endif // (_WIN32_WINNT >= 0x600) && defined(UNICODE)

_AFXWIN_INLINE CListBox::CListBox()
	{ }
_AFXWIN_INLINE int CListBox::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CListBox::SetCurSel(int nSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE int CListBox::GetHorizontalExtent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT,
		0, 0); }
_AFXWIN_INLINE void CListBox::SetHorizontalExtent(int cxExtent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0); }
_AFXWIN_INLINE int CListBox::GetSelCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetSelItems(int nMaxItems, LPINT rgIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex); }
_AFXWIN_INLINE int CListBox::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CListBox::SetTopIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0);}
_AFXWIN_INLINE DWORD_PTR CListBox::GetItemData(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CListBox::GetItemDataPtr(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (LPVOID)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemDataPtr(int nIndex, void* pData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CListBox::GetItemRect(int nIndex, LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXWIN_INLINE int CListBox::GetSel(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetSel(int nIndex, BOOL bSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex); }
_AFXWIN_INLINE int CListBox::GetText(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszBuffer) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer); 
}
_AFXWIN_INLINE int CListBox::GetTextLen(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CListBox::SetColumnWidth(int cxWidth)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops); }
_AFXWIN_INLINE void CListBox::SetTabStops()
	{ ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(const int& cxEachStop)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE int CListBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CListBox::GetItemHeight(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CListBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CListBox::GetCaretIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0L); }
_AFXWIN_INLINE int CListBox::SetCaretIndex(int nIndex, BOOL bScroll)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0)); }
_AFXWIN_INLINE int CListBox::AddString(LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::DeleteString(UINT nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }
_AFXWIN_INLINE int CListBox::InsertString(int nIndex, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem); }
_AFXWIN_INLINE void CListBox::ResetContent()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CListBox::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CListBox::FindString(int nStartAfter, LPCTSTR lpszItem) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_FINDSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelectString(int nStartAfter, LPCTSTR lpszItem)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
	{ ASSERT(::IsWindow(m_hWnd)); return bSelect ?
		(int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) :
		(int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem); }
_AFXWIN_INLINE void CListBox::SetAnchorIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0); }
_AFXWIN_INLINE int CListBox::GetAnchorIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0); }
_AFXWIN_INLINE LCID CListBox::GetLocale() const
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CListBox::SetLocale(LCID nNewLocale)
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0); }
_AFXWIN_INLINE int CListBox::InitStorage(int nItems, UINT nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes); }

_AFXWIN_INLINE CCheckListBox::CCheckListBox()
	{ m_cyText = 0; m_nStyle = 0; EnableActiveAccessibility(); }
_AFXWIN_INLINE UINT CCheckListBox::GetCheckStyle()
	{ return m_nStyle; }

_AFXWIN_INLINE CComboBox::CComboBox()
	{ }
_AFXWIN_INLINE int CComboBox::GetCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CComboBox::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetCurSel(int nSelect)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE DWORD CComboBox::GetEditSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0)); }
_AFXWIN_INLINE BOOL CComboBox::LimitText(int nMaxChars)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0); }
_AFXWIN_INLINE BOOL CComboBox::SetEditSel(int nStartChar, int nEndChar)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar)); }
_AFXWIN_INLINE DWORD_PTR CComboBox::GetItemData(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::SetItemData(int nIndex, DWORD_PTR dwItemData)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CComboBox::GetItemDataPtr(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (LPVOID)GetItemData(nIndex); }
_AFXWIN_INLINE int CComboBox::SetItemDataPtr(int nIndex, void* pData)
	{ ASSERT(::IsWindow(m_hWnd)); return SetItemData(nIndex, (DWORD_PTR)(LPVOID)pData); }
_AFXWIN_INLINE int CComboBox::GetLBText(_In_ int nIndex, _Pre_notnull_ _Post_z_ LPTSTR lpszText) const
{ 
	ASSERT(::IsWindow(m_hWnd)); 
	return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText); 
}
_AFXWIN_INLINE int CComboBox::GetLBTextLen(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CComboBox::ShowDropDown(BOOL bShowIt)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0); }
_AFXWIN_INLINE int CComboBox::AddString(LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::DeleteString(UINT nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0);}
_AFXWIN_INLINE int CComboBox::InsertString(int nIndex, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::ResetContent()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::Dir(UINT attr, LPCTSTR lpszWildCard)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CComboBox::FindString(int nStartAfter, LPCTSTR lpszString) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter,
		(LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::SelectString(int nStartAfter, LPCTSTR lpszString)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CComboBox::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CComboBox::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CComboBox::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CComboBox::GetItemHeight(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CComboBox::FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CComboBox::SetExtendedUI(BOOL bExtended )
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L); }
_AFXWIN_INLINE BOOL CComboBox::GetExtendedUI() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L); }
_AFXWIN_INLINE void CComboBox::GetDroppedControlRect(LPRECT lprect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect); }
_AFXWIN_INLINE BOOL CComboBox::GetDroppedState() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L); }
_AFXWIN_INLINE LCID CComboBox::GetLocale() const
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0); }
_AFXWIN_INLINE LCID CComboBox::SetLocale(LCID nNewLocale)
	{ ASSERT(::IsWindow(m_hWnd)); return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0); }
_AFXWIN_INLINE int CComboBox::GetTopIndex() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetTopIndex(int nIndex)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::InitStorage(int nItems, UINT nBytes)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes); }
_AFXWIN_INLINE void CComboBox::SetHorizontalExtent(UINT nExtent)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0); }
_AFXWIN_INLINE UINT CComboBox::GetHorizontalExtent() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetDroppedWidth(UINT nWidth)
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0); }
_AFXWIN_INLINE int CComboBox::GetDroppedWidth() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0); }
_AFXWIN_INLINE CEdit::CEdit()
	{ }
_AFXWIN_INLINE BOOL CEdit::CanUndo() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXWIN_INLINE int CEdit::GetLineCount() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::GetModify() const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXWIN_INLINE void CEdit::SetModify(BOOL bModified)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0); }
_AFXWIN_INLINE void CEdit::GetRect(LPRECT lpRect) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::GetSel(int& nStartChar, int& nEndChar) const
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar,(LPARAM)&nEndChar); }
_AFXWIN_INLINE DWORD CEdit::GetSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return DWORD(::SendMessage(m_hWnd, EM_GETSEL, 0, 0)); }
_AFXWIN_INLINE HLOCAL CEdit::GetHandle() const
	{ ASSERT(::IsWindow(m_hWnd)); return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0); }
_AFXWIN_INLINE void CEdit::SetHandle(HLOCAL hBuffer)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0); }
_AFXWIN_INLINE int CEdit::GetLine(_In_ int nIndex, _Out_ LPTSTR lpszBuffer) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CEdit::GetLine(_In_ int nIndex, _Out_cap_post_count_(nMaxLength, return) LPTSTR lpszBuffer, _In_ int nMaxLength) const
	{
		ASSERT(::IsWindow(m_hWnd));
		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
_AFXWIN_INLINE void CEdit::EmptyUndoBuffer()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::FmtLines(BOOL bAddEOL)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0); }
_AFXWIN_INLINE void CEdit::LimitText(int nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0); }
_AFXWIN_INLINE int CEdit::LineFromChar(int nIndex) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0); }
_AFXWIN_INLINE int CEdit::LineIndex(int nLine) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0); }
_AFXWIN_INLINE int CEdit::LineLength(int nLine) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0); }
_AFXWIN_INLINE void CEdit::LineScroll(int nLines, int nChars)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines); }
_AFXWIN_INLINE void CEdit::ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText); }
_AFXWIN_INLINE void CEdit::SetPasswordChar(TCHAR ch)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0); }
_AFXWIN_INLINE void CEdit::SetRect(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetRectNP(LPCRECT lpRect)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetSel(DWORD dwSelection, BOOL bNoScroll)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL,
		LOWORD(dwSelection), HIWORD(dwSelection));
	  if (!bNoScroll)
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE void CEdit::SetSel(int nStartChar, int nEndChar, BOOL bNoScroll)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
	  if (!bNoScroll)
		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops,
		(LPARAM)rgTabStops); }
_AFXWIN_INLINE void CEdit::SetTabStops()
	{ ASSERT(::IsWindow(m_hWnd)); VERIFY(::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(const int& cxEachStop)
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS,
		1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE BOOL CEdit::Undo()
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXWIN_INLINE void CEdit::Clear()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CEdit::Copy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CEdit::Cut()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CEdit::Paste()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::SetReadOnly(BOOL bReadOnly )
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXWIN_INLINE int CEdit::GetFirstVisibleLine() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXWIN_INLINE TCHAR CEdit::GetPasswordChar() const
	{ ASSERT(::IsWindow(m_hWnd)); return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L); }
_AFXWIN_INLINE void CEdit::SetMargins(UINT nLeft, UINT nRight)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight)); }
_AFXWIN_INLINE DWORD CEdit::GetMargins() const
	{ ASSERT(::IsWindow(m_hWnd)); return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0); }
_AFXWIN_INLINE void CEdit::SetLimitText(UINT nMax)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0); }
_AFXWIN_INLINE UINT CEdit::GetLimitText() const
	{ ASSERT(::IsWindow(m_hWnd)); return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0); }
_AFXWIN_INLINE CPoint CEdit::PosFromChar(UINT nChar) const
	{ ASSERT(::IsWindow(m_hWnd)); return CPoint( (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0)); }
_AFXWIN_INLINE int CEdit::CharFromPos(CPoint pt) const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y)); }

_AFXWIN_INLINE CScrollBar::CScrollBar()
	{ }
_AFXWIN_INLINE int CScrollBar::GetScrollPos() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetScrollPos(m_hWnd, SB_CTL); }
_AFXWIN_INLINE int CScrollBar::SetScrollPos(int nPos, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
	{ ASSERT(::IsWindow(m_hWnd)); ::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos); }
_AFXWIN_INLINE void CScrollBar::SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw)
	{ ASSERT(::IsWindow(m_hWnd)); ::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::ShowScrollBar(BOOL bShow)
	{ ASSERT(::IsWindow(m_hWnd)); ::ShowScrollBar(m_hWnd, SB_CTL, bShow); }
_AFXWIN_INLINE BOOL CScrollBar::EnableScrollBar(UINT nArrowFlags)
	{ ASSERT(::IsWindow(m_hWnd)); return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags); }
_AFXWIN_INLINE BOOL CScrollBar::SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw)
	{ return CWnd::SetScrollInfo(SB_CTL, lpScrollInfo, bRedraw); }
_AFXWIN_INLINE BOOL CScrollBar::GetScrollInfo(LPSCROLLINFO lpScrollInfo, UINT nMask)
	{ return CWnd::GetScrollInfo(SB_CTL, lpScrollInfo, nMask); }
_AFXWIN_INLINE int CScrollBar::GetScrollLimit()
	{ return CWnd::GetScrollLimit(SB_CTL); }


// MDI functions
_AFXWIN_INLINE void CMDIFrameWnd::MDIActivate(CWnd* pWndActivate)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE,
		(WPARAM)pWndActivate->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIIconArrange()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIMaximize(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIPrev()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 1); }
_AFXWIN_INLINE void CMDIFrameWnd::MDINext()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIRestore(CWnd* pWnd)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE CMenu* CMDIFrameWnd::MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu)
	{ ASSERT(::IsWindow(m_hWnd)); return CMenu::FromHandle((HMENU)::SendMessage(
		m_hWndMDIClient, WM_MDISETMENU, (WPARAM)pFrameMenu->GetSafeHmenu(),
		(LPARAM)pWindowMenu->GetSafeHmenu())); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDICascade()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, 0, 0); }

_AFXWIN_INLINE void CMDIFrameWnd::MDICascade(int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, nType, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile(int nType)
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(m_hWndMDIClient, WM_MDITILE, nType, 0); }
_AFXWIN_INLINE void CMDIChildWnd::MDIDestroy()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIDESTROY, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIActivate()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIACTIVATE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIMaximize()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIMAXIMIZE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIRestore()
	{ ASSERT(::IsWindow(m_hWnd)); ::SendMessage(GetParent()->m_hWnd, WM_MDIRESTORE, (WPARAM)m_hWnd, 0L); }

// CView
_AFXWIN_INLINE CDocument* CView::GetDocument() const
	{ ASSERT(this != NULL); return m_pDocument; }
_AFXWIN_INLINE CSize CScrollView::GetTotalSize() const
	{ ASSERT(this != NULL); return m_totalLog; }

// CDocument
_AFXWIN_INLINE const CString& CDocument::GetTitle() const
	{ ASSERT(this != NULL); return m_strTitle; }
_AFXWIN_INLINE const CString& CDocument::GetPathName() const
	{ ASSERT(this != NULL); return m_strPathName; }
_AFXWIN_INLINE CDocTemplate* CDocument::GetDocTemplate() const
	{ ASSERT(this != NULL); return m_pDocTemplate; }
_AFXWIN_INLINE BOOL CDocument::IsModified()
	{ ASSERT(this != NULL); return m_bModified; }
_AFXWIN_INLINE void CDocument::SetModifiedFlag(BOOL bModified)
	{ ASSERT(this != NULL); m_bModified = bModified; }

// CWinThread
_AFXWIN_INLINE CWinThread::operator HANDLE() const
	{ return this == NULL ? NULL : m_hThread; }
_AFXWIN_INLINE BOOL CWinThread::SetThreadPriority(int nPriority)
	{ ASSERT(m_hThread != NULL); return ::SetThreadPriority(m_hThread, nPriority); }
_AFXWIN_INLINE int CWinThread::GetThreadPriority()
	{ ASSERT(m_hThread != NULL); return ::GetThreadPriority(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::ResumeThread()
	{ ASSERT(m_hThread != NULL); return ::ResumeThread(m_hThread); }
_AFXWIN_INLINE DWORD CWinThread::SuspendThread()
	{ ASSERT(m_hThread != NULL); return ::SuspendThread(m_hThread); }
_AFXWIN_INLINE BOOL CWinThread::PostThreadMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ ASSERT(m_hThread != NULL); return ::PostThreadMessage(m_nThreadID, message, wParam, lParam); }

// CWinApp
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(LPCTSTR lpszResourceName) const
	{ return ::LoadCursor(AfxFindResourceHandle(lpszResourceName,
		ATL_RT_GROUP_CURSOR), lpszResourceName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(UINT nIDResource) const
	{ return ::LoadCursorW(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),
		ATL_RT_GROUP_CURSOR), ATL_MAKEINTRESOURCEW(nIDResource)); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadStandardCursor(LPCTSTR lpszCursorName) const
	{ return ::LoadCursor(NULL, lpszCursorName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadOEMCursor(UINT nIDCursor) const
	{ return ::LoadCursorW(NULL, ATL_MAKEINTRESOURCEW(nIDCursor)); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(LPCTSTR lpszResourceName) const
	{ return ::LoadIcon(AfxFindResourceHandle(lpszResourceName,
		ATL_RT_GROUP_ICON), lpszResourceName); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(UINT nIDResource) const
	{ return ::LoadIconW(AfxFindResourceHandle(ATL_MAKEINTRESOURCE(nIDResource),
		ATL_RT_GROUP_ICON), ATL_MAKEINTRESOURCEW(nIDResource)); }
_AFXWIN_INLINE HICON CWinApp::LoadStandardIcon(LPCTSTR lpszIconName) const
	{ return ::LoadIcon(NULL, lpszIconName); }
_AFXWIN_INLINE HICON CWinApp::LoadOEMIcon(UINT nIDIcon) const
	{ return ::LoadIconW(NULL, ATL_MAKEINTRESOURCEW(nIDIcon)); }
_AFXWIN_INLINE void CWinApp::EnableHtmlHelp()
	{ SetHelpMode( afxHTMLHelp ); }

_AFXWIN_INLINE AFX_HELP_TYPE CWinApp::GetHelpMode() 
	{ return m_eHelpType; }

_AFXWIN_INLINE void CWinApp::SetHelpMode( AFX_HELP_TYPE eHelpType )
	{ 
		ASSERT( eHelpType == afxHTMLHelp || eHelpType == afxWinHelp );
		m_eHelpType = eHelpType; 
	}

#pragma warning(push)
#pragma warning(disable: 4996)
_AFXWIN_INLINE BOOL CWinApp::Enable3dControls()
	{ return TRUE; }
#ifndef _AFXDLL
_AFXWIN_INLINE BOOL CWinApp::Enable3dControlsStatic()
	{ return TRUE; }
#endif
_AFXWIN_INLINE void CWinApp::SetDialogBkColor(COLORREF /*clrCtlBk*/, COLORREF /*clrCtlText*/)
{
}
#pragma warning(pop)

_AFXWIN_INLINE CWaitCursor::CWaitCursor()
	{ AfxGetApp()->BeginWaitCursor(); }
_AFXWIN_INLINE CWaitCursor::~CWaitCursor()
{
	AFX_BEGIN_DESTRUCTOR

		AfxGetApp()->EndWaitCursor();

	AFX_END_DESTRUCTOR
}
_AFXWIN_INLINE void CWaitCursor::Restore()
	{ AfxGetApp()->RestoreWaitCursor(); }

/////////////////////////////////////////////////////////////////////////////
// Obsolete and non-portable

_AFXWIN_INLINE void CWnd::CloseWindow()
	{ ASSERT(::IsWindow(m_hWnd)); ::CloseWindow(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenIcon()
	{ ASSERT(::IsWindow(m_hWnd)); return ::OpenIcon(m_hWnd); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwin4.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Always Inline. Functions only in Win2K or later

#pragma once

#if (_WIN32_WINNT >= 0x0500)

AFX_INLINE COLORREF CDC::GetDCBrushColor() const
	{ ENSURE(m_hDC != NULL); return ::GetDCBrushColor(m_hDC); }
AFX_INLINE COLORREF CDC::SetDCBrushColor(COLORREF crColor)
	{ ENSURE(m_hDC != NULL); return ::SetDCBrushColor(m_hDC, crColor); }

AFX_INLINE COLORREF CDC::GetDCPenColor() const
	{ ENSURE(m_hDC != NULL); return ::GetDCPenColor(m_hDC); }
AFX_INLINE COLORREF CDC::SetDCPenColor(COLORREF crColor)
	{ ENSURE(m_hDC != NULL); return ::SetDCPenColor(m_hDC, crColor); }

AFX_INLINE BOOL CDC::GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const
	{ ENSURE(m_hDC != NULL); return ::GetCharABCWidthsI(m_hDC, giFirst, cgi, pgi, lpabc); }
AFX_INLINE BOOL CDC::GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const
	{ ENSURE(m_hDC != NULL); return ::GetCharWidthI(m_hDC, giFirst, cgi, pgi, lpBuffer); }

AFX_INLINE BOOL CDC::GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const
{
	ENSURE(lpSize != NULL);
	ENSURE(m_hDC != NULL);
	return ::GetTextExtentExPointI(m_hDC, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);
}
AFX_INLINE BOOL CDC::GetTextExtentPointI(LPWORD pgiIn, int cgi, LPSIZE lpSize) const
{
	ENSURE(lpSize != NULL);
	ENSURE(m_hDC != NULL);
	return ::GetTextExtentPointI(m_hDC, pgiIn, cgi, lpSize);
}

#endif

#if(WINVER >= 0x0500)

AFX_INLINE BOOL CWnd::GetWindowInfo(PWINDOWINFO pwi) const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetWindowInfo(m_hWnd, pwi); }

AFX_INLINE CWnd* CWnd::GetAncestor(UINT gaFlags) const
	{ ASSERT(::IsWindow(m_hWnd)); return  CWnd::FromHandle(::GetAncestor(m_hWnd, gaFlags)); }

AFX_INLINE BOOL CWnd::GetScrollBarInfo(LONG idObject, PSCROLLBARINFO psbi) const
{
	ASSERT(::IsWindow(m_hWnd));
	ENSURE(psbi != NULL);
	return ::GetScrollBarInfo(m_hWnd, idObject, psbi);
}

AFX_INLINE BOOL CWnd::GetTitleBarInfo(PTITLEBARINFO pti) const
{
	ASSERT(::IsWindow(m_hWnd));
	ENSURE(pti != NULL);
	return ::GetTitleBarInfo(m_hWnd, pti);
}

AFX_INLINE BOOL CWnd::AnimateWindow(DWORD dwTime, DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::AnimateWindow(m_hWnd, dwTime, dwFlags);
}

AFX_INLINE BOOL CWnd::FlashWindowEx(DWORD dwFlags, UINT  uCount, DWORD dwTimeout)
{
	ASSERT(::IsWindow(m_hWnd));
	FLASHWINFO fwi;
	fwi.cbSize = sizeof(fwi);
	fwi.hwnd = m_hWnd;
	fwi.dwFlags = dwFlags;
	fwi.uCount = uCount;
	fwi.dwTimeout = dwTimeout;

	return ::FlashWindowEx(&fwi);
}

AFX_INLINE BOOL CComboBox::GetComboBoxInfo(PCOMBOBOXINFO pcbi) const
{
	ASSERT(::IsWindow(m_hWnd));
	ENSURE(pcbi != NULL);
	return ::GetComboBoxInfo(m_hWnd, pcbi);
}

AFX_INLINE DWORD CListBox::GetListBoxInfo() const
	{ ASSERT(::IsWindow(m_hWnd)); return ::GetListBoxInfo(m_hWnd); }

AFX_INLINE BOOL CMenu::SetMenuInfo(LPCMENUINFO lpcmi)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuInfo(m_hMenu, lpcmi); }

AFX_INLINE BOOL CMenu::GetMenuInfo(LPMENUINFO lpcmi) const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuInfo(m_hMenu, lpcmi); }

#endif	// WINVER >= 0x0500

#if (_WIN32_WINNT >= 0x501) && defined(UNICODE)
AFX_INLINE BOOL CComboBox::SetMinVisibleItems(_In_ int iMinVisible)
{
	ASSERT(::IsWindow(m_hWnd));
	return ComboBox_SetMinVisible(m_hWnd, iMinVisible); // CB_SETMINVISIBLE
}

AFX_INLINE int CComboBox::GetMinVisible() const
{
	ASSERT(::IsWindow(m_hWnd));
	return ComboBox_GetMinVisible(m_hWnd); // CB_GETMINVISIBLE
}

#ifdef CB_SETCUEBANNER
AFX_INLINE BOOL CComboBox::SetCueBanner(_In_z_ LPCTSTR lpszText)
{
	ASSERT(::IsWindow(m_hWnd));
	return ComboBox_SetCueBannerText(m_hWnd, lpszText); // CB_SETCUEBANNER
}

AFX_INLINE CString CComboBox::GetCueBanner() const
{
	ASSERT(::IsWindow(m_hWnd));
	LPTSTR lpszText=NULL;
	int cchText = 0;
	CString strOut;
	BOOL b = CWnd::EnlargeBufferGetText<BOOL>(FALSE, lpszText, cchText, CB_GETCUEBANNER, (WPARAM&)lpszText, (LPARAM&)cchText, strOut);
	if (b)
		return strOut;
	else
		return CString();
}

AFX_INLINE BOOL CComboBox::GetCueBanner(_Out_z_cap_(cchText) LPWSTR lpszText, _In_ int cchText) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lpszText != NULL);
	if (cchText == 0 || lpszText == NULL)
		return FALSE;

	lpszText[0] = L'\0';
	return ComboBox_GetCueBannerText(m_hWnd, lpszText, cchText); // CB_GETCUEBANNER
}
#endif  // CB_SETCUEBANNER
#endif  // (_WIN32_WINNT >= 0x501) && defined(UNICODE)

#if(_WIN32_WINNT >= 0x0500)

AFX_INLINE BOOL CWnd::SetLayeredWindowAttributes(COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::SetLayeredWindowAttributes(m_hWnd, crKey, bAlpha, dwFlags);
}

AFX_INLINE BOOL CWnd::UpdateLayeredWindow(CDC* pDCDst, POINT *pptDst, SIZE *psize,
		CDC* pDCSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
{
	ASSERT(::IsWindow(m_hWnd));
	return ::UpdateLayeredWindow(m_hWnd, pDCDst->GetSafeHdc(), pptDst, psize,
		pDCSrc->GetSafeHdc(), pptSrc, crKey, pblend, dwFlags);
}

#endif	// _WIN32_WINNT >= 0x0500

#if(_WIN32_WINNT >= 0x0501)

AFX_INLINE BOOL CWnd::GetLayeredWindowAttributes(COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ::GetLayeredWindowAttributes(m_hWnd, pcrKey, pbAlpha, pdwFlags);
}

AFX_INLINE BOOL CWnd::PrintWindow(CDC* pDC, UINT nFlags) const
{
	ASSERT(::IsWindow(m_hWnd));
	return ::PrintWindow(m_hWnd, pDC->GetSafeHdc(), nFlags);
}

AFX_INLINE BOOL CScrollBar::GetScrollBarInfo(PSCROLLBARINFO pScrollInfo) const
	{ ASSERT(::IsWindow(m_hWnd)); return (BOOL)::SendMessage(m_hWnd, SBM_GETSCROLLBARINFO, NULL, (LPARAM)pScrollInfo); }

AFX_INLINE BOOL CEdit::SetCueBanner(_In_z_ LPCWSTR lpszText, _In_ BOOL fDrawWhenFocused /* = FALSE */)
{
	ASSERT(::IsWindow(m_hWnd));
#ifdef Edit_SetCueBannerTextFocused
	return Edit_SetCueBannerTextFocused(m_hWnd, lpszText, fDrawWhenFocused); // EM_SETCUEBANNER
#else
	(fDrawWhenFocused);
	return Edit_SetCueBannerText(m_hWnd, lpszText); // EM_SETCUEBANNER
#endif
}

AFX_INLINE BOOL CEdit::GetCueBanner(_Out_z_cap_(cchText) LPWSTR lpszText, _In_ int cchText) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lpszText != NULL);
	if (cchText == 0 || lpszText == NULL)
		return FALSE;

	lpszText[0] = L'\0';

	return Edit_GetCueBannerText(m_hWnd, lpszText, cchText); // EM_GETCUEBANNER
}

#ifdef UNICODE
AFX_INLINE CString CEdit::GetCueBanner() const
{
	ASSERT(::IsWindow(m_hWnd));
	LPTSTR lpszText=NULL;
	int cchText = 0;
	CString strOut;
	BOOL b = CWnd::EnlargeBufferGetText<BOOL>(FALSE, lpszText, cchText, EM_GETCUEBANNER, (WPARAM&)lpszText, (LPARAM&)cchText, strOut);
	if (b)
		return strOut;
	else
		return CString();
}

AFX_INLINE BOOL CEdit::ShowBalloonTip(_In_z_ LPCWSTR lpszTitle, _In_z_ LPCWSTR lpszText, _In_ INT ttiIcon)
{
	ASSERT(::IsWindow(m_hWnd));
	EDITBALLOONTIP bt;
	::ZeroMemory(&bt, sizeof(EDITBALLOONTIP));

	bt.cbStruct = sizeof(EDITBALLOONTIP);
	bt.pszTitle = lpszTitle;
	bt.pszText = lpszText;
	bt.ttiIcon = ttiIcon;
	
	return Edit_ShowBalloonTip(m_hWnd, &bt); // EM_SHOWBALLOONTIP
}

AFX_INLINE BOOL CEdit::ShowBalloonTip(_In_ PEDITBALLOONTIP pEditBalloonTip)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pEditBalloonTip != NULL);
	if (pEditBalloonTip == NULL)
	{
		return FALSE;
	}
	return Edit_ShowBalloonTip(m_hWnd, pEditBalloonTip); // EM_SHOWBALLOONTIP
}

AFX_INLINE BOOL CEdit::HideBalloonTip()
{
	ASSERT(::IsWindow(m_hWnd));
	return Edit_HideBalloonTip(m_hWnd); // EM_HIDEBALLOONTIP
}
#endif // (UNICODE)

#endif // (_WIN32_WINNT >= 0x0501)

#if ( _WIN32_WINNT >= 0x0600 ) && defined(UNICODE)

AFX_INLINE void CEdit::SetHighlight(_In_ int ichStart, _In_ int ichEnd)
{
	ASSERT(::IsWindow(m_hWnd));
	return Edit_SetHilite(m_hWnd, ichStart, ichEnd); // EM_SETHILITE
}

AFX_INLINE BOOL CEdit::GetHighlight(_Out_ int* pichStart, _Out_ int* pichEnd) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pichStart != NULL);
	ASSERT(pichEnd != NULL);
	if (pichStart == NULL || pichEnd == NULL)
		return FALSE;

	DWORD dwHighlight = Edit_GetHilite(m_hWnd); // EM_GETHILITE
	*pichStart = (int)LOWORD(dwHighlight);
	*pichEnd = (int)HIWORD(dwHighlight);
	return TRUE;
}

#endif  // (_WIN32_WINNT >= 0x0600) && defined(UNICODE)

#if (_WIN32_WINNT >= 0x501)

AFX_INLINE BOOL CButton::GetIdealSize(_Out_ SIZE* psize) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(psize != NULL);
	return Button_GetIdealSize(m_hWnd, psize); // BCM_GETIDEALSIZE
}

AFX_INLINE BOOL CButton::SetImageList(PBUTTON_IMAGELIST pbuttonImagelist)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pbuttonImagelist != NULL);
	return Button_SetImageList(m_hWnd, pbuttonImagelist); // BCM_SETIMAGELIST
}

AFX_INLINE BOOL CButton::GetImageList(PBUTTON_IMAGELIST pbuttonImagelist) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pbuttonImagelist != NULL);
	return Button_GetImageList(m_hWnd, pbuttonImagelist); // BCM_GETIMAGELIST
}

AFX_INLINE BOOL CButton::SetTextMargin(RECT* pmargin)
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pmargin != NULL);
	return Button_SetTextMargin(m_hWnd, pmargin); // BCM_SETTEXTMARGIN
}

AFX_INLINE BOOL CButton::GetTextMargin(RECT* pmargin) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(pmargin != NULL);
	return Button_GetTextMargin(m_hWnd, pmargin); // BCM_GETTEXTMARGIN
}

#endif	// _WIN32_WINNT >= 0x0501

#if ( _WIN32_WINNT >= 0x0600 ) && defined(UNICODE)

AFX_INLINE CString CButton::GetNote() const
{
	ASSERT(::IsWindow(m_hWnd));
	UINT nCount = 256;
	CString str;
	LPTSTR lpstr = str.GetBufferSetLength(nCount);
	if (lpstr == NULL)
	{
		AfxThrowMemoryException();
	}
	while((BOOL)Button_GetNote(m_hWnd, lpstr, &nCount) == FALSE)
	{
		if(GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			AfxThrowNotSupportedException();
		}
		lpstr = str.GetBufferSetLength(nCount);
		if (lpstr == NULL)
		{
			AfxThrowMemoryException();
		}
	}
	str.ReleaseBuffer();
	return str;
}

_Check_return_ AFX_INLINE BOOL CButton::GetNote(_Out_z_cap_(*pcchNote) LPTSTR lpszNote, _Inout_ UINT* pcchNote) const
{
	ASSERT(::IsWindow(m_hWnd));
	ASSERT(lpszNote != NULL);
	ASSERT(pcchNote != NULL);
	return Button_GetNote(m_hWnd, lpszNote, pcchNote); // BCM_GETNOTE
}

AFX_INLINE BOOL CButton::SetNote(_In_z_ LPCTSTR lpszNote)
{
	ASSERT(::IsWindow(m_hWnd));
	return Button_SetNote(m_hWnd, lpszNote); // BCM_SETNOTE
}

AFX_INLINE UINT CButton::GetNoteLength() const
{
	ASSERT(::IsWindow(m_hWnd));
	return (UINT)Button_GetNoteLength(m_hWnd); // BCM_GETNOTELENGTH
}

AFX_INLINE BOOL CButton::GetSplitInfo(_Out_ PBUTTON_SPLITINFO pInfo) const
{
	ASSERT(::IsWindow(m_hWnd));
	return Button_GetSplitInfo(m_hWnd, pInfo); // BCM_GETSPLITINFO
}

AFX_INLINE BOOL CButton::SetSplitInfo(_In_ PBUTTON_SPLITINFO pInfo)
{
	ASSERT(::IsWindow(m_hWnd));
	return Button_SetSplitInfo(m_hWnd, pInfo); // BCM_SETSPLITINFO
}

AFX_INLINE UINT CButton::GetSplitStyle() const
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_STYLE;
	Button_GetSplitInfo(m_hWnd, &buttonSplitInfo);
	return buttonSplitInfo.uSplitStyle;
}

AFX_INLINE BOOL CButton::SetSplitStyle(_In_ UINT nStyle)
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_STYLE;
	buttonSplitInfo.uSplitStyle = nStyle;
	return Button_SetSplitInfo(m_hWnd, &buttonSplitInfo);
}

AFX_INLINE BOOL CButton::GetSplitSize(_Out_ LPSIZE pSize) const
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_SIZE;
	BOOL fRet = Button_GetSplitInfo(m_hWnd, &buttonSplitInfo);
	pSize->cx = buttonSplitInfo.size.cx;
	pSize->cy = buttonSplitInfo.size.cy;
	return fRet;
}

AFX_INLINE BOOL CButton::SetSplitSize(_In_ LPSIZE pSize)
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_SIZE;
	buttonSplitInfo.size.cx = pSize->cx;
	buttonSplitInfo.size.cy = pSize->cy;
	return Button_SetSplitInfo(m_hWnd, &buttonSplitInfo);
}

AFX_INLINE CImageList* CButton::GetSplitImageList() const
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_IMAGE;
	Button_GetSplitInfo(m_hWnd, &buttonSplitInfo);
	return CImageList::FromHandle(buttonSplitInfo.himlGlyph);
}

AFX_INLINE BOOL CButton::SetSplitImageList(_In_ CImageList* pSplitImageList)
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_IMAGE;
	buttonSplitInfo.himlGlyph = pSplitImageList->GetSafeHandle();
	return Button_SetSplitInfo(m_hWnd, &buttonSplitInfo);
}

AFX_INLINE TCHAR CButton::GetSplitGlyph() const
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_GLYPH;
	Button_GetSplitInfo(m_hWnd, &buttonSplitInfo);
	return (WCHAR)buttonSplitInfo.himlGlyph;
}

AFX_INLINE BOOL CButton::SetSplitGlyph(_In_ TCHAR chGlyph)
{
	ASSERT(::IsWindow(m_hWnd));
	BUTTON_SPLITINFO buttonSplitInfo = {0};
	buttonSplitInfo.mask = BCSIF_GLYPH;
	buttonSplitInfo.himlGlyph = (HIMAGELIST)chGlyph;
	return Button_SetSplitInfo(m_hWnd, &buttonSplitInfo);
}

AFX_INLINE BOOL CButton::SetDropDownState(_In_ BOOL fDropDown)
{
	ASSERT(::IsWindow(m_hWnd));
	return Button_SetDropDownState(m_hWnd, fDropDown); // BCM_SETDROPDOWNSTATE
}

AFX_INLINE HICON CButton::SetShield(_In_ BOOL fElevationRequired)
{
	ASSERT(::IsWindow(m_hWnd));
	return (HICON)(Button_SetElevationRequiredState(m_hWnd, fElevationRequired)); // BCM_SETSHIELD
}

#endif // _WIN32_WINNT >= 0x600 && defined(UNICODE)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwindowsmanagerdialog.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxribbonres.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMDIFrameWndEx;

extern AFX_IMPORT_DATA UINT AFX_WM_WINDOW_HELP;

/////////////////////////////////////////////////////////////////////////////
// CMFCWindowsManagerDialog dialog

class CMFCWindowsManagerDialog : public CDialog
{
// Construction
public:
	CMFCWindowsManagerDialog(CMDIFrameWndEx* pMDIFrame, BOOL bHelpButton = FALSE);   // standard constructor

// Dialog Data
	enum { IDD = IDD_AFXBARRES_WINDOWS_DLG };
	CListBox m_wndList;

// Overrides
protected:
	virtual BOOL OnInitDialog();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Implementation
protected:
	void MDIMessage(UINT uMsg,WPARAM flag);
	void FillWindowList(void);
	void SelActive(void);
	void UpdateButtons(void);

	CMDIFrameWndEx* m_pMDIFrame;
	const BOOL          m_bHelpButton;
	BOOL                m_bMDIActions;
	CList<HWND,HWND>    m_lstCloseDisabled;
	CList<HWND,HWND>    m_lstSaveDisabled;

	//{{AFX_MSG(CMFCWindowsManagerDialog)
	afx_msg void OnActivate();
	afx_msg void OnSave();
	afx_msg void OnClose();
	afx_msg void OnCascade();
	afx_msg void OnTilehorz();
	afx_msg void OnTilevert();
	afx_msg void OnMinimize();
	afx_msg void OnSelchangeList();
	afx_msg void OnWindowHelp();
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwinappex.h ===
// This MFC Library source code supports the Microsoft Office Fluent User Interface 
// (the "Fluent UI") and is provided only as referential material to supplement the 
// Microsoft Foundation Classes Reference and related electronic documentation 
// included with the MFC C++ library software.  
// License terms to copy, use or distribute the Fluent UI are available separately.  
// To learn more about our Fluent UI licensing program, please visit 
// http://msdn.microsoft.com/officeui.
//
// Copyright (C) Microsoft Corporation
// All rights reserved.

#pragma once

#include "afxcontrolbarutil.h"
#include "afxusertool.h"

#ifdef _AFX_PACKING
#pragma pack(push, _AFX_PACKING)
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

class CMouseManager;
class CContextMenuManager;
class CKeyboardManager;
class CUserToolsManager;
class CFrameImpl;
class CMDIFrameWndEx;
class CFrameWndEx;
class COleIPFrameWndEx;
class CShellManager;
class CWinAppEx;
class CTooltipManager;

class CWinAppEx : public CWinApp
{
	friend class CMFCPopupMenu;
	friend class CMFCRibbonRecentFilesList;
	friend class CMFCTasksPane;
	friend class CMFCFileDialog;

	DECLARE_DYNAMIC(CWinAppEx)
public:
	CWinAppEx(BOOL bResourceSmartUpdate = TRUE);
	virtual ~CWinAppEx();

	virtual int ExitInstance();

	LPCTSTR SetRegistryBase(LPCTSTR lpszSectionName = NULL);
	LPCTSTR	GetRegistryBase() { return m_strRegSection; }

	// Saved data version:
	int GetDataVersionMajor() const { return m_iSavedVersionMajor; }
	int GetDataVersionMinor() const { return m_iSavedVersionMinor; }
	int GetDataVersion() const;

	BOOL InitMouseManager();
	BOOL InitContextMenuManager();
	BOOL InitKeyboardManager();
	BOOL InitShellManager();
	BOOL InitTooltipManager();

	BOOL EnableUserTools(const UINT uiCmdToolsDummy, const UINT uiCmdFirst, const UINT uiCmdLast,
		CRuntimeClass* pToolRTC = RUNTIME_CLASS(CUserTool), UINT uArgMenuID = 0, UINT uInitDirMenuID = 0);
	BOOL EnableTearOffMenus(LPCTSTR lpszRegEntry, const UINT uiCmdFirst, const UINT uiCmdLast);

	BOOL IsResourceSmartUpdate() const { return m_bResourceSmartUpdate; }
	void EnableLoadWindowPlacement(BOOL bEnable = TRUE) { m_bLoadWindowPlacement = bEnable; }

	CMouseManager* GetMouseManager();
	CContextMenuManager* GetContextMenuManager();
	CKeyboardManager* GetKeyboardManager();
	CUserToolsManager* GetUserToolsManager();
	CShellManager* GetShellManager();
	CTooltipManager* GetTooltipManager();

	// Call one of these in CMyApp::InitInstance just after ProcessShellCommand() and before pMainFrame->ShowWindow().
	BOOL LoadState(CMDIFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);
	BOOL LoadState(CFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);
	BOOL LoadState(COleIPFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);
	virtual BOOL LoadState(LPCTSTR lpszSectionName = NULL, CFrameImpl* pFrameImpl = NULL);

	virtual BOOL CleanState(LPCTSTR lpszSectionName = NULL);
	virtual BOOL SaveState(LPCTSTR lpszSectionName = NULL, CFrameImpl* pFrameImpl = NULL);

	BOOL SaveState(CMDIFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);
	BOOL SaveState(CFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);
	BOOL SaveState(COleIPFrameWndEx* pFrame, LPCTSTR lpszSectionName = NULL);

	BOOL IsStateExists(LPCTSTR lpszSectionName /*=NULL*/);

	virtual BOOL OnViewDoubleClick(CWnd* pWnd, int iViewId);
	virtual BOOL ShowPopupMenu(UINT uiMenuResId, const CPoint& point, CWnd* pWnd);

	CString GetRegSectionPath(LPCTSTR szSectionAdd = _T(""));

	// These functions load and store values from the "Custom" subkey
	// To use subkeys of the "Custom" subkey use GetSectionInt() etc. instead
	int GetInt(LPCTSTR lpszEntry, int nDefault = 0);
	CString GetString(LPCTSTR lpszEntry, LPCTSTR lpzDefault = _T(""));
	BOOL GetBinary(LPCTSTR lpszEntry, LPBYTE* ppData, UINT* pBytes);
	BOOL GetObject(LPCTSTR lpszEntry, CObject& obj);
	BOOL WriteInt(LPCTSTR lpszEntry, int nValue );
	BOOL WriteString(LPCTSTR lpszEntry, LPCTSTR lpszValue );
	BOOL WriteBinary(LPCTSTR lpszEntry, LPBYTE pData, UINT nBytes);
	BOOL WriteObject(LPCTSTR lpszEntry, CObject& obj);

	// These functions load and store values from a given subkey
	// of the "Custom" subkey. For simpler access you may use GetInt() etc.
	int GetSectionInt( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, int nDefault = 0);
	CString GetSectionString( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPCTSTR lpszDefault = _T(""));
	BOOL GetSectionBinary(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPBYTE* ppData, UINT* pBytes);
	BOOL GetSectionObject(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, CObject& obj);
	BOOL WriteSectionInt( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, int nValue );
	BOOL WriteSectionString( LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPCTSTR lpszValue );
	BOOL WriteSectionBinary(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, LPBYTE pData, UINT nBytes);
	BOOL WriteSectionObject(LPCTSTR lpszSubSection, LPCTSTR lpszEntry, CObject& obj);

	// WinHelp override:
	virtual void OnAppContextHelp(CWnd* pWndControl, const DWORD dwHelpIDArray []);

	// Idle processing override:
	virtual BOOL OnWorkspaceIdle(CWnd* /*pWnd*/) { return FALSE; }

public:
	BOOL m_bLoadUserToolbars;

protected:
	friend class CFrameImpl;

	// Overidables for customization
	virtual void OnClosingMainFrame(CFrameImpl* pFrameImpl);
	
	virtual void PreLoadState() {}    // called before anything is loaded
	virtual void LoadCustomState() {} // called after everything is loaded
	virtual void PreSaveState() {}    // called before anything is saved
	virtual void SaveCustomState() {} // called after everything is saved

	virtual BOOL LoadWindowPlacement(CRect& rectNormalPosition, int& nFflags, int& nShowCmd);
	virtual BOOL StoreWindowPlacement(const CRect& rectNormalPosition, int nFflags, int nShowCmd);
	virtual BOOL ReloadWindowPlacement(CFrameWnd* pFrame);

protected:
	CString m_strRegSection;

	BOOL m_bKeyboardManagerAutocreated;
	BOOL m_bContextMenuManagerAutocreated;
	BOOL m_bMouseManagerAutocreated;
	BOOL m_bUserToolsManagerAutoCreated;
	BOOL m_bTearOffManagerAutoCreated;
	BOOL m_bShellManagerAutocreated;
	BOOL m_bTooltipManagerAutocreated;
	BOOL m_bForceDockStateLoad; // Load dock bars state even it's not valid
	BOOL m_bLoadSaveFrameBarsOnly;
	BOOL m_bSaveState;          // Automatically save state when the main frame is closed.
	BOOL m_bForceImageReset;    // Force image reset every time when the frame is loaded
	BOOL m_bLoadWindowPlacement;

	const BOOL m_bResourceSmartUpdate; // Automatic toolbars/menu resource update

	int m_iSavedVersionMajor;
	int m_iSavedVersionMinor;
};

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#ifdef _AFX_PACKING
#pragma pack(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwin1.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 1)

#pragma once

#ifdef _AFXWIN_INLINE

// Global helper functions
_AFXWIN_INLINE CWinApp* AFXAPI AfxGetApp()
	{ return afxCurrentWinApp; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetInstanceHandle()
	{ ASSERT(afxCurrentInstanceHandle != NULL);
		return afxCurrentInstanceHandle; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()
	{ ASSERT(afxCurrentResourceHandle != NULL);
		return afxCurrentResourceHandle; }
_AFXWIN_INLINE void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource)
	{ ASSERT(hInstResource != NULL); afxCurrentResourceHandle = hInstResource; }
_AFXWIN_INLINE LPCTSTR AFXAPI AfxGetAppName()
	{ ASSERT(afxCurrentAppName != NULL); return afxCurrentAppName; }
_AFXWIN_INLINE COleMessageFilter* AFXAPI AfxOleGetMessageFilter()
	{ ASSERT_VALID(AfxGetThread()); return AfxGetThread()->m_pMessageFilter; }
_AFXWIN_INLINE CWnd* AFXAPI AfxGetMainWnd()
	{ CWinThread* pThread = AfxGetThread();
		return pThread != NULL ? pThread->GetMainWnd() : NULL; }

_AFXWIN_INLINE BOOL AFXAPI AfxGetAmbientActCtx()
	{ 	return afxAmbientActCtx; }
_AFXWIN_INLINE void AFXAPI AfxSetAmbientActCtx(BOOL bSet)
	{  afxAmbientActCtx = bSet; }

// CArchive output helpers
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, SIZE size)
	{ ar.Write(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, POINT point)
	{ ar.Write(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect)
	{ ar.Write(&rect, sizeof(RECT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size)
	{ ar.EnsureRead(&size, sizeof(SIZE)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, POINT& point)
	{ ar.EnsureRead(&point, sizeof(POINT)); return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect)
	{ ar.EnsureRead(&rect, sizeof(RECT)); return ar; }

// exception support
_AFXWIN_INLINE CResourceException::CResourceException()
	: CSimpleException() { }
_AFXWIN_INLINE CResourceException::CResourceException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CResourceException::~CResourceException()
	{ }
_AFXWIN_INLINE CUserException::CUserException()
	: CSimpleException() { }
_AFXWIN_INLINE CUserException::CUserException(BOOL bAutoDelete, UINT nResourceID)
	: CSimpleException(bAutoDelete) { m_nResourceID = nResourceID; }
_AFXWIN_INLINE CUserException::~CUserException()
	{ }

// CGdiObject
_AFXWIN_INLINE CGdiObject::operator HGDIOBJ() const
	{ return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE HGDIOBJ CGdiObject::GetSafeHandle() const
	{ return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE CGdiObject::CGdiObject()
	{ m_hObject = NULL; }
_AFXWIN_INLINE CGdiObject::~CGdiObject()
{
    AFX_BEGIN_DESTRUCTOR

        DeleteObject(); 

    AFX_END_DESTRUCTOR
}

_AFXWIN_INLINE int CGdiObject::_AFX_FUNCNAME(GetObject)(int nCount, LPVOID lpObject) const
	{ ASSERT(m_hObject != NULL); return ::GetObject(m_hObject, nCount, lpObject); }
#pragma push_macro("GetObject")
#undef GetObject
_AFXWIN_INLINE int CGdiObject::GetObject(int nCount, LPVOID lpObject) const
	{ return _AFX_FUNCNAME(GetObject)(nCount, lpObject); }
#pragma pop_macro("GetObject")
_AFXWIN_INLINE BOOL CGdiObject::CreateStockObject(int nIndex)
	{ return (m_hObject = ::GetStockObject(nIndex)) != NULL; }
_AFXWIN_INLINE BOOL CGdiObject::UnrealizeObject()
	{ ASSERT(m_hObject != NULL); return ::UnrealizeObject(m_hObject); }
_AFXWIN_INLINE UINT CGdiObject::GetObjectType() const
	{ return (UINT)::GetObjectType(m_hObject); }
_AFXWIN_INLINE BOOL CGdiObject::operator==(const CGdiObject& obj) const
	{ return ((HGDIOBJ) obj) == m_hObject; }
_AFXWIN_INLINE BOOL CGdiObject::operator!=(const CGdiObject& obj) const
	{ return ((HGDIOBJ) obj) != m_hObject; }

// CPen
_AFXWIN_INLINE CPen::operator HPEN() const
	{ return (HPEN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPen* PASCAL CPen::FromHandle(HPEN hPen)
	{ return (CPen*) CGdiObject::FromHandle(hPen); }
_AFXWIN_INLINE CPen::CPen()
	{ }
_AFXWIN_INLINE CPen::~CPen()
	{ }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{ return Attach(::CreatePen(nPenStyle, nWidth, crColor)); }
_AFXWIN_INLINE BOOL CPen::CreatePenIndirect(LPLOGPEN lpLogPen)
	{ return Attach(::CreatePenIndirect(lpLogPen)); }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush,
		int nStyleCount, const DWORD* lpStyle)
	{ return Attach(::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount,
		lpStyle)); }
_AFXWIN_INLINE int CPen::GetExtLogPen(EXTLOGPEN* pLogPen)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(EXTLOGPEN), pLogPen); }
_AFXWIN_INLINE int CPen::GetLogPen(LOGPEN* pLogPen)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGPEN), pLogPen); }

// CBrush
_AFXWIN_INLINE CBrush::operator HBRUSH() const
	{ return (HBRUSH)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBrush* PASCAL CBrush::FromHandle(HBRUSH hBrush)
	{ return (CBrush*) CGdiObject::FromHandle(hBrush); }
_AFXWIN_INLINE CBrush::CBrush()
	{ }
_AFXWIN_INLINE CBrush::~CBrush()
	{ }
_AFXWIN_INLINE BOOL CBrush::CreateSolidBrush(COLORREF crColor)
	{ return Attach(::CreateSolidBrush(crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateHatchBrush(int nIndex, COLORREF crColor)
	{ return Attach(::CreateHatchBrush(nIndex, crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{ return Attach(::CreateBrushIndirect(lpLogBrush)); }
_AFXWIN_INLINE BOOL CBrush::CreatePatternBrush(CBitmap* pBitmap)
	{ return Attach(::CreatePatternBrush((HBITMAP)pBitmap->GetSafeHandle())); }
_AFXWIN_INLINE BOOL CBrush::CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{ return Attach(::CreateDIBPatternBrushPt(lpPackedDIB, nUsage)); }
_AFXWIN_INLINE BOOL CBrush::CreateSysColorBrush(int nIndex)
	{ return Attach(::GetSysColorBrush(nIndex)); }
_AFXWIN_INLINE int CBrush::GetLogBrush(LOGBRUSH* pLogBrush)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGBRUSH), pLogBrush); }

// CFont
_AFXWIN_INLINE CFont::operator HFONT() const
	{ return (HFONT)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CFont* PASCAL CFont::FromHandle(HFONT hFont)
	{ return (CFont*) CGdiObject::FromHandle(hFont); }
_AFXWIN_INLINE CFont::CFont()
	{ }
_AFXWIN_INLINE CFont::~CFont()
	{ }
_AFXWIN_INLINE BOOL CFont::CreateFontIndirect(const LOGFONT* lpLogFont)
	{ return Attach(::CreateFontIndirect(lpLogFont)); }
_AFXWIN_INLINE BOOL CFont::CreateFont(int nHeight, int nWidth, int nEscapement,
		int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
		BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
		BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
		LPCTSTR lpszFacename)
	{ return Attach(::CreateFont(nHeight, nWidth, nEscapement,
		nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
		nCharSet, nOutPrecision, nClipPrecision, nQuality,
		nPitchAndFamily, lpszFacename)); }
_AFXWIN_INLINE int CFont::GetLogFont(LOGFONT* pLogFont)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(LOGFONT), pLogFont); }

// CBitmap
_AFXWIN_INLINE CBitmap::operator HBITMAP() const
	{ return (HBITMAP)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CBitmap* PASCAL CBitmap::FromHandle(HBITMAP hBitmap)
	{ return (CBitmap*) CGdiObject::FromHandle(hBitmap); }
_AFXWIN_INLINE CBitmap::CBitmap()
	{ }
_AFXWIN_INLINE CBitmap::~CBitmap()
	{ }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmap(int nWidth, int nHeight, UINT nPlanes,
	 UINT nBitcount, const void* lpBits)
	{ return Attach(::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits)); }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmapIndirect(LPBITMAP lpBitmap)
	{ return Attach(::CreateBitmapIndirect(lpBitmap)); }

_AFXWIN_INLINE DWORD CBitmap::SetBitmapBits(DWORD dwCount, const void* lpBits)
	{ return ::SetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE DWORD CBitmap::GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{ return ::GetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(LPCTSTR lpszResourceName)
	{ return Attach(::LoadBitmap(AfxFindResourceHandle(
		lpszResourceName, RT_BITMAP), lpszResourceName));}
#ifndef _AFX_NO_AFXCMN_SUPPORT
_AFXWIN_INLINE BOOL CBitmap::LoadMappedBitmap(UINT nIDBitmap, UINT nFlags,
	LPCOLORMAP lpColorMap, int nMapSize)
	{ return Attach(::AfxCreateMappedBitmap(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDBitmap), RT_BITMAP), nIDBitmap, (WORD)nFlags,
		lpColorMap, nMapSize)); }
#endif
_AFXWIN_INLINE CSize CBitmap::SetBitmapDimension(int nWidth, int nHeight)
	{
		SIZE size;
		VERIFY(::SetBitmapDimensionEx((HBITMAP)m_hObject, nWidth, nHeight, &size));
		return size;
	}
_AFXWIN_INLINE CSize CBitmap::GetBitmapDimension() const
	{
		SIZE size;
		VERIFY(::GetBitmapDimensionEx((HBITMAP)m_hObject, &size));
		return size;
	}

_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(UINT nIDResource)
	{ return Attach(::LoadBitmapW(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDResource), RT_BITMAP), MAKEINTRESOURCEW(nIDResource))); }
_AFXWIN_INLINE BOOL CBitmap::LoadOEMBitmap(UINT nIDBitmap)
	{ return Attach(::LoadBitmapW(NULL, MAKEINTRESOURCEW(nIDBitmap))); }
_AFXWIN_INLINE BOOL CBitmap::CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateCompatibleBitmap(pDC->m_hDC, nWidth, nHeight)); }
_AFXWIN_INLINE BOOL CBitmap::CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateDiscardableBitmap(pDC->m_hDC, nWidth, nHeight)); }
_AFXWIN_INLINE int CBitmap::GetBitmap(BITMAP* pBitMap)
	{ ASSERT(m_hObject != NULL);
		return ::GetObject(m_hObject, sizeof(BITMAP), pBitMap); }

// CPalette
_AFXWIN_INLINE CPalette::operator HPALETTE() const
	{ return (HPALETTE)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CPalette* PASCAL CPalette::FromHandle(HPALETTE hPalette)
	{ return (CPalette*) CGdiObject::FromHandle(hPalette); }
_AFXWIN_INLINE CPalette::CPalette()
	{ }
_AFXWIN_INLINE CPalette::~CPalette()
	{ }
_AFXWIN_INLINE BOOL CPalette::CreatePalette(LPLOGPALETTE lpLogPalette)
	{ return Attach(::CreatePalette(lpLogPalette)); }
_AFXWIN_INLINE BOOL CPalette::CreateHalftonePalette(CDC* pDC)
	{ ASSERT(pDC != NULL && pDC->m_hDC != NULL); return Attach(
		::CreateHalftonePalette(pDC->m_hDC)); }
_AFXWIN_INLINE UINT CPalette::GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors) const
	{ ASSERT(m_hObject != NULL); return ::GetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ ASSERT(m_hObject != NULL); return ::SetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE void CPalette::AnimatePalette(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ ASSERT(m_hObject != NULL); ::AnimatePalette((HPALETTE)m_hObject, nStartIndex, nNumEntries,
			lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::GetNearestPaletteIndex(COLORREF crColor) const
	{ ASSERT(m_hObject != NULL); return ::GetNearestPaletteIndex((HPALETTE)m_hObject, crColor); }
_AFXWIN_INLINE BOOL CPalette::ResizePalette(UINT nNumEntries)
	{ ASSERT(m_hObject != NULL); return ::ResizePalette((HPALETTE)m_hObject, nNumEntries); }
_AFXWIN_INLINE int CPalette::GetEntryCount()
	{ ASSERT(m_hObject != NULL); WORD nEntries;
		 ::GetObject(m_hObject, sizeof(WORD), &nEntries); return (int)nEntries; }

// CRgn
_AFXWIN_INLINE CRgn::operator HRGN() const
	{ return (HRGN)(this == NULL ? NULL : m_hObject); }
_AFXWIN_INLINE CRgn* PASCAL CRgn::FromHandle(HRGN hRgn)
	{ return (CRgn*) CGdiObject::FromHandle(hRgn); }
_AFXWIN_INLINE CRgn::CRgn()
	{ }
_AFXWIN_INLINE CRgn::~CRgn()
	{ }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateRectRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateEllipticRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateEllipticRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{ return Attach(::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode)); }
_AFXWIN_INLINE BOOL CRgn::CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{ return Attach(::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3)); }
_AFXWIN_INLINE BOOL CRgn::CreateFromPath(CDC* pDC)
	{ ASSERT(pDC != NULL); return Attach(::PathToRegion(pDC->m_hDC)); }
_AFXWIN_INLINE BOOL CRgn::CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{ return Attach(::ExtCreateRegion(lpXForm, nCount, pRgnData)); }
_AFXWIN_INLINE int CRgn::GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{ ASSERT(m_hObject != NULL); return (int)::GetRegionData((HRGN)m_hObject, nDataSize, lpRgnData); }
_AFXWIN_INLINE void CRgn::SetRectRgn(int x1, int y1, int x2, int y2)
	{ ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRgn::SetRectRgn(LPCRECT lpRect)
	{ ASSERT(m_hObject != NULL); ::SetRectRgn((HRGN)m_hObject, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE int CRgn::CombineRgn(const CRgn* pRgn1, const CRgn* pRgn2, int nCombineMode)
	{ ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgn1->GetSafeHandle(),
		(HRGN)pRgn2->GetSafeHandle(), nCombineMode); }
_AFXWIN_INLINE int CRgn::CopyRgn(const CRgn* pRgnSrc)
	{ ASSERT(m_hObject != NULL); return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgnSrc->GetSafeHandle(), NULL, RGN_COPY); }
_AFXWIN_INLINE BOOL CRgn::EqualRgn(const CRgn* pRgn) const
	{ ASSERT(m_hObject != NULL); return ::EqualRgn((HRGN)m_hObject, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE int CRgn::OffsetRgn(int x, int y)
	{ ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE int CRgn::OffsetRgn(POINT point)
	{ ASSERT(m_hObject != NULL); return ::OffsetRgn((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE int CRgn::GetRgnBox(LPRECT lpRect) const
	{ ASSERT(m_hObject != NULL); return ::GetRgnBox((HRGN)m_hObject, lpRect); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(int x, int y) const
	{ ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(POINT point) const
	{ ASSERT(m_hObject != NULL); return ::PtInRegion((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE BOOL CRgn::RectInRegion(LPCRECT lpRect) const
	{ ASSERT(m_hObject != NULL); return ::RectInRegion((HRGN)m_hObject, lpRect); }

// CDC
_AFXWIN_INLINE CDC::operator HDC() const
	{ return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE HDC CDC::GetSafeHdc() const
	{ return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE CWnd* CDC::GetWindow() const
	{ ASSERT(m_hDC != NULL); return CWnd::FromHandle(::WindowFromDC(m_hDC)); }
_AFXWIN_INLINE BOOL CDC::IsPrinting() const
	{ return m_bPrinting; }
_AFXWIN_INLINE BOOL CDC::CreateDC(LPCTSTR lpszDriverName,
	LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
	{ return Attach(::CreateDC(lpszDriverName,
		lpszDeviceName, lpszOutput, (const DEVMODE*)lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateIC(LPCTSTR lpszDriverName,
	LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const void* lpInitData)
	{ return Attach(::CreateIC(lpszDriverName,
		lpszDeviceName, lpszOutput, (const DEVMODE*) lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateCompatibleDC(CDC* pDC)
	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }
_AFXWIN_INLINE int CDC::ExcludeUpdateRgn(CWnd* pWnd)
	{ ASSERT(m_hDC != NULL); return ::ExcludeUpdateRgn(m_hDC, pWnd->m_hWnd); }
_AFXWIN_INLINE int CDC::GetDeviceCaps(int nIndex) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetDeviceCaps(m_hAttribDC, nIndex); }
_AFXWIN_INLINE CPoint CDC::GetBrushOrg() const
	{
		ASSERT(m_hDC != NULL);
		POINT point;
		VERIFY(::GetBrushOrgEx(m_hDC, &point));
		return point;
	}
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(int x, int y)
	{
		ASSERT(m_hDC != NULL);
		POINT point;
		VERIFY(::SetBrushOrgEx(m_hDC, x, y, &point));
		return point;
	}
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(POINT point)
	{
		ASSERT(m_hDC != NULL);
		VERIFY(::SetBrushOrgEx(m_hDC, point.x, point.y, &point));
		return point;
	}

_AFXWIN_INLINE int CDC::EnumObjects(int nObjectType,
		int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{ ASSERT(m_hAttribDC != NULL); return ::EnumObjects(m_hAttribDC, nObjectType, (GOBJENUMPROC)lpfn, lpData); }

_AFXWIN_INLINE CBitmap* CDC::SelectObject(CBitmap* pBitmap)
	{ ASSERT(m_hDC != NULL); return (CBitmap*) SelectGdiObject(m_hDC, pBitmap->GetSafeHandle()); }
_AFXWIN_INLINE CGdiObject* CDC::SelectObject(CGdiObject* pObject)
	{ ASSERT(m_hDC != NULL); return SelectGdiObject(m_hDC, pObject->GetSafeHandle()); }
_AFXWIN_INLINE HGDIOBJ CDC::SelectObject(HGDIOBJ hObject) // Safe for NULL handles
	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object
		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }
_AFXWIN_INLINE COLORREF CDC::GetNearestColor(COLORREF crColor) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetNearestColor(m_hAttribDC, crColor); }
_AFXWIN_INLINE UINT CDC::RealizePalette()
	{ ASSERT(m_hDC != NULL); return ::RealizePalette(m_hDC); }
_AFXWIN_INLINE void CDC::UpdateColors()
	{ ASSERT(m_hDC != NULL); ::UpdateColors(m_hDC); }
_AFXWIN_INLINE COLORREF CDC::GetBkColor() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetBkColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetBkMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetBkMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetPolyFillMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetPolyFillMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetROP2() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetROP2(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetStretchBltMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetStretchBltMode(m_hAttribDC); }
_AFXWIN_INLINE COLORREF CDC::GetTextColor() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetMapMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetMapMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetGraphicsMode() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetGraphicsMode(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetWorldTransform(XFORM* pXform) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetWorldTransform(m_hAttribDC,pXform); }

_AFXWIN_INLINE CPoint CDC::GetViewportOrg() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(::GetViewportOrgEx(m_hAttribDC, &point));
		return point;
	}
_AFXWIN_INLINE CSize CDC::GetViewportExt() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetViewportExtEx(m_hAttribDC, &size));
		return size;
	}
_AFXWIN_INLINE CPoint CDC::GetWindowOrg() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(::GetWindowOrgEx(m_hAttribDC, &point));
		return point;
	}
_AFXWIN_INLINE CSize CDC::GetWindowExt() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetWindowExtEx(m_hAttribDC, &size));
		return size;
	}

// non-virtual helpers calling virtual mapping functions
_AFXWIN_INLINE CPoint CDC::SetViewportOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetViewportOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetViewportExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetViewportExt(size.cx, size.cy); }
_AFXWIN_INLINE CPoint CDC::SetWindowOrg(POINT point)
	{ ASSERT(m_hDC != NULL); return SetWindowOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetWindowExt(SIZE size)
	{ ASSERT(m_hDC != NULL); return SetWindowExt(size.cx, size.cy); }

_AFXWIN_INLINE void CDC::DPtoLP(LPPOINT lpPoints, int nCount) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(::DPtoLP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::DPtoLP(LPRECT lpRect) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(::DPtoLP(m_hAttribDC, (LPPOINT)lpRect, 2)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPPOINT lpPoints, int nCount) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(::LPtoDP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPRECT lpRect) const
	{ ASSERT(m_hAttribDC != NULL); VERIFY(::LPtoDP(m_hAttribDC, (LPPOINT)lpRect, 2)); }

_AFXWIN_INLINE BOOL CDC::FillRgn(CRgn* pRgn, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::FillRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight)
	{ ASSERT(m_hDC != NULL); return ::FrameRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle(),
		nWidth, nHeight); }
_AFXWIN_INLINE BOOL CDC::InvertRgn(CRgn* pRgn)
	{ ASSERT(m_hDC != NULL); return ::InvertRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PaintRgn(CRgn* pRgn)
	{ ASSERT(m_hDC != NULL); return ::PaintRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PtVisible(int x, int y) const
	{ ASSERT(m_hDC != NULL); return ::PtVisible(m_hDC, x, y); }
_AFXWIN_INLINE BOOL CDC::PtVisible(POINT point) const
	{ ASSERT(m_hDC != NULL); return PtVisible(point.x, point.y); } // call virtual
_AFXWIN_INLINE BOOL CDC::RectVisible(LPCRECT lpRect) const
	{ ASSERT(m_hDC != NULL); return ::RectVisible(m_hDC, lpRect); }
_AFXWIN_INLINE CPoint CDC::GetCurrentPosition() const
	{
		ASSERT(m_hAttribDC != NULL);
		POINT point;
		VERIFY(::GetCurrentPositionEx(m_hAttribDC, &point));
		return point;
	}

_AFXWIN_INLINE CPoint CDC::MoveTo(POINT point)
	{ ASSERT(m_hDC != NULL); return MoveTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::LineTo(POINT point)
	{ ASSERT(m_hDC != NULL); return LineTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Arc(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polyline(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::Polyline(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE void CDC::FillRect(LPCRECT lpRect, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); ::FillRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::FrameRect(LPCRECT lpRect, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); ::FrameRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::InvertRect(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); ::InvertRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(int x, int y, HICON hIcon)
	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, x, y, hIcon); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(POINT point, HICON hIcon)
	{ ASSERT(m_hDC != NULL); return ::DrawIcon(m_hDC, point.x, point.y, hIcon); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, CBitmap* pBitmap, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		NULL, (LPARAM)pBitmap->GetSafeHandle(), 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_BITMAP); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush, NULL,
		(LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, HICON hIcon, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(), NULL,
		(LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_ICON); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText, int nTextLen, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags|(bPrefixText ? DST_PREFIXTEXT : DST_TEXT)); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, hBrush,
		lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
_AFXWIN_INLINE BOOL CDC::DrawState(CPoint pt, CSize size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, CBrush* pBrush)
	{ ASSERT(m_hDC != NULL); return ::DrawState(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags|DST_COMPLEX); }
_AFXWIN_INLINE BOOL CDC::DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{ ASSERT(m_hDC != NULL); return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags); }
_AFXWIN_INLINE BOOL CDC::DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{ ASSERT(m_hDC != NULL); return ::DrawFrameControl(m_hDC, lpRect, nType, nState); }

_AFXWIN_INLINE BOOL CDC::Chord(int x1, int y1, int x2, int y2, int x3, int y3,
	int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Chord(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE void CDC::DrawFocusRect(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); ::DrawFocusRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::Ellipse(int x1, int y1, int x2, int y2)
	{ ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Ellipse(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); return ::Ellipse(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ ASSERT(m_hDC != NULL); return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ::Pie(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polygon(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::Polygon(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::PolyPolygon(const POINT* lpPoints, const INT* lpPolyCounts, int nCount)
	{ ASSERT(m_hDC != NULL); return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount); }
_AFXWIN_INLINE BOOL CDC::Rectangle(int x1, int y1, int x2, int y2)
	{ ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Rectangle(LPCRECT lpRect)
	{ ASSERT(m_hDC != NULL); return ::Rectangle(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{ ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3); }
_AFXWIN_INLINE BOOL CDC::RoundRect(LPCRECT lpRect, POINT point)
	{ ASSERT(m_hDC != NULL); return ::RoundRect(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop); }
_AFXWIN_INLINE BOOL CDC::BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::BitBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }
_AFXWIN_INLINE BOOL CDC::StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::StretchBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, nSrcHeight,
		dwRop); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(int x, int y) const
	{ ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, x, y); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(POINT point) const
	{ ASSERT(m_hDC != NULL); return ::GetPixel(m_hDC, point.x, point.y); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, x, y, crColor); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(POINT point, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixel(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::FloodFill(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::FloodFill(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{ ASSERT(m_hDC != NULL); return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, LPCTSTR lpszString, int nCount)
	{ ASSERT(m_hDC != NULL); return ::TextOut(m_hDC, x, y, lpszString, nCount); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, const CString& str)
	{ ASSERT(m_hDC != NULL); return TextOut(x, y, (LPCTSTR)str, (int)str.GetLength()); } // call virtual
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	LPCTSTR lpszString, UINT nCount, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		lpszString, nCount, lpDxWidths); }
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	const CString& str, LPINT lpDxWidths)
	{ ASSERT(m_hDC != NULL); return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		str, (UINT)str.GetLength(), lpDxWidths); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, lpszString, nCount,
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, const CString& str,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ ASSERT(m_hDC != NULL); return ::TabbedTextOut(m_hDC, x, y, str, (int)str.GetLength(),
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawText)(LPCTSTR lpszString, int nCount, LPRECT lpRect,
		UINT nFormat)
	{ ASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawText)(const CString& str, LPRECT lpRect, UINT nFormat)
	{ ASSERT(m_hDC != NULL);
		// these flags would modify the string
		ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
		ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
		return _AFX_FUNCNAME(DrawText)((LPCTSTR)str, (int)str.GetLength(), lpRect, nFormat); }

_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawTextEx)(LPTSTR lpszString, int nCount, LPRECT lpRect,
		UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		return ::DrawTextEx(m_hDC, lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXWIN_INLINE int CDC::_AFX_FUNCNAME(DrawTextEx)(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ ASSERT(m_hDC != NULL);
		// these flags would modify the string
		ASSERT((nFormat & (DT_END_ELLIPSIS | DT_MODIFYSTRING)) != (DT_END_ELLIPSIS | DT_MODIFYSTRING));
		ASSERT((nFormat & (DT_PATH_ELLIPSIS | DT_MODIFYSTRING)) != (DT_PATH_ELLIPSIS | DT_MODIFYSTRING));
		return _AFX_FUNCNAME(DrawTextEx)(const_cast<LPTSTR>((LPCTSTR)str), (int)str.GetLength(), lpRect, nFormat, lpDTParams); }

#pragma push_macro("DrawText")
#pragma push_macro("DrawTextEx")
#undef DrawText
#undef DrawTextEx
_AFXWIN_INLINE int CDC::DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::DrawText(const CString& str, LPRECT lpRect, UINT nFormat)
	{ return _AFX_FUNCNAME(DrawText)(str, lpRect, nFormat); }
_AFXWIN_INLINE int CDC::DrawTextEx(LPTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(lpszString, nCount, lpRect, nFormat, lpDTParams); }
_AFXWIN_INLINE int CDC::DrawTextEx(const CString& str, LPRECT lpRect, UINT nFormat, LPDRAWTEXTPARAMS lpDTParams)
	{ return _AFX_FUNCNAME(DrawTextEx)(str, lpRect, nFormat, lpDTParams); }
#pragma pop_macro("DrawText")
#pragma pop_macro("DrawTextEx")

_AFXWIN_INLINE CSize CDC::GetTextExtent(LPCTSTR lpszString, int nCount) const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hAttribDC, lpszString, nCount, &size));
		return size;
	}
_AFXWIN_INLINE CSize CDC::GetTextExtent(const CString& str) const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hAttribDC, str, (int)str.GetLength(), &size));
		return size;
	}

_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(LPCTSTR lpszString, int nCount) const
	{
		ASSERT(m_hDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hDC, lpszString, nCount, &size));
		return size;
	}
_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(const CString& str) const
	{
		ASSERT(m_hDC != NULL);
		SIZE size;
		VERIFY(::GetTextExtentPoint32(m_hDC, str, (int)str.GetLength(), &size));
		return size;
	}

_AFXWIN_INLINE CSize CDC::GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTabbedTextExtent(m_hAttribDC,
		str, (int)str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE CSize CDC::GetOutputTabbedTextExtent(LPCTSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE  CSize CDC::GetOutputTabbedTextExtent(const CString& str,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{ ASSERT(m_hDC != NULL); return ::GetTabbedTextExtent(m_hDC,
		str, (int)str.GetLength(), nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE BOOL CDC::GrayString(CBrush* pBrush,
	BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int),
		LPARAM lpData, int nCount,
		int x, int y, int nWidth, int nHeight)
	{ ASSERT(m_hDC != NULL); return ::GrayString(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		(GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight); }
_AFXWIN_INLINE UINT CDC::GetTextAlign() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextAlign(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetTextFace(_In_ int nCount, _Out_z_cap_post_count_(nCount, return) LPTSTR lpszFacename) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextFace(m_hAttribDC, nCount, lpszFacename); }
_AFXWIN_INLINE  int CDC::GetTextFace(CString& rString) const
	{ ASSERT(m_hAttribDC != NULL); int nResult = ::GetTextFace(m_hAttribDC,
		256, rString.GetBuffer(256)); rString.ReleaseBuffer();
		return nResult; }
_AFXWIN_INLINE BOOL CDC::_AFX_FUNCNAME(GetTextMetrics)(LPTEXTMETRIC lpMetrics) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextMetrics(m_hAttribDC, lpMetrics); }
#pragma push_macro("GetTextMetrics")
#undef GetTextMetrics
_AFXWIN_INLINE BOOL CDC::GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ return _AFX_FUNCNAME(GetTextMetrics)(lpMetrics); }
#pragma pop_macro("GetTextMetrics")
_AFXWIN_INLINE BOOL CDC::GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ ASSERT(m_hDC != NULL); return ::GetTextMetrics(m_hDC, lpMetrics); }
_AFXWIN_INLINE int CDC::GetTextCharacterExtra() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetTextCharacterExtra(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharWidth(m_hAttribDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE BOOL CDC::GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ ASSERT(m_hDC != NULL); return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE DWORD CDC::GetFontLanguageInfo() const
	{ ASSERT(m_hDC != NULL); return ::GetFontLanguageInfo(m_hDC); }

_AFXWIN_INLINE DWORD CDC::GetCharacterPlacement(LPCTSTR lpString, int nCount, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const
	{ ASSERT(m_hDC != NULL); return ::GetCharacterPlacement(m_hDC, lpString, nCount, nMaxExtent, lpResults, dwFlags); }
_AFXWIN_INLINE DWORD CDC::GetCharacterPlacement(CString& str, int nMaxExtent, LPGCP_RESULTS lpResults, DWORD dwFlags) const
	{ ASSERT(m_hDC != NULL); return ::GetCharacterPlacement(m_hDC, (LPCTSTR)str, str.GetLength(), nMaxExtent, lpResults, dwFlags); }


_AFXWIN_INLINE CSize CDC::GetAspectRatioFilter() const
	{
		ASSERT(m_hAttribDC != NULL);
		SIZE size;
		VERIFY(::GetAspectRatioFilterEx(m_hAttribDC, &size));
		return size;
	}
_AFXWIN_INLINE BOOL CDC::ScrollDC(int dx, int dy,
		LPCRECT lpRectScroll, LPCRECT lpRectClip,
		CRgn* pRgnUpdate, LPRECT lpRectUpdate)
	{ ASSERT(m_hDC != NULL); return ::ScrollDC(m_hDC, dx, dy, lpRectScroll,
		lpRectClip, (HRGN)pRgnUpdate->GetSafeHandle(), lpRectUpdate); }

// Printer Escape Functions
_AFXWIN_INLINE int CDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{ ASSERT(m_hDC != NULL); return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);}

// CDC 3.1 Specific functions
_AFXWIN_INLINE UINT CDC::SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{ ASSERT(m_hDC != NULL); return ::SetBoundsRect(m_hDC, lpRectBounds, flags); }
_AFXWIN_INLINE UINT CDC::GetBoundsRect(LPRECT lpRectBounds, UINT flags)
	{ ASSERT(m_hAttribDC != NULL); return ::GetBoundsRect(m_hAttribDC, lpRectBounds, flags); }
_AFXWIN_INLINE BOOL CDC::ResetDC(const DEVMODE* lpDevMode)
	{ ASSERT(m_hAttribDC != NULL); return ::ResetDC(m_hAttribDC, lpDevMode) != NULL; }
_AFXWIN_INLINE UINT CDC::GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetOutlineTextMetrics(m_hAttribDC, cbData, lpotm); }
_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidths(m_hAttribDC, nFirstChar, nLastChar, lpabc); }
_AFXWIN_INLINE DWORD CDC::GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData,
	DWORD cbData) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetFontData(m_hAttribDC, dwTable, dwOffset, lpData, cbData); }
_AFXWIN_INLINE int CDC::GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetKerningPairs(m_hAttribDC, nPairs, lpkrnpair); }
_AFXWIN_INLINE DWORD CDC::GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetGlyphOutline(m_hAttribDC, nChar, nFormat,
			lpgm, cbBuffer, lpBuffer, lpmat2); }

// Document handling functions
_AFXWIN_INLINE int CDC::StartDoc(LPDOCINFO lpDocInfo)
	{ ASSERT(m_hDC != NULL); return ::StartDoc(m_hDC, lpDocInfo); }
_AFXWIN_INLINE int CDC::StartPage()
	{ ASSERT(m_hDC != NULL); return ::StartPage(m_hDC); }
_AFXWIN_INLINE int CDC::EndPage()
	{ ASSERT(m_hDC != NULL); return ::EndPage(m_hDC); }
_AFXWIN_INLINE int CDC::SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{ ASSERT(m_hDC != NULL); return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn); }
_AFXWIN_INLINE int CDC::AbortDoc()
	{ ASSERT(m_hDC != NULL); return ::AbortDoc(m_hDC); }
_AFXWIN_INLINE int CDC::EndDoc()
	{ ASSERT(m_hDC != NULL); return ::EndDoc(m_hDC); }

_AFXWIN_INLINE BOOL CDC::MaskBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
		int xSrc, int ySrc, CBitmap& maskBitmap, int xMask, int yMask, DWORD dwRop)
	{ ASSERT(m_hDC != NULL); return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, pSrcDC->GetSafeHdc(),
		xSrc, ySrc,  (HBITMAP)maskBitmap.m_hObject, xMask, yMask, dwRop); }
_AFXWIN_INLINE BOOL CDC::PlgBlt(LPPOINT lpPoint, CDC* pSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, CBitmap& maskBitmap, int xMask, int yMask)
	{ ASSERT(m_hDC != NULL); return ::PlgBlt(m_hDC, lpPoint, pSrcDC->GetSafeHdc(), xSrc, ySrc, nWidth,
		nHeight, (HBITMAP)maskBitmap.m_hObject, xMask, yMask); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(int x, int y, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::SetPixelV(POINT point, COLORREF crColor)
	{ ASSERT(m_hDC != NULL); return ::SetPixelV(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::AngleArc(int x, int y, int nRadius,
		float fStartAngle, float fSweepAngle)
	{ ASSERT(m_hDC != NULL); return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle); }
_AFXWIN_INLINE BOOL CDC::ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ ASSERT(m_hDC != NULL); return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE int CDC::GetArcDirection() const
	{ ASSERT(m_hAttribDC != NULL); return ::GetArcDirection(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::PolyPolyline(const POINT* lpPoints, const DWORD* lpPolyPoints,
		int nCount)
	{ ASSERT(m_hDC != NULL); return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetColorAdjustment(m_hAttribDC, lpColorAdjust); }
_AFXWIN_INLINE CPen* CDC::GetCurrentPen() const
	{ ASSERT(m_hAttribDC != NULL); return CPen::FromHandle((HPEN)::GetCurrentObject(m_hAttribDC, OBJ_PEN)); }
_AFXWIN_INLINE CBrush* CDC::GetCurrentBrush() const
	{ ASSERT(m_hAttribDC != NULL); return CBrush::FromHandle((HBRUSH)::GetCurrentObject(m_hAttribDC, OBJ_BRUSH)); }
_AFXWIN_INLINE CPalette* CDC::GetCurrentPalette() const
	{ ASSERT(m_hAttribDC != NULL); return CPalette::FromHandle((HPALETTE)::GetCurrentObject(m_hAttribDC, OBJ_PAL)); }
_AFXWIN_INLINE CFont* CDC::GetCurrentFont() const
	{ ASSERT(m_hAttribDC != NULL); return CFont::FromHandle((HFONT)::GetCurrentObject(m_hAttribDC, OBJ_FONT)); }
_AFXWIN_INLINE CBitmap* CDC::GetCurrentBitmap() const
	{ ASSERT(m_hAttribDC != NULL); return CBitmap::FromHandle((HBITMAP)::GetCurrentObject(m_hAttribDC, OBJ_BITMAP)); }
_AFXWIN_INLINE BOOL CDC::PolyBezier(const POINT* lpPoints, int nCount)
	{ ASSERT(m_hDC != NULL); return ::PolyBezier(m_hDC, lpPoints, nCount); }

_AFXWIN_INLINE int CDC::DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{ ASSERT(m_hDC != NULL); return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData); }
_AFXWIN_INLINE int CDC::Escape(_In_ int nEscape, _In_ int nInputSize, _In_bytecount_(nInputSize) LPCSTR lpszInputData,
		_In_ int nOutputSize, _Out_bytecap_(nOutputSize) LPSTR lpszOutputData)
	{ ASSERT(m_hDC != NULL); return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData,
		nOutputSize, lpszOutputData); }

_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharABCWidthsFloat(m_hAttribDC, nFirstChar, nLastChar, lpABCF); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const
	{ ASSERT(m_hAttribDC != NULL); return ::GetCharWidthFloat(m_hAttribDC, nFirstChar, nLastChar, lpFloatBuffer); }

_AFXWIN_INLINE BOOL CDC::AbortPath()
	{ ASSERT(m_hDC != NULL); return ::AbortPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::BeginPath()
	{ ASSERT(m_hDC != NULL); return ::BeginPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::CloseFigure()
	{ ASSERT(m_hDC != NULL); return ::CloseFigure(m_hDC); }
_AFXWIN_INLINE BOOL CDC::EndPath()
	{ ASSERT(m_hDC != NULL); return ::EndPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FillPath()
	{ ASSERT(m_hDC != NULL); return ::FillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::FlattenPath()
	{ ASSERT(m_hDC != NULL); return ::FlattenPath(m_hDC); }
_AFXWIN_INLINE float CDC::GetMiterLimit() const
	{ ASSERT(m_hDC != NULL); float fMiterLimit;
		VERIFY(::GetMiterLimit(m_hDC, &fMiterLimit)); return fMiterLimit; }
_AFXWIN_INLINE int CDC::GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{ ASSERT(m_hDC != NULL); return ::GetPath(m_hDC, lpPoints, lpTypes, nCount); }
_AFXWIN_INLINE BOOL CDC::SetMiterLimit(float fMiterLimit)
	{ ASSERT(m_hDC != NULL); return ::SetMiterLimit(m_hDC, fMiterLimit, NULL); }
_AFXWIN_INLINE BOOL CDC::StrokeAndFillPath()
	{ ASSERT(m_hDC != NULL); return ::StrokeAndFillPath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::StrokePath()
	{ ASSERT(m_hDC != NULL); return ::StrokePath(m_hDC); }
_AFXWIN_INLINE BOOL CDC::WidenPath()
	{ ASSERT(m_hDC != NULL); return ::WidenPath(m_hDC); }

_AFXWIN_INLINE BOOL CDC::AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData)
	{ ASSERT(m_hDC != NULL); return ::GdiComment(m_hDC, nDataSize, pCommentData); }
_AFXWIN_INLINE BOOL CDC::PlayMetaFile(HENHMETAFILE hEnhMF, LPCRECT lpBounds)
	{ ASSERT(m_hDC != NULL); return ::PlayEnhMetaFile(m_hDC, hEnhMF, lpBounds); }

/////////////////////////////////////////////////////////////////////////////
// CImageList

_AFXWIN_INLINE CImageList::operator HIMAGELIST() const
	{ return m_hImageList;}
_AFXWIN_INLINE HIMAGELIST CImageList::GetSafeHandle() const
	{ return (this == NULL) ? NULL : m_hImageList; }
_AFXWIN_INLINE int CImageList::GetImageCount() const
	{ ASSERT(m_hImageList != NULL); return AfxImageList_GetImageCount(m_hImageList); }
_AFXWIN_INLINE int CImageList::Add(CBitmap* pbmImage, CBitmap* pbmMask)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Add(m_hImageList, (HBITMAP)pbmImage->GetSafeHandle(), (HBITMAP)pbmMask->GetSafeHandle()); }
_AFXWIN_INLINE int CImageList::Add(CBitmap* pbmImage, COLORREF crMask)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_AddMasked(m_hImageList, (HBITMAP)pbmImage->GetSafeHandle(), crMask); }
_AFXWIN_INLINE BOOL CImageList::Remove(int nImage)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Remove(m_hImageList, nImage); }
_AFXWIN_INLINE BOOL CImageList::Replace(int nImage, CBitmap* pbmImage, CBitmap* pbmMask)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_Replace(m_hImageList, nImage, (HBITMAP)pbmImage->GetSafeHandle(), (HBITMAP)pbmMask->GetSafeHandle()); }
_AFXWIN_INLINE int CImageList::Add(HICON hIcon)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_AddIcon(m_hImageList, hIcon); }
_AFXWIN_INLINE int CImageList::Replace(int nImage, HICON hIcon)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_ReplaceIcon(m_hImageList, nImage, hIcon); }
_AFXWIN_INLINE HICON CImageList::ExtractIcon(int nImage)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_ExtractIcon(NULL, m_hImageList, nImage); }
_AFXWIN_INLINE BOOL CImageList::Draw(CDC* pDC, int nImage, POINT pt, UINT nStyle)
	{ ASSERT(m_hImageList != NULL); ASSERT(pDC != NULL); return AfxImageList_Draw(m_hImageList, nImage, pDC->GetSafeHdc(), pt.x, pt.y, nStyle); }
_AFXWIN_INLINE BOOL CImageList::DrawEx(CDC* pDC, int nImage, POINT pt, SIZE sz, COLORREF clrBk, COLORREF clrFg, UINT nStyle)
	{ ASSERT(m_hImageList != NULL); ASSERT(pDC != NULL); return AfxImageList_DrawEx(m_hImageList, nImage, pDC->GetSafeHdc(), pt.x, pt.y, sz.cx, sz.cy, clrBk, clrFg, nStyle); }
_AFXWIN_INLINE COLORREF CImageList::SetBkColor(COLORREF cr)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetBkColor(m_hImageList, cr); }
_AFXWIN_INLINE COLORREF CImageList::GetBkColor() const
	{ ASSERT(m_hImageList != NULL); return AfxImageList_GetBkColor(m_hImageList); }
_AFXWIN_INLINE BOOL CImageList::SetOverlayImage(int nImage, int nOverlay)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetOverlayImage(m_hImageList, nImage, nOverlay); }
_AFXWIN_INLINE BOOL CImageList::GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const
	{ ASSERT(m_hImageList != NULL); return AfxImageList_GetImageInfo(m_hImageList, nImage, pImageInfo); }
_AFXWIN_INLINE BOOL CImageList::BeginDrag(int nImage, CPoint ptHotSpot)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_BeginDrag(m_hImageList, nImage, ptHotSpot.x, ptHotSpot.y); }
_AFXWIN_INLINE void PASCAL CImageList::EndDrag()
	{ AfxImageList_EndDrag(); }
_AFXWIN_INLINE BOOL PASCAL CImageList::DragMove(CPoint pt)
	{ return AfxImageList_DragMove(pt.x, pt.y); }
_AFXWIN_INLINE BOOL CImageList::SetDragCursorImage(int nDrag, CPoint ptHotSpot)
	{ ASSERT(m_hImageList != NULL); return AfxImageList_SetDragCursorImage(m_hImageList, nDrag, ptHotSpot.x, ptHotSpot.y); }
_AFXWIN_INLINE BOOL PASCAL CImageList::DragShowNolock(BOOL bShow)
	{return AfxImageList_DragShowNolock(bShow);}
_AFXWIN_INLINE CImageList* PASCAL CImageList::GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot)
	{return CImageList::FromHandle(AfxImageList_GetDragImage(lpPoint, lpPointHotSpot));}
_AFXWIN_INLINE BOOL PASCAL CImageList::DragEnter(CWnd* pWndLock, CPoint point)
	{ return AfxImageList_DragEnter(pWndLock->GetSafeHwnd(), point.x, point.y); }
_AFXWIN_INLINE BOOL PASCAL CImageList::DragLeave(CWnd* pWndLock)
	{ return AfxImageList_DragLeave(pWndLock->GetSafeHwnd()); }

/////////////////////////////////////////////////////////////////////////////	

// CMenu
_AFXWIN_INLINE CMenu::CMenu()
	{ m_hMenu = NULL; }
_AFXWIN_INLINE CMenu::~CMenu()
	{ DestroyMenu(); }
_AFXWIN_INLINE BOOL CMenu::CreateMenu()
	{ return Attach(::CreateMenu()); }
_AFXWIN_INLINE BOOL CMenu::CreatePopupMenu()
	{ return Attach(::CreatePopupMenu()); }
_AFXWIN_INLINE CMenu::operator HMENU() const
	{ ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
		return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::operator==(const CMenu& menu) const
	{ return ((HMENU) menu) == m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::operator!=(const CMenu& menu) const
	{ return ((HMENU) menu) != m_hMenu; }
_AFXWIN_INLINE HMENU CMenu::GetSafeHmenu() const
	{ ASSERT(this == NULL || m_hMenu == NULL || ::IsMenu(m_hMenu));
		return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::DeleteMenu(UINT nPosition, UINT nFlags)
	{ ASSERT(::IsMenu(m_hMenu)); return ::DeleteMenu(m_hMenu, nPosition, nFlags); }

_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE UINT CMenu::CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{ ASSERT(::IsMenu(m_hMenu)); return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck); }
_AFXWIN_INLINE UINT CMenu::EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{ ASSERT(::IsMenu(m_hMenu)); return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable); }
_AFXWIN_INLINE BOOL CMenu::SetDefaultItem(UINT uItem, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuDefaultItem(m_hMenu, uItem, fByPos); }
_AFXWIN_INLINE UINT CMenu::GetDefaultItem(UINT gmdiFlags, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuDefaultItem(m_hMenu, fByPos, gmdiFlags); }
_AFXWIN_INLINE int CMenu::GetMenuItemCount() const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuItemCount(m_hMenu); }
_AFXWIN_INLINE UINT CMenu::GetMenuItemID(int nPos) const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuItemID(m_hMenu, nPos); }
_AFXWIN_INLINE UINT CMenu::GetMenuState(UINT nID, UINT nFlags) const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuState(m_hMenu, nID, nFlags); }
_AFXWIN_INLINE int CMenu::GetMenuString(_In_ UINT nIDItem, _Out_z_cap_(nMaxCount) LPTSTR lpString, _In_ int nMaxCount, _In_ UINT nFlags) const
	{ ASSERT(::IsMenu(m_hMenu)); return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags); }
_AFXWIN_INLINE BOOL CMenu::GetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::GetMenuItemInfo(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
_AFXWIN_INLINE BOOL CMenu::SetMenuItemInfo(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::SetMenuItemInfo(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
_AFXWIN_INLINE CMenu* CMenu::GetSubMenu(int nPos) const
	{ ASSERT(::IsMenu(m_hMenu)); return CMenu::FromHandle(::GetSubMenu(m_hMenu, nPos)); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem,
		LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::InsertMenuItem(UINT uItem, LPMENUITEMINFO lpMenuItemInfo, BOOL fByPos)
	{ ASSERT(::IsMenu(m_hMenu)); ASSERT_POINTER(lpMenuItemInfo, MENUITEMINFO);
		return ::InsertMenuItem(m_hMenu, uItem, fByPos, lpMenuItemInfo); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, LPCTSTR lpszNewItem)
	{ ASSERT(::IsMenu(m_hMenu)); return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, const CBitmap* pBmp)
	{ ASSERT(::IsMenu(m_hMenu)); return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		(LPCTSTR)pBmp->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::RemoveMenu(UINT nPosition, UINT nFlags)
	{ ASSERT(::IsMenu(m_hMenu)); return ::RemoveMenu(m_hMenu, nPosition, nFlags); }
_AFXWIN_INLINE BOOL CMenu::SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
		const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked)
	{ ASSERT(::IsMenu(m_hMenu)); return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags,
		(HBITMAP)pBmpUnchecked->GetSafeHandle(),
		(HBITMAP)pBmpChecked->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(LPCTSTR lpszResourceName)
	{ return Attach(::LoadMenu(AfxFindResourceHandle(lpszResourceName,
		RT_MENU), lpszResourceName)); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(UINT nIDResource)
	{ return Attach(::LoadMenuW(AfxFindResourceHandle(
		MAKEINTRESOURCE(nIDResource), RT_MENU), MAKEINTRESOURCEW(nIDResource))); }
_AFXWIN_INLINE BOOL CMenu::LoadMenuIndirect(const void* lpMenuTemplate)
	{ return Attach(::LoadMenuIndirect(lpMenuTemplate)); }
// Win4
_AFXWIN_INLINE BOOL CMenu::SetMenuContextHelpId(DWORD dwContextHelpId)
	{ return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId); }
_AFXWIN_INLINE DWORD CMenu::GetMenuContextHelpId() const
	{ return ::GetMenuContextHelpId(m_hMenu); }
_AFXWIN_INLINE BOOL CMenu::CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{ return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags); }

// CCmdUI
_AFXWIN_INLINE void CCmdUI::ContinueRouting()
	{ m_bContinueRouting = TRUE; }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwinforms.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFX_WINFORMS_H__
#define __AFX_WINFORMS_H__

#ifndef __cplusplus
	#error MFC requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __cplusplus_cli
	#error MFC WinForms support requires /clr (doesn't support oldSyntax)
#endif

#ifndef _AFXDLL
	#error MFC WinForms support requires MFC dll version.
#endif

#pragma once

#using <mscorlib.dll>
#using <System.dll>
#using <System.Windows.Forms.dll>
#using <System.Drawing.dll>


#using <mfcmifc80.dll>

#ifdef BUILD_MFCM
#define AFX_MFCM_EXPORT __declspec(dllexport)
#else
#define AFX_MFCM_EXPORT __declspec(dllimport)

#ifndef _MFC_FILENAME_VER
#define _MFC_FILENAME_VER "100"
#endif

#ifndef _MFC_FILENAME_VER_DOT
#define _MFC_FILENAME_VER_DOT "10.0"
#endif

#ifndef _UNICODE
	#ifdef _DEBUG
		#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "d.lib")		
	#else		
		#pragma comment(lib, "mfcm" _MFC_FILENAME_VER ".lib")		
	#endif
#else
	#ifdef _DEBUG
		#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "ud.lib")		
	#else
		#pragma comment(lib, "mfcm" _MFC_FILENAME_VER "u.lib")		
	#endif
#endif

#endif //BUILD_MFCM

#include <vcclr.h>
#include <msclr\event.h>
#include <afxdisp.h>
#include <afxpriv.h>



namespace Microsoft {
	namespace VisualC {
		namespace MFC {



/////////////////////////////////////////////////////////////////////////////
// CWin32Window - Win32 HWND wrapper implementing IWin32Window. Used to pass 
// Parent HWNDs from MFC to WinForms.
//

public ref class CWin32Window : public System::Windows::Forms::IWin32Window 
{
	const HWND m_hWnd;
public:
	CWin32Window(HWND hWnd) : m_hWnd(hWnd){}
	property System::IntPtr Handle
	{
		virtual System::IntPtr get()
		{
			return static_cast<System::IntPtr>(m_hWnd);
		}		
	}	
};

/////////////////////////////////////////////////////////////////////////////
// CControlCreationInfoEx - Inits and Cleanup CControlCreationInfo struct 
//  GCHandle information.
//

class CControlCreationInfoEx : public CControlCreationInfo {
public:
	typedef System::Runtime::InteropServices::GCHandle GCHandle;
	CControlCreationInfoEx();
	
	void Init(System::Object^ p,HandleKind hk);
	
	~CControlCreationInfoEx();
	
};

////////////////////////////////////
// Notification from __gc Helper class.
__interface IHandleEvents {
	void OnHandleCreated(System::Object^ o, System::EventArgs^ e);
	void OnHandleDestroyed(System::Object^ o, System::EventArgs^ e);
};


public ref class CWinFormsEventsHelper
{
public:
	CWinFormsEventsHelper();
    

	property System::Windows::Forms::Control^ Control
	{
		System::Windows::Forms::Control^ get();
		void set(System::Windows::Forms::Control^ pControl);
	}
	
	void Advise(IHandleEvents* pSink);
	void Unadvise(IHandleEvents* pSink);
	

private:
	void OnHandleCreated( System::Object^ o, System::EventArgs^ args);
	
	void OnHandleDestroyed( System::Object^ o, System::EventArgs^ args);
	
public:
	System::Windows::Forms::Control^ m_pControl;
	IHandleEvents* m_pSink;

};

/////////////////////////////////////////////////////////////////////////////
// CWinFormsControlSite - overrides COleControlSite when the ActiveX is a 
// WinForm control.

 
class CWinFormsControlSite : public COleControlSite,public IHandleEvents {
public:
	CWinFormsControlSite(COleControlContainer* pCtrlCont);
	~CWinFormsControlSite();
	
	virtual HRESULT DoVerb(LONG nVerb, LPMSG lpMsg);
	
	virtual void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
	
	void SetControlEnabled(bool bEnable);
	
	virtual void SetPropertyV(DISPID dwDispID, VARTYPE vtProp, va_list argList);
	
	virtual DWORD GetStyle() const;	

	virtual HRESULT CreateOrLoad(const CControlCreationInfo& creationInfo);	
	virtual HRESULT CreateControlCommon(CWnd* pWndCtrl, REFCLSID clsid,const CControlCreationInfo& creationInfo,
		LPCTSTR lpszWindowName, DWORD dwStyle, const POINT* ppt, const SIZE* psize, UINT nID,
		CFile* pPersist, BOOL bStorage, BSTR bstrLicKey);

	void OnHandleCreatedHandler();

	virtual void OnHandleCreated( gcroot<System::Object^> , gcroot<System::EventArgs^> );
	virtual void OnHandleDestroyed( gcroot<System::Object^> , gcroot<System::EventArgs^> );

	virtual void OnHandleCreated(System::Object^, System::EventArgs^);	
	virtual void OnHandleDestroyed(System::Object^, System::EventArgs^);
	
	System::Windows::Forms::Control^ get_Control() const;
	
	gcroot<CWinFormsEventsHelper^> m_gcEventHelper;
};

/////////////////////////////////////////////////////////////////////////////
// CWinFormsControl
// Provides the basic functionality for AX hosting of WinForms Control
//
template<class TManagedControl>
class CWinFormsControl : public CWnd	
{
public:
	CWinFormsControl();

	inline TManagedControl^ GetControl() const;
	

	inline operator TManagedControl^() const;
	inline TManagedControl^ operator->() const;
	inline HWND GetControlHandle() const;

	inline BOOL CreateManagedControl(System::Type^ pType,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);

	inline BOOL CreateManagedControl(typename TManagedControl^ pControl,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);
	

	inline BOOL CreateManagedControl(DWORD dwStyle,const RECT& rect, CWnd* pParentWnd, int nID);
	
	////////////////////////////////////////////////////////////////
	//Purpose: Create a WinForms control and placing it on top
	// of a STATIC control, placed in Resource Editor as a place holder
	// for the .Net control.
	//Input: window styles, IDC_ of STATIC place holder, and Parent CWnd*
	//Return: TRUE if creation succeeded.
	////////////////////////////////////////////////////////////////
	inline BOOL CreateManagedControl(DWORD dwStyle,int nPlaceHolderID, CWnd* pParentWnd);	

	//Creates a control of managed type.
	inline BOOL InternalCreateManagedControl(const CControlCreationInfo& info,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID);
};

////////////////////////////////////////////////////////////////////////
// CWinFormsView 
// Provides generic functionality for AX hosting of WinForms Control as an MFC View
// 

class CWinFormsView : public CView 
{
	DECLARE_DYNAMIC(CWinFormsView)

public:
	
	CWinFormsView(System::Type^ pManagedViewType);

	System::Windows::Forms::Control^ GetControl() const;
	
	operator System::Windows::Forms::Control^() const;
	

protected:
	virtual void OnInitialUpdate();
	
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);

	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
								CView* pDeactiveView);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);
	
protected:
	virtual void OnDraw(CDC*) { };
	afx_msg void OnSize(UINT nType, int cx, int cy);
	
	gcroot<System::Type^> m_pManagedViewType;
private:
	CWinFormsControl<System::Windows::Forms::Control> m_control;
	gcroot<System::Object^> m_CmdSource;
		
	DECLARE_MESSAGE_MAP()

};

#define IDC_WINFRMCTRL_DIALOG 45002

//
// The WinForms Form wrapper
//
template <typename TManagedControl>
class CWinFormsDialog : public CDialog
{	
public:
	enum { IDD = AFX_IDD_EMPTYDIALOG };
public:		
	CWinFormsDialog(UINT nIDTemplate = IDD, CWnd* pParentWnd = NULL);
	virtual BOOL OnInitDialog();		
	//
	// The .Net Control  interface accessors
	//
	inline TManagedControl^ GetControl() const;
	inline operator TManagedControl^() const throw();
	inline TManagedControl^ operator->() const throw();
	inline HWND GetControlHandle() const throw();	
protected:
	CWinFormsControl<TManagedControl> m_control;
	afx_msg void OnSize(UINT nType, int cx, int cy);
	
private:
	DECLARE_MESSAGE_MAP()
	gcroot<TManagedControl^> m_pWFControl;
};

template <typename T>
void DDX_ManagedControl(CDataExchange* pDX, int nIDC,CWinFormsControl<T>& control);

		namespace Internal {
			using Microsoft::VisualC::MFC::CControlCreationInfoEx;
			using Microsoft::VisualC::MFC::CWin32Window;
			using Microsoft::VisualC::MFC::IHandleEvents;
			using Microsoft::VisualC::MFC::CWinFormsEventsHelper;
		}
		
	} //namespace MFC


	} //VisualC
} //Microsoft

using Microsoft::VisualC::MFC::CWinFormsView;
using Microsoft::VisualC::MFC::CWinFormsDialog;
using Microsoft::VisualC::MFC::CWinFormsControl;
using Microsoft::VisualC::MFC::CWinFormsControlSite;
using Microsoft::VisualC::MFC::DDX_ManagedControl;

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE AFX_INLINE
#endif
#include <afxwinforms.inl>



#endif // __AFX_WINFORMS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlacc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLACC_H__
#define __ATLACC_H__

#pragma once

#include <oleacc.h>
#include <atliface.h>
#include <atlbase.h>
#include <atlcom.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "oleacc.lib")
#endif	// _ATL_NO_DEFAULT_LIBS


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

HRESULT STDMETHODCALLTYPE AtlIAccessibleInvokeHelper(
	_Inout_ IAccessible* pAccessible,
	_In_ DISPID dispIdMember,
	_In_ REFIID,
	_In_ LCID,
	_In_ WORD wFlags,
	_In_ DISPPARAMS *pDispParams,
	_Out_opt_ VARIANT *pVarResult,
	_Out_opt_ EXCEPINFO *,
	_Out_opt_ UINT *puArgErr);

HRESULT STDMETHODCALLTYPE AtlIAccessibleGetIDsOfNamesHelper(
	_In_ REFIID,
	_In_count_(cNames) _Deref_pre_z_ LPOLESTR *rgszNames,
	_In_ UINT cNames,
	_In_ LCID,
	_Out_cap_(cNames) DISPID *rgDispId);


template <class T>
class IAccessibleProxyImpl :
	public IAccessible,
	public IAccessibleProxy
{
public :
	IAccessible* m_pAccessible;
	IAccessibleServer* m_pAccessibleServer;
	IAccessibleProxyImpl() :
		m_pAccessible(NULL), m_pAccessibleServer(NULL)
	{
	}

	HRESULT STDMETHODCALLTYPE get_accParent(_Deref_out_ IDispatch **ppdispParent)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (ppdispParent == NULL)
			return E_POINTER;
		return m_pAccessible->get_accParent(ppdispParent);
	}

	HRESULT STDMETHODCALLTYPE get_accChildCount(_Out_ long *pcountChildren)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pcountChildren== NULL)
			return E_POINTER;
		return m_pAccessible->get_accChildCount(pcountChildren);
	}

	HRESULT STDMETHODCALLTYPE get_accChild(
		_In_ VARIANT varChild,
		_Deref_out_ IDispatch **ppdispChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (ppdispChild == NULL)
			return E_POINTER;
		return m_pAccessible->get_accChild(varChild, ppdispChild);
	}

	HRESULT STDMETHODCALLTYPE get_accName(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszName)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszName == NULL)
			return E_POINTER;
		return m_pAccessible->get_accName(varChild, pszName);
	}

	HRESULT STDMETHODCALLTYPE get_accValue(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszValue)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszValue == NULL)
			return E_POINTER;
		return m_pAccessible->get_accValue(varChild, pszValue);
	}

	HRESULT STDMETHODCALLTYPE get_accDescription(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszDescription)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszDescription == NULL)
			return E_POINTER;
		return m_pAccessible->get_accDescription(varChild, pszDescription);
	}

	HRESULT STDMETHODCALLTYPE get_accRole(
		_In_ VARIANT varChild,
		_Out_ VARIANT *pvarRole)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarRole == NULL)
			return E_POINTER;
		return m_pAccessible->get_accRole(varChild, pvarRole);
	}

	HRESULT STDMETHODCALLTYPE get_accState(
		_In_ VARIANT varChild,
		_Out_ VARIANT *pvarState)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarState == NULL)
			return E_POINTER;
		return m_pAccessible->get_accState(varChild, pvarState);
	}

	HRESULT STDMETHODCALLTYPE get_accHelp(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszHelp)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszHelp == NULL)
			return E_POINTER;
		return m_pAccessible->get_accHelp(varChild, pszHelp);
	}

	HRESULT STDMETHODCALLTYPE get_accHelpTopic(
		_Deref_out_z_ BSTR *pszHelpFile,
		_In_ VARIANT varChild,
		_Out_ long *pidTopic)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszHelpFile == NULL)
			return E_POINTER;
		if (pidTopic == NULL)
			return E_POINTER;
		return m_pAccessible->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
	}

	HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszKeyboardShortcut)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszKeyboardShortcut == NULL)
			return E_POINTER;
		return m_pAccessible->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
	}

	HRESULT STDMETHODCALLTYPE get_accFocus(
		_Out_ VARIANT *pvarChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarChild == NULL)
			return E_POINTER;
		return m_pAccessible->get_accFocus(pvarChild);
	}

	HRESULT STDMETHODCALLTYPE get_accSelection(
		_Out_ VARIANT *pvarChildren)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarChildren == NULL)
			return E_POINTER;
		return m_pAccessible->get_accSelection(pvarChildren);
	}

	HRESULT STDMETHODCALLTYPE get_accDefaultAction(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszDefaultAction)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pszDefaultAction == NULL)
			return E_POINTER;
		return m_pAccessible->get_accDefaultAction(varChild, pszDefaultAction);
	}

	HRESULT STDMETHODCALLTYPE accSelect(
		_In_ long flagsSelect,
		_In_ VARIANT varChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->accSelect(flagsSelect, varChild);
	}

	HRESULT STDMETHODCALLTYPE accLocation(
		_Out_ long *pxLeft,
		_Out_ long *pyTop,
		_Out_ long *pcxWidth,
		_Out_ long *pcyHeight,
		_Inout_ VARIANT varChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pxLeft == NULL)
			return E_POINTER;

		if (pyTop == NULL)
			return E_POINTER;

		if (pcxWidth == NULL)
			return E_POINTER;

		if (pcyHeight == NULL)
			return E_POINTER;
		return m_pAccessible->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
	}

	HRESULT STDMETHODCALLTYPE accNavigate(
		_In_ long navDir,
		_In_ VARIANT varStart,
		_Out_ VARIANT *pvarEndUpAt)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarEndUpAt == NULL)
			return E_POINTER;
		return m_pAccessible->accNavigate(navDir, varStart, pvarEndUpAt);
	}

	HRESULT STDMETHODCALLTYPE accHitTest(
		_In_ long xLeft,
		_In_ long yTop,
		_Out_ VARIANT *pvarChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		if (pvarChild == NULL)
			return E_POINTER;
		return m_pAccessible->accHitTest(xLeft, yTop, pvarChild);
	}

	HRESULT STDMETHODCALLTYPE accDoDefaultAction(_In_ VARIANT varChild)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->accDoDefaultAction(varChild);
	}

	HRESULT STDMETHODCALLTYPE put_accName(
		_In_ VARIANT /*varChild*/,
		_In_z_ BSTR /*szName*/)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE put_accValue(
		_In_ VARIANT /*varChild*/,
		_In_z_ BSTR /*szValue*/)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return E_NOTIMPL;
	}

	HRESULT STDMETHODCALLTYPE SetServer(
		_In_ IAccessible *pAccessible,
		_In_ IAccessibleServer* pServer)
	{
		// hold a weak reference to the server
		m_pAccessible = pAccessible;
		m_pAccessibleServer = pServer;
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE Invoke(
		_In_ DISPID dispIdMember,
		_In_ REFIID riid,
		_In_ LCID lcid,
		_In_ WORD wFlags,
		_In_ DISPPARAMS *pDispParams,
		_Out_opt_ VARIANT *pVarResult,
		_Out_opt_ EXCEPINFO *pExcepInfo,
		_Out_opt_ UINT *puArgErr)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
	}

	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		_In_ REFIID riid,
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR *rgszNames,
		_In_ UINT cNames,
		_In_ LCID lcid,
		_Out_cap_(cNames) DISPID *rgDispId)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
	}

	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(_Out_ unsigned int* pctinfo)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->GetTypeInfoCount(pctinfo);
	}

	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		_In_ unsigned int iTInfo,
		_In_ LCID lcid,
		_Deref_out_ ITypeInfo** ppTInfo)
	{
		if (m_pAccessible == NULL)
			return RPC_E_DISCONNECTED;
		return m_pAccessible->GetTypeInfo(iTInfo, lcid, ppTInfo);
	}
};

class ATL_NO_VTABLE CAccessibleProxy :
	public CComObjectRootEx<CComSingleThreadModel>,
	public IAccessibleProxyImpl<CAccessibleProxy>,
	public IOleWindow
{
public:
	CAccessibleProxy()
	{
	}
	virtual ~CAccessibleProxy()
	{
	}

	HRESULT STDMETHODCALLTYPE GetWindow(_In_opt_ HWND* /*phwnd*/)
	{
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(_In_ BOOL /*fEnterMode*/)
	{
		return E_NOTIMPL;
	}

	HRESULT FinalRelease()
	{
		if (m_pAccessibleServer == NULL)
			return S_OK;
		return m_pAccessibleServer->SetProxy(NULL);
	}

BEGIN_COM_MAP(CAccessibleProxy)
	COM_INTERFACE_ENTRY(IAccessibleProxy)
	COM_INTERFACE_ENTRY(IAccessible)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IOleWindow)
END_COM_MAP()

public:
};

template <class T>
class IAccessibleImpl :
	public IAccessible,
	public IAccessibleServer
{
public :
	IAccessibleImpl() : m_pProxy(NULL)
	{
	}

	IAccessibleProxy* m_pProxy;
	CComPtr<IAccessible> m_spStdObject;
	HRESULT EnsureStdObj()
	{
		if (m_spStdObject == NULL)
		{
			T* pT = static_cast<T*>(this);
			HRESULT hr = CreateStdAccessibleObject(pT->m_hWnd, OBJID_CLIENT, __uuidof(IAccessible), (void**)&m_spStdObject);
			if (FAILED(hr))
				return hr;
		}
		return S_OK;
	}

	// Delegate to standard helper?
	HRESULT STDMETHODCALLTYPE get_accParent(_Deref_out_ IDispatch **ppdispParent)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accParent(ppdispParent);
	}

	// Delegate to standard helper?
	HRESULT STDMETHODCALLTYPE get_accChildCount(_Out_ long *pcountChildren)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accChildCount(pcountChildren);
	}

	// Delegate to standard helper?
	HRESULT STDMETHODCALLTYPE get_accChild(
		_In_ VARIANT varChild,
		_Deref_out_ IDispatch **ppdispChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accChild(varChild, ppdispChild);
	}

	// Override in users code
	HRESULT STDMETHODCALLTYPE get_accName(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszName)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accName(varChild, pszName);
	}

	// Override in users code
	// Default inplementation will get window text and return it.
	HRESULT STDMETHODCALLTYPE get_accValue(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszValue)
	{
		return m_spStdObject->get_accValue(varChild, pszValue);
	}

	// Override in users code
	HRESULT STDMETHODCALLTYPE get_accDescription(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszDescription)
	{
		return m_spStdObject->get_accDescription(varChild, pszDescription);
	}

	// Investigate
	HRESULT STDMETHODCALLTYPE get_accRole(
		_In_ VARIANT varChild,
		_Out_ VARIANT *pvarRole)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accRole(varChild, pvarRole);
	}

	// Investigate
	HRESULT STDMETHODCALLTYPE get_accState(
		_In_ VARIANT varChild,
		_Out_ VARIANT *pvarState)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accState(varChild, pvarState);
	}

	// Override in User's code?
	HRESULT STDMETHODCALLTYPE get_accHelp(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszHelp)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accHelp(varChild, pszHelp);
	}

	// Override in user's code?
	HRESULT STDMETHODCALLTYPE get_accHelpTopic(
		_Deref_out_z_ BSTR *pszHelpFile,
		_In_ VARIANT varChild,
		_Out_ long *pidTopic)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
	}

	// Override in user's code?
	HRESULT STDMETHODCALLTYPE get_accKeyboardShortcut(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszKeyboardShortcut)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
	}

	// Delegate to standard implementation?
	HRESULT STDMETHODCALLTYPE get_accFocus(
		_Out_ VARIANT *pvarChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accFocus(pvarChild);
	}

	// Investigate
	HRESULT STDMETHODCALLTYPE get_accSelection(
		_Out_ VARIANT *pvarChildren)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accSelection(pvarChildren);
	}

	// Override in user's code
	HRESULT STDMETHODCALLTYPE get_accDefaultAction(
		_In_ VARIANT varChild,
		_Deref_out_z_ BSTR *pszDefaultAction)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->get_accDefaultAction(varChild, pszDefaultAction);
	}

	// Investigate
	HRESULT STDMETHODCALLTYPE accSelect(
		_In_ long flagsSelect,
		_In_ VARIANT varChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->accSelect(flagsSelect, varChild);
	}

	// Delegate?
	HRESULT STDMETHODCALLTYPE accLocation(
		_Out_ long *pxLeft,
		_Out_ long *pyTop,
		_Out_ long *pcxWidth,
		_Out_ long *pcyHeight,
		_Inout_ VARIANT varChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
	}

	// Delegate? May have to implement for COM children
	HRESULT STDMETHODCALLTYPE accNavigate(
		_In_ long navDir,
		_In_ VARIANT varStart,
		_Out_ VARIANT *pvarEndUpAt)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->accNavigate(navDir, varStart, pvarEndUpAt);
	}

	// Delegate?
	HRESULT STDMETHODCALLTYPE accHitTest(
		_In_ long xLeft,
		_In_ long yTop,
		_Out_ VARIANT *pvarChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->accHitTest(xLeft, yTop, pvarChild);
	}

	// Override in user's code
	HRESULT STDMETHODCALLTYPE accDoDefaultAction(_In_ VARIANT varChild)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->accDoDefaultAction(varChild);
	}

	// Obsolete
	HRESULT STDMETHODCALLTYPE put_accName(
		_In_ VARIANT varChild,
		_In_z_ BSTR szName)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->put_accName(varChild, szName);
	}

	// Obsolete
	HRESULT STDMETHODCALLTYPE put_accValue(
		_In_ VARIANT varChild,
		_In_z_ BSTR szValue)
	{
		ATLASSUME(m_spStdObject != NULL);
		return m_spStdObject->put_accValue(varChild, szValue);
	}

	HRESULT STDMETHODCALLTYPE SetProxy(_In_ IAccessibleProxy *pUnknown)
	{
		// We keep a weak reference to the server
		m_pProxy = pUnknown;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetHWND(_Out_ HWND *phWnd)
	{
		if (phWnd == NULL)
			return E_POINTER;
		T* pT = static_cast<T*>(this);
		*phWnd = pT->m_hWnd;
		return S_OK;
	}

	HRESULT STDMETHODCALLTYPE GetEnumVariant(
		_Deref_out_opt_ IEnumVARIANT **ppEnumVariant)
	{
		if (ppEnumVariant == NULL)
			return E_POINTER;
		*ppEnumVariant = NULL;
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Invoke(
		_In_ DISPID dispIdMember,
		_In_ REFIID refiid,
		_In_ LCID lcid,
		_In_ WORD wFlags,
		_In_ DISPPARAMS *pDispParams,
		_Out_opt_ VARIANT *pVarResult,
		_Out_opt_ EXCEPINFO *pExcepInfo,
		_Out_opt_ UINT *puArgErr)
	{
		return AtlIAccessibleInvokeHelper(this, dispIdMember, refiid,
				lcid, wFlags, pDispParams, pVarResult,
					pExcepInfo, puArgErr);
	}
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		_In_ REFIID refiid,
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR *rgszNames,
		_In_ UINT cNames,
		_In_ LCID lcid,
		_Out_cap_(cNames) DISPID *rgDispId)
	{
		return AtlIAccessibleGetIDsOfNamesHelper(refiid, rgszNames, cNames, lcid, rgDispId);
	}

	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(_Out_ unsigned int*  pctinfo)
	{
		if (pctinfo == NULL)
		{
			return E_POINTER;
		}
		*pctinfo = 1;
		return S_OK;
	}
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		_In_ unsigned int /*iTInfo*/,
		_In_ LCID /*lcid*/,
		_In_opt_ ITypeInfo** /*ppTInfo*/)
	{
		return E_NOTIMPL;
	}
	long __stdcall QueryInterface(
		_In_ const struct _GUID &/*refIID*/,
		_Deref_out_opt_ _Deref_post_opt_bytecount_c_(sizeof(IUnknown)) void **ppv)
	{
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;
/*		if (IsEqualGUID(refIID, __uuidof(IAccessibleServer)))
		{
			*ppv = static_cast<void*>(static_cast<IAccessibleServer*>(this));
			return S_OK;
		}
		if (IsEqualGUID(refIID, __uuidof(IAccessible)))
		{
			*ppv = static_cast<void*>(static_cast<IAccessible*>(this));
			return S_OK;
		}
		if (IsEqualGUID(refIID, __uuidof(IUnknown)))
		{
			*ppv = static_cast<void*>(static_cast<IUnknown*>(static_cast<IAccessible*>(this)));
			return S_OK;
		}
		if (IsEqualGUID(refIID, __uuidof(IDispatch)))
		{
			*ppv = static_cast<void*>(static_cast<IDispatch*>(static_cast<IAccessible*>(this)));
			return S_OK;
		}
*/
		return E_NOINTERFACE;
	}
	unsigned long __stdcall AddRef(void)
	{
		return 1;
	}
	unsigned long __stdcall Release(void)
	{
		return 1;
	}

	HRESULT CreateAccessibleProxy(
		_In_ WPARAM wParam,
		_In_ LPARAM lParam,
		_Out_ LRESULT *pResult)
	{
		ATLASSERT(pResult != NULL);
		DWORD dwObjId = (DWORD) lParam;
		HRESULT hr = E_FAIL;

		if(pResult == NULL)
			return E_INVALIDARG;

		if (dwObjId == OBJID_CLIENT)
		{
			hr = EnsureStdObj();
			if (SUCCEEDED(hr))
			{
				if (m_pProxy == NULL)
				{
					CComObject<CAccessibleProxy> *p;
					hr = CComObject<CAccessibleProxy>::CreateInstance(&p);
					if (SUCCEEDED(hr))
					{
						CComPtr<IAccessibleProxy> spProx;
						hr = p->QueryInterface(&spProx);
						if (SUCCEEDED(hr))
						{
							m_pProxy = spProx;
							spProx->SetServer(static_cast<IAccessible*>(this), static_cast<IAccessibleServer*>(this));
							*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
						}
						hr = S_OK;
					}
				}
				else
				{
					*pResult = LresultFromObject (__uuidof(IAccessible), wParam, m_pProxy);
					hr = S_OK;
				}
			}
		}
		return hr;
	}
};

inline HRESULT STDMETHODCALLTYPE AtlIAccessibleInvokeHelper(
	_Inout_ IAccessible* pAccessible,
	_In_ DISPID dispIdMember,
	_In_ REFIID,
	_In_ LCID,
	_In_ WORD wFlags,
	_In_ DISPPARAMS *pDispParams,
	_Out_opt_ VARIANT *pVarResult,
	_Out_opt_ EXCEPINFO *,
	_Out_opt_ UINT *puArgErr)
{
	UINT uArgErr;
	VARIANT vResult;
	vResult.vt = VT_EMPTY;

	if(pAccessible == NULL)
	{
		return E_INVALIDARG;
	}

	if (pDispParams == NULL)
	{
		return DISP_E_BADVARTYPE;
	}

	if (pDispParams->cArgs > 5)
	{
		return DISP_E_BADPARAMCOUNT;
	}

	VARIANTARG * rgpParams[5];
	{
		ATLASSERT(pDispParams->cNamedArgs <= pDispParams->cArgs);
		UINT i = 0;
		for (; i < pDispParams->cNamedArgs; i++)
		{
			if ((UINT)pDispParams->rgdispidNamedArgs[i] >= pDispParams->cArgs)
			{
				return DISP_E_BADPARAMCOUNT;
			}
			rgpParams[pDispParams->rgdispidNamedArgs[i]] = &pDispParams->rgvarg[i];
		}
		for (; i < pDispParams->cArgs; i++)
		{
			rgpParams[pDispParams->cArgs - i - 1] = &pDispParams->rgvarg[i];
		}
	}

	HRESULT hr = DISP_E_MEMBERNOTFOUND;

	if(puArgErr == NULL)
	{
  		puArgErr = &uArgErr;
	}

	if(pVarResult == NULL)
	{
		pVarResult = &vResult;
	}
	VARIANT varg;
	VariantInit(&varg);

	switch (dispIdMember)
	{
	case DISPID_ACC_DODEFAULTACTION :		// -5018
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			VARIANT i1 = *rgpParams[0];
			hr = pAccessible->accDoDefaultAction(i1);
			break;
		}
	case DISPID_ACC_HITTEST :				// -5017
		{
			if(pDispParams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (rgpParams[0]->vt != VT_I4)
			{
				hr = VariantChangeType(&varg, rgpParams[0], 0, VT_I4);
				if(FAILED(hr))
				{
					*puArgErr = 0;
					break;
				}
				rgpParams[0] = &varg;
			}
			long i1 = V_I4(rgpParams[0]);

			if (rgpParams[1]->vt != VT_I4)
			{
				hr = VariantChangeType(&varg, rgpParams[1], 0, VT_I4);
				if(FAILED(hr))
				{
					*puArgErr = 1;
					break;
				}
				rgpParams[1] = &varg;
			}
			long i2 = V_I4(rgpParams[1]);

			hr = pAccessible->accHitTest(i1, i2, pVarResult);
			break;
		}
	case DISPID_ACC_NAVIGATE :				// -5016
		{
			if(pDispParams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			if (rgpParams[0]->vt != VT_I4)
			{
				hr = VariantChangeType(&varg, rgpParams[0], 0, VT_I4);
				if(FAILED(hr))
				{
					*puArgErr = 0;
					break;
				}
				rgpParams[0] = &varg;
			}
			long i1 = V_I4(rgpParams[0]);

			VARIANT i2 = *rgpParams[1];

			hr = pAccessible->accNavigate(i1, i2, pVarResult);
			break;
		}
	case DISPID_ACC_LOCATION :				// -5015
		{
			BOOL bError = FALSE;

			if(pDispParams->cArgs != 5)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			long *pI4Params[4];
			for (int iParam = 0; iParam < 4; iParam++)
			{
				if (!(rgpParams[iParam]->vt & VT_BYREF) ||
					(rgpParams[iParam]->vt & (VT_VARIANT | VT_I4)) == 0)
				{
					hr = DISP_E_TYPEMISMATCH;
					bError = TRUE;
					*puArgErr = iParam;
					break;
				}
				if (rgpParams[iParam]->vt & VT_VARIANT)
				{
					VariantClear(V_VARIANTREF(rgpParams[iParam]));
					V_VARIANTREF(rgpParams[iParam])->vt = VT_I4;
					pI4Params[iParam] = &V_I4(V_VARIANTREF(rgpParams[iParam]));
				}
				else
				{
					pI4Params[iParam] = V_I4REF(rgpParams[iParam]);
				}
			}

			if (!bError)
			{
				VARIANT i5 = *rgpParams[4];
				hr = pAccessible->accLocation(pI4Params[0], pI4Params[1], pI4Params[2], pI4Params[3], i5);
			}
			break;
		}
	case DISPID_ACC_SELECT :				// -5014
		{
			if(pDispParams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			if (rgpParams[0]->vt != VT_I4)
			{
				hr = VariantChangeType(&varg, rgpParams[0], 0, VT_I4);
				if(FAILED(hr))
				{
					*puArgErr = 0;
					break;
				}
				rgpParams[0] = &varg;
			}
			long i1 = V_I4(rgpParams[0]);

			VARIANT i2 = *rgpParams[1];

			hr = pAccessible->accSelect(i1, i2);
			break;
		}
	case DISPID_ACC_DEFAULTACTION :			// -5013
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			VARIANT i1 = *rgpParams[0];

			BSTR * i2 = &(V_BSTR(pVarResult));
			hr = pAccessible->get_accDefaultAction(i1, i2);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_BSTR;
			}
			break;
		}
	case DISPID_ACC_SELECTION :				// -5012
		{
			hr = pAccessible->get_accSelection(pVarResult);
			break;
		}
	case DISPID_ACC_FOCUS :					// -5011
		{
			hr = pAccessible->get_accFocus(pVarResult);
			break;
		}
	case DISPID_ACC_KEYBOARDSHORTCUT :		// -5010
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			VARIANT i1 = *rgpParams[0];

			BSTR* i2 = &(V_BSTR(pVarResult));
			hr = pAccessible->get_accKeyboardShortcut(i1, i2);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_BSTR;
			}

			break;
		}
	case DISPID_ACC_HELPTOPIC :				// -5009
		{

			if(pDispParams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			BSTR* i1 = NULL;
			if ((rgpParams[0]->vt & VT_BYREF) && !(rgpParams[0]->vt & (VT_VARIANT | VT_BSTR)))
			{
				hr = DISP_E_TYPEMISMATCH;
				*puArgErr = 0;
				break;
			}
			if (rgpParams[0]->vt == (VT_VARIANT | VT_BYREF))
			{
				VariantClear(V_VARIANTREF(rgpParams[0]));
				V_VARIANTREF(rgpParams[0])->vt = VT_BSTR;
				i1 = &V_BSTR(V_VARIANTREF(rgpParams[0]));
			}
			else if (rgpParams[0]->vt == (VT_BSTR | VT_BYREF))
			{
				i1 = V_BSTRREF(rgpParams[0]);
			}
			else
			{
				VariantClear(rgpParams[0]);
				i1 = &V_BSTR(rgpParams[0]);
				rgpParams[0]->vt = VT_BSTR;
			}

			VARIANT i2 = *rgpParams[1];
			long* i3 = &(V_I4(pVarResult));

			hr = pAccessible->get_accHelpTopic(i1, i2, i3);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_I4;
			}

			break;
		}
	case DISPID_ACC_HELP :					// -5008
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			VARIANT i1 = *rgpParams[0];
			BSTR* i2 = &(V_BSTR(pVarResult));
			hr = pAccessible->get_accHelp(i1, i2);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_BSTR;
			}

			break;
		}
	case DISPID_ACC_STATE :					// -5007
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			VARIANT i1 = *rgpParams[0];
			hr = pAccessible->get_accState(i1, pVarResult);
			break;
		}
	case DISPID_ACC_ROLE :					// -5006
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			VARIANT i1 = *rgpParams[0];
			hr = pAccessible->get_accRole(i1, pVarResult);
			break;
		}
	case DISPID_ACC_DESCRIPTION :			// -5005
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}

			VARIANT i1 = *rgpParams[0];
			BSTR* i2 = &(V_BSTR(pVarResult));
			hr = pAccessible->get_accDescription(i1, i2);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_BSTR;
			}

			break;
		}
	case DISPID_ACC_VALUE :					// -5004
		{
			if (wFlags & 2)
			{
				if(pDispParams->cArgs != 1)
				{
					hr = DISP_E_BADPARAMCOUNT;
					break;
				}

				VARIANT i1 = *rgpParams[0];
				BSTR* i2 = &(V_BSTR(pVarResult));
				hr = pAccessible->get_accValue(i1, i2);
				if(SUCCEEDED(hr))
				{
					pVarResult->vt = VT_BSTR;
				}

				break;
			}
			else if (wFlags & 4)
			{
				if(pDispParams->cArgs != 2)
				{
					hr = DISP_E_BADPARAMCOUNT;
					break;
				}

				VARIANT i1 = *rgpParams[0];

				if (rgpParams[1]->vt != VT_BSTR)
				{
					hr = VariantChangeType(&varg, rgpParams[1], 0, VT_I4);
					if(FAILED(hr))
					{
						*puArgErr = 1;
						break;
					}
					rgpParams[1] = &varg;
				}
				BSTR i2 = V_BSTR(rgpParams[1]);

				hr = pAccessible->put_accValue(i1, i2);
				break;
			}
		}
	case DISPID_ACC_NAME :					// -5003
		{
			if (wFlags & 2)
			{
				if(pDispParams->cArgs != 1)
				{
					hr = DISP_E_BADPARAMCOUNT;
					break;
				}
				VARIANT i1 = *rgpParams[0];

				BSTR* i2 = &(V_BSTR(pVarResult));

				hr = pAccessible->get_accName(i1, i2);

				if(SUCCEEDED(hr))
				{
					pVarResult->vt = VT_BSTR;
				}

				break;
			}
			else if (wFlags & 4)
			{
				if(pDispParams->cArgs != 2)
				{
					hr = DISP_E_BADPARAMCOUNT;
					break;
				}
				VARIANT i1 = *rgpParams[0];

				if (rgpParams[1]->vt != VT_BSTR)
				{
					hr = VariantChangeType(&varg, rgpParams[1], 0, VT_I4);
					if(FAILED(hr))
					{
						*puArgErr = 1;
						break;
					}
					rgpParams[1] = &varg;
				}
				BSTR i2 = V_BSTR(rgpParams[1]);

				hr = pAccessible->put_accName(i1, i2);
				break;
			}
		}
	case DISPID_ACC_CHILD :					// -5002
		{
			if(pDispParams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			VARIANT i1 = *rgpParams[0];

			IDispatch** i2 = &(V_DISPATCH(pVarResult));
			hr = pAccessible->get_accChild(i1, i2);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_DISPATCH;
			}

			break;
		}
	case DISPID_ACC_CHILDCOUNT :			// -5001
		{
			long* i1 = &(V_I4(pVarResult));
			hr = pAccessible->get_accChildCount(i1);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_I4;
			}

			break;
		}
	case DISPID_ACC_PARENT :				// -5000
		{
			IDispatch** i1 = &(V_DISPATCH(pVarResult));
			hr = pAccessible->get_accParent(i1);
			if(SUCCEEDED(hr))
			{
				pVarResult->vt = VT_DISPATCH;
			}

			break;
		}
	default:
		break;
	}

	VariantClear(&varg);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE AtlIAccessibleGetIDsOfNamesHelper(
	_In_ REFIID,
	_In_count_(cNames) _Deref_pre_z_ LPOLESTR *rgszNames,
	_In_ UINT cNames,
	_In_ LCID,
	_Out_cap_(cNames) DISPID *rgDispId)
{
	static LPOLESTR names[] =
	{
		L"accParent",
		L"accChildCount",
		L"accChild",
		L"accName",
		L"accValue",
		L"accDescription",
		L"accRole",
		L"accState",
		L"accHelp",
		L"accHelpTopic",
		L"accKeyboardShortcut",
		L"accFocus",
		L"accSelection",
		L"accDefaultAction",
		L"accSelect",
		L"accLocation",
		L"accNavigate",
		L"accHitTest",
		L"accDoDefaultAction"
	};
	static DISPID dids[] =
	{
		DISPID_ACC_PARENT,				// -5000
		DISPID_ACC_CHILDCOUNT,			// -5001
		DISPID_ACC_CHILD,				// -5002
		DISPID_ACC_NAME,				// -5003
		DISPID_ACC_VALUE,				// -5004
		DISPID_ACC_DESCRIPTION,			// -5005
		DISPID_ACC_ROLE,				// -5006
		DISPID_ACC_STATE,				// -5007
		DISPID_ACC_HELP,				// -5008
		DISPID_ACC_HELPTOPIC,			// -5009
		DISPID_ACC_KEYBOARDSHORTCUT,	// -5010
		DISPID_ACC_FOCUS,				// -5011
		DISPID_ACC_SELECTION,			// -5012
		DISPID_ACC_DEFAULTACTION,		// -5013
		DISPID_ACC_SELECT,				// -5014
		DISPID_ACC_LOCATION,			// -5015
		DISPID_ACC_NAVIGATE,			// -5016
		DISPID_ACC_HITTEST,				// -5017
		DISPID_ACC_DODEFAULTACTION		// -5018
	};
	for (unsigned int i = 0; i < cNames; ++i)
	{
		bool bFoundIt = false;
		for (unsigned int j = 0; j < sizeof(names)/sizeof(LPOLESTR); ++j)
		{
			if (lstrcmpW(rgszNames[i], names[j]) == 0)
			{
				bFoundIt = true;
				rgDispId[i] = dids[j];
			}
		}
		if (!bFoundIt)
		{
			return DISP_E_UNKNOWNNAME;
		}
	}
	return S_OK;
}

} // namespace ATL
#pragma pack(pop)

#endif	// __ATLACC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlalloc.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma once
#ifndef __ATLALLOC_H__
#define __ATLALLOC_H__
#endif

#include <windows.h>
#include <ole2.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

/*
This is	more than a	little unsatisfying. /Wp64 warns when we convert a size_t to an	int
because	it knows such a	conversion won't port.
But, when we have overloaded templates,	there may well exist both conversions and we need
to fool	the	warning	into not firing	on 32 bit builds
*/
#if !defined(_ATL_W64)
#if !defined(__midl) &&	(defined(_X86_)	|| defined(_M_IX86))
#define	_ATL_W64 __w64
#else
#define	_ATL_W64
#endif
#endif

/* Can't use ::std::numeric_limits<T> here because we don't want to introduce a new
   deprendency of this code on SCL
*/

template<typename T>
class AtlLimits;

template<>
class AtlLimits<int _ATL_W64>
{
public:
	static const int _Min=INT_MIN;
	static const int _Max=INT_MAX;
};

template<>
class AtlLimits<unsigned int _ATL_W64>
{
public:
	static const unsigned int _Min=0;
	static const unsigned int _Max=UINT_MAX;
};

template<>
class AtlLimits<long _ATL_W64>
{
public:
	static const long _Min=LONG_MIN;
	static const long _Max=LONG_MAX;
};

template<>
class AtlLimits<unsigned long _ATL_W64>
{
public:
	static const unsigned long _Min=0;
	static const unsigned long _Max=ULONG_MAX;
};

template<>
class AtlLimits<long long>
{
public:
	static const long long _Min=LLONG_MIN;
	static const long long _Max=LLONG_MAX;
};

template<>
class AtlLimits<unsigned long long>
{
public:
	static const unsigned long long _Min=0;
	static const unsigned long long _Max=ULLONG_MAX;
};

/* generic version */
template<typename T>
inline HRESULT AtlAdd(
	_Out_ T* ptResult,
	_In_ T tLeft,
	_In_ T tRight)
{
	if(::ATL::AtlLimits<T>::_Max-tLeft < tRight)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*ptResult= tLeft + tRight;
	return S_OK;
}

/* generic but compariatively slow version */
template<typename T>
inline HRESULT AtlMultiply(
	_Out_ T* ptResult,
	_In_ T tLeft,
	_In_ T tRight)
{
	/* avoid divide 0 */
	if(tLeft==0)
	{
		*ptResult=0;
		return S_OK;
	}
	if(::ATL::AtlLimits<T>::_Max/tLeft < tRight)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*ptResult= tLeft * tRight;
	return S_OK;
}

/* fast	version	for	32 bit integers	*/
template<>
inline HRESULT AtlMultiply(
	_Out_ int _ATL_W64 *piResult,
	_In_ int _ATL_W64 iLeft,
	_In_ int _ATL_W64 iRight)
{
	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);
	if(i64Result>INT_MAX || i64Result < INT_MIN)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*piResult=static_cast<int _ATL_W64>(i64Result);
	return S_OK;
}

template<>
inline HRESULT AtlMultiply(
	_Out_ unsigned int _ATL_W64 *piResult,
	_In_ unsigned int _ATL_W64 iLeft,
	_In_ unsigned int _ATL_W64 iRight)
{
	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);
	if(i64Result>UINT_MAX)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);
	return S_OK;
}

template<>
inline HRESULT AtlMultiply(
	_Out_ long _ATL_W64 *piResult,
	_In_ long _ATL_W64 iLeft,
	_In_ long _ATL_W64 iRight)
{
	__int64 i64Result=static_cast<__int64>(iLeft) * static_cast<__int64>(iRight);
	if(i64Result>LONG_MAX || i64Result < LONG_MIN)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*piResult=static_cast<long _ATL_W64>(i64Result);
	return S_OK;
}

template<>
inline HRESULT AtlMultiply(
	_Out_ unsigned long _ATL_W64 *piResult,
	_In_ unsigned long _ATL_W64 iLeft,
	_In_ unsigned long _ATL_W64 iRight)
{
	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);
	if(i64Result>ULONG_MAX)
	{
		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
	}
	*piResult=static_cast<unsigned long _ATL_W64>(i64Result);
	return S_OK;
}

template <typename T>
inline T AtlMultiplyThrow(
	_In_ T tLeft,
	_In_ T tRight)
{
	T tResult;
	HRESULT hr=AtlMultiply(&tResult, tLeft, tRight);
	if(FAILED(hr))
	{
		AtlThrow(hr);
	}
	return tResult;
}

template <typename T>
inline T AtlAddThrow(
	_In_ T tLeft,
	_In_ T tRight)
{
	T tResult;
	HRESULT hr=AtlAdd(&tResult, tLeft, tRight);
	if(FAILED(hr))
	{
		AtlThrow(hr);
	}
	return tResult;
}

_Ret_opt_bytecount_x_(nCount * nSize) inline LPVOID AtlCoTaskMemCAlloc(
	_In_ ULONG nCount,
	_In_ ULONG nSize)
{
	HRESULT hr;
	ULONG nBytes=0;
	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))
	{
		return NULL;
	}
	return ::CoTaskMemAlloc(nBytes);
}

_Ret_opt_bytecount_x_(nCount * nSize) inline LPVOID AtlCoTaskMemRecalloc(
	_In_opt_ void *pvMemory,
	_In_ ULONG nCount,
	_In_ ULONG nSize)
{
	HRESULT hr;
	ULONG nBytes=0;
	if( FAILED(hr=::ATL::AtlMultiply(&nBytes, nCount, nSize)))
	{
		return NULL;
	}
	return ::CoTaskMemRealloc(pvMemory, nBytes);
}

}	// namespace ATL
#pragma pack(pop)

#pragma pack(push,8)
namespace ATL
{
// forward declaration of Checked::memcpy_s

namespace Checked
{
    void __cdecl memcpy_s(
		_Out_bytecap_post_bytecount_(_S1max,_N) void *s1,
		_In_ size_t _S1max,
		_In_bytecount_(_N) const void *s2,
		_In_ size_t _N);
}

/////////////////////////////////////////////////////////////////////////////
// Allocation helpers

class CCRTAllocator
{
public:
	_Ret_opt_bytecap_(nBytes) static void* Reallocate(
		_In_ void* p,
		_In_ size_t nBytes) throw()
	{
		return realloc(p, nBytes);
	}

	_Ret_opt_bytecap_(nBytes) static void* Allocate(_In_ size_t nBytes) throw()
	{
		return malloc(nBytes);
	}

	static void Free(_In_ void* p) throw()
	{
		free(p);
	}
};

class CLocalAllocator
{
public:
	_Ret_opt_bytecap_(nBytes) static void* Allocate(_In_ size_t nBytes) throw()
	{
		return ::LocalAlloc(LMEM_FIXED, nBytes);
	}
	_Ret_opt_bytecap_(nBytes) static void* Reallocate(
		_In_ void* p,
		_In_ size_t nBytes) throw()
	{
		if (p==NULL){
			return ( Allocate(nBytes) );

		}
		if (nBytes==0){
			Free(p);
			return NULL;
		}
		return SAL_Assume_bytecap_for_opt_(::LocalReAlloc(p, nBytes, 0), nBytes);
	}
	static void Free(_In_ void* p) throw()
	{
		::LocalFree(p);
	}
};

class CGlobalAllocator
{
public:
	_Ret_opt_bytecap_(nBytes) static void* Allocate(_In_ size_t nBytes) throw()
	{
		return ::GlobalAlloc(GMEM_FIXED, nBytes);
	}
	_Ret_opt_bytecap_(nBytes) static void* Reallocate(
		_In_ void* p,
		_In_ size_t nBytes) throw()
	{
		if (p==NULL){
			return ( Allocate(nBytes) );

		}
		if (nBytes==0){
			Free(p);
			return NULL;
		}
		return SAL_Assume_bytecap_for_opt_(::GlobalReAlloc(p, nBytes, 0), nBytes);
	}
	static void Free(_In_ void* p) throw()
	{
		::GlobalFree(p);
	}
};

template <class T, class Allocator = CCRTAllocator>
class CHeapPtrBase
{
protected:
	CHeapPtrBase() throw() :
		m_pData(NULL)
	{
	}
	CHeapPtrBase(_Inout_ CHeapPtrBase<T, Allocator>& p) throw()
	{
		m_pData = p.Detach();  // Transfer ownership
	}
	explicit CHeapPtrBase(_In_ T* pData) throw() :
		m_pData(pData)
	{
	}

public:
	~CHeapPtrBase() throw()
	{
		Free();
	}

protected:
	CHeapPtrBase<T, Allocator>& operator=(_Inout_ CHeapPtrBase<T, Allocator>& p) throw()
	{
		if(m_pData != p.m_pData)
			Attach(p.Detach());  // Transfer ownership
		return *this;
	}

public:
	operator T*() const throw()
	{
		return m_pData;
	}

	T* operator->() const throw()
	{
		ATLASSERT(m_pData != NULL);
		return m_pData;
	}

	T** operator&() throw()
	{
		ATLASSUME(m_pData == NULL);
		return &m_pData;
	}

	// Allocate a buffer with the given number of bytes
	bool AllocateBytes(_In_ size_t nBytes) throw()
	{
		ATLASSERT(m_pData == NULL);
		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));
		if (m_pData == NULL)
			return false;

		return true;
	}

	// Attach to an existing pointer (takes ownership)
	void Attach(_In_ T* pData) throw()
	{
		Allocator::Free(m_pData);
		m_pData = pData;
	}

	// Detach the pointer (releases ownership)
	T* Detach() throw()
	{
		T* pTemp = m_pData;
		m_pData = NULL;
		return pTemp;
	}

	// Free the memory pointed to, and set the pointer to NULL
	void Free() throw()
	{
		Allocator::Free(m_pData);
		m_pData = NULL;
	}

	// Reallocate the buffer to hold a given number of bytes
	bool ReallocateBytes(_In_ size_t nBytes) throw()
	{
		T* pNew;

		pNew = static_cast<T*>(Allocator::Reallocate(m_pData, nBytes));
		if (pNew == NULL)
			return false;
		m_pData = pNew;

		return true;
	}

public:
	T* m_pData;
};

template <typename T, class Allocator = CCRTAllocator>
class CHeapPtr :
	public CHeapPtrBase<T, Allocator>
{
public:
	CHeapPtr() throw()
	{
	}
	CHeapPtr(_Inout_ CHeapPtr<T, Allocator>& p) throw() :
		CHeapPtrBase<T, Allocator>(p)
	{
	}
	explicit CHeapPtr(_In_ T* p) throw() :
		CHeapPtrBase<T, Allocator>(p)
	{
	}

	CHeapPtr<T, Allocator>& operator=(_Inout_ CHeapPtr<T, Allocator>& p) throw()
	{
		CHeapPtrBase<T, Allocator>::operator=(p);

		return *this;
	}

	// Allocate a buffer with the given number of elements
	bool Allocate(_In_ size_t nElements = 1) throw()
	{
		size_t nBytes=0;
		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))
		{
			return false;
		}
		return AllocateBytes(nBytes);
	}

	// Reallocate the buffer to hold a given number of elements
	bool Reallocate(_In_ size_t nElements) throw()
	{
		size_t nBytes=0;
		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))
		{
			return false;
		}
		return ReallocateBytes(nBytes);
	}
};

template< typename T, int t_nFixedBytes = 128, class Allocator = CCRTAllocator >
class CTempBuffer
{
public:
	CTempBuffer() throw() :
		m_p( NULL )
	{
	}
	CTempBuffer(_In_ size_t nElements) throw( ... ) :
		m_p( NULL )
	{
		Allocate( nElements );
	}

	~CTempBuffer() throw()
	{
		if( m_p != reinterpret_cast< T* >( m_abFixedBuffer ) )
		{
			FreeHeap();
		}
	}

	operator T*() const throw()
	{
		return( m_p );
	}
	T* operator->() const throw()
	{
		ATLASSERT( m_p != NULL );
		return( m_p );
	}

	_Ret_opt_bytecap_x_(nElements * sizeof(T)) T* Allocate(_In_ size_t nElements) throw( ... )
	{
		return( AllocateBytes( ::ATL::AtlMultiplyThrow(nElements,sizeof( T )) ) );
	}

	_Ret_opt_bytecap_x_(nElements * sizeof(T)) T* Reallocate(_In_ size_t nElements) throw( ... )
	{
		ATLENSURE(nElements < size_t(-1)/sizeof(T) );
		size_t nNewSize = nElements*sizeof( T ) ;

		if (m_p == NULL)
			return AllocateBytes(nNewSize);

		if (nNewSize > t_nFixedBytes)
		{
			if( m_p == reinterpret_cast< T* >( m_abFixedBuffer ) )
			{
				// We have to allocate from the heap and copy the contents into the new buffer
				AllocateHeap(nNewSize);
				Checked::memcpy_s(m_p, nNewSize, m_abFixedBuffer, t_nFixedBytes);
			}
			else
			{
				ReAllocateHeap( nNewSize );
			}
		}
		else
		{
			if (m_p != reinterpret_cast< T* >( m_abFixedBuffer ))
			{
				Checked::memcpy_s(m_abFixedBuffer, t_nFixedBytes, m_p, nNewSize);
				FreeHeap();
			}
			m_p = reinterpret_cast< T* >( m_abFixedBuffer );
		}

		return m_p;
	}

	_Ret_opt_bytecap_(nBytes) T* AllocateBytes(_In_ size_t nBytes)
	{
		ATLASSERT( m_p == NULL );
		if( nBytes > t_nFixedBytes )
		{
			AllocateHeap( nBytes );
		}
		else
		{
			m_p = reinterpret_cast< T* >( m_abFixedBuffer );
		}

		return( m_p );
	}

private:
	ATL_NOINLINE void AllocateHeap(_In_ size_t nBytes)
	{
		T* p = static_cast< T* >( Allocator::Allocate( nBytes ) );
		if( p == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		m_p = p;
	}

	ATL_NOINLINE void ReAllocateHeap(_In_ size_t nNewSize)
	{
		T* p = static_cast< T* >( Allocator::Reallocate(m_p, nNewSize) );
		if ( p == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		m_p = p;
	}

	ATL_NOINLINE void FreeHeap() throw()
	{
		Allocator::Free( m_p );
	}

private:
	T* m_p;
	BYTE m_abFixedBuffer[t_nFixedBytes];
};


// Allocating memory on the stack without causing stack overflow.
// Only use these through the _ATL_SAFE_ALLOCA_* macros
namespace _ATL_SAFE_ALLOCA_IMPL
{

#ifndef _ATL_STACK_MARGIN
#if defined(_M_IX86)
#define _ATL_STACK_MARGIN	0x2000	// Minimum stack available after call to _ATL_SAFE_ALLOCA
#else //_M_AMD64 _M_IA64
#define _ATL_STACK_MARGIN	0x4000
#endif
#endif //_ATL_STACK_MARGIN

//Verifies if sufficient space is available on the stack.
//Note: This function should never be inlined, because the stack allocation
//may not be freed until the end of the calling function (instead of the end of _AtlVerifyStackAvailable).
__declspec(noinline) inline bool _AtlVerifyStackAvailable(_In_ SIZE_T Size)
{
    bool bStackAvailable = true;

    __try
    {
		SIZE_T size=0;
		HRESULT hrAdd=::ATL::AtlAdd(&size, Size, static_cast<SIZE_T>(_ATL_STACK_MARGIN));
		if(FAILED(hrAdd))
		{
			ATLASSERT(FALSE);
			bStackAvailable = false;
		}
		else
		{
			PVOID p = _alloca(size);
			(p);
		}
    }
    __except ((EXCEPTION_STACK_OVERFLOW == GetExceptionCode()) ?
                   EXCEPTION_EXECUTE_HANDLER :
                   EXCEPTION_CONTINUE_SEARCH)
    {
        bStackAvailable = false;
        _resetstkoflw();
    }
    return bStackAvailable;
}


// Helper Classes to manage heap buffers for _ATL_SAFE_ALLOCA
template < class Allocator>
class CAtlSafeAllocBufferManager
{
private :
	struct CAtlSafeAllocBufferNode
	{
		CAtlSafeAllocBufferNode* m_pNext;
#if defined(_M_IX86)
		BYTE _pad[4];
#elif defined(_M_IA64)
		BYTE _pad[8];
#elif defined(_M_AMD64)
		BYTE _pad[8];
#else
	#error Only supported for X86, AMD64 and IA64
#endif
		void* GetData()
		{
			return (this + 1);
		}
	};

	CAtlSafeAllocBufferNode* m_pHead;
public :

	CAtlSafeAllocBufferManager() : m_pHead(NULL)
	{
	}
	_Ret_opt_bytecap_(nRequestedSize) void* Allocate(_In_ SIZE_T nRequestedSize)
	{
		CAtlSafeAllocBufferNode *p = (CAtlSafeAllocBufferNode*)Allocator::Allocate(::ATL::AtlAddThrow(nRequestedSize, static_cast<SIZE_T>(sizeof(CAtlSafeAllocBufferNode))));
		if (p == NULL)
			return NULL;

		// Add buffer to the list
		p->m_pNext = m_pHead;
		m_pHead = p;

		return p->GetData();
	}
	~CAtlSafeAllocBufferManager()
	{
		// Walk the list and free the buffers
		while (m_pHead != NULL)
		{
			CAtlSafeAllocBufferNode* p = m_pHead;
			m_pHead = m_pHead->m_pNext;
			Allocator::Free(p);
		}
	}
};

}	// namespace _ATL_SAFE_ALLOCA_IMPL

}	// namespace ATL
 #pragma pack(pop)

// Use one of the following macros before using _ATL_SAFE_ALLOCA
// EX version allows specifying a different heap allocator
#define USES_ATL_SAFE_ALLOCA_EX(x)    ATL::_ATL_SAFE_ALLOCA_IMPL::CAtlSafeAllocBufferManager<x> _AtlSafeAllocaManager

#ifndef USES_ATL_SAFE_ALLOCA
#define USES_ATL_SAFE_ALLOCA		USES_ATL_SAFE_ALLOCA_EX(ATL::CCRTAllocator)
#endif

// nRequestedSize - requested size in bytes
// nThreshold - size in bytes beyond which memory is allocated from the heap.

// Defining _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE always allocates the size specified
// for threshold if the stack space is available irrespective of requested size.
// This available for testing purposes. It will help determine the max stack usage due to _alloca's
// Disable _alloca not within try-except prefast warning since we verify stack space is available before.
#ifdef _ATL_SAFE_ALLOCA_ALWAYS_ALLOCATE_THRESHOLD_SIZE
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
	__pragma(warning(push))\
	__pragma(warning(disable:4616))\
	__pragma(warning(disable:6255))\
	((nRequestedSize <= nThreshold && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold) ) ?	\
		_alloca(nThreshold) :	\
		((ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nThreshold)) ? _alloca(nThreshold) : 0),	\
			_AtlSafeAllocaManager.Allocate(nRequestedSize))\
	__pragma(warning(pop))
#else
#define _ATL_SAFE_ALLOCA(nRequestedSize, nThreshold)	\
	__pragma(warning(push))\
	__pragma(warning(disable:4616))\
	__pragma(warning(disable:6255))\
	((nRequestedSize <= nThreshold && ATL::_ATL_SAFE_ALLOCA_IMPL::_AtlVerifyStackAvailable(nRequestedSize) ) ?	\
		_alloca(nRequestedSize) :	\
		_AtlSafeAllocaManager.Allocate(nRequestedSize))\
	__pragma(warning(pop))
#endif

// Use 1024 bytes as the default threshold in ATL
#ifndef _ATL_SAFE_ALLOCA_DEF_THRESHOLD
#define _ATL_SAFE_ALLOCA_DEF_THRESHOLD	1024
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlbase.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_INL__
#define __ATLBASE_INL__

#pragma once

#ifndef __ATLBASE_H__
	#error atlbase.inl requires atlbase.h to be included first
#endif
#pragma warning(push)
#pragma warning(disable:4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(
	_Inout_ IUnknown* pUnkCP,
	_Inout_opt_ IUnknown* pUnk,
	_In_ const IID& iid,
	_Out_ LPDWORD pdw)
{
	if(pUnkCP == NULL)
		return E_INVALIDARG;

	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(
	_Inout_ IUnknown* pUnkCP,
	_In_ const IID& iid,
	_In_ DWORD dw)
{
	if(pUnkCP == NULL)
		return E_INVALIDARG;

	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(_Inout_ IStream* pStream)
{
	HRESULT hRes=S_OK;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes=CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return hRes;
}

ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlMarshalPtrInProc(
	_Inout_ IUnknown* pUnk,
	_In_ const IID& iid,
	_Deref_out_ IStream** ppStream)
{
	ATLASSERT(ppStream != NULL);
	if (ppStream == NULL)
		return E_POINTER;

	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}
ATLPREFAST_UNSUPPRESS()

ATLINLINE ATLAPI AtlUnmarshalPtr(
	_Inout_ IStream* pStream,
	_In_ const IID& iid,
	_Deref_out_ IUnknown** ppUnk)
{
	ATLASSERT(ppUnk != NULL);
	if (ppUnk == NULL)
		return E_POINTER;

	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module
ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlComModuleGetClassObject(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ REFCLSID rclsid,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv)
{
	if (ppv == NULL)
	{
		return E_POINTER;
	}

	*ppv = NULL;

	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
	{
		return E_INVALIDARG;
	}

	if (pComModule->cbSize == 0)  // Module hasn't been initialized
	{
		return E_UNEXPECTED;
	}

	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			const _ATL_OBJMAP_ENTRY* pEntry = *ppEntry;

			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
			{
				if (pEntry->pCF == NULL)
				{
					CComCritSecLock<CComCriticalSection> lock(pComModule->m_csObjMap, false);
					hr = lock.Lock();
					if (FAILED(hr))
					{
						ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in AtlComModuleGetClassObject\n"));
						ATLASSERT(FALSE);
						break;
					}

					if (pEntry->pCF == NULL)
					{
						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
					}
				}

				if (pEntry->pCF != NULL)
				{
					hr = pEntry->pCF->QueryInterface(riid, ppv);
				}
				break;
			}
		}
	}

	if (*ppv == NULL && hr == S_OK)
	{
		hr = CLASS_E_CLASSNOTAVAILABLE;
	}

	return hr;
}
ATLPREFAST_UNSUPPRESS()

ATLINLINE ATLAPI AtlComModuleRegisterClassObjects(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ DWORD dwClsContext,
	_In_ DWORD dwFlags)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_FALSE;
	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast && SUCCEEDED(hr); ppEntry++)
	{
		if (*ppEntry != NULL)
			hr = (*ppEntry)->RegisterClassObject(dwClsContext, dwFlags);
	}
	return hr;
}

ATLINLINE ATLAPI AtlComModuleRevokeClassObjects(
	_Inout_ _ATL_COM_MODULE* pComModule)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast && hr == S_OK; ppEntry++)
	{
		if (*ppEntry != NULL)
			hr = (*ppEntry)->RevokeClassObject();
	}
	return hr;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(_In_ HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjectsEx(1, &hEvent, INFINITE, QS_ALLINPUT, MWMO_INPUTAVAILABLE);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,0,0,0,PM_NOREMOVE))
		{
			// check for unicode window so we call the appropriate functions
			BOOL bUnicode = ::IsWindowUnicode(msg.hwnd);
			BOOL bRet;

			if (bUnicode)
				bRet = ::GetMessageW(&msg, NULL, 0, 0);
			else
				bRet = ::GetMessageA(&msg, NULL, 0, 0);

			if (bRet > 0)
			{
				::TranslateMessage(&msg);

				if (bUnicode)
					::DispatchMessageW(&msg);
				else
					::DispatchMessageA(&msg);
			}

			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// QI support
ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlInternalQueryInterface(
	_Inout_ void* pThis,
	_In_ const _ATL_INTMAP_ENTRY* pEntries,
	_In_ REFIID iid,
	_Deref_out_ void** ppvObject)
{
	ATLASSERT(pThis != NULL);
	ATLASSERT(pEntries!= NULL);

	if(pThis == NULL || pEntries == NULL)
		return E_INVALIDARG;

	// First entry in the com map should be a simple map entry
	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				ATLASSERT(!bBlind);
				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}
ATLPREFAST_UNSUPPRESS()

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(_In_opt_ void* /* pReserved */)
{
	return _ATL_VER;
}

/////////////////////////////////////////////////////////////////////////////
// Windowing

ATLINLINE ATLAPI_(void) AtlWinModuleAddCreateWndData(
	_Inout_ _ATL_WIN_MODULE* pWinModule,
	_Inout_ _AtlCreateWndData* pData,
	_In_ void* pObject)
{
	if (pWinModule == NULL)
		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);

	ATLASSERT(pData != NULL && pObject != NULL);
	if(pData == NULL || pObject == NULL)
		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);

	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlWinModuleAddCreateWndData\n"));
		ATLASSERT(0);
		return;
	}
	pData->m_pNext = pWinModule->m_pCreateWndList;
	pWinModule->m_pCreateWndList = pData;
}

ATLINLINE ATLAPI_(void*) AtlWinModuleExtractCreateWndData(
	_Inout_opt_ _ATL_WIN_MODULE* pWinModule)
{
	if (pWinModule == NULL)
		return NULL;

	void* pv = NULL;
	CComCritSecLock<CComCriticalSection> lock(pWinModule->m_csWindowCreate, false);
	if (FAILED(lock.Lock()))
	{
		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to lock critical section in AtlWinModuleExtractCreateWndData\n"));
		ATLASSERT(0);
		return pv;
	}
	_AtlCreateWndData* pEntry = pWinModule->m_pCreateWndList;
	if(pEntry != NULL)
	{
		DWORD dwThreadID = ::GetCurrentThreadId();
		_AtlCreateWndData* pPrev = NULL;
		while(pEntry != NULL)
		{
			if(pEntry->m_dwThreadID == dwThreadID)
			{
				if(pPrev == NULL)
					pWinModule->m_pCreateWndList = pEntry->m_pNext;
				else
					pPrev->m_pNext = pEntry->m_pNext;
				pv = pEntry->m_pThis;
				break;
			}
			pPrev = pEntry;
			pEntry = pEntry->m_pNext;
		}
	}
	return pv;
}

ATLINLINE ATLAPI AtlWinModuleInit(
	_Inout_ _ATL_WIN_MODULE* pWinModule)
{
	if (pWinModule == NULL)
		return E_INVALIDARG;

	// check only in the DLL
	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))
		return E_INVALIDARG;

	pWinModule->m_pCreateWndList = NULL;

	HRESULT hr = pWinModule->m_csWindowCreate.Init();
	if (FAILED(hr))
	{
		ATLTRACE(atlTraceWindowing, 0, _T("ERROR : Unable to initialize critical section in AtlWinModuleInit\n"));
		ATLASSERT(0);
	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Module

ATLINLINE ATLAPI AtlModuleAddTermFunc(
	_Inout_ _ATL_MODULE* pModule,
	_In_ _ATL_TERMFUNC* pFunc,
	_In_ DWORD_PTR dw)
{
	if (pModule == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	_ATL_TERMFUNC_ELEM* pNew = NULL;
	ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
	if (pNew == NULL)
		hr = E_OUTOFMEMORY;
	else
	{
		pNew->pFunc = pFunc;
		pNew->dw = dw;
		CComCritSecLock<CComCriticalSection> lock(pModule->m_csStaticDataInitAndTypeInfo, false);
		hr = lock.Lock();
		if (SUCCEEDED(hr))
		{
			pNew->pNext = pModule->m_pTermFuncs;
			pModule->m_pTermFuncs = pNew;
		}
		else
		{
			delete pNew;
			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to lock critical section in AtlModuleAddTermFunc\n"));
			ATLASSERT(0);
		}
	}
	return hr;
}

ATLINLINE ATLAPI_(void) AtlCallTermFunc(_Inout_ _ATL_MODULE* pModule)
{
	if (pModule == NULL)
		_AtlRaiseException((DWORD)EXCEPTION_ACCESS_VIOLATION);

	_ATL_TERMFUNC_ELEM* pElem = pModule->m_pTermFuncs;
	_ATL_TERMFUNC_ELEM* pNext = NULL;
	while (pElem != NULL)
	{
		pElem->pFunc(pElem->dw);
		pNext = pElem->pNext;
		delete pElem;
		pElem = pNext;
	}
	pModule->m_pTermFuncs = NULL;
}

} // namespace ATL
#pragma warning(pop)
#endif // __ATLBASE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlbuild.h ===
// ATLMFC build numbers (YYMMDD)
#pragma once
#define _LIBS_BUILD 30319
#define _LIBS_USER_BUILD "30319"

#define _LIBS_PRODUCT_VERSION_MAJOR 10
#define _LIBS_USER_PRODUCT_VERSION_MAJOR "10"
#define _LIBS_PRODUCT_VERSION_MINOR 0
#define _LIBS_USER_PRODUCT_VERSION_MINOR "00"

#define _LIBS_FILE_VERSION_MAJOR 10
#define _LIBS_USER_FILE_VERSION_MAJOR "10"
#define _LIBS_FILE_VERSION_MINOR 0
#define _LIBS_USER_FILE_VERSION_MINOR "00"
#define _LIBS_USER_FULL_VER "10.00.30319"

#ifndef _LIBS_RBLD
#define _LIBS_RBLD 01
#define _LIBS_USER_RBLD "01"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\afxwinforms.inl ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWINFORMS.H

#pragma warning(disable:4439)	// C4439: function with a managed parameter must have a __clrcall calling convention

extern "C" void AfxmEnsureManagedInitialization();
extern "C" void AfxmReleaseManagedReferences(IUnknown*);

namespace Microsoft {
	namespace VisualC {
		namespace MFC {

#ifndef AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD
#define AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD

//CWinFormsEventsHelper
inline CWinFormsEventsHelper::CWinFormsEventsHelper() 
    {	
		m_pSink = NULL;
	}	
inline void CWinFormsEventsHelper::Control::set(System::Windows::Forms::Control^ pControl)
	{
		ENSURE_ARG(pControl!=nullptr);
		ENSURE(m_pControl == nullptr);
		m_pControl=pControl;
		  m_pControl->HandleCreated += 
			  gcnew System::EventHandler(this, &CWinFormsEventsHelper::OnHandleCreated);
		  m_pControl->HandleDestroyed += 
			  gcnew System::EventHandler(this, &CWinFormsEventsHelper::OnHandleDestroyed);

	}
inline System::Windows::Forms::Control^ CWinFormsEventsHelper::Control::get()
	{
		return m_pControl;
	}
inline void CWinFormsEventsHelper::Advise(IHandleEvents* pSink)
	{	
		ENSURE_ARG(pSink!=NULL);
		ENSURE_ARG(m_pSink == NULL || m_pSink == pSink);
		m_pSink = pSink;
	}

inline void CWinFormsEventsHelper::Unadvise(IHandleEvents* pSink)
	{
		ENSURE_ARG(m_pSink == NULL || m_pSink == pSink);
		m_pSink = NULL;
	}

inline void CWinFormsEventsHelper::OnHandleCreated( System::Object^ o, System::EventArgs^ args)
	{
		if (m_pSink)
		{
			m_pSink->OnHandleCreated(o, args);
		}
	}
inline void CWinFormsEventsHelper::OnHandleDestroyed( System::Object^ o, System::EventArgs^ args)
	{
		if (m_pSink)
		{
			m_pSink->OnHandleDestroyed(o, args);
		}
		
	}

//CWinFormsControl<class TManagedControl>

template<class TManagedControl>
CWinFormsControl<TManagedControl>::CWinFormsControl()
	{		
	}

template<class TManagedControl>
inline TManagedControl^ CWinFormsControl<TManagedControl>::GetControl() const
	{
		CWinFormsControlSite* pSite=static_cast<CWinFormsControlSite*>(m_pCtrlSite);
		TManagedControl^ pCtrl=nullptr;
		if (pSite)
		{
			pCtrl=static_cast<TManagedControl^>(pSite->get_Control());
		}
		return pCtrl;
	}

template<class TManagedControl>
inline CWinFormsControl<TManagedControl>::operator TManagedControl^() const
	{
		return GetControl();
	}

template<class TManagedControl>
inline TManagedControl^ CWinFormsControl<TManagedControl>::operator->() const
	{
		return GetControl();
	}

template<class TManagedControl>
inline HWND CWinFormsControl<TManagedControl>::GetControlHandle() const
	{
		return reinterpret_cast<HWND>(static_cast<INT_PTR>(GetControl()->Handle));
	}	
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::InternalCreateManagedControl(const CControlCreationInfo& info,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
{
	CRect rect2( rect );
	CPoint pt;
	CSize size;

	pt = rect2.TopLeft();
	size = rect2.Size();
	AfxmEnsureManagedInitialization();
	pParentWnd->m_nFlags |= WF_NOWIN32ISDIALOGMSG;
	return CreateControl(info,dwStyle,&pt,&size,pParentWnd,nID);
}

template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(System::Type^ pType,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
	{
		//Marshal the .Net Type a GCHandle to pass through native MFC.
		CControlCreationInfoEx info;
		info.Init(pType,CControlCreationInfo::ReflectionType);
		info.m_clsid=CLSID_WinFormsControl;
		return InternalCreateManagedControl(info,dwStyle,rect,pParentWnd,nID);		
	}

template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(TManagedControl^ pControl,DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, int nID)
	{
		ENSURE_ARG(pControl!=nullptr);
		CControlCreationInfoEx info;
		info.Init(pControl,CControlCreationInfo::ControlInstance);
		info.m_clsid=CLSID_WinFormsControl;
		return InternalCreateManagedControl(info,dwStyle,rect,pParentWnd,nID);		
	}
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(DWORD dwStyle,const RECT& rect, CWnd* pParentWnd, int nID)
	{
		return CreateManagedControl(TManagedControl::typeid,dwStyle,rect, pParentWnd, nID);		
	}
template<class TManagedControl>
inline BOOL CWinFormsControl<TManagedControl>::CreateManagedControl(DWORD dwStyle,
		int nPlaceHolderID, CWnd* pParentWnd)
	{		
		ENSURE_ARG(pParentWnd!=NULL);
		CWnd* pwnd = pParentWnd->GetDlgItem(nPlaceHolderID);
		CRect rectPlaceHolder;
		ENSURE(pwnd != NULL);
		pwnd->GetWindowRect(&rectPlaceHolder);
		pParentWnd->ScreenToClient(rectPlaceHolder);
		//Combine caller supplied with place holder styles.
		DWORD controlStyle = dwStyle | pwnd->GetStyle();		
		BOOL ret=CreateManagedControl(controlStyle,rectPlaceHolder,pParentWnd,nPlaceHolderID);
		// Set ZOrder only, so managed control replaces the STATIC place holder in the child windows list.
		// This list affects Z-Order and Tab order.

		ASSERT(GetControlHandle()!=NULL);
		BOOL ok=::SetWindowPos(GetControlHandle(), pwnd->m_hWnd, 0, 0, 0, 0,
			SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
		ASSERT(ok);
				
		
		//Also need to change the linked list of tab order, maintained to support MFC implementation of 
		//IsDialogMessage, to delete the last entry (added by CreateControl), and change the place holder
		//entry, to point at our new control.
		COleControlSiteOrWnd *pThisSitePlaceHolderWnd=_AfxFindSiteOrWnd(pParentWnd,this);
		COleControlSiteOrWnd *pSitePlaceHolderWnd=_AfxFindSiteOrWnd(pParentWnd,pwnd);
		POSITION posRemove=pParentWnd->GetControlContainer()->m_listSitesOrWnds.Find(pThisSitePlaceHolderWnd);
		ASSERT(posRemove != NULL);
		if (posRemove)
		{
			pParentWnd->GetControlContainer()->m_listSitesOrWnds.RemoveAt(posRemove);
			ENSURE(pThisSitePlaceHolderWnd!=NULL);
			pThisSitePlaceHolderWnd->m_pSite = NULL; //So delete m_pSite in COleControlSiteOrWnd will not destory the site.
			delete pThisSitePlaceHolderWnd;
		}

		ASSERT(pSitePlaceHolderWnd);
		if (pSitePlaceHolderWnd)
		{
			pSitePlaceHolderWnd->m_hWnd = NULL;
			pSitePlaceHolderWnd->m_pSite = GetControlSite();
		}

		pwnd->DestroyWindow();
		return ret;
	}

///////////////////////////////////////////////////////////////////////////////
//CWinFormsDialog

BEGIN_TEMPLATE_MESSAGE_MAP(CWinFormsDialog, TManagedControl, CDialog)
	ON_WM_SIZE()
END_MESSAGE_MAP()

template <typename TManagedControl>
CWinFormsDialog<TManagedControl>::CWinFormsDialog(UINT nIDTemplate, CWnd* pParentWnd)
: CDialog(nIDTemplate, pParentWnd)
{
	m_pWFControl = gcnew TManagedControl();
}

template <typename TManagedControl>
BOOL CWinFormsDialog<TManagedControl>::OnInitDialog()
{	
	BOOL bRet=CDialog::OnInitDialog();
	ENSURE(bRet);
	//Create an instance of the control and retrieve its Size
	TManagedControl^ pControl = m_pWFControl;
	//Adjust the size of the dialog to accommodate for the control size.	
	CRect rcDlg;
	GetWindowRect(&rcDlg);	
	CRect rcDlgClient;
	GetClientRect(&rcDlgClient);
	ClientToScreen(&rcDlgClient);
	rcDlg.bottom -= rcDlgClient.Height();
	rcDlg.bottom +=  pControl->Size.Height;
	rcDlg.right  = rcDlg.left + pControl->Size.Width;
	MoveWindow(&rcDlg,FALSE);

	//Set title text to match control Text property
	CString title(pControl->Text);
	SetWindowText(title.GetString());
	//Host the new control in the mfc dialog
	CControlCreationInfoEx info;
	info.Init(pControl,CControlCreationInfo::ControlInstance);
	info.m_clsid=CLSID_WinFormsControl;	

	CRect rcCtrl;
	rcCtrl.top  = 0;
	rcCtrl.left = 0;
	rcCtrl.bottom = pControl->Size.Height;
	rcCtrl.right  = pControl->Size.Width;
	bRet=m_control.InternalCreateManagedControl(info,WS_VISIBLE | WS_TABSTOP,rcCtrl,this,IDC_WINFRMCTRL_DIALOG);

	ENSURE(GetControlHandle()!=NULL && bRet);
	return TRUE;
}
template <typename TManagedControl>
inline TManagedControl^ CWinFormsDialog<TManagedControl>::GetControl() const
	{
		return m_pWFControl;
	}

template <typename TManagedControl>
inline CWinFormsDialog<TManagedControl>::operator TManagedControl^() const
	{
		return GetControl();
	}

template <typename TManagedControl>
inline TManagedControl^ CWinFormsDialog<TManagedControl>::operator->() const
	{
		return GetControl();
	}

template <typename TManagedControl>
inline HWND CWinFormsDialog<TManagedControl>::GetControlHandle() const
	{
		return reinterpret_cast<HWND>(static_cast<INT_PTR>(GetControl()->Handle));
	}

template <typename TManagedControl>
void CWinFormsDialog<TManagedControl>::OnSize(UINT nType, int cx, int cy)
{		
	__super::OnSize(nType, cx, cy);

	//When view size changes, adjust the WinForms control (which is child of the view) 
	//size to occupy the entire client area of the view.
	CRect rcView;
	GetClientRect(&rcView);
	System::Drawing::Size size(rcView.Width(), rcView.Height());

	if (GetControl()!=nullptr)
	{
		GetControl()->Size = size;
	}
}

template <typename T>
void DDX_ManagedControl(CDataExchange* pDX, int nIDC,CWinFormsControl<T>& control)
{	
	if ((control.m_hWnd == NULL) && (control.GetControlUnknown() == NULL))    // not attached yet	
	{
		ASSERT(!pDX->m_bSaveAndValidate);		

		if (!control.CreateManagedControl(0,nIDC, pDX->m_pDlgWnd))
		{
			ASSERT(FALSE);
			AfxThrowNotSupportedException();
		}
	}
}

#endif //AFXWFRM_TEMPLATES_INL_INCLUDE_GUARD

#ifndef METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE
#define METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE
//Inline in both Debug and Release - workaround for non-exportable __clrcall methods.

inline void CWinFormsControlSite::OnHandleCreated( System::Object^ , System::EventArgs^ )
	{		
		OnHandleCreatedHandler();
	}

inline void CWinFormsControlSite::OnHandleDestroyed( System::Object^ , System::EventArgs^ )
	{		
		DetachWindow();
	}

inline void CControlCreationInfoEx::Init(System::Object^ p,HandleKind hk)
	{
		// no need to check for valid handle; was allocated in ctor
		(GCHandle::operator GCHandle(static_cast<System::IntPtr>(m_nHandle) )).Target = p;		
		m_hk=hk;
	}

inline System::Windows::Forms::Control^  CWinFormsControlSite::get_Control() const
	{		
		System::Windows::Forms::Control^ pControl=m_gcEventHelper->Control::get();
		ENSURE((CWinFormsEventsHelper^)m_gcEventHelper!=nullptr && pControl!=nullptr);
		return pControl;
	}

//CWinFormsView
inline CWinFormsView::CWinFormsView(System::Type^ pManagedViewType)
	: m_pManagedViewType(pManagedViewType)
	{					
		ASSERT((System::Type^)m_pManagedViewType!=nullptr);		
	}

inline System::Windows::Forms::Control^ CWinFormsView::GetControl() const
	{
		return m_control.GetControl();
	}

inline CWinFormsView::operator System::Windows::Forms::Control^() const
	{
		return GetControl();
	}

#endif //METHODS_INLINED_IN_BOTH_DEBUG_AND_RELEASE

#ifdef _AFXWIN_INLINE
#ifndef AFXWFRM_INL_INCLUDE_GUARD
#define AFXWFRM_INL_INCLUDE_GUARD

//CControlCreationInfoEx
_AFXWIN_INLINE CControlCreationInfoEx::CControlCreationInfoEx()
	{		
		m_nHandle = static_cast<intptr_t>( GCHandle::operator System::IntPtr(GCHandle::Alloc(nullptr)) );
	}

_AFXWIN_INLINE CControlCreationInfoEx::~CControlCreationInfoEx()
	{
		GCHandle g = GCHandle::operator GCHandle(static_cast<System::IntPtr>(m_nHandle));
		g.Free();
		m_nHandle = 0;
	}

//CWinFormsControlSite
_AFXWIN_INLINE CWinFormsControlSite::CWinFormsControlSite(COleControlContainer* pCtrlCont)
	: COleControlSite(pCtrlCont),m_gcEventHelper(gcnew CWinFormsEventsHelper())
	{
		m_gcEventHelper->Advise(this);
	}

_AFXWIN_INLINE CWinFormsControlSite::~CWinFormsControlSite() 
	{
		m_gcEventHelper->Unadvise(this);
	}
_AFXWIN_INLINE void CWinFormsControlSite::SetControlEnabled(bool bEnable)
	{
		get_Control()->Enabled=bEnable;
	}
_AFXWIN_INLINE void CWinFormsControlSite::OnHandleDestroyed( gcroot<System::Object^> , gcroot<System::EventArgs^> )
	{
		DetachWindow();
	}


#endif //AFXWFRM_INL_INCLUDE_GUARD
#endif // _AFXWIN_INLINE
		} //MFC
	} //VisualC
} //Microsoft
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#pragma once

// Warnings outside of the push/pop sequence will be disabled for all user
// projects.  The only warnings that should be disabled outside the push/pop
// are warnings that are a) benign and b) will show up in user projects
// without being directly caused by the user

#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4514) // unreferenced inlines are common

// These two warnings will occur in any class that contains or derives from a
// class with a private copy constructor or copy assignment operator.
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated

// This is a very common pattern for us
#pragma warning(disable: 4355) // 'this' : used in base member initializer list

#ifdef _ATL_ALL_WARNINGS
#pragma warning( push )
#endif

#pragma warning(disable : 4668)	// is not defined as a preprocessor macro, replacing with '0' for '#if/#elif
#pragma warning(disable : 4820)	// padding added after member
#pragma warning(disable : 4917)	// a GUID can only be associated with a class, interface or namespace

#pragma warning(disable : 4217)	// member template functions cannot be used for copy-assignment or copy-construction

#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4291) // allow placement new
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4268) // const static/global data initialized to zeros

#pragma warning (push)
// Warning 4702 is generated based on compiler backend data flow analysis. This means that for
// some specific instantiations of a template it can be generated even when the code branch is
// required for other instantiations. In future we should find a way to be more selective about this
#pragma warning(disable: 4702) // Unreachable code
#pragma warning(disable: 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif
#ifndef ATL_NO_LEAN_AND_MEAN
#define ATL_NO_LEAN_AND_MEAN
#endif

#include <atldef.h>

#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif

#include <atlcore.h>
#include <ole2.h>
#include <atlcomcli.h>

#include <comcat.h>
#include <stddef.h>

#include <tchar.h>
#include <limits.h>

#include <olectl.h>
#include <atliface.h>

#include <errno.h>
#include <process.h>    // for _beginthreadex, _endthreadex

#include <stdio.h>
#include <stdarg.h>

#include <atlconv.h>
#include <shlwapi.h>
#include <atlsimpcoll.h>
#include <atltrace.h>
#include <atlexcept.h>
#include <atltransactionmanager.h>

#define _ATL_TYPELIB_INDEX_LENGTH 10
#define _ATL_QUOTES_SPACE 2

#pragma pack(push, _ATL_PACKING)

#ifndef _ATL_NO_DEFAULT_LIBS

#if defined(_ATL_DLL)
	#pragma comment(lib, "atl.lib")

#endif	// _ATL_DLL

#ifdef _DEBUG
	#pragma comment(lib, "atlsd.lib")
#else
	#pragma comment(lib, "atls.lib")
#endif

#ifdef _ATL_MIN_CRT
	#pragma message("_ATL_MIN_CRT is no longer supported.  Please see documentation for more information.")
#endif


#endif	// !_ATL_NO_DEFAULT_LIBS

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = 					 {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = 				 {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = 				 {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = 			 {0xb6ea2050,0x048a,0x11d1,{0x82,0xb9,0x00,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = 		 {0xb6ea2051,0x048a,0x11d1,{0x82,0xb9,0x00,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = 		 {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = 	 {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindowLic = 		 {0x3935BDA8,0x4ED9,0x495c,{0x86,0x50,0xE0,0x1F,0xC1,0xE3,0x8A,0x4B}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatchEx = 	 {0xB2D0778B,0xAC99,0x4c58,{0xA5,0xC8,0xE7,0x72,0x4E,0x53,0x16,0xB5}};


#ifndef _delayimp_h
extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif

#ifdef _AFX
void AFXAPI AfxOleLockApp();
void AFXAPI AfxOleUnlockApp();
#endif	// _AFX

// Support Windows SDK v5.0
#ifndef LSTATUS
typedef __success(return==ERROR_SUCCESS) LONG LSTATUS;
#endif

namespace ATL
{

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(
	_In_opt_ void* pv,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(
	_In_opt_ void* pv,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv,
	_In_ DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(_In_ DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(_In_ DWORD_PTR dw);

struct _ATL_TERMFUNC_ELEM
{
	_ATL_TERMFUNC* pFunc;
	DWORD_PTR dw;
	_ATL_TERMFUNC_ELEM* pNext;
};

// Can't inherit from _ATL_OBJMAP_ENTRY20
// because it messes up the OBJECT_MAP macros
struct _ATL_OBJMAP_ENTRY30
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(_In_ BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	_ATL_CATMAPFUNC* pfnGetCategoryMap;
	HRESULT WINAPI RevokeClassObject()
	{
		if (dwRegister == 0)
			return S_OK;
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(
		_In_ DWORD dwClsContext,
		_In_ DWORD dwFlags)
	{
		IUnknown* p = NULL;
		if (pfnGetClassObject == NULL)
			return S_OK;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, __uuidof(IUnknown), (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		if (p != NULL)
			p->Release();
		return hRes;
	}
// Added in ATL 3.0
	void (WINAPI *pfnObjectMain)(_In_ bool bStarting);
};

typedef _ATL_OBJMAP_ENTRY30 _ATL_OBJMAP_ENTRY;

// Auto Object Map

#pragma section("ATL$__a", read)
#pragma section("ATL$__z", read)
#pragma section("ATL$__m", read)
extern "C"
{
__declspec(selectany) __declspec(allocate("ATL$__a")) _ATL_OBJMAP_ENTRY* __pobjMapEntryFirst = NULL;
__declspec(selectany) __declspec(allocate("ATL$__z")) _ATL_OBJMAP_ENTRY* __pobjMapEntryLast = NULL;
}

#if !defined(_M_IA64)
#pragma comment(linker, "/merge:ATL=.rdata")
#endif

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
	void* m_pThis;
	DWORD m_dwThreadID;
	_AtlCreateWndData* m_pNext;
};


// perfmon registration/unregistration function definitions
typedef HRESULT (*_ATL_PERFREGFUNC)(_In_ HINSTANCE hDllInstance);
typedef HRESULT (*_ATL_PERFUNREGFUNC)();
__declspec(selectany) _ATL_PERFREGFUNC _pPerfRegFunc = NULL;
__declspec(selectany) _ATL_PERFUNREGFUNC _pPerfUnRegFunc = NULL;

bool __declspec(selectany) _AtlRegisterPerUser = false;

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

template< class TLock >
class CComCritSecLock
{
public:
	CComCritSecLock(
		_Inout_ TLock& cs,
		_In_ bool bInitialLock = true );
	~CComCritSecLock() throw();

	HRESULT Lock() throw();
	void Unlock() throw();

// Implementation
private:
	TLock& m_cs;
	bool m_bLocked;

// Private to avoid accidental use
	CComCritSecLock(_In_ const CComCritSecLock&) throw();
	CComCritSecLock& operator=(_In_ const CComCritSecLock&) throw();
};

template< class TLock >
inline CComCritSecLock< TLock >::CComCritSecLock(
		_Inout_ TLock& cs,
		_In_ bool bInitialLock) :
	m_cs( cs ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		HRESULT hr;

		hr = Lock();
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}
	}
}

template< class TLock >
inline CComCritSecLock< TLock >::~CComCritSecLock() throw()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

template< class TLock >
inline HRESULT CComCritSecLock< TLock >::Lock() throw()
{
	HRESULT hr;

	ATLASSERT( !m_bLocked );
	hr = m_cs.Lock();
	if( FAILED( hr ) )
	{
		return( hr );
	}
	m_bLocked = true;

	return( S_OK );
}

template< class TLock >
inline void CComCritSecLock< TLock >::Unlock() throw()
{
	ATLASSUME( m_bLocked );
	m_cs.Unlock();
	m_bLocked = false;
}

class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(_Inout_ LPLONG p) throw()
	{
		return InterlockedIncrement(p);
	}
	static ULONG WINAPI Decrement(_Inout_ LPLONG p) throw()
	{
		return InterlockedDecrement(p);
	}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection AutoDeleteCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(_Inout_ LPLONG p) throw()
	{
		return InterlockedIncrement(p);
	}
	static ULONG WINAPI Decrement(_Inout_ LPLONG p) throw()
	{
		return InterlockedDecrement(p);
	}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComAutoDeleteCriticalSection AutoDeleteCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(_Inout_ LPLONG p) throw()
	{
		return ++(*p);
	}
	static ULONG WINAPI Decrement(_Inout_ LPLONG p) throw()
	{
		return --(*p);
	}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection AutoDeleteCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)

#if defined(_ATL_APARTMENT_THREADED) || defined(_ATL_FREE_THREADED)
#pragma message ("More than one global threading model defined.")
#endif

	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;

#elif defined(_ATL_APARTMENT_THREADED)

#if defined(_ATL_SINGLE_THREADED) || defined(_ATL_FREE_THREADED)
#pragma message ("More than one global threading model defined.")
#endif

	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;

#elif defined(_ATL_FREE_THREADED)

#if defined(_ATL_SINGLE_THREADED) || defined(_ATL_APARTMENT_THREADED)
#pragma message ("More than one global threading model defined.")
#endif

	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;

#else
#pragma message ("No global threading model defined")
#endif

/////////////////////////////////////////////////////////////////////////////
// Module


// Used by COM related code in ATL
struct _ATL_COM_MODULE70
{
	UINT cbSize;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY** m_ppAutoObjMapFirst;
	_ATL_OBJMAP_ENTRY** m_ppAutoObjMapLast;
	CComCriticalSection m_csObjMap;
};
typedef _ATL_COM_MODULE70 _ATL_COM_MODULE;


// Used by Windowing code in ATL
struct _ATL_WIN_MODULE70
{
	UINT cbSize;
	CComCriticalSection m_csWindowCreate;
	_AtlCreateWndData* m_pCreateWndList;
	CSimpleArray<ATOM> m_rgWindowClassAtoms;
};
typedef _ATL_WIN_MODULE70 _ATL_WIN_MODULE;


struct _ATL_MODULE70
{
	UINT cbSize;
	LONG m_nLockCnt;
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
	CComCriticalSection m_csStaticDataInitAndTypeInfo;
};
typedef _ATL_MODULE70 _ATL_MODULE;


/////////////////////////////////////////////////////////////////////////////
//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((ATL::_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD_PTR dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// Global Functions

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(
	_Inout_ void* pThis,
	_In_ const _ATL_INTMAP_ENTRY* pEntries,
	_In_ REFIID iid,
	_Deref_out_ void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(_Inout_ IStream* pStream);

ATLAPI AtlMarshalPtrInProc(
	_Inout_ IUnknown* pUnk,
	_In_ const IID& iid,
	_Deref_out_ IStream** ppStream);

ATLAPI AtlUnmarshalPtr(
	_Inout_ IStream* pStream,
	_In_ const IID& iid,
	_Deref_out_ IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(_In_ HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(
	_Inout_ IUnknown* pUnkCP,
	_Inout_opt_ IUnknown* pUnk,
	_In_ const IID& iid,
	_Out_ LPDWORD pdw);

ATLAPI AtlUnadvise(
	_Inout_ IUnknown* pUnkCP,
	_In_ const IID& iid,
	_In_ DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(
	_In_ const CLSID& clsid,
	_In_z_ LPCOLESTR lpszDesc,
	_In_ DWORD dwHelpID,
	_In_opt_z_ LPCOLESTR lpszHelpFile,
	_In_ const IID& iid,
	_In_ HRESULT hRes,
	_In_opt_ HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlComModuleRegisterClassObjects(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ DWORD dwClsContext,
	_In_ DWORD dwFlags);

ATLAPI AtlComModuleRevokeClassObjects(
	_Inout_ _ATL_COM_MODULE* pComModule);

ATLAPI AtlComModuleGetClassObject(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ REFCLSID rclsid,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv);

ATLAPI AtlRegisterClassCategoriesHelper(
	_In_ REFCLSID clsid,
	_In_opt_ const struct _ATL_CATMAP_ENTRY* pCatMap,
	_In_ BOOL bRegister);

ATLAPI AtlUpdateRegistryFromResourceD(
	_In_ HINSTANCE hInst,
	_In_z_ LPCOLESTR lpszRes,
	_In_ BOOL bRegister,
	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries,
	_In_opt_ IRegistrar* pReg = NULL);

ATLAPI AtlSetPerUserRegistration(_In_ bool bEnable);
ATLAPI AtlGetPerUserRegistration(_Out_ bool* pbEnabled);

ATLAPI AtlLoadTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex,
	_Deref_out_z_ BSTR* pbstrPath,
	_Deref_out_ ITypeLib** ppTypeLib);

ATLAPI_(DWORD) AtlGetVersion(_In_opt_ void* pReserved);

ATLAPI AtlModuleAddTermFunc(
	_Inout_ _ATL_MODULE* pModule,
	_In_ _ATL_TERMFUNC* pFunc,
	_In_ DWORD_PTR dw);

ATLAPI_(void) AtlCallTermFunc(_Inout_ _ATL_MODULE* pModule);

ATLAPI AtlWinModuleInit(_Inout_ _ATL_WIN_MODULE* pWinModule);

ATLAPIINL AtlWinModuleTerm(
	_Inout_ _ATL_WIN_MODULE* pWinModule,
	_In_ HINSTANCE hInst);

ATLAPI_(void) AtlWinModuleAddCreateWndData(
	_Inout_ _ATL_WIN_MODULE* pWinModule,
	_Inout_ _AtlCreateWndData* pData,
	_In_ void* pObject);

ATLAPI_(void*) AtlWinModuleExtractCreateWndData(
	_Inout_opt_ _ATL_WIN_MODULE* pWinModule);

/////////////////////////////////////////////////////////////////////////////

ATLAPIINL AtlComModuleRegisterServer(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ BOOL bRegTypeLib,
	_In_opt_ const CLSID* pCLSID = NULL);

ATLAPIINL AtlComModuleUnregisterServer(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ BOOL bUnRegTypeLib,
	_In_opt_ const CLSID* pCLSID = NULL);

ATLAPIINL AtlRegisterTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex);

ATLAPIINL AtlUnRegisterTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex);

/////////////////////////////////////////////////////////////////////////////
// Get Registrar object from ATL DLL.

#if !defined(_ATL_STATIC_REGISTRY)
#ifdef _ATL_DLL_IMPL
extern "C" HRESULT __stdcall AtlCreateRegistrar(_Deref_out_ IRegistrar** ppReg);
#else
extern "C" __declspec(dllimport) HRESULT __stdcall AtlCreateRegistrar(_Deref_out_ IRegistrar** ppReg);
#endif
#endif

/////////////////////////////////////////////////////////////////////////////
// GUID comparison
inline BOOL WINAPI InlineIsEqualUnknown(_In_ REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

template <class T>
LPCTSTR AtlDebugGetClassName(_In_opt_ T*)
{
#ifdef _DEBUG
	const _ATL_INTMAP_ENTRY* pEntries = T::_GetEntries();
	return (LPCTSTR)pEntries[-1].dw;
#else
	return NULL;
#endif
}

// Validation macro for OUT pointer
// Used in QI and CreateInstance
#define _ATL_VALIDATE_OUT_POINTER(x)\
	do {					\
	ATLASSERT(x != NULL);	\
	if (x == NULL)			\
		return E_POINTER;	\
	*x = NULL;				\
	} while(0)

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "shell32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")
#pragma comment(lib, "shlwapi.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

template< typename T >
class CAutoVectorPtr
{
public:
	CAutoVectorPtr() throw() :
		m_p( NULL )
	{
	}
	CAutoVectorPtr(_Inout_ CAutoVectorPtr< T >& p) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	explicit CAutoVectorPtr(_In_ T* p) throw() :
		m_p( p )
	{
	}
	~CAutoVectorPtr() throw()
	{
		Free();
	}

	operator T*() const throw()
	{
		return( m_p );
	}

	CAutoVectorPtr< T >& operator=(_Inout_ CAutoVectorPtr< T >& p) throw()
	{
		if(*this==p)
		{
			if(m_p == NULL)
			{
				// This branch means both two pointers are NULL, do nothing.
			}
			else if(this!=&p)
			{
				// If this assert fires, it means you attempted to assign one CAutoVectorPtr to another when they both contained
				// a pointer to the same underlying vector. This means a bug in your code, since your vector will get
				// double-deleted.
				ATLASSERT(FALSE);

				// For safety, we are going to detach the other CAutoVectorPtr to avoid a double-free. Your code still
				// has a bug, though.
				p.Detach();
			}
			else
			{
				// Alternatively, this branch means that you are assigning a CAutoVectorPtr to itself, which is
				// pointless but permissible

				// nothing to do
			}
		}
		else
		{
			Free();
			Attach( p.Detach() );  // Transfer ownership
		}
		return( *this );
	}

	// basic comparison operators
	bool operator!=(_In_ CAutoVectorPtr<T>& p) const
	{
		return !operator==(p);
	}

	bool operator==(_In_ CAutoVectorPtr<T>& p) const
	{
		return m_p==p.m_p;
	}

	// Allocate the vector
	bool Allocate(_In_ size_t nElements) throw()
	{
		ATLASSUME( m_p == NULL );
		ATLTRY( m_p = new T[nElements] );
		if( m_p == NULL )
		{
			return( false );
		}

		return( true );
	}
	// Attach to an existing pointer (takes ownership)
	void Attach(_In_ T* p) throw()
	{
		ATLASSUME( m_p == NULL );
		m_p = p;
	}
	// Detach the pointer (releases ownership)
	T* Detach() throw()
	{
		T* p;

		p = m_p;
		m_p = NULL;

		return( p );
	}
	// Delete the vector pointed to, and set the pointer to NULL
	void Free() throw()
	{
		delete[] m_p;
		m_p = NULL;
	}

public:
	T* m_p;
};

template< typename T >
class CAutoPtr
{
public:
	CAutoPtr() throw() :
		m_p( NULL )
	{
	}
	template< typename TSrc >
	CAutoPtr(_Inout_ CAutoPtr< TSrc >& p) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	CAutoPtr(_Inout_ CAutoPtr< T >& p) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	explicit CAutoPtr(_In_ T* p) throw() :
		m_p( p )
	{
	}
	~CAutoPtr() throw()
	{
		Free();
	}

	// Templated version to allow pBase = pDerived
	template< typename TSrc >
	CAutoPtr< T >& operator=(_Inout_ CAutoPtr< TSrc >& p) throw()
	{
		if(m_p==p.m_p)
		{
			// This means that two CAutoPtrs of two different types had the same m_p in them
			// which is never correct
			ATLASSERT(FALSE);
		}
		else
		{
			Free();
			Attach( p.Detach() );  // Transfer ownership
		}
		return( *this );
	}
	CAutoPtr< T >& operator=(_Inout_ CAutoPtr< T >& p) throw()
	{
		if(*this==p)
		{
			if(this!=&p)
			{
				// If this assert fires, it means you attempted to assign one CAutoPtr to another when they both contained
				// a pointer to the same underlying object. This means a bug in your code, since your object will get
				// double-deleted.
#ifdef ATL_AUTOPTR_ASSIGNMENT_ASSERT
				ATLASSERT(FALSE);
#endif

				// For safety, we are going to detach the other CAutoPtr to avoid a double-free. Your code still
				// has a bug, though.
				p.Detach();
			}
			else
			{
				// Alternatively, this branch means that you are assigning a CAutoPtr to itself, which is
				// pointless but permissible

				// nothing to do
			}
		}
		else
		{
			Free();
			Attach( p.Detach() );  // Transfer ownership
		}
		return( *this );
	}

	// basic comparison operators
	bool operator!=(_In_ CAutoPtr<T>& p) const
	{
		return !operator==(p);
	}

	bool operator==(_In_ CAutoPtr<T>& p) const
	{
		return m_p==p.m_p;
	}

	operator T*() const throw()
	{
		return( m_p );
	}
	T* operator->() const throw()
	{
		ATLASSUME( m_p != NULL );
		return( m_p );
	}

	// Attach to an existing pointer (takes ownership)
	void Attach(_In_opt_ T* p) throw()
	{
		ATLASSUME( m_p == NULL );
		m_p = p;
	}
	// Detach the pointer (releases ownership)
	T* Detach() throw()
	{
		T* p;

		p = m_p;
		m_p = NULL;

		return( p );
	}
	// Delete the object pointed to, and set the pointer to NULL
	void Free() throw()
	{
		delete m_p;
		m_p = NULL;
	}

public:
	T* m_p;
};

/* Automatic cleanup for _malloca objects */
template< typename T >
class CAutoStackPtr
{
public:
	CAutoStackPtr() throw() :
		m_p( NULL )
	{
	}
	template< typename TSrc >
	CAutoStackPtr(_Inout_ CAutoStackPtr< TSrc >& p) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	CAutoStackPtr(_Inout_ CAutoStackPtr< T >& p) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	explicit CAutoStackPtr(_In_opt_ T* p) throw() :
		m_p( p )
	{
	}
	~CAutoStackPtr() throw()
	{
		Free();
	}

	// Templated version to allow pBase = pDerived
	template< typename TSrc >
	CAutoStackPtr< T >& operator=(_Inout_ CAutoStackPtr< TSrc >& p) throw()
	{
		if(m_p==p.m_p)
		{
			// This means that two CAutoPtrs of two different types had the same m_p in them
			// which is never correct
			ATLASSERT(FALSE);
		}
		else
		{
			Free();
			Attach( p.Detach() );  // Transfer ownership
		}
		return( *this );
	}
	CAutoStackPtr< T >& operator=(_Inout_ CAutoStackPtr< T >& p) throw()
	{
		if(*this==p)
		{
			if(this!=&p)
			{
				// If this assert fires, it means you attempted to assign one CAutoPtr to another when they both contained
				// a pointer to the same underlying object. This means a bug in your code, since your object will get
				// double-deleted.
				ATLASSERT(FALSE);

				// For safety, we are going to detach the other CAutoPtr to avoid a double-free. Your code still
				// has a bug, though.
				p.Detach();
			}
			else
			{
				// Alternatively, this branch means that you are assigning a CAutoPtr to itself, which is
				// pointless but permissible

				// nothing to do
			}
		}
		else
		{
			Free();
			Attach( p.Detach() );  // Transfer ownership
		}
		return( *this );
	}

	// basic comparison operators
	bool operator!=(_In_ CAutoStackPtr<T>& p) const
	{
		return !operator==(p);
	}

	bool operator==(_In_ CAutoStackPtr<T>& p) const
	{
		return m_p==p.m_p;
	}

	operator T*() const throw()
	{
		return( m_p );
	}
	T* operator->() const throw()
	{
		ATLASSUME( m_p != NULL );
		return( m_p );
	}

	// Attach to an existing pointer (takes ownership)
	void Attach(_In_opt_ T* p) throw()
	{
		ATLASSUME( m_p == NULL );
		m_p = p;
	}
	// Detach the pointer (releases ownership)
	T* Detach() throw()
	{
		T* p;

		p = m_p;
		m_p = NULL;

		return( p );
	}
	// Delete the object pointed to, and set the pointer to NULL
	void Free() throw()
	{
		/* Note: _freea only actually does anything if m_p was heap allocated
		   If m_p was from the stack, it wouldn't be possible to actually free it here
		   [wrong function] unless we got inlined. But really all we do if m_p is
		   stack-based is ignore it and let its alloca storage disappear at the end
		   of the outer function.
		*/
		_freea(m_p);
		m_p = NULL;
	}

public:
	T* m_p;
};

// static_cast_auto template functions.  Used like static_cast, only they work on CAutoPtr objects
template< class Dest, class Src >
Dest* static_cast_auto(_In_ const CAutoPtr< Src >& pSrc) throw()
{
	return( static_cast< Dest* >( static_cast< Src* >( pSrc ) ) );
}


class CComAllocator
{
public:
	static void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return ::CoTaskMemRealloc(p, ULONG(nBytes));
	}
	static void* Allocate(_In_ size_t nBytes) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return ::CoTaskMemAlloc(ULONG(nBytes));
	}
	static void Free(_In_opt_ void* p) throw()
	{
		::CoTaskMemFree(p);
	}
};

template <typename T>
class CComHeapPtr :
	public CHeapPtr<T, CComAllocator>
{
public:
	CComHeapPtr() throw()
	{
	}

	explicit CComHeapPtr(_In_ T* pData) throw() :
		CHeapPtr<T, CComAllocator>(pData)
	{
	}
};

template <class T, class Reallocator>
_Ret_opt_count_(cEls) T* AtlSafeRealloc(
	_In_opt_ T* pT,
	_In_ size_t cEls) throw()
{
	T* pTemp;

	size_t nBytes=0;
	if(FAILED(::ATL::AtlMultiply(&nBytes, cEls, sizeof(T))))
	{
		return NULL;
	}
	pTemp = static_cast<T*>(Reallocator::Reallocate(pT, nBytes));
	if (pTemp == NULL)
	{
		Reallocator::Free(pT);
		return NULL;
	}
	pT = pTemp;
	return pTemp;
}

class CHandle
{
public:
	CHandle() throw();
	CHandle(_Inout_ CHandle& h) throw();
	explicit CHandle(_In_ HANDLE h) throw();
	~CHandle() throw();

	CHandle& operator=(_Inout_ CHandle& h) throw();

	operator HANDLE() const throw();

	// Attach to an existing handle (takes ownership).
	void Attach(_In_ HANDLE h) throw();
	// Detach the handle from the object (releases ownership).
	HANDLE Detach() throw();

	// Close the handle.
	void Close() throw();

public:
	HANDLE m_h;
};

inline CHandle::CHandle() throw() :
	m_h( NULL )
{
}

inline CHandle::CHandle(_Inout_ CHandle& h) throw() :
	m_h( NULL )
{
	Attach( h.Detach() );
}

inline CHandle::CHandle(_In_ HANDLE h) throw() :
	m_h( h )
{
}

inline CHandle::~CHandle() throw()
{
	if( m_h != NULL )
	{
		Close();
	}
}

inline CHandle& CHandle::operator=(_Inout_ CHandle& h) throw()
{
	if( this != &h )
	{
		if( m_h != NULL )
		{
			Close();
		}
		Attach( h.Detach() );
	}

	return( *this );
}

inline CHandle::operator HANDLE() const throw()
{
	return( m_h );
}

inline void CHandle::Attach(_In_ HANDLE h) throw()
{
	ATLASSUME( m_h == NULL );
	m_h = h;  // Take ownership
}

inline HANDLE CHandle::Detach() throw()
{
	HANDLE h;

	h = m_h;  // Release ownership
	m_h = NULL;

	return( h );
}

inline void CHandle::Close() throw()
{
	if( m_h != NULL )
	{
		::CloseHandle( m_h );
		m_h = NULL;
	}
}

class CCritSecLock
{
public:
	CCritSecLock(
		_Inout_ CRITICAL_SECTION& cs,
		_In_ bool bInitialLock = true);
	~CCritSecLock() throw();

	void Lock();
	void Unlock() throw();

// Implementation
private:
	CRITICAL_SECTION& m_cs;
	bool m_bLocked;

// Private to avoid accidental use
	CCritSecLock(_In_ const CCritSecLock&) throw();
	CCritSecLock& operator=(_In_ const CCritSecLock&) throw();
};

inline CCritSecLock::CCritSecLock(
		_Inout_ CRITICAL_SECTION& cs,
		_In_ bool bInitialLock) :
	m_cs( cs ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		Lock();
	}
}

inline CCritSecLock::~CCritSecLock() throw()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

inline void CCritSecLock::Lock()
{
	ATLASSERT( !m_bLocked );

	::EnterCriticalSection( &m_cs );
	m_bLocked = true;
}

inline void CCritSecLock::Unlock() throw()
{
	ATLASSUME( m_bLocked );
	::LeaveCriticalSection( &m_cs );
	m_bLocked = false;
}

/////////////////////////////////////////////////////////////////////////////
// Interface debugging
#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
HRESULT WINAPI AtlDumpIID(
	_In_ REFIID iid,
	_In_z_ LPCTSTR pszClassName,
	_In_ HRESULT hr) throw();
#endif	// _ATL_DEBUG_INTERFACES || _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_INTERFACES

struct _QIThunk
{
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid,
		_Deref_out_ void** pp)
	{
		ATLASSUME(m_dwRef >= 0);
		ATLASSUME(m_pUnk != NULL);
		return m_pUnk->QueryInterface(iid, pp);
	}
	STDMETHOD_(ULONG, AddRef)()
	{
		ATLASSUME(m_pUnk != NULL);
		if (m_bBreak)
			DebugBreak();
		m_pUnk->AddRef();
		return InternalAddRef();
	}
	ULONG InternalAddRef()
	{
		ATLASSUME(m_pUnk != NULL);
		if (m_bBreak)
			DebugBreak();
		ATLASSUME(m_dwRef >= 0);
		long l = InterlockedIncrement(&m_dwRef);

		TCHAR buf[512+1];
		_stprintf_s(buf, _countof(buf), _T("QIThunk - %-10d\tAddRef  :\tObject = 0x%p\tRefcount = %d\t"),
			m_nIndex, m_pUnk, m_dwRef);
		buf[_countof(buf)-1] = 0;
		OutputDebugString(buf);
		AtlDumpIID(m_iid, m_lpszClassName, S_OK);

		if (l > m_dwMaxRef)
			m_dwMaxRef = l;
		return l;
	}
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(f3)();
	STDMETHOD(f4)();
	STDMETHOD(f5)();
	STDMETHOD(f6)();
	STDMETHOD(f7)();
	STDMETHOD(f8)();
	STDMETHOD(f9)();
	STDMETHOD(f10)();
	STDMETHOD(f11)();
	STDMETHOD(f12)();
	STDMETHOD(f13)();
	STDMETHOD(f14)();
	STDMETHOD(f15)();
	STDMETHOD(f16)();
	STDMETHOD(f17)();
	STDMETHOD(f18)();
	STDMETHOD(f19)();
	STDMETHOD(f20)();
	STDMETHOD(f21)();
	STDMETHOD(f22)();
	STDMETHOD(f23)();
	STDMETHOD(f24)();
	STDMETHOD(f25)();
	STDMETHOD(f26)();
	STDMETHOD(f27)();
	STDMETHOD(f28)();
	STDMETHOD(f29)();
	STDMETHOD(f30)();
	STDMETHOD(f31)();
	STDMETHOD(f32)();
	STDMETHOD(f33)();
	STDMETHOD(f34)();
	STDMETHOD(f35)();
	STDMETHOD(f36)();
	STDMETHOD(f37)();
	STDMETHOD(f38)();
	STDMETHOD(f39)();
	STDMETHOD(f40)();
	STDMETHOD(f41)();
	STDMETHOD(f42)();
	STDMETHOD(f43)();
	STDMETHOD(f44)();
	STDMETHOD(f45)();
	STDMETHOD(f46)();
	STDMETHOD(f47)();
	STDMETHOD(f48)();
	STDMETHOD(f49)();
	STDMETHOD(f50)();
	STDMETHOD(f51)();
	STDMETHOD(f52)();
	STDMETHOD(f53)();
	STDMETHOD(f54)();
	STDMETHOD(f55)();
	STDMETHOD(f56)();
	STDMETHOD(f57)();
	STDMETHOD(f58)();
	STDMETHOD(f59)();
	STDMETHOD(f60)();
	STDMETHOD(f61)();
	STDMETHOD(f62)();
	STDMETHOD(f63)();
	STDMETHOD(f64)();
	STDMETHOD(f65)();
	STDMETHOD(f66)();
	STDMETHOD(f67)();
	STDMETHOD(f68)();
	STDMETHOD(f69)();
	STDMETHOD(f70)();
	STDMETHOD(f71)();
	STDMETHOD(f72)();
	STDMETHOD(f73)();
	STDMETHOD(f74)();
	STDMETHOD(f75)();
	STDMETHOD(f76)();
	STDMETHOD(f77)();
	STDMETHOD(f78)();
	STDMETHOD(f79)();
	STDMETHOD(f80)();
	STDMETHOD(f81)();
	STDMETHOD(f82)();
	STDMETHOD(f83)();
	STDMETHOD(f84)();
	STDMETHOD(f85)();
	STDMETHOD(f86)();
	STDMETHOD(f87)();
	STDMETHOD(f88)();
	STDMETHOD(f89)();
	STDMETHOD(f90)();
	STDMETHOD(f91)();
	STDMETHOD(f92)();
	STDMETHOD(f93)();
	STDMETHOD(f94)();
	STDMETHOD(f95)();
	STDMETHOD(f96)();
	STDMETHOD(f97)();
	STDMETHOD(f98)();
	STDMETHOD(f99)();
	STDMETHOD(f100)();
	STDMETHOD(f101)();
	STDMETHOD(f102)();
	STDMETHOD(f103)();
	STDMETHOD(f104)();
	STDMETHOD(f105)();
	STDMETHOD(f106)();
	STDMETHOD(f107)();
	STDMETHOD(f108)();
	STDMETHOD(f109)();
	STDMETHOD(f110)();
	STDMETHOD(f111)();
	STDMETHOD(f112)();
	STDMETHOD(f113)();
	STDMETHOD(f114)();
	STDMETHOD(f115)();
	STDMETHOD(f116)();
	STDMETHOD(f117)();
	STDMETHOD(f118)();
	STDMETHOD(f119)();
	STDMETHOD(f120)();
	STDMETHOD(f121)();
	STDMETHOD(f122)();
	STDMETHOD(f123)();
	STDMETHOD(f124)();
	STDMETHOD(f125)();
	STDMETHOD(f126)();
	STDMETHOD(f127)();
	STDMETHOD(f128)();
	STDMETHOD(f129)();
	STDMETHOD(f130)();
	STDMETHOD(f131)();
	STDMETHOD(f132)();
	STDMETHOD(f133)();
	STDMETHOD(f134)();
	STDMETHOD(f135)();
	STDMETHOD(f136)();
	STDMETHOD(f137)();
	STDMETHOD(f138)();
	STDMETHOD(f139)();
	STDMETHOD(f140)();
	STDMETHOD(f141)();
	STDMETHOD(f142)();
	STDMETHOD(f143)();
	STDMETHOD(f144)();
	STDMETHOD(f145)();
	STDMETHOD(f146)();
	STDMETHOD(f147)();
	STDMETHOD(f148)();
	STDMETHOD(f149)();
	STDMETHOD(f150)();
	STDMETHOD(f151)();
	STDMETHOD(f152)();
	STDMETHOD(f153)();
	STDMETHOD(f154)();
	STDMETHOD(f155)();
	STDMETHOD(f156)();
	STDMETHOD(f157)();
	STDMETHOD(f158)();
	STDMETHOD(f159)();
	STDMETHOD(f160)();
	STDMETHOD(f161)();
	STDMETHOD(f162)();
	STDMETHOD(f163)();
	STDMETHOD(f164)();
	STDMETHOD(f165)();
	STDMETHOD(f166)();
	STDMETHOD(f167)();
	STDMETHOD(f168)();
	STDMETHOD(f169)();
	STDMETHOD(f170)();
	STDMETHOD(f171)();
	STDMETHOD(f172)();
	STDMETHOD(f173)();
	STDMETHOD(f174)();
	STDMETHOD(f175)();
	STDMETHOD(f176)();
	STDMETHOD(f177)();
	STDMETHOD(f178)();
	STDMETHOD(f179)();
	STDMETHOD(f180)();
	STDMETHOD(f181)();
	STDMETHOD(f182)();
	STDMETHOD(f183)();
	STDMETHOD(f184)();
	STDMETHOD(f185)();
	STDMETHOD(f186)();
	STDMETHOD(f187)();
	STDMETHOD(f188)();
	STDMETHOD(f189)();
	STDMETHOD(f190)();
	STDMETHOD(f191)();
	STDMETHOD(f192)();
	STDMETHOD(f193)();
	STDMETHOD(f194)();
	STDMETHOD(f195)();
	STDMETHOD(f196)();
	STDMETHOD(f197)();
	STDMETHOD(f198)();
	STDMETHOD(f199)();
	STDMETHOD(f200)();
	STDMETHOD(f201)();
	STDMETHOD(f202)();
	STDMETHOD(f203)();
	STDMETHOD(f204)();
	STDMETHOD(f205)();
	STDMETHOD(f206)();
	STDMETHOD(f207)();
	STDMETHOD(f208)();
	STDMETHOD(f209)();
	STDMETHOD(f210)();
	STDMETHOD(f211)();
	STDMETHOD(f212)();
	STDMETHOD(f213)();
	STDMETHOD(f214)();
	STDMETHOD(f215)();
	STDMETHOD(f216)();
	STDMETHOD(f217)();
	STDMETHOD(f218)();
	STDMETHOD(f219)();
	STDMETHOD(f220)();
	STDMETHOD(f221)();
	STDMETHOD(f222)();
	STDMETHOD(f223)();
	STDMETHOD(f224)();
	STDMETHOD(f225)();
	STDMETHOD(f226)();
	STDMETHOD(f227)();
	STDMETHOD(f228)();
	STDMETHOD(f229)();
	STDMETHOD(f230)();
	STDMETHOD(f231)();
	STDMETHOD(f232)();
	STDMETHOD(f233)();
	STDMETHOD(f234)();
	STDMETHOD(f235)();
	STDMETHOD(f236)();
	STDMETHOD(f237)();
	STDMETHOD(f238)();
	STDMETHOD(f239)();
	STDMETHOD(f240)();
	STDMETHOD(f241)();
	STDMETHOD(f242)();
	STDMETHOD(f243)();
	STDMETHOD(f244)();
	STDMETHOD(f245)();
	STDMETHOD(f246)();
	STDMETHOD(f247)();
	STDMETHOD(f248)();
	STDMETHOD(f249)();
	STDMETHOD(f250)();
	STDMETHOD(f251)();
	STDMETHOD(f252)();
	STDMETHOD(f253)();
	STDMETHOD(f254)();
	STDMETHOD(f255)();
	STDMETHOD(f256)();
	STDMETHOD(f257)();
	STDMETHOD(f258)();
	STDMETHOD(f259)();
	STDMETHOD(f260)();
	STDMETHOD(f261)();
	STDMETHOD(f262)();
	STDMETHOD(f263)();
	STDMETHOD(f264)();
	STDMETHOD(f265)();
	STDMETHOD(f266)();
	STDMETHOD(f267)();
	STDMETHOD(f268)();
	STDMETHOD(f269)();
	STDMETHOD(f270)();
	STDMETHOD(f271)();
	STDMETHOD(f272)();
	STDMETHOD(f273)();
	STDMETHOD(f274)();
	STDMETHOD(f275)();
	STDMETHOD(f276)();
	STDMETHOD(f277)();
	STDMETHOD(f278)();
	STDMETHOD(f279)();
	STDMETHOD(f280)();
	STDMETHOD(f281)();
	STDMETHOD(f282)();
	STDMETHOD(f283)();
	STDMETHOD(f284)();
	STDMETHOD(f285)();
	STDMETHOD(f286)();
	STDMETHOD(f287)();
	STDMETHOD(f288)();
	STDMETHOD(f289)();
	STDMETHOD(f290)();
	STDMETHOD(f291)();
	STDMETHOD(f292)();
	STDMETHOD(f293)();
	STDMETHOD(f294)();
	STDMETHOD(f295)();
	STDMETHOD(f296)();
	STDMETHOD(f297)();
	STDMETHOD(f298)();
	STDMETHOD(f299)();
	STDMETHOD(f300)();
	STDMETHOD(f301)();
	STDMETHOD(f302)();
	STDMETHOD(f303)();
	STDMETHOD(f304)();
	STDMETHOD(f305)();
	STDMETHOD(f306)();
	STDMETHOD(f307)();
	STDMETHOD(f308)();
	STDMETHOD(f309)();
	STDMETHOD(f310)();
	STDMETHOD(f311)();
	STDMETHOD(f312)();
	STDMETHOD(f313)();
	STDMETHOD(f314)();
	STDMETHOD(f315)();
	STDMETHOD(f316)();
	STDMETHOD(f317)();
	STDMETHOD(f318)();
	STDMETHOD(f319)();
	STDMETHOD(f320)();
	STDMETHOD(f321)();
	STDMETHOD(f322)();
	STDMETHOD(f323)();
	STDMETHOD(f324)();
	STDMETHOD(f325)();
	STDMETHOD(f326)();
	STDMETHOD(f327)();
	STDMETHOD(f328)();
	STDMETHOD(f329)();
	STDMETHOD(f330)();
	STDMETHOD(f331)();
	STDMETHOD(f332)();
	STDMETHOD(f333)();
	STDMETHOD(f334)();
	STDMETHOD(f335)();
	STDMETHOD(f336)();
	STDMETHOD(f337)();
	STDMETHOD(f338)();
	STDMETHOD(f339)();
	STDMETHOD(f340)();
	STDMETHOD(f341)();
	STDMETHOD(f342)();
	STDMETHOD(f343)();
	STDMETHOD(f344)();
	STDMETHOD(f345)();
	STDMETHOD(f346)();
	STDMETHOD(f347)();
	STDMETHOD(f348)();
	STDMETHOD(f349)();
	STDMETHOD(f350)();
	STDMETHOD(f351)();
	STDMETHOD(f352)();
	STDMETHOD(f353)();
	STDMETHOD(f354)();
	STDMETHOD(f355)();
	STDMETHOD(f356)();
	STDMETHOD(f357)();
	STDMETHOD(f358)();
	STDMETHOD(f359)();
	STDMETHOD(f360)();
	STDMETHOD(f361)();
	STDMETHOD(f362)();
	STDMETHOD(f363)();
	STDMETHOD(f364)();
	STDMETHOD(f365)();
	STDMETHOD(f366)();
	STDMETHOD(f367)();
	STDMETHOD(f368)();
	STDMETHOD(f369)();
	STDMETHOD(f370)();
	STDMETHOD(f371)();
	STDMETHOD(f372)();
	STDMETHOD(f373)();
	STDMETHOD(f374)();
	STDMETHOD(f375)();
	STDMETHOD(f376)();
	STDMETHOD(f377)();
	STDMETHOD(f378)();
	STDMETHOD(f379)();
	STDMETHOD(f380)();
	STDMETHOD(f381)();
	STDMETHOD(f382)();
	STDMETHOD(f383)();
	STDMETHOD(f384)();
	STDMETHOD(f385)();
	STDMETHOD(f386)();
	STDMETHOD(f387)();
	STDMETHOD(f388)();
	STDMETHOD(f389)();
	STDMETHOD(f390)();
	STDMETHOD(f391)();
	STDMETHOD(f392)();
	STDMETHOD(f393)();
	STDMETHOD(f394)();
	STDMETHOD(f395)();
	STDMETHOD(f396)();
	STDMETHOD(f397)();
	STDMETHOD(f398)();
	STDMETHOD(f399)();
	STDMETHOD(f400)();
	STDMETHOD(f401)();
	STDMETHOD(f402)();
	STDMETHOD(f403)();
	STDMETHOD(f404)();
	STDMETHOD(f405)();
	STDMETHOD(f406)();
	STDMETHOD(f407)();
	STDMETHOD(f408)();
	STDMETHOD(f409)();
	STDMETHOD(f410)();
	STDMETHOD(f411)();
	STDMETHOD(f412)();
	STDMETHOD(f413)();
	STDMETHOD(f414)();
	STDMETHOD(f415)();
	STDMETHOD(f416)();
	STDMETHOD(f417)();
	STDMETHOD(f418)();
	STDMETHOD(f419)();
	STDMETHOD(f420)();
	STDMETHOD(f421)();
	STDMETHOD(f422)();
	STDMETHOD(f423)();
	STDMETHOD(f424)();
	STDMETHOD(f425)();
	STDMETHOD(f426)();
	STDMETHOD(f427)();
	STDMETHOD(f428)();
	STDMETHOD(f429)();
	STDMETHOD(f430)();
	STDMETHOD(f431)();
	STDMETHOD(f432)();
	STDMETHOD(f433)();
	STDMETHOD(f434)();
	STDMETHOD(f435)();
	STDMETHOD(f436)();
	STDMETHOD(f437)();
	STDMETHOD(f438)();
	STDMETHOD(f439)();
	STDMETHOD(f440)();
	STDMETHOD(f441)();
	STDMETHOD(f442)();
	STDMETHOD(f443)();
	STDMETHOD(f444)();
	STDMETHOD(f445)();
	STDMETHOD(f446)();
	STDMETHOD(f447)();
	STDMETHOD(f448)();
	STDMETHOD(f449)();
	STDMETHOD(f450)();
	STDMETHOD(f451)();
	STDMETHOD(f452)();
	STDMETHOD(f453)();
	STDMETHOD(f454)();
	STDMETHOD(f455)();
	STDMETHOD(f456)();
	STDMETHOD(f457)();
	STDMETHOD(f458)();
	STDMETHOD(f459)();
	STDMETHOD(f460)();
	STDMETHOD(f461)();
	STDMETHOD(f462)();
	STDMETHOD(f463)();
	STDMETHOD(f464)();
	STDMETHOD(f465)();
	STDMETHOD(f466)();
	STDMETHOD(f467)();
	STDMETHOD(f468)();
	STDMETHOD(f469)();
	STDMETHOD(f470)();
	STDMETHOD(f471)();
	STDMETHOD(f472)();
	STDMETHOD(f473)();
	STDMETHOD(f474)();
	STDMETHOD(f475)();
	STDMETHOD(f476)();
	STDMETHOD(f477)();
	STDMETHOD(f478)();
	STDMETHOD(f479)();
	STDMETHOD(f480)();
	STDMETHOD(f481)();
	STDMETHOD(f482)();
	STDMETHOD(f483)();
	STDMETHOD(f484)();
	STDMETHOD(f485)();
	STDMETHOD(f486)();
	STDMETHOD(f487)();
	STDMETHOD(f488)();
	STDMETHOD(f489)();
	STDMETHOD(f490)();
	STDMETHOD(f491)();
	STDMETHOD(f492)();
	STDMETHOD(f493)();
	STDMETHOD(f494)();
	STDMETHOD(f495)();
	STDMETHOD(f496)();
	STDMETHOD(f497)();
	STDMETHOD(f498)();
	STDMETHOD(f499)();
	STDMETHOD(f500)();
	STDMETHOD(f501)();
	STDMETHOD(f502)();
	STDMETHOD(f503)();
	STDMETHOD(f504)();
	STDMETHOD(f505)();
	STDMETHOD(f506)();
	STDMETHOD(f507)();
	STDMETHOD(f508)();
	STDMETHOD(f509)();
	STDMETHOD(f510)();
	STDMETHOD(f511)();
	STDMETHOD(f512)();
	STDMETHOD(f513)();
	STDMETHOD(f514)();
	STDMETHOD(f515)();
	STDMETHOD(f516)();
	STDMETHOD(f517)();
	STDMETHOD(f518)();
	STDMETHOD(f519)();
	STDMETHOD(f520)();
	STDMETHOD(f521)();
	STDMETHOD(f522)();
	STDMETHOD(f523)();
	STDMETHOD(f524)();
	STDMETHOD(f525)();
	STDMETHOD(f526)();
	STDMETHOD(f527)();
	STDMETHOD(f528)();
	STDMETHOD(f529)();
	STDMETHOD(f530)();
	STDMETHOD(f531)();
	STDMETHOD(f532)();
	STDMETHOD(f533)();
	STDMETHOD(f534)();
	STDMETHOD(f535)();
	STDMETHOD(f536)();
	STDMETHOD(f537)();
	STDMETHOD(f538)();
	STDMETHOD(f539)();
	STDMETHOD(f540)();
	STDMETHOD(f541)();
	STDMETHOD(f542)();
	STDMETHOD(f543)();
	STDMETHOD(f544)();
	STDMETHOD(f545)();
	STDMETHOD(f546)();
	STDMETHOD(f547)();
	STDMETHOD(f548)();
	STDMETHOD(f549)();
	STDMETHOD(f550)();
	STDMETHOD(f551)();
	STDMETHOD(f552)();
	STDMETHOD(f553)();
	STDMETHOD(f554)();
	STDMETHOD(f555)();
	STDMETHOD(f556)();
	STDMETHOD(f557)();
	STDMETHOD(f558)();
	STDMETHOD(f559)();
	STDMETHOD(f560)();
	STDMETHOD(f561)();
	STDMETHOD(f562)();
	STDMETHOD(f563)();
	STDMETHOD(f564)();
	STDMETHOD(f565)();
	STDMETHOD(f566)();
	STDMETHOD(f567)();
	STDMETHOD(f568)();
	STDMETHOD(f569)();
	STDMETHOD(f570)();
	STDMETHOD(f571)();
	STDMETHOD(f572)();
	STDMETHOD(f573)();
	STDMETHOD(f574)();
	STDMETHOD(f575)();
	STDMETHOD(f576)();
	STDMETHOD(f577)();
	STDMETHOD(f578)();
	STDMETHOD(f579)();
	STDMETHOD(f580)();
	STDMETHOD(f581)();
	STDMETHOD(f582)();
	STDMETHOD(f583)();
	STDMETHOD(f584)();
	STDMETHOD(f585)();
	STDMETHOD(f586)();
	STDMETHOD(f587)();
	STDMETHOD(f588)();
	STDMETHOD(f589)();
	STDMETHOD(f590)();
	STDMETHOD(f591)();
	STDMETHOD(f592)();
	STDMETHOD(f593)();
	STDMETHOD(f594)();
	STDMETHOD(f595)();
	STDMETHOD(f596)();
	STDMETHOD(f597)();
	STDMETHOD(f598)();
	STDMETHOD(f599)();
	STDMETHOD(f600)();
	STDMETHOD(f601)();
	STDMETHOD(f602)();
	STDMETHOD(f603)();
	STDMETHOD(f604)();
	STDMETHOD(f605)();
	STDMETHOD(f606)();
	STDMETHOD(f607)();
	STDMETHOD(f608)();
	STDMETHOD(f609)();
	STDMETHOD(f610)();
	STDMETHOD(f611)();
	STDMETHOD(f612)();
	STDMETHOD(f613)();
	STDMETHOD(f614)();
	STDMETHOD(f615)();
	STDMETHOD(f616)();
	STDMETHOD(f617)();
	STDMETHOD(f618)();
	STDMETHOD(f619)();
	STDMETHOD(f620)();
	STDMETHOD(f621)();
	STDMETHOD(f622)();
	STDMETHOD(f623)();
	STDMETHOD(f624)();
	STDMETHOD(f625)();
	STDMETHOD(f626)();
	STDMETHOD(f627)();
	STDMETHOD(f628)();
	STDMETHOD(f629)();
	STDMETHOD(f630)();
	STDMETHOD(f631)();
	STDMETHOD(f632)();
	STDMETHOD(f633)();
	STDMETHOD(f634)();
	STDMETHOD(f635)();
	STDMETHOD(f636)();
	STDMETHOD(f637)();
	STDMETHOD(f638)();
	STDMETHOD(f639)();
	STDMETHOD(f640)();
	STDMETHOD(f641)();
	STDMETHOD(f642)();
	STDMETHOD(f643)();
	STDMETHOD(f644)();
	STDMETHOD(f645)();
	STDMETHOD(f646)();
	STDMETHOD(f647)();
	STDMETHOD(f648)();
	STDMETHOD(f649)();
	STDMETHOD(f650)();
	STDMETHOD(f651)();
	STDMETHOD(f652)();
	STDMETHOD(f653)();
	STDMETHOD(f654)();
	STDMETHOD(f655)();
	STDMETHOD(f656)();
	STDMETHOD(f657)();
	STDMETHOD(f658)();
	STDMETHOD(f659)();
	STDMETHOD(f660)();
	STDMETHOD(f661)();
	STDMETHOD(f662)();
	STDMETHOD(f663)();
	STDMETHOD(f664)();
	STDMETHOD(f665)();
	STDMETHOD(f666)();
	STDMETHOD(f667)();
	STDMETHOD(f668)();
	STDMETHOD(f669)();
	STDMETHOD(f670)();
	STDMETHOD(f671)();
	STDMETHOD(f672)();
	STDMETHOD(f673)();
	STDMETHOD(f674)();
	STDMETHOD(f675)();
	STDMETHOD(f676)();
	STDMETHOD(f677)();
	STDMETHOD(f678)();
	STDMETHOD(f679)();
	STDMETHOD(f680)();
	STDMETHOD(f681)();
	STDMETHOD(f682)();
	STDMETHOD(f683)();
	STDMETHOD(f684)();
	STDMETHOD(f685)();
	STDMETHOD(f686)();
	STDMETHOD(f687)();
	STDMETHOD(f688)();
	STDMETHOD(f689)();
	STDMETHOD(f690)();
	STDMETHOD(f691)();
	STDMETHOD(f692)();
	STDMETHOD(f693)();
	STDMETHOD(f694)();
	STDMETHOD(f695)();
	STDMETHOD(f696)();
	STDMETHOD(f697)();
	STDMETHOD(f698)();
	STDMETHOD(f699)();
	STDMETHOD(f700)();
	STDMETHOD(f701)();
	STDMETHOD(f702)();
	STDMETHOD(f703)();
	STDMETHOD(f704)();
	STDMETHOD(f705)();
	STDMETHOD(f706)();
	STDMETHOD(f707)();
	STDMETHOD(f708)();
	STDMETHOD(f709)();
	STDMETHOD(f710)();
	STDMETHOD(f711)();
	STDMETHOD(f712)();
	STDMETHOD(f713)();
	STDMETHOD(f714)();
	STDMETHOD(f715)();
	STDMETHOD(f716)();
	STDMETHOD(f717)();
	STDMETHOD(f718)();
	STDMETHOD(f719)();
	STDMETHOD(f720)();
	STDMETHOD(f721)();
	STDMETHOD(f722)();
	STDMETHOD(f723)();
	STDMETHOD(f724)();
	STDMETHOD(f725)();
	STDMETHOD(f726)();
	STDMETHOD(f727)();
	STDMETHOD(f728)();
	STDMETHOD(f729)();
	STDMETHOD(f730)();
	STDMETHOD(f731)();
	STDMETHOD(f732)();
	STDMETHOD(f733)();
	STDMETHOD(f734)();
	STDMETHOD(f735)();
	STDMETHOD(f736)();
	STDMETHOD(f737)();
	STDMETHOD(f738)();
	STDMETHOD(f739)();
	STDMETHOD(f740)();
	STDMETHOD(f741)();
	STDMETHOD(f742)();
	STDMETHOD(f743)();
	STDMETHOD(f744)();
	STDMETHOD(f745)();
	STDMETHOD(f746)();
	STDMETHOD(f747)();
	STDMETHOD(f748)();
	STDMETHOD(f749)();
	STDMETHOD(f750)();
	STDMETHOD(f751)();
	STDMETHOD(f752)();
	STDMETHOD(f753)();
	STDMETHOD(f754)();
	STDMETHOD(f755)();
	STDMETHOD(f756)();
	STDMETHOD(f757)();
	STDMETHOD(f758)();
	STDMETHOD(f759)();
	STDMETHOD(f760)();
	STDMETHOD(f761)();
	STDMETHOD(f762)();
	STDMETHOD(f763)();
	STDMETHOD(f764)();
	STDMETHOD(f765)();
	STDMETHOD(f766)();
	STDMETHOD(f767)();
	STDMETHOD(f768)();
	STDMETHOD(f769)();
	STDMETHOD(f770)();
	STDMETHOD(f771)();
	STDMETHOD(f772)();
	STDMETHOD(f773)();
	STDMETHOD(f774)();
	STDMETHOD(f775)();
	STDMETHOD(f776)();
	STDMETHOD(f777)();
	STDMETHOD(f778)();
	STDMETHOD(f779)();
	STDMETHOD(f780)();
	STDMETHOD(f781)();
	STDMETHOD(f782)();
	STDMETHOD(f783)();
	STDMETHOD(f784)();
	STDMETHOD(f785)();
	STDMETHOD(f786)();
	STDMETHOD(f787)();
	STDMETHOD(f788)();
	STDMETHOD(f789)();
	STDMETHOD(f790)();
	STDMETHOD(f791)();
	STDMETHOD(f792)();
	STDMETHOD(f793)();
	STDMETHOD(f794)();
	STDMETHOD(f795)();
	STDMETHOD(f796)();
	STDMETHOD(f797)();
	STDMETHOD(f798)();
	STDMETHOD(f799)();
	STDMETHOD(f800)();
	STDMETHOD(f801)();
	STDMETHOD(f802)();
	STDMETHOD(f803)();
	STDMETHOD(f804)();
	STDMETHOD(f805)();
	STDMETHOD(f806)();
	STDMETHOD(f807)();
	STDMETHOD(f808)();
	STDMETHOD(f809)();
	STDMETHOD(f810)();
	STDMETHOD(f811)();
	STDMETHOD(f812)();
	STDMETHOD(f813)();
	STDMETHOD(f814)();
	STDMETHOD(f815)();
	STDMETHOD(f816)();
	STDMETHOD(f817)();
	STDMETHOD(f818)();
	STDMETHOD(f819)();
	STDMETHOD(f820)();
	STDMETHOD(f821)();
	STDMETHOD(f822)();
	STDMETHOD(f823)();
	STDMETHOD(f824)();
	STDMETHOD(f825)();
	STDMETHOD(f826)();
	STDMETHOD(f827)();
	STDMETHOD(f828)();
	STDMETHOD(f829)();
	STDMETHOD(f830)();
	STDMETHOD(f831)();
	STDMETHOD(f832)();
	STDMETHOD(f833)();
	STDMETHOD(f834)();
	STDMETHOD(f835)();
	STDMETHOD(f836)();
	STDMETHOD(f837)();
	STDMETHOD(f838)();
	STDMETHOD(f839)();
	STDMETHOD(f840)();
	STDMETHOD(f841)();
	STDMETHOD(f842)();
	STDMETHOD(f843)();
	STDMETHOD(f844)();
	STDMETHOD(f845)();
	STDMETHOD(f846)();
	STDMETHOD(f847)();
	STDMETHOD(f848)();
	STDMETHOD(f849)();
	STDMETHOD(f850)();
	STDMETHOD(f851)();
	STDMETHOD(f852)();
	STDMETHOD(f853)();
	STDMETHOD(f854)();
	STDMETHOD(f855)();
	STDMETHOD(f856)();
	STDMETHOD(f857)();
	STDMETHOD(f858)();
	STDMETHOD(f859)();
	STDMETHOD(f860)();
	STDMETHOD(f861)();
	STDMETHOD(f862)();
	STDMETHOD(f863)();
	STDMETHOD(f864)();
	STDMETHOD(f865)();
	STDMETHOD(f866)();
	STDMETHOD(f867)();
	STDMETHOD(f868)();
	STDMETHOD(f869)();
	STDMETHOD(f870)();
	STDMETHOD(f871)();
	STDMETHOD(f872)();
	STDMETHOD(f873)();
	STDMETHOD(f874)();
	STDMETHOD(f875)();
	STDMETHOD(f876)();
	STDMETHOD(f877)();
	STDMETHOD(f878)();
	STDMETHOD(f879)();
	STDMETHOD(f880)();
	STDMETHOD(f881)();
	STDMETHOD(f882)();
	STDMETHOD(f883)();
	STDMETHOD(f884)();
	STDMETHOD(f885)();
	STDMETHOD(f886)();
	STDMETHOD(f887)();
	STDMETHOD(f888)();
	STDMETHOD(f889)();
	STDMETHOD(f890)();
	STDMETHOD(f891)();
	STDMETHOD(f892)();
	STDMETHOD(f893)();
	STDMETHOD(f894)();
	STDMETHOD(f895)();
	STDMETHOD(f896)();
	STDMETHOD(f897)();
	STDMETHOD(f898)();
	STDMETHOD(f899)();
	STDMETHOD(f900)();
	STDMETHOD(f901)();
	STDMETHOD(f902)();
	STDMETHOD(f903)();
	STDMETHOD(f904)();
	STDMETHOD(f905)();
	STDMETHOD(f906)();
	STDMETHOD(f907)();
	STDMETHOD(f908)();
	STDMETHOD(f909)();
	STDMETHOD(f910)();
	STDMETHOD(f911)();
	STDMETHOD(f912)();
	STDMETHOD(f913)();
	STDMETHOD(f914)();
	STDMETHOD(f915)();
	STDMETHOD(f916)();
	STDMETHOD(f917)();
	STDMETHOD(f918)();
	STDMETHOD(f919)();
	STDMETHOD(f920)();
	STDMETHOD(f921)();
	STDMETHOD(f922)();
	STDMETHOD(f923)();
	STDMETHOD(f924)();
	STDMETHOD(f925)();
	STDMETHOD(f926)();
	STDMETHOD(f927)();
	STDMETHOD(f928)();
	STDMETHOD(f929)();
	STDMETHOD(f930)();
	STDMETHOD(f931)();
	STDMETHOD(f932)();
	STDMETHOD(f933)();
	STDMETHOD(f934)();
	STDMETHOD(f935)();
	STDMETHOD(f936)();
	STDMETHOD(f937)();
	STDMETHOD(f938)();
	STDMETHOD(f939)();
	STDMETHOD(f940)();
	STDMETHOD(f941)();
	STDMETHOD(f942)();
	STDMETHOD(f943)();
	STDMETHOD(f944)();
	STDMETHOD(f945)();
	STDMETHOD(f946)();
	STDMETHOD(f947)();
	STDMETHOD(f948)();
	STDMETHOD(f949)();
	STDMETHOD(f950)();
	STDMETHOD(f951)();
	STDMETHOD(f952)();
	STDMETHOD(f953)();
	STDMETHOD(f954)();
	STDMETHOD(f955)();
	STDMETHOD(f956)();
	STDMETHOD(f957)();
	STDMETHOD(f958)();
	STDMETHOD(f959)();
	STDMETHOD(f960)();
	STDMETHOD(f961)();
	STDMETHOD(f962)();
	STDMETHOD(f963)();
	STDMETHOD(f964)();
	STDMETHOD(f965)();
	STDMETHOD(f966)();
	STDMETHOD(f967)();
	STDMETHOD(f968)();
	STDMETHOD(f969)();
	STDMETHOD(f970)();
	STDMETHOD(f971)();
	STDMETHOD(f972)();
	STDMETHOD(f973)();
	STDMETHOD(f974)();
	STDMETHOD(f975)();
	STDMETHOD(f976)();
	STDMETHOD(f977)();
	STDMETHOD(f978)();
	STDMETHOD(f979)();
	STDMETHOD(f980)();
	STDMETHOD(f981)();
	STDMETHOD(f982)();
	STDMETHOD(f983)();
	STDMETHOD(f984)();
	STDMETHOD(f985)();
	STDMETHOD(f986)();
	STDMETHOD(f987)();
	STDMETHOD(f988)();
	STDMETHOD(f989)();
	STDMETHOD(f990)();
	STDMETHOD(f991)();
	STDMETHOD(f992)();
	STDMETHOD(f993)();
	STDMETHOD(f994)();
	STDMETHOD(f995)();
	STDMETHOD(f996)();
	STDMETHOD(f997)();
	STDMETHOD(f998)();
	STDMETHOD(f999)();
	STDMETHOD(f1000)();
	STDMETHOD(f1001)();
	STDMETHOD(f1002)();
	STDMETHOD(f1003)();
	STDMETHOD(f1004)();
	STDMETHOD(f1005)();
	STDMETHOD(f1006)();
	STDMETHOD(f1007)();
	STDMETHOD(f1008)();
	STDMETHOD(f1009)();
	STDMETHOD(f1010)();
	STDMETHOD(f1011)();
	STDMETHOD(f1012)();
	STDMETHOD(f1013)();
	STDMETHOD(f1014)();
	STDMETHOD(f1015)();
	STDMETHOD(f1016)();
	STDMETHOD(f1017)();
	STDMETHOD(f1018)();
	STDMETHOD(f1019)();
	STDMETHOD(f1020)();
	STDMETHOD(f1021)();
	STDMETHOD(f1022)();
	STDMETHOD(f1023)();

	_QIThunk(
		_In_ IUnknown* pOrig,
		_In_z_ LPCTSTR p,
		_In_ const IID& i,
		_In_ UINT n,
		_In_ bool b)
	{
		m_lpszClassName = p;
		m_iid = i;
		m_nIndex = n;
		m_dwRef = 0;
		m_dwMaxRef = 0;
		ATLENSURE(pOrig);
		m_pUnk = pOrig;
		m_bBreak = b;
		m_bNonAddRefThunk = false;
	}
	IUnknown* m_pUnk;
	long m_dwRef;
	long m_dwMaxRef;
	LPCTSTR m_lpszClassName;
	IID m_iid;
	UINT m_nIndex;
	bool m_bBreak;
	bool m_bNonAddRefThunk;
	void Dump() throw();
};

#endif

/////////////////////////////////////////////////////////////////////////////
// Module Classes


#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif // _ATL_STATIC_REGISTRY


class CAtlComModule : 
	public _ATL_COM_MODULE
{
public:

	CAtlComModule() throw()
	{
		cbSize = 0;

		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
		m_ppAutoObjMapLast = &__pobjMapEntryLast;

		if (FAILED(m_csObjMap.Init()))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlComModule\n"));
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
			return;
		}
		// Set cbSize on success.
		cbSize = sizeof(_ATL_COM_MODULE);
	}

	~CAtlComModule()
	{
		Term();
	}

	// Called from ~CAtlComModule or from ~CAtlExeModule.
	void Term()
	{
		if (cbSize == 0)
			return;

		for (_ATL_OBJMAP_ENTRY** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)
		{
			if (*ppEntry != NULL)
			{
				_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
				if (pEntry->pCF != NULL)
					pEntry->pCF->Release();
				pEntry->pCF = NULL;
			}
		}
		m_csObjMap.Term();
		// Set to 0 to indicate that this function has been called
		// At this point no one should be concerned about cbsize
		// having the correct value
		cbSize = 0;
	}

	// Registry support (helpers)
	HRESULT RegisterTypeLib()
	{
		return AtlRegisterTypeLib(m_hInstTypeLib, NULL);
	}
	HRESULT RegisterTypeLib(_In_opt_z_ LPCTSTR lpszIndex)
	{
		USES_CONVERSION_EX;
		LPCOLESTR pwszTemp = NULL;
		if( lpszIndex != NULL )
		{
			pwszTemp = T2COLE_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
			if( pwszTemp == NULL )
				return E_OUTOFMEMORY;
#endif
		}
		return AtlRegisterTypeLib(m_hInstTypeLib, pwszTemp);
	}
	HRESULT UnRegisterTypeLib()
	{
		return AtlUnRegisterTypeLib(m_hInstTypeLib, NULL);
	}
	HRESULT UnRegisterTypeLib(_In_opt_z_ LPCTSTR lpszIndex)
	{
		USES_CONVERSION_EX;
		LPCOLESTR pwszTemp = NULL;
		if( lpszIndex != NULL )
		{
			pwszTemp = T2COLE_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
			if( pwszTemp == NULL )
				return E_OUTOFMEMORY;
#endif
		}
		return AtlUnRegisterTypeLib(m_hInstTypeLib, pwszTemp);
	}

	// RegisterServer walks the ATL Autogenerated object map and registers each object in the map
	// If pCLSID is not NULL then only the object referred to by pCLSID is registered (The default case)
	// otherwise all the objects are registered
	HRESULT RegisterServer(
		_In_ BOOL bRegTypeLib = FALSE,
		_In_opt_ const CLSID* pCLSID = NULL)
	{
		return AtlComModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	// UnregisterServer walks the ATL Autogenerated object map and unregisters each object in the map
	// If pCLSID is not NULL then only the object referred to by pCLSID is unregistered (The default case)
	// otherwise all the objects are unregistered.
	HRESULT UnregisterServer(
		_In_ BOOL bRegTypeLib = FALSE,
		_In_opt_ const CLSID* pCLSID = NULL)
	{
		return AtlComModuleUnregisterServer(this, bRegTypeLib, pCLSID);
	}

	// Implementation

	// Call ObjectMain for all the objects.
	void ExecuteObjectMain(_In_ bool bStarting)
	{
		for (_ATL_OBJMAP_ENTRY** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)
		{
			if (*ppEntry != NULL)
				(*ppEntry)->pfnObjectMain(bStarting);
		}
	}
};

extern CAtlComModule _AtlComModule;

#ifdef _ATL_DEBUG_INTERFACES

class CAtlDebugInterfacesModule
{
public:
	CAtlDebugInterfacesModule() throw() :
		m_nIndexQI( 0 ),
		m_nIndexBreakAt( 0 )
	{
		if (FAILED(m_cs.Init()))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to initialize critical section in CAtlDebugInterfacesModule\n"));
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
		}
	}
	~CAtlDebugInterfacesModule() throw()
	{
		// Release all class factories.
		_AtlComModule.Term();
		DumpLeakedThunks();
	}

	HRESULT AddThunk(
		_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
		_In_z_ LPCTSTR lpsz,
		_In_ REFIID iid) throw()
	{
		if ((pp == NULL) || (*pp == NULL))
			return E_POINTER;
		IUnknown* p = *pp;
		_QIThunk* pThunk = NULL;
		CComCritSecLock<CComCriticalSection> lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CAtlDebugInterfacesModule\n"));
			ATLASSERT(0);
			return hr;
		}

		// Check if exists for identity
		if (InlineIsEqualUnknown(iid))
		{
			for (int i = 0; i < m_aThunks.GetSize(); i++)
			{
				if (m_aThunks[i]->m_pUnk == p && InlineIsEqualGUID(m_aThunks[i]->m_iid, iid))
				{
					m_aThunks[i]->InternalAddRef();
					pThunk = m_aThunks[i];
					break;
				}
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
			{
				return E_OUTOFMEMORY;
			}
			pThunk->InternalAddRef();
			m_aThunks.Add(pThunk);
		}
		*pp = (IUnknown*)pThunk;
		return S_OK;
	}
	HRESULT AddNonAddRefThunk(
		_In_ IUnknown* p,
		_In_z_ LPCTSTR lpsz,
		_Deref_out_ IUnknown** ppThunkRet) throw()
	{
		if (ppThunkRet == NULL)
			return E_POINTER;
		*ppThunkRet = NULL;

		_QIThunk* pThunk = NULL;
		CComCritSecLock<CComCriticalSection> lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CAtlDebugInterfacesModule\n"));
			ATLASSERT(0);
			return hr;
		}

		// Check if exists already for identity
		for (int i = 0; i < m_aThunks.GetSize(); i++)
		{
			if (m_aThunks[i]->m_pUnk == p)
			{
				m_aThunks[i]->m_bNonAddRefThunk = true;
				pThunk = m_aThunks[i];
				break;
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, __uuidof(IUnknown), m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
			{
				return E_OUTOFMEMORY;
			}
			pThunk->m_bNonAddRefThunk = true;
			m_aThunks.Add(pThunk);
		}
		*ppThunkRet = (IUnknown*)pThunk;
		return S_OK;;
	}
	void DeleteNonAddRefThunk(_In_ IUnknown* pUnk) throw()
	{
		CComCritSecLock<CComCriticalSection> lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CAtlDebugInterfacesModule\n"));
			ATLASSERT(0);
			return;
		}

		for (int i = 0; i < m_aThunks.GetSize(); i++)
		{
			if (m_aThunks[i]->m_bNonAddRefThunk && m_aThunks[i]->m_pUnk == pUnk)
			{
				delete m_aThunks[i];
				m_aThunks.RemoveAt(i);
				break;
			}
		}
	}
	void DeleteThunk(_In_ _QIThunk* p) throw()
	{
		CComCritSecLock<CComCriticalSection> lock(m_cs, false);
		HRESULT hr = lock.Lock();
		if (FAILED(hr))
		{
			ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CAtlDebugInterfacesModule\n"));
			ATLASSERT(0);
			return;
		}

		int nIndex = m_aThunks.Find(p);
		if (nIndex != -1)
		{
			m_aThunks[nIndex]->m_pUnk = NULL;
			delete m_aThunks[nIndex];
			m_aThunks.RemoveAt(nIndex);
		}
	}
	bool DumpLeakedThunks()
	{
		bool b = false;
		for (int i = 0; i < m_aThunks.GetSize(); i++)
		{
			b = true;
			m_aThunks[i]->Dump();
			delete m_aThunks[i];
		}
		m_aThunks.RemoveAll();
		return b;
	}

public:
	UINT m_nIndexQI;
	UINT m_nIndexBreakAt;
	CSimpleArray<_QIThunk*> m_aThunks;
	CComAutoDeleteCriticalSection m_cs;
};

extern CAtlDebugInterfacesModule _AtlDebugInterfacesModule;

#ifndef _ATL_STATIC_LIB_IMPL
// Should not be pulled into the static lib
__declspec (selectany) CAtlDebugInterfacesModule _AtlDebugInterfacesModule;
#endif

inline ULONG _QIThunk::Release()
{
	ATLASSUME(m_pUnk != NULL);
	if (m_bBreak)
		DebugBreak();
	ATLASSUME(m_dwRef > 0);

	// save copies of member variables we wish to use after the InterlockedDecrement
	UINT nIndex = m_nIndex;
	IUnknown* pUnk = m_pUnk;
	IID iid = m_iid;
	LPCTSTR lpszClassName = m_lpszClassName;
	bool bNonAddRefThunk = m_bNonAddRefThunk;

	ULONG l = InterlockedDecrement(&m_dwRef);

	TCHAR buf[512+1];
	_stprintf_s(buf, _countof(buf), _T("QIThunk - %-10d\tRelease :\tObject = 0x%p\tRefcount = %d\t"), nIndex, pUnk, l);
	buf[_countof(buf)-1] = 0;
	OutputDebugString(buf);
	AtlDumpIID(iid, lpszClassName, S_OK);

	bool bDeleteThunk = (l == 0 && !bNonAddRefThunk);
	pUnk->Release();
	if (bDeleteThunk)
		_AtlDebugInterfacesModule.DeleteThunk(this);
	return l;
}

#endif 	// _ATL_DEBUG_INTERFACES


class CAtlWinModule : 
	public _ATL_WIN_MODULE
{
public:
	CAtlWinModule()
	{
		cbSize = sizeof(_ATL_WIN_MODULE);
		HRESULT hr = AtlWinModuleInit(this);
		if (FAILED(hr))
		{
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
			cbSize = 0;
			return;
		}
	}

	~CAtlWinModule()
	{
		Term();
	}

	void Term()
	{
		AtlWinModuleTerm(this, _AtlBaseModule.GetModuleInstance());
	}

	void AddCreateWndData(_Inout_ _AtlCreateWndData* pData, _In_ void* pObject)
	{
		AtlWinModuleAddCreateWndData(this, pData, pObject);
	}

	void* ExtractCreateWndData()
	{
		return AtlWinModuleExtractCreateWndData(this);
	}
};

extern CAtlWinModule _AtlWinModule;

class CAtlModule;
__declspec(selectany) CAtlModule* _pAtlModule = NULL;

#if defined(_M_CEE) && !defined(_ATL_MIXED)

// This small class takes care of releasing the class factories at managed
// shutdown when we are compiling /clr. We can't wait to call _AtlComModule.Term()
// in _AtlComModule destructor, since _AtlComModule is a native global object, and it
// will be destructed after the managed runtime has been shutdown.

// Notice that if the user defines _ATL_MIXED, he/she will need to take care
// of releasing the eventual managed class factories at the right time.

class CAtlReleaseManagedClassFactories
{
public:
	CAtlReleaseManagedClassFactories() { }
	~CAtlReleaseManagedClassFactories()
	{
		_AtlComModule.Term();
	}
};

__declspec (selectany) CAtlReleaseManagedClassFactories _AtlReleaseManagedClassFactories;

extern "C"
{
__declspec (selectany) void *_pAtlReleaseManagedClassFactories = &_AtlReleaseManagedClassFactories;
}
#if defined(_M_IX86)
	#pragma comment(linker, "/include:__pAtlReleaseManagedClassFactories")
#else
	#pragma comment(linker, "/include:_pAtlReleaseManagedClassFactories")
#endif

#endif

class ATL_NO_VTABLE CAtlModule : 
	public _ATL_MODULE
{
public :
	static GUID m_libid;
	IGlobalInterfaceTable* m_pGIT;

	CAtlModule() throw()
	{
		// Should have only one instance of a class
		// derived from CAtlModule in a project.
		ATLASSERT(_pAtlModule == NULL);
		cbSize = 0;
		m_pTermFuncs = NULL;

		m_nLockCnt = 0;
		_pAtlModule = this;
		m_pGIT = NULL;

		if (FAILED(m_csStaticDataInitAndTypeInfo.Init()))
		{
			ATLTRACE(atlTraceGeneral, 0, _T("ERROR : Unable to initialize critical section in CAtlModule\n"));
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
			return;
		}

		// Set cbSize on success.
		cbSize = sizeof(_ATL_MODULE);
	}

	void Term() throw()
	{
		// cbSize == 0 indicates that Term has already been called
		if (cbSize == 0)
			return;

		// Call term functions
		if (m_pTermFuncs != NULL)
		{
			AtlCallTermFunc(this);
			m_pTermFuncs = NULL;
		}

		if (m_pGIT != NULL)
			m_pGIT->Release();

		m_csStaticDataInitAndTypeInfo.Term();

		cbSize = 0;
	}

	virtual ~CAtlModule() throw()
	{
		Term();
	}

	virtual LONG Lock() throw()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}

	virtual LONG Unlock() throw()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}

	virtual LONG GetLockCount() throw()
	{
		return m_nLockCnt;
	}

	HRESULT AddTermFunc(
		_In_ _ATL_TERMFUNC* pFunc, 
		_In_ DWORD_PTR dw) throw()
	{
		return AtlModuleAddTermFunc(this, pFunc, dw);
	}

	virtual HRESULT GetGITPtr(_Deref_out_ IGlobalInterfaceTable** ppGIT) throw()
	{
		ATLASSERT(ppGIT != NULL);

		if (ppGIT == NULL)
			return E_POINTER;

		HRESULT hr = S_OK;
		if (m_pGIT == NULL)
		{
			hr = ::CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
				__uuidof(IGlobalInterfaceTable), (void**)&m_pGIT);
		}

		if (SUCCEEDED(hr))
		{
			ATLASSUME(m_pGIT != NULL);
			*ppGIT = m_pGIT;
			m_pGIT->AddRef();
		}
		return hr;
	}

	virtual HRESULT AddCommonRGSReplacements(_Inout_ IRegistrarBase* /*pRegistrar*/) throw() = 0;

	// Resource-based Registration
#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(
		_In_z_ LPCTSTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();
	HRESULT WINAPI UpdateRegistryFromResourceS(
		_In_ UINT nResID,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();
#else
	HRESULT WINAPI UpdateRegistryFromResourceD(
		_In_z_ LPCTSTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		if(lpszRes == NULL)
			return E_INVALIDARG;

		USES_CONVERSION_EX;
		LPCOLESTR pwszTemp = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		ATLASSUME(pwszTemp != NULL);
#ifdef _UNICODE
		if(pwszTemp == NULL)
			return E_OUTOFMEMORY;
#endif
		return UpdateRegistryFromResourceDHelper(pwszTemp, bRegister, pMapEntries);
	}
	HRESULT WINAPI UpdateRegistryFromResourceD(
		_In_ UINT nResID,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		return UpdateRegistryFromResourceDHelper((LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
	}
#endif

	// Implementation
#if !defined(_ATL_STATIC_REGISTRY)
	inline HRESULT WINAPI UpdateRegistryFromResourceDHelper(
		_In_z_ LPCOLESTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		CComPtr<IRegistrar> spRegistrar;
		HRESULT hr = AtlCreateRegistrar(&spRegistrar);
		if (FAILED(hr))
			return hr;

		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				ATLASSERT(NULL != pMapEntries->szData);
				spRegistrar->AddReplacement(pMapEntries->szKey, pMapEntries->szData);
				pMapEntries++;
			}
		}

		hr = AddCommonRGSReplacements(spRegistrar);
		if (FAILED(hr))
			return hr;

		return AtlUpdateRegistryFromResourceD(_AtlBaseModule.GetModuleInstance(), lpszRes, bRegister,
			NULL, spRegistrar);
	}
#endif

	static void EscapeSingleQuote(
		_Out_z_cap_(destSizeInChars) LPOLESTR lpDest,
		_In_ size_t destSizeInChars,
		_In_z_ LPCOLESTR lp) throw()
	{
		if (destSizeInChars == 0)
		{
			return;
		}
		UINT i = 0;
		// copy charecters to the destination buffer but leave the last char to be NULL.
		for (i=0; i < destSizeInChars-1 && *lp; i++)
		{
			*lpDest++ = *lp;
			// make sure we won't promote lpDest behind the buffer limit.
			if (*lp == '\'' && ++i < destSizeInChars-1)
				*lpDest++ = *lp;
			lp++;
		}
		*lpDest = '\0';
	}

	ATL_DEPRECATED("CAtlModule::EscapeSingleQuote(dest, src) is unsafe. Instead, use CAtlModule::EscapeSingleQuote(dest, size, src)")
	static void EscapeSingleQuote(
		_Out_ _Post_z_ LPOLESTR lpDest,
		_In_z_ LPCOLESTR lp) throw()
	{
ATLPREFAST_SUPPRESS(6386)
		EscapeSingleQuote(lpDest, SIZE_MAX/sizeof(OLECHAR), lp);
ATLPREFAST_UNSUPPRESS()
	}

	// search for an occurence of string p2 in string p1
	static LPCTSTR FindOneOf(
		_In_z_ LPCTSTR p1,
		_In_z_ LPCTSTR p2) throw()
	{
		while (p1 != NULL && *p1 != _T('\0'))
		{
			LPCTSTR p = p2;
			while (p != NULL && *p != _T('\0'))
			{
				if (*p1 == *p)
					return CharNext(p1);
				p = CharNext(p);
			}
			p1 = CharNext(p1);
		}
		return NULL;
	}
#pragma warning(push)
#pragma warning(disable : 4302)	// 'type cast' : truncation from 'LPSTR' to 'TCHAR'

	static int WordCmpI(
		_In_z_ LPCTSTR psz1,
		_In_z_ LPCTSTR psz2) throw()
	{
		TCHAR c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
		TCHAR c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
		while (c1 != _T('\0') && c1 == c2 && c1 != ' ' && c1 != '\t')
		{
			psz1 = CharNext(psz1);
			psz2 = CharNext(psz2);
			c1 = (TCHAR)CharUpper((LPTSTR)*psz1);
			c2 = (TCHAR)CharUpper((LPTSTR)*psz2);
		}
		if ((c1 == _T('\0') || c1 == ' ' || c1 == '\t') && (c2 == _T('\0') || c2 == ' ' || c2 == '\t'))
			return 0;

		return (c1 < c2) ? -1 : 1;
	}

#pragma warning (pop)
};

__declspec(selectany) GUID CAtlModule::m_libid = {0x0, 0x0, 0x0, {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0} };

#define DECLARE_LIBID(libid) \
	static void InitLibId() throw() \
	{ \
		ATL::CAtlModule::m_libid = libid; \
	}

#define DECLARE_REGISTRY_APPID_RESOURCEID(resid, appid) \
	static LPCOLESTR GetAppId() throw() \
	{ \
		return OLESTR(appid); \
	} \
	static TCHAR* GetAppIdT() throw() \
	{ \
		return _T(appid); \
	} \
	static HRESULT WINAPI UpdateRegistryAppId(_In_ BOOL bRegister) throw() \
	{ \
		ATL::_ATL_REGMAP_ENTRY aMapEntries [] = \
		{ \
			{ OLESTR("APPID"), GetAppId() }, \
			{ NULL, NULL } \
		}; \
		return ATL::_pAtlModule->UpdateRegistryFromResource(resid, bRegister, aMapEntries); \
	}

inline HRESULT AtlGetGITPtr(_Deref_out_ IGlobalInterfaceTable** ppGIT) throw()
{
	if (ppGIT == NULL)
		return E_POINTER;

	if (_pAtlModule == NULL)
	{
		return CoCreateInstance(CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER,
			__uuidof(IGlobalInterfaceTable), (void**)ppGIT);
	}
	else
	{
		return _pAtlModule->GetGITPtr(ppGIT);
	}
}

template <class T>
class ATL_NO_VTABLE CAtlModuleT : 
	public CAtlModule
{
public :
	CAtlModuleT() throw()
	{
		T::InitLibId();
	}

	static void InitLibId() throw()
	{
	}

	HRESULT RegisterServer(
		_In_ BOOL bRegTypeLib = FALSE,
		_In_opt_ const CLSID* pCLSID = NULL) throw()
	{
		(pCLSID);
		(bRegTypeLib);

		HRESULT hr = S_OK;

#ifndef _ATL_NO_COM_SUPPORT

		hr = _AtlComModule.RegisterServer(bRegTypeLib, pCLSID);

#endif	// _ATL_NO_COM_SUPPORT


#ifndef _ATL_NO_PERF_SUPPORT

		if (SUCCEEDED(hr) && _pPerfRegFunc != NULL)
			hr = (*_pPerfRegFunc)(_AtlBaseModule.m_hInst);

#endif

		return hr;
	}

	HRESULT UnregisterServer(
		_In_ BOOL bUnRegTypeLib,
		_In_opt_ const CLSID* pCLSID = NULL) throw()
	{
		(bUnRegTypeLib);
		(pCLSID);

		HRESULT hr = S_OK;

#ifndef _ATL_NO_PERF_SUPPORT

		if (_pPerfUnRegFunc != NULL)
			hr = (*_pPerfUnRegFunc)();

#endif

#ifndef _ATL_NO_COM_SUPPORT

		if (SUCCEEDED(hr))
			hr = _AtlComModule.UnregisterServer(bUnRegTypeLib, pCLSID);

#endif	// _ATL_NO_COM_SUPPORT

		return hr;

	}

	static HRESULT WINAPI UpdateRegistryAppId(_In_ BOOL /*bRegister*/) throw()
	{
		return S_OK;
	}
	HRESULT RegisterAppId() throw()
	{
		return T::UpdateRegistryAppId(TRUE);
	}

	HRESULT UnregisterAppId() throw()
	{
		return T::UpdateRegistryAppId(FALSE);
	}

	virtual HRESULT AddCommonRGSReplacements(_Inout_ IRegistrarBase* pRegistrar) throw()
	{
		return pRegistrar->AddReplacement(L"APPID", T::GetAppId());
	}
	static LPCOLESTR GetAppId() throw()
	{
		return OLESTR("");
	}
};

#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
namespace __identifier("<AtlImplementationDetails>")
#pragma warning(pop)
{
	__declspec(selectany) bool DllModuleInitialized = false;
}

#endif

template <class T>
class ATL_NO_VTABLE CAtlDllModuleT : 
	public CAtlModuleT<T>
{
public :
	CAtlDllModuleT() throw()
	{
		_AtlComModule.ExecuteObjectMain(true);
#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
		using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
		ATLASSERT(DllModuleInitialized == false);
		DllModuleInitialized = true;
		_DllMain(DLL_PROCESS_ATTACH, NULL);
#endif
	}

	~CAtlDllModuleT() throw()
	{
#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
		using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
		ATLASSERT(DllModuleInitialized == true);
		_DllMain(DLL_PROCESS_DETACH, NULL);
#endif
		_AtlComModule.ExecuteObjectMain(false);
	}

	BOOL WINAPI DllMain(
		_In_ DWORD dwReason,
		_In_opt_ LPVOID lpReserved) throw();

	BOOL WINAPI _DllMain(
		_In_ DWORD dwReason,
		_In_opt_ LPVOID /* lpReserved */) throw()
	{
		if (dwReason == DLL_PROCESS_ATTACH)
		{
			if (CAtlBaseModule::m_bInitFailed)
			{
				ATLASSERT(0);
				return FALSE;
			}
		}
#ifdef _DEBUG
		else if (dwReason == DLL_PROCESS_DETACH)
		{
			// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
			_AtlWinModule.Term();
		}
#endif	// _DEBUG
		return TRUE;    // ok
	}

	HRESULT DllCanUnloadNow() throw()
	{
		T* pT = static_cast<T*>(this);
		return (pT->GetLockCount()==0) ? S_OK : S_FALSE;
	}

	HRESULT DllGetClassObject(
		_In_ REFCLSID rclsid,
		_In_ REFIID riid,
		_Deref_out_ LPVOID* ppv) throw()
	{
		T* pT = static_cast<T*>(this);
		return pT->GetClassObject(rclsid, riid, ppv);
	}

	HRESULT DllRegisterServer(
		_In_ BOOL bRegTypeLib = TRUE) throw()
	{
		LCID lcid = GetThreadLocale();
		SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
		// registers object, typelib and all interfaces in typelib
		T* pT = static_cast<T*>(this);
		HRESULT hr = pT->RegisterAppId();
		if (SUCCEEDED(hr))
			hr = pT->RegisterServer(bRegTypeLib);
		SetThreadLocale(lcid);
		return hr;
	}

	HRESULT DllUnregisterServer(
		_In_ BOOL bUnRegTypeLib = TRUE) throw()
	{
		LCID lcid = GetThreadLocale();
		SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
		T* pT = static_cast<T*>(this);
		HRESULT hr = pT->UnregisterServer(bUnRegTypeLib);
		if (SUCCEEDED(hr))
			hr = pT->UnregisterAppId();
		SetThreadLocale(lcid);
		return hr;
	}

	// Obtain a Class Factory
	HRESULT GetClassObject(
		_In_ REFCLSID rclsid,
		_In_ REFIID riid,
		_Deref_out_ LPVOID* ppv) throw()
	{
		return AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
	}
};

#pragma managed(push, off)

template <class T>
inline BOOL WINAPI CAtlDllModuleT<T>::DllMain(
	_In_ DWORD dwReason,
	_In_opt_ LPVOID lpReserved) throw()
{
#if !defined(_ATL_NATIVE_INITIALIZATION)
	UNREFERENCED_PARAMETER(dwReason); UNREFERENCED_PARAMETER(lpReserved);
#pragma warning(push)
#pragma warning(disable:4483)
	using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		ATLASSERT(DllModuleInitialized == false);
	}
	return TRUE;
#else
	return _DllMain(dwReason, lpReserved);
#endif
}

#pragma managed(pop)

#ifndef _AFX


template <class T>
class ATL_NO_VTABLE CAtlExeModuleT : 
	public CAtlModuleT<T>
{
public :
#ifndef _ATL_NO_COM_SUPPORT

	DWORD m_dwMainThreadID;
	HANDLE m_hEventShutdown;
	DWORD m_dwTimeOut;
	DWORD m_dwPause;
	bool m_bDelayShutdown;
	bool m_bActivity;
	bool m_bComInitialized;    // Flag that indicates if ATL initialized COM

#endif // _ATL_NO_COM_SUPPORT

	CAtlExeModuleT() throw()

#ifndef _ATL_NO_COM_SUPPORT

		: m_dwMainThreadID(::GetCurrentThreadId()),
		m_dwTimeOut(5000),
		m_dwPause(1000),
		m_hEventShutdown(NULL),
		m_bDelayShutdown(true),
		m_bComInitialized(false)

#endif // _ATL_NO_COM_SUPPORT

	{
#if !defined(_ATL_NO_COM_SUPPORT)

		_AtlComModule.ExecuteObjectMain(true);

#endif	//  !defined(_ATL_NO_COM_SUPPORT)

	}

	~CAtlExeModuleT() throw()
	{
#ifndef _ATL_NO_COM_SUPPORT

		_AtlComModule.ExecuteObjectMain(false);

#endif

		// Call term functions before COM is uninitialized
		Term();

#ifndef _ATL_NO_COM_SUPPORT

		// Clean up AtlComModule before COM is uninitialized
		_AtlComModule.Term();

#endif // _ATL_NO_COM_SUPPORT
	}

	static HRESULT InitializeCom() throw()
	{
#if defined(_ATL_FREE_THREADED)
		return CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
		return CoInitialize(NULL);
#endif
	}

	static void UninitializeCom() throw()
	{
		CoUninitialize();
	}

	LONG Lock() throw()
	{
		return CoAddRefServerProcess();
	}

	LONG Unlock() throw()
	{
		LONG lRet = CoReleaseServerProcess();

#ifndef _ATL_NO_COM_SUPPORT

		if (lRet == 0)
		{
			if (m_bDelayShutdown)
			{
				m_bActivity = true;
				::SetEvent(m_hEventShutdown); // tell monitor that we transitioned to zero
			}
			else
			{
				::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
			}
		}

#endif	// _ATL_NO_COM_SUPPORT

		return lRet;
	}
#ifndef _ATL_NO_COM_SUPPORT

	void MonitorShutdown() throw()
	{
		::WaitForSingleObject(m_hEventShutdown, INFINITE);
		::CloseHandle(m_hEventShutdown);
		::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
	}

	HANDLE StartMonitor() throw()
	{
		m_hEventShutdown = ::CreateEvent(NULL, false, false, NULL);
		if (m_hEventShutdown == NULL)
		{
			return NULL;
		}
		DWORD dwThreadID;
		HANDLE hThread = ::CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
		if(hThread==NULL)
		{
			::CloseHandle(m_hEventShutdown);
		}
		return hThread;
	}

	static DWORD WINAPI MonitorProc(_In_ void* pv) throw()
	{
		CAtlExeModuleT<T>* p = static_cast<CAtlExeModuleT<T>*>(pv);
		p->MonitorShutdown();
		return 0;
	}
#endif	// _ATL_NO_COM_SUPPORT

	int WinMain(_In_ int nShowCmd) throw()
	{
		if (CAtlBaseModule::m_bInitFailed)
		{
			ATLASSERT(0);
			return -1;
		}
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;

#if !defined(_ATL_NO_COM_SUPPORT)
		hr = T::InitializeCom();
		if (FAILED(hr))
		{
			// Ignore RPC_E_CHANGED_MODE if CLR is loaded. Error is due to CLR initializing
			// COM and InitializeCOM trying to initialize COM with different flags.
			if (hr != RPC_E_CHANGED_MODE || GetModuleHandle(_T("Mscoree.dll")) == NULL)
			{
				ATLASSERT(0);
				return hr;
			}
		}
		else
		{
			m_bComInitialized = true;
		}
#endif	//  !defined(_ATL_NO_COM_SUPPORT)

		LPTSTR lpCmdLine = GetCommandLine();
		if (pT->ParseCommandLine(lpCmdLine, &hr) == true)
			hr = pT->Run(nShowCmd);

#ifdef _DEBUG
		// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
		_AtlWinModule.Term();
#endif	// _DEBUG

#ifndef _ATL_NO_COM_SUPPORT
		if (m_bComInitialized)
			T::UninitializeCom();
#endif // _ATL_NO_COM_SUPPORT

		return hr;
	}

	// Scan command line and perform registration
	// Return value specifies if server should run

	// Parses the command line and registers/unregisters the rgs file if necessary
	bool ParseCommandLine(
		_In_z_ LPCTSTR lpCmdLine,
		_Out_ HRESULT* pnRetCode) throw()
	{
		*pnRetCode = S_OK;

		TCHAR szTokens[] = _T("-/");

		T* pT = static_cast<T*>(this);
		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while (lpszToken != NULL)
		{
			if (WordCmpI(lpszToken, _T("UnregServer"))==0)
			{
				*pnRetCode = pT->UnregisterServer(TRUE);
				if (SUCCEEDED(*pnRetCode))
					*pnRetCode = pT->UnregisterAppId();
				return false;
			}

			if (WordCmpI(lpszToken, _T("RegServer"))==0)
			{
				*pnRetCode = pT->RegisterAppId();
				if (SUCCEEDED(*pnRetCode))
					*pnRetCode = pT->RegisterServer(TRUE);
				return false;
			}

			if (WordCmpI(lpszToken, _T("UnregServerPerUser"))==0)
			{
				*pnRetCode = AtlSetPerUserRegistration(true);
				if (FAILED(*pnRetCode))
				{
					return false;
				}

				*pnRetCode = pT->UnregisterServer(TRUE);
				if (SUCCEEDED(*pnRetCode))
					*pnRetCode = pT->UnregisterAppId();
				return false;
			}

			if (WordCmpI(lpszToken, _T("RegServerPerUser"))==0)
			{
				*pnRetCode = AtlSetPerUserRegistration(true);
				if (FAILED(*pnRetCode))
				{
					return false;
				}

				*pnRetCode = pT->RegisterAppId();
				if (SUCCEEDED(*pnRetCode))
					*pnRetCode = pT->RegisterServer(TRUE);
				return false;
			}

			lpszToken = FindOneOf(lpszToken, szTokens);
		}

		return true;
	}

	HRESULT PreMessageLoop(_In_ int /*nShowCmd*/) throw()
	{
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);
		pT;

#ifndef _ATL_NO_COM_SUPPORT

#if defined(_ATL_FREE_THREADED)

		// NOTE: much of this code is duplicated in CAtlServiceModuleT::PreMessageLoop below, so
		// if you make changes to either method make sure to change both methods (if necessary).

		hr = pT->RegisterClassObjects(CLSCTX_LOCAL_SERVER,
			REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);

		if (FAILED(hr))
			return hr;

		if (hr == S_OK)
		{
			if (m_bDelayShutdown)
			{
				CHandle h(pT->StartMonitor());
				if (h.m_h == NULL)
				{
					hr = E_FAIL;
				}
				else
				{
					hr = CoResumeClassObjects();
					ATLASSERT(SUCCEEDED(hr));
					if (FAILED(hr))
					{
						::SetEvent(m_hEventShutdown); // tell monitor to shutdown
						::WaitForSingleObject(h, m_dwTimeOut * 2);
					}
				}
			}
			else
			{
				hr = CoResumeClassObjects();
				ATLASSERT(SUCCEEDED(hr));
			}

			if (FAILED(hr))
				pT->RevokeClassObjects();
		}
		else
		{
			m_bDelayShutdown = false;
		}

#else

		hr = pT->RegisterClassObjects(CLSCTX_LOCAL_SERVER,
			REGCLS_MULTIPLEUSE);
		if (hr == S_OK)
		{
			if (m_bDelayShutdown && !pT->StartMonitor())
			{
				hr = E_FAIL;
			}
		}
		else
		{
			m_bDelayShutdown = false;
		}


#endif

#endif	// _ATL_NO_COM_SUPPORT

		ATLASSERT(SUCCEEDED(hr));
		return hr;
	}

	HRESULT PostMessageLoop() throw()
	{
		HRESULT hr = S_OK;

#ifndef _ATL_NO_COM_SUPPORT

		T* pT = static_cast<T*>(this);
		hr = pT->RevokeClassObjects();
		if (m_bDelayShutdown)
			Sleep(m_dwPause); //wait for any threads to finish

#endif	// _ATL_NO_COM_SUPPORT

		return hr;
	}

	void RunMessageLoop() throw()
	{
		MSG msg;
		while (GetMessage(&msg, 0, 0, 0) > 0)
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

	HRESULT Run(_In_ int nShowCmd = SW_HIDE) throw()
	{
		HRESULT hr = S_OK;

		T* pT = static_cast<T*>(this);
		hr = pT->PreMessageLoop(nShowCmd);

		// Call RunMessageLoop only if PreMessageLoop returns S_OK.
		if (hr == S_OK)
		{
			pT->RunMessageLoop();
		}

		// Call PostMessageLoop if PreMessageLoop returns success.
		if (SUCCEEDED(hr))
		{
			hr = pT->PostMessageLoop();
		}

		ATLASSERT(SUCCEEDED(hr));
		return hr;
	}

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(
		_In_ DWORD dwClsContext,
		_In_ DWORD dwFlags) throw()
	{
		return AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
	}
	HRESULT RevokeClassObjects() throw()
	{
		return AtlComModuleRevokeClassObjects(&_AtlComModule);
	}
};

#ifndef _ATL_NO_SERVICE
template <class T, UINT nServiceNameID>
class ATL_NO_VTABLE CAtlServiceModuleT : 
	public CAtlExeModuleT<T>
{
public :

	CAtlServiceModuleT() throw()
	{
		m_bService = TRUE;
		LoadString(_AtlBaseModule.GetModuleInstance(), nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

		// set up the initial service status
		m_hServiceStatus = NULL;
		m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
		m_status.dwCurrentState = SERVICE_STOPPED;
		m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
		m_status.dwWin32ExitCode = 0;
		m_status.dwServiceSpecificExitCode = 0;
		m_status.dwCheckPoint = 0;
		m_status.dwWaitHint = 0;
	}

	int WinMain(_In_ int nShowCmd) throw()
	{
		if (CAtlBaseModule::m_bInitFailed)
		{
			ATLASSERT(0);
			return -1;
		}

		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;

		LPTSTR lpCmdLine = GetCommandLine();
		if (pT->ParseCommandLine(lpCmdLine, &hr) == true)
			hr = pT->Start(nShowCmd);

#ifdef _DEBUG
		// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
		_AtlWinModule.Term();
#endif	// _DEBUG
		return hr;
	}

	HRESULT Start(_In_ int nShowCmd) throw()
	{
		T* pT = static_cast<T*>(this);
		// Are we Service or Local Server
		CRegKey keyAppID;
		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
		if (lRes != ERROR_SUCCESS)
		{
			m_status.dwWin32ExitCode = lRes;
			return m_status.dwWin32ExitCode;
		}

		CRegKey key;
		lRes = key.Open(keyAppID, pT->GetAppIdT(), KEY_READ);
		if (lRes != ERROR_SUCCESS)
		{
			m_status.dwWin32ExitCode = lRes;
			return m_status.dwWin32ExitCode;
		}

		TCHAR szValue[MAX_PATH];
		DWORD dwLen = MAX_PATH;
		lRes = key.QueryStringValue(_T("LocalService"), szValue, &dwLen);

		m_bService = FALSE;
		if (lRes == ERROR_SUCCESS)
			m_bService = TRUE;

		if (m_bService)
		{
			SERVICE_TABLE_ENTRY st[] =
			{
				{ m_szServiceName, _ServiceMain },
				{ NULL, NULL }
			};
			if (::StartServiceCtrlDispatcher(st) == 0)
				m_status.dwWin32ExitCode = GetLastError();
			return m_status.dwWin32ExitCode;
		}
		// local server - call Run() directly, rather than
		// from ServiceMain()
		m_status.dwWin32ExitCode = pT->Run(nShowCmd);
		return m_status.dwWin32ExitCode;
	}

	inline HRESULT RegisterAppId(_In_ bool bService = false) throw()
	{
		if (!Uninstall())
			return E_FAIL;

		HRESULT hr = T::UpdateRegistryAppId(TRUE);
		if (FAILED(hr))
			return hr;

		CRegKey keyAppID;
		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
		if (lRes != ERROR_SUCCESS)
			return AtlHresultFromWin32(lRes);

		CRegKey key;

		lRes = key.Create(keyAppID, T::GetAppIdT());
		if (lRes != ERROR_SUCCESS)
			return AtlHresultFromWin32(lRes);

		key.DeleteValue(_T("LocalService"));

		if (!bService)
			return S_OK;

		key.SetStringValue(_T("LocalService"), m_szServiceName);

		// Create service
		if (!Install())
			return E_FAIL;
		return S_OK;
	}

	HRESULT UnregisterAppId() throw()
	{
		if (!Uninstall())
			return E_FAIL;
		// First remove entries not in the RGS file.
		CRegKey keyAppID;
		LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
		if (lRes != ERROR_SUCCESS)
			return AtlHresultFromWin32(lRes);

		CRegKey key;
		lRes = key.Open(keyAppID, T::GetAppIdT(), KEY_WRITE);
		if (lRes != ERROR_SUCCESS)
			return AtlHresultFromWin32(lRes);
		key.DeleteValue(_T("LocalService"));

		return T::UpdateRegistryAppId(FALSE);
	}

	// Parses the command line and registers/unregisters the rgs file if necessary
	bool ParseCommandLine(
		_In_z_ LPCTSTR lpCmdLine,
		_Out_ HRESULT* pnRetCode) throw()
	{
		if (!CAtlExeModuleT<T>::ParseCommandLine(lpCmdLine, pnRetCode))
			return false;

		TCHAR szTokens[] = _T("-/");
		*pnRetCode = S_OK;

		T* pT = static_cast<T*>(this);
		LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
		while (lpszToken != NULL)
		{
			if (WordCmpI(lpszToken, _T("Service"))==0)
			{
				*pnRetCode = pT->RegisterAppId(true);
				if (SUCCEEDED(*pnRetCode))
					*pnRetCode = pT->RegisterServer(TRUE);
				return false;
			}
			lpszToken = FindOneOf(lpszToken, szTokens);
		}
		return true;
	}

	void ServiceMain(
		_In_ DWORD dwArgc,
		_In_count_(dwArgc) _Deref_pre_z_ LPTSTR* lpszArgv) throw()
	{
		lpszArgv;
		dwArgc;
		// Register the control request handler
		m_status.dwCurrentState = SERVICE_START_PENDING;
		m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
		if (m_hServiceStatus == NULL)
		{
			LogEvent(_T("Handler not installed"));
			return;
		}
		SetServiceStatus(SERVICE_START_PENDING);

		m_status.dwWin32ExitCode = S_OK;
		m_status.dwCheckPoint = 0;
		m_status.dwWaitHint = 0;

		T* pT = static_cast<T*>(this);
#ifndef _ATL_NO_COM_SUPPORT

		HRESULT hr = E_FAIL;
		hr = T::InitializeCom();
		if (FAILED(hr))
		{
			// Ignore RPC_E_CHANGED_MODE if CLR is loaded. Error is due to CLR initializing
			// COM and InitializeCOM trying to initialize COM with different flags.
			if (hr != RPC_E_CHANGED_MODE || GetModuleHandle(_T("Mscoree.dll")) == NULL)
			{
				return;
			}
		}
		else
		{
			m_bComInitialized = true;
		}

		m_bDelayShutdown = false;
#endif //_ATL_NO_COM_SUPPORT
		// When the Run function returns, the service has stopped.
		m_status.dwWin32ExitCode = pT->Run(SW_HIDE);

#ifndef _ATL_NO_COM_SUPPORT
		if (m_bService && m_bComInitialized)
			T::UninitializeCom();
#endif

		SetServiceStatus(SERVICE_STOPPED);
		LogEvent(_T("Service stopped"));
	}

	HRESULT Run(_In_ int nShowCmd = SW_HIDE) throw()
	{
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);

		hr = pT->PreMessageLoop(nShowCmd);

		if (hr == S_OK)
		{
			pT->RunMessageLoop();
		}

		if (SUCCEEDED(hr))
		{
			hr = pT->PostMessageLoop();
		}

		return hr;
	}

	HRESULT PreMessageLoop(_In_ int nShowCmd) throw()
	{
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);		

		if (m_bService)
		{
			m_dwThreadID = GetCurrentThreadId();			
			hr = pT->InitializeSecurity();

			if (FAILED(hr))
			{
				return hr;
			}
		}

#ifndef _ATL_NO_COM_SUPPORT

#if defined(_ATL_FREE_THREADED)

		// NOTE: much of this code is duplicated in CAtlExeModuleT::PreMessageLoop above, so if
		// you make changes to either method make sure to change both methods (if necessary).

		hr = pT->RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
		if (FAILED(hr))
		{
			return hr;
		}

		if (hr == S_OK)
		{
			if (m_bDelayShutdown)
			{
				CHandle h(pT->StartMonitor());
				if (h.m_h == NULL)
				{
					hr = E_FAIL;
				}
				else
				{
					if (m_bService)
					{
						LogEvent(_T("Service started/resumed"));
						SetServiceStatus(SERVICE_RUNNING);
					}

					hr = CoResumeClassObjects();
					ATLASSERT(SUCCEEDED(hr));
					if (FAILED(hr))
					{
						::SetEvent(m_hEventShutdown); // tell monitor to shutdown
						::WaitForSingleObject(h, m_dwTimeOut * 2);
					}
				}
			}
			else
			{
				if (m_bService)
				{
					LogEvent(_T("Service started/resumed"));
					SetServiceStatus(SERVICE_RUNNING);
				}

				hr = CoResumeClassObjects();
				ATLASSERT(SUCCEEDED(hr));
			}

			if (FAILED(hr))
				pT->RevokeClassObjects();
		}
		else
		{
			m_bDelayShutdown = false;
		}

#else
		hr = CAtlExeModuleT<T>::PreMessageLoop(nShowCmd);
#endif // _ATL_FREE_THREADED

#endif	// _ATL_NO_COM_SUPPORT

		ATLASSERT(SUCCEEDED(hr));
		return hr;
	}

	void OnStop() throw()
	{
		SetServiceStatus(SERVICE_STOP_PENDING);
		PostThreadMessage(m_dwThreadID, WM_QUIT, 0, 0);
	}

	void OnPause() throw()
	{
	}

	void OnContinue() throw()
	{
	}

	void OnInterrogate() throw()
	{
	}

	void OnShutdown() throw()
	{
	}

	void OnUnknownRequest(_In_ DWORD /*dwOpcode*/) throw()
	{
		LogEvent(_T("Bad service request"));
	}

	void Handler(_In_ DWORD dwOpcode) throw()
	{
		T* pT = static_cast<T*>(this);

		switch (dwOpcode)
		{
		case SERVICE_CONTROL_STOP:
			pT->OnStop();
			break;
		case SERVICE_CONTROL_PAUSE:
			pT->OnPause();
			break;
		case SERVICE_CONTROL_CONTINUE:
			pT->OnContinue();
			break;
		case SERVICE_CONTROL_INTERROGATE:
			pT->OnInterrogate();
			break;
		case SERVICE_CONTROL_SHUTDOWN:
			pT->OnShutdown();
			break;
		default:
			pT->OnUnknownRequest(dwOpcode);
		}
	}

	BOOL IsInstalled() throw()
	{
		BOOL bResult = FALSE;

		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

		if (hSCM != NULL)
		{
			SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
			if (hService != NULL)
			{
				bResult = TRUE;
				::CloseServiceHandle(hService);
			}
			::CloseServiceHandle(hSCM);
		}
		return bResult;
	}
	BOOL Install() throw()
	{
		if (IsInstalled())
			return TRUE;

		// Get the executable file path
		TCHAR szFilePath[MAX_PATH + _ATL_QUOTES_SPACE];
		DWORD dwFLen = ::GetModuleFileName(NULL, szFilePath + 1, MAX_PATH);
		if( dwFLen == 0 || dwFLen == MAX_PATH )
			return FALSE;

		// Quote the FilePath before calling CreateService
		szFilePath[0] = _T('\"');
		szFilePath[dwFLen + 1] = _T('\"');
		szFilePath[dwFLen + 2] = 0;

		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
		if (hSCM == NULL)
		{
			TCHAR szBuf[1024];
			if (AtlLoadString(ATL_SERVICE_MANAGER_OPEN_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
#else
				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
#endif
			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
			return FALSE;
		}

		SC_HANDLE hService = ::CreateService(
			hSCM, m_szServiceName, m_szServiceName,
			SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
			SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
			szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

		if (hService == NULL)
		{
			::CloseServiceHandle(hSCM);
			TCHAR szBuf[1024];
			if (AtlLoadString(ATL_SERVICE_START_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not start service"));
#else
				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not start service"));
#endif
			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
			return FALSE;
		}

		::CloseServiceHandle(hService);
		::CloseServiceHandle(hSCM);
		return TRUE;
	}

	BOOL Uninstall() throw()
	{
		if (!IsInstalled())
			return TRUE;

		SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

		if (hSCM == NULL)
		{
			TCHAR szBuf[1024];
			if (AtlLoadString(ATL_SERVICE_MANAGER_OPEN_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
#else
				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open Service Manager"));
#endif
			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
			return FALSE;
		}

		SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

		if (hService == NULL)
		{
			::CloseServiceHandle(hSCM);
			TCHAR szBuf[1024];
			if (AtlLoadString(ATL_SERVICE_OPEN_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
				Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not open service"));
#else
				Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not open service"));
#endif
			MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
			return FALSE;
		}
		SERVICE_STATUS status;
		BOOL bRet = ::ControlService(hService, SERVICE_CONTROL_STOP, &status);
		if (!bRet)
		{
			DWORD dwError = GetLastError();
			if (!((dwError == ERROR_SERVICE_NOT_ACTIVE) ||  (dwError == ERROR_SERVICE_CANNOT_ACCEPT_CTRL && status.dwCurrentState == SERVICE_STOP_PENDING)))
			{
				TCHAR szBuf[1024];
				if (AtlLoadString(ATL_SERVICE_STOP_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
					Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not stop service"));
#else
					Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not stop service"));
#endif
				MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
			}
		}

		BOOL bDelete = ::DeleteService(hService);
		::CloseServiceHandle(hService);
		::CloseServiceHandle(hSCM);

		if (bDelete)
			return TRUE;

		TCHAR szBuf[1024];
		if (AtlLoadString(ATL_SERVICE_DELETE_ERROR, szBuf, 1024) == 0)
#ifdef UNICODE
			Checked::wcscpy_s(szBuf, _countof(szBuf), _T("Could not delete service"));
#else
			Checked::strcpy_s(szBuf, _countof(szBuf), _T("Could not delete service"));
#endif
		MessageBox(NULL, szBuf, m_szServiceName, MB_OK);
		return FALSE;
	}

	LONG Unlock() throw()
	{
		LONG lRet;
		if (m_bService)
		{
			// We are running as a service, therefore transition to zero does not
			// unload the process
			lRet = CAtlModuleT<T>::Unlock();
		}
		else
		{
			// We are running as EXE, use MonitorShutdown logic provided by CExeModule
			lRet = CAtlExeModuleT<T>::Unlock();
		}
		return lRet;
	}

	void LogEventEx(
		_In_ int id,
		_In_opt_z_ LPCTSTR pszMessage=NULL,
		_In_ WORD type = EVENTLOG_INFORMATION_TYPE) throw()
	{
		HANDLE hEventSource;
		if (m_szServiceName)
		{
			/* Get a handle to use with ReportEvent(). */
			hEventSource = RegisterEventSource(NULL, m_szServiceName);
			if (hEventSource != NULL)
			{
				/* Write to event log. */
				ReportEvent(hEventSource,
							type,
							(WORD)0,
							id,
							NULL,
							(WORD)(pszMessage != NULL ? 1 : 0),
							0,
							pszMessage != NULL ? &pszMessage : NULL,
							NULL);
				DeregisterEventSource(hEventSource);
			}
		}
	}

#pragma warning(push)
#pragma warning(disable : 4793)
	void __cdecl LogEvent(
		_In_z_ _Printf_format_string_ LPCTSTR pszFormat, ...) throw()
	{
		const int LOG_EVENT_MSG_SIZE = 256;

		TCHAR chMsg[LOG_EVENT_MSG_SIZE];
		HANDLE hEventSource;
		LPTSTR lpszStrings[1];
		va_list pArg;

		va_start(pArg, pszFormat);
		_vsntprintf_s(chMsg, LOG_EVENT_MSG_SIZE, LOG_EVENT_MSG_SIZE-1, pszFormat, pArg);
		va_end(pArg);

		chMsg[LOG_EVENT_MSG_SIZE - 1] = 0;

		lpszStrings[0] = chMsg;

		if (!m_bService)
		{
			// Not running as a service, so print out the error message
			// to the console if possible
			_putts(chMsg);
		}

		/* Get a handle to use with ReportEvent(). */
		hEventSource = RegisterEventSource(NULL, m_szServiceName);
		if (hEventSource != NULL)
		{
			/* Write to event log. */
			ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
			DeregisterEventSource(hEventSource);
		}
	}
#pragma warning(pop)

	void SetServiceStatus(_In_ DWORD dwState) throw()
	{
		m_status.dwCurrentState = dwState;
		::SetServiceStatus(m_hServiceStatus, &m_status);
	}

//Implementation
protected:
	static void WINAPI _ServiceMain(
		_In_ DWORD dwArgc,
		_In_count_(dwArgc) _Deref_pre_z_ LPTSTR* lpszArgv) throw()
	{
		((T*)_pAtlModule)->ServiceMain(dwArgc, lpszArgv);
	}
	static void WINAPI _Handler(_In_ DWORD dwOpcode) throw()
	{
		((T*)_pAtlModule)->Handler(dwOpcode);
	}

// data members
public:
	TCHAR m_szServiceName[256];
	SERVICE_STATUS_HANDLE m_hServiceStatus;
	SERVICE_STATUS m_status;
	BOOL m_bService;
	DWORD m_dwThreadID;
};

#endif //	_ATL_NO_SERVICE

#endif	// !_AFX

#ifdef _AFX

class CAtlMfcModule : 
	public ATL::CAtlModuleT<CAtlMfcModule>
{
public :
	virtual LONG Lock() throw()
	{
#ifdef _USRDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		AfxOleLockApp();
		return AfxGetModuleState()->m_nObjectCount;
	}

	virtual LONG Unlock() throw()
	{
#ifdef _USRDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		AfxOleUnlockApp();
		return AfxGetModuleState()->m_nObjectCount;
	}

	virtual LONG GetLockCount() throw()
	{
#ifdef _USRDLL
		AFX_MANAGE_STATE(AfxGetStaticModuleState());
#endif
		return AfxGetModuleState()->m_nObjectCount;
	}

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(
		_In_ REFCLSID rclsid,
		_In_ REFIID riid,
		_Deref_out_ LPVOID* ppv)
	{
		return ATL::AtlComModuleGetClassObject(&ATL::_AtlComModule, rclsid, riid, ppv);
	}

	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(
		_In_ DWORD dwClsContext,
		_In_ DWORD dwFlags)
	{
		return ATL::AtlComModuleRegisterClassObjects(&ATL::_AtlComModule, dwClsContext, dwFlags);
	}

	HRESULT RevokeClassObjects()
	{
		return ATL::AtlComModuleRevokeClassObjects(&ATL::_AtlComModule);
	}
};

#endif //	_AFX

/////////////////////////////////////////////////////////////////////////////
// CComModule - Uses the functionality provided by other modules

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

#ifndef _ATL_NO_COMMODULE

class CComModule;

#if !defined(_ATL_NATIVE_INITIALIZATION)

#pragma managed(push, off)

#pragma warning(push)
#pragma warning(disable:4483)
namespace __identifier("<AtlImplementationDetails>")
#pragma warning(pop)
{
	struct CComModuleHelper
	{
		CComModule* Module;
		HINSTANCE Instance;
		_ATL_OBJMAP_ENTRY* ObjectMap;
		const GUID* LibraryId;

		// Must NOT have any constructors
		// We initialize the object in DllMain *before*
		// the constructors would run.

		void Initialize(
			_In_ CComModule* pModule,
			_In_ HINSTANCE hInstance,
			_In_ _ATL_OBJMAP_ENTRY* pObjMap,
			_In_ const GUID* pLibID)
		{
			Module = pModule;
			Instance = hInstance;
			ObjectMap = pObjMap;
			LibraryId = pLibID;
		}
	};

	__declspec(selectany) CComModuleHelper ComModuleHelper;
	__declspec(selectany) bool ComModuleInitialized = false;
}

#pragma managed(pop)

#endif


__declspec(selectany) CComModule* _pModule = NULL;
class CComModule : 
	public CAtlModuleT<CComModule>
{
public :

	CComModule()
	{
		// Should have only one instance of a class
		// derived from CComModule in a project.
		ATLASSERT(_pModule == NULL);
		_pModule = this;
#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
		using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
		ATLASSERT(ComModuleInitialized == false);
		// If ComModuleHelper.Module == NULL it mean that DllMain has not been called, so we assume CComModule lives in
		// an exe and not in a dll
		if (ComModuleHelper.Module != NULL)
		{
			ATLASSERT(ComModuleHelper.Module == this);
			_DllMain(ComModuleHelper.Instance, DLL_PROCESS_ATTACH, NULL, ComModuleHelper.ObjectMap, ComModuleHelper.LibraryId);
		}
		ComModuleInitialized = true;
#endif
	}

	~CComModule()
	{
#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
		using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
		ATLASSERT(ComModuleInitialized == true);
		// If ComModuleHelper.Module == NULL it mean that DllMain has not been called, so we assume CComModule lives in
		// an exe and not in a dll
		if (ComModuleHelper.Module != NULL)
		{
			ATLASSERT(ComModuleHelper.Module == this);
			_DllMain(ComModuleHelper.Instance, DLL_PROCESS_DETACH, NULL, ComModuleHelper.ObjectMap, ComModuleHelper.LibraryId);
		}
#endif
	}

	__declspec(property(get = get_m_hInst)) HINSTANCE m_hInst;
	HINSTANCE& get_m_hInst() const throw()
	{
		return _AtlBaseModule.m_hInst;
	}

	__declspec(property(get = get_m_hInstResource, put = put_m_hInstResource)) HINSTANCE m_hInstResource;
	HINSTANCE& get_m_hInstResource() const throw()
	{
		return _AtlBaseModule.m_hInstResource;
	}
	void put_m_hInstResource(_In_ HINSTANCE h) throw()
	{
		_AtlBaseModule.SetResourceInstance(h);
	}
	HINSTANCE SetResourceInstance(_In_ HINSTANCE h) throw()
	{
		return _AtlBaseModule.SetResourceInstance(h);
	}

	HINSTANCE GetModuleInstance() throw()
	{
		return _AtlBaseModule.m_hInst;
	}
	HINSTANCE GetResourceInstance() throw()
	{
		return _AtlBaseModule.m_hInstResource;
	}

	__declspec(property(get = get_m_hInstTypeLib, put = put_m_hInstTypeLib)) HINSTANCE m_hInstTypeLib;
	HINSTANCE& get_m_hInstTypeLib() const throw()
	{
		return _AtlComModule.m_hInstTypeLib;
	}
	void put_m_hInstTypeLib(_In_ HINSTANCE h) throw()
	{
		_AtlComModule.m_hInstTypeLib = h;
	}

	HINSTANCE GetTypeLibInstance() const throw()
	{
		return _AtlComModule.m_hInstTypeLib;
	}

	// For Backward compatibility
	_ATL_OBJMAP_ENTRY* m_pObjMap;

	__declspec(property(get  = get_m_csWindowCreate)) CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION& get_m_csWindowCreate() throw();

	__declspec(property(get  = get_m_csObjMap)) CRITICAL_SECTION m_csObjMap;
	CRITICAL_SECTION& get_m_csObjMap() throw();

	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csTypeInfoHolder;
	__declspec(property(get  = get_m_csStaticDataInit)) CRITICAL_SECTION m_csStaticDataInit;
	CRITICAL_SECTION& get_m_csStaticDataInit() throw();
	void EnterStaticDataCriticalSection() throw()
	{
		EnterCriticalSection(&m_csStaticDataInit);
	}

	void LeaveStaticDataCriticalSection() throw()
	{
		LeaveCriticalSection(&m_csStaticDataInit);
	}

	__declspec(property(get  = get_dwAtlBuildVer)) DWORD dwAtlBuildVer;
	DWORD& get_dwAtlBuildVer() throw()
	{
		return _AtlBaseModule.dwAtlBuildVer;
	}

	__declspec(property(get  = get_m_pCreateWndList, put = put_m_pCreateWndList)) _AtlCreateWndData* m_pCreateWndList;
	_AtlCreateWndData*& get_m_pCreateWndList() throw();
	void put_m_pCreateWndList(_In_ _AtlCreateWndData* p) throw();

	__declspec(property(get  = get_pguidVer)) const GUID* pguidVer;
	const GUID*& get_pguidVer() throw()
	{
		return _AtlBaseModule.pguidVer;
	}

#ifdef _ATL_DEBUG_INTERFACES

	__declspec(property(get  = get_m_nIndexQI, put = put_m_nIndexQI)) UINT m_nIndexQI;
	UINT& get_m_nIndexQI() throw();
	void put_m_nIndexQI(_In_ UINT nIndex) throw();

	__declspec(property(get  = get_m_nIndexBreakAt, put = put_m_nIndexBreakAt)) UINT m_nIndexBreakAt;
	UINT& get_m_nIndexBreakAt() throw();
	void put_m_nIndexBreakAt(_In_ UINT nIndex) throw();

	__declspec(property(get  = get_m_paThunks)) CSimpleArray<_QIThunk*>* m_paThunks;
	CSimpleArray<_QIThunk*>* get_m_paThunks() throw();
	HRESULT AddThunk(
		_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
		_In_z_ LPCTSTR lpsz,
		_In_ REFIID iid) throw();

	HRESULT AddNonAddRefThunk(
		_Inout_ IUnknown* p,
		_In_z_ LPCTSTR lpsz,
		_Deref_out_ IUnknown** ppThunkRet) throw();

	void DeleteNonAddRefThunk(_In_ IUnknown* pUnk) throw();
	void DeleteThunk(_In_ _QIThunk* p) throw();
	bool DumpLeakedThunks() throw();
#endif // _ATL_DEBUG_INTERFACES

	HRESULT Init(
		_In_ _ATL_OBJMAP_ENTRY* p,
		_In_ HINSTANCE h,
		_In_opt_ const GUID* plibid = NULL) throw();

	void Term() throw();

	HRESULT GetClassObject(
		_In_ REFCLSID rclsid,
		_In_ REFIID riid,
		_Deref_out_ LPVOID* ppv) throw();
	// Register/Revoke All Class Factories with the OS (EXE only)
	HRESULT RegisterClassObjects(_In_ DWORD dwClsContext, _In_ DWORD dwFlags) throw();
	HRESULT RevokeClassObjects() throw();
	// Registry support (helpers)
	HRESULT RegisterTypeLib() throw();
	HRESULT RegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw();
	HRESULT UnRegisterTypeLib() throw();
	HRESULT UnRegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw();
	HRESULT RegisterServer(
		_In_ BOOL bRegTypeLib = FALSE,
		_In_opt_ const CLSID* pCLSID = NULL) throw();
	HRESULT UnregisterServer(
		_In_ BOOL bUnRegTypeLib,
		_In_opt_ const CLSID* pCLSID = NULL) throw();
	HRESULT UnregisterServer(_In_opt_ const CLSID* pCLSID = NULL) throw();

	void AddCreateWndData(
		_In_ _AtlCreateWndData* pData,
		_In_ void* pObject) throw()
	{
		_AtlWinModule.AddCreateWndData(pData, pObject);
	}

	void* ExtractCreateWndData() throw()
	{
		return _AtlWinModule.ExtractCreateWndData();
	}

	// Only used in CComAutoThreadModule
	HRESULT CreateInstance(
		_In_opt_ void* /*pfnCreateInstance*/,
		_In_ REFIID /*riid*/,
		_In_opt_ void** /*ppvObj*/) throw()
	{
		ATLASSERT(0);
		ATLTRACENOTIMPL(_T("CComModule::CreateInstance"));
	}

	HRESULT RegisterAppId(_In_z_ LPCTSTR pAppId);
	HRESULT UnregisterAppId(_In_z_ LPCTSTR pAppId);

	// Resource-based Registration
#if defined(_ATL_STATIC_REGISTRY)	
	virtual HRESULT WINAPI UpdateRegistryFromResourceD(
		_In_opt_z_ LPCTSTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		(lpszRes);
		(bRegister);
		(pMapEntries);
		return E_FAIL;
	}
#else
	virtual HRESULT WINAPI UpdateRegistryFromResourceD(
		_In_z_ LPCTSTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceD(lpszRes, bRegister, pMapEntries);
	}
#endif	
	
	virtual HRESULT WINAPI UpdateRegistryFromResourceD(
		_In_ UINT nResID,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
#if defined(_ATL_STATIC_REGISTRY)
		(nResID);
		(bRegister);
		(pMapEntries);
		return E_FAIL;
#else
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceD(nResID, bRegister, pMapEntries);
#endif
	}

	// Statically linking to Registry Ponent
	virtual HRESULT WINAPI UpdateRegistryFromResourceS(
		_In_z_ LPCTSTR lpszRes,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
#ifdef _ATL_STATIC_REGISTRY
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(lpszRes, bRegister, pMapEntries);
#else
		(lpszRes);
		(bRegister);
		(pMapEntries);
		return E_FAIL;
#endif
	}
	virtual HRESULT WINAPI UpdateRegistryFromResourceS(
		_In_ UINT nResID,
		_In_ BOOL bRegister,
		_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
#ifdef _ATL_STATIC_REGISTRY
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(nResID, bRegister, pMapEntries);
#else
		(nResID);
		(bRegister);
		(pMapEntries);
		return E_FAIL;
#endif
	}

	// Use RGS file for registration

	ATL_DEPRECATED("CComModule::RegisterProgID is no longer recommended. Instead, use an RGS file for registration.")
	static HRESULT RegisterProgID(
		_In_z_ LPCTSTR lpszCLSID,
		_In_z_ LPCTSTR lpszProgID,
		_In_z_ LPCTSTR lpszUserDesc);

	ATL_DEPRECATED("CComModule::RegisterVersionIndependentProgID is no longer recommended. Instead, use an RGS file for registration.")
	static HRESULT RegisterVersionIndependentProgID(
		_In_z_ LPCTSTR lpszCLSID,
		_In_z_ LPCTSTR lpszVerIndProgID,
		_In_z_ LPCTSTR lpszCurVerProgID,
		_In_z_ LPCTSTR lpszUserDesc);

	// Standard Registration
	ATL_DEPRECATED("CComModule::UpdateRegistryClass is no longer recommended. Instead, use an RGS file for registration.")
	HRESULT WINAPI UpdateRegistryClass(
		_In_ const CLSID& clsid,
		_In_opt_z_ LPCTSTR lpszProgID,
		_In_opt_z_ LPCTSTR lpszVerIndProgID,
		_In_ UINT nDescID,
		_In_ DWORD dwFlags,
		_In_ BOOL bRegister);

	ATL_DEPRECATED("CComModule::UpdateRegistryClass is no longer recommended. Instead, use an RGS file for registration.")
	HRESULT WINAPI UpdateRegistryClass(
		_In_ const CLSID& clsid,
		_In_opt_z_ LPCTSTR lpszProgID,
		_In_opt_z_ LPCTSTR lpszVerIndProgID,
		_In_z_ LPCTSTR szDesc,
		_In_ DWORD dwFlags,
		_In_ BOOL bRegister);

	ATL_DEPRECATED("CComModule::RegisterClassHelper is no longer recommended. Instead, use an RGS file for registration.")
	HRESULT WINAPI RegisterClassHelper(
		_In_ const CLSID& clsid,
		_In_opt_z_ LPCTSTR lpszProgID,
		_In_opt_z_ LPCTSTR lpszVerIndProgID,
		_In_z_ LPCTSTR szDesc,
		_In_ DWORD dwFlags);

	ATL_DEPRECATED("CComModule::UnregisterClassHelper is no longer recommended. Instead, use an RGS file for registration.")
	HRESULT WINAPI UnregisterClassHelper(
		_In_ const CLSID& clsid,
		_In_opt_z_ LPCTSTR lpszProgID,
		_In_opt_z_ LPCTSTR lpszVerIndProgID);

	BOOL WINAPI DllMain(
		_In_ HINSTANCE hInstance,
		_In_ DWORD dwReason,
		_In_opt_ LPVOID /* lpReserved */,
		_In_ _ATL_OBJMAP_ENTRY* pObjMap,
		_In_ const GUID* pLibID);

	BOOL WINAPI _DllMain(
		_In_ HINSTANCE hInstance,
		_In_ DWORD dwReason,
		_In_opt_ LPVOID /* lpReserved */,
		_In_ _ATL_OBJMAP_ENTRY* pObjMap,
		_In_ const GUID* pLibID)
	{
		if (dwReason == DLL_PROCESS_ATTACH)
		{
			if (CAtlBaseModule::m_bInitFailed)
			{
				ATLASSERT(0);
				return FALSE;
			}

			if (FAILED(Init(pObjMap, hInstance, pLibID)))
			{
				Term();
				return FALSE;
			}
		}
		else if (dwReason == DLL_PROCESS_DETACH)
			Term();
		return TRUE;    // ok
	}

	HRESULT DllCanUnloadNow()  throw()
	{
		return (GetLockCount()==0) ? S_OK : S_FALSE;
	}
	HRESULT DllGetClassObject(
		_In_ REFCLSID rclsid,
		_In_ REFIID riid,
		_Deref_out_ LPVOID* ppv)  throw()
	{
		return GetClassObject(rclsid, riid, ppv);
	}

	HRESULT DllRegisterServer(_In_ BOOL bRegTypeLib = TRUE)  throw()
	{
		// registers object, typelib and all interfaces in typelib
		return RegisterServer(bRegTypeLib);
	}

	HRESULT DllUnregisterServer(_In_ BOOL bUnRegTypeLib = TRUE)  throw()
	{
		return UnregisterServer(bUnRegTypeLib);
	}

private:
	static HRESULT RegisterProgIDHelper(
		_In_z_ LPCTSTR lpszCLSID,
		_In_z_ LPCTSTR lpszProgID,
		_In_opt_z_ LPCTSTR lpszCurVerProgID,
		_In_z_ LPCTSTR lpszUserDesc,
		_In_ BOOL bIsVerIndProgID);
};

#pragma managed(push, off)
inline BOOL WINAPI CComModule::DllMain(
	_In_ HINSTANCE hInstance,
	_In_ DWORD dwReason,
	_In_opt_ LPVOID lpReserved,
	_In_ _ATL_OBJMAP_ENTRY* pObjMap,
	_In_ const GUID* pLibID)
{
#if !defined(_ATL_NATIVE_INITIALIZATION)
#pragma warning(push)
#pragma warning(disable:4483)
	using namespace __identifier("<AtlImplementationDetails>");
#pragma warning(pop)
	UNREFERENCED_PARAMETER(lpReserved);
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		ATLASSERT(ComModuleInitialized == false);
		ComModuleHelper.Initialize(this, hInstance, pObjMap, pLibID);
	}
	return TRUE;
#else
	return _DllMain(hInstance, dwReason, lpReserved, pObjMap, pLibID);
#endif
}
#pragma managed(pop)

#endif	// !_ATL_NO_COMMODULE

/////////////////////////////////////////////////////////////////////////////
// Thread creation helpers

// CRTThreadTraits
// This class is for use with CThreadPool or CWorkerThread
// It should be used if the worker class will use CRT
// functions.
class CRTThreadTraits
{
public:
	static HANDLE CreateThread(
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
		_In_ DWORD dwStackSize,
		_In_ LPTHREAD_START_ROUTINE pfnThreadProc,
		_In_opt_ void *pvParam,
		_In_ DWORD dwCreationFlags,
		_Out_opt_ DWORD *pdwThreadId) throw()
	{
		ATLASSERT(sizeof(DWORD) == sizeof(unsigned int)); // sanity check for pdwThreadId

		// _beginthreadex calls CreateThread which will set the last error value before it returns.
		return (HANDLE) _beginthreadex(lpsa, dwStackSize, (unsigned int (__stdcall *)(void *)) pfnThreadProc, pvParam, dwCreationFlags, (unsigned int *) pdwThreadId);
	}
};

// Win32ThreadTraits
// This class is for use with CThreadPool or CWorkerThread
// It should be used if the worker class will not use CRT
// functions.
class Win32ThreadTraits
{
public:
	static HANDLE CreateThread(
		_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
		_In_ DWORD dwStackSize,
		_In_ LPTHREAD_START_ROUTINE pfnThreadProc,
		_In_opt_ void *pvParam,
		_In_ DWORD dwCreationFlags,
		_Out_opt_ DWORD *pdwThreadId) throw()
	{
		return ::CreateThread(lpsa, dwStackSize, pfnThreadProc, pvParam, dwCreationFlags, pdwThreadId);
	}
};

typedef CRTThreadTraits DefaultThreadTraits;

template <typename T>
HANDLE CreateThreadT(
	_In_opt_ LPSECURITY_ATTRIBUTES lpsa,
	_In_ DWORD dwStackSize,
	_In_ DWORD (WINAPI * pfn)(_In_ T *pparam),
	_In_opt_ T *pparam,
	_In_ DWORD dwCreationFlags,
	_Out_opt_ LPDWORD pdw)
{
	return DefaultThreadTraits::CreateThread(lpsa,
		dwStackSize,
		(LPTHREAD_START_ROUTINE)pfn,
		pparam,
		dwCreationFlags,
		pdw);
}

template <typename T>
HANDLE AtlCreateThread(_In_ DWORD (WINAPI* pfn)(_In_ T *pparam), _In_ T *pparam)
{
	return CreateThreadT(0, 0, pfn, pparam, 0, 0);
}

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
	_ATL_CREATORFUNC* pfnCreateInstance;
	const IID* piid;
	HANDLE hEvent;
	LPSTREAM pStream;
	HRESULT hRes;
};

class CComApartment
{
public:
	CComApartment()
	{
		m_nLockCnt = 0;
		m_hThread = NULL;
	}
	static UINT ATL_CREATE_OBJECT;
	static DWORD WINAPI _Apartment(_In_ void* pv)
	{
		ATLENSURE(pv != NULL);
		return ((CComApartment*)pv)->Apartment();
	}
	DWORD Apartment()
	{
		CoInitialize(NULL);
		MSG msg;
		while(GetMessage(&msg, 0, 0, 0) > 0)
		{
			if (msg.message == ATL_CREATE_OBJECT)
			{
				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
				IUnknown* pUnk = NULL;
				pdata->hRes = pdata->pfnCreateInstance(NULL, __uuidof(IUnknown), (void**)&pUnk);
				if (SUCCEEDED(pdata->hRes))
					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
				if (SUCCEEDED(pdata->hRes))
				{
					pUnk->Release();
					ATLTRACE(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
				}
#ifdef _DEBUG
				else
				{
					ATLTRACE(atlTraceCOM, 2, _T("Failed to create Object on thread = %d\n"), GetCurrentThreadId());
				}
#endif
				SetEvent(pdata->hEvent);
			}
			DispatchMessage(&msg);
		}
		CoUninitialize();

		return 0;
	}
	LONG Lock()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}
	LONG Unlock()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount()
	{
		return m_nLockCnt;
	}

	DWORD m_dwThreadID;
	HANDLE m_hThread;
	LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
	CComSimpleThreadAllocator()
	{
		m_nThread = 0;
	}
	int GetThread(_In_opt_ CComApartment* /*pApt*/, _In_ int nThreads)
	{
		if (++m_nThread == nThreads)
			m_nThread = 0;
		return m_nThread;
	}
	int m_nThread;
};

__interface IAtlAutoThreadModule
{
	virtual HRESULT CreateInstance(
		_In_ void* pfnCreateInstance,
		_In_ REFIID riid,
		_Deref_out_ void** ppvObj);
};

__declspec(selectany) IAtlAutoThreadModule* _pAtlAutoThreadModule;

template <class T, class ThreadAllocator = CComSimpleThreadAllocator, DWORD dwWait = INFINITE>
class ATL_NO_VTABLE CAtlAutoThreadModuleT : 
	public IAtlAutoThreadModule
{
// This class is not for use in a DLL.
// If this class were used in a DLL,  there will be a deadlock when the DLL is unloaded.
// because of dwWait's default value of INFINITE
public:
	CAtlAutoThreadModuleT(_In_ int nThreads = T::GetDefaultThreads())
	{
		ATLASSERT(_pAtlAutoThreadModule == NULL);
		_pAtlAutoThreadModule = this;
		m_pApartments = NULL;
		m_nThreads= 0;

		ATLTRY(m_pApartments = new CComApartment[nThreads]);
		ATLASSERT(m_pApartments != NULL);
		if(m_pApartments == NULL)
		{
			CAtlBaseModule::m_bInitFailed = true;
			ATLENSURE(0);
		}

		memset(m_pApartments, 0, sizeof(CComApartment) * nThreads);

		m_nThreads = nThreads;
		for (int i = 0; i < nThreads; i++)
		{
			typedef unsigned ( __stdcall *pfnThread )( void * );
			errno_t save_errno = Checked::get_errno();
			Checked::set_errno(0);
			m_pApartments[i].m_hThread = (HANDLE)_beginthreadex(NULL, 0, (pfnThread)CComApartment::_Apartment, &m_pApartments[i], 0, (UINT*)&m_pApartments[i].m_dwThreadID);
			if (m_pApartments[i].m_hThread == NULL)
			{
				HRESULT hr = E_FAIL;
				// _beginthreadex sets errno when it fails
				switch (Checked::get_errno())
				{
				case EAGAIN:
					hr = HRESULT_FROM_WIN32(ERROR_TOO_MANY_TCBS);
					break;
				case EINVAL:
					hr = E_INVALIDARG;
					break;
				}
				ATLASSERT(0);
				CAtlBaseModule::m_bInitFailed = true;
				break;
			}
			Checked::set_errno(save_errno);
		}
		if (!CAtlBaseModule::m_bInitFailed)
			CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
	}

	virtual ~CAtlAutoThreadModuleT()
	{
		if (m_pApartments == NULL)
			return;

		DWORD dwCurrentThreadId = GetCurrentThreadId();
		int nCurrentThread = -1;
		for (int i=0; i < m_nThreads; i++)
		{
			if (m_pApartments[i].m_hThread == NULL)
				continue;
			if (m_pApartments[i].m_dwThreadID == dwCurrentThreadId)
			{
				nCurrentThread = i;
				continue;
			}
			while (::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0) == 0)
			{
				/* Unfortunately, we can not use GetLastError() here to determine
				 * what went wrong here.  It could be the thread ID is invalid (in this case
				 * we want to break from this loop) or it could be the message loop for this
				 * thread has not been created yet (in this case, we should sleep and try again).
				 * However, GetLastError() will return ERROR_INVALID_THREAD_ID for both cases.
				 */
				::Sleep(100);
			}
			::WaitForSingleObject(m_pApartments[i].m_hThread, dwWait);
			CloseHandle(m_pApartments[i].m_hThread);
		}
		if (nCurrentThread != -1)
			CloseHandle(m_pApartments[nCurrentThread].m_hThread);

		delete [] m_pApartments;
		m_pApartments = NULL;
	}

	HRESULT CreateInstance(
		_In_opt_ void* pfnCreateInstance,
		_In_ REFIID riid,
		_Deref_out_ void** ppvObj)
	{
		ATLASSERT(ppvObj != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;

		_ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
		_AtlAptCreateObjData data;
		data.pfnCreateInstance = pFunc;
		data.piid = &riid;
		data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		ATLENSURE(data.hEvent != NULL);
		data.hRes = S_OK;
		int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
		int nIterations = 0;
		while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0 && ++nIterations < 100)
		{
			Sleep(100);
		}
		if (nIterations < 100)
		{
			AtlWaitWithMessageLoop(data.hEvent);
		}
		else
		{
			data.hRes = AtlHresultFromLastError();
		}
		if (data.hEvent)
			CloseHandle(data.hEvent);
		if (SUCCEEDED(data.hRes))
			data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
		return data.hRes;
	}
	DWORD dwThreadID;
	int m_nThreads;
	CComApartment* m_pApartments;
	ThreadAllocator m_Allocator;
	static int GetDefaultThreads()
	{
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		return si.dwNumberOfProcessors * 4;
	}
};

class CAtlAutoThreadModule : 
	public CAtlAutoThreadModuleT<CAtlAutoThreadModule>
{
public :
};

#ifndef _ATL_NO_COMMODULE

template <class ThreadAllocator = CComSimpleThreadAllocator, DWORD dwWait = INFINITE>
class CComAutoThreadModule :
	public CComModule,
	public CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>
{
public:
	CComAutoThreadModule(_In_ int nThreads = GetDefaultThreads()) :
		CAtlAutoThreadModuleT<CComAutoThreadModule<ThreadAllocator,dwWait>, ThreadAllocator, dwWait>(nThreads)
	{
	}
	HRESULT Init(
		_In_ _ATL_OBJMAP_ENTRY* p,
		_In_ HINSTANCE h,
		_In_opt_ const GUID* plibid = NULL,
		_In_ int nThreads = GetDefaultThreads())
	{
		nThreads;
		ATLASSERT(nThreads == GetDefaultThreads() && _T("Set number of threads through the constructor"));
		return CComModule::Init(p, h, plibid);
	}
};

#endif	// !_ATL_NO_COMMODULE

// Used in CThreadPool
class Win32WaitTraits
{
public:
	static DWORD WaitForSingleObject(
		_In_ HANDLE hHandle,
		_In_ DWORD dwTimeout)
	{
		return ::WaitForSingleObject(hHandle, dwTimeout);
	}
};

typedef Win32WaitTraits DefaultWaitTraits;

/////////////////////////////////////////////////////////////////////////////
// GIT Pointer

template <class T>
class CComGITPtr
{
public:
	CComGITPtr() throw()
	{
		m_dwCookie = 0;
	}
	CComGITPtr(_In_ T* p)
	{
		m_dwCookie = 0;
		HRESULT hr = Attach(p);

		if (FAILED(hr))
			AtlThrow(hr);
	}
	CComGITPtr(_In_ const CComGITPtr& git)
	{
		m_dwCookie = 0;

		if (git.m_dwCookie != 0)
		{
			CComPtr<T> spT;

			HRESULT hr = git.CopyTo(&spT);
			if (SUCCEEDED(hr))
				hr = Attach(spT);

			if (FAILED(hr))
				AtlThrow(hr);
		}
	}
	explicit CComGITPtr(_In_ DWORD dwCookie) throw()
	{
		ATLASSUME(dwCookie != NULL);
		m_dwCookie = dwCookie;

#ifdef _DEBUG
		CComPtr<T> spT;
		HRESULT hr = CopyTo(&spT);
		ATLASSERT(SUCCEEDED(hr));
#endif
	}

	CComGITPtr(CComGITPtr&& rv)
	{
		m_dwCookie = rv.m_dwCookie;
		rv.m_dwCookie = 0;
	}

	CComGITPtr& operator=(CComGITPtr&& rv)
	{
		if (this != &rv)
		{
			ATLVERIFY(SUCCEEDED(Revoke()));

			m_dwCookie = rv.m_dwCookie;
			rv.m_dwCookie = 0;
		}

		return *this;
	}

	~CComGITPtr() throw()
	{
		Revoke();
	}
	CComGITPtr& operator=(_In_ const CComGITPtr& git)
	{
		if (this != &git)
		{
			if (git.m_dwCookie == 0)
			{
				ATLVERIFY(SUCCEEDED(Revoke()));
			}
			else
			{
				CComPtr<T> spT;

				HRESULT hr = git.CopyTo(&spT);
				if (SUCCEEDED(hr))
				{
					hr = Attach(spT);
				}

				if (FAILED(hr))
				{
					AtlThrow(hr);
				}
			}
		}
		return *this;
	}
	CComGITPtr& operator=(_In_ T* p)
	{
		HRESULT hr = Attach(p);
		if (FAILED(hr))
			AtlThrow(hr);
		return *this;
	}
	CComGITPtr& operator=(_In_ DWORD dwCookie)
	{
		if(*this!=dwCookie)
		{
			HRESULT hr = Attach(dwCookie);
			if (FAILED(hr))
			{
				AtlThrow(hr);
			}

			m_dwCookie = dwCookie;

#ifdef _DEBUG
			CComPtr<T> spT;
			hr = CopyTo(&spT);
			ATLASSERT(SUCCEEDED(hr));
#endif
		}
		return *this;
	}

	// basic comparison operators
	bool operator!=(_In_ const CComGITPtr& git) const
	{
		return !operator==(git);
	}

	bool operator!=(_In_ DWORD dwCookie) const
	{
		return !operator==(dwCookie);
	}

	bool operator==(_In_ const CComGITPtr& git) const
	{
		return m_dwCookie==git.GetCookie();
	}

	bool operator==(_In_ DWORD dwCookie) const
	{
		return m_dwCookie==dwCookie;
	}

	// Get the cookie from the class
	operator DWORD() const
	{
		return m_dwCookie;
	}
	// Get the cookie from the class
	DWORD GetCookie() const
	{
		return m_dwCookie;
	}
	// Register the passed interface pointer in the GIT
	HRESULT Attach(_In_ T* p) throw()
	{
		if (p)
		{
			CComPtr<IGlobalInterfaceTable> spGIT;
			HRESULT hr = E_FAIL;
			hr = AtlGetGITPtr(&spGIT);
			ATLASSERT(spGIT != NULL);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				return hr;

			if (m_dwCookie != 0)
				hr = spGIT->RevokeInterfaceFromGlobal(m_dwCookie);
			if (FAILED(hr))
				return hr;

			return spGIT->RegisterInterfaceInGlobal(p, __uuidof(T), &m_dwCookie);
		}
		else
		{
			return Revoke();
		}
	}

	HRESULT Attach(_In_ DWORD dwCookie) throw()
	{
		ATLASSERT(dwCookie != NULL);
		HRESULT hr = Revoke();
		if (FAILED(hr))
			return hr;
		m_dwCookie = dwCookie;
		return S_OK;
	}

	// Detach
	DWORD Detach() throw()
	{
		DWORD dwCookie = m_dwCookie;
		m_dwCookie = NULL;
		return dwCookie;
	}

	// Remove the interface from the GIT
	HRESULT Revoke() throw()
	{
		HRESULT hr = S_OK;
		if (m_dwCookie != 0)
		{
			CComPtr<IGlobalInterfaceTable> spGIT;
			hr = AtlGetGITPtr(&spGIT);

			ATLASSERT(spGIT != NULL);
			ATLASSERT(SUCCEEDED(hr));
			if (FAILED(hr))
				return hr;

			hr = spGIT->RevokeInterfaceFromGlobal(m_dwCookie);
			if (SUCCEEDED(hr))
				m_dwCookie = 0;
		}
		return hr;
	}
	// Get's the interface from the GIT and copies it to the passed pointer. The pointer
	// must be released by the caller when finished.
	HRESULT CopyTo(_Deref_out_ T** pp) const throw()
	{
		CComPtr<IGlobalInterfaceTable> spGIT;
		HRESULT hr = E_FAIL;
		hr = AtlGetGITPtr(&spGIT);

		ATLASSERT(spGIT != NULL);
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;

		ATLASSUME(m_dwCookie!=NULL);
		return spGIT->GetInterfaceFromGlobal(m_dwCookie, __uuidof(T), (void**)pp);
	}
	DWORD m_dwCookie;
};

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	/// <summary>
	/// CRegKey constructor</summary>
	/// <param name="pTM">Pointer to CAtlTransactionManager object</param>
	CRegKey(_In_opt_ CAtlTransactionManager* pTM = NULL) throw();
	CRegKey(_Inout_ CRegKey& key) throw();
	explicit CRegKey(_In_ HKEY hKey) throw();
	~CRegKey() throw();

	CRegKey& operator=(_Inout_ CRegKey& key) throw();

// Attributes
public:
	operator HKEY() const throw();
	HKEY m_hKey;
	REGSAM m_samWOW64;

	/// <summary>
	/// Pointer to CAtlTransactionManager object</summary>
	CAtlTransactionManager* m_pTM;

// Operations
public:
	ATL_DEPRECATED("CRegKey::SetValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::SetDWORDValue")
	LONG SetValue(
		_In_ DWORD dwValue,
		_In_opt_z_ LPCTSTR lpszValueName);

	ATL_DEPRECATED("CRegKey::SetValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::SetStringValue and CRegKey::SetMultiStringValue")
	LONG SetValue(
		_In_z_ LPCTSTR lpszValue,
		_In_opt_z_ LPCTSTR lpszValueName = NULL,
		_In_ bool bMulti = false,
		_In_ int nValueLen = -1);
	LONG SetValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_ DWORD dwType,
		_In_opt_ const void* pValue,
		_In_ ULONG nBytes) throw();
	LONG SetGUIDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_ REFGUID guidValue) throw();
	LONG SetBinaryValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_opt_ const void* pValue,
		_In_ ULONG nBytes) throw();
	LONG SetDWORDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_ DWORD dwValue) throw();
	LONG SetQWORDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_ ULONGLONG qwValue) throw();
	LONG SetStringValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_opt_z_ LPCTSTR pszValue,
		_In_ DWORD dwType = REG_SZ) throw();
	LONG SetMultiStringValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_In_z_ LPCTSTR pszValue) throw();

	ATL_DEPRECATED("CRegKey::QueryValue(DWORD, TCHAR *valueName) has been superseded by CRegKey::QueryDWORDValue")
	LONG QueryValue(
		_Out_ DWORD& dwValue,
		_In_opt_z_ LPCTSTR lpszValueName);

	ATL_DEPRECATED("CRegKey::QueryValue(TCHAR *value, TCHAR *valueName) has been superseded by CRegKey::QueryStringValue and CRegKey::QueryMultiStringValue")
	LONG QueryValue(
		_Out_opt_z_cap_post_count_(*pdwCount, *pdwCount) LPTSTR szValue,
		_In_opt_z_ LPCTSTR lpszValueName,
		_Inout_ DWORD* pdwCount);
	LONG QueryValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_opt_ DWORD* pdwType,
		_Out_opt_ void* pData,
		_Inout_ ULONG* pnBytes) throw();
	LONG QueryGUIDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_ GUID& guidValue) throw();
	LONG QueryBinaryValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_opt_ void* pValue,
		_Inout_opt_ ULONG* pnBytes) throw();
	LONG QueryDWORDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_ DWORD& dwValue) throw();
	LONG QueryQWORDValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_ ULONGLONG& qwValue) throw();
	LONG QueryStringValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
		_Inout_ ULONG* pnChars) throw();
	LONG QueryMultiStringValue(
		_In_opt_z_ LPCTSTR pszValueName,
		_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
		_Inout_ ULONG* pnChars) throw();

	// Get the key's security attributes.
	LONG GetKeySecurity(
		_In_ SECURITY_INFORMATION si,
		_Out_opt_ PSECURITY_DESCRIPTOR psd,
		_Inout_ LPDWORD pnBytes) throw();
	// Set the key's security attributes.
	LONG SetKeySecurity(
		_In_ SECURITY_INFORMATION si,
		_In_ PSECURITY_DESCRIPTOR psd) throw();

	LONG SetKeyValue(
		_In_z_ LPCTSTR lpszKeyName,
		_In_opt_z_ LPCTSTR lpszValue,
		_In_opt_z_ LPCTSTR lpszValueName = NULL) throw();
	static LONG WINAPI SetValue(
		_In_ HKEY hKeyParent,
		_In_z_ LPCTSTR lpszKeyName,
		_In_opt_z_ LPCTSTR lpszValue,
		_In_opt_z_ LPCTSTR lpszValueName = NULL);

	// Create a new registry key (or open an existing one).
	LONG Create(
		_In_ HKEY hKeyParent,
		_In_z_ LPCTSTR lpszKeyName,
		_In_opt_z_ LPTSTR lpszClass = REG_NONE,
		_In_ DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE,
		_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		_Out_opt_ LPDWORD lpdwDisposition = NULL) throw();
	// Open an existing registry key.
	LONG Open(
		_In_ HKEY hKeyParent,
		_In_opt_z_ LPCTSTR lpszKeyName,
		_In_ REGSAM samDesired = KEY_READ | KEY_WRITE) throw();
	// Close the registry key.
	LONG Close() throw();
	// Flush the key's data to disk.
	LONG Flush() throw();

	// Detach the CRegKey object from its HKEY.  Releases ownership.
	HKEY Detach() throw();
	// Attach the CRegKey object to an existing HKEY.  Takes ownership.
	void Attach(_In_ HKEY hKey) throw();

	// Enumerate the subkeys of the key.
	LONG EnumKey(
		_In_ DWORD iIndex,
		_Out_z_cap_post_count_(*pnNameLength, *pnNameLength) LPTSTR pszName,
		_Inout_ LPDWORD pnNameLength,
		_Out_opt_ FILETIME* pftLastWriteTime = NULL) throw();
	LONG NotifyChangeKeyValue(
		_In_ BOOL bWatchSubtree,
		_In_ DWORD dwNotifyFilter,
		_In_ HANDLE hEvent,
		_In_ BOOL bAsync = TRUE) throw();

	LONG DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw();
	LONG RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw();
	LONG DeleteValue(_In_z_ LPCTSTR lpszValue) throw();
};

inline CRegKey::CRegKey(_In_opt_ CAtlTransactionManager* pTM) throw() :
	m_hKey( NULL ), m_samWOW64(0), m_pTM(pTM)
{
}

inline CRegKey::CRegKey(_Inout_ CRegKey& key) throw() :
	m_hKey( NULL ), m_samWOW64(key.m_samWOW64), m_pTM(key.m_pTM)
{
	Attach( key.Detach() );
}

inline CRegKey::CRegKey(_In_ HKEY hKey) throw() :
	m_hKey(hKey), m_samWOW64(0), m_pTM(NULL)
{
}

inline CRegKey::~CRegKey() throw()
{Close();}

inline CRegKey& CRegKey::operator=(_Inout_ CRegKey& key) throw()
{
	if(m_hKey!=key.m_hKey)
	{
		Close();
		Attach( key.Detach() );
		m_samWOW64 = key.m_samWOW64;
		m_pTM = key.m_pTM;
	}
	return( *this );
}

inline CRegKey::operator HKEY() const throw()
{
	return m_hKey;
}

inline HKEY CRegKey::Detach() throw()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	m_samWOW64 = 0;
	m_pTM = NULL;
	return hKey;
}

inline void CRegKey::Attach(_In_ HKEY hKey) throw()
{
	ATLASSUME(m_hKey == NULL);
	m_hKey = hKey;
	m_samWOW64 = 0;
	m_pTM = NULL;
}

inline LONG CRegKey::DeleteSubKey(_In_z_ LPCTSTR lpszSubKey) throw()
{
	ATLASSUME(m_hKey != NULL);

	if (m_pTM != NULL)
	{
		return m_pTM->RegDeleteKey(m_hKey, lpszSubKey);
	}

#if WINVER >= 0x0501
	typedef LSTATUS (WINAPI * PFNRegDeleteKeyEx)(_In_ HKEY, _In_z_ LPCTSTR, _In_ REGSAM, _In_ DWORD);
	static bool bInitialized = false;
	static PFNRegDeleteKeyEx pfnRegDeleteKeyEx = NULL;

	if (!bInitialized)
	{
		HMODULE hAdvapi32 = GetModuleHandle(_T("Advapi32.dll"));
		if (hAdvapi32 != NULL)
		{
#ifdef _UNICODE
			pfnRegDeleteKeyEx = (PFNRegDeleteKeyEx)GetProcAddress(hAdvapi32, "RegDeleteKeyExW");
#else
			pfnRegDeleteKeyEx = (PFNRegDeleteKeyEx)GetProcAddress(hAdvapi32, "RegDeleteKeyExA");
#endif	// _UNICODE
		}
		bInitialized = true;
	}

	if (pfnRegDeleteKeyEx != NULL)
	{
		return pfnRegDeleteKeyEx(m_hKey, lpszSubKey, m_samWOW64, 0);
	}

#endif	// WINVER

	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(_In_z_ LPCTSTR lpszValue) throw()
{
	ATLASSUME(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close() throw()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	m_samWOW64 = 0;
	return lRes;
}

inline LONG CRegKey::Flush() throw()
{
	ATLASSUME(m_hKey != NULL);

	return ::RegFlushKey(m_hKey);
}

inline LONG CRegKey::EnumKey(
	_In_ DWORD iIndex,
	_Out_z_cap_post_count_(*pnNameLength, *pnNameLength) LPTSTR pszName,
	_Inout_ LPDWORD pnNameLength,
	_Out_opt_ FILETIME* pftLastWriteTime) throw()
{
	FILETIME ftLastWriteTime;

	ATLASSUME(m_hKey != NULL);
	if (pftLastWriteTime == NULL)
	{
		pftLastWriteTime = &ftLastWriteTime;
	}

	return ::RegEnumKeyEx(m_hKey, iIndex, pszName, pnNameLength, NULL, NULL, NULL, pftLastWriteTime);
}

inline LONG CRegKey::NotifyChangeKeyValue(
	_In_ BOOL bWatchSubtree,
	_In_ DWORD dwNotifyFilter,
	_In_ HANDLE hEvent,
	_In_ BOOL bAsync) throw()
{
	ATLASSUME(m_hKey != NULL);
	ATLASSERT((hEvent != NULL) || !bAsync);

	return ::RegNotifyChangeKeyValue(m_hKey, bWatchSubtree, dwNotifyFilter, hEvent, bAsync);
}

inline LONG CRegKey::Create(
	_In_ HKEY hKeyParent,
	_In_z_ LPCTSTR lpszKeyName,
	_In_opt_z_ LPTSTR lpszClass,
	_In_ DWORD dwOptions,
	_In_ REGSAM samDesired,
	_In_opt_ LPSECURITY_ATTRIBUTES lpSecAttr,
	_Out_opt_ LPDWORD lpdwDisposition) throw()
{
	ATLASSERT(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = m_pTM != NULL ?
		m_pTM->RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw) :
		RegCreateKeyEx(hKeyParent, lpszKeyName, 0, lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
#if WINVER >= 0x0501
		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);
#endif
	}
	return lRes;
}

inline LONG CRegKey::Open(
	_In_ HKEY hKeyParent,
	_In_opt_z_ LPCTSTR lpszKeyName,
	_In_ REGSAM samDesired) throw()
{
	ATLASSUME(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = m_pTM != NULL ?
		m_pTM->RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey) :
		RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		ATLASSERT(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
#if WINVER >= 0x0501
		m_samWOW64 = samDesired & (KEY_WOW64_32KEY | KEY_WOW64_64KEY);
#endif
	}
	return lRes;
}

#pragma warning(push)
#pragma warning(disable: 4996)
inline LONG CRegKey::QueryValue(
	_Out_ DWORD& dwValue,
	_In_opt_z_ LPCTSTR lpszValueName)
{
	DWORD dwType = 0;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	if (dwType != REG_DWORD)
		return ERROR_INVALID_DATA;
	return lRes;
}

ATLPREFAST_SUPPRESS(6053 6385)
inline LONG CRegKey::QueryValue(
	_Out_opt_z_cap_post_count_(*pdwCount, *pdwCount) LPTSTR pszValue,
	_In_opt_z_ LPCTSTR lpszValueName,
	_Inout_ DWORD* pdwCount)
{
	ATLENSURE(pdwCount != NULL);
	DWORD dwType = 0;
	LONG lRes = RegQueryValueEx(m_hKey, lpszValueName, NULL, &dwType, (LPBYTE)pszValue, pdwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	if (pszValue != NULL)
	{
		if(*pdwCount>0)
		{
			switch(dwType)
			{
				case REG_SZ:
				case REG_EXPAND_SZ:
					if ((*pdwCount) % sizeof(TCHAR) != 0 || pszValue[(*pdwCount) / sizeof(TCHAR) - 1] != 0)
					{
						pszValue[0]=_T('\0');
		 				return ERROR_INVALID_DATA;
					}
					break;
				case REG_MULTI_SZ:
					if ((*pdwCount) % sizeof(TCHAR) != 0 || (*pdwCount) / sizeof(TCHAR) < 1 || pszValue[(*pdwCount) / sizeof(TCHAR) -1] != 0 || (((*pdwCount) / sizeof(TCHAR))>1 && pszValue[(*pdwCount) / sizeof(TCHAR) - 2] != 0) )
					{
						pszValue[0]=_T('\0');
						return ERROR_INVALID_DATA;
					}
					break;
				default:
					// Ensure termination
					pszValue[0]=_T('\0');
					return ERROR_INVALID_DATA;
			}
		}
		else
		{
			// this is a blank one with no data yet
			// Ensure termination
			pszValue[0]=_T('\0');
		}
	}
	return lRes;
}
ATLPREFAST_UNSUPPRESS()

inline LONG CRegKey::QueryValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_opt_ DWORD* pdwType,
	_Out_opt_ void* pData,
	_Inout_ ULONG* pnBytes) throw()
{
	ATLASSUME(m_hKey != NULL);

	return( ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType, static_cast< LPBYTE >( pData ), pnBytes) );
}

inline LONG CRegKey::QueryDWORDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_ DWORD& dwValue) throw()
{
	LONG lRes;
	ULONG nBytes;
	DWORD dwType;

	ATLASSUME(m_hKey != NULL);

	nBytes = sizeof(DWORD);
	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue),
		&nBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_DWORD)
		return ERROR_INVALID_DATA;

	return ERROR_SUCCESS;
}
inline LONG CRegKey::QueryQWORDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_ ULONGLONG& qwValue) throw()
{
	LONG lRes;
	ULONG nBytes;
	DWORD dwType;

	ATLASSUME(m_hKey != NULL);

	nBytes = sizeof(ULONGLONG);
	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&qwValue),
		&nBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_QWORD)
		return ERROR_INVALID_DATA;

	return ERROR_SUCCESS;
}

inline LONG CRegKey::QueryBinaryValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_opt_ void* pValue,
	_Inout_opt_ ULONG* pnBytes) throw()
{
	LONG lRes;
	DWORD dwType;

	ATLASSERT(pnBytes != NULL);
	ATLASSUME(m_hKey != NULL);

	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pValue),
		pnBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_BINARY)
		return ERROR_INVALID_DATA;

	return ERROR_SUCCESS;
}

ATLPREFAST_SUPPRESS(6053)
/* prefast noise VSW 496818 */
inline LONG CRegKey::QueryStringValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
	_Inout_ ULONG* pnChars) throw()
{
	LONG lRes;
	DWORD dwType;
	ULONG nBytes;

	ATLASSUME(m_hKey != NULL);
	ATLASSERT(pnChars != NULL);

	nBytes = (*pnChars)*sizeof(TCHAR);
	*pnChars = 0;
	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue),
		&nBytes);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	if(dwType != REG_SZ && dwType != REG_EXPAND_SZ)
	{
		return ERROR_INVALID_DATA;
	}

	if (pszValue != NULL)
	{
		if(nBytes!=0)
		{
ATLPREFAST_SUPPRESS(6385) // suppress noisy code analysis warning due to annotation on RegQueryValueEx
			if ((nBytes % sizeof(TCHAR) != 0) || (pszValue[nBytes / sizeof(TCHAR) -1] != 0))
			{
				return ERROR_INVALID_DATA;
			}
ATLPREFAST_UNSUPPRESS()
		}
		else
		{
			pszValue[0]=_T('\0');
		}
	}

	*pnChars = nBytes/sizeof(TCHAR);

	return ERROR_SUCCESS;
}
ATLPREFAST_UNSUPPRESS()

ATLPREFAST_SUPPRESS(6053)
/* prefast noise VSW 496818 */
inline LONG CRegKey::QueryMultiStringValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_opt_z_cap_post_count_(*pnChars, *pnChars) LPTSTR pszValue,
	_Inout_ ULONG* pnChars) throw()
{
	LONG lRes;
	DWORD dwType;
	ULONG nBytes;

	ATLASSUME(m_hKey != NULL);
	ATLASSERT(pnChars != NULL);

	if (pszValue != NULL && *pnChars < 2)
		return ERROR_INSUFFICIENT_BUFFER;

	nBytes = (*pnChars)*sizeof(TCHAR);
	*pnChars = 0;

	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue),
		&nBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_MULTI_SZ)
		return ERROR_INVALID_DATA;
	if (pszValue != NULL && (nBytes % sizeof(TCHAR) != 0 || nBytes / sizeof(TCHAR) < 1 || pszValue[nBytes / sizeof(TCHAR) -1] != 0 || ((nBytes/sizeof(TCHAR))>1 && pszValue[nBytes / sizeof(TCHAR) - 2] != 0)))
		return ERROR_INVALID_DATA;

	*pnChars = nBytes/sizeof(TCHAR);

	return ERROR_SUCCESS;
}
ATLPREFAST_UNSUPPRESS()

inline LONG CRegKey::QueryGUIDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_Out_ GUID& guidValue) throw()
{
	TCHAR szGUID[64];
	LONG lRes;
	ULONG nCount;
	HRESULT hr;

	ATLASSUME(m_hKey != NULL);

	guidValue = GUID_NULL;

	nCount = 64;
	lRes = QueryStringValue(pszValueName, szGUID, &nCount);

	if (lRes != ERROR_SUCCESS)
		return lRes;

	if(szGUID[0] != _T('{'))
		return ERROR_INVALID_DATA;

	USES_CONVERSION_EX;
	LPOLESTR lpstr = T2OLE_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(lpstr == NULL)
		return E_OUTOFMEMORY;
#endif

	hr = ::CLSIDFromString(lpstr, &guidValue);
	if (FAILED(hr))
		return ERROR_INVALID_DATA;

	return ERROR_SUCCESS;
}

inline LONG WINAPI CRegKey::SetValue(
	_In_ HKEY hKeyParent,
	_In_z_ LPCTSTR lpszKeyName,
	_In_opt_z_ LPCTSTR lpszValue,
	_In_opt_z_ LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetStringValue(lpszValueName, lpszValue);
	return lRes;
}

inline LONG CRegKey::SetKeyValue(
	_In_z_ LPCTSTR lpszKeyName,
	_In_opt_z_ LPCTSTR lpszValue,
	_In_opt_z_ LPCTSTR lpszValueName) throw()
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE | m_samWOW64);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetStringValue(lpszValueName, lpszValue);
	return lRes;
}

#pragma warning(push)
#pragma warning(disable: 4996)
inline LONG CRegKey::SetValue(
	_In_ DWORD dwValue,
	_In_opt_z_ LPCTSTR pszValueName)
{
	ATLASSUME(m_hKey != NULL);
	return SetDWORDValue(pszValueName, dwValue);
}

inline LONG CRegKey::SetValue(
	_In_z_ LPCTSTR lpszValue,
	_In_opt_z_ LPCTSTR lpszValueName,
	_In_ bool bMulti,
	_In_ int nValueLen)
{
	ATLENSURE(lpszValue != NULL);
	ATLASSUME(m_hKey != NULL);

	if (bMulti && nValueLen == -1)
		return ERROR_INVALID_PARAMETER;

	if (nValueLen == -1)
		nValueLen = lstrlen(lpszValue) + 1;

	DWORD dwType = bMulti ? REG_MULTI_SZ : REG_SZ;

	return ::RegSetValueEx(m_hKey, lpszValueName, 0, dwType,
		reinterpret_cast<const BYTE*>(lpszValue), nValueLen*sizeof(TCHAR));
}
#pragma warning(pop)

inline LONG CRegKey::SetValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_ DWORD dwType,
	_In_opt_ const void* pValue,
	_In_ ULONG nBytes) throw()
{
	ATLASSUME(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, static_cast<const BYTE*>(pValue), nBytes);
}

inline LONG CRegKey::SetBinaryValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_opt_ const void* pData,
	_In_ ULONG nBytes) throw()
{
	ATLASSUME(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_BINARY, reinterpret_cast<const BYTE*>(pData), nBytes);
}

inline LONG CRegKey::SetDWORDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_ DWORD dwValue) throw()
{
	ATLASSUME(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));
}

inline LONG CRegKey::SetQWORDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_ ULONGLONG qwValue) throw()
{
	ATLASSUME(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_QWORD, reinterpret_cast<const BYTE*>(&qwValue), sizeof(ULONGLONG));
}

inline LONG CRegKey::SetStringValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_opt_z_ LPCTSTR pszValue,
	_In_ DWORD dwType) throw()
{
	ATLASSUME(m_hKey != NULL);
	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);
	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));

	return ::RegSetValueEx(m_hKey, pszValueName, 0, dwType, reinterpret_cast<const BYTE*>(pszValue), (lstrlen(pszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::SetMultiStringValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_z_ LPCTSTR pszValue) throw()
{
	LPCTSTR pszTemp;
	ULONG nBytes;
	ULONG nLength;

	ATLASSUME(m_hKey != NULL);
	ATLENSURE_RETURN_VAL(pszValue != NULL, ERROR_INVALID_DATA);

	// Find the total length (in bytes) of all of the strings, including the
	// terminating '\0' of each string, and the second '\0' that terminates
	// the list.
	nBytes = 0;
	pszTemp = pszValue;
	do
	{
		nLength = lstrlen(pszTemp)+1;
		pszTemp += nLength;
		nBytes += nLength*sizeof(TCHAR);
	} while (nLength != 1);

	return ::RegSetValueEx(m_hKey, pszValueName, 0, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),
		nBytes);
}

inline LONG CRegKey::SetGUIDValue(
	_In_opt_z_ LPCTSTR pszValueName,
	_In_ REFGUID guidValue) throw()
{
	OLECHAR szGUID[64];

	ATLASSUME(m_hKey != NULL);

	::StringFromGUID2(guidValue, szGUID, 64);

	USES_CONVERSION_EX;
	LPCTSTR lpstr = OLE2CT_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(lpstr == NULL)
		return E_OUTOFMEMORY;
#endif
	return SetStringValue(pszValueName, lpstr);
}

inline LONG CRegKey::GetKeySecurity(
	_In_ SECURITY_INFORMATION si,
	_Out_opt_ PSECURITY_DESCRIPTOR psd,
	_Inout_ LPDWORD pnBytes) throw()
{
	ATLASSUME(m_hKey != NULL);
	ATLASSUME(pnBytes != NULL);

	return ::RegGetKeySecurity(m_hKey, si, psd, pnBytes);
}

inline LONG CRegKey::SetKeySecurity(
	_In_ SECURITY_INFORMATION si,
	_In_ PSECURITY_DESCRIPTOR psd) throw()
{
	ATLASSUME(m_hKey != NULL);
	ATLASSUME(psd != NULL);

	return ::RegSetKeySecurity(m_hKey, si, psd);
}

inline LONG CRegKey::RecurseDeleteKey(_In_z_ LPCTSTR lpszKey) throw()
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE | m_samWOW64);
	if (lRes != ERROR_SUCCESS)
	{
		if (lRes != ERROR_FILE_NOT_FOUND && lRes != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceCOM, 0, _T("CRegKey::RecurseDeleteKey : Failed to Open Key %s(Error = %d)\n"), lpszKey, lRes);
		}
		return lRes;
	}
	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifndef _ATL_NO_COMMODULE

inline HRESULT CComModule::RegisterProgIDHelper(
	_In_z_ LPCTSTR lpszCLSID,
	_In_z_ LPCTSTR lpszProgID,
	_In_opt_z_ LPCTSTR lpszCurVerProgID,
	_In_z_ LPCTSTR lpszUserDesc,
	_In_ BOOL bIsVerIndProgID)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_SET_VALUE);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = keyProgID.SetStringValue(NULL, lpszUserDesc);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = bIsVerIndProgID ? keyProgID.SetKeyValue(_T("CurVer"), lpszCurVerProgID) : ERROR_SUCCESS;
				if (lRes == ERROR_SUCCESS)
					return S_OK;
			}
		}
	}
	return AtlHresultFromWin32(lRes);
}

inline HRESULT CComModule::RegisterProgID(
	_In_z_ LPCTSTR lpszCLSID,
	_In_z_ LPCTSTR lpszProgID,
	_In_z_ LPCTSTR lpszUserDesc)
{
	return RegisterProgIDHelper(lpszCLSID, lpszProgID, NULL, lpszUserDesc, FALSE);
}

inline HRESULT CComModule::RegisterVersionIndependentProgID(
	_In_z_ LPCTSTR lpszCLSID,
	_In_z_ LPCTSTR lpszVerIndProgID,
	_In_z_ LPCTSTR lpszCurVerProgID,
	_In_z_ LPCTSTR lpszUserDesc)
{
	return RegisterProgIDHelper(lpszCLSID, lpszVerIndProgID, lpszCurVerProgID, lpszUserDesc, TRUE);
}

inline HRESULT CComModule::RegisterAppId(_In_z_ LPCTSTR pAppId)
{
	CRegKey keyAppID;
	HRESULT hr = S_OK;
	LONG lRet;

	if ( (lRet = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE)) == ERROR_SUCCESS)
	{
		TCHAR szModule1[MAX_PATH];
		TCHAR szModule2[MAX_PATH];
		TCHAR* pszFileName;

		DWORD dwFLen = ::GetModuleFileName(GetModuleInstance(), szModule1, MAX_PATH);
		if ( dwFLen != 0 && dwFLen != MAX_PATH )
		{
			if (::GetFullPathName(szModule1, MAX_PATH, szModule2, &pszFileName) != 0)
			{
				CRegKey keyAppIDEXE;
				if ( (lRet = keyAppIDEXE.Create(keyAppID, pszFileName, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
				{
					lRet = keyAppIDEXE.SetStringValue(_T("AppID"), pAppId);
					if (lRet != ERROR_SUCCESS)
					{
						ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to set app id string value\n"));
						hr = AtlHresultFromWin32(lRet);
						return hr;
					}
				}
				else
				{
					ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to create file name key\n"));
					hr = AtlHresultFromWin32(lRet);
					return hr;
				}
				if ( (lRet = keyAppIDEXE.Create(keyAppID, pAppId, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE)) == ERROR_SUCCESS)
				{
					lRet = keyAppIDEXE.SetStringValue(NULL, pszFileName);
					if (lRet != ERROR_SUCCESS)
					{
						ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to set file name string value\n"));
						hr = AtlHresultFromWin32(lRet);
						return hr;
					}
				}
				else
				{
					ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to create app id key\n"));
					hr = AtlHresultFromWin32(lRet);
					return hr;
				}
			}
			else
			{
				ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to get full path name for file %s\n"), szModule1);
				hr = AtlHresultFromLastError();
			}
		}
		else
		{
			ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to get module name\n"));
			if( dwFLen == 0 )
				hr = AtlHresultFromLastError();
			else if( dwFLen == MAX_PATH )
				hr =  HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}
	else
	{
		ATLTRACE(atlTraceCOM, 0, _T("CComModule::RegisterAppId : Failed to open registry key\n"));
		hr = AtlHresultFromWin32(lRet);
	}
	return hr;
}

inline HRESULT CComModule::UnregisterAppId(_In_z_ LPCTSTR pAppId)
{
	CRegKey keyAppID;
	HRESULT hr = S_OK;
	LONG lRet = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ | KEY_WRITE);

	if (lRet == ERROR_SUCCESS)
	{
		TCHAR szModule1[MAX_PATH];
		TCHAR szModule2[MAX_PATH];
		TCHAR* pszFileName;

		DWORD dwFLen = ::GetModuleFileName(GetModuleInstance(), szModule1, MAX_PATH);
		if ( dwFLen != 0 && dwFLen != MAX_PATH )
		{
			if (::GetFullPathName(szModule1, MAX_PATH, szModule2, &pszFileName) != 0)
			{
				if ((lRet = keyAppID.RecurseDeleteKey(pAppId)) != ERROR_SUCCESS)
				{
					if (lRet != ERROR_FILE_NOT_FOUND)
						hr = AtlHresultFromWin32(lRet);
				}
				if ((lRet = keyAppID.RecurseDeleteKey(pszFileName)) != ERROR_SUCCESS)
				{
					if (lRet != ERROR_FILE_NOT_FOUND)
						hr = AtlHresultFromWin32(lRet);
				}
			}
			else
			{
				ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to get full path name for file %s\n"), szModule1);
				hr = AtlHresultFromLastError();
			}
		}
		else
		{
			ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to get module name\n"));
			if( dwFLen == 0 )
				hr = AtlHresultFromLastError();
			else if( dwFLen == MAX_PATH )
				hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
		}
	}
	else
	{
		if (lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceCOM, 0, _T("CComModule::UnregisterAppId : Failed to open registry key\n"));
			hr = AtlHresultFromWin32(lRet);
		}
	}
	return hr;
}
#endif	// !_ATL_NO_COMMODULE

#ifdef _ATL_STATIC_REGISTRY
}	// namespace ATL


#include <statreg.h>


namespace ATL
{

// Statically linking to Registry Ponent
inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResourceS(
	_In_z_ LPCTSTR lpszRes,
	_In_ BOOL bRegister,
	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
{
	CRegObject ro;
	HRESULT hr = ro.FinalConstruct();
	if (FAILED(hr))
	{
		return hr;
	}

	if (pMapEntries != NULL)
	{
		while (pMapEntries->szKey != NULL)
		{
			ATLASSUME(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	hr = AddCommonRGSReplacements(&ro);
	if (FAILED(hr))
		return hr;

	USES_CONVERSION_EX;
	TCHAR szModule[MAX_PATH];
	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);
	if( dwFLen == 0 )
		return AtlHresultFromLastError();
	else if( dwFLen == MAX_PATH )
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	LPOLESTR pszModule = NULL;
	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(pszModule == NULL)
		return E_OUTOFMEMORY;
#endif

	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);

	HRESULT hRes;
	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
	{
		// If Registering as an EXE, then we quote the resultant path.
		// We don't do it for a DLL, because LoadLibrary fails if the path is
		// quoted
		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
		pszModuleQuote[0] = OLESTR('\"');
		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))
		{
			return E_FAIL;
		}
		size_t nLen = ocslen(pszModuleQuote);
		pszModuleQuote[nLen] = OLESTR('\"');
		pszModuleQuote[nLen + 1] = 0;

		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	}
	else
	{
		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);
	}

	if(FAILED(hRes))
		return hRes;

	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);
	if(FAILED(hRes))
		return hRes;

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE_EX(lpszRes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(pszRes == NULL)
		return E_OUTOFMEMORY;
#endif
	hr = (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
		ro.ResourceUnregisterSz(pszModule, pszRes, szType);
	return hr;
}
inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResourceS(
	_In_ UINT nResID,
	_In_ BOOL bRegister,
	_In_opt_ struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
{
	CRegObject ro;
	HRESULT hr = ro.FinalConstruct();
	if (FAILED(hr))
	{
		return hr;
	}

	if (pMapEntries != NULL)
	{
		while (pMapEntries->szKey != NULL)
		{
			ATLASSUME(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	hr = AddCommonRGSReplacements(&ro);
	if (FAILED(hr))
		return hr;

	USES_CONVERSION_EX;
	TCHAR szModule[MAX_PATH];
	HINSTANCE hInst = _AtlBaseModule.GetModuleInstance();
	DWORD dwFLen = GetModuleFileName(hInst, szModule, MAX_PATH);
	if( dwFLen == 0 )
		return AtlHresultFromLastError();
	else if( dwFLen == MAX_PATH )
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	LPOLESTR pszModule = NULL;
	pszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(pszModule == NULL)
		return E_OUTOFMEMORY;
#endif

	OLECHAR pszModuleUnquoted[_MAX_PATH * 2];
	EscapeSingleQuote(pszModuleUnquoted, _countof(pszModuleUnquoted), pszModule);

	HRESULT hRes;
	if ((hInst == NULL) || (hInst == GetModuleHandle(NULL))) // register as EXE
	{
		// If Registering as an EXE, then we quote the resultant path.
		// We don't do it for a DLL, because LoadLibrary fails if the path is
		// quoted
		OLECHAR pszModuleQuote[(_MAX_PATH + _ATL_QUOTES_SPACE)*2];
		pszModuleQuote[0] = OLESTR('\"');
		if(!ocscpy_s(pszModuleQuote + 1, (_MAX_PATH + _ATL_QUOTES_SPACE)*2 - 1, pszModuleUnquoted))
		{
			return E_FAIL;
		}
		size_t nLen = ocslen(pszModuleQuote);
		pszModuleQuote[nLen] = OLESTR('\"');
		pszModuleQuote[nLen + 1] = 0;

		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	}
	else
	{
		hRes = ro.AddReplacement(OLESTR("Module"), pszModuleUnquoted);
	}

	if(FAILED(hRes))
		return hRes;

	hRes = ro.AddReplacement(OLESTR("Module_Raw"), pszModuleUnquoted);
	if(FAILED(hRes))
		return hRes;

	LPCOLESTR szType = OLESTR("REGISTRY");
	hr = (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
		ro.ResourceUnregister(pszModule, nResID, szType);
	return hr;
}
#endif //_ATL_STATIC_REGISTRY

#ifndef _ATL_NO_COMMODULE

#pragma warning( push )
#pragma warning( disable: 4996 )  // Disable "deprecated symbol" warning

inline HRESULT WINAPI CComModule::UpdateRegistryClass(
	_In_ const CLSID& clsid,
	_In_opt_z_ LPCTSTR lpszProgID,
	_In_opt_z_ LPCTSTR lpszVerIndProgID,
	_In_ UINT nDescID,
	_In_ DWORD dwFlags,
	_In_ BOOL bRegister)
{
	if (bRegister)
	{
		TCHAR szDesc[256];
		LoadString(m_hInst, nDescID, szDesc, 256);
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, szDesc, dwFlags);
	}
	return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::UpdateRegistryClass(
	_In_ const CLSID& clsid,
	_In_opt_z_ LPCTSTR lpszProgID,
	_In_opt_z_ LPCTSTR lpszVerIndProgID,
	_In_z_ LPCTSTR szDesc,
	_In_ DWORD dwFlags,
	_In_ BOOL bRegister)
{
	if (bRegister)
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, szDesc, dwFlags);
	return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(
	_In_ const CLSID& clsid,
	_In_opt_z_ LPCTSTR lpszProgID,
	_In_opt_z_ LPCTSTR lpszVerIndProgID,
	_In_z_ LPCTSTR szDesc,
	_In_ DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION_EX;
	TCHAR szModule[_MAX_PATH + _ATL_QUOTES_SPACE];

	ATLENSURE(lpszProgID && lpszVerIndProgID || !lpszProgID && !lpszVerIndProgID);

	if (!szDesc)
	{
		szDesc = _T("");
	}

	// If the ModuleFileName's length is equal or greater than the 3rd parameter
	// (length of the buffer passed),GetModuleFileName fills the buffer (truncates
	// if neccessary), but doesn't null terminate it. It returns the same value as
	// the 3rd parameter passed. So if the return value is the same as the 3rd param
	// then you have a non null terminated buffer (which may or may not be truncated)
	// We pass (szModule + 1) because in case it's an EXE we need to quote the PATH
	// The quote is done later in this method before the SetKeyValue is called
	DWORD dwLen = GetModuleFileName(m_hInst, szModule + 1, MAX_PATH);
	if (dwLen == 0)
	{
		return AtlHresultFromLastError();
	}
	else if( dwLen == MAX_PATH )
	{
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}

	LPOLESTR lpOleStr;
	HRESULT hRes = StringFromCLSID(clsid, &lpOleStr);
	if (FAILED(hRes))
		return hRes;

	LPTSTR lpszCLSID = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(lpszCLSID == NULL)
	{
		CoTaskMemFree(lpOleStr);
		return E_OUTOFMEMORY;
	}
#endif

	hRes = lpszProgID ? RegisterProgID(lpszCLSID, lpszProgID, szDesc) : S_OK;
	if (hRes == S_OK)
	{
		// use lpszProgID as the CurVer ProgID
		hRes = lpszVerIndProgID ? RegisterVersionIndependentProgID(lpszCLSID, lpszVerIndProgID, lpszProgID, szDesc) : S_OK;
	}
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ | KEY_WRITE);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpszCLSID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = key.SetStringValue(NULL, szDesc);
				if (lRes == ERROR_SUCCESS)
				{
					lRes = lpszProgID ? key.SetKeyValue(szProgID, lpszProgID) : ERROR_SUCCESS;
					if (lRes == ERROR_SUCCESS)
					{
						lRes = lpszVerIndProgID ? key.SetKeyValue(szVIProgID, lpszVerIndProgID) : ERROR_SUCCESS;
						if (lRes == ERROR_SUCCESS)
						{
							if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
							{
								// If Registering as an EXE, then we quote the resultant path.
								// We don't do it for a DLL, because LoadLibrary fails if the path is
								// quoted
								szModule[0] = _T('\"');
								szModule[dwLen + 1] = _T('\"');
								szModule[dwLen + 2] = 0;

								lRes = key.SetKeyValue(szLS32, szModule);
							}
							else
							{
								lRes = key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule + 1);
								if (lRes == ERROR_SUCCESS)
								{
									LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
										(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
									if (lpszModel != NULL)
										lRes = key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
								}
							}
						}
					}
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = AtlHresultFromWin32(lRes);
	return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(
	_In_ const CLSID& clsid,
	_In_opt_z_ LPCTSTR lpszProgID,
	_In_opt_z_ LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION_EX;
	CRegKey key;
	LONG lRet;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lpszProgID[0]!=_T('\0'))
	{
		lRet = key.RecurseDeleteKey(lpszProgID);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceCOM, 0, _T("Failed to Unregister ProgID : %s\n"), lpszProgID);
			key.Detach();
			return AtlHresultFromWin32(lRet);
		}
	}
	if (lpszVerIndProgID != NULL && lpszVerIndProgID[0]!=_T('\0'))
	{
		lRet = key.RecurseDeleteKey(lpszVerIndProgID);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceCOM, 0, _T("Failed to Unregister Version Independent ProgID : %s\n"), lpszVerIndProgID);
			key.Detach();
			return AtlHresultFromWin32(lRet);
		}
	}
	LPOLESTR lpOleStr;
	HRESULT hr = StringFromCLSID(clsid, &lpOleStr);
	if (SUCCEEDED(hr))
	{
		LPTSTR lpsz = OLE2T_EX(lpOleStr, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
		if(lpsz == NULL)
		{
			CoTaskMemFree(lpOleStr);
			return E_OUTOFMEMORY;
		}
#endif

		lRet = key.Open(key, _T("CLSID"), KEY_READ | KEY_WRITE);
		if (lRet == ERROR_SUCCESS)
			lRet = key.RecurseDeleteKey(lpsz);
		if (lRet != ERROR_SUCCESS && lRet != ERROR_FILE_NOT_FOUND && lRet != ERROR_PATH_NOT_FOUND)
		{
			ATLTRACE(atlTraceCOM, 0, _T("Failed to delete CLSID : %s\n"), lpsz);
			hr = AtlHresultFromWin32(lRet);
		}
		CoTaskMemFree(lpOleStr);
	}
	else
	{
		ATLTRACE(atlTraceCOM, 0, _T("Failed to delete CLSID : {%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
			clsid.Data1,
			clsid.Data2,
			clsid.Data3,
			clsid.Data4[0],
			clsid.Data4[1],
			clsid.Data4[2],
			clsid.Data4[3],
			clsid.Data4[4],
			clsid.Data4[5],
			clsid.Data4[6],
			clsid.Data4[7]
			);
	}
	key.Detach();
	return hr;
}

#pragma warning( pop ) // Disable "deprecated symbol" warning

#endif	// !_ATL_NO_COMMODULE

#ifdef _ATL_DEBUG_INTERFACES

inline void _QIThunk::Dump() throw()
{
	TCHAR buf[512+1];
	if (m_dwRef != 0)
	{
		_stprintf_s(buf, _countof(buf), _T("ATL: QIThunk - %-10d\tLEAK    :\tObject = 0x%p\tRefcount = %d\tMaxRefCount = %d\t"),
			m_nIndex, m_pUnk, m_dwRef, m_dwMaxRef);
		buf[_countof(buf)-1] = 0;
		OutputDebugString(buf);
		AtlDumpIID(m_iid, m_lpszClassName, S_OK);
	}
	else
	{
		_stprintf_s(buf, _countof(buf), _T("ATL: QIThunk - %-10d\tNonAddRef LEAK :\tObject = 0x%p\t"), m_nIndex, m_pUnk);
		buf[_countof(buf)-1] = 0;
		OutputDebugString(buf);
		AtlDumpIID(m_iid, m_lpszClassName, S_OK);
	}
}

#endif	// _ATL_DEBUG_INTERFACES

#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
__forceinline HRESULT WINAPI AtlDumpIID(
	_In_ REFIID iid,
	_In_z_ LPCTSTR pszClassName,
	_In_ HRESULT hr) throw()
{
	USES_CONVERSION_EX;
	CRegKey key;
	TCHAR szName[100];
	DWORD dwType;
	DWORD dw = sizeof(szName);

	LPOLESTR pszGUID = NULL;
	if (FAILED(StringFromCLSID(iid, &pszGUID)))
		return hr;

	OutputDebugString(pszClassName);
	OutputDebugString(_T(" - "));

	LPTSTR lpszGUID = OLE2T_EX(pszGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(lpszGUID == NULL)
	{
		CoTaskMemFree(pszGUID);
		return hr;
	}
#endif
	// Attempt to find it in the interfaces section
	BOOL fClsNameFound = FALSE;
	if (key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ) == ERROR_SUCCESS)
	{
		if (key.Open(key, lpszGUID, KEY_READ) == ERROR_SUCCESS)
		{
			*szName = 0;
			if (RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw) == ERROR_SUCCESS)
			{
				OutputDebugString(szName);
				fClsNameFound = TRUE;
			}
		}
	}
	// Attempt to find it in the clsid section
	if ( !fClsNameFound && key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
	{
		if (key.Open(key, lpszGUID, KEY_READ) == ERROR_SUCCESS)
		{
			*szName = 0;
			if (RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw) == ERROR_SUCCESS)
			{
				OutputDebugString(_T("(CLSID\?\?\?) "));
				OutputDebugString(szName);
				fClsNameFound = TRUE;
			}
		}
	}
	/*Dump out the GUID only if no class name found*/
	if( !fClsNameFound )
		OutputDebugString(lpszGUID);

	if (hr != S_OK)
		OutputDebugString(_T(" - failed"));
	OutputDebugString(_T("\n"));
	CoTaskMemFree(pszGUID);

	return hr;
}
#endif	// _ATL_DEBUG_INTERFACES || _ATL_DEBUG_QI


// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL

#ifndef _ATL_NO_AUTOMATIC_NAMESPACE
using namespace ATL;
#endif //!_ATL_NO_AUTOMATIC_NAMESPACE

#ifdef _ATL_ATTRIBUTES
#include <atlplus.h>
#endif

namespace ATL
{

// All exports go here
// Pull in if building ATL DLL or not linking to ATL DLL
#ifndef _ATL_DLL

/////////////////////////////////////////////////////////////////////////////
// statics

static inline LPTSTR AtlFindExtension(_In_z_ LPCTSTR psz)
{
	if (psz == NULL)
		return NULL;
	LPCTSTR pszRemember = NULL;
	while (*psz != _T('\0'))
	{
		switch(*psz)
		{
		case _T('\\'):
			pszRemember = NULL;
			break;
		case _T('.'):
			pszRemember = psz;
			break;
		default:
			break;
		}
		psz = CharNext(psz);
	}
	return (LPTSTR)((pszRemember == NULL) ? psz : pszRemember);
}

/////////////////////////////////////////////////////////////////////////////
// Per User Registration

ATLINLINE ATLAPI AtlSetPerUserRegistration(_In_ bool bEnable)
{
	_AtlRegisterPerUser = bEnable;
	return S_OK;
}

ATLINLINE ATLAPI AtlGetPerUserRegistration(_Out_ bool* pbEnabled)
{
	if (pbEnabled == NULL)
		return E_POINTER;

	*pbEnabled = _AtlRegisterPerUser;
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib registration

#define _ATL_MAX_PATH_PLUS_INDEX (_MAX_PATH + _ATL_TYPELIB_INDEX_LENGTH)

ATLPREFAST_SUPPRESS(6387)
ATLINLINE ATLAPI AtlLoadTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex,
	_Deref_out_z_ BSTR* pbstrPath,
	_Deref_out_ ITypeLib** ppTypeLib)
{
	ATLASSERT(pbstrPath != NULL && ppTypeLib != NULL);
	if (pbstrPath == NULL || ppTypeLib == NULL)
		return E_POINTER;

	*pbstrPath = NULL;
	*ppTypeLib = NULL;

	USES_CONVERSION_EX;
	ATLASSERT(hInstTypeLib != NULL);
	TCHAR szModule[_ATL_MAX_PATH_PLUS_INDEX];

	DWORD dwFLen = GetModuleFileName(hInstTypeLib, szModule, MAX_PATH);
	if( dwFLen == 0 )
		return AtlHresultFromLastError();
	else if( dwFLen == MAX_PATH )
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

	// get the extension pointer in case of fail
	LPTSTR lpszExt = NULL;

	lpszExt = AtlFindExtension(szModule);

	if (lpszIndex != NULL)
	{
		LPCTSTR lpcszIndex = OLE2CT_EX(lpszIndex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if(lpcszIndex == NULL)
		{
			return E_OUTOFMEMORY;
		}
		DWORD nIndexLen = lstrlen(lpcszIndex);

		DWORD newLen = dwFLen + nIndexLen;
		if ((newLen < dwFLen) || (newLen < nIndexLen) || (newLen >= _ATL_MAX_PATH_PLUS_INDEX))
			return E_FAIL;
#ifdef UNICODE
		Checked::wcscpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);
#else
		Checked::strcpy_s(szModule + dwFLen, _countof(szModule) - dwFLen, lpcszIndex);
#endif
	}
	LPOLESTR lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if(lpszModule == NULL)
		return E_OUTOFMEMORY;
#endif
	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
	if (FAILED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		TCHAR szExt[] = _T(".tlb");
		if ((lpszExt - szModule + sizeof(szExt)/sizeof(TCHAR)) > _MAX_PATH)
			return E_FAIL;

#ifdef UNICODE
		Checked::wcscpy_s(lpszExt, _countof(szModule) - (lpszExt - szModule), szExt);
#else
		Checked::strcpy_s(lpszExt, _countof(szModule) - (lpszExt - szModule), szExt);
#endif
		lpszModule = T2OLE_EX(szModule, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
		if(lpszModule == NULL)
			return E_OUTOFMEMORY;
#endif
		hr = LoadTypeLib(lpszModule, ppTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		*pbstrPath = ::SysAllocString(lpszModule);
		if (*pbstrPath == NULL)
			hr = E_OUTOFMEMORY;
	}
	return hr;
}
ATLPREFAST_UNSUPPRESS()

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper(
	_In_ REFCLSID clsid,
    _In_opt_ const struct _ATL_CATMAP_ENTRY* pCatMap,
	_In_ BOOL bRegister)
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
	  return( S_OK );
   }

   if (InlineIsEqualGUID(clsid, GUID_NULL))
   {
	  ATLASSERT(0 && _T("Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to register class categories for non creatable objects."));
	  return S_OK;
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
	  // Since not all systems have the category manager installed, we'll allow
	  // the registration to succeed even though we didn't register our
	  // categories.  If you really want to register categories on a system
	  // without the category manager, you can either manually add the
	  // appropriate entries to your registry script (.rgs), or you can
	  // redistribute comcat.dll.
	  return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
	  catid = *pEntry->pcatid;
	  if( bRegister )
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
			   &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
			   &catid );
		 }
		 if( FAILED( hResult ) )
		 {
			return( hResult );
		 }
	  }
	  else
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
		 }
	  }
	  pEntry++;
   }

   // When unregistering remove "Implemented Categories" and "Required Categories" subkeys if they are empty.
   if (!bRegister)
   {
		OLECHAR szGUID[64];
		::StringFromGUID2(clsid, szGUID, 64);
		USES_CONVERSION_EX;
		TCHAR* pszGUID = OLE2T_EX(szGUID, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (pszGUID != NULL)
		{
			TCHAR szKey[128];
#ifdef UNICODE
			Checked::wcscpy_s(szKey, _countof(szKey), _T("CLSID\\"));
			Checked::wcscat_s(szKey, _countof(szKey), pszGUID);
			Checked::wcscat_s(szKey, _countof(szKey), _T("\\Required Categories"));
#else
			Checked::strcpy_s(szKey, _countof(szKey), _T("CLSID\\"));
			Checked::strcat_s(szKey, _countof(szKey), pszGUID);
			Checked::strcat_s(szKey, _countof(szKey), _T("\\Required Categories"));
#endif

			CRegKey root(HKEY_CLASSES_ROOT);
			CRegKey key;
			DWORD cbSubKeys = 0;

			LRESULT lRes = key.Open(root, szKey, KEY_READ);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
				key.Close();
				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
				{
					root.DeleteSubKey(szKey);
				}
			}

#ifdef UNICODE
			Checked::wcscpy_s(szKey, _countof(szKey), _T("CLSID\\"));
			Checked::wcscat_s(szKey, _countof(szKey), pszGUID);
			Checked::wcscat_s(szKey, _countof(szKey), _T("\\Implemented Categories"));
#else
			Checked::strcpy_s(szKey, _countof(szKey), _T("CLSID\\"));
			Checked::strcat_s(szKey, _countof(szKey), pszGUID);
			Checked::strcat_s(szKey, _countof(szKey), _T("\\Implemented Categories"));
#endif
			lRes = key.Open(root, szKey, KEY_READ);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
				key.Close();
				if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
				{
					root.DeleteSubKey(szKey);
				}
			}
		}
   }
   return( S_OK );
}

#endif // _ATL_DLL

ATLINLINE ATLAPIINL AtlWinModuleTerm(
	_Inout_ _ATL_WIN_MODULE* pWinModule,
	_In_ HINSTANCE hInst)
{
	if (pWinModule == NULL)
		return E_INVALIDARG;
	if (pWinModule->cbSize == 0)
		return S_OK;
	if (pWinModule->cbSize != sizeof(_ATL_WIN_MODULE))
		return E_INVALIDARG;

	for (int i = 0; i < pWinModule->m_rgWindowClassAtoms.GetSize(); i++)
		UnregisterClass((LPCTSTR)pWinModule->m_rgWindowClassAtoms[i], hInst);
	pWinModule->m_rgWindowClassAtoms.RemoveAll();
	pWinModule->m_csWindowCreate.Term();
	pWinModule->cbSize = 0;
	return S_OK;
}

static inline UINT WINAPI AtlGetDirLen(_In_z_ LPCOLESTR lpszPathName) throw()
{
	ATLASSERT(lpszPathName != NULL);
	if(lpszPathName == NULL)
		return 0;

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != '\0'; )
	{

		LPCOLESTR lp = CharNextW(lpsz);

		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return UINT( lpszTemp-lpszPathName );
}

ATLINLINE ATLAPIINL AtlUnRegisterTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		TLIBATTR* ptla;
		hr = pTypeLib->GetLibAttr(&ptla);
		if (SUCCEEDED(hr))
		{
			typedef HRESULT (STDAPICALLTYPE *PFNUNREGISTERTYPELIB)(REFGUID, WORD /* wVerMajor */, WORD /* wVerMinor */, LCID, SYSKIND);
			PFNUNREGISTERTYPELIB pfnUnRegisterTypeLib = NULL;

			bool bRedirectionEnabled = false;
			hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
			if( FAILED(hr) )
			{
				return hr;
			}

			if( true == bRedirectionEnabled )
			{
				HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");
				if(hmodOleAut)
				{
					pfnUnRegisterTypeLib=reinterpret_cast<PFNUNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "UnRegisterTypeLibForUser"));
				}
			}

			if( NULL == pfnUnRegisterTypeLib )
			{
				pfnUnRegisterTypeLib = (PFNUNREGISTERTYPELIB)&UnRegisterTypeLib;
			}

			hr = pfnUnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);

			pTypeLib->ReleaseTLibAttr(ptla);
		}
	}
	return hr;
}

ATLINLINE ATLAPIINL AtlRegisterTypeLib(
	_In_ HINSTANCE hInstTypeLib,
	_In_opt_z_ LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		LPCOLESTR szDir=NULL;
		OLECHAR szDirBuffer[MAX_PATH];
		CComBSTR bstrHelpFile;
		hr = pTypeLib->GetDocumentation(-1, NULL, NULL, NULL, &bstrHelpFile);
		if (SUCCEEDED(hr) && bstrHelpFile != NULL)
		{
			Checked::wcsncpy_s(szDirBuffer, MAX_PATH, bstrHelpFile.m_str, bstrHelpFile.Length());
			szDirBuffer[MAX_PATH - 1] = 0;

			// truncate at the directory level
			szDirBuffer[AtlGetDirLen(szDirBuffer)] = 0;

			szDir=&szDirBuffer[0];
		}

		typedef HRESULT (STDAPICALLTYPE *PFNREGISTERTYPELIB)(ITypeLib *, LPCOLESTR /* const szFullPath */, LPCOLESTR /* const szHelpDir */);
		PFNREGISTERTYPELIB pfnRegisterTypeLib = NULL;

		bool bRedirectionEnabled = false;
		hr = AtlGetPerUserRegistration(&bRedirectionEnabled);
		if( FAILED(hr) )
		{
			return hr;
		}

		if( true == bRedirectionEnabled )
		{
			HMODULE hmodOleAut=::GetModuleHandleW(L"OLEAUT32.DLL");
			if(hmodOleAut)
			{
				pfnRegisterTypeLib=reinterpret_cast<PFNREGISTERTYPELIB>(::GetProcAddress(hmodOleAut, "RegisterTypeLibForUser"));
			}
		}

		if( NULL == pfnRegisterTypeLib )
		{
			pfnRegisterTypeLib = (PFNREGISTERTYPELIB)&RegisterTypeLib;
		}

		hr = pfnRegisterTypeLib(pTypeLib, bstrPath, szDir);

	}
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Registration

// AtlComModuleRegisterServer walks the ATL Autogenerated Object Map and registers each object in the map
// If pCLSID is not NULL then only the object referred to by pCLSID is registered (The default case)
// otherwise all the objects are registered
ATLINLINE ATLAPIINL AtlComModuleRegisterServer(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ BOOL bRegTypeLib,
	_In_opt_ const CLSID* pCLSID)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;
	ATLASSERT(pComModule->m_hInstTypeLib != NULL);

	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = pEntry->pfnUpdateRegistry(TRUE);
			if (FAILED(hr))
				break;
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hr))
				break;
		}
	}

	if (SUCCEEDED(hr) && bRegTypeLib)
	{
		ATLASSUME(pComModule->m_hInstTypeLib != NULL);
		hr = AtlRegisterTypeLib(pComModule->m_hInstTypeLib, 0);
	}

	return hr;
}

// AtlComUnregisterServer walks the ATL Object Map and unregisters each object in the map
// If pCLSID is not NULL then only the object referred to by pCLSID is unregistered (The default case)
// otherwise all the objects are unregistered.
ATLINLINE ATLAPIINL AtlComModuleUnregisterServer(
	_Inout_ _ATL_COM_MODULE* pComModule,
	_In_ BOOL bUnRegTypeLib,
	_In_opt_ const CLSID* pCLSID)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, pEntry->pfnGetCategoryMap(), FALSE );
			if (FAILED(hr))
				break;
			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr) && bUnRegTypeLib)
		hr = AtlUnRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

#pragma warning(push)
#pragma warning(disable : 4191)	// 'type cast' : unsafe conversion from 'FARPROC' to 'DLLGETVERSIONPROC'

inline HRESULT AtlGetDllVersion(
	_In_ HINSTANCE hInstDLL,
	_Out_ DLLVERSIONINFO* pDllVersionInfo)
{
	ATLENSURE(pDllVersionInfo != NULL);

	// We must get this function explicitly because some DLLs don't implement it.
	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");

	if(pfnDllGetVersion == NULL)
	{
		return E_NOTIMPL;
	}

	return (*pfnDllGetVersion)(pDllVersionInfo);
}

#pragma warning(pop)

inline HRESULT AtlGetDllVersion(
	_In_z_ LPCTSTR lpstrDllName,
	_Out_ DLLVERSIONINFO* pDllVersionInfo)
{
	HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
	if(hInstDLL == NULL)
	{
		return AtlHresultFromLastError();
	}
	HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
	::FreeLibrary(hInstDLL);
	return hRet;
}

// Common Control Versions:
//   WinNT 4.0          maj=4 min=00
//   IE 3.x             maj=4 min=70
//   IE 4.0             maj=4 min=71
//   IE 5.0             maj=5 min=80
//   Win2000            maj=5 min=81
inline HRESULT AtlGetCommCtrlVersion(
	_Out_ LPDWORD pdwMajor,
	_Out_ LPDWORD pdwMinor)
{
	ATLENSURE(( pdwMajor != NULL ) && ( pdwMinor != NULL ));

	DLLVERSIONINFO dvi;
	memset(&dvi, 0, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);

	HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}

	return hRet;
}

// Shell Versions:
//   WinNT 4.0                                      maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop             maj=4 min=71
//   IE 4.01 with Web Integrated Desktop            maj=4 min=72
//   Win2000                                        maj=5 min=00
inline HRESULT AtlGetShellVersion(
	_Out_ LPDWORD pdwMajor,
	_Out_ LPDWORD pdwMinor)
{
	ATLENSURE(( pdwMajor != NULL) && ( pdwMinor != NULL ));

	DLLVERSIONINFO dvi;
	memset(&dvi, 0, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}

	return hRet;
}

inline ATL_DEPRECATED("AtlModuleRegisterClassObjects has been replaced by AtlComModuleRegisterClassObjects")
HRESULT AtlModuleRegisterClassObjects(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ DWORD dwClsContext,
	_In_ DWORD dwFlags)
{
	return AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
}

inline ATL_DEPRECATED("AtlModuleRevokeClassObjects has been replaced by AtlComModuleRevokeClassObjects")
HRESULT AtlModuleRevokeClassObjects(_In_opt_ _ATL_MODULE* /*pM*/)
{
	return AtlComModuleRevokeClassObjects(&_AtlComModule);
}

inline ATL_DEPRECATED("AtlModuleGetClassObject has been replaced by AtlComModuleGetClassObject")
HRESULT AtlModuleGetClassObject(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ REFCLSID rclsid,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv)
{
	return AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
}

inline ATL_DEPRECATED("AtlModuleRegisterServer has been replaced by AtlComModuleRegisterServer")
HRESULT AtlModuleRegisterServer(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ BOOL bRegTypeLib,
	_In_opt_ const CLSID* pCLSID = NULL)
{
	return AtlComModuleRegisterServer(&_AtlComModule, bRegTypeLib, pCLSID);
}

inline ATL_DEPRECATED("AtlModuleUnregisterServer has been replaced by AtlComModuleUnregisterServer")
HRESULT AtlModuleUnregisterServer(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_opt_ const CLSID* pCLSID = NULL)
{
	return AtlComModuleUnregisterServer(&_AtlComModule, FALSE, pCLSID);
}

inline ATL_DEPRECATED("AtlModuleUnregisterServerEx has been replaced by AtlComModuleUnregisterServer")
HRESULT AtlModuleUnregisterServerEx(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ BOOL bUnRegTypeLib,
	_In_opt_ const CLSID* pCLSID = NULL)
{
	return AtlComModuleUnregisterServer(&_AtlComModule, bUnRegTypeLib, pCLSID);
}

inline ATL_DEPRECATED("AtlModuleUpdateRegistryFromResourceD has been replaced by AtlUpdateRegistryFromResourceD")
HRESULT AtlModuleUpdateRegistryFromResourceD(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_z_ LPCOLESTR lpszRes,
	_In_ BOOL bRegister,
	_In_ struct _ATL_REGMAP_ENTRY* pMapEntries,
	_In_opt_ IRegistrar* pReg = NULL)
{
	return AtlUpdateRegistryFromResourceD(_AtlBaseModule.GetModuleInstance(), lpszRes, bRegister, pMapEntries, pReg);
}

inline ATL_DEPRECATED("AtlModuleRegisterTypeLib has been replaced by AtlRegisterTypeLib")
HRESULT AtlModuleRegisterTypeLib(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_z_ LPCOLESTR lpszIndex)
{
	return AtlRegisterTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex);
}

inline ATL_DEPRECATED("AtlModuleUnRegisterTypeLib has been replaced by AtlUnRegisterTypeLib")
HRESULT AtlModuleUnRegisterTypeLib(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_z_ LPCOLESTR lpszIndex)
{
	return AtlUnRegisterTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex);
}

inline ATL_DEPRECATED("AtlModuleLoadTypeLib has been replaced by AtlLoadTypeLib")
HRESULT AtlModuleLoadTypeLib(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_z_ LPCOLESTR lpszIndex,
	_Deref_out_z_ BSTR* pbstrPath,
	_Deref_out_ ITypeLib** ppTypeLib)
{
	return AtlLoadTypeLib(_AtlComModule.m_hInstTypeLib, lpszIndex, pbstrPath, ppTypeLib);
}

inline ATL_DEPRECATED("AtlModuleInit is no longer required")
HRESULT AtlModuleInit(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_opt_ _ATL_OBJMAP_ENTRY* /*p*/,
	_In_ HINSTANCE /*h*/)
{
	return S_OK;
}

inline ATL_DEPRECATED("AtlModuleTerm is no longer required")
HRESULT AtlModuleTerm(_In_opt_ _ATL_MODULE* /*pM*/)
{
	return S_OK;
}

inline ATL_DEPRECATED("AtlModuleAddCreateWndData has been replaced by AtlWinModuleAddCreateWndData")
void AtlModuleAddCreateWndData(
	_In_opt_ _ATL_MODULE* /*pM*/,
	_In_ _AtlCreateWndData* pData,
	_In_ void* pObject)
{
	AtlWinModuleAddCreateWndData(&_AtlWinModule, pData, pObject);
}

inline ATL_DEPRECATED("AtlModuleExtractCreateWndData has been replaced by AtlWinModuleExtractCreateWndData")
void* AtlModuleExtractCreateWndData(_In_opt_ _ATL_MODULE* /*pM*/)
{
	return AtlWinModuleExtractCreateWndData(&_AtlWinModule);
}

#ifndef _ATL_NO_COMMODULE

inline CRITICAL_SECTION& CComModule::get_m_csWindowCreate() throw()
{
	return _AtlWinModule.m_csWindowCreate.m_sec;
}

inline CRITICAL_SECTION& CComModule::get_m_csObjMap() throw()
{
	return _AtlComModule.m_csObjMap.m_sec;
}

inline CRITICAL_SECTION& CComModule::get_m_csStaticDataInit() throw()
{
	return m_csStaticDataInitAndTypeInfo.m_sec;
}

inline _AtlCreateWndData*& CComModule::get_m_pCreateWndList()  throw()
{
	return _AtlWinModule.m_pCreateWndList;
}
inline void CComModule::put_m_pCreateWndList(_In_ _AtlCreateWndData* p) throw()
{
	_AtlWinModule.m_pCreateWndList = p;
}
#ifdef _ATL_DEBUG_INTERFACES
inline UINT& CComModule::get_m_nIndexQI() throw()
{
	return _AtlDebugInterfacesModule.m_nIndexQI;
}
inline void CComModule::put_m_nIndexQI(_In_ UINT nIndex) throw()
{
	_AtlDebugInterfacesModule.m_nIndexQI = nIndex;
}
inline UINT& CComModule::get_m_nIndexBreakAt() throw()
{
	return _AtlDebugInterfacesModule.m_nIndexBreakAt;
}
inline void CComModule::put_m_nIndexBreakAt(_In_ UINT nIndex) throw()
{
	_AtlDebugInterfacesModule.m_nIndexBreakAt = nIndex;
}
inline CSimpleArray<_QIThunk*>* CComModule::get_m_paThunks() throw()
{
	return &_AtlDebugInterfacesModule.m_aThunks;
}
inline HRESULT CComModule::AddThunk(
	_Inout_ _Deref_pre_valid_ _Deref_post_valid_ IUnknown** pp,
	_In_z_ LPCTSTR lpsz,
	_In_ REFIID iid) throw()
{
	return _AtlDebugInterfacesModule.AddThunk(pp, lpsz, iid);
}
inline HRESULT CComModule::AddNonAddRefThunk(
	_Inout_ IUnknown* p,
	_In_z_ LPCTSTR lpsz,
	_Deref_out_ IUnknown** ppThunkRet) throw()
{
	return _AtlDebugInterfacesModule.AddNonAddRefThunk(p, lpsz, ppThunkRet);
}

inline void CComModule::DeleteNonAddRefThunk(_In_ IUnknown* pUnk) throw()
{
	_AtlDebugInterfacesModule.DeleteNonAddRefThunk(pUnk);
}

inline void CComModule::DeleteThunk(_In_ _QIThunk* p) throw()
{
	_AtlDebugInterfacesModule.DeleteThunk(p);
}

inline bool CComModule::DumpLeakedThunks() throw()
{
	return _AtlDebugInterfacesModule.DumpLeakedThunks();
}
#endif // _ATL_DEBUG_INTERFACES

inline HRESULT CComModule::Init(
	_In_ _ATL_OBJMAP_ENTRY* p,
	_In_ HINSTANCE /*h*/,
	_In_opt_ const GUID* plibid) throw()
{
	if (plibid != NULL)
		m_libid = *plibid;

	_ATL_OBJMAP_ENTRY* pEntry;
	if (p != (_ATL_OBJMAP_ENTRY*)-1)
	{
		m_pObjMap = p;
		if (m_pObjMap != NULL)
		{
			pEntry = m_pObjMap;
			while (pEntry->pclsid != NULL)
			{
				pEntry->pfnObjectMain(true); //initialize class resources
				pEntry++;
			}
		}
	}
	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
			(*ppEntry)->pfnObjectMain(true); //initialize class resources
	}
	return S_OK;
}

inline void CComModule::Term() throw()
{
	_ATL_OBJMAP_ENTRY* pEntry;
	if (m_pObjMap != NULL)
	{
		pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry->pfnObjectMain(false); //cleanup class resources
			pEntry++;
		}
	}

	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
			(*ppEntry)->pfnObjectMain(false); //cleanup class resources
	}
#ifdef _DEBUG
	// Prevent false memory leak reporting. ~CAtlWinModule may be too late.
	_AtlWinModule.Term();
#endif	// _DEBUG

	CAtlModuleT<CComModule>::Term();
}

ATLPREFAST_SUPPRESS(6387)
inline HRESULT CComModule::GetClassObject(
	_In_ REFCLSID rclsid,
	_In_ REFIID riid,
	_Deref_out_ LPVOID* ppv) throw()
{
	*ppv = NULL;
	HRESULT hr = S_OK;

	if (m_pObjMap != NULL)
	{
		const _ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;

		while (pEntry->pclsid != NULL)
		{
			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
			{
				if (pEntry->pCF == NULL)
				{
					CComCritSecLock<CComCriticalSection> lock(_AtlComModule.m_csObjMap, false);
					hr = lock.Lock();
					if (FAILED(hr))
					{
						ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CComModule::GetClassObject\n"));
						ATLASSERT(FALSE);
						break;
					}

					if (pEntry->pCF == NULL)
					{
						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
					}
				}

				if (pEntry->pCF != NULL)
				{
					hr = pEntry->pCF->QueryInterface(riid, ppv);
				}
				break;
			}
			pEntry++;
		}
	}

	if (*ppv == NULL && hr == S_OK)
	{
		hr = AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
	}

	return hr;
}
ATLPREFAST_UNSUPPRESS()

// Register/Revoke All Class Factories with the OS (EXE only)
inline HRESULT CComModule::RegisterClassObjects(
	_In_ DWORD dwClsContext,
	_In_ DWORD dwFlags) throw()
{
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry;
	if (m_pObjMap != NULL)
	{
		pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL && hr == S_OK)
		{
			hr = pEntry->RegisterClassObject(dwClsContext, dwFlags);
			pEntry++;
		}
	}
	if (hr == S_OK)
		hr = AtlComModuleRegisterClassObjects(&_AtlComModule, dwClsContext, dwFlags);
	return hr;
}
inline HRESULT CComModule::RevokeClassObjects() throw()
{
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry;
	if (m_pObjMap != NULL)
	{
		pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL && hr == S_OK)
		{
			hr = pEntry->RevokeClassObject();
			pEntry++;
		}
	}
	if (hr == S_OK)
		hr = AtlComModuleRevokeClassObjects(&_AtlComModule);
	return hr;
}

// Registry support (helpers)
inline HRESULT CComModule::RegisterTypeLib() throw()
{
	return _AtlComModule.RegisterTypeLib();
}
inline HRESULT CComModule::RegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw()
{
	return _AtlComModule.RegisterTypeLib(lpszIndex);
}
inline HRESULT CComModule::UnRegisterTypeLib() throw()
{
	return _AtlComModule.UnRegisterTypeLib();
}
inline HRESULT CComModule::UnRegisterTypeLib(_In_z_ LPCTSTR lpszIndex) throw()
{
	return _AtlComModule.UnRegisterTypeLib(lpszIndex);
}

inline HRESULT CComModule::RegisterServer(
	_In_ BOOL bRegTypeLib /*= FALSE*/,
	_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
{
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	if (pEntry != NULL)
	{
		for (;pEntry->pclsid != NULL; pEntry++)
		{
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = pEntry->pfnUpdateRegistry(TRUE);
			if (FAILED(hr))
				break;
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr))
		hr = CAtlModuleT<CComModule>::RegisterServer(bRegTypeLib, pCLSID);
	return hr;
}

inline HRESULT CComModule::UnregisterServer(
	_In_ BOOL bUnRegTypeLib,
	_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
{
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	if (pEntry != NULL)
	{
		for (;pEntry->pclsid != NULL; pEntry++)
		{
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), FALSE );
			if (FAILED(hr))
				break;
			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr))
		hr = CAtlModuleT<CComModule>::UnregisterServer(bUnRegTypeLib, pCLSID);
	return hr;
}

inline HRESULT CComModule::UnregisterServer(_In_opt_ const CLSID* pCLSID /*= NULL*/) throw()
{
	return UnregisterServer(FALSE, pCLSID);
}

#endif	// !_ATL_NO_COMMODULE

}	// namespace ATL


#pragma warning( pop )

#if !defined(_ATL_DLL) && !defined(_DEBUG)

#include <atlbase.inl>

#endif	// !_ATL_DLL && !_DEBUG

#pragma pack(pop)
#ifdef _ATL_ALL_WARNINGS
#pragma warning( pop )
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlcoll.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOLL_H__
#define __ATLCOLL_H__

#pragma once

#include <atlbase.h>
#include <new.h>

// setup default packing value
#ifndef _X86_
#include <afxv_cpu.h>
#endif

#pragma warning(push)
#pragma warning(disable: 4702)  // Unreachable code.  This file will have lots of it, especially without EH enabled.
#pragma warning(disable: 4512)  // assignment operator could not be generated
#pragma warning(disable: 4290)  // C++ Exception Specification ignored
#pragma warning(disable: 4127)  // conditional expression constant
#pragma warning(disable: 4571)  //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions

// abstract iteration position
#ifndef _AFX
struct __POSITION
{
};
#endif
typedef __POSITION* POSITION;

#ifndef _AFX_PACKING
#define _AFX_PACKING 4
#endif

#pragma pack(push,_ATL_PACKING)
namespace ATL {

struct CAtlPlex     // warning variable length structure
{
	CAtlPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data()
	{
		return this+1;
	}

	static CAtlPlex* Create(
		_Inout_ CAtlPlex*& head,
		_In_ size_t nMax,
		_In_ size_t cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

inline CAtlPlex* CAtlPlex::Create(
	_Inout_ CAtlPlex*& pHead,
	_In_ size_t nMax,
	_In_ size_t nElementSize)
{
	CAtlPlex* pPlex;

	ATLASSERT( nMax > 0 );
	ATLASSERT( nElementSize > 0 );

	size_t nBytes=0;
	if( 	FAILED(::ATL::AtlMultiply(&nBytes, nMax, nElementSize)) ||
		FAILED(::ATL::AtlAdd(&nBytes, nBytes, sizeof(CAtlPlex))) )
	{
		return NULL;
	}
	pPlex = static_cast< CAtlPlex* >( malloc( nBytes ) );
	if( pPlex == NULL )
	{
		return( NULL );
	}

	pPlex->pNext = pHead;
	pHead = pPlex;

	return( pPlex );
}

inline void CAtlPlex::FreeDataChain()
{
	CAtlPlex* pPlex;

	pPlex = this;
	while( pPlex != NULL )
	{
		CAtlPlex* pNext;

		pNext = pPlex->pNext;
		free( pPlex );
		pPlex = pNext;
	}
}

template< typename T >
class CElementTraitsBase
{
public:
	typedef const T& INARGTYPE;
	typedef T& OUTARGTYPE;

	static void CopyElements(
		_Out_bytecap_x_(nElements * sizeof(T)) T* pDest,
		_In_bytecount_x_(nElements * sizeof(T)) const T* pSrc,
		_In_ size_t nElements)
	{		
		for( size_t iElement = 0; iElement < nElements; iElement++ )
		{
			pDest[iElement] = pSrc[iElement];
		}
	}
	
	static void RelocateElements(
		_Out_bytecap_x_(nElements * sizeof(T)) T* pDest,
		_In_bytecount_x_(nElements * sizeof(T)) T* pSrc,
		_In_ size_t nElements)
	{
		// A simple memmove works for nearly all types.
		// You'll have to override this for types that have pointers to their
		// own members.
		Checked::memmove_s( pDest, nElements*sizeof( T ), pSrc, nElements*sizeof( T ));
	}
};

template< typename T >
class CDefaultHashTraits
{
public:
	static ULONG Hash(_In_ const T& element) throw()
	{
		return( ULONG( ULONG_PTR( element ) ) );
	}
};

template< typename T >
class CDefaultCompareTraits
{
public:
	static bool CompareElements(
		_In_ const T& element1,
		_In_ const T& element2)
	{
		return( (element1 == element2) != 0 );  // != 0 to handle overloads of operator== that return BOOL instead of bool
	}

	static int CompareElementsOrdered(
		_In_ const T& element1,
		_In_ const T& element2)
	{
		if( element1 < element2 )
		{
			return( -1 );
		}
		else if( element1 == element2 )
		{
			return( 0 );
		}
		else
		{
			ATLASSERT( element1 > element2 );
			return( 1 );
		}
	}
};

template< typename T >
class CDefaultElementTraits :
	public CElementTraitsBase< T >,
	public CDefaultHashTraits< T >,
	public CDefaultCompareTraits< T >
{
};

template< typename T >
class CElementTraits :
	public CDefaultElementTraits< T >
{
};

template<>
class CElementTraits< GUID > :
	public CElementTraitsBase< GUID >
{
public:
	static ULONG Hash(_In_ INARGTYPE guid)
	{
		const DWORD* pdwData = reinterpret_cast< const DWORD* >( &guid );

		return( pdwData[0]^pdwData[1]^pdwData[2]^pdwData[3] );
	}

	static bool CompareElements(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2)
	{
		return( (element1 == element2) != 0 );  // != 0 to handle overloads of operator== that return BOOL instead of bool
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2)
	{
		const DWORD* pdwData1 = reinterpret_cast< const DWORD* >( &element1 );
		const DWORD* pdwData2 = reinterpret_cast< const DWORD* >( &element2 );

		for( int iDWORD = 3; iDWORD >= 0; iDWORD-- )
		{
			if( pdwData1[iDWORD] > pdwData2[iDWORD] )
			{
				return( 1 );
			}
			else if( pdwData1[iDWORD] < pdwData2[iDWORD] )
			{
				return( -1 );
			}
		}

		return( 0 );
	}
};

template<>
class CElementTraits< CComVariant > :
	public CElementTraitsBase< CComVariant >
{
public:
	typedef const VARIANT& INARGTYPE;

//	static ULONG Hash( INARGTYPE t );  // variant hashing is problematic

	static bool CompareElements(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2)
	{
		return VarCmp(const_cast<VARIANT*>(&element1), const_cast<VARIANT*>(&element2), LOCALE_USER_DEFAULT, 0)==static_cast<HRESULT>(VARCMP_EQ);
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2)
	{
		HRESULT hr = VarCmp(const_cast<VARIANT*>(&element1), const_cast<VARIANT*>(&element2), LOCALE_USER_DEFAULT, 0);
		if( hr == static_cast<HRESULT>(VARCMP_LT) )
		{
			return( -1 );
		}
		else if( hr == static_cast<HRESULT>(VARCMP_GT) )
		{
			return( 1 );
		}
		else
		{
			ATLASSERT( hr == static_cast<HRESULT>(VARCMP_EQ) || hr == static_cast<HRESULT>(VARCMP_NULL) );
			return( 0 );
		}
	}
};

template<>
class CElementTraits< CComBSTR > :
	public CElementTraitsBase< CComBSTR >
{
public:
	static ULONG Hash(_In_ INARGTYPE bstr) throw()
	{
		ULONG nHash = 0;
		const OLECHAR* pch = bstr;
		ULONG nLength = bstr.Length();
		for( ULONG iChar = 0; iChar < nLength; iChar++ )
		{
			nHash = (nHash<<5)+nHash+pch[iChar];
		}

		return( nHash );
	}

	static bool CompareElements(
		_In_ INARGTYPE bstr1,
		_In_ INARGTYPE bstr2) throw()
	{
		return( bstr1 == bstr2 );
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE bstr1,
		_In_ INARGTYPE bstr2) throw()
	{
		HRESULT hr = VarBstrCmp( bstr1, bstr2, LOCALE_SYSTEM_DEFAULT, 0 );
		switch( hr )
		{
		case static_cast<HRESULT>(VARCMP_LT):
			return( -1 );
			break;

		case static_cast<HRESULT>(VARCMP_GT):
			return( 1 );
			break;

		case static_cast<HRESULT>(VARCMP_EQ):
			return( 0 );
			break;

		default:
			ATLASSERT( false );
			return( 0 );
			break;
		}
	}
};

template< typename I, const IID* piid = &__uuidof( I ) >
class CComQIPtrElementTraits :
	public CDefaultElementTraits< ATL::CComQIPtr< I, piid > >
{
public:
	typedef I* INARGTYPE;
};

template< typename T >
class CAutoPtrElementTraits :
	public CDefaultElementTraits< ATL::CAutoPtr< T > >
{
public:
	typedef ATL::CAutoPtr< T >& INARGTYPE;
	typedef T*& OUTARGTYPE;

    // Specialise copy elements to allow non-const since we transfer ownership on assignment
    static void CopyElements(
		_Out_cap_(nElements) ::ATL::CAutoPtr< T >* pDest,
		_In_count_(nElements) ::ATL::CAutoPtr< T >* pSrc,
		_In_ size_t nElements)
	{
		for( size_t iElement = 0; iElement < nElements; iElement++ )
		{
			pDest[iElement] = pSrc[iElement];
		}
	}
};

template< typename T >
class CAutoVectorPtrElementTraits :
	public CDefaultElementTraits< ATL::CAutoVectorPtr< T > >
{
public:
	typedef ATL::CAutoVectorPtr< T >& INARGTYPE;
	typedef T*& OUTARGTYPE;

    // Specialise copy elements to allow non-const since we transfer ownership on assignment
    static void CopyElements(
		_Out_cap_(nElements) ::ATL::CAutoVectorPtr< T >* pDest,
		_In_count_(nElements) ::ATL::CAutoVectorPtr< T >* pSrc,
		_In_ size_t nElements)
	{
		for( size_t iElement = 0; iElement < nElements; iElement++ )
		{
			pDest[iElement] = pSrc[iElement];
		}
	}
};

template< typename T, class Allocator = ATL::CCRTAllocator >
class CHeapPtrElementTraits :
	public CDefaultElementTraits< ATL::CHeapPtr< T, Allocator > >
{
public:
	typedef ATL::CHeapPtr< T, Allocator >& INARGTYPE;
	typedef T*& OUTARGTYPE;
};

template < typename T >
class CDefaultCharTraits
{
};

template <>
class CDefaultCharTraits<char>
{
public:
	static char CharToUpper(_In_ char x)
	{
		return (char)toupper(x);
	}

	static char CharToLower(_In_ char x)
	{
		return (char)tolower(x);
	}
};

template <>
class CDefaultCharTraits<wchar_t>
{
public:
	static wchar_t CharToUpper(_In_ wchar_t x)
	{
		return (wchar_t)towupper(x);
	}

	static wchar_t CharToLower(_In_ wchar_t x)
	{
		return (wchar_t)towlower(x);
	}
};

template< typename T, class CharTraits = CDefaultCharTraits<T::XCHAR> >
class CStringElementTraitsI :
	public CElementTraitsBase< T >
{
public:
	typedef typename T::PCXSTR INARGTYPE;
	typedef T& OUTARGTYPE;

	static ULONG Hash(_In_ INARGTYPE str)
	{
		ULONG nHash = 0;

		const T::XCHAR* pch = str;

		ATLENSURE( pch != NULL );

		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+CharTraits::CharToUpper(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool CompareElements(
		_In_ INARGTYPE str1,
		_In_ INARGTYPE str2) throw()
	{
		return( T::StrTraits::StringCompareIgnore( str1, str2 ) == 0 );
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE str1,
		_In_ INARGTYPE str2) throw()
	{
		return( T::StrTraits::StringCompareIgnore( str1, str2 ) );
	}
};

template< typename T >
class CStringRefElementTraits :
	public CElementTraitsBase< T >
{
public:
	static ULONG Hash(_In_ INARGTYPE str)
	{
		ULONG nHash = 0;

		const T::XCHAR* pch = str;

		ATLENSURE( pch != NULL );

		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool CompareElements(
		_In_ INARGTYPE element1,
		_In_ INARGTYPE element2) throw()
	{
		return( element1 == element2 );
	}

	static int CompareElementsOrdered(
		_In_ INARGTYPE str1,
		_In_ INARGTYPE str2) throw()
	{
		return( str1.Compare( str2 ) );
	}
};

template< typename T >
class CPrimitiveElementTraits :
	public CDefaultElementTraits< T >
{
public:
	typedef T INARGTYPE;
	typedef T& OUTARGTYPE;
};

#define _DECLARE_PRIMITIVE_TRAITS( T ) \
	template<> \
	class CElementTraits< T > : \
		public CPrimitiveElementTraits< T > \
	{ \
	};

_DECLARE_PRIMITIVE_TRAITS( unsigned char )
_DECLARE_PRIMITIVE_TRAITS( unsigned short )
_DECLARE_PRIMITIVE_TRAITS( unsigned int )
_DECLARE_PRIMITIVE_TRAITS( unsigned long )
_DECLARE_PRIMITIVE_TRAITS( unsigned __int64 )
_DECLARE_PRIMITIVE_TRAITS( signed char )
_DECLARE_PRIMITIVE_TRAITS( char )
_DECLARE_PRIMITIVE_TRAITS( short )
_DECLARE_PRIMITIVE_TRAITS( int )
_DECLARE_PRIMITIVE_TRAITS( long )
_DECLARE_PRIMITIVE_TRAITS( __int64 )
_DECLARE_PRIMITIVE_TRAITS( float )
_DECLARE_PRIMITIVE_TRAITS( double )
_DECLARE_PRIMITIVE_TRAITS( bool )
#ifdef _NATIVE_WCHAR_T_DEFINED
_DECLARE_PRIMITIVE_TRAITS( wchar_t )
#endif
_DECLARE_PRIMITIVE_TRAITS( void* )

template< typename E, class ETraits = CElementTraits< E > >
class CAtlArray
{
public:
	typedef typename ETraits::INARGTYPE INARGTYPE;
	typedef typename ETraits::OUTARGTYPE OUTARGTYPE;

public:
	CAtlArray() throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();
	bool SetCount(_In_ size_t nNewSize, _In_ int nGrowBy = -1);

	void FreeExtra() throw();
	void RemoveAll() throw();

	const E& GetAt(_In_ size_t iElement) const;
	void SetAt(
		_In_ size_t iElement,
		/* _In_ */ INARGTYPE element);
	E& GetAt(_In_ size_t iElement);

	const E* GetData() const throw();
	E* GetData() throw();

	void SetAtGrow(
		_In_ size_t iElement,
		/* _In_ */ INARGTYPE element);
	// Add an empty element to the end of the array
	size_t Add();
	// Add an element to the end of the array
	size_t Add(/* _In_ */ INARGTYPE element);
	size_t Append(_In_ const CAtlArray< E, ETraits >& aSrc);
	void Copy(_In_ const CAtlArray< E, ETraits >& aSrc);

	const E& operator[](_In_ size_t iElement) const;
	E& operator[](_In_ size_t iElement);

	void InsertAt(
		_In_ size_t iElement,
		/* _In_ */ INARGTYPE element,
		_In_ size_t nCount = 1);
	void InsertArrayAt(
		_In_ size_t iStart,
		_In_ const CAtlArray< E, ETraits >* paNew);
	void RemoveAt(
		_In_ size_t iElement,
		_In_ size_t nCount = 1);

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

private:
	bool GrowBuffer(_In_ size_t nNewSize);

// Implementation
private:
	E* m_pData;
	size_t m_nSize;
	size_t m_nMaxSize;
	int m_nGrowBy;

private:
	static void CallConstructors(
		_Inout_cap_(nElements) E* pElements,
		_In_ size_t nElements);
	static void CallDestructors(
		_Inout_ _Prepost_bytecount_x_(sizeof(E) * nElements) E* pElements,
		_In_ size_t nElements) throw();

public:
	~CAtlArray() throw();

private:
	// Private to prevent use
	CAtlArray(_In_ const CAtlArray&) throw();
	CAtlArray& operator=(_In_ const CAtlArray&) throw();
};

template< class I, const IID* piid = &__uuidof( I ) >
class CInterfaceArray :
	public CAtlArray< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >
{
public:
	CInterfaceArray() throw()
	{
	}

private:
	// Private to prevent use
	CInterfaceArray(_In_ const CInterfaceArray&) throw();
	CInterfaceArray& operator=(_In_ const CInterfaceArray&) throw();
};

template< typename E >
class CAutoPtrArray :
	public CAtlArray< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >
{
public:
	CAutoPtrArray() throw()
	{
	}

private:
	// Private to prevent use
	CAutoPtrArray(_In_ const CAutoPtrArray&) throw();
	CAutoPtrArray& operator=(_In_ const CAutoPtrArray&) throw();
};

template< typename E, class Allocator = ATL::CCRTAllocator >
class CHeapPtrArray :
	public CAtlArray< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >
{
public:
	CHeapPtrArray() throw()
	{
	}

private:
	// Private to prevent use
	CHeapPtrArray(_In_ const CHeapPtrArray&) throw();
	CHeapPtrArray& operator=(_In_ const CHeapPtrArray&) throw();
};

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::GetCount() const throw()
{
	return( m_nSize );
}

template< typename E, class ETraits >
inline bool CAtlArray< E, ETraits >::IsEmpty() const throw()
{
	return( m_nSize == 0 );
}

template< typename E, class ETraits >
inline void CAtlArray< E, ETraits >::RemoveAll() throw()
{
	SetCount( 0, -1 );
}

template< typename E, class ETraits >
inline const E& CAtlArray< E, ETraits >::GetAt(_In_ size_t iElement) const
{
	ATLASSERT( iElement < m_nSize );
	if(iElement >= m_nSize)
		AtlThrow(E_INVALIDARG);

	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline void CAtlArray< E, ETraits >::SetAt(
	_In_ size_t iElement,
	/* _In_ */ INARGTYPE element)
{
	ATLASSERT( iElement < m_nSize );
	if(iElement >= m_nSize)
		AtlThrow(E_INVALIDARG);

	m_pData[iElement] = element;
}

template< typename E, class ETraits >
inline E& CAtlArray< E, ETraits >::GetAt(_In_ size_t iElement)
{
	ATLASSERT( iElement < m_nSize );
	if(iElement >= m_nSize)
		AtlThrow(E_INVALIDARG);

	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline const E* CAtlArray< E, ETraits >::GetData() const throw()
{
	return( m_pData );
}

template< typename E, class ETraits >
inline E* CAtlArray< E, ETraits >::GetData() throw()
{
	return( m_pData );
}

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::Add()
{
	size_t iElement;

	iElement = m_nSize;
	bool bSuccess = SetCount(AtlAddThrow<size_t>(m_nSize, 1));
	if( !bSuccess )
	{
		AtlThrow( E_OUTOFMEMORY );
	}

	return( iElement );
}

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::Add(/* _In_ */ INARGTYPE element)
{
	size_t iElement;

	iElement = m_nSize;
	if( iElement >= m_nMaxSize )
	{
		bool bSuccess = GrowBuffer( iElement+1 );
		if( !bSuccess )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
	}
	::new( m_pData+iElement ) E( element );
	m_nSize++;

	return( iElement );
}

#pragma pop_macro("new")

template< typename E, class ETraits >
inline const E& CAtlArray< E, ETraits >::operator[](_In_ size_t iElement) const
{
	ATLASSERT( iElement < m_nSize );
	if(iElement >= m_nSize)
		AtlThrow(E_INVALIDARG);

	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline E& CAtlArray< E, ETraits >::operator[](_In_ size_t iElement)
{
	ATLASSERT( iElement < m_nSize );
	if(iElement >= m_nSize)
		AtlThrow(E_INVALIDARG);

	return( m_pData[iElement] );
}

template< typename E, class ETraits >
CAtlArray< E, ETraits >::CAtlArray()  throw():
	m_pData( NULL ),
	m_nSize( 0 ),
	m_nMaxSize( 0 ),
	m_nGrowBy( 0 )
{
}

template< typename E, class ETraits >
CAtlArray< E, ETraits >::~CAtlArray() throw()
{
	if( m_pData != NULL )
	{
		CallDestructors( m_pData, m_nSize );
		free( m_pData );
	}
}

template< typename E, class ETraits >
bool CAtlArray< E, ETraits >::GrowBuffer(_In_ size_t nNewSize)
{
	if( nNewSize > m_nMaxSize )
	{
		if( m_pData == NULL )
		{
			size_t nAllocSize =  size_t( m_nGrowBy ) > nNewSize ? size_t( m_nGrowBy ) : nNewSize ;
			m_pData = static_cast< E* >( calloc( nAllocSize,sizeof( E ) ) );
			if( m_pData == NULL )
			{
				return( false );
			}
			m_nMaxSize = nAllocSize;
		}
		else
		{
			// otherwise, grow array
			size_t nGrowBy = m_nGrowBy;
			if( nGrowBy == 0 )
			{
				// heuristically determine growth when nGrowBy == 0
				//  (this avoids heap fragmentation in many situations)
				nGrowBy = m_nSize/8;
				nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
			}
			size_t nNewMax;
			if( nNewSize < (m_nMaxSize+nGrowBy) )
				nNewMax = m_nMaxSize+nGrowBy;  // granularity
			else
				nNewMax = nNewSize;  // no slush

			ATLASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
			ATLASSERT( nNewMax <= SIZE_T_MAX/sizeof( E ) ); // no overflow
#endif
			E* pNewData = static_cast< E* >( calloc( nNewMax,sizeof( E ) ) );
			if( pNewData == NULL )
			{
				return false;
			}

			// copy new data from old
			ETraits::RelocateElements( pNewData, m_pData, m_nSize );

			// get rid of old stuff (note: no destructors called)
			free( m_pData );
			m_pData = pNewData;
			m_nMaxSize = nNewMax;
		}
	}

	return true;
}

template< typename E, class ETraits >
bool CAtlArray< E, ETraits >::SetCount(
	_In_ size_t nNewSize,
	_In_ int nGrowBy)
{
	ATLASSERT_VALID(this);

	if( nGrowBy != -1 )
	{
		m_nGrowBy = nGrowBy;  // set new size
	}

	if( nNewSize == 0 )
	{
		// shrink to nothing
		if( m_pData != NULL )
		{
			CallDestructors( m_pData, m_nSize );
			free( m_pData );
			m_pData = NULL;
		}
		m_nSize = 0;
		m_nMaxSize = 0;
	}
	else if( nNewSize <= m_nMaxSize )
	{
		// it fits
		if( nNewSize > m_nSize )
		{
			// initialize the new elements
			CallConstructors( m_pData+m_nSize, nNewSize-m_nSize );
		}
		else if( m_nSize > nNewSize )
		{
			// destroy the old elements
			CallDestructors( m_pData+nNewSize, m_nSize-nNewSize );
		}
		m_nSize = nNewSize;
	}
	else
	{
		bool bSuccess;

		bSuccess = GrowBuffer( nNewSize );
		if( !bSuccess )
		{
			return( false );
		}

		// construct new elements
		ATLASSERT( nNewSize > m_nSize );
		CallConstructors( m_pData+m_nSize, nNewSize-m_nSize );

		m_nSize = nNewSize;
	}

	return true;
}

template< typename E, class ETraits >
size_t CAtlArray< E, ETraits >::Append(_In_ const CAtlArray< E, ETraits >& aSrc)
{
	ATLASSERT_VALID(this);
	ATLASSERT( this != &aSrc );   // cannot append to itself

	size_t nOldSize = m_nSize;
	bool bSuccess = SetCount(AtlAddThrow<size_t>(m_nSize, aSrc.m_nSize));
	if( !bSuccess )
	{
		AtlThrow( E_OUTOFMEMORY );
	}

	ETraits::CopyElements( m_pData+nOldSize, aSrc.m_pData, aSrc.m_nSize );

	return( nOldSize );
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::Copy(_In_ const CAtlArray< E, ETraits >& aSrc)
{
	ATLASSERT_VALID(this);
	ATLASSERT( this != &aSrc );   // cannot append to itself

	bool bSuccess=SetCount( aSrc.m_nSize );
	if( !bSuccess )
	{
		AtlThrow( E_OUTOFMEMORY );
	}

	ETraits::CopyElements( m_pData, aSrc.m_pData, aSrc.m_nSize );
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::FreeExtra() throw()
{
	ATLASSERT_VALID(this);

	if( m_nSize != m_nMaxSize )
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ATLASSUME( m_nSize <= (SIZE_T_MAX/sizeof( E )) ); // no overflow
#endif
		E* pNewData = NULL;
		if( m_nSize != 0 )
		{
			pNewData = (E*)calloc( m_nSize,sizeof( E ) );
			if( pNewData == NULL )
			{
				return;
			}

			// copy new data from old
			ETraits::RelocateElements( pNewData, m_pData, m_nSize );
		}

		// get rid of old stuff (note: no destructors called)
		free( m_pData );
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::SetAtGrow(
	_In_ size_t iElement,
	/* _In_ */ INARGTYPE element)
{
	ATLASSERT_VALID(this);
	size_t nOldSize;

	nOldSize = m_nSize;
	if( iElement >= m_nSize )
	{
		bool bSuccess = SetCount(AtlAddThrow<size_t>(iElement, 1), -1 );
		if( !bSuccess )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
	}

	_ATLTRY
	{
		m_pData[iElement] = element;
	}
	_ATLCATCHALL()
	{
		if( m_nSize != nOldSize )
		{
			SetCount( nOldSize, -1 );
		}
		_ATLRETHROW;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::InsertAt(
	_In_ size_t iElement,
	/* _In_ */ INARGTYPE element,
	_In_ size_t nElements /*=1*/)
{
	ATLASSERT_VALID(this);
	ATLASSERT( nElements > 0 );     // zero size not allowed

	if( iElement >= m_nSize )
	{
		// adding after the end of the array
		bool bSuccess = SetCount(AtlAddThrow<size_t>(iElement, nElements), -1 );   // grow so nIndex is valid
		if( !bSuccess )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
	}
	else
	{
		// inserting in the middle of the array
		size_t nOldSize = m_nSize;
		bool bSuccess = SetCount(AtlAddThrow<size_t>(m_nSize, nElements), -1 );  // grow it to new size
		if( !bSuccess )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		// destroy intial data before copying over it
		CallDestructors( m_pData+nOldSize, nElements );
		// shift old data up to fill gap
		ETraits::RelocateElements( m_pData+(iElement+nElements), m_pData+iElement,
			nOldSize-iElement );

		_ATLTRY
		{
			// re-init slots we copied from
			CallConstructors( m_pData+iElement, nElements );
		}
		_ATLCATCHALL()
		{
			ETraits::RelocateElements( m_pData+iElement, m_pData+(iElement+nElements),
				nOldSize-iElement );
			SetCount( nOldSize, -1 );
			_ATLRETHROW;
		}
	}

	// insert new value in the gap
	ATLASSERT( (iElement+nElements) <= m_nSize );
	for( size_t iNewElement = iElement; iNewElement < (iElement+nElements); iNewElement++ )
	{
		m_pData[iNewElement] = element;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::RemoveAt(
	_In_ size_t iElement,
	_In_ size_t nElements)
{
	ATLASSERT_VALID(this);
	ATLASSERT( (iElement+nElements) <= m_nSize );

	size_t newCount = iElement+nElements;
	if ((newCount < iElement) || (newCount < nElements) || (newCount > m_nSize))
		AtlThrow(E_INVALIDARG);

	// just remove a range
	size_t nMoveCount = m_nSize-(newCount);
	CallDestructors( m_pData+iElement, nElements );
	if( nMoveCount > 0 )
	{
		ETraits::RelocateElements( m_pData+iElement, m_pData+(newCount),
			nMoveCount );
	}
	m_nSize -= nElements;
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::InsertArrayAt(
	_In_ size_t iStartElement,
	_In_ const CAtlArray< E, ETraits >* paNew)
{
	ATLASSERT_VALID( this );
	ATLENSURE( paNew != NULL );
	ATLASSERT_VALID( paNew );

	if( paNew->GetCount() > 0 )
	{
		InsertAt( iStartElement, paNew->GetAt( 0 ), paNew->GetCount() );
		for( size_t iElement = 0; iElement < paNew->GetCount(); iElement++ )
		{
			SetAt( iStartElement+iElement, paNew->GetAt( iElement ) );
		}
	}
}

#ifdef _DEBUG
template< typename E, class ETraits >
void CAtlArray< E, ETraits >::AssertValid() const
{
	if( m_pData == NULL )
	{
		ATLASSUME( m_nSize == 0 );
		ATLASSUME( m_nMaxSize == 0 );
	}
	else
	{
		ATLASSUME( m_nSize <= m_nMaxSize );
		ATLASSERT( AtlIsValidAddress( m_pData, m_nMaxSize * sizeof( E ) ) );
	}
}
#endif

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::CallConstructors(
	_Inout_cap_(nElements) E* pElements,
	_In_ size_t nElements)
{
	size_t iElement = 0;

	_ATLTRY
	{
		for( iElement = 0; iElement < nElements; iElement++ )
		{
			::new( pElements+iElement ) E;
		}
	}
	_ATLCATCHALL()
	{
		while( iElement > 0 )
		{
			iElement--;
			pElements[iElement].~E();
		}

		_ATLRETHROW;
	}
}

#pragma pop_macro("new")

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::CallDestructors(
	_Inout_ _Prepost_bytecount_x_(sizeof(E) * nElements) E* pElements,
	_In_ size_t nElements) throw()
{
	(pElements);
	
	for( size_t iElement = 0; iElement < nElements; iElement++ )
	{
		pElements[iElement].~E();
	}
}


template< typename E, class ETraits = CElementTraits< E > >
class CAtlList
{
public:
	typedef typename ETraits::INARGTYPE INARGTYPE;

private:
	class CNode :
		public __POSITION
	{
	public:
		CNode()
		{
		}
		CNode(/* _In_ */ INARGTYPE element) :
			m_element( element )
		{
		}
		~CNode() throw()
		{
		}

	public:
		CNode* m_pNext;
		CNode* m_pPrev;
		E m_element;

	private:
		CNode(_In_ const CNode&) throw();
	};

public:
	CAtlList(_In_ UINT nBlockSize = 10) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	E& GetHead();
	const E& GetHead() const;
	E& GetTail();
	const E& GetTail() const;

	E RemoveHead();
	E RemoveTail();
	void RemoveHeadNoReturn() throw();
	void RemoveTailNoReturn() throw();

	POSITION AddHead();
	POSITION AddHead(/* _In_ */ INARGTYPE element);
	void AddHeadList(_In_ const CAtlList< E, ETraits >* plNew);
	POSITION AddTail();
	POSITION AddTail(/* _In_ */ INARGTYPE element);
	void AddTailList(_In_ const CAtlList< E, ETraits >* plNew);

	void RemoveAll() throw();

	POSITION GetHeadPosition() const throw();
	POSITION GetTailPosition() const throw();
	E& GetNext(_Inout_ POSITION& pos);
	const E& GetNext(_Inout_ POSITION& pos) const;
	E& GetPrev(_Inout_ POSITION& pos);
	const E& GetPrev(_Inout_ POSITION& pos) const throw();

	E& GetAt(_In_ POSITION pos);
	const E& GetAt(_In_ POSITION pos) const;
	void SetAt(
		_In_ POSITION pos,
		/* _In_ */ INARGTYPE element);
	void RemoveAt(_In_ POSITION pos) throw();

	POSITION InsertBefore(
		_In_ POSITION pos,
		/* _In_ */ INARGTYPE element);
	POSITION InsertAfter(
		_In_ POSITION pos,
		/* _In_ */ INARGTYPE element);

	POSITION Find(
		/* _In_ */ INARGTYPE element,
		_In_opt_ POSITION posStartAfter = NULL) const throw();
	POSITION FindIndex(_In_ size_t iElement) const throw();

	void MoveToHead(_In_ POSITION pos);
	void MoveToTail(_In_ POSITION pos);
	void SwapElements(
		_In_ POSITION pos1,
		_In_ POSITION pos2) throw();

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

// Implementation
private:
	CNode* m_pHead;
	CNode* m_pTail;
	size_t m_nElements;
	CAtlPlex* m_pBlocks;
	CNode* m_pFree;
	UINT m_nBlockSize;

private:
	void GetFreeNode();
	CNode* NewNode(
		_In_opt_ CNode* pPrev,
		_In_opt_ CNode* pNext);
	CNode* NewNode(
		/* _In_ */ INARGTYPE element,
		_In_opt_ CNode* pPrev,
		_In_opt_ CNode* pNext);
	void FreeNode(_Inout_ CNode* pNode) throw();

public:
	~CAtlList() throw();

private:
	// Private to prevent use
	CAtlList(_In_ const CAtlList&) throw();
	CAtlList& operator=(_In_ const CAtlList&) throw();
};

template< class I, const IID* piid = &__uuidof( I ) >
class CInterfaceList :
	public CAtlList< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >
{
public:
	CInterfaceList(_In_ UINT nBlockSize = 10) throw() :
		CAtlList< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CInterfaceList(_In_ const CInterfaceList&) throw();
	CInterfaceList& operator=(_In_ const CInterfaceList&) throw();
};

template< typename E >
class CAutoPtrList :
	public CAtlList< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >
{
public:
	CAutoPtrList(_In_ UINT nBlockSize = 10) throw() :
		CAtlList< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CAutoPtrList(_In_ const CAutoPtrList&) throw();
	CAutoPtrList& operator=(_In_ const CAutoPtrList&) throw();
};

template< typename E, class Allocator = ATL::CCRTAllocator >
class CHeapPtrList :
	public CAtlList< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >
{
public:
	CHeapPtrList(_In_ UINT nBlockSize = 10) throw() :
		CAtlList< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CHeapPtrList(_In_ const CHeapPtrList&) throw();
	CHeapPtrList& operator=(_In_ const CHeapPtrList&) throw();
};

template< typename E, class ETraits >
inline size_t CAtlList< E, ETraits >::GetCount() const throw()
{
	return( m_nElements );
}

template< typename E, class ETraits >
inline bool CAtlList< E, ETraits >::IsEmpty() const throw()
{
	return( m_nElements == 0 );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetHead()
{
	ATLENSURE( m_pHead != NULL );
	return( m_pHead->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetHead() const
{
	ATLENSURE( m_pHead != NULL );
	return( m_pHead->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetTail()
{
	ATLENSURE( m_pTail != NULL );
	return( m_pTail->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetTail() const
{
	ATLENSURE( m_pTail != NULL );
	return( m_pTail->m_element );
}

template< typename E, class ETraits >
inline POSITION CAtlList< E, ETraits >::GetHeadPosition() const throw()
{
	return( POSITION( m_pHead ) );
}

template< typename E, class ETraits >
inline POSITION CAtlList< E, ETraits >::GetTailPosition() const throw()
{
	return( POSITION( m_pTail ) );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetNext(_Inout_ POSITION& pos)
{
	CNode* pNode;

	ATLENSURE( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pNext );

	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetNext(_Inout_ POSITION& pos) const
{
	CNode* pNode;

	ATLENSURE( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pNext );

	return( pNode->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetPrev(_Inout_ POSITION& pos)
{
	CNode* pNode;

	ATLENSURE( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pPrev );

	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetPrev(_Inout_ POSITION& pos) const throw()
{
	CNode* pNode;

	ATLASSUME( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pPrev );

	return( pNode->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetAt(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );
	CNode* pNode = (CNode*)pos;
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetAt(_In_ POSITION pos) const
{
	ATLENSURE( pos != NULL );
	CNode* pNode = (CNode*)pos;
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline void CAtlList< E, ETraits >::SetAt(
	_In_ POSITION pos,
	/* _In_ */ INARGTYPE element)
{
	ATLENSURE( pos != NULL );
	CNode* pNode = (CNode*)pos;
	pNode->m_element = element;
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::CAtlList(_In_ UINT nBlockSize) throw() :
	m_nElements( 0 ),
	m_pHead( NULL ),
	m_pTail( NULL ),
	m_nBlockSize( nBlockSize ),
	m_pBlocks( NULL ),
	m_pFree( NULL )
{
	ATLASSERT( nBlockSize > 0 );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveAll()
{
	while( m_nElements > 0 )
	{
		CNode* pKill = m_pHead;
		ATLENSURE( pKill != NULL );

		m_pHead = m_pHead->m_pNext;
		FreeNode( pKill );
	}

	ATLASSUME( m_nElements == 0 );
	m_pHead = NULL;
	m_pTail = NULL;
	m_pFree = NULL;

	if( m_pBlocks != NULL )
	{
		m_pBlocks->FreeDataChain();
		m_pBlocks = NULL;
	}
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::~CAtlList() throw()
{
	RemoveAll();
	ATLASSUME( m_nElements == 0 );
}

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
void CAtlList< E, ETraits >::GetFreeNode()
{
	if( m_pFree == NULL )
	{
		CAtlPlex* pPlex;
		CNode* pNode;

		pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		pNode = (CNode*)pPlex->data();
		pNode += m_nBlockSize-1;
		for( int iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pNext = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLASSUME( m_pFree != NULL );
}

template< typename E, class ETraits >
typename CAtlList< E, ETraits >::CNode* CAtlList< E, ETraits >::NewNode(
	_In_opt_ CNode* pPrev,
	_In_opt_ CNode* pNext )
{
	GetFreeNode();

	CNode* pNewNode = m_pFree;
	CNode* pNextFree = m_pFree->m_pNext;

	::new( pNewNode ) CNode;

	m_pFree = pNextFree;
	pNewNode->m_pPrev = pPrev;
	pNewNode->m_pNext = pNext;
	m_nElements++;
	ATLASSUME( m_nElements > 0 );

	return( pNewNode );
}

template< typename E, class ETraits >
typename CAtlList< E, ETraits >::CNode* CAtlList< E, ETraits >::NewNode(
	/* _In_ */ INARGTYPE element,
	_In_opt_ CNode* pPrev,
	_In_opt_ CNode* pNext)
{
	GetFreeNode();

	CNode* pNewNode = m_pFree;
	CNode* pNextFree = m_pFree->m_pNext;

	::new( pNewNode ) CNode( element );

	m_pFree = pNextFree;
	pNewNode->m_pPrev = pPrev;
	pNewNode->m_pNext = pNext;
	m_nElements++;
	ATLASSUME( m_nElements > 0 );

	return( pNewNode );
}

#pragma pop_macro("new")

template< typename E, class ETraits >
void CAtlList< E, ETraits >::FreeNode(_Inout_ CNode* pNode) throw()
{
	pNode->~CNode();
	pNode->m_pNext = m_pFree;
	m_pFree = pNode;
	ATLASSUME( m_nElements > 0 );
	m_nElements--;
	if( m_nElements == 0 )
	{
		RemoveAll();
	}
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddHead()
{
	CNode* pNode = NewNode( NULL, m_pHead );
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = pNode;
	}
	else
	{
		m_pTail = pNode;
	}
	m_pHead = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddHead(/* _In_ */ INARGTYPE element)
{
	CNode* pNode;

	pNode = NewNode( element, NULL, m_pHead );

	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = pNode;
	}
	else
	{
		m_pTail = pNode;
	}
	m_pHead = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddTail()
{
	CNode* pNode = NewNode( m_pTail, NULL );
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = pNode;
	}
	else
	{
		m_pHead = pNode;
	}
	m_pTail = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddTail(/* _In_ */ INARGTYPE element)
{
	CNode* pNode;

	pNode = NewNode( element, m_pTail, NULL );

	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = pNode;
	}
	else
	{
		m_pHead = pNode;
	}
	m_pTail = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::AddHeadList(_In_ const CAtlList< E, ETraits >* plNew)
{
	ATLENSURE( plNew != NULL );

	POSITION pos = plNew->GetTailPosition();
	while( pos != NULL )
	{
		INARGTYPE element = plNew->GetPrev( pos );
		AddHead( element );
	}
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::AddTailList(_In_ const CAtlList< E, ETraits >* plNew)
{
	ATLENSURE( plNew != NULL );

	POSITION pos = plNew->GetHeadPosition();
	while( pos != NULL )
	{
		INARGTYPE element = plNew->GetNext( pos );
		AddTail( element );
	}
}

template< typename E, class ETraits >
E CAtlList< E, ETraits >::RemoveHead()
{
	ATLENSURE( m_pHead != NULL );

	CNode* pNode = m_pHead;
	E element( pNode->m_element );

	m_pHead = pNode->m_pNext;
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = NULL;
	}
	else
	{
		m_pTail = NULL;
	}
	FreeNode( pNode );

	return( element );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveHeadNoReturn()
{
	ATLENSURE( m_pHead != NULL );

	CNode* pNode = m_pHead;

	m_pHead = pNode->m_pNext;
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = NULL;
	}
	else
	{
		m_pTail = NULL;
	}
	FreeNode( pNode );
}

template< typename E, class ETraits >
E CAtlList< E, ETraits >::RemoveTail()
{
	ATLENSURE( m_pTail != NULL );

	CNode* pNode = m_pTail;

	E element( pNode->m_element );

	m_pTail = pNode->m_pPrev;
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = NULL;
	}
	else
	{
		m_pHead = NULL;
	}
	FreeNode( pNode );

	return( element );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveTailNoReturn()
{
	ATLENSURE( m_pTail != NULL );

	CNode* pNode = m_pTail;

	m_pTail = pNode->m_pPrev;
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = NULL;
	}
	else
	{
		m_pHead = NULL;
	}
	FreeNode( pNode );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::InsertBefore(
	_In_ POSITION pos,
	/* _In_ */ INARGTYPE element)
{
	ATLASSERT_VALID(this);

	if( pos == NULL )
		return AddHead( element ); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*)pos;
	CNode* pNewNode = NewNode( element, pOldNode->m_pPrev, pOldNode );

	if( pOldNode->m_pPrev != NULL )
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pPrev, sizeof(CNode)));
		pOldNode->m_pPrev->m_pNext = pNewNode;
	}
	else
	{
		ATLASSERT( pOldNode == m_pHead );
		m_pHead = pNewNode;
	}
	pOldNode->m_pPrev = pNewNode;

	return( POSITION( pNewNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::InsertAfter(
	_In_ POSITION pos,
	/* _In_ */ INARGTYPE element)
{
	ATLASSERT_VALID(this);

	if( pos == NULL )
		return AddTail( element ); // insert after nothing -> tail of the list

	// Insert it after position
	CNode* pOldNode = (CNode*)pos;
	CNode* pNewNode = NewNode( element, pOldNode, pOldNode->m_pNext );

	if( pOldNode->m_pNext != NULL )
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pNext, sizeof(CNode)));
		pOldNode->m_pNext->m_pPrev = pNewNode;
	}
	else
	{
		ATLASSERT( pOldNode == m_pTail );
		m_pTail = pNewNode;
	}
	pOldNode->m_pNext = pNewNode;

	return( POSITION( pNewNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveAt(_In_ POSITION pos)
{
	ATLASSERT_VALID(this);
	ATLENSURE( pos != NULL );

	CNode* pOldNode = (CNode*)pos;

	// remove pOldNode from list
	if( pOldNode == m_pHead )
	{
		m_pHead = pOldNode->m_pNext;
	}
	else
	{
		ATLASSERT( AtlIsValidAddress( pOldNode->m_pPrev, sizeof(CNode) ));
		pOldNode->m_pPrev->m_pNext = pOldNode->m_pNext;
	}
	if( pOldNode == m_pTail )
	{
		m_pTail = pOldNode->m_pPrev;
	}
	else
	{
		ATLASSERT( AtlIsValidAddress( pOldNode->m_pNext, sizeof(CNode) ));
		pOldNode->m_pNext->m_pPrev = pOldNode->m_pPrev;
	}
	FreeNode( pOldNode );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::FindIndex(_In_ size_t iElement) const throw()
{
	ATLASSERT_VALID(this);

	if( iElement >= m_nElements )
		return NULL;  // went too far

	if(m_pHead == NULL)
		return NULL;

	CNode* pNode = m_pHead;
	for( size_t iSearch = 0; iSearch < iElement; iSearch++ )
	{
		pNode = pNode->m_pNext;
	}

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::MoveToHead(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );

	if( pNode == m_pHead )
	{
		// Already at the head
		return;
	}

	if( pNode->m_pNext == NULL )
	{
		ATLASSERT( pNode == m_pTail );
		m_pTail = pNode->m_pPrev;
	}
	else
	{
		pNode->m_pNext->m_pPrev = pNode->m_pPrev;
	}

	ATLASSUME( pNode->m_pPrev != NULL );  // This node can't be the head, since we already checked that case
	pNode->m_pPrev->m_pNext = pNode->m_pNext;

	m_pHead->m_pPrev = pNode;
	pNode->m_pNext = m_pHead;
	pNode->m_pPrev = NULL;
	m_pHead = pNode;
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::MoveToTail(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );
	CNode* pNode = static_cast< CNode* >( pos );

	if( pNode == m_pTail )
	{
		// Already at the tail
		return;
	}

	if( pNode->m_pPrev == NULL )
	{
		ATLENSURE( pNode == m_pHead );
		m_pHead = pNode->m_pNext;
	}
	else
	{
		pNode->m_pPrev->m_pNext = pNode->m_pNext;
	}

	pNode->m_pNext->m_pPrev = pNode->m_pPrev;

	m_pTail->m_pNext = pNode;
	pNode->m_pPrev = m_pTail;
	pNode->m_pNext = NULL;
	m_pTail = pNode;
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::SwapElements(
	_In_ POSITION pos1,
	_In_ POSITION pos2) throw()
{
	ATLASSUME( pos1 != NULL );
	ATLASSUME( pos2 != NULL );

	if( pos1 == pos2 )
	{
		// Nothing to do
		return;
	}

	CNode* pNode1 = static_cast< CNode* >( pos1 );
	CNode* pNode2 = static_cast< CNode* >( pos2 );
	if( pNode2->m_pNext == pNode1 )
	{
		// Swap pNode2 and pNode1 so that the next case works
		CNode* pNodeTemp = pNode1;
		pNode1 = pNode2;
		pNode2 = pNodeTemp;
	}
	if( pNode1->m_pNext == pNode2 )
	{
		// Node1 and Node2 are adjacent
		pNode2->m_pPrev = pNode1->m_pPrev;
		if( pNode1->m_pPrev != NULL )
		{
			pNode1->m_pPrev->m_pNext = pNode2;
		}
		else
		{
			ATLASSUME( m_pHead == pNode1 );
			m_pHead = pNode2;
		}
		pNode1->m_pNext = pNode2->m_pNext;
		if( pNode2->m_pNext != NULL )
		{
			pNode2->m_pNext->m_pPrev = pNode1;
		}
		else
		{
			ATLASSUME( m_pTail == pNode2 );
			m_pTail = pNode1;
		}
		pNode2->m_pNext = pNode1;
		pNode1->m_pPrev = pNode2;
	}
	else
	{
		// The two nodes are not adjacent
		CNode* pNodeTemp;

		pNodeTemp = pNode1->m_pPrev;
		pNode1->m_pPrev = pNode2->m_pPrev;
		pNode2->m_pPrev = pNodeTemp;

		pNodeTemp = pNode1->m_pNext;
		pNode1->m_pNext = pNode2->m_pNext;
		pNode2->m_pNext = pNodeTemp;

		if( pNode1->m_pNext != NULL )
		{
			pNode1->m_pNext->m_pPrev = pNode1;
		}
		else
		{
			ATLASSUME( m_pTail == pNode2 );
			m_pTail = pNode1;
		}
		if( pNode1->m_pPrev != NULL )
		{
			pNode1->m_pPrev->m_pNext = pNode1;
		}
		else
		{
			ATLASSUME( m_pHead == pNode2 );
			m_pHead = pNode1;
		}
		if( pNode2->m_pNext != NULL )
		{
			pNode2->m_pNext->m_pPrev = pNode2;
		}
		else
		{
			ATLASSUME( m_pTail == pNode1 );
			m_pTail = pNode2;
		}
		if( pNode2->m_pPrev != NULL )
		{
			pNode2->m_pPrev->m_pNext = pNode2;
		}
		else
		{
			ATLASSUME( m_pHead == pNode1 );
			m_pHead = pNode2;
		}
	}
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::Find(
	/* _In_ */ INARGTYPE element,
	_In_opt_ POSITION posStartAfter) const throw()
{
	ATLASSERT_VALID(this);

	CNode* pNode = (CNode*)posStartAfter;
	if( pNode == NULL )
	{
		pNode = m_pHead;  // start at head
	}
	else
	{
		pNode = SAL_Assume_bytecap_for_opt_(pNode, sizeof(CNode));
		ATLASSERT(AtlIsValidAddress(pNode, sizeof(CNode)));
		ATLASSUME(pNode != NULL);

		pNode = pNode->m_pNext;  // start after the one specified
	}

	for( ; pNode != NULL; pNode = pNode->m_pNext )
	{
		if( ETraits::CompareElements( pNode->m_element, element ) )
			return( POSITION( pNode ) );
	}

	return( NULL );
}

#ifdef _DEBUG
template< typename E, class ETraits >
void CAtlList< E, ETraits >::AssertValid() const
{
	if( IsEmpty() )
	{
		// empty list
		ATLASSUME(m_pHead == NULL);
		ATLASSUME(m_pTail == NULL);
	}
	else
	{
		// non-empty list
		ATLASSERT(AtlIsValidAddress(m_pHead, sizeof(CNode)));
		ATLASSERT(AtlIsValidAddress(m_pTail, sizeof(CNode)));
	}
}
#endif

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CAtlMap
{
public:
	typedef typename KTraits::INARGTYPE KINARGTYPE;
	typedef typename KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef typename VTraits::INARGTYPE VINARGTYPE;
	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;

	class CPair :
		public __POSITION
	{
	protected:
		CPair(/* _In_ */ KINARGTYPE key) :
			m_key( key )
		{
		}

	public:
		const K m_key;
		V m_value;
	};

private:
	class CNode :
		public CPair
	{
	public:
		CNode(
				/* _In_ */ KINARGTYPE key,
				_In_ UINT nHash) :
			CPair( key ),
			m_nHash( nHash )
		{
		}

	public:
		UINT GetHash() const throw()
		{
			return( m_nHash );
		}

	public:
		CNode* m_pNext;
		UINT m_nHash;
	};

public:
	CAtlMap(
		_In_ UINT nBins = 17,
		_In_ float fOptimalLoad = 0.75f,
		_In_ float fLoThreshold = 0.25f,
		_In_ float fHiThreshold = 2.25f,
		_In_ UINT nBlockSize = 10) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	bool Lookup(
		/* _In_ */ KINARGTYPE key,
		_Out_ VOUTARGTYPE value) const;
	const CPair* Lookup(/* _In_ */ KINARGTYPE key) const throw();
	CPair* Lookup(/* _In_ */ KINARGTYPE key) throw();
	V& operator[](/* _In_ */ KINARGTYPE key) throw(...);

	POSITION SetAt(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value);
	void SetValueAt(
		_In_ POSITION pos,
		/* _In_ */ VINARGTYPE value);

	bool RemoveKey(/* _In_ */ KINARGTYPE key) throw();
	void RemoveAll();
	void RemoveAtPos(_In_ POSITION pos) throw();

	POSITION GetStartPosition() const throw();
	void GetNextAssoc(
		_Inout_ POSITION& pos,
		_Out_ KOUTARGTYPE key,
		_Out_ VOUTARGTYPE value) const;
	const CPair* GetNext(_Inout_ POSITION& pos) const throw();
	CPair* GetNext(_Inout_ POSITION& pos) throw();
	const K& GetNextKey(_Inout_ POSITION& pos) const;
	const V& GetNextValue(_Inout_ POSITION& pos) const;
	V& GetNextValue(_Inout_ POSITION& pos);
	void GetAt(
		_In_ POSITION pos,
		_Out_ KOUTARGTYPE key,
		_Out_ VOUTARGTYPE value) const;
	CPair* GetAt(_In_ POSITION pos) throw();
	const CPair* GetAt(_In_ POSITION pos) const throw();
	const K& GetKeyAt(_In_ POSITION pos) const;
	const V& GetValueAt(_In_ POSITION pos) const;
	V& GetValueAt(_In_ POSITION pos);

	UINT GetHashTableSize() const throw();
	bool InitHashTable(
		_In_ UINT nBins,
		_In_ bool bAllocNow = true);
	void EnableAutoRehash() throw();
	void DisableAutoRehash() throw();
	void Rehash(_In_ UINT nBins = 0);
	void SetOptimalLoad(
		_In_ float fOptimalLoad,
		_In_ float fLoThreshold,
		_In_ float fHiThreshold,
		_In_ bool bRehashNow = false);

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

// Implementation
private:
	CNode** m_ppBins;
	size_t m_nElements;
	UINT m_nBins;
	float m_fOptimalLoad;
	float m_fLoThreshold;
	float m_fHiThreshold;
	size_t m_nHiRehashThreshold;
	size_t m_nLoRehashThreshold;
	ULONG m_nLockCount;
	UINT m_nBlockSize;
	CAtlPlex* m_pBlocks;
	CNode* m_pFree;

private:
	bool IsLocked() const throw();
	UINT PickSize(_In_ size_t nElements) const throw();
	CNode* NewNode(
		/* _In_ */ KINARGTYPE key,
		_In_ UINT iBin,
		_In_ UINT nHash);
	void FreeNode(_Inout_ CNode* pNode);
	void FreePlexes() throw();
	CNode* GetNode(
		/* _In_ */ KINARGTYPE key,
		_Out_ UINT& iBin,
		_Out_ UINT& nHash,
		_Deref_out_opt_ CNode*& pPrev) const throw();
	CNode* CreateNode(
		/* _In_ */ KINARGTYPE key,
		_In_ UINT iBin,
		_In_ UINT nHash) throw(...);
	void RemoveNode(
		_In_ CNode* pNode,
		_In_opt_ CNode* pPrev) throw();
	CNode* FindNextNode(_In_ CNode* pNode) const throw();
	void UpdateRehashThresholds() throw();

public:
	~CAtlMap() throw();

private:
	// Private to prevent use
	CAtlMap(_In_ const CAtlMap&) throw();
	CAtlMap& operator=(_In_ const CAtlMap&) throw();
};

template< typename K, typename I, class KTraits = CElementTraits< K > >
class CMapToInterface :
	public CAtlMap< K, ATL::CComQIPtr< I >, KTraits, CComQIPtrElementTraits< I > >
{
public:
	CMapToInterface(_In_ UINT nBins = 17) throw();

private:
	// Private to prevent use
	CMapToInterface(_In_ const CMapToInterface&) throw();
	CMapToInterface& operator=(_In_ const CMapToInterface&) throw();
};

template< typename K, typename I, class KTraits >
inline CMapToInterface< K, I, KTraits >::CMapToInterface(_In_ UINT nBins) throw() :
	CAtlMap< K, ATL::CComQIPtr< I >, KTraits, CComQIPtrElementTraits< I > >( nBins )
{
}

template< typename K, typename V, class KTraits = CElementTraits< K > >
class CMapToAutoPtr :
	public CAtlMap< K, ATL::CAutoPtr< V >, KTraits, CAutoPtrElementTraits< V > >
{
public:
	CMapToAutoPtr(_In_ UINT nBins = 17) throw();

private:
	// Private to prevent use
	CMapToAutoPtr(_In_ const CMapToAutoPtr&) throw();
	CMapToAutoPtr& operator=(_In_ const CMapToAutoPtr&) throw();
};

template< typename K, typename V, class KTraits >
inline CMapToAutoPtr< K, V, KTraits >::CMapToAutoPtr(_In_ UINT nBins) throw() :
	CAtlMap< K, ATL::CAutoPtr< V >, KTraits, CAutoPtrElementTraits< V > >( nBins )
{
}

template< typename K, typename V, class KTraits, class VTraits >
inline size_t CAtlMap< K, V, KTraits, VTraits >::GetCount() const throw()
{
	return( m_nElements );
}

template< typename K, typename V, class KTraits, class VTraits >
inline bool CAtlMap< K, V, KTraits, VTraits >::IsEmpty() const throw()
{
	return( m_nElements == 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
inline V& CAtlMap< K, V, KTraits, VTraits >::operator[](/* _In_ */ KINARGTYPE key) throw(...)
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		pNode = CreateNode( key, iBin, nHash );
	}

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline UINT CAtlMap< K, V, KTraits, VTraits >::GetHashTableSize() const throw()
{
	return( m_nBins );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos,
	_Out_ KOUTARGTYPE key,
	_Out_ VOUTARGTYPE value) const
{
	ATLENSURE( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );

	key = pNode->m_key;
	value = pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
inline typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos) throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos) const throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< const CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const K& CAtlMap< K, V, KTraits, VTraits >::GetKeyAt(_In_ POSITION pos) const
{
	ATLENSURE( pos != NULL );

	CNode* pNode = (CNode*)pos;

	return( pNode->m_key );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const V& CAtlMap< K, V, KTraits, VTraits >::GetValueAt(_In_ POSITION pos) const
{
	ATLENSURE( pos != NULL );

	CNode* pNode = (CNode*)pos;

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline V& CAtlMap< K, V, KTraits, VTraits >::GetValueAt(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );

	CNode* pNode = (CNode*)pos;

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::DisableAutoRehash() throw()
{
	m_nLockCount++;
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::EnableAutoRehash() throw()
{
	ATLASSUME( m_nLockCount > 0 );
	m_nLockCount--;
}

template< typename K, typename V, class KTraits, class VTraits >
inline bool CAtlMap< K, V, KTraits, VTraits >::IsLocked() const throw()
{
	return( m_nLockCount != 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
UINT CAtlMap< K, V, KTraits, VTraits >::PickSize(_In_ size_t nElements) const throw()
{
	// List of primes such that s_anPrimes[i] is the smallest prime greater than 2^(5+i/3)
	static const UINT s_anPrimes[] =
	{
		17, 23, 29, 37, 41, 53, 67, 83, 103, 131, 163, 211, 257, 331, 409, 521, 647, 821,
		1031, 1291, 1627, 2053, 2591, 3251, 4099, 5167, 6521, 8209, 10331,
		13007, 16411, 20663, 26017, 32771, 41299, 52021, 65537, 82571, 104033,
		131101, 165161, 208067, 262147, 330287, 416147, 524309, 660563,
		832291, 1048583, 1321139, 1664543, 2097169, 2642257, 3329023, 4194319,
		5284493, 6658049, 8388617, 10568993, 13316089, UINT_MAX
	};

	size_t nBins = (size_t)(nElements/m_fOptimalLoad);
	UINT nBinsEstimate = UINT(  UINT_MAX < nBins ? UINT_MAX : nBins );

	// Find the smallest prime greater than our estimate
	int iPrime = 0;
	while( nBinsEstimate > s_anPrimes[iPrime] )
	{
		iPrime++;
	}

	if( s_anPrimes[iPrime] == UINT_MAX )
	{
		return( nBinsEstimate );
	}
	else
	{
		return( s_anPrimes[iPrime] );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::CreateNode(
	/* _In_ */ KINARGTYPE key,
	_In_ UINT iBin,
	_In_ UINT nHash) throw(...)
{
	CNode* pNode;

	if( m_ppBins == NULL )
	{
		bool bSuccess;

		bSuccess = InitHashTable( m_nBins );
		if( !bSuccess )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
	}

	pNode = NewNode( key, iBin, nHash );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CAtlMap< K, V, KTraits, VTraits >::GetStartPosition() const throw()
{
	if( IsEmpty() )
	{
		return( NULL );
	}

	for( UINT iBin = 0; iBin < m_nBins; iBin++ )
	{
		if( m_ppBins[iBin] != NULL )
		{
			return( POSITION( m_ppBins[iBin] ) );
		}
	}
	ATLASSERT( false );

	return( NULL );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CAtlMap< K, V, KTraits, VTraits >::SetAt(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value)
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		pNode = CreateNode( key, iBin, nHash );
		_ATLTRY
		{
			pNode->m_value = value;
		}
		_ATLCATCHALL()
		{
			RemoveAtPos( POSITION( pNode ) );
			_ATLRETHROW;
		}
	}
	else
	{
		pNode->m_value = value;
	}

	return( POSITION( pNode ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::SetValueAt(
	_In_ POSITION pos,
	/* _In_ */ VINARGTYPE value)
{
	ATLASSUME( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );

	pNode->m_value = value;
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CAtlMap(
		_In_ UINT nBins,
		_In_ float fOptimalLoad,
		_In_ float fLoThreshold,
		_In_ float fHiThreshold,
		_In_ UINT nBlockSize) throw() :
	m_ppBins( NULL ),
	m_nBins( nBins ),
	m_nElements( 0 ),
	m_nLockCount( 0 ),  // Start unlocked
	m_fOptimalLoad( fOptimalLoad ),
	m_fLoThreshold( fLoThreshold ),
	m_fHiThreshold( fHiThreshold ),
	m_nHiRehashThreshold( UINT_MAX ),
	m_nLoRehashThreshold( 0 ),
	m_pBlocks( NULL ),
	m_pFree( NULL ),
	m_nBlockSize( nBlockSize )
{
	ATLASSERT( nBins > 0 );
	ATLASSERT( nBlockSize > 0 );

	SetOptimalLoad( fOptimalLoad, fLoThreshold, fHiThreshold, false );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::SetOptimalLoad(
	_In_ float fOptimalLoad,
	_In_ float fLoThreshold,
	_In_ float fHiThreshold,
	_In_ bool bRehashNow)
{
	ATLASSERT( fOptimalLoad > 0 );
	ATLASSERT( (fLoThreshold >= 0) && (fLoThreshold < fOptimalLoad) );
	ATLASSERT( fHiThreshold > fOptimalLoad );

	m_fOptimalLoad = fOptimalLoad;
	m_fLoThreshold = fLoThreshold;
	m_fHiThreshold = fHiThreshold;

	UpdateRehashThresholds();

	if( bRehashNow && ((m_nElements > m_nHiRehashThreshold) ||
		(m_nElements < m_nLoRehashThreshold)) )
	{
		Rehash( PickSize( m_nElements ) );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::UpdateRehashThresholds() throw()
{
	m_nHiRehashThreshold = size_t( m_fHiThreshold*m_nBins );
	m_nLoRehashThreshold = size_t( m_fLoThreshold*m_nBins );
	if( m_nLoRehashThreshold < 17 )
	{
		m_nLoRehashThreshold = 0;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::InitHashTable(_In_ UINT nBins, _In_ bool bAllocNow)
{
	ATLASSUME( m_nElements == 0 );
	ATLASSERT( nBins > 0 );

	if( m_ppBins != NULL )
	{
		delete[] m_ppBins;
		m_ppBins = NULL;
	}

	if( bAllocNow )
	{
		ATLTRY( m_ppBins = new CNode*[nBins] );
		if( m_ppBins == NULL )
		{
			return false;
		}

		ATLENSURE( UINT_MAX / sizeof( CNode* ) >= nBins );
		memset( m_ppBins, 0, sizeof( CNode* )*nBins );
	}
	m_nBins = nBins;

	UpdateRehashThresholds();

	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveAll()
{
	DisableAutoRehash();
	if( m_ppBins != NULL )
	{
		for( UINT iBin = 0; iBin < m_nBins; iBin++ )
		{
			CNode* pNext;

			pNext = m_ppBins[iBin];
			while( pNext != NULL )
			{
				CNode* pKill;

				pKill = pNext;
				pNext = pNext->m_pNext;
				FreeNode( pKill );
			}
		}
	}

	delete[] m_ppBins;
	m_ppBins = NULL;
	m_nElements = 0;

	if( !IsLocked() )
	{
		InitHashTable( PickSize( m_nElements ), false );
	}

	FreePlexes();
	EnableAutoRehash();
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::~CAtlMap() throw()
{
	_ATLTRY
	{
		RemoveAll();
	}
	_ATLCATCHALL()
	{
		ATLASSERT(false);
	}
}

#pragma push_macro("new")
#undef new

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::NewNode(
	/* _In_ */ KINARGTYPE key,
	_In_ UINT iBin,
	_In_ UINT nHash)
{
	CNode* pNewNode;

	if( m_pFree == NULL )
	{
		CAtlPlex* pPlex;
		CNode* pNode;

		pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		pNode = (CNode*)pPlex->data();
		pNode += m_nBlockSize-1;
		for( int iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pNext = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLENSURE(m_pFree != NULL );
	pNewNode = m_pFree;
	m_pFree = pNewNode->m_pNext;

	_ATLTRY
	{
		::new( pNewNode ) CNode( key, nHash );
	}
	_ATLCATCHALL()
	{
		pNewNode->m_pNext = m_pFree;
		m_pFree = pNewNode;

		_ATLRETHROW;
	}
	m_nElements++;

	pNewNode->m_pNext = m_ppBins[iBin];
	m_ppBins[iBin] = pNewNode;

	if( (m_nElements > m_nHiRehashThreshold) && !IsLocked() )
	{
		Rehash( PickSize( m_nElements ) );
	}

	return( pNewNode );
}

#pragma pop_macro("new")

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::FreeNode(_Inout_ CNode* pNode)
{
	ATLENSURE( pNode != NULL );

	pNode->~CNode();
	pNode->m_pNext = m_pFree;
	m_pFree = pNode;

	ATLASSUME( m_nElements > 0 );
	m_nElements--;

	if( (m_nElements < m_nLoRehashThreshold) && !IsLocked() )
	{
		Rehash( PickSize( m_nElements ) );
	}

	if( m_nElements == 0 )
	{
		FreePlexes();
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::FreePlexes() throw()
{
	m_pFree = NULL;
	if( m_pBlocks != NULL )
	{
		m_pBlocks->FreeDataChain();
		m_pBlocks = NULL;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::GetNode(
	/* _In_ */ KINARGTYPE key,
	_Out_ UINT& iBin,
	_Out_ UINT& nHash,
	_Deref_out_opt_ CNode*& pPrev) const throw()
{
	CNode* pFollow;

	nHash = KTraits::Hash( key );
	iBin = nHash%m_nBins;

	if( m_ppBins == NULL )
	{
		return( NULL );
	}

	pFollow = NULL;
	pPrev = NULL;
	for( CNode* pNode = m_ppBins[iBin]; pNode != NULL; pNode = pNode->m_pNext )
	{
		if( (pNode->GetHash() == nHash) && KTraits::CompareElements( pNode->m_key, key ) )
		{
			pPrev = pFollow;
			return( pNode );
		}
		pFollow = pNode;
	}

	return( NULL );
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key,
	_Out_ VOUTARGTYPE value) const
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		return( false );
	}

	value = pNode->m_value;

	return( true );
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key) const throw()
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key) throw()
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::RemoveKey(/* _In_ */ KINARGTYPE key) throw()
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pPrev = NULL;
	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		return( false );
	}

	RemoveNode( pNode, pPrev );

	return( true );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveNode(
	_In_ CNode* pNode,
	_In_opt_ CNode* pPrev)
{
	ATLENSURE( pNode != NULL );

	UINT iBin = pNode->GetHash() % m_nBins;

	if( pPrev == NULL )
	{
		ATLASSUME( m_ppBins[iBin] == pNode );
		m_ppBins[iBin] = pNode->m_pNext;
	}
	else
	{
		ATLASSERT( pPrev->m_pNext == pNode );
		pPrev->m_pNext = pNode->m_pNext;
	}
	FreeNode( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveAtPos(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	CNode* pPrev = NULL;
	UINT iBin = pNode->GetHash() % m_nBins;

	ATLASSUME( m_ppBins[iBin] != NULL );
	if( pNode == m_ppBins[iBin] )
	{
		pPrev = NULL;
	}
	else
	{
		pPrev = m_ppBins[iBin];
		while( pPrev->m_pNext != pNode )
		{
			pPrev = pPrev->m_pNext;
			ATLASSERT( pPrev != NULL );
		}
	}
	RemoveNode( pNode, pPrev );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::Rehash(_In_ UINT nBins)
{
	CNode** ppBins = NULL;

	if( nBins == 0 )
	{
		nBins = PickSize( m_nElements );
	}

	if( nBins == m_nBins )
	{
		return;
	}

	ATLTRACE(atlTraceMap, 2, _T("Rehash: %u bins\n"), nBins );

	if( m_ppBins == NULL )
	{
		// Just set the new number of bins
		InitHashTable( nBins, false );
		return;
	}

	ATLTRY(ppBins = new CNode*[nBins]);
	if (ppBins == NULL)
	{
		AtlThrow( E_OUTOFMEMORY );
	}

	ATLENSURE( UINT_MAX / sizeof( CNode* ) >= nBins );
	memset( ppBins, 0, nBins*sizeof( CNode* ) );

	// Nothing gets copied.  We just rewire the old nodes
	// into the new bins.
	for( UINT iSrcBin = 0; iSrcBin < m_nBins; iSrcBin++ )
	{
		CNode* pNode;

		pNode = m_ppBins[iSrcBin];
		while( pNode != NULL )
		{
			CNode* pNext;
			UINT iDestBin;

			pNext = pNode->m_pNext;  // Save so we don't trash it
			iDestBin = pNode->GetHash()%nBins;
			pNode->m_pNext = ppBins[iDestBin];
			ppBins[iDestBin] = pNode;

			pNode = pNext;
		}
	}

	delete[] m_ppBins;
	m_ppBins = ppBins;
	m_nBins = nBins;

	UpdateRehashThresholds();
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::GetNextAssoc(
	_Inout_ POSITION& pos,
	_Out_ KOUTARGTYPE key,
	_Out_ VOUTARGTYPE value) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSUME( m_ppBins != NULL );
	ATLENSURE( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );
	key = pNode->m_key;
	value = pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetNext(
	_Inout_ POSITION& pos) const throw()
{
	CNode* pNode;
	CNode* pNext;

	ATLASSUME( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetNext(
	_Inout_ POSITION& pos) throw()
{
	ATLASSUME( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	CNode* pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CAtlMap< K, V, KTraits, VTraits >::GetNextKey(
	_Inout_ POSITION& pos) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSUME( m_ppBins != NULL );
	ATLENSURE( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode->m_key );
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CAtlMap< K, V, KTraits, VTraits >::GetNextValue(
	_Inout_ POSITION& pos) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSUME( m_ppBins != NULL );
	ATLENSURE( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
V& CAtlMap< K, V, KTraits, VTraits >::GetNextValue(
	_Inout_ POSITION& pos)
{
	CNode* pNode;
	CNode* pNext;

	ATLASSUME( m_ppBins != NULL );
	ATLENSURE( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::FindNextNode(
	_In_ CNode* pNode) const throw()
{
	CNode* pNext;

	if(pNode == NULL)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if( pNode->m_pNext != NULL )
	{
		pNext = pNode->m_pNext;
	}
	else
	{
		UINT iBin;

		pNext = NULL;
		iBin = (pNode->GetHash()%m_nBins)+1;
		while( (pNext == NULL) && (iBin < m_nBins) )
		{
			if( m_ppBins[iBin] != NULL )
			{
				pNext = m_ppBins[iBin];
			}

			iBin++;
		}
	}

	return( pNext );
}

#ifdef _DEBUG
template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::AssertValid() const
{
	ATLASSUME( m_nBins > 0 );
	// non-empty map should have hash table
	ATLASSERT( IsEmpty() || (m_ppBins != NULL) );
}
#endif

#pragma push_macro("new")
#undef new

//
// The red-black tree code is based on the the descriptions in
// "Introduction to Algorithms", by Cormen, Leiserson, and Rivest
//
template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBTree
{
public:
	typedef typename KTraits::INARGTYPE KINARGTYPE;
	typedef typename KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef typename VTraits::INARGTYPE VINARGTYPE;
	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;

public:
	class CPair :
		public __POSITION
	{
	protected:

		CPair(
				/* _In_ */ KINARGTYPE key,
				/* _In_ */ VINARGTYPE value) :
			m_key( key ),
			m_value( value )
		{
		}
		~CPair() throw()
		{
		}

	public:
		const K m_key;
		V m_value;
	};

private:

	class CNode :
		public CPair
	{
	public:
		enum RB_COLOR
		{
			RB_RED,
			RB_BLACK
		};

	public:
		RB_COLOR m_eColor;
		CNode* m_pLeft;
		CNode* m_pRight;
		CNode* m_pParent;

		CNode(
				/* _In_ */ KINARGTYPE key,
				/* _In_ */ VINARGTYPE value) :
			CPair( key, value ),
			m_pParent( NULL ),
			m_eColor( RB_BLACK )
		{
		}
		~CNode() throw()
		{
		}
	};

private:
	CNode* m_pRoot;
	size_t m_nCount;
	CNode* m_pFree;
	CAtlPlex* m_pBlocks;
	size_t m_nBlockSize;

	// sentinel node
	CNode *m_pNil;

	// methods
	bool IsNil(_In_ CNode *p) const throw();
	void SetNil(_Deref_out_ CNode **p) throw();

	CNode* NewNode(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value) throw( ... );
	void FreeNode(_Inout_ CNode* pNode) throw();
	void RemovePostOrder(_In_ CNode* pNode) throw();
	CNode* LeftRotate(_In_ CNode* pNode) throw();
	CNode* RightRotate(_In_ CNode* pNode) throw();
	void SwapNode(
		_Out_ CNode* pDest,
		_Inout_ CNode* pSrc) throw();
	CNode* InsertImpl(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value) throw( ... );
	void RBDeleteFixup(_In_ CNode* pNode) throw();
	bool RBDelete(_In_opt_ CNode* pZ) throw();

#ifdef _DEBUG

	// internal debugging code to verify red-black properties of tree:
	// 1) Every node is either red or black
	// 2) Every leaf (NIL) is black
	// 3) If a node is red, both its children are black
	// 4) Every simple path from a node to a descendant leaf node contains
	//    the same number of black nodes
private:
	void VerifyIntegrity(
		_In_ const CNode *pNode,
		_In_ int nCurrBlackDepth,
		_Out_ int &nBlackDepth) const throw();

public:
	void VerifyIntegrity() const throw();

#endif // _DEBUG

protected:
	CNode* Minimum(_In_opt_ CNode* pNode) const throw();
	CNode* Maximum(_In_opt_ CNode* pNode) const throw();
	CNode* Predecessor(_In_opt_ CNode* pNode) const throw();
	CNode* Successor(_In_opt_ CNode* pNode) const throw();
	CNode* RBInsert(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value) throw( ... );
	CNode* Find(/* _In_ */ KINARGTYPE key) const throw();
	CNode* FindPrefix(/* _In_ */ KINARGTYPE key) const throw();

protected:
	explicit CRBTree(_In_ size_t nBlockSize = 10) throw();  // protected to prevent instantiation

public:
	~CRBTree() throw();

	void RemoveAll() throw();
	void RemoveAt(_In_ POSITION pos) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	POSITION FindFirstKeyAfter(/* _In_ */ KINARGTYPE key) const throw();

	POSITION GetHeadPosition() const throw();
	POSITION GetTailPosition() const throw();
	void GetNextAssoc(
		_Inout_ POSITION& pos,
		_Out_ KOUTARGTYPE key,
		_Out_ VOUTARGTYPE value) const;
	const CPair* GetNext(_Inout_ POSITION& pos) const throw();
	CPair* GetNext(_Inout_ POSITION& pos) throw();
	const CPair* GetPrev(_Inout_ POSITION& pos) const throw();
	CPair* GetPrev(_Inout_ POSITION& pos) throw();
	const K& GetNextKey(_Inout_ POSITION& pos) const throw();
	const V& GetNextValue(_Inout_ POSITION& pos) const throw();
	V& GetNextValue(_Inout_ POSITION& pos) throw();

	CPair* GetAt(_In_ POSITION pos) throw();
	const CPair* GetAt(_In_ POSITION pos) const throw();
	void GetAt(
		_In_ POSITION pos,
		_Out_ KOUTARGTYPE key,
		_Out_ VOUTARGTYPE value) const;
	const K& GetKeyAt(_In_ POSITION pos) const;
	const V& GetValueAt(_In_ POSITION pos) const;
	V& GetValueAt(_In_ POSITION pos);
	void SetValueAt(
		_In_ POSITION pos,
		/* _In_ */ VINARGTYPE value);

private:
	// Private to prevent use
	CRBTree(_In_ const CRBTree&) throw();
	CRBTree& operator=(_In_ const CRBTree&) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
inline bool CRBTree< K, V, KTraits, VTraits >::IsNil(_In_ CNode *p) const throw()
{
	return ( p == m_pNil );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CRBTree< K, V, KTraits, VTraits >::SetNil(_Deref_out_ CNode **p)
{
	ATLENSURE( p != NULL );
	*p = m_pNil;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CRBTree(_In_ size_t nBlockSize) throw() :
	m_pRoot( NULL ),
	m_nCount( 0 ),
	m_nBlockSize( nBlockSize ),
	m_pFree( NULL ),
	m_pBlocks( NULL ),
	m_pNil( NULL )
{
	ATLASSERT( nBlockSize > 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::~CRBTree() throw()
{
	RemoveAll();
	if (m_pNil != NULL)
	{
		free(m_pNil);
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemoveAll() throw()
{
	if (!IsNil(m_pRoot))
		RemovePostOrder(m_pRoot);
	m_nCount = 0;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pFree = NULL;
	m_pRoot = m_pNil;
}

template< typename K, typename V, class KTraits, class VTraits >
size_t CRBTree< K, V, KTraits, VTraits >::GetCount() const throw()
{
	return m_nCount;
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBTree< K, V, KTraits, VTraits >::IsEmpty() const throw()
{
	return( m_nCount == 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::FindFirstKeyAfter(/* _In_ */ KINARGTYPE key) const throw()
{
	return( FindPrefix( key ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemoveAt(_In_ POSITION pos) throw()
{
	ATLASSERT(pos != NULL);
	RBDelete(static_cast<CNode*>(pos));
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::GetHeadPosition() const throw()
{
	return( Minimum( m_pRoot ) );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::GetTailPosition() const throw()
{
	return( Maximum( m_pRoot ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::GetNextAssoc(
	_Inout_ POSITION& pos,
	_Out_ KOUTARGTYPE key,
	_Out_ VOUTARGTYPE value) const
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);

	key = pNode->m_key;
	value = pNode->m_value;

	pos = Successor(pNode);
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetNext(
	_Inout_ POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Successor(pNode);
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetNext(
	_Inout_ POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Successor(pNode);
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetPrev(
	_Inout_ POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Predecessor(pNode);

	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetPrev(
	_Inout_ POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Predecessor(pNode);

	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CRBTree< K, V, KTraits, VTraits >::GetNextKey(
	_Inout_ POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);

	return pNode->m_key;
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBTree< K, V, KTraits, VTraits >::GetNextValue(
	_Inout_ POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);

	return pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBTree< K, V, KTraits, VTraits >::GetNextValue(
	_Inout_ POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);

	return pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos) throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos) const throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< const CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::GetAt(
	_In_ POSITION pos,
	_Out_ KOUTARGTYPE key,
	_Out_ VOUTARGTYPE value) const
{
	ATLENSURE( pos != NULL );
	key = static_cast<CNode*>(pos)->m_key;
	value = static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CRBTree< K, V, KTraits, VTraits >::GetKeyAt(_In_ POSITION pos) const
{
	ATLENSURE( pos != NULL );
	return static_cast<CNode*>(pos)->m_key;
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBTree< K, V, KTraits, VTraits >::GetValueAt(_In_ POSITION pos) const
{
	ATLENSURE( pos != NULL );
	return static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBTree< K, V, KTraits, VTraits >::GetValueAt(_In_ POSITION pos)
{
	ATLENSURE( pos != NULL );
	return static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::SetValueAt(
	_In_ POSITION pos,
	/* _In_ */ VINARGTYPE value)
{
	ATLENSURE( pos != NULL );
	static_cast<CNode*>(pos)->m_value = value;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::NewNode(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value) throw( ... )
{
	if( m_pFree == NULL )
	{
		if (m_pNil == NULL)
		{
			m_pNil = reinterpret_cast<CNode *>(malloc(sizeof( CNode )));
			if (m_pNil == NULL)
			{
				AtlThrow( E_OUTOFMEMORY );
			}
			memset(m_pNil, 0x00, sizeof(CNode));
			m_pNil->m_eColor = CNode::RB_BLACK;
			m_pNil->m_pParent = m_pNil->m_pLeft = m_pNil->m_pRight = m_pNil;
			m_pRoot = m_pNil;
		}

		CAtlPlex* pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		CNode* pNode = static_cast< CNode* >( pPlex->data() );
		pNode += m_nBlockSize-1;
		for( INT_PTR iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pLeft = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLASSUME( m_pFree != NULL );

	CNode* pNewNode = m_pFree;
	::new( pNewNode ) CNode( key, value );

	m_pFree = m_pFree->m_pLeft;
	pNewNode->m_eColor = CNode::RB_RED;
	SetNil(&pNewNode->m_pLeft);
	SetNil(&pNewNode->m_pRight);
	SetNil(&pNewNode->m_pParent);

	m_nCount++;
	ATLASSUME( m_nCount > 0 );

	return( pNewNode );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::FreeNode(_Inout_ CNode* pNode)
{
	ATLENSURE( pNode != NULL );
	pNode->~CNode();
	pNode->m_pLeft = m_pFree;
	m_pFree = pNode;
	ATLASSUME( m_nCount > 0 );
	m_nCount--;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemovePostOrder(_In_ CNode* pNode) throw()
{
	if (IsNil(pNode))
		return;
	RemovePostOrder(pNode->m_pLeft);
	RemovePostOrder(pNode->m_pRight);
	FreeNode( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::LeftRotate(
	_In_ CNode* pNode) throw()
{
	ATLASSERT(pNode != NULL);
	if(pNode == NULL)
		return NULL;

	CNode* pRight = pNode->m_pRight;
	pNode->m_pRight = pRight->m_pLeft;
	if (!IsNil(pRight->m_pLeft))
		pRight->m_pLeft->m_pParent = pNode;

	pRight->m_pParent = pNode->m_pParent;
	if (IsNil(pNode->m_pParent))
		m_pRoot = pRight;
	else if (pNode == pNode->m_pParent->m_pLeft)
		pNode->m_pParent->m_pLeft = pRight;
	else
		pNode->m_pParent->m_pRight = pRight;

	pRight->m_pLeft = pNode;
	pNode->m_pParent = pRight;
	return pNode;

}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::RightRotate(
	_In_ CNode* pNode) throw()
{
	ATLASSERT(pNode != NULL);
	if(pNode == NULL)
		return NULL;

	CNode* pLeft = pNode->m_pLeft;
	pNode->m_pLeft = pLeft->m_pRight;
	if (!IsNil(pLeft->m_pRight))
		pLeft->m_pRight->m_pParent = pNode;

	pLeft->m_pParent = pNode->m_pParent;
	if (IsNil(pNode->m_pParent))
		m_pRoot = pLeft;
	else if (pNode == pNode->m_pParent->m_pRight)
		pNode->m_pParent->m_pRight = pLeft;
	else
		pNode->m_pParent->m_pLeft = pLeft;

	pLeft->m_pRight = pNode;
	pNode->m_pParent = pLeft;
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Find(
	/* _In_ */ KINARGTYPE key) const throw()
{
	CNode* pKey = NULL;
	CNode* pNode = m_pRoot;
	while( !IsNil(pNode) && (pKey == NULL) )
	{
		int nCompare = KTraits::CompareElementsOrdered( key, pNode->m_key );
		if( nCompare == 0 )
		{
			pKey = pNode;
		}
		else
		{
			if( nCompare < 0 )
			{
				pNode = pNode->m_pLeft;
			}
			else
			{
				pNode = pNode->m_pRight;
			}
		}
	}

	if( pKey == NULL )
	{
		return( NULL );
	}

#pragma warning(push)
#pragma warning(disable:4127)

	while( true )
	{
		CNode* pPrev = Predecessor( pKey );
		if( (pPrev != NULL) && KTraits::CompareElements( key, pPrev->m_key ) )
		{
			pKey = pPrev;
		}
		else
		{
			return( pKey );
		}
	}

#pragma warning(pop)
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::FindPrefix(
	/* _In_ */ KINARGTYPE key) const throw()
{
	// First, attempt to find a node that matches the key exactly
	CNode* pParent = NULL;
	CNode* pKey = NULL;
	CNode* pNode = m_pRoot;
	while( !IsNil(pNode) && (pKey == NULL) )
	{
		pParent = pNode;
		int nCompare = KTraits::CompareElementsOrdered( key, pNode->m_key );
		if( nCompare == 0 )
		{
			pKey = pNode;
		}
		else if( nCompare < 0 )
		{
			pNode = pNode->m_pLeft;
		}
		else
		{
			pNode = pNode->m_pRight;
		}
	}

	if( pKey != NULL )
	{
		// We found a node with the exact key, so find the first node after
		// this one with a different key
		while( true )
		{
			CNode* pNext = Successor( pKey );
			if ((pNext != NULL) && KTraits::CompareElements( key, pNext->m_key ))
			{
				pKey = pNext;
			}
			else
			{
				return pNext;
			}
		}
	}
	else if (pParent != NULL)
	{
		// No node matched the key exactly, so pick the first node with
		// a key greater than the given key
		int nCompare = KTraits::CompareElementsOrdered( key, pParent->m_key );
		if( nCompare < 0 )
		{
			pKey = pParent;
		}
		else
		{
			ATLASSERT( nCompare > 0 );
			pKey = Successor( pParent );
		}
	}

	return( pKey );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::SwapNode(_Out_ CNode* pDest, _Inout_ CNode* pSrc)
{
	ATLENSURE( pDest != NULL );
	ATLENSURE( pSrc != NULL );

	pDest->m_pParent = pSrc->m_pParent;
	if (pSrc->m_pParent->m_pLeft == pSrc)
	{
		pSrc->m_pParent->m_pLeft = pDest;
	}
	else
	{
		pSrc->m_pParent->m_pRight = pDest;
	}

	pDest->m_pRight = pSrc->m_pRight;
	pDest->m_pLeft = pSrc->m_pLeft;
	pDest->m_eColor = pSrc->m_eColor;
	pDest->m_pRight->m_pParent = pDest;
	pDest->m_pLeft->m_pParent = pDest;

	if (m_pRoot == pSrc)
	{
		m_pRoot = pDest;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::InsertImpl(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value) throw( ... )
{
	CNode* pNew = NewNode( key, value );

	CNode* pY = NULL;
	CNode* pX = m_pRoot;

	while (!IsNil(pX))
	{
		pY = pX;
		if( KTraits::CompareElementsOrdered( key, pX->m_key ) <= 0 )
			pX = pX->m_pLeft;
		else
			pX = pX->m_pRight;
	}

	pNew->m_pParent = pY;
	if (pY == NULL)
	{
		m_pRoot = pNew;
	}
	else if( KTraits::CompareElementsOrdered( key, pY->m_key ) <= 0 )
		pY->m_pLeft = pNew;
	else
		pY->m_pRight = pNew;

	return pNew;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RBDeleteFixup(_In_ CNode* pNode)
{
	ATLENSURE( pNode != NULL );

	CNode* pX = pNode;
	CNode* pW = NULL;

	while (( pX != m_pRoot ) && ( pX->m_eColor == CNode::RB_BLACK ))
	{
		if (pX == pX->m_pParent->m_pLeft)
		{
			pW = pX->m_pParent->m_pRight;
			if (pW->m_eColor == CNode::RB_RED)
			{
				pW->m_eColor = CNode::RB_BLACK;
				pW->m_pParent->m_eColor = CNode::RB_RED;
				LeftRotate(pX->m_pParent);
				pW = pX->m_pParent->m_pRight;
			}
			if (pW->m_pLeft->m_eColor == CNode::RB_BLACK && pW->m_pRight->m_eColor == CNode::RB_BLACK)
			{
				pW->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent;
			}
			else
			{
				if (pW->m_pRight->m_eColor == CNode::RB_BLACK)
				{
					pW->m_pLeft->m_eColor = CNode::RB_BLACK;
					pW->m_eColor = CNode::RB_RED;
					RightRotate(pW);
					pW = pX->m_pParent->m_pRight;
				}
				pW->m_eColor = pX->m_pParent->m_eColor;
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pW->m_pRight->m_eColor = CNode::RB_BLACK;
				LeftRotate(pX->m_pParent);
				pX = m_pRoot;
			}
		}
		else
		{
			pW = pX->m_pParent->m_pLeft;
			if (pW->m_eColor == CNode::RB_RED)
			{
				pW->m_eColor = CNode::RB_BLACK;
				pW->m_pParent->m_eColor = CNode::RB_RED;
				RightRotate(pX->m_pParent);
				pW = pX->m_pParent->m_pLeft;
			}
			if (pW->m_pRight->m_eColor == CNode::RB_BLACK && pW->m_pLeft->m_eColor == CNode::RB_BLACK)
			{
				pW->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent;
			}
			else
			{
				if (pW->m_pLeft->m_eColor == CNode::RB_BLACK)
				{
					pW->m_pRight->m_eColor = CNode::RB_BLACK;
					pW->m_eColor = CNode::RB_RED;
					LeftRotate(pW);
					pW = pX->m_pParent->m_pLeft;
				}
				pW->m_eColor = pX->m_pParent->m_eColor;
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pW->m_pLeft->m_eColor = CNode::RB_BLACK;
				RightRotate(pX->m_pParent);
				pX = m_pRoot;
			}
		}
	}

	pX->m_eColor = CNode::RB_BLACK;
}


template< typename K, typename V, class KTraits, class VTraits >
bool CRBTree< K, V, KTraits, VTraits >::RBDelete(_In_opt_ CNode* pZ) throw()
{
	if (pZ == NULL)
		return false;

	CNode* pY = NULL;
	CNode* pX = NULL;
	if (IsNil(pZ->m_pLeft) || IsNil(pZ->m_pRight))
		pY = pZ;
	else
		pY = Successor(pZ);

	if (!IsNil(pY->m_pLeft))
		pX = pY->m_pLeft;
	else
		pX = pY->m_pRight;

	pX->m_pParent = pY->m_pParent;

	if (IsNil(pY->m_pParent))
		m_pRoot = pX;
	else if (pY == pY->m_pParent->m_pLeft)
		pY->m_pParent->m_pLeft = pX;
	else
		pY->m_pParent->m_pRight = pX;

	if (pY->m_eColor == CNode::RB_BLACK)
		RBDeleteFixup(pX);

	if (pY != pZ)
		SwapNode(pY, pZ);

	if (m_pRoot != NULL)
		SetNil(&m_pRoot->m_pParent);

	FreeNode( pZ );

	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Minimum(
	_In_opt_ CNode* pNode) const throw()
{
	if (pNode == NULL || IsNil(pNode))
	{
		return NULL;
	}

	CNode* pMin = pNode;
	while (!IsNil(pMin->m_pLeft))
	{
		pMin = pMin->m_pLeft;
	}

	return pMin;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Maximum(
	_In_opt_ CNode* pNode) const throw()
{
	if (pNode == NULL || IsNil(pNode))
	{
		return NULL;
	}

	CNode* pMax = pNode;
	while (!IsNil(pMax->m_pRight))
	{
		pMax = pMax->m_pRight;
	}

	return pMax;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Predecessor(
	_In_opt_ CNode* pNode ) const throw()
{
	if( pNode == NULL )
	{
		return( NULL );
	}
	if( !IsNil(pNode->m_pLeft) )
	{
		return( Maximum( pNode->m_pLeft ) );
	}

	CNode* pParent = pNode->m_pParent;
	CNode* pLeft = pNode;
	while( !IsNil(pParent) && (pLeft == pParent->m_pLeft) )
	{
		pLeft = pParent;
		pParent = pParent->m_pParent;
	}

	if (IsNil(pParent))
	{
		pParent = NULL;
	}
	return( pParent );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Successor(
	_In_opt_ CNode* pNode) const throw()
{
	if ( pNode == NULL )
	{
		return NULL;
	}
	if ( !IsNil(pNode->m_pRight) )
	{
		return Minimum(pNode->m_pRight);
	}

	CNode* pParent = pNode->m_pParent;
	CNode* pRight = pNode;
	while ( !IsNil(pParent) && (pRight == pParent->m_pRight) )
	{
		pRight = pParent;
		pParent = pParent->m_pParent;
	}

	if (IsNil(pParent))
	{
		pParent = NULL;
	}
	return pParent;
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::RBInsert(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value) throw( ... )
{
	CNode* pNewNode = InsertImpl( key, value );

	CNode* pX = pNewNode;
	pX->m_eColor = CNode::RB_RED;
	CNode* pY = NULL;
	while (pX != m_pRoot && pX->m_pParent->m_eColor == CNode::RB_RED)
	{
		if (pX->m_pParent == pX->m_pParent->m_pParent->m_pLeft)
		{
			pY = pX->m_pParent->m_pParent->m_pRight;
			if (pY != NULL && pY->m_eColor == CNode::RB_RED)
			{
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pY->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent->m_pParent;
			}
			else
			{
				if (pX == pX->m_pParent->m_pRight)
				{
					pX = pX->m_pParent;
					LeftRotate(pX);
				}
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				RightRotate(pX->m_pParent->m_pParent);
			}
		}
		else
		{
			pY = pX->m_pParent->m_pParent->m_pLeft;
			if (pY != NULL && pY->m_eColor == CNode::RB_RED)
			{
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pY->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent->m_pParent;
			}
			else
			{
				if (pX == pX->m_pParent->m_pLeft)
				{
					pX = pX->m_pParent;
					RightRotate(pX);
				}
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				LeftRotate(pX->m_pParent->m_pParent);
			}
		}
	}

	m_pRoot->m_eColor = CNode::RB_BLACK;
	SetNil(&m_pRoot->m_pParent);

	return( pNewNode );
}

#ifdef _DEBUG

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::VerifyIntegrity(
	_In_ const CNode *pNode,
	_In_ int nCurrBlackDepth,
	_Out_ int &nBlackDepth) const throw()
{
	bool bCheckForBlack = false;
	bool bLeaf = true;

	if (pNode->m_eColor == CNode::RB_RED)
		bCheckForBlack = true;
	else
		nCurrBlackDepth++;

	ATLASSERT(pNode->m_pLeft != NULL);
	if (!IsNil(pNode->m_pLeft))
	{
		bLeaf = false;
		if (bCheckForBlack)
		{
			ATLASSERT(pNode->m_pLeft->m_eColor == CNode::RB_BLACK);
		}

		VerifyIntegrity(pNode->m_pLeft, nCurrBlackDepth, nBlackDepth);
	}

	ATLASSERT(pNode->m_pRight != NULL);
	if (!IsNil(pNode->m_pRight))
	{
		bLeaf = false;
		if (bCheckForBlack)
		{
			ATLASSERT(pNode->m_pRight->m_eColor == CNode::RB_BLACK);
		}

		VerifyIntegrity(pNode->m_pRight, nCurrBlackDepth, nBlackDepth);
	}

	ATLASSERT( pNode->m_pParent != NULL );
	ATLASSERT( ( IsNil(pNode->m_pParent) ) ||
			( pNode->m_pParent->m_pLeft == pNode ) ||
			( pNode->m_pParent->m_pRight == pNode ) );

	if (bLeaf)
	{
		if (nBlackDepth == 0)
		{
			nBlackDepth = nCurrBlackDepth;
		}
		else
		{
			ATLASSERT(nBlackDepth == nCurrBlackDepth);
		}
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::VerifyIntegrity() const throw()
{
	if ((m_pRoot == NULL) || (IsNil(m_pRoot)))
		return;

	ATLASSUME(m_pRoot->m_eColor == CNode::RB_BLACK);
	int nBlackDepth = 0;
	VerifyIntegrity(m_pRoot, 0, nBlackDepth);
}

#endif // _DEBUG

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBMap :
	public CRBTree< K, V, KTraits, VTraits >
{
public:
	explicit CRBMap(_In_ size_t nBlockSize = 10) throw();
	~CRBMap() throw();

	bool Lookup(
		/* _In_ */ KINARGTYPE key,
		_Out_ VOUTARGTYPE value) const throw( ... );
	const CPair* Lookup(/* _In_ */ KINARGTYPE key) const throw();
	CPair* Lookup(/* _In_ */ KINARGTYPE key) throw();
	POSITION SetAt(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value) throw( ... );
	bool RemoveKey(/* _In_ */ KINARGTYPE key) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
CRBMap< K, V, KTraits, VTraits >::CRBMap(_In_ size_t nBlockSize) throw() :
	CRBTree< K, V, KTraits, VTraits >( nBlockSize )
{
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMap< K, V, KTraits, VTraits >::~CRBMap() throw()
{
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CRBMap< K, V, KTraits, VTraits >::CPair* CRBMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key) const throw()
{
	return Find(key);
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBMap< K, V, KTraits, VTraits >::CPair* CRBMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key) throw()
{
	return Find(key);
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBMap< K, V, KTraits, VTraits >::Lookup(
	/* _In_ */ KINARGTYPE key,
	_Out_ VOUTARGTYPE value) const throw( ... )
{
	const CPair* pLookup = Find( key );
	if( pLookup == NULL )
		return false;

	value = pLookup->m_value;
	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMap< K, V, KTraits, VTraits >::SetAt(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value) throw( ... )
{
	CPair* pNode = Find( key );
	if( pNode == NULL )
	{
		return( RBInsert( key, value ) );
	}
	else
	{
		pNode->m_value = value;

		return( pNode );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBMap< K, V, KTraits, VTraits >::RemoveKey(/* _In_ */ KINARGTYPE key) throw()
{
	POSITION pos = Lookup( key );
	if( pos != NULL )
	{
		RemoveAt( pos );

		return( true );
	}
	else
	{
		return( false );
	}
}

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBMultiMap :
	public CRBTree< K, V, KTraits, VTraits >
{
public:
	explicit CRBMultiMap(_In_ size_t nBlockSize = 10) throw();
	~CRBMultiMap() throw();

	POSITION Insert(
		/* _In_ */ KINARGTYPE key,
		/* _In_ */ VINARGTYPE value) throw( ... );
	size_t RemoveKey(/* _In_ */ KINARGTYPE key) throw();

	POSITION FindFirstWithKey(/* _In_ */ KINARGTYPE key) const throw();
	const CPair* GetNextWithKey(
		_Inout_ POSITION& pos,
		/* _In_ */ KINARGTYPE key) const throw();
	CPair* GetNextWithKey(
		_Inout_ POSITION& pos,
		/* _In_ */ KINARGTYPE key) throw();
	const V& GetNextValueWithKey(
		_Inout_ POSITION& pos,
		/* _In_ */ KINARGTYPE key) const throw();
	V& GetNextValueWithKey(
		_Inout_ POSITION& pos,
		/* _In_ */ KINARGTYPE key) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
CRBMultiMap< K, V, KTraits, VTraits >::CRBMultiMap(_In_ size_t nBlockSize) throw() :
	CRBTree< K, V, KTraits, VTraits >( nBlockSize )
{
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMultiMap< K, V, KTraits, VTraits >::~CRBMultiMap() throw()
{
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMultiMap< K, V, KTraits, VTraits >::Insert(
	/* _In_ */ KINARGTYPE key,
	/* _In_ */ VINARGTYPE value) throw( ... )
{
	return( RBInsert( key, value ) );
}

template< typename K, typename V, class KTraits, class VTraits >
size_t CRBMultiMap< K, V, KTraits, VTraits >::RemoveKey(
	/* _In_ */ KINARGTYPE key) throw()
{
	size_t nElementsDeleted = 0;

	POSITION pos = FindFirstWithKey( key );
	while( pos != NULL )
	{
		POSITION posDelete = pos;
		GetNextWithKey( pos, key );
		RemoveAt( posDelete );
		nElementsDeleted++;
	}

	return( nElementsDeleted );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMultiMap< K, V, KTraits, VTraits >::FindFirstWithKey(
	/* _In_ */ KINARGTYPE key) const throw()
{
	return( Find( key ) );
}

template< typename K, typename V, class KTraits, class VTraits >
const typename CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V, KTraits, VTraits >::GetNextWithKey(
	_Inout_ POSITION& pos,
	/* _In_ */ KINARGTYPE key) const throw()
{
	ATLASSERT( pos != NULL );
	const CPair* pNode = GetNext( pos );
	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
	{
		pos = NULL;
	}

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
typename CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V, KTraits, VTraits >::GetNextWithKey(
	_Inout_ POSITION& pos,
	/* _In_ */ KINARGTYPE key) throw()
{
	ATLASSERT( pos != NULL );
	CPair* pNode = GetNext( pos );
	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
	{
		pos = NULL;
	}

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBMultiMap< K, V, KTraits, VTraits >::GetNextValueWithKey(
	_Inout_ POSITION& pos,
	/* _In_ */ KINARGTYPE key) const throw()
{
	const CPair* pPair = GetNextWithKey( pos, key );

	return( pPair->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBMultiMap< K, V, KTraits, VTraits >::GetNextValueWithKey(
	_Inout_ POSITION& pos,
	/* _In_ */ KINARGTYPE key) throw()
{
	CPair* pPair = GetNextWithKey( pos, key );

	return( pPair->m_value );
}

#pragma pop_macro("new")

}; // namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#endif  // __ATLCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlchecked.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCHECKED_H__
#define __ATLCHECKED_H__

#pragma once

#include <atldef.h>
#include <atlexcept.h>
#include <malloc.h>
#include <string.h>
#include <mbstring.h>
#include <wchar.h>
#include <tchar.h>
#include <stdlib.h>


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline errno_t AtlCrtErrorCheck(_In_ errno_t nError)
{
	switch(nError)
	{
	case ENOMEM:
		AtlThrow(E_OUTOFMEMORY);
		break;
	case EINVAL:
	case ERANGE:
		AtlThrow(E_INVALIDARG);
		break;
	case 0:
	case STRUNCATE:
		break;
	default:
		AtlThrow(E_FAIL);
		break;
	}
	return nError;
}

/////////////////////////////////////////////////////////////////////////////
// Secure (Checked) CRT functions

namespace Checked
{

#ifdef _AFX
#define ATLMFC_CRT_ERRORCHECK(expr) AFX_CRT_ERRORCHECK(expr)
#else
#define ATLMFC_CRT_ERRORCHECK(expr) ATL_CRT_ERRORCHECK(expr)
#endif

inline void __cdecl memcpy_s(
	_Out_bytecap_post_bytecount_(_S1max,_N)  void *_S1,
	_In_ size_t _S1max,
	_In_bytecount_(_N) const void *_S2,
	_In_ size_t _N)
{
	ATLMFC_CRT_ERRORCHECK(::memcpy_s(_S1, _S1max, _S2, _N));
}

inline void __cdecl wmemcpy_s(
	_Out_cap_post_count_(_N1,_N) wchar_t *_S1,
	_In_ size_t _N1,
	_In_count_(_N) const wchar_t *_S2,
	_In_ size_t _N)
{
	ATLMFC_CRT_ERRORCHECK(::wmemcpy_s(_S1, _N1, _S2, _N));
}

inline void __cdecl memmove_s(
	_Out_bytecap_post_bytecount_(_S1max,_N) void *_S1,
	_In_ size_t _S1max,
	_In_bytecount_(_N) const void *_S2,
	_In_ size_t _N)
{
	ATLMFC_CRT_ERRORCHECK(::memmove_s(_S1, _S1max, _S2, _N));
}

inline void __cdecl strcpy_s(
	_Out_z_cap_(_S1max) char *_S1,
	_In_ size_t _S1max,
	_In_z_ const char *_S2)
{
	ATLMFC_CRT_ERRORCHECK(::strcpy_s(_S1, _S1max, _S2));
}

inline void __cdecl wcscpy_s(
	_Out_z_cap_(_S1max) wchar_t *_S1,
	_In_ size_t _S1max,
	_In_z_ const wchar_t *_S2)
{
	ATLMFC_CRT_ERRORCHECK(::wcscpy_s(_S1, _S1max, _S2));
}

inline void __cdecl tcscpy_s(
	_Out_z_cap_(_SizeInChars) TCHAR * _Dst,
	_In_ size_t _SizeInChars,
	_In_z_ const TCHAR * _Src)
{
	ATLMFC_CRT_ERRORCHECK(::_tcscpy_s(_Dst, _SizeInChars, _Src));
}

inline errno_t __cdecl strncpy_s(
	_Out_z_cap_(_SizeInChars) char *_Dest,
	_In_ size_t _SizeInChars,
	_In_z_ const char *_Source,
	_In_ size_t _Count)
{
	return ATLMFC_CRT_ERRORCHECK(::strncpy_s(_Dest, _SizeInChars, _Source,_Count));
}

inline errno_t __cdecl wcsncpy_s(
	_Out_z_cap_(_SizeInChars) wchar_t *_Dest,
	_In_ size_t _SizeInChars,
	_In_z_ const wchar_t *_Source,
	_In_ size_t _Count)
{
	return ATLMFC_CRT_ERRORCHECK(::wcsncpy_s(_Dest, _SizeInChars, _Source,_Count));
}

inline errno_t __cdecl tcsncpy_s(
	_Out_z_cap_(_SizeInChars) TCHAR *_Dest,
	_In_ size_t _SizeInChars,
	_In_z_ const TCHAR *_Source,
	_In_ size_t _Count)
{
	return ATLMFC_CRT_ERRORCHECK(::_tcsncpy_s(_Dest, _SizeInChars, _Source,_Count));
}

inline void __cdecl strcat_s(
	_Inout_z_cap_(_SizeInChars) char * _Dst,
	_In_ size_t _SizeInChars,
	_In_z_ const char * _Src)
{
	ATLMFC_CRT_ERRORCHECK(::strcat_s(_Dst, _SizeInChars, _Src));
}

inline void __cdecl wcscat_s(
	_Inout_z_cap_(_SizeInChars) wchar_t * _Dst,
	_In_ size_t _SizeInChars,
	_In_z_ const wchar_t * _Src)
{
	ATLMFC_CRT_ERRORCHECK(::wcscat_s(_Dst, _SizeInChars, _Src));
}

inline void __cdecl tcscat_s(
	_Inout_z_cap_(_SizeInChars) TCHAR * _Dst,
	_In_ size_t _SizeInChars,
	_In_z_ const TCHAR * _Src)
{
	ATLMFC_CRT_ERRORCHECK(::_tcscat_s(_Dst, _SizeInChars, _Src));
}

inline void __cdecl strlwr_s(
	_Inout_z_cap_(_SizeInChars) char * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_strlwr_s(_Str, _SizeInChars));
}

inline void __cdecl wcslwr_s(
	_Inout_z_cap_(_SizeInChars) wchar_t * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_wcslwr_s(_Str, _SizeInChars));
}

inline void __cdecl mbslwr_s(
	_Inout_z_bytecap_(_SizeInChars) unsigned char * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_mbslwr_s(_Str, _SizeInChars));
}

inline void __cdecl tcslwr_s(
	_Inout_z_cap_(_SizeInChars) TCHAR * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_tcslwr_s(_Str, _SizeInChars));
}

inline void __cdecl strupr_s(
	_Inout_z_cap_(_SizeInChars) char * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_strupr_s(_Str, _SizeInChars));
}

inline void __cdecl wcsupr_s(
	_Inout_z_cap_(_SizeInChars) wchar_t * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_wcsupr_s(_Str, _SizeInChars));
}

inline void __cdecl mbsupr_s(
	_Inout_z_bytecap_(_SizeInChars) unsigned char * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_mbsupr_s(_Str, _SizeInChars));
}

inline void __cdecl tcsupr_s(
	_Inout_z_cap_(_SizeInChars) TCHAR * _Str,
	_In_ size_t _SizeInChars)
{
	ATLMFC_CRT_ERRORCHECK(::_tcsupr_s(_Str, _SizeInChars));
}

inline void __cdecl itoa_s(
	_In_ int _Val,
	_Out_z_cap_(_SizeInChars) char *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_itoa_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl itot_s(
	_In_ int _Val,
	_Out_z_cap_(_SizeInChars) TCHAR *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_itot_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ltoa_s(
	_In_ long _Val,
	_Out_z_cap_(_SizeInChars) char *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ltoa_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ltot_s(
	_In_ long _Val,
	_Out_z_cap_(_SizeInChars) TCHAR *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ltot_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ultoa_s(
	_In_ unsigned long _Val,
	_Out_z_cap_(_SizeInChars) char *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ultoa_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ultow_s(
	_In_ unsigned long _Val,
	_Out_z_cap_(_SizeInChars) wchar_t *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ultow_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ultot_s(
	_In_ unsigned long _Val,
	_Out_z_cap_(_SizeInChars) TCHAR *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ultot_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl i64toa_s(
	_In_ __int64 _Val,
	_Out_z_cap_(_SizeInChars) char *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_i64toa_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl i64tow_s(
	_In_ __int64 _Val,
	_Out_z_cap_(_SizeInChars) wchar_t *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_i64tow_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ui64toa_s(
	_In_ unsigned __int64 _Val,
	_Out_z_cap_(_SizeInChars) char *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ui64toa_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl ui64tow_s(
	_In_ unsigned __int64 _Val,
	_Out_z_cap_(_SizeInChars) wchar_t *_Buf,
	_In_ size_t _SizeInChars,
	_In_ int _Radix)
{
	ATLMFC_CRT_ERRORCHECK(::_ui64tow_s(_Val, _Buf, _SizeInChars, _Radix));
}

inline void __cdecl gcvt_s(
	_Out_z_cap_(_SizeInChars) char *_Buffer,
	_In_ size_t _SizeInChars,
	_In_ double _Value,
	_In_ int _Ndec)
{
	ATLMFC_CRT_ERRORCHECK(::_gcvt_s(_Buffer, _SizeInChars, _Value, _Ndec));
}

inline void __cdecl tsplitpath_s(
	_In_z_ const TCHAR *_Path,
	_Out_opt_z_cap_(_Drive_len) TCHAR *_Drive,
	_In_ size_t _Drive_len,
	_Out_opt_z_cap_(_Dir_len) TCHAR *_Dir,
	_In_ size_t _Dir_len,
	_Out_opt_z_cap_(_Fname_len) TCHAR *_Fname,
	_In_ size_t _Fname_len,
	_Out_opt_z_cap_(_Ext_len) TCHAR *_Ext,
	_In_ size_t _Ext_len)
{
	ATLMFC_CRT_ERRORCHECK(::_tsplitpath_s(_Path, _Drive, _Drive_len, _Dir, _Dir_len, _Fname, _Fname_len, _Ext, _Ext_len));
}

inline void __cdecl tmakepath_s(
	_Out_z_cap_(_SizeInChars) TCHAR *_Path,
	_In_ size_t _SizeInChars,
	_In_z_ const TCHAR *_Drive,
	_In_z_ const TCHAR *_Dir,
	_In_z_ const TCHAR *_Fname,
	_In_z_ const TCHAR *_Ext)
{
	ATLMFC_CRT_ERRORCHECK(::_tmakepath_s(_Path, _SizeInChars, _Drive, _Dir, _Fname, _Ext));
}

inline size_t __cdecl strnlen(
	_In_z_count_(_Maxsize) const char *_Str,
	_In_ size_t _Maxsize)
{
	return ::strnlen(_Str, _Maxsize);
}

inline size_t __cdecl wcsnlen(
	_In_z_count_(_Maxsize) const wchar_t *_Wcs,
	_In_ size_t _Maxsize)
{
	return ::wcsnlen(_Wcs, _Maxsize);
}

inline size_t __cdecl tcsnlen(
	_In_z_count_(_Maxsize) const TCHAR *_Str,
	_In_ size_t _Maxsize)
{
	return ::_tcsnlen(_Str, _Maxsize);
}

inline int get_errno() throw()
{
	int nErrNo=0;
	errno_t nErrCall=::_get_errno(&nErrNo);
	if(nErrCall)
	{
		return nErrCall;
	}
	return nErrNo;
}

inline void set_errno(_In_ int _Value)
{
	ATLMFC_CRT_ERRORCHECK(::_set_errno(_Value));
}

} // namespace Checked

} // namespace ATL
#pragma pack(pop)

#endif // __ATLCHECKED_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4355) // 'this' used in initializer list
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#pragma warning(disable : 4668)	// is not defined as a preprocessor macro, replacing with '0' for '#if/#elif
#pragma warning(disable : 4820)	// padding added after member
#pragma warning(disable : 4571) //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifdef _ATL_ALL_WARNINGS
#pragma warning( push )
#endif
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4786) // avoid 255-character limit warnings

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#include <atlstdthunk.h>
#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

#include <limits.h>

#pragma pack(push, _ATL_PACKING)
namespace ATL
{

#define CComConnectionPointContainerImpl ATL::IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ATL::ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl ATL::IProvideClassInfo2Impl
#define CComDualImpl ATL::IDispatchImpl

#ifdef _ATL_DEBUG_QI
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_QI
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_ UINT nID, 
	_In_ const IID& iid = GUID_NULL,
	_In_ HRESULT hRes = 0, 
	_In_ HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_ UINT nID, 
	_In_ DWORD dwHelpID,
	_In_z_ LPCOLESTR lpszHelpFile, 
	_In_ const IID& iid = GUID_NULL, 
	_In_ HRESULT hRes = 0, 
	_In_ HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_z_ LPCSTR lpszDesc,
	_In_ DWORD dwHelpID, 
	_In_opt_z_ LPCSTR lpszHelpFile, 
	_In_ const IID& iid = GUID_NULL, 
	_In_ HRESULT hRes = 0)
{
	ATLASSERT(lpszDesc != NULL);
	if (lpszDesc == NULL)
		return E_POINTER;
	USES_CONVERSION_EX;
	LPCOLESTR pwszDesc = A2COLE_EX(lpszDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
	if(pwszDesc == NULL)
		return E_OUTOFMEMORY;
	
	LPCWSTR pwzHelpFile = NULL;
	if(lpszHelpFile != NULL)
	{
		pwzHelpFile = A2CW_EX(lpszHelpFile, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if(pwzHelpFile == NULL)
			return E_OUTOFMEMORY;
	}
		
	return AtlSetErrorInfo(clsid, pwszDesc, dwHelpID, pwzHelpFile, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_z_ LPCSTR lpszDesc,
	_In_ const IID& iid = GUID_NULL, 
	_In_ HRESULT hRes = 0)
{
	return AtlReportError(clsid, lpszDesc, 0, NULL, iid, hRes);
}

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_z_ LPCOLESTR lpszDesc,
	_In_ const IID& iid = GUID_NULL, 
	_In_ HRESULT hRes = 0)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(
	_In_ const CLSID& clsid, 
	_In_z_ LPCOLESTR lpszDesc, 
	_In_ DWORD dwHelpID,
	_In_z_ LPCOLESTR lpszHelpFile, 
	_In_ const IID& iid = GUID_NULL, 
	_In_ HRESULT hRes = 0)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

// Returns the apartment type that the current thread is in. false is returned
// if the thread isn't in an apartment.
inline bool AtlGetApartmentType(_Out_ DWORD* pApartmentType)
{
	HRESULT hr = CoInitialize(NULL);
 	if (SUCCEEDED(hr))
		CoUninitialize();

	if (hr == S_FALSE)
	{
		*pApartmentType = COINIT_APARTMENTTHREADED;
		return true;
	}
	else if (hr == RPC_E_CHANGED_MODE)
	{	
		*pApartmentType = COINIT_MULTITHREADED;
		return true;
	}

	return false;
}

/////////////////////////////////////////////////////////////////////////////
// CComTypeAttr

class CComTypeAttr
{
// Construction
public:
   CComTypeAttr(_In_ ITypeInfo* pTypeInfo) throw() :
	  m_pTypeAttr( NULL ),
	  m_pTypeInfo( pTypeInfo )
   {
   }
   ~CComTypeAttr() throw()
   {
	  Release();
   }

// Operators
public:
   TYPEATTR* operator->() throw()
   {
	  ATLASSUME( m_pTypeAttr != NULL );

	  return m_pTypeAttr;
   }
   TYPEATTR** operator&() throw()
   {
	  ATLASSUME( m_pTypeAttr == NULL );

	  return &m_pTypeAttr;
   }

   operator const TYPEATTR*() const throw()
   {
	  return m_pTypeAttr;
   }

// Operations
public:
   void Release() throw()
   {
	  if( m_pTypeAttr != NULL )
	  {
		 ATLASSUME( m_pTypeInfo != NULL );
		 m_pTypeInfo->ReleaseTypeAttr( m_pTypeAttr );
		 m_pTypeAttr = NULL;
	  }
   }

public:
   TYPEATTR* m_pTypeAttr;
   CComPtr< ITypeInfo > m_pTypeInfo;
};


/////////////////////////////////////////////////////////////////////////////
// CComVarDesc

class CComVarDesc
{
// Construction
public:
   CComVarDesc(_In_ ITypeInfo* pTypeInfo) throw() :
	  m_pVarDesc( NULL ),
	  m_pTypeInfo( pTypeInfo )
   {
   }
   ~CComVarDesc() throw()
   {
	  Release();
   }

// Operators
public:
   VARDESC* operator->() throw()
   {
	  ATLASSUME( m_pVarDesc != NULL );

	  return m_pVarDesc;
   }
   VARDESC** operator&() throw()
   {
	  ATLASSUME( m_pVarDesc == NULL );

	  return &m_pVarDesc;
   }

   operator const VARDESC*() const throw()
   {
	  return m_pVarDesc;
   }

// Operations
public:
   void Release() throw()
   {
	  if( m_pVarDesc != NULL )
	  {
		 ATLASSUME( m_pTypeInfo != NULL );
		 m_pTypeInfo->ReleaseVarDesc( m_pVarDesc );
		 m_pVarDesc = NULL;
	  }
   }

public:
   VARDESC* m_pVarDesc;
   CComPtr< ITypeInfo > m_pTypeInfo;
};


/////////////////////////////////////////////////////////////////////////////
// CComFuncDesc

class CComFuncDesc
{
// Construction
public:
   CComFuncDesc(_In_ ITypeInfo* pTypeInfo) throw() :
	  m_pFuncDesc( NULL ),
	  m_pTypeInfo( pTypeInfo )
   {
   }
   ~CComFuncDesc() throw()
   {
	  Release();
   }

// Operators
public:
   FUNCDESC* operator->() throw()
   {
	  ATLASSUME( m_pFuncDesc != NULL );

	  return m_pFuncDesc;
   }
   FUNCDESC** operator&() throw()
   {
	  ATLASSUME( m_pFuncDesc == NULL );

	  return &m_pFuncDesc;
   }

   operator const FUNCDESC*() const throw()
   {
	  return m_pFuncDesc;
   }

// Operations
public:
   void Release() throw()
   {
	  if( m_pFuncDesc != NULL )
	  {
		 ATLASSUME( m_pTypeInfo != NULL );
		 m_pTypeInfo->ReleaseFuncDesc( m_pFuncDesc );
		 m_pFuncDesc = NULL;
	  }
   }

public:
   FUNCDESC* m_pFuncDesc;
   CComPtr< ITypeInfo > m_pTypeInfo;
};


/////////////////////////////////////////////////////////////////////////////
// CComExcepInfo

class CComExcepInfo :
   public EXCEPINFO
{
// Construction
public:
   CComExcepInfo()
   {
	  memset( this, 0, sizeof( *this ) );
   }
   ~CComExcepInfo()
   {
	  Clear();
   }

// Operations
public:
   void Clear()
   {
      ::SysFreeString(bstrSource);
      ::SysFreeString(bstrDescription);
      ::SysFreeString(bstrHelpFile);

	  memset(this, 0, sizeof(*this));
   }
};


//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl : 
	public IPersist
{
public:
	STDMETHOD(GetClassID)(_Out_ CLSID *pClassID)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_FAIL;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(
		_In_opt_ IUnknown* /*pUnk*/, 
		_In_ DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(
		_In_opt_ IUnknown* /*pUnk*/, 
		_In_ DISPID /*dispID*/)
	{
		return S_OK;
	}
};
typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;


//////////////////////////////////////////////////////////////////////////////
// ALT_PROP_VAL_MAP

struct ATL_PROPVALMAP_ENTRY
{
	DISPID dispid;
	VARIANT val;
	LPCOLESTR szDesc;
};

#define BEGIN_PROP_VAL_MAP(theClass) \
	static ATL::ATL_PROPVALMAP_ENTRY* GetPropValMap(_Out_opt_ int *cnt)\
	{\
		static ATL::ATL_PROPVALMAP_ENTRY pPropMap[] = \
		{

#define PROP_VAL_INT(dispid, ival, str) \
			{dispid, {VT_I4, 0, 0, 0, ival}, OLESTR(str)},


#define END_PROP_VAL_MAP() \
		}; \
		if (cnt)	\
			*cnt = sizeof(pPropMap)/sizeof(pPropMap[0]);	\
		return pPropMap; \
	}

#define DECLARE_EMPTY_PROP_VAL_MAP() \
public: \
	_Ret_null_ static ATL::ATL_PROPVALMAP_ENTRY* GetPropValMap(_Out_opt_ int *cnt)\
	{ \
		if (cnt)	\
			*cnt = 0;	\
		return NULL; \
	}

//////////////////////////////////////////////////////////////////////////////
// ATL Persistence

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;
	ClassesAllowedInStream rgclsidAllowed;
	DWORD cclsidAllowed;
	DISPID dispid;
	DWORD dwOffsetData;
	DWORD dwSizeData;
	VARTYPE vt;
};

template<VARTYPE V>
struct AtlExpectedDispatchOrUnknown 
{
	ATLSTATIC_ASSERT(V == VT_DISPATCH || V == VT_UNKNOWN, 
			"Incorrect VARTYPE value in PROP_ENTRY_INTERFACE definition. Expected VT_DISPATCH or VT_UNKNOWN.");
	static const VARTYPE value = V;	
};

// This one is used for ATL 2.X controls
// it includes an implicit m_sizeExtent
#define BEGIN_PROPERTY_MAP(theClass) \
	BEGIN_PROP_MAP(theClass) \
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4) \
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)

// This one can be used on any type of object, but does not
// include the implicit m_sizeExtent
#define BEGIN_PROP_MAP(theClass) \
	__if_not_exists(__ATL_PROP_NOTIFY_EVENT_CLASS) \
	{ \
		typedef ATL::_ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	} \
	typedef theClass _PropMapClass; \
	static const ATL::ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static const ATL::ATL_PROPMAP_ENTRY pPropMap[] = \
		{
#ifndef _ATL_PROP_ENTRY_NO_WARNING 
#pragma deprecated(PROP_ENTRY, PROP_ENTRY_EX)
#endif

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), NULL, 0, dispid, 0, 0, VT_EMPTY},

#define PROP_ENTRY_INTERFACE(szDesc, dispid, clsid, rgclsidAllowed, cclsidAllowed, vt) \
		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), rgclsidAllowed, cclsidAllowed, dispid, 0, 0, \
		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
		
#define PROP_ENTRY_INTERFACE_CALLBACK(szDesc, dispid, clsid, pfnFunc, vt) \
		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), reinterpret_cast<const CLSID *>(pfnFunc), 0, dispid, 0, 0, \
		ATL::AtlExpectedDispatchOrUnknown<vt>::value},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), &clsid, &iidDispatch, NULL, 0, dispid, 0, 0, VT_EMPTY},

#define PROP_ENTRY_INTERFACE_EX(szDesc, dispid, clsid, iidDispatch, rgclsidAllowed, cclsidAllowed, vt) \
		{OLESTR(szDesc), &clsid, &iidDispatch, rgclsidAllowed, cclsidAllowed, dispid, 0, 0, \
		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
		
#define PROP_ENTRY_INTERFACE_CALLBACK_EX(szDesc, dispid, clsid, iidDispatch, pfnFunc, vt) \
		{OLESTR(szDesc), &clsid, &iidDispatch, reinterpret_cast<const CLSID *>(pfnFunc), 0, dispid, 0, 0, \
		ATL::AtlExpectedDispatchOrUnknown<vt>::value},
		
#define PROP_ENTRY_TYPE(szDesc, dispid, clsid, vt) \
		{OLESTR(szDesc), &clsid, &__uuidof(IDispatch), NULL, 0, dispid, 0, 0, vt},

#define PROP_ENTRY_TYPE_EX(szDesc, dispid, clsid, iidDispatch, vt) \
		{OLESTR(szDesc), &clsid, &iidDispatch, NULL, 0, dispid, 0, 0, vt},

#define PROP_PAGE(clsid) \
		{NULL, &clsid, &IID_NULL, NULL, 0, 0, 0, 0, 0},

#define PROP_DATA_ENTRY(szDesc, member, vt) \
		{OLESTR(szDesc), &CLSID_NULL, NULL, NULL, 0, 0, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), vt},

#define END_PROPERTY_MAP() \
			{NULL, NULL, &IID_NULL, NULL, 0, 0, 0, 0, 0} \
		}; \
		return pPropMap; \
	}

#define END_PROP_MAP() \
			{NULL, NULL, &IID_NULL, NULL, 0, 0, 0, 0, 0} \
		}; \
		return pPropMap; \
	}

//////////////////////////////////////////////////////////////////////////////
// IPersist* Helpers

ATLAPI AtlIPersistStreamInit_Load(
	_Inout_ LPSTREAM pStm, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk);

ATLAPI AtlIPersistStreamInit_Save(
	_Inout_ LPSTREAM pStm, 
	_In_ BOOL fClearDirty, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk);

ATLAPI AtlIPersistPropertyBag_Load(
	_Inout_ LPPROPERTYBAG pPropBag, 
	_Inout_ LPERRORLOG pErrorLog, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk);

ATLAPI AtlIPersistPropertyBag_Save(
	_Inout_ LPPROPERTYBAG pPropBag, 
	_In_ BOOL fClearDirty, 
	_In_ BOOL fSaveAllProperties, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk);

//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl : 
	public IPersistStreamInit
{
public:
	// IPersist
	STDMETHOD(GetClassID)(_Out_ CLSID *pClassID)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(_Inout_ LPSTREAM pStm)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::Load\n"));

		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(_Inout_ LPSTREAM pStm, _In_ BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(_Out_ ULARGE_INTEGER* pcbSize)
	{
		HRESULT hr = S_OK;
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::GetSizeMax\n"));

		ATLASSERT(pcbSize != NULL);
		if (pcbSize == NULL)
		{
			return E_POINTER;
		}

		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLENSURE_RETURN(pMap != NULL);

		// Start the size with the size of the ATL version we write out.
		ULARGE_INTEGER nSize;		
		nSize.QuadPart = sizeof(DWORD);

		CComPtr<IDispatch> pDispatch;
		const IID* piidOld = NULL;
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			ULARGE_INTEGER nVarSize;
			nVarSize.QuadPart = 0;
			
			if (pMap[i].szDesc == NULL)
			{
				continue;
			}

			// check if raw data entry
			if (pMap[i].dwSizeData != 0)
			{			
				//Calculate stream size for BSTRs special case
				if (pMap[i].vt == VT_BSTR)
				{
					void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pT);
					ATLENSURE_RETURN( pData >= (void*)(DWORD_PTR)pMap[i].dwOffsetData
									&& pData >= (void*)(DWORD_PTR)pT );
					BSTR bstr = *reinterpret_cast<BSTR*>(pData);
						
					nVarSize.LowPart = CComBSTR::GetStreamSize(bstr);
				} 
				else
				{
					nVarSize.LowPart = pMap[i].dwSizeData;
				}					
			}
			else
			{
				CComVariant var;
				if (pMap[i].piidDispatch != piidOld)
				{
					pDispatch.Release();
					ATLENSURE_RETURN(pMap[i].piidDispatch);
					
					hr = pT->GetUnknown()->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch);
					if (FAILED(hr))
					{
						ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);						
						break;
					}
					piidOld = pMap[i].piidDispatch;
				}

				hr = pDispatch.GetProperty(pMap[i].dispid, &var);
				if (FAILED(hr))
				{
					ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);					
					break;
				}
				
				hr = var.GetSizeMax(&nVarSize);			
				if (FAILED(hr))
				{
					ATLTRACE(atlTraceCOM, 0, _T("Failed to get size for property #%i\n"), i);					
					break;
				}
			}
			
			hr = AtlAdd(&nSize.QuadPart, nSize.QuadPart, nVarSize.QuadPart);
			if (FAILED(hr))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Result overflow after adding property #%i\n"), i);				
				break;
			}			
		}
		*pcbSize = nSize;
		return hr;
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStreamInitImpl::InitNew\n"));
		T* pT = static_cast<T*>(this);
		pT->m_bRequiresSave = TRUE;
		return S_OK;
	}

	HRESULT IPersistStreamInit_Load(
		_Inout_ LPSTREAM pStm, 
		_In_ const ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;

	}
	HRESULT IPersistStreamInit_Save(
		_Inout_ LPSTREAM pStm, 
		_In_ BOOL fClearDirty, 
		_In_ const ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
		if (fClearDirty && SUCCEEDED(hr))
		{
			pT->m_bRequiresSave=FALSE;
		}
		return hr;

	}
};

//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl : 
	public IPersistStorage
{
public:
	// IPersist
	STDMETHOD(GetClassID)(_Out_ CLSID *pClassID)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::IsDirty\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(_In_opt_ IStorage*)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::InitNew\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(_Inout_ IStorage* pStorage)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::Load\n"));
		if (pStorage == NULL)
			return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(_Inout_ IStorage* pStorage, _In_ BOOL fSameAsLoad)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::Save\n"));
		if (pStorage == NULL)
			return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(_Inout_opt_ IStorage* /* pStorage */)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(__uuidof(IPersistStreamInit), (void**)&p)))
		pT->_InternalQueryInterface(__uuidof(IPersistStreamInit), (void**)&p);
	return p;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl : 
	public IPersistPropertyBag
{
public:
	// IPersist
	STDMETHOD(GetClassID)(_Out_ CLSID *pClassID)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistPropertyBagImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistPropertyBagImpl::InitNew\n"));
		T* pT = static_cast<T*>(this);
		pT->m_bRequiresSave = TRUE;
		return S_OK;
	}
	STDMETHOD(Load)(
		_Inout_ LPPROPERTYBAG pPropBag, 
		_Inout_opt_ LPERRORLOG pErrorLog)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(
		_Inout_ LPPROPERTYBAG pPropBag, 
		_In_ BOOL fClearDirty, 
		_In_ BOOL fSaveAllProperties)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
	HRESULT IPersistPropertyBag_Load(
		_Inout_ LPPROPERTYBAG pPropBag, 
		_In_opt_ LPERRORLOG pErrorLog, 
		_In_ const ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;
	}
	HRESULT IPersistPropertyBag_Save(
		_Inout_ LPPROPERTYBAG pPropBag, 
		_In_ BOOL fClearDirty, 
		_In_ BOOL fSaveAllProperties, 
		_In_ const ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap, pT, pT->GetUnknown());
		if (fClearDirty && SUCCEEDED(hr))
		{
			pT->m_bRequiresSave=FALSE;
		}
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
ATL_DEPRECATED("CSecurityDescriptor has been replaced by CSID") class CSecurityDescriptor
{
public:
	CSecurityDescriptor();
	~CSecurityDescriptor();

public:
	HRESULT Attach(_In_ PSECURITY_DESCRIPTOR pSelfRelativeSD);
	HRESULT AttachObject(_In_ HANDLE hObject);
	HRESULT Initialize();
	HRESULT InitializeFromProcessToken(_In_ BOOL bDefaulted = FALSE);
	HRESULT InitializeFromThreadToken(
		_In_ BOOL bDefaulted = FALSE, 
		_In_ BOOL bRevertToProcessToken = TRUE);
	HRESULT SetOwner(
		_In_opt_ PSID pOwnerSid, 
		_In_ BOOL bDefaulted = FALSE);
	HRESULT SetGroup(
		_In_opt_ PSID pGroupSid, 
		_In_ BOOL bDefaulted = FALSE);
	HRESULT Allow(
		_In_z_ LPCTSTR pszPrincipal, 
		_In_ DWORD dwAccessMask);
	HRESULT Deny(
		_In_z_ LPCTSTR pszPrincipal, 
		_In_ DWORD dwAccessMask);
	HRESULT Revoke(_In_z_ LPCTSTR pszPrincipal);
	HRESULT Allow(
		_In_ PSID pSid, 
		_In_ DWORD dwAccessMask);
	HRESULT Deny(
		_In_ PSID pSid, 
		_In_ DWORD dwAccessMask);
	HRESULT Revoke(_In_ PSID pSid);

	// utility functions
	// Any PSID you get from these functions should be free()ed
	static HRESULT SetPrivilege(
		_In_z_ LPCTSTR Privilege, 
		_In_ BOOL bEnable = TRUE, 
		_In_ HANDLE hToken = NULL);
	static HRESULT GetTokenSids(
		_In_ HANDLE hToken, 
		_Out_opt_ PSID* ppUserSid, 
		_Out_opt_ PSID* ppGroupSid);
	static HRESULT GetProcessSids(
		_Out_opt_ PSID* ppUserSid, 
		_Out_opt_ PSID* ppGroupSid = NULL);
	static HRESULT GetThreadSids(
		_Out_opt_ PSID* ppUserSid, 
		_Out_opt_ PSID* ppGroupSid = NULL, 
		_In_ BOOL bOpenAsSelf = FALSE);
	static HRESULT CopyACL(
		_Out_ PACL pDest, 
		_In_opt_ PACL pSrc);
	static HRESULT GetCurrentUserSID(_Deref_out_ PSID *ppSid);
	static HRESULT GetPrincipalSID(
		_In_z_ LPCTSTR pszPrincipal, 
		_Deref_out_ PSID *ppSid);
	static HRESULT AddAccessAllowedACEToACL(
		_Inout_ PACL *Acl, 
		_In_ PSID pSid, 
		_In_ DWORD dwAccessMask);
	static HRESULT AddAccessDeniedACEToACL(
		_Inout_ PACL *Acl, 
		_In_ PSID pSid, 
		_In_ DWORD dwAccessMask);
	static HRESULT RemovePrincipalFromACL(
		_In_ PACL Acl, 
		_In_ PSID pSid);
	
ATLPREFAST_SUPPRESS(6387)
	static HRESULT CloneSID(
		_Deref_out_ PSID *ppSIDDest, 
		_In_ PSID pSIDSrc)
	{
		HRESULT hr = S_OK;
		if (ppSIDDest == NULL)
			return E_POINTER;

		*ppSIDDest = NULL;
			
		if (!IsValidSid(pSIDSrc))
		{
			return E_INVALIDARG;			
		}

		DWORD dwSize = GetLengthSid(pSIDSrc);

		*ppSIDDest = (PSID) malloc(dwSize);
		if (*ppSIDDest == NULL)
			return E_OUTOFMEMORY;
		if (!CopySid(dwSize, *ppSIDDest, pSIDSrc))
		{
			hr = AtlHresultFromLastError();
			ATLASSERT(FALSE);
			free(*ppSIDDest);
			*ppSIDDest = NULL;
		}		
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	operator PSECURITY_DESCRIPTOR()
	{
		return m_pSD;
	}

public:
	PSECURITY_DESCRIPTOR m_pSD;
	PSID m_pOwner;
	PSID m_pGroup;
	PACL m_pDACL;
	PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
	m_pSD = NULL;
	m_pOwner = NULL;
	m_pGroup = NULL;
	m_pDACL = NULL;
	m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
	delete m_pSD;
	free(m_pOwner);
	free(m_pGroup);
	free(m_pDACL);
	free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
	delete m_pSD;
	m_pSD = NULL;

	free(m_pOwner);
	m_pOwner = NULL;

	free(m_pGroup);
	m_pGroup = NULL;

	free(m_pDACL);
	m_pDACL = NULL;

	free(m_pSACL);
	m_pSACL = NULL;

	ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
	if (m_pSD != NULL)
	{
		if (InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
			return S_OK;

		HRESULT hr = AtlHresultFromLastError();
		delete m_pSD;
		m_pSD = NULL;
		ATLASSERT(FALSE);
		return hr;
	}

	return E_OUTOFMEMORY;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(_In_ BOOL bDefaulted)
{
	HRESULT hr = Initialize();
	if (SUCCEEDED(hr))
	{
		PSID pUserSid = NULL;
		PSID pGroupSid = NULL;
		hr = GetProcessSids(&pUserSid, &pGroupSid);
		if (SUCCEEDED(hr))
		{
			hr = SetOwner(pUserSid, bDefaulted);
			if (SUCCEEDED(hr))
			{
				hr = SetGroup(pGroupSid, bDefaulted);
			}			
			free(pUserSid);
			free(pGroupSid);
			// If something failed reinitialize the object
			if (FAILED(hr))
				Initialize();
		}
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(
	_In_ BOOL bDefaulted, 
	_In_ BOOL bRevertToProcessToken)
{
	HRESULT hr = Initialize();
	if (SUCCEEDED(hr))
	{
		PSID pUserSid = NULL;
		PSID pGroupSid = NULL;
	
		hr = GetThreadSids(&pUserSid, &pGroupSid);
		if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
			hr = GetProcessSids(&pUserSid, &pGroupSid);
		if (SUCCEEDED(hr))
		{
			hr = SetOwner(pUserSid, bDefaulted);
			if (SUCCEEDED(hr))
				hr = SetGroup(pGroupSid, bDefaulted);
			free(pUserSid);
			free(pGroupSid);
			// If something failed reinitialize the object
			if (FAILED(hr))
				Initialize();
		}
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(
	_In_opt_ PSID pOwnerSid, 
	_In_ BOOL bDefaulted)
{
	ATLASSUME(m_pSD);
	HRESULT hr = S_OK;

	// Mark the SD as having no owner
	if (SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
	{
		free(m_pOwner);
		m_pOwner = NULL;

		// If they asked for no owner don't do the copy
		if (pOwnerSid == NULL)
			return S_OK;

		// Make a copy of the Sid for the return value
		hr = CloneSID(&m_pOwner, pOwnerSid);
		if (SUCCEEDED(hr))
		{
			ATLASSERT(IsValidSid(m_pOwner));

			if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
			{
				hr = AtlHresultFromLastError();
				ATLASSERT(FALSE);
				free(m_pOwner);
				m_pOwner = NULL;
			}
		}
	}
	else
	{
		hr = AtlHresultFromLastError();
		ATLASSERT(FALSE);
	}

	return hr;
}

inline HRESULT CSecurityDescriptor::SetGroup(
	_In_opt_ PSID pGroupSid,
	_In_ BOOL bDefaulted)
{
	ATLASSUME(m_pSD);
	HRESULT hr = S_OK;

	// Mark the SD as having no Group
	if (SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
	{
		free(m_pGroup);
		m_pGroup = NULL;

		// If they asked for no Group don't do the copy
		if (pGroupSid == NULL)
			return S_OK;

		// Make a copy of the Sid for the return value
		hr = CloneSID(&m_pGroup, pGroupSid);
		if (SUCCEEDED(hr))
		{		
			ATLASSERT(IsValidSid(m_pGroup));

			if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
			{
				hr = AtlHresultFromLastError();
				ATLASSERT(FALSE);
				free(m_pGroup);
				m_pGroup = NULL;
			}
		}
	}
	else
	{
		hr = AtlHresultFromLastError();
		ATLASSERT(FALSE);
	}

	return hr;
}

inline HRESULT CSecurityDescriptor::Allow(
	_In_z_ LPCTSTR pszPrincipal, 
	_In_ DWORD dwAccessMask)
{
	PSID pSid;
	HRESULT hr = GetPrincipalSID(pszPrincipal, &pSid);
	if (SUCCEEDED(hr))
	{
		hr = Allow(pSid, dwAccessMask);
		free(pSid);
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::Deny(
	_In_z_ LPCTSTR pszPrincipal, 
	_In_ DWORD dwAccessMask)
{
	PSID pSid;
	HRESULT hr = GetPrincipalSID(pszPrincipal, &pSid);
	if (SUCCEEDED(hr))
	{
		hr = Deny(pSid, dwAccessMask);
		free(pSid);
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(_In_z_ LPCTSTR pszPrincipal)
{
	PSID pSid;
	HRESULT hr = GetPrincipalSID(pszPrincipal, &pSid);
	if (SUCCEEDED(hr))
	{
		hr = Revoke(pSid);
		free(pSid);
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::Allow(
	_In_ PSID pSid, 
	_In_ DWORD dwAccessMask)
{
	HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pSid, dwAccessMask);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
			hr = AtlHresultFromLastError();
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::Deny(
	_In_ PSID pSid, 
	_In_ DWORD dwAccessMask)
{
	HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pSid, dwAccessMask);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
			hr = AtlHresultFromLastError();
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(_In_ PSID pSid)
{
	HRESULT hr = RemovePrincipalFromACL(m_pDACL, pSid);
	if (SUCCEEDED(hr))
	{
		if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
			hr = AtlHresultFromLastError();
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(
	_Out_opt_ PSID* ppUserSid, 
	_Out_opt_ PSID* ppGroupSid)
{
	HRESULT hr = S_OK;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
	{
		hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
		CloseHandle(hToken);
	}
	else
	{
		// Couldn't open process token
		hr = AtlHresultFromLastError();
		ATLASSERT(FALSE);
	}

	return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(
	_Out_opt_ PSID* ppUserSid, 
	_Out_opt_ PSID* ppGroupSid, 
	_In_ BOOL bOpenAsSelf)
{
	HRESULT hr = S_OK;
	HANDLE hToken = NULL;
	if (ppUserSid)
		*ppUserSid = NULL;
	if (ppGroupSid)
		*ppGroupSid = NULL;
	if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken))
	{
		hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
		CloseHandle(hToken);
	} 
	else
		// Couldn't open thread token
		hr = AtlHresultFromLastError();

	return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(
	_In_ HANDLE hToken, 
	_Out_opt_ PSID* ppUserSid, 
	_Out_opt_ PSID* ppGroupSid)
{
	DWORD dwSize = 0;
	HRESULT hr = S_OK;
	if (ppUserSid != NULL)
		*ppUserSid = NULL;
	if (ppGroupSid != NULL)
		*ppGroupSid = NULL;

	if (ppUserSid != NULL)
	{
		PTOKEN_USER ptkUser = NULL;

		// Get length required for TokenUser by specifying buffer length of 0
		GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
		// Expected ERROR_INSUFFICIENT_BUFFER		
		DWORD dwError = GetLastError();
		if (dwError == ERROR_INSUFFICIENT_BUFFER)
		{
			ptkUser = (TOKEN_USER*) malloc(dwSize);
			if (ptkUser != NULL)
			{
				// Get Sid of process token.
				if (GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
				{
					// Make a copy of the Sid for the return value
					hr = CloneSID(ppUserSid, ptkUser->User.Sid);
#ifdef _DEBUG
					if (SUCCEEDED(hr))
					{					
						ATLASSERT(IsValidSid(*ppUserSid));
					}
#endif
				}
				else
					// Couldn't get user info
					hr = AtlHresultFromLastError();

				free(ptkUser);
				ptkUser = NULL;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
		{
			ATLASSERT(FALSE);
			hr = AtlHresultFromWin32(dwError);
		}
	}
	if (SUCCEEDED(hr) && ppGroupSid != NULL)
	{
		PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
		DWORD dwError = GetLastError();
		// Expected ERROR_INSUFFICIENT_BUFFER
		if (dwError == ERROR_INSUFFICIENT_BUFFER)
		{
			ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
			if (ptkGroup != NULL)
			{
				// Get Sid of process token.
				if (GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
				{
					// Make a copy of the Sid for the return value
					hr = CloneSID(ppGroupSid, ptkGroup->PrimaryGroup);
#ifdef _DEBUG					
					if (SUCCEEDED(hr))
					{
						ATLASSERT(IsValidSid(*ppGroupSid));
					}
#endif
				}
				else
					// Couldn't get user info
					hr = AtlHresultFromLastError();

				free(ptkGroup);
				ptkGroup = NULL;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
			hr = AtlHresultFromWin32(dwError);
	}
	if (FAILED(hr))
	{
		if (ppUserSid != NULL)
		{
			free (*ppUserSid);
			*ppUserSid = NULL;
		}
		if (ppGroupSid != NULL)
		{
			free (*ppGroupSid);
			*ppGroupSid = NULL;
		}
	}

	return hr;
}

ATLPREFAST_SUPPRESS(6387)
inline HRESULT CSecurityDescriptor::GetCurrentUserSID(_Deref_out_ PSID *ppSid)
{
	if (ppSid == NULL)
		return E_POINTER;
	*ppSid = NULL;

	HANDLE tkHandle;
	HRESULT hr = S_OK;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
	{
		TOKEN_USER *tkUser = NULL;
		DWORD tkSize;

		// Get length required for TokenPrimaryGroup by specifying buffer length of 0
		GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
		DWORD dwError = GetLastError();
		// Expected ERROR_INSUFFICIENT_BUFFER
		if (dwError == ERROR_INSUFFICIENT_BUFFER)
		{
			tkUser = (TOKEN_USER *) malloc(tkSize);
			if (tkUser != NULL)
			{
				// Now make the real call
				if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
				{
					hr = CloneSID(ppSid, tkUser->User.Sid);
#ifdef _DEBUG					
					if (SUCCEEDED(hr))
					{					
						ATLASSERT(IsValidSid(*ppSid));
					}
#endif
				}
				else
					hr = AtlHresultFromLastError();

				free (tkUser);
				tkUser = NULL;
			}
			else
				hr = E_OUTOFMEMORY;
		}
		else
		{
			hr = AtlHresultFromWin32(dwError);
			ATLASSERT(FALSE);
		}
		CloseHandle(tkHandle);
	}
	else
		hr = AtlHresultFromLastError();
	
	return hr;
}
ATLPREFAST_UNSUPPRESS()

ATLPREFAST_SUPPRESS(6387)
inline HRESULT CSecurityDescriptor::GetPrincipalSID(
	_In_z_ LPCTSTR pszPrincipal, 
	_Deref_out_ PSID *ppSid)
{
	if (ppSid == NULL)
		return E_POINTER;
	if (pszPrincipal == NULL)
		return E_INVALIDARG;
	*ppSid = NULL;

	HRESULT hr;
	LPTSTR pszRefDomain = NULL;
	DWORD dwDomainSize = 0;
	DWORD dwSidSize = 0;
	SID_NAME_USE snu;
	DWORD dwError;

	// Call to get size info for alloc
	LookupAccountName(NULL, pszPrincipal, NULL, &dwSidSize, NULL, &dwDomainSize, &snu);

	dwError = GetLastError();
	if (dwError == ERROR_INSUFFICIENT_BUFFER)
	{
		ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
		if (pszRefDomain != NULL)
		{
			*ppSid = (PSID) malloc(dwSidSize);
			if (*ppSid != NULL)
			{
				if (LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
				{
					hr = S_OK;
				}
				else
				{					
					hr = AtlHresultFromLastError();
					free(*ppSid);
					*ppSid = NULL;
				}
			}
			else
				hr = E_OUTOFMEMORY;
			delete[] pszRefDomain;
		}
		else
			hr = E_OUTOFMEMORY;
	}
	else
		hr = AtlHresultFromWin32(dwError);
	
	return hr;
}
ATLPREFAST_UNSUPPRESS()

inline HRESULT CSecurityDescriptor::Attach(_In_ PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
	PACL    pDACL = NULL;
	PACL    pSACL = NULL;
	BOOL    bDACLPresent, bSACLPresent;
	BOOL    bDefaulted;
	HRESULT hr;
	PSID    pUserSid;
	PSID    pGroupSid;
	
	if (pSelfRelativeSD == NULL || !IsValidSecurityDescriptor(pSelfRelativeSD))
		return E_INVALIDARG;
	
	hr = Initialize();
	if(FAILED(hr))
		return hr;

	// get the existing DACL.
	if (GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
	{
		if (bDACLPresent)
		{
			// pDACL should be valid if bDACLPresent is true
			ATLENSURE_RETURN(pDACL != NULL);
			// allocate new DACL.
			m_pDACL = (PACL) malloc(pDACL->AclSize);
			if (m_pDACL != NULL)
			{
				// initialize the DACL
				if (InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
				{
					// copy the ACL
					hr = CopyACL(m_pDACL, pDACL);
					if (SUCCEEDED(hr) && !IsValidAcl(m_pDACL))
						hr = E_FAIL;
				}
				else
					hr = AtlHresultFromLastError();
			}
			else
				hr = E_OUTOFMEMORY;
		}
		// set the DACL
		if (SUCCEEDED(hr) && !SetSecurityDescriptorDacl(m_pSD, bDACLPresent, m_pDACL, bDefaulted))
			hr = AtlHresultFromLastError();
	}
	else
		hr = AtlHresultFromLastError();

	// get the existing SACL.
	if (SUCCEEDED(hr) && GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
	{
		if (bSACLPresent)
		{
			// pSACL should be valid if bSACLPresent is true
			ATLENSURE_RETURN(pSACL != NULL);
			// allocate new SACL.
			m_pSACL = (PACL) malloc(pSACL->AclSize);
			if (m_pSACL != NULL)
			{
				// initialize the SACL
				if (InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
				{
					// copy the ACL
					hr = CopyACL(m_pSACL, pSACL);
					if (SUCCEEDED(hr) && !IsValidAcl(m_pSACL))
						hr = E_FAIL;
				}
				else
					hr = AtlHresultFromLastError();
			}
			else
				hr = E_OUTOFMEMORY;
		}
		// set the SACL
		if (SUCCEEDED(hr) && !SetSecurityDescriptorSacl(m_pSD, bSACLPresent, m_pSACL, bDefaulted))
			hr = AtlHresultFromLastError();
	}
	else if (SUCCEEDED(hr))
		hr = AtlHresultFromLastError();
	
	if (SUCCEEDED(hr))
	{
		if (GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
		{
			if (SUCCEEDED(hr = SetOwner(pUserSid, bDefaulted)))
			{
				if (GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
				{
					if (SUCCEEDED(hr = SetGroup(pGroupSid, bDefaulted)))
					{
						if (!IsValidSecurityDescriptor(m_pSD))
							hr = E_FAIL;
					}
				}
				else
					hr = AtlHresultFromLastError();
			}
		}
		else
			hr = AtlHresultFromLastError();
	}

	if (FAILED(hr))
	{
		free(m_pDACL);
		m_pDACL = NULL;

		free(m_pSACL);
		m_pSACL = NULL;

		delete m_pSD;
	 	m_pSD = NULL;
	}

	return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(_In_ HANDLE hObject)
{
	HRESULT hr;
	DWORD dwError;
	DWORD dwSize = 0;
	PSECURITY_DESCRIPTOR pSD = NULL;

ATLPREFAST_SUPPRESS(6309 6387)
	/* prefast noise VSW 497702 */
	GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION, NULL, 0, &dwSize);
ATLPREFAST_UNSUPPRESS()

	dwError = GetLastError();
	if (dwError != ERROR_INSUFFICIENT_BUFFER)
		return AtlHresultFromWin32(dwError);

	pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
	if (pSD != NULL)
	{
		if (GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
			DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))

			hr = Attach(pSD);
		else
			hr = AtlHresultFromLastError();
		free(pSD);
	}
	else
		hr = E_OUTOFMEMORY;

	return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(
	_Out_ PACL pDest, 
	_In_opt_ PACL pSrc)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	LPVOID pAce;
	ACE_HEADER *aceHeader;

	if (pDest == NULL)
		return E_POINTER;

	if (pSrc == NULL)
		return S_OK;

	if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		return AtlHresultFromLastError();

	// Copy all of the ACEs to the new ACL
	for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
	{
		if (!GetAce(pSrc, i, &pAce))
			return AtlHresultFromLastError();

		aceHeader = (ACE_HEADER *) pAce;

		if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
			return AtlHresultFromLastError();
	}

	return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(
	_Inout_ PACL *ppAcl, 
	_In_ PSID pSid, 
	_In_ DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	PACL oldACL, newACL = NULL;
	HRESULT hr = S_OK;

	if (ppAcl == NULL)
		return E_POINTER;

	oldACL = *ppAcl;
	
	if (pSid == NULL || !IsValidSid(pSid))
		return E_INVALIDARG;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL && !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		hr = AtlHresultFromLastError();

	if (SUCCEEDED(hr))
	{
		aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_DENIED_ACE) + GetLengthSid(pSid) - sizeof(DWORD);
		newACL = (PACL) malloc(aclSize);
		if (newACL != NULL)
		{
			if (InitializeAcl(newACL, aclSize, ACL_REVISION))
			{
				// access denied ACEs should be before access allowed ACEs
				if (AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, pSid))
				{
					// Copy existing ACEs to the new ACL
					hr = CopyACL(newACL, oldACL);
					if (SUCCEEDED(hr))
					{
						*ppAcl = newACL;
						free(oldACL);
					}
				}
				else
					hr = AtlHresultFromLastError();
			}
			else
				hr = AtlHresultFromLastError();

			if (FAILED(hr))
				free(newACL);
		}
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(
	_Inout_ PACL *ppAcl, 
	_In_ PSID pSid, 
	_In_ DWORD dwAccessMask)
{
	ACL_SIZE_INFORMATION aclSizeInfo;
	int aclSize;
	HRESULT hr = S_OK;
	PACL oldACL, newACL = NULL;

	if (ppAcl == NULL)
		return E_POINTER;

	oldACL = *ppAcl;
	
	if (pSid == NULL || !IsValidSid(pSid))
		return E_INVALIDARG;

	aclSizeInfo.AclBytesInUse = 0;
	if (*ppAcl != NULL && !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
		hr = AtlHresultFromLastError();

	if (SUCCEEDED(hr))
	{
		aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSid) - sizeof(DWORD);
		newACL = (PACL) malloc(aclSize);
		if (newACL != NULL)
		{
			if (InitializeAcl(newACL, aclSize, ACL_REVISION))
			{
				// Copy existing ACEs
				hr = CopyACL(newACL, oldACL);
				if (SUCCEEDED(hr))
				{
					// Add access Allowed ACEs after all other existing ACEs (possibly access denied ACEs)
					if (AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, pSid))
					{
						*ppAcl = newACL;
						free(oldACL);
					}
					else
						hr = AtlHresultFromLastError();
				}
			}
			else
				hr = AtlHresultFromLastError();

			if (FAILED(hr))
				free(newACL);
		}
		else
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(
	_In_ PACL pAcl, 
	_In_ PSID principalSID)
{
	if (pAcl == NULL || principalSID == NULL || !IsValidSid(principalSID))
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	ACL_SIZE_INFORMATION aclSizeInfo;
	if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
	{
		hr = AtlHresultFromLastError();
		aclSizeInfo.AceCount = 0;
	}
		
	for (ULONG i = aclSizeInfo.AceCount; i > 0; i--)
	{
		ULONG uIndex = i - 1;
		LPVOID ace;	
		if (!GetAce(pAcl, uIndex, &ace))
		{
			hr = AtlHresultFromLastError();
			break;
		}

		ACE_HEADER *aceHeader = (ACE_HEADER *) ace;

		if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
		{
			ACCESS_ALLOWED_ACE *accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		} 
		else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
		{
			ACCESS_DENIED_ACE *accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		} 
		else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
		{
			SYSTEM_AUDIT_ACE *systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;
			if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
			{
				DeleteAce(pAcl, uIndex);
			}
		}
	}
	return hr;
}

inline HRESULT CSecurityDescriptor::SetPrivilege(
	_In_z_ LPCTSTR privilege, 
	_In_ BOOL bEnable, 
	_In_ HANDLE hToken)
{
	TOKEN_PRIVILEGES tpPrevious;
	TOKEN_PRIVILEGES tp;
	DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
	LUID   luid;
	HANDLE hTokenUsed;

	if (!LookupPrivilegeValue(NULL, privilege, &luid ))
		goto _Error;

	// if no token specified open process token
	if (hToken != 0)
		hTokenUsed = hToken;
	else
		if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
			goto _Error;

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = 0;

	memset(&tpPrevious, 0, sizeof(tpPrevious));

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
		goto _Error_CloseHandle;

	tpPrevious.PrivilegeCount = 1;
	tpPrevious.Privileges[0].Luid = luid;

	if (bEnable)
		tpPrevious.Privileges[0].Attributes |= SE_PRIVILEGE_ENABLED;
	else
		tpPrevious.Privileges[0].Attributes &= ~SE_PRIVILEGE_ENABLED;

	if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
		goto _Error_CloseHandle;

	if(hToken == 0)
		CloseHandle(hTokenUsed);

	return S_OK;

	HRESULT hr;

_Error:
	hr = AtlHresultFromLastError();
	return hr;

_Error_CloseHandle:
	hr = AtlHresultFromLastError();
	if (hToken == 0)
		CloseHandle(hTokenUsed);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

ATLPREFAST_SUPPRESS(6387)
template <class T1>
class CComCreator
{
public:
	_Success_(return == S_OK) static HRESULT WINAPI CreateInstance(
		_In_opt_ void* pv, 
		_In_ REFIID riid, 
		_Deref_out_ LPVOID* ppv)
	{
		ATLASSERT(ppv != NULL);
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;

ATLPREFAST_SUPPRESS(6014)
		/* prefast noise VSW 489981 */
		ATLTRY(p = new T1(pv))
ATLPREFAST_UNSUPPRESS()

		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};
ATLPREFAST_UNSUPPRESS()

template <class T1>
class CComInternalCreator
{
public:
	static HRESULT WINAPI CreateInstance(
		_In_opt_ void* pv, 
		_In_ REFIID riid, 
		_Deref_out_ LPVOID* ppv)
	{
		ATLASSERT(ppv != NULL);
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;

ATLPREFAST_SUPPRESS(6014)
		ATLTRY(p = new T1(pv))
ATLPREFAST_UNSUPPRESS()

		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->_InternalQueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(
		_In_opt_ void*, 
		_In_ REFIID, 
		_Deref_out_opt_ LPVOID* ppv)
	{
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;

		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(
		_In_opt_ void* pv, 
		_In_ REFIID riid, 
		_Deref_out_ LPVOID* ppv)
	{
		ATLASSERT(ppv != NULL);

		return (pv == NULL) ? 
			T1::CreateInstance(NULL, riid, ppv) : 
			T2::CreateInstance(pv, riid, ppv);
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComCreator< ATL::CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator2< ATL::CComFailCreator<E_FAIL>, ATL::CComCreator< ATL::CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator< ATL::CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD_PTR dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
	static HRESULT WINAPI CreateInstance(
		_In_ void* pv, 
		_In_ REFIID/*riid*/, 
		_Deref_out_ LPVOID* ppv) throw()
	{
		// Only Assert here. CoCreateInstance will return the correct HRESULT if ppv == NULL
		ATLASSERT(ppv != NULL && *ppv == NULL);

		ATLASSERT(pv != NULL);
		if (pv == NULL)
			return E_INVALIDARG;

		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, __uuidof(IUnknown), ppv);
	}
};

#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD_PTR)_T(#x), \
		(ATL::_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#define _ATL_DECLARE_GET_UNKNOWN(x)\
	IUnknown* GetUnknown() throw() \
	{ \
		IUnknown* p; \
		ATL::_AtlDebugInterfacesModule.AddNonAddRefThunk(_GetRawUnknown(), _T(#x), &p); \
		return p; \
	}
#else
#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() throw() {return _GetRawUnknown();}
#endif

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(_In_ void* pv, _In_ REFIID iid, _Deref_out_ void** ppvObject, _In_ DWORD_PTR dw) throw()\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = E_FAIL; \
		__try \
		{ \
			hRes = ATL::CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		} \
		__finally \
		{ \
			p->Unlock();\
		} \
		return hRes;\
	}\
	IUnknown* _GetRawUnknown() throw() \
	{ ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((INT_PTR)this+_GetEntries()->dw); } \
	_ATL_DECLARE_GET_UNKNOWN(x)\
	HRESULT _InternalQueryInterface( \
		_In_ REFIID iid, \
		_Deref_out_ void** ppvObject) throw() \
	{ \
		return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); \
	} \
	const static ATL::_ATL_INTMAP_ENTRY* WINAPI _GetEntries() throw() { \
	static const ATL::_ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

// For use by attributes for chaining to existing COM_MAP
#define BEGIN_ATTRCOM_MAP(x) public: \
	typedef x _AttrComMapClass; \
	const static ATL::_ATL_INTMAP_ENTRY* WINAPI _GetAttrEntries() throw() { \
	static const ATL::_ATL_INTMAP_ENTRY _entries[] = {

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() throw() {return GetUnknown();}

#define COM_INTERFACE_ENTRY_BREAK(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_NoInterface},

#define COM_INTERFACE_ENTRY(x)\
	{&_ATL_IIDOF(x), \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	_ATL_SIMPLEMAPENTRY},

// The impl macros are now obsolete
#define COM_INTERFACE_ENTRY_IMPL(x)\
	COM_INTERFACE_ENTRY_IID(_ATL_IIDOF(x), x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
	COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)
//

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&_ATL_IIDOF(x),\
	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(8))))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(8))))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD_PTR)&ATL::_CComCreatorData<\
		ATL::CComInternalCreator< ATL::CComTearOffObject< x > >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
	{&iid,\
	(DWORD_PTR)&ATL::_CComCacheData<\
		ATL::CComCreator< ATL::CComCachedTearOffObject< x > >,\
		(DWORD_PTR)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	(DWORD_PTR)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	(DWORD_PTR)offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
	{&iid,\
	(DWORD_PTR)&ATL::_CComCacheData<\
		ATL::CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD_PTR)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
	{NULL,\
	(DWORD_PTR)&ATL::_CComCacheData<\
		ATL::CComAggregateCreator<_ComMapClass, &clsid>,\
		(DWORD_PTR)offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD_PTR)&ATL::_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#ifdef _ATL_DEBUG
#define END_COM_MAP() \
	__if_exists(_GetAttrEntries) {{NULL, (DWORD_PTR)_GetAttrEntries, _ChainAttr }, }\
	{NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef(void) throw() = 0; \
	virtual ULONG STDMETHODCALLTYPE Release(void) throw() = 0; \
	STDMETHOD(QueryInterface)( \
		_In_ REFIID, \
		_Deref_out_ void**) throw() = 0;
#else
#define END_COM_MAP() \
	__if_exists(_GetAttrEntries) {{NULL, (DWORD_PTR)_GetAttrEntries, _ChainAttr }, }\
	{NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef(void) throw() = 0; \
	virtual ULONG STDMETHODCALLTYPE Release(void) throw() = 0; \
	STDMETHOD(QueryInterface)( \
		_In_ REFIID, \
		_Deref_out_ void**) throw() = 0;
#endif // _ATL_DEBUG

#define END_ATTRCOM_MAP() \
	{NULL, 0, 0}}; return _entries;} 


#define BEGIN_CATEGORY_MAP(x)\
	static const struct ATL::_ATL_CATMAP_ENTRY* GetCategoryMap() throw() {\
	static const struct ATL::_ATL_CATMAP_ENTRY pMap[] = {
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },
#define REQUIRED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_REQUIRED, &catid },
#define END_CATEGORY_MAP()\
   { _ATL_CATMAP_ENTRY_END, NULL } };\
   return( pMap ); }

#define BEGIN_OBJECT_MAP(x) static ATL::_ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE(class) {&CLSID_NULL, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE_EX(clsid, class) {&clsid, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },

#ifndef OBJECT_ENTRY_PRAGMA

#if defined(_M_IX86)
#define OBJECT_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:___pobjMap_" #class));
#elif defined(_M_IA64)
#define OBJECT_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pobjMap_" #class));
#elif defined(_M_AMD64)
#define OBJECT_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pobjMap_" #class));
#else
#error Unknown Platform. define OBJECT_ENTRY_PRAGMA
#endif

#endif	//OBJECT_ENTRY_PRAGMA

#define OBJECT_ENTRY_AUTO(clsid, class) \
	__declspec(selectany) ATL::_ATL_OBJMAP_ENTRY __objMap_##class = {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain }; \
	extern "C" __declspec(allocate("ATL$__m")) __declspec(selectany) ATL::_ATL_OBJMAP_ENTRY* const __pobjMap_##class = &__objMap_##class; \
	OBJECT_ENTRY_PRAGMA(class)


#define OBJECT_ENTRY_NON_CREATEABLE_EX_AUTO(clsid, class) \
	__declspec(selectany) ATL::_ATL_OBJMAP_ENTRY __objMap_##class = {&clsid, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain }; \
	extern "C" __declspec(allocate("ATL$__m")) __declspec(selectany) ATL::_ATL_OBJMAP_ENTRY* const __pobjMap_##class = &__objMap_##class; \
	OBJECT_ENTRY_PRAGMA(class)

// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	~CComObjectRootBase()
	{
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	// For library initialization only
	HRESULT _AtlFinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() 
	{
	}
	void _AtlFinalRelease() // temp
	{
	}		

	void _HRPass(_In_ HRESULT hr)		// temp 
	{
		(hr);
	}

	void _HRFail(_In_ HRESULT hr)		// temp...
	{
		(hr);
	}


	//ObjectMain is called during Module::Init and Module::Term
	static void WINAPI ObjectMain(_In_ bool /* bStarting */);

	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() 
	{
		return NULL;
	}
	static HRESULT WINAPI InternalQueryInterface(
		_Inout_ void* pThis,
		_In_ const _ATL_INTMAP_ENTRY* pEntries, 		
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject)
	{
		// Only Assert here. AtlInternalQueryInterface will return the correct HRESULT if ppvObject == NULL
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
		ATLASSERT(ppvObject != NULL);
#endif
		ATLASSERT(pThis != NULL);
		// First entry in the com map should be a simple map entry
		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
	#endif // _ATL_DEBUG_INTERFACES
		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
	#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
	#endif // _ATL_DEBUG_INTERFACES
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
	ULONG OuterAddRef()
	{
		return m_pOuterUnknown->AddRef();
	}
	ULONG OuterRelease()
	{
		return m_pOuterUnknown->Release();
	}
	HRESULT OuterQueryInterface(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(_In_opt_ void*) 
	{
	}
	void InternalFinalConstructAddRef() 
	{
	}
	void InternalFinalConstructRelease()
	{
		ATLASSUME(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Break(
		_In_opt_ void* /* pv */, 
		_In_ REFIID iid, 
		_In_opt_ void** /* ppvObject */, 
		_In_ DWORD_PTR /* dw */)
	{
		(iid);
		_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
		DebugBreak();
		return S_FALSE;
	}
	static HRESULT WINAPI _NoInterface(
		_In_opt_ void* /* pv */, 
		_In_ REFIID /* iid */, 
		_In_opt_ void** /* ppvObject */, 
		_In_ DWORD_PTR /* dw */)
	{
		return E_NOINTERFACE;
	}
	static HRESULT WINAPI _Creator(
		_In_ void* pv, 
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject, 
		_In_ DWORD_PTR dw)
	{
		_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
		return pcd->pFunc(pv, iid, ppvObject);
	}
	static HRESULT WINAPI _Delegate(
		_In_ void* pv, 
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject, 
		_In_ DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
		if (p != NULL)
			hRes = p->QueryInterface(iid, ppvObject);
		return hRes;
	}
	static HRESULT WINAPI _Chain(
		_In_ void* pv, 
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject, 
		_In_ DWORD_PTR dw)
	{
		_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
		void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
		return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
	}
	static HRESULT WINAPI _ChainAttr(
		_In_ void* pv, 
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject, 
		_In_ DWORD_PTR dw)
	{
		const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)() = (const _ATL_INTMAP_ENTRY* (WINAPI *)())dw;
		const _ATL_INTMAP_ENTRY *pEntries = pFunc();
		if (pEntries == NULL)
			return S_OK;
		return InternalQueryInterface(pv, pEntries, iid, ppvObject);
	}
	static HRESULT WINAPI _Cache(
		_In_ void* pv, 
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject, 
		_In_ DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, __uuidof(IUnknown), (void**)pp);
		if (*pp != NULL)
			hRes = (*pp)->QueryInterface(iid, ppvObject);
		return hRes;
	}

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

#pragma managed(push, off)
inline void WINAPI CComObjectRootBase::ObjectMain(_In_ bool /* bStarting */)
{
}
#pragma managed(pop)


//foward declaration
template <class ThreadModel>
class CComObjectRootEx;

template <class ThreadModel>
class CComObjectLockT
{
public:
	CComObjectLockT(_Inout_opt_ CComObjectRootEx<ThreadModel>* p)
	{
		if (p)
			p->Lock();
		m_p = p;
	}

	~CComObjectLockT()
	{
		if (m_p)
			m_p->Unlock();
	}
	CComObjectRootEx<ThreadModel>* m_p;
};

template <> class CComObjectLockT<CComSingleThreadModel>;

template <class ThreadModel>
class CComObjectRootEx : 
	public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef typename _ThreadModel::AutoCriticalSection _CritSec;
	typedef typename _ThreadModel::AutoDeleteCriticalSection _AutoDelCritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	~CComObjectRootEx() 
	{
	}

	ULONG InternalAddRef()
	{
		ATLASSUME(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
#ifdef _DEBUG
		LONG nRef = _ThreadModel::Decrement(&m_dwRef);
		if (nRef < -(LONG_MAX / 2))
		{
			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));
		}
		return nRef;
#else
		return _ThreadModel::Decrement(&m_dwRef);
#endif
	}

	HRESULT _AtlInitialConstruct()
	{
		return m_critsec.Init();
	}
	void Lock() 
	{
		m_critsec.Lock();
	}
	void Unlock() 
	{
		m_critsec.Unlock();
	}
private:
	_AutoDelCritSec m_critsec;
};

template <>
class CComObjectRootEx<CComSingleThreadModel> : 
	public CComObjectRootBase
{
public:
	typedef CComSingleThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef _ThreadModel::AutoDeleteCriticalSection _AutoDelCritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	~CComObjectRootEx() {}

	ULONG InternalAddRef()
	{
		ATLASSUME(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
#ifdef _DEBUG
		long nRef = _ThreadModel::Decrement(&m_dwRef);
		if (nRef < -(LONG_MAX / 2))
		{
			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));
		}
		return nRef;
#else
		return _ThreadModel::Decrement(&m_dwRef);
#endif	
	}

	HRESULT _AtlInitialConstruct()
	{
		return S_OK;
	}

	void Lock() 
	{
	}
	void Unlock() 
	{
	}
};

template <>
class CComObjectLockT<CComSingleThreadModel>
{
public:
	CComObjectLockT(_Inout_opt_ CComObjectRootEx<CComSingleThreadModel>*) 
	{
	}
	~CComObjectLockT() 
	{
	}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(ATL::CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
	static LPCTSTR WINAPI GetObjectDescription() throw()\
	{\
		return _T(x);\
	}

#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(_In_ BOOL /*bRegister*/) throw()\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
	{\
		__if_exists(_GetMiscStatus) \
		{ \
			ATL::_ATL_REGMAP_ENTRY regMapEntries[2]; \
			memset(&regMapEntries[1], 0, sizeof(ATL::_ATL_REGMAP_ENTRY)); \
			regMapEntries[0].szKey = L"OLEMISC"; \
			TCHAR szOleMisc[32]; \
			ATL::Checked::itot_s(_GetMiscStatus(), szOleMisc, _countof(szOleMisc), 10); \
			USES_CONVERSION_EX; \
			regMapEntries[0].szData = T2OLE_EX(szOleMisc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD); \
			if (regMapEntries[0].szData == NULL) \
				return E_OUTOFMEMORY; \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(_T(#x), bRegister, regMapEntries); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(_T(#x), bRegister, regMapEntries); \
			} \
		} \
		__if_not_exists(_GetMiscStatus) \
		{ \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(_T(#x), bRegister); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(_T(#x), bRegister); \
			} \
		} \
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(_In_ BOOL bRegister) throw()\
	{\
		__if_exists(_GetMiscStatus) \
		{ \
			ATL::_ATL_REGMAP_ENTRY regMapEntries[2]; \
			memset(&regMapEntries[1], 0, sizeof(ATL::_ATL_REGMAP_ENTRY)); \
			regMapEntries[0].szKey = L"OLEMISC"; \
			TCHAR szOleMisc[32]; \
			ATL::Checked::itot_s(_GetMiscStatus(), szOleMisc, _countof(szOleMisc), 10); \
			USES_CONVERSION_EX; \
			regMapEntries[0].szData = T2OLE_EX(szOleMisc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD); \
			if (regMapEntries[0].szData == NULL) \
				return E_OUTOFMEMORY; \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(x, bRegister, regMapEntries); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister, regMapEntries); \
			} \
		} \
		__if_not_exists(_GetMiscStatus) \
		{ \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(x, bRegister); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister); \
			} \
		} \
	}

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

#define DECLARE_OLEMISC_STATUS(x) \
	static DWORD _GetMiscStatus() throw() \
	{ \
		static DWORD m_dwOleMisc = x; \
		return m_dwOleMisc; \
	}

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : 
	public CComObjectRootEx<ThreadModel>
{
public:
	typedef Owner _OwnerClass;
	Owner* m_pOwner;
	CComTearOffObjectBase() 
	{
		m_pOwner = NULL;
	}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : 
	public Base
{
public:
	typedef Base _BaseClass;
	CComObject(_In_opt_ void* = NULL) throw()
	{
		_pAtlModule->Lock();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComObject() throw()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_pAtlModule->Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return _InternalQueryInterface(iid, ppvObject);
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(
		_Deref_out_ Q** pp) throw()
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(_Deref_out_ CComObject<Base>** pp) throw();
};

ATLPREFAST_SUPPRESS(6387)
template <class Base>
_Success_(return == S_OK) HRESULT WINAPI CComObject<Base>::CreateInstance(
	_Deref_out_ CComObject<Base>** pp) throw()
{
	ATLASSERT(pp != NULL);
	if (pp == NULL)
		return E_POINTER;
	*pp = NULL;

	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->_AtlInitialConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->FinalConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->_AtlFinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;	
	return hRes;
}
ATLPREFAST_UNSUPPRESS()

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : 
	public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(_In_opt_ void* = NULL)
	{
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComObjectCached()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() throw()
	{
		ULONG l = InternalAddRef();
		if (l == 2)
			_pAtlModule->Lock();
		return l;
	}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		else if (l == 1)
			_pAtlModule->Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return _InternalQueryInterface(iid, ppvObject);
	}
	static HRESULT WINAPI CreateInstance(
		_Deref_out_ CComObjectCached<Base>** pp) throw();
};

ATLPREFAST_SUPPRESS(6387)
template <class Base>
_Success_(return == S_OK) HRESULT WINAPI CComObjectCached<Base>::CreateInstance(
	_Deref_out_ CComObjectCached<Base>** pp) throw()
{
	ATLASSERT(pp != NULL);
	if (pp == NULL)
		return E_POINTER;
	*pp = NULL;

	HRESULT hRes = E_OUTOFMEMORY;
	CComObjectCached<Base>* p = NULL;
	ATLTRY(p = new CComObjectCached<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->_AtlInitialConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->FinalConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->_AtlFinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}
ATLPREFAST_UNSUPPRESS()


//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock :
	public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(_In_opt_ void* = NULL)
	{
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds

	virtual ~CComObjectNoLock()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() throw() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return _InternalQueryInterface(iid, ppvObject);
	}
};


// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide _InternalQueryInterface
template <class Base>
class CComObjectGlobal :
	public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(_In_opt_ void* = NULL)
	{
		m_hResFinalConstruct = S_OK;
		__if_exists(FinalConstruct)
		{
			__if_exists(InternalFinalConstructAddRef)
			{
				InternalFinalConstructAddRef();
			}
			m_hResFinalConstruct = _AtlInitialConstruct();
			if (SUCCEEDED(m_hResFinalConstruct))
				m_hResFinalConstruct = FinalConstruct();
			__if_exists(InternalFinalConstructRelease)
			{
				InternalFinalConstructRelease();
			}
		}
	}
	virtual ~CComObjectGlobal()
	{
		__if_exists(FinalRelease)
		{
			FinalRelease();
		}
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	STDMETHOD_(ULONG, AddRef)() throw()
	{
		return _pAtlModule->Lock();
	}
	STDMETHOD_(ULONG, Release)() throw()
	{
		return _pAtlModule->Unlock();
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return _InternalQueryInterface(iid, ppvObject);
	}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : 
	public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(_In_opt_ void* = NULL)
	{
		m_hResFinalConstruct = _AtlInitialConstruct();
		if (SUCCEEDED(m_hResFinalConstruct))
			m_hResFinalConstruct = FinalConstruct();
	}
	virtual ~CComObjectStack()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	
	STDMETHOD_(ULONG, AddRef)() throw() 
	{
		ATLASSERT(FALSE);
		return 0;
	}
	STDMETHOD_(ULONG, Release)() throw() 
	{
		ATLASSERT(FALSE);
		return 0;
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID, 
		_In_opt_ void**) throw()
	{
		ATLASSERT(FALSE);
		return E_NOINTERFACE;
	}
	HRESULT m_hResFinalConstruct;
};

// Base must be derived from CComObjectRoot
template <class Base>
class CComObjectStackEx : 
	public Base
{
public:
	typedef Base _BaseClass;

	CComObjectStackEx(_In_opt_ void* = NULL) 
	{ 
#ifdef _DEBUG
		m_dwRef = 0;
#endif
		m_hResFinalConstruct = _AtlInitialConstruct();
		if (SUCCEEDED(m_hResFinalConstruct))
			m_hResFinalConstruct = FinalConstruct(); 
	}

	virtual ~CComObjectStackEx()
	{
		// This assert indicates mismatched ref counts.
		//
		// The ref count has no control over the
		// lifetime of this object, so you must ensure
		// by some other means that the object remains 
		// alive while clients have references to its interfaces.
		ATLASSUME(m_dwRef == 0);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	STDMETHOD_(ULONG, AddRef)() throw()
	{
#ifdef _DEBUG
		return InternalAddRef();
#else
		return 0;
#endif
	}

	STDMETHOD_(ULONG, Release)() throw()
	{
#ifdef _DEBUG
		return InternalRelease();
#else
		return 0;
#endif
	}

	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return _InternalQueryInterface(iid, ppvObject);
	}

	HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : 
	public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(_In_opt_ void* pv) 
	{
		m_pOuterUnknown = (IUnknown*)pv;
	}
#ifdef _ATL_DEBUG_INTERFACES
	virtual ~CComContainedObject()
	{
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(m_pOuterUnknown);
	}
#endif

	STDMETHOD_(ULONG, AddRef)() throw() 
	{
		return OuterAddRef();
	}
	STDMETHOD_(ULONG, Release)() throw() 
	{
		return OuterRelease();
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return OuterQueryInterface(iid, ppvObject);
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(
		_Deref_out_ Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown() throw()
	{
#ifdef _ATL_DEBUG_INTERFACES
		IUnknown* p;
		_AtlDebugInterfacesModule.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
		return p;
#else
		return m_pOuterUnknown;
#endif
	}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(_In_opt_ void* pv) : 
		m_contained(pv)
	{
		_pAtlModule->Lock();
	}
	HRESULT _AtlInitialConstruct()
	{
		HRESULT hr = m_contained._AtlInitialConstruct();
		if (SUCCEEDED(hr))
		{
			hr = CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >::_AtlInitialConstruct();
		}
		return hr;
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComAggObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
#endif
		_pAtlModule->Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject)
	{
		ATLASSERT(ppvObject != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(_Deref_out_ Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(
		_Inout_opt_ LPUNKNOWN pUnkOuter, 
		_Deref_out_ CComAggObject<contained>** pp)
	{
		ATLASSERT(pp != NULL);
		if (pp == NULL)
			return E_POINTER;
		*pp = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		CComAggObject<contained>* p = NULL;
		ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated
template <class contained>
class CComPolyObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComPolyObject(_In_opt_ void* pv) : m_contained(pv ? pv : this)
	{
		_pAtlModule->Lock();
	}
	HRESULT _AtlInitialConstruct()
	{
		HRESULT hr = m_contained._AtlInitialConstruct();
		if (SUCCEEDED(hr))
		{
			hr = CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >::_AtlInitialConstruct();
		}
		return hr;
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		InternalAddRef();
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		HRESULT hr = m_contained.FinalConstruct();
		InternalRelease();
		return hr;
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComPolyObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
#endif
		_pAtlModule->Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject)
	{
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
		ATLASSERT(ppvObject != NULL);
#endif
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
ATLPREFAST_SUPPRESS(6387)
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(_Deref_out_ Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	
	_Success_(return == S_OK) static HRESULT WINAPI CreateInstance(
		_Inout_opt_ LPUNKNOWN pUnkOuter, 
		_Deref_out_ CComPolyObject<contained>** pp)
	{
		ATLASSERT(pp != NULL);
		if (pp == NULL)
			return E_POINTER;
		*pp = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		CComPolyObject<contained>* p = NULL;
		ATLTRY(p = new CComPolyObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->_AtlInitialConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;		
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : 
	public Base
{
public:
	CComTearOffObject(_In_ void* pv)
	{
		ATLASSUME(m_pOwner == NULL);
		m_pOwner = reinterpret_cast<Base::_OwnerClass*>(pv);
		m_pOwner->AddRef();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComTearOffObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		m_pOwner->Release();
	}

	STDMETHOD_(ULONG, AddRef)() throw() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject) throw()
	{
		return m_pOwner->QueryInterface(iid, ppvObject);
	}
};

template <class contained>
class CComCachedTearOffObject :
	public IUnknown,
	public CComObjectRootEx<typename contained::_ThreadModel::ThreadModelNoCS>
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(_In_ void* pv) :
		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
	{
		ATLASSUME(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<contained::_OwnerClass*>(pv);
	}
	HRESULT _AtlInitialConstruct()
	{
		HRESULT hr = m_contained._AtlInitialConstruct();
		if (SUCCEEDED(hr))
		{
			hr = CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >::_AtlInitialConstruct();
		}
		return hr;
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	virtual ~CComCachedTearOffObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_AtlDebugInterfacesModule.DeleteNonAddRefThunk(this);
#endif
	}

	STDMETHOD_(ULONG, AddRef)() 
	{
		return InternalAddRef();
	}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(
		_In_ REFIID iid, 
		_Deref_out_ void** ppvObject)
	{
		ATLASSERT(ppvObject != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};


class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	virtual ~CComClassFactory()
	{
	}

ATLPREFAST_SUPPRESS(6387)
	// IClassFactory
	STDMETHOD(CreateInstance)(
		_Inout_opt_ LPUNKNOWN pUnkOuter, 
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObj)
	{
		ATLASSUME(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// can't ask for anything other than IUnknown when aggregating

			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			{
				ATLTRACE(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
				hRes = CLASS_E_NOAGGREGATION;
			}
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
		}
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(LockServer)(_In_ BOOL fLock)
	{
		if (fLock)
			_pAtlModule->Lock();
		else
			_pAtlModule->Unlock();
		return S_OK;
	}
	// helper
	void SetVoid(_In_opt_ void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : 
	public IClassFactory2,
	public CComObjectRootEx<CComGlobalsThreadModel>,
	public license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
BEGIN_COM_MAP(CComClassFactory2<license>)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(_In_ BOOL fLock)
	{
		if (fLock)
			_pAtlModule->Lock();
		else
			_pAtlModule->Unlock();
		return S_OK;
	}
	STDMETHOD(CreateInstance)(
		_Inout_opt_ LPUNKNOWN pUnkOuter,
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObj)
	{
		ATLASSUME(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(
		_Inout_opt_ IUnknown* pUnkOuter, 
		_In_opt_ IUnknown* /* pUnkReserved */, 
		_In_ REFIID riid, 
		_In_z_ BSTR bstrKey, 
		_Deref_out_ void** ppvObject)
	{
		ATLASSUME(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(
		_In_ DWORD dwReserved, 
		_Deref_out_z_ BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(_Out_ LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
	void SetVoid(_In_ void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory
class CComClassFactoryAutoThread :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactoryAutoThread)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	virtual ~CComClassFactoryAutoThread()
	{
	}
	
	// helper
	void SetVoid(_In_ void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}

ATLPREFAST_SUPPRESS(6387)
	STDMETHODIMP CreateInstance(
		_In_opt_ LPUNKNOWN pUnkOuter,
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObj)
	{
		ATLASSUME(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// cannot aggregate across apartments
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				ATLASSERT(_pAtlAutoThreadModule && _T("Global instance of CAtlAutoThreadModule not declared"));
				if (_pAtlAutoThreadModule == NULL)
					return E_FAIL;

				hRes = _pAtlAutoThreadModule->CreateInstance(m_pfnCreateInstance, riid, ppvObj);
			}
		}		
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHODIMP LockServer(_In_ BOOL fLock)
	{
		if (fLock)
			_pAtlModule->Lock();
		else
			_pAtlModule->Unlock();
		return S_OK;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};


/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : 
	public CComClassFactory
{
public:
	CComClassFactorySingleton() : m_hrCreate(S_OK)
	{
	}
	virtual ~CComClassFactorySingleton()
	{
	}
	// IClassFactory
	STDMETHOD(CreateInstance)(
		_In_opt_ LPUNKNOWN pUnkOuter, 
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				if (m_hrCreate == S_OK && m_spObj == NULL)
				{
					__try
					{
						Lock();
						// Did another thread get here first?
						if (m_hrCreate == S_OK && m_spObj == NULL)
						{
							CComObjectCached<T> *p;
							m_hrCreate = CComObjectCached<T>::CreateInstance(&p);
							if (SUCCEEDED(m_hrCreate))
							{
								m_hrCreate = p->QueryInterface(IID_IUnknown, (void**)&m_spObj);
								if (FAILED(m_hrCreate))
								{
									delete p;
								}
							}
						}
					}
					__finally
					{
						Unlock();
					}
				}
				if (m_hrCreate == S_OK)
				{
					hRes = m_spObj->QueryInterface(riid, ppvObj);
				}
				else
				{
					hRes = m_hrCreate;
				}
			}
		}
		return hRes;
	}
	HRESULT m_hrCreate;
	CComPtr<IUnknown> m_spObj;
};


template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() 
	{
		return *pclsid;
	}
	static LPCTSTR WINAPI GetObjectDescription() 
	{
		return NULL;
	}
	static HRESULT WINAPI Error(
		_In_z_ LPCOLESTR lpszDesc,
		_In_ const IID& iid = GUID_NULL, 
		_In_ HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(
		_In_z_ LPCOLESTR lpszDesc, 
		_In_ DWORD dwHelpID,
		_In_z_ LPCOLESTR lpszHelpFile, 
		_In_ const IID& iid = GUID_NULL, 
		_In_ HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(
		_In_ UINT nID, 
		_In_ const IID& iid = GUID_NULL,
		_In_ HRESULT hRes = 0, 
		_In_ HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(
		_In_ UINT nID, 
		_In_ DWORD dwHelpID,
		_In_z_ LPCOLESTR lpszHelpFile, 
		_In_ const IID& iid = GUID_NULL,
		_In_ HRESULT hRes = 0, 
		_In_ HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(
		_In_z_ LPCSTR lpszDesc,
		_In_ const IID& iid = GUID_NULL, 
		_In_ HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(
		_In_z_ LPCSTR lpszDesc, 
		_In_ DWORD dwHelpID,
		_In_z_ LPCSTR lpszHelpFile, 
		_In_ const IID& iid = GUID_NULL, 
		_In_ HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
	template <class Q>
	static HRESULT CreateInstance(
		_Inout_opt_ IUnknown* punkOuter, 
		_Deref_out_ Q** pp)
	{
		return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
	}
	template <class Q>
	static HRESULT CreateInstance(_Deref_out_ Q** pp)
	{
		return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
		stringdispid() : nLen(0), id(DISPID_UNKNOWN){}
	};
	stringdispid* m_pMap;
	int m_nCount;

public:

#ifdef _ATL_DLL_IMPL
	CComTypeInfoHolder(
		_In_ const GUID* pguid, 
		_In_ const GUID* plibid, 
		_In_ WORD wMajor, 
		_In_ WORD wMinor) :
		m_pguid(pguid), m_plibid(plibid), m_wMajor(wMajor), m_wMinor(wMinor), 
		m_pInfo(NULL), m_dwRef(0), m_pMap(NULL), m_nCount(0)
	{
	}

	~CComTypeInfoHolder()
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
		delete [] m_pMap;
		m_pMap = NULL;
	}
#endif

	HRESULT GetTI(
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** ppInfo)
	{
		ATLASSERT(ppInfo != NULL);
		if (ppInfo == NULL)
			return E_POINTER;

		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(_In_ LCID lcid);
	HRESULT EnsureTI(_In_ LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL || m_pMap == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	// This function is called by the module on exit
	// It is registered through _pAtlModule->AddTermFunc()
	static void __stdcall Cleanup(_In_ DWORD_PTR dw);

	HRESULT GetTypeInfo(
		_In_ UINT itinfo, 
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** pptinfo)
	{
		if (itinfo != 0)
		{
			return DISP_E_BADINDEX;
		}
		return GetTI(lcid, pptinfo);
	}
	HRESULT GetIDsOfNames(
		_In_ REFIID /* riid */, 
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR* rgszNames, 
		_In_ UINT cNames,
		_In_ LCID lcid, 
		_Out_ DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			hRes = E_FAIL;
			// Look in cache if
			//	cache is populated
			//	parameter names are not requested
			if (m_pMap != NULL && cNames == 1)
			{
				int n = int( ocslen(rgszNames[0]) );
				for (int j=m_nCount-1; j>=0; j--)
				{
					if ((n == m_pMap[j].nLen) &&
						(memcmp(m_pMap[j].bstr, rgszNames[0], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
					{
						rgdispid[0] = m_pMap[j].id;
						hRes = S_OK;
						break;
					}
				}
			}
			// if cache is empty or name not in cache or parameter names are requested,
			// delegate to ITypeInfo::GetIDsOfNames
			if (FAILED(hRes))
			{
				hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
			}
		}
		return hRes;
	}

	_Check_return_ HRESULT Invoke(
		_Inout_ IDispatch* p, 
		_In_ DISPID dispidMember, 
		_In_ REFIID /* riid */,
		_In_ LCID lcid, 
		_In_ WORD wFlags, 
		_In_ DISPPARAMS* pdispparams, 
		_Out_opt_ VARIANT* pvarResult,
		_Out_opt_ EXCEPINFO* pexcepinfo, 
		_Out_opt_ UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	_Check_return_ HRESULT LoadNameCache(_Inout_ ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			stringdispid* pMap = NULL;
			m_nCount = pta->cFuncs;
			m_pMap = NULL;
			if (m_nCount != 0)
			{
				ATLTRY(pMap = new stringdispid[m_nCount]);
				if (pMap == NULL)
				{
					pTypeInfo->ReleaseTypeAttr(pta);
					return E_OUTOFMEMORY;
				}
			}
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						pMap[i].bstr.Attach(bstrName.Detach());
						pMap[i].nLen = SysStringLen(pMap[i].bstr);
						pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			m_pMap = pMap;
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};

inline void __stdcall CComTypeInfoHolder::Cleanup(_In_ DWORD_PTR dw)
{
	ATLASSERT(dw != 0);
	if (dw == 0)
		return;
		
	CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
	if (p->m_pInfo != NULL)
		p->m_pInfo->Release();
	p->m_pInfo = NULL;
	delete [] p->m_pMap;
	p->m_pMap = NULL;
}

inline HRESULT CComTypeInfoHolder::GetTI(_In_ LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSUME(m_plibid != NULL && m_pguid != NULL);

	if (m_pInfo != NULL && m_pMap != NULL)
		return S_OK;

	CComCritSecLock<CComCriticalSection> lock(_pAtlModule->m_csStaticDataInitAndTypeInfo, false);
	HRESULT hRes = lock.Lock();
	if (FAILED(hRes))
	{
		ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to lock critical section in CComTypeInfoHolder::GetTI\n"));
		ATLASSERT(0);
		return hRes;
	}
	hRes = E_FAIL;
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib = NULL;
		if (InlineIsEqualGUID(CAtlModule::m_libid, *m_plibid) && m_wMajor == 0xFFFF && m_wMinor == 0xFFFF)
		{
			TCHAR szFilePath[MAX_PATH];
			DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);
			if( dwFLen != 0 && dwFLen != MAX_PATH )
			{
				USES_CONVERSION_EX;
				LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
				if (pszFile == NULL)
					return E_OUTOFMEMORY;
#endif
				hRes = LoadTypeLib(pszFile, &pTypeLib);
			}
		}
		else
		{
			ATLASSUME(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Module LIBID not initialized. See DECLARE_LIBID documentation.");
			hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
#ifdef _DEBUG			
			if (SUCCEEDED(hRes))
			{
				// Trace out an warning if the requested TypelibID is the same as the modules TypelibID
				// and versions do not match.
				// 
				// In most cases it is due to wrong version template parameters to IDispatchImpl, 
				// IProvideClassInfoImpl or IProvideClassInfo2Impl.
				// Set major and minor versions to 0xFFFF if the modules type lib has to be loaded
				// irrespective of its version.
				// 
				// Get the module's file path
				TCHAR szFilePath[MAX_PATH];
				DWORD dwFLen = ::GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szFilePath, MAX_PATH);
				if( dwFLen != 0 && dwFLen != MAX_PATH )
				{
					USES_CONVERSION_EX;
					CComPtr<ITypeLib> spTypeLibModule;
					HRESULT hRes2 = S_OK;
					LPOLESTR pszFile = T2OLE_EX(szFilePath, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
					if (pszFile == NULL)
						hRes2 = E_OUTOFMEMORY;
					else
						hRes2 = LoadTypeLib(pszFile, &spTypeLibModule);
					if (SUCCEEDED(hRes2))
					{
						TLIBATTR* pLibAttr;
						hRes2 = spTypeLibModule->GetLibAttr(&pLibAttr);
						if (SUCCEEDED(hRes2))
						{
							if (InlineIsEqualGUID(pLibAttr->guid, *m_plibid) &&
								(pLibAttr->wMajorVerNum != m_wMajor ||
								pLibAttr->wMinorVerNum != m_wMinor))
							{
								ATLTRACE(atlTraceCOM, 0, _T("Warning : CComTypeInfoHolder::GetTI : Loaded typelib does not match the typelib in the module : %s\n"), szFilePath);
								ATLTRACE(atlTraceCOM, 0, _T("\tSee IDispatchImpl overview help topic for more information\n"));							
							}
							spTypeLibModule->ReleaseTLibAttr(pLibAttr);
						}
					}
				}
			}
			else
			{
				ATLTRACE(atlTraceCOM, 0, _T("ERROR : Unable to load Typelibrary. (HRESULT = 0x%x)\n"), hRes);
				ATLTRACE(atlTraceCOM, 0, _T("\tVerify TypelibID and major version specified with\n"));
				ATLTRACE(atlTraceCOM, 0, _T("\tIDispatchImpl, CStockPropImpl, IProvideClassInfoImpl or IProvideCLassInfo2Impl\n"));
			}
#endif		
		}
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
					spInfo = spTypeInfo2;

				m_pInfo = spInfo.Detach();
#ifndef _ATL_DLL_IMPL
				_pAtlModule->AddTermFunc(Cleanup, (DWORD_PTR)this);
#endif
			}
			pTypeLib->Release();
		}
	}
	else
	{
		// Another thread has loaded the typeinfo so we're OK.
		hRes = S_OK;
	}

	if (m_pInfo != NULL && m_pMap == NULL)
	{
		hRes=LoadNameCache(m_pInfo);
	}

	return hRes;
}


//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
ATLPREFAST_SUPPRESS(6387)
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl : 
	public IObjectWithSite
{
public:
	virtual ~IObjectWithSiteImpl()
	{
	}
	STDMETHOD(SetSite)(_In_opt_ IUnknown *pUnkSite)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IObjectWithSiteImpl::SetSite\n"));
		T* pT = static_cast<T*>(this);
		pT->m_spUnkSite = pUnkSite;
		return S_OK;
	}
	STDMETHOD(GetSite)(
		_In_ REFIID riid, 
		_Deref_out_ void** ppvSite)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IObjectWithSiteImpl::GetSite\n"));
		T* pT = static_cast<T*>(this);
		ATLASSERT(ppvSite);
		HRESULT hRes = E_POINTER;
		if (ppvSite != NULL)
		{
			if (pT->m_spUnkSite)
				hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
			else
			{
				*ppvSite = NULL;
				hRes = E_FAIL;
			}
		}
		return hRes;
	}	
	HRESULT SetChildSite(_Inout_ IUnknown* punkChild)
	{
		if (punkChild == NULL)
			return E_POINTER;

		HRESULT hr;
		CComPtr<IObjectWithSite> spChildSite;
		hr = punkChild->QueryInterface(__uuidof(IObjectWithSite), (void**)&spChildSite);
		if (SUCCEEDED(hr))
			hr = spChildSite->SetSite((IUnknown*)this);

		return hr;
	}
	static HRESULT SetChildSite(_Inout_ IUnknown* punkChild, _Inout_ IUnknown* punkParent)
	{
		return AtlSetChildSite(punkChild, punkParent);
	}

	CComPtr<IUnknown> m_spUnkSite;
};
ATLPREFAST_UNSUPPRESS()

//////////////////////////////////////////////////////////////////////////////
// IServiceProvider
//
template <class T>
class ATL_NO_VTABLE IServiceProviderImpl : 
	public IServiceProvider
{
public:
	STDMETHOD(QueryService)(
		_In_ REFGUID guidService, 
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObject)
	{
		ATLTRACE(atlTraceCOM, 2, _T("IServiceProviderImpl::QueryService\n"));

		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryService(guidService, riid, ppvObject);
	}
};

#define BEGIN_SERVICE_MAP(x) public: \
	HRESULT _InternalQueryService(_In_ REFGUID guidService, _In_ REFIID riid, _Deref_out_ void** ppvObject) \
	{ \
		ATLASSERT(ppvObject != NULL); \
		if (ppvObject == NULL) \
			return E_POINTER; \
		*ppvObject = NULL;

#define SERVICE_ENTRY(x) \
		if (InlineIsEqualGUID(guidService, x)) \
			return QueryInterface(riid, ppvObject);

#define SERVICE_ENTRY_CHAIN(x) \
		ATL::CComQIPtr<IServiceProvider, &__uuidof(IServiceProvider)> spProvider(x); \
		if (spProvider != NULL) \
			return spProvider->QueryService(guidService, riid, ppvObject);

#define END_SERVICE_MAP() \
		return E_NOINTERFACE; \
	}


/////////////////////////////////////////////////////////////////////////////
// IDispEventImpl

ATLAPI AtlGetObjectSourceInterface(
	_Inout_ IUnknown* punkObj, 
	_Out_ GUID* plibid, 
	_Out_ IID* piid, 
	_Out_ unsigned short* pdwMajor, 
	_Out_ unsigned short* pdwMinor);

#ifdef _M_IA64
template <class T>
class CComStdCallThunk
{
public:
	typedef void (__stdcall T::*TMFP)();
	void* pVtable;
	void* pFunc;
	_stdcallthunk thunk;
	void Init(_In_ TMFP dw, _In_ void* pThis)
	{
		pVtable = &pFunc;
		pFunc = &thunk;		
		union {
			DWORD_PTR dwFunc;
			TMFP pfn;
		} pfn;
		pfn.pfn = dw;
		thunk.Init(pfn.dwFunc, pThis);
	}
};

#elif defined ( _M_IX86 ) || defined ( _M_AMD64 )

extern "C"
{
void __stdcall CComStdCallThunkHelper();
}

template <class T>
class CComStdCallThunk
{
public:
	typedef void (__stdcall T::*TMFP)();
	void *pVTable;								// pointer to artificial VTABLE
	void *pThis;								// pointer to the class
	TMFP pfn;									// Pointer to member function to call
	void (__stdcall *pfnHelper)();				// Artificial VTABLE entry. Points to CComStdCallThunkHelper
												// which modifies the stack and jumps to pfn

	void Init(_In_ TMFP pf, _In_ void *p)
	{
		pfnHelper = CComStdCallThunkHelper;
		pVTable = &pfnHelper;
		pThis = p;
		pfn = pf;
	}
};
#else
#error X86, AMD64 and IA64
#endif // _M_IX86 |

#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif

struct _ATL_FUNC_INFO
{
	CALLCONV cc;
	VARTYPE vtReturn;
	SHORT nParams;
	VARTYPE pVarTypes[_ATL_MAX_VARTYPES];
};

class ATL_NO_VTABLE _IDispEvent
{
public:
	_IDispEvent() : m_libid(GUID_NULL), 
		m_iid(IID_NULL), m_wMajorVerNum(0), 
		m_wMinorVerNum(0), m_dwEventCookie(0xFEFEFEFE) 
	{
	}
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocDEQueryInterface)(
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	
	GUID m_libid; // used for dynamic case
	IID m_iid; // used for dynamic case
	unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
	unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
	DWORD m_dwEventCookie;
	HRESULT DispEventAdvise(
		_Inout_ IUnknown* pUnk, 
		_In_ const IID* piid)
	{
		ATLENSURE(m_dwEventCookie == 0xFEFEFEFE);
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(
		_Inout_ IUnknown* pUnk, 
		_In_ const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
	//---- add Advise & Unadvise for ease of calling from attribute code ----
	HRESULT Advise(_Inout_ IUnknown *punk) 
	{ 
		HRESULT hr = AtlGetObjectSourceInterface(punk, &m_libid, &m_iid, &m_wMajorVerNum, &m_wMinorVerNum);
		if (FAILED(hr))
			return hr;
		return DispEventAdvise(punk, &m_iid);
	}
	HRESULT Unadvise(_Inout_ IUnknown *punk) 
	{ 
		HRESULT hr = AtlGetObjectSourceInterface(punk, &m_libid, &m_iid, &m_wMajorVerNum, &m_wMinorVerNum);
		if (FAILED(hr))
			return hr;
		return DispEventUnadvise(punk, &m_iid);
	}
};

template <UINT nID, const IID* piid>
class ATL_NO_VTABLE _IDispEventLocator : 
	public _IDispEvent
{
public:
};

template <UINT nID, class T, const IID* pdiid>
class ATL_NO_VTABLE IDispEventSimpleImpl : 
	public _IDispEventLocator<nID, pdiid>
{
public:
	STDMETHOD(_LocDEQueryInterface)(
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObject)
	{
		ATLASSERT(ppvObject != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		if (InlineIsEqualGUID(riid, IID_NULL))
			return E_NOINTERFACE;

		if (InlineIsEqualGUID(riid, *pdiid) || 
			InlineIsEqualUnknown(riid) ||
			InlineIsEqualGUID(riid, __uuidof(IDispatch)) ||
			InlineIsEqualGUID(riid, m_iid))
		{
			*ppvObject = this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, _T("IDispEventImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}

	// These are here only to support use in non-COM objects	
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	STDMETHOD(GetTypeInfoCount)(_In_ /* _Out_ */ UINT* /*pctinfo*/)
	{
		ATLTRACENOTIMPL(_T("IDispEventSimpleImpl::GetTypeInfoCount"));
	}
	STDMETHOD(GetTypeInfo)(
		_In_ UINT /*itinfo*/, 
		_In_ LCID /*lcid*/, 
		_In_opt_ ITypeInfo** /*pptinfo*/)
	{
		ATLTRACENOTIMPL(_T("IDispEventSimpleImpl::GetTypeInfo"));
	}
	STDMETHOD(GetIDsOfNames)(
		_In_ REFIID /*riid*/, 
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR* /*rgszNames*/, 
		_In_ UINT cNames,
		_In_ LCID /*lcid*/, 
		_In_opt_ DISPID* /*rgdispid*/)
	{
		UNREFERENCED_PARAMETER(cNames);
		ATLTRACENOTIMPL(_T("IDispEventSimpleImpl::GetIDsOfNames"));
	}
	STDMETHOD(Invoke)(
		_In_ DISPID dispidMember, 
		_In_ REFIID /*riid*/,
		_In_ LCID lcid, 
		_In_ WORD /*wFlags*/, 
		_In_ DISPPARAMS* pdispparams, 
		_Out_opt_ VARIANT* pvarResult,
		_In_opt_ EXCEPINFO* /*pexcepinfo*/, 
		_In_opt_ UINT* /*puArgErr*/)
	{
		const _ATL_EVENT_ENTRY<T>* pMap = T::_GetSinkMap();
		const _ATL_EVENT_ENTRY<T>* pFound = NULL;
		while (pMap->piid != NULL)
		{
			if ((pMap->nControlID == nID) && (pMap->dispid == dispidMember) && 
				(IsEqualIID(*(pMap->piid), *pdiid)))
			{
				pFound = pMap;
				break;
			}
			pMap++;
		}
		if (pFound == NULL)
			return S_OK;


		_ATL_FUNC_INFO info;
		_ATL_FUNC_INFO* pInfo;
		if (pFound->pInfo != NULL)
			pInfo = pFound->pInfo;
		else
		{
			pInfo = &info;
			HRESULT hr = GetFuncInfoFromId(*pdiid, dispidMember, lcid, info);
			if (FAILED(hr))
				return S_OK;
		}
		return InvokeFromFuncInfo(pFound->pfn, *pInfo, pdispparams, pvarResult);
	}

	//Helper for invoking the event
	HRESULT InvokeFromFuncInfo(
		/* _In_ */ void (__stdcall T::*pEvent)(), 
		_In_ _ATL_FUNC_INFO& info, 
		_In_ DISPPARAMS* pdispparams, 
		_Out_opt_ VARIANT* pvarResult)
	{
		ATLASSERT(pdispparams->cArgs == (UINT)info.nParams);

		T* pT = static_cast<T*>(this);

		// If this assert occurs, then add 
		// #define _ATL_MAX_VARTYPES nnnn
		// before including atlcom.h
		ATLASSERT(info.nParams <= _ATL_MAX_VARTYPES);
		if (info.nParams > _ATL_MAX_VARTYPES)
		{
			return E_FAIL;
		}
		VARIANTARG* rgVarArgs[_ATL_MAX_VARTYPES];
		VARIANTARG** pVarArgs = info.nParams ? rgVarArgs : 0;

		UINT nIndex = 0;

#ifndef _ATL_IGNORE_NAMED_ARGS
		for (nIndex; nIndex < pdispparams->cNamedArgs; nIndex++)
		{
			ATLASSERT( ( NULL != pVarArgs ) && ( pdispparams->rgdispidNamedArgs[nIndex] < _countof(rgVarArgs) ) );
			if( ( NULL == pVarArgs ) || ( pdispparams->rgdispidNamedArgs[nIndex] >= _countof(rgVarArgs) ) )
			{
				return E_FAIL;
			}
			pVarArgs[pdispparams->rgdispidNamedArgs[nIndex]] = &pdispparams->rgvarg[nIndex];
		}
#endif

		for (; nIndex < pdispparams->cArgs; nIndex++)
		{
			ATLASSERT( NULL != pVarArgs );
			if( NULL == pVarArgs )
			{
				return E_FAIL;
			}
			pVarArgs[info.nParams-nIndex-1] = &pdispparams->rgvarg[nIndex];
		}

		CComStdCallThunk<T> thunk;
		thunk.Init(pEvent, pT);

		CComVariant tmpResult;
		if (pvarResult == NULL)
			pvarResult = &tmpResult;

		HRESULT hr = DispCallFunc(
			&thunk,
			0,
			info.cc,
			info.vtReturn,
			info.nParams,
			info.pVarTypes,
			pVarArgs,
			pvarResult);
		ATLASSERT(SUCCEEDED(hr));
		return hr;
	}

	//Helper for finding the function index for a DISPID
	virtual HRESULT GetFuncInfoFromId(
		_In_ const IID& /*iid*/, 
		_In_ DISPID /*dispidMember*/, 
		_In_ LCID /*lcid*/, 
		_In_ _ATL_FUNC_INFO& /*info*/)
	{
		ATLTRACE(_T("TODO: Classes using IDispEventSimpleImpl should override this method\n"));
		ATLASSERT(0);
		ATLTRACENOTIMPL(_T("IDispEventSimpleImpl::GetFuncInfoFromId"));
	}
	//Helpers for sinking events on random IUnknown*
	HRESULT DispEventAdvise(
		_Inout_ IUnknown* pUnk, 
		_In_ const IID* piid)
	{
		ATLENSURE(m_dwEventCookie == 0xFEFEFEFE);		
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(
		_Inout_ IUnknown* pUnk, 
		_In_ const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
	HRESULT DispEventAdvise(_Inout_ IUnknown* pUnk)
	{
		return _IDispEvent::DispEventAdvise(pUnk, pdiid);
	}
	HRESULT DispEventUnadvise(_Inout_ IUnknown* pUnk)
	{
		return _IDispEvent::DispEventUnadvise(pUnk, pdiid);
	}
};

//Helper for advising connections points from a sink map
template <class T>
inline HRESULT AtlAdviseSinkMap(
	_Inout_ T* pT, 
	_In_ bool bAdvise)
{
	ATLASSERT(::IsWindow(pT->m_hWnd));
	const _ATL_EVENT_ENTRY<T>* pEntries = T::_GetSinkMap();
	if (pEntries == NULL)
		return S_OK;
	HRESULT hr = S_OK;
	while (pEntries->piid != NULL)
	{
		_IDispEvent* pDE = (_IDispEvent*)((DWORD_PTR)pT+pEntries->nOffset);
		bool bNotAdvised = pDE->m_dwEventCookie == 0xFEFEFEFE;
		if (bAdvise ^ bNotAdvised)
		{
			pEntries++;
			continue;
		}
		hr = E_FAIL;
		HWND h = pT->GetDlgItem(pEntries->nControlID);
		ATLASSERT(h != NULL);
		if (h != NULL)
		{
			CComPtr<IUnknown> spUnk;
			AtlAxGetControl(h, &spUnk);
			ATLASSERT(spUnk != NULL);
			if (spUnk != NULL)
			{
				if (bAdvise)
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventAdvise(spUnk, pEntries->piid);
					else
					{
						hr = AtlGetObjectSourceInterface(spUnk, &pDE->m_libid, &pDE->m_iid, &pDE->m_wMajorVerNum, &pDE->m_wMinorVerNum);
						if (FAILED(hr))
							return hr;
						hr = pDE->DispEventAdvise(spUnk, &pDE->m_iid);
					}
				}
				else
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventUnadvise(spUnk, pEntries->piid);
					else
						hr = pDE->DispEventUnadvise(spUnk, &pDE->m_iid);
				}
				ATLASSERT(hr == S_OK);
			}
		}
		if (FAILED(hr))
			break;
		pEntries++;
	}
	return hr;
}

#pragma warning(push)
#pragma warning(disable: 4061) // enumerate XXX not explicitly handled by a case label
inline VARTYPE AtlGetUserDefinedType(
	_Inout_ ITypeInfo *pTI, 
	_In_ HREFTYPE hrt)
{
	ATLENSURE_THROW(pTI != NULL, E_INVALIDARG);

	CComPtr<ITypeInfo> spTypeInfo;
	VARTYPE vt = VT_USERDEFINED;
	HRESULT hr = E_FAIL;
	hr = pTI->GetRefTypeInfo(hrt, &spTypeInfo);
	if(FAILED(hr))
		return vt;
	TYPEATTR *pta = NULL;

	hr = spTypeInfo->GetTypeAttr(&pta);
	if(SUCCEEDED(hr) && pta && (pta->typekind == TKIND_ALIAS || pta->typekind == TKIND_ENUM))
	{
		if (pta->tdescAlias.vt == VT_USERDEFINED)
			vt = AtlGetUserDefinedType(spTypeInfo, pta->tdescAlias.hreftype);
		else
		{
			switch (pta->typekind)
			{
			case TKIND_ENUM :
				vt = VT_I4;
				break;
			case TKIND_INTERFACE :
				vt = VT_UNKNOWN;
				break;
			case TKIND_DISPATCH :
				vt = VT_DISPATCH;
				break;
			default:
				vt = pta->tdescAlias.vt;
			}
		}				
	}

	if(pta)
		spTypeInfo->ReleaseTypeAttr(pta);
	return vt;

}
#pragma warning(pop)

inline HRESULT AtlGetFuncInfoFromId(
	_In_ ITypeInfo* pTypeInfo, 
	_In_ const IID& /*iid*/, 
	_In_ DISPID dispidMember, 
	_In_ LCID /*lcid*/, 
	_Inout_ _ATL_FUNC_INFO& info)
{
	if (pTypeInfo == NULL)
		return E_INVALIDARG;

	HRESULT hr = S_OK;
	FUNCDESC* pFuncDesc = NULL;
	TYPEATTR* pAttr;
	hr = pTypeInfo->GetTypeAttr(&pAttr);
	if (FAILED(hr))
		return hr;
	int i;
	for (i=0;i<pAttr->cFuncs;i++)
	{
		hr = pTypeInfo->GetFuncDesc(i, &pFuncDesc);
		if (FAILED(hr))
			return hr;
		if (pFuncDesc->memid == dispidMember)
			break;
		pTypeInfo->ReleaseFuncDesc(pFuncDesc);
		pFuncDesc = NULL;
	}
	pTypeInfo->ReleaseTypeAttr(pAttr);
	if (pFuncDesc == NULL)
		return E_FAIL;

	// If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
	// before including atlcom.h
	ATLASSERT(pFuncDesc->cParams <= _ATL_MAX_VARTYPES);
	if (pFuncDesc->cParams > _ATL_MAX_VARTYPES)
		return E_FAIL;

	for (i = 0; i < pFuncDesc->cParams; i++)
	{
		info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.vt;
		if (info.pVarTypes[i] == VT_PTR)
			info.pVarTypes[i] = (VARTYPE)(pFuncDesc->lprgelemdescParam[i].tdesc.lptdesc->vt | VT_BYREF);
		if (info.pVarTypes[i] == VT_SAFEARRAY)
			info.pVarTypes[i] = (VARTYPE)(pFuncDesc->lprgelemdescParam[i].tdesc.lptdesc->vt | VT_ARRAY);
		if (info.pVarTypes[i] == VT_USERDEFINED)
			info.pVarTypes[i] = AtlGetUserDefinedType(pTypeInfo, pFuncDesc->lprgelemdescParam[i].tdesc.hreftype);
	}

	VARTYPE vtReturn = pFuncDesc->elemdescFunc.tdesc.vt;
	switch(vtReturn)
	{
	case VT_INT:
		vtReturn = VT_I4;
		break;
	case VT_UINT:
		vtReturn = VT_UI4;
		break;
	case VT_VOID:
		vtReturn = VT_EMPTY; // this is how DispCallFunc() represents void
		break;
	case VT_HRESULT:
		vtReturn = VT_ERROR;
		break;
	}
	info.vtReturn = vtReturn;
	info.cc = pFuncDesc->callconv;
	info.nParams = pFuncDesc->cParams;
	pTypeInfo->ReleaseFuncDesc(pFuncDesc);
	return S_OK;
}

template <UINT nID, class T, const IID* pdiid = &IID_NULL, const GUID* plibid = &GUID_NULL, 
	WORD wMajor = 0, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : 
	public IDispEventSimpleImpl<nID, T, pdiid>
{
public:
	typedef tihclass _tihclass;

	IDispEventImpl()
	{
		m_libid = *plibid;
		m_iid = *pdiid;
		m_wMajorVerNum = wMajor;
		m_wMinorVerNum = wMinor;
	}

	STDMETHOD(GetTypeInfoCount)(_Out_ UINT* pctinfo)
	{ 
		if (pctinfo == NULL) 
			return E_POINTER; 
		*pctinfo = 1; 
		return S_OK;
	}

	STDMETHOD(GetTypeInfo)(
		_In_ UINT itinfo, 
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}

	STDMETHOD(GetIDsOfNames)(
		_In_ REFIID riid, 
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR* rgszNames, 
		_In_ UINT cNames,
		_In_ LCID lcid, 
		_Out_ DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}

	//Helper for finding the function index for a DISPID
	HRESULT GetFuncInfoFromId(
		_In_ const IID& iid, 
		_In_ DISPID dispidMember, 
		_In_ LCID lcid, 
		_Inout_ _ATL_FUNC_INFO& info)
	{
		CComPtr<ITypeInfo> spTypeInfo;
	 
		if (InlineIsEqualGUID(*_tih.m_plibid, GUID_NULL))
		{
			m_InnerLibid = m_libid; 
			m_InnerIid = m_iid;
			_tih.m_plibid = &m_InnerLibid;
			_tih.m_pguid = &m_InnerIid;
			_tih.m_wMajor = m_wMajorVerNum;
			_tih.m_wMinor = m_wMinorVerNum;

		}
		HRESULT hr = _tih.GetTI(lcid, &spTypeInfo);
		if (FAILED(hr))
			return hr;
		return AtlGetFuncInfoFromId(spTypeInfo, iid, dispidMember, lcid, info);
	}
	VARTYPE GetUserDefinedType(_Inout_ ITypeInfo *pTI, _In_ HREFTYPE hrt)
	{
		return AtlGetUserDefinedType(pTI, hrt);
	}
protected:
	static _tihclass _tih;
	static GUID	m_InnerLibid; // used for dynamic case
	static IID m_InnerIid; // used for dynamic case
	static HRESULT GetTI(
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}
};
 
template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
	{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};
 
template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
GUID  IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::m_InnerLibid=GUID_NULL; 

template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IID  IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::m_InnerIid=IID_NULL;

template <class T>
struct _ATL_EVENT_ENTRY
{
	UINT nControlID;			//ID identifying object instance
	const IID* piid;			//dispinterface IID
	int nOffset;				//offset of dispinterface from this pointer
	DISPID dispid;				//DISPID of method/property
	void (__stdcall T::*pfn)();	//method to invoke
	_ATL_FUNC_INFO* pInfo;
};


//Sink map is used to set up event handling
#define BEGIN_SINK_MAP(_class)\
	typedef _class _GetSinkMapFinder;\
	static const ATL::_ATL_EVENT_ENTRY<_class>* _GetSinkMap()\
	{\
		PTM_WARNING_DISABLE \
		typedef _class _atl_event_classtype;\
		static const ATL::_ATL_EVENT_ENTRY<_class> map[] = {


#define SINK_ENTRY_INFO(id, iid, dispid, fn, info) {id, &iid, (int)(INT_PTR)(static_cast<ATL::_IDispEventLocator<id, &iid>*>((_atl_event_classtype*)8))-8, dispid, (void (__stdcall _atl_event_classtype::*)())fn, info},
#define SINK_ENTRY_EX(id, iid, dispid, fn) SINK_ENTRY_INFO(id, iid, dispid, fn, NULL)
#define SINK_ENTRY(id, dispid, fn) SINK_ENTRY_EX(id, IID_NULL, dispid, fn)
#define END_SINK_MAP() \
	{0, NULL, 0, 0, NULL, NULL} }; return map;\
	PTM_WARNING_RESTORE \
	}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid = &__uuidof(T), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : 
	public T
{
public:
	typedef tihclass _tihclass;
// IDispatch
	STDMETHOD(GetTypeInfoCount)(_Out_ UINT* pctinfo)
	{
		if (pctinfo == NULL) 
			return E_POINTER; 
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(
		_In_ UINT itinfo, 
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(
		_In_ REFIID riid, 
		_In_count_(cNames) _Deref_pre_z_ LPOLESTR* rgszNames, 
		_In_ UINT cNames,
		_In_ LCID lcid, 
		_Out_ DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(
		_In_ DISPID dispidMember, 
		_In_ REFIID riid,
		_In_ LCID lcid, 
		_In_ WORD wFlags, 
		_In_ DISPPARAMS* pdispparams, 
		_Out_opt_ VARIANT* pvarResult,
		_Out_opt_ EXCEPINFO* pexcepinfo, 
		_Out_opt_ UINT* puArgErr)
	{
		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}

#ifdef _ATL_DLL_IMPL
	// Do not cache type info if it is used in the ATL dll
	IDispatchImpl() : _tih(piid, plibid, wMajor, wMinor)
	{
	}
	virtual ~IDispatchImpl()
	{
	}

protected:
	_tihclass _tih;
	HRESULT GetTI(
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}

#else

protected:
	static _tihclass _tih;
	static HRESULT GetTI(
		_In_ LCID lcid, 
		_Deref_out_ ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}

#endif
};

#ifndef _ATL_DLL_IMPL

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};

#endif

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl
template <const CLSID* pcoclsid, const GUID* plibid = &CAtlModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfoImpl : 
	public IProvideClassInfo
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(_Deref_out_ ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}

protected:
	static _tihclass _tih;
};

template <const CLSID* pcoclsid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2Impl
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CAtlModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : 
	public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(_Deref_out_ ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(
		_In_ DWORD dwGuidKind, 
		_Out_ GUID* pGUID)
	{
		if (pGUID == NULL)
		{
			return E_POINTER;
		}
		*pGUID = GUID_NULL;
		if(dwGuidKind!=GUIDKIND_DEFAULT_SOURCE_DISP_IID)
		{
			return E_INVALIDARG;
		}
		if (psrcid != NULL)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : 
	public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(_In_ REFIID riid)
	{
		return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static HRESULT copy(_Out_ T* p1, _In_ const T* p2) 
	{ 
		Checked::memcpy_s(p1, sizeof(T), p2, sizeof(T)); 
		return S_OK;
	}
	static void init(_Inout_opt_ T*) 
	{
	}
	static void destroy(_Inout_opt_ T*) 
	{
	}
};

template<>
class _Copy<VARIANT>
{
public:
	static HRESULT copy(_Out_ VARIANT* p1, _In_ const VARIANT* p2) 
	{
		p1->vt = VT_EMPTY; 
		return VariantCopy(p1, const_cast<VARIANT*>(p2));
	}
	static void init(_Inout_ VARIANT* p) 
	{
		p->vt = VT_EMPTY;
	}
	static void destroy(_Inout_ VARIANT* p) 
	{
		VariantClear(p);
	}
};

template<>
class _Copy<LPOLESTR>
{
public:
	static HRESULT copy(_Out_ LPOLESTR* p1, _In_z_ const LPOLESTR* p2)
	{
		ATLENSURE(p1 != NULL && p2 != NULL);
		HRESULT hr = S_OK;
		ULONG len = ocslen(*p2)+1;
		(*p1) = (LPOLESTR)::ATL::AtlCoTaskMemCAlloc(len, static_cast<ULONG>(sizeof(OLECHAR)));
		if (*p1 == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			if(!ocscpy_s(*p1, len, *p2))
			{
				hr = E_FAIL;
			}
		}
		return hr;
	}
	static void init(_Inout_z_ LPOLESTR* p) 
	{
		*p = NULL;
	}
	static void destroy(_Inout_z_ LPOLESTR* p) 
	{ 
		CoTaskMemFree(*p);
	}
};

template<>
class _Copy<OLEVERB>
{
public:
	static HRESULT copy(_Out_ OLEVERB* p1, _In_ const OLEVERB* p2)
	{
		ATLENSURE(p1 != NULL && p2 != NULL);
		HRESULT hr = S_OK;
		*p1 = *p2;
		if (p2->lpszVerbName == NULL)
		{
			return S_OK;
		}

		ULONG len = ocslen(p2->lpszVerbName)+1;
		p1->lpszVerbName = (LPOLESTR)::ATL::AtlCoTaskMemCAlloc(len, static_cast<ULONG>(sizeof(OLECHAR)));
		if (p1->lpszVerbName == NULL)
		{
			hr = E_OUTOFMEMORY;
		}
		else
		{
			if(!ocscpy_s(p1->lpszVerbName, len, p2->lpszVerbName))
			{
				hr = E_FAIL;
			}
		}
		return hr;
	}
	static void init(_Inout_ OLEVERB* p) 
	{ 
		p->lpszVerbName = NULL;
	}
	static void destroy(_Inout_ OLEVERB* p) 
	{ 
		if (p->lpszVerbName)
		{
			CoTaskMemFree(p->lpszVerbName);
		}
	}
};

template<>
class _Copy<CONNECTDATA>
{
public:
	static HRESULT copy(_Out_ CONNECTDATA* p1, _In_ const CONNECTDATA* p2)
	{
		ATLENSURE(p1 != NULL && p2 != NULL);
		*p1 = *p2;
		if (p1->pUnk)
		{
			p1->pUnk->AddRef();
		}
		return S_OK;
	}
	static void init(_Inout_ CONNECTDATA* ) 
	{
	}
	static void destroy(_Inout_ CONNECTDATA* p) 
	{
		if (p->pUnk) 
		{
			p->pUnk->Release();
		}
	}
};

template <class T>
class _CopyInterface
{
public:
	static HRESULT copy(_Out_ T* * p1, _In_ T * const * p2)
	{
		ATLENSURE(p1 != NULL && p2 != NULL);
		*p1 = *p2;
		if (*p1)
			(*p1)->AddRef();
		return S_OK;
	}
	static void init(_Inout_ T** ) {}
	static void destroy(_Inout_ T** p) 
	{
		if (*p) 
		{
			(*p)->Release();
		}
	}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : 
	public IUnknown
{
public:
	STDMETHOD(Next)(
		_In_ ULONG celt, 
		_Out_ T* rgelt, 
		_Out_opt_ ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(_In_ ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(_Deref_out_ CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy>
class ATL_NO_VTABLE CComEnumImpl : 
	public Base
{
public:
	CComEnumImpl() 
	{
		m_begin = m_end = m_iter = NULL;
		m_dwFlags = 0;
	}
	virtual ~CComEnumImpl();
	
	STDMETHOD(Next)(
		_In_ ULONG celt, 
		_Out_ T* rgelt, 
		_Out_opt_ ULONG* pceltFetched);
	STDMETHOD(Skip)(_In_ ULONG celt);
	STDMETHOD(Reset)(void)
	{
		m_iter = m_begin;
		return S_OK;
	}
	STDMETHOD(Clone)(_Deref_out_ Base** ppEnum);
	HRESULT Init(
		_In_ T* begin, 
		_In_ T* end, 
		_In_opt_ IUnknown* pUnk,
		_In_ CComEnumFlags flags = AtlFlagNoCopy);
	
	CComPtr<IUnknown> m_spUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy>
CComEnumImpl<Base, piid, T, Copy>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Next(
	_In_ ULONG celt, 
	_Out_ T* rgelt,
	_Out_opt_ ULONG* pceltFetched)
{
	if (pceltFetched != NULL)
		*pceltFetched = 0;
	if (rgelt == NULL || (celt > 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = celt < nRem ? celt : nRem ;
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Skip(_In_ ULONG celt)
{
	ULONG nRem = ULONG(m_end - m_iter);
	ULONG nSkip = (celt > nRem) ? nRem : celt;
	m_iter += nSkip;
	return (celt == nSkip) ? S_OK : S_FALSE;
}

ATLPREFAST_SUPPRESS(6387)
template <class Base, const IID* piid, class T, class Copy>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy>::Clone(
	_Deref_out_ Base** ppEnum)
{
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{		
			// If this object has ownership of the data then we need to keep it around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitOwn) ? this : m_spUnk);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
		
	return hRes;
}
ATLPREFAST_UNSUPPRESS()

template <class Base, const IID* piid, class T, class Copy>
HRESULT CComEnumImpl<Base, piid, T, Copy>::Init(
	_In_ T* begin, 
	_In_ T* end, 
	_In_opt_ IUnknown* pUnk,
	_In_ CComEnumFlags flags)
{
	if (flags == AtlFlagCopy)
	{
		ATLASSUME(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[end-begin])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_spUnk = pUnk;
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
class ATL_NO_VTABLE IEnumOnSTLImpl : 
	public Base
{
public:
	HRESULT Init(
		_In_ IUnknown *pUnkForRelease, 
		_In_ CollType& collection)
	{
		m_spUnk = pUnkForRelease;
		m_pcollection = &collection;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Next)(
		_In_ ULONG celt, 
		_Out_ T* rgelt, 
		_Out_opt_ ULONG* pceltFetched);
	STDMETHOD(Skip)(_In_ ULONG celt);
	STDMETHOD(Reset)(void)
	{
		if (m_pcollection == NULL)
			return E_FAIL;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Clone)(_Deref_out_ Base** ppEnum);
//Data
	CComPtr<IUnknown> m_spUnk;
	CollType* m_pcollection;
	typename CollType::const_iterator m_iter;
};

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Next(
	_In_ ULONG celt, 
	_Out_ T* rgelt,
	_Out_opt_ ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt > 1 && pceltFetched == NULL))
		return E_POINTER;
	if (pceltFetched != NULL)
		*pceltFetched = 0;
	if (m_pcollection == NULL)
		return E_FAIL;

	ULONG nActual = 0;
	HRESULT hr = S_OK;
	T* pelt = rgelt;
	while (SUCCEEDED(hr) && m_iter != m_pcollection->end() && nActual < celt)
	{
		hr = Copy::copy(pelt, &*m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			nActual = 0;
		}
		else
		{
			pelt++;
			m_iter++;
			nActual++;
		}
	}
	if (SUCCEEDED(hr))
	{
		if (pceltFetched)
			*pceltFetched = nActual;
		if (nActual < celt)
			hr = S_FALSE;
	}
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Skip(_In_ ULONG celt)
{
	HRESULT hr = S_OK;
	while (celt--)
	{
		if (m_iter != m_pcollection->end())
			m_iter++;
		else
		{
			hr = S_FALSE;
			break;
		}
	}
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType>::Clone(
	_Deref_out_ Base** ppEnum)
{
	typedef CComObject<CComEnumOnSTL<Base, piid, T, Copy, CollType> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(m_spUnk, *m_pcollection);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnumOnSTL :
	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType>,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : 
	public T
{
public:
	STDMETHOD(get_Count)(_Out_ long* pcount)
	{
		if (pcount == NULL)
			return E_POINTER;
		ATLASSUME(m_coll.size()<=LONG_MAX);

		*pcount = (long)m_coll.size();

		return S_OK;
	}
	STDMETHOD(get_Item)(
		_In_ long Index, 
		_Out_ ItemType* pvar)
	{
		//Index is 1-based
		if (pvar == NULL)
			return E_POINTER;
		if (Index < 1)
			return E_INVALIDARG;
		HRESULT hr = E_FAIL;
		Index--;
		CollType::const_iterator iter = m_coll.begin();
		while (iter != m_coll.end() && Index > 0)
		{
			iter++;
			Index--;
		}
		if (iter != m_coll.end())
			hr = CopyItem::copy(pvar, &*iter);
		return hr;
	}
	STDMETHOD(get__NewEnum)(_Deref_out_ IUnknown** ppUnk)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hRes = S_OK;
		CComObject<EnumType>* p;
		hRes = CComObject<EnumType>::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(this, m_coll);
			if (hRes == S_OK)
				hRes = p->QueryInterface(__uuidof(IUnknown), (void**)ppUnk);
		}
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
	CollType m_coll;
};

//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl : 
	public ISpecifyPropertyPages
{
public:
	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(_Out_ CAUUID* pPages)
	{
		ATLTRACE(atlTraceCOM, 2, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return GetPagesHelper(pPages, pMap);
	}
protected:
	HRESULT GetPagesHelper(
		_Out_ CAUUID* pPages, 
		_In_ const ATL_PROPMAP_ENTRY* pMap)
	{
		if (pPages == NULL)
			return E_POINTER;
		ATLASSERT(pMap != NULL);
		if (pMap == NULL)
			return E_POINTER;

		int nCnt = 0;
		int i;
		// Get count of unique pages to alloc the array
ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
ATLPREFAST_UNSUPPRESS()
		{
			// only allow non data entry types
			if (pMap[i].vt == 0)
			{
				// Does this property have a page?  CLSID_NULL means it does not
				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
					nCnt++;
			}
		}
		pPages->pElems = (GUID*) ::ATL::AtlCoTaskMemCAlloc(nCnt, static_cast<ULONG>(sizeof(CLSID)));
		if (pPages->pElems == NULL)
			return E_OUTOFMEMORY;
		// reset count of items we have added to the array
		nCnt = 0;
		for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			// only allow non data entry types
			if (pMap[i].vt == 0)
			{
				// Does this property have a page?  CLSID_NULL means it does not
				if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
				{
					BOOL bFound = FALSE;
					// Search through array we are building up to see
					// if it is already in there
					for (int j=0; j<nCnt; j++)
					{
						if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
						{
							// It's already there, so no need to add it again
							bFound = TRUE;
							break;
						}
					}
					// If we didn't find it in there then add it
					if (!bFound)
						pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
				}
			}
		}
		pPages->cElems = nCnt;
		return S_OK;
	}

};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD_PTR dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	__if_not_exists(_atl_conn_classtype) \
	{ \
		typedef x _atl_conn_classtype;\
	} \
	static const ATL::_ATL_CONNMAP_ENTRY* GetConnMap(_Out_opt_ int* pnEntries) {\
	static const ATL::_ATL_CONNMAP_ENTRY _entries[] = {
#define BEGIN_ATTRCONNECTION_POINT_MAP(x)\
	__if_not_exists(_atl_conn_classtype) \
	{ \
		typedef x _atl_conn_classtype;\
	} \
	static const ATL::_ATL_CONNMAP_ENTRY* GetAttrConnMap(_Out_opt_ int* pnEntries) {\
	static const ATL::_ATL_CONNMAP_ENTRY _entries[] = {

// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){offsetofclass(ATL::_ICPLocator<&iid>, _atl_conn_classtype)-\
	offsetofclass(ATL::IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() \
	__if_exists(GetAttrConnMap) \
	{ \
		{(DWORD_PTR) -2}, \
		{(DWORD_PTR) GetAttrConnMap }, \
	} \
	{(DWORD_PTR)-1} }; \
	if (pnEntries) \
	{ \
		__if_exists(GetAttrConnMap) \
		{ \
			GetAttrConnMap(pnEntries); \
			*pnEntries += sizeof(_entries)/sizeof(ATL::_ATL_CONNMAP_ENTRY) - 3; \
		} \
		__if_not_exists(GetAttrConnMap) \
		{ \
		*pnEntries = sizeof(_entries)/sizeof(ATL::_ATL_CONNMAP_ENTRY) - 1; \
		} \
	} \
	return _entries;}
#define END_ATTRCONNECTION_POINT_MAP() \
	{(DWORD_PTR)-1} }; \
	if (pnEntries) \
	{ \
		*pnEntries = sizeof(_entries)/sizeof(ATL::_ATL_CONNMAP_ENTRY) - 1; \
	} \
	return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
	CComUnkArray()
	{
		memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
	}
	DWORD Add(_In_ IUnknown* pUnk);
	BOOL Remove(_In_ DWORD dwCookie);
	// If there is more than one instance of the same IUnknown*,
	// this function returns the cookie for the first one.
	DWORD WINAPI GetCookie(_In_ IUnknown** ppFind)
	{
		ATLASSERT(ppFind && *ppFind);
		if (ppFind && *ppFind)
		{
			// find IUnknown* in array
			for (DWORD dwCookie = 0; dwCookie < nMaxSize; dwCookie++)
			{
				if (m_arr[dwCookie] == *ppFind)
					return dwCookie+1; // cookie minus one is an index into the array
			}
		}
		return 0;
	}
	IUnknown* WINAPI GetUnknown(_In_ DWORD dwCookie)
	{
		ATLASSERT(dwCookie != 0 && dwCookie <= nMaxSize);
		if (dwCookie != 0 && dwCookie <= nMaxSize)
			return m_arr[dwCookie-1]; // cookie minus one is an index into the array
		else
			return NULL;
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return &m_arr[nMaxSize];
	}
protected:
	IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(_In_ IUnknown* pUnk)
{
	DWORD dwCookie = 1;
	for (IUnknown** pp = begin(); pp < end(); pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return dwCookie;
		}
		dwCookie++;
	}
	// If this fires then you need a larger array
	ATLASSERT(0);
	return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(_In_ DWORD dwCookie)
{
	ATLASSERT(dwCookie != 0 && dwCookie <= nMaxSize);
	if (dwCookie != 0 && dwCookie <= nMaxSize && m_arr[dwCookie-1] != NULL)
	{
		m_arr[dwCookie-1] = NULL;
		return TRUE;
	}
	else
		return FALSE;
}

template<>
class CComUnkArray<1>
{
public:
	CComUnkArray()
	{
		m_arr[0] = NULL;
	}
	DWORD Add(_In_ IUnknown* pUnk)
	{
		if (m_arr[0] != NULL)
		{
			// If this fires then you need a larger array
			ATLASSERT(0);
			return 0;
		}
		m_arr[0] = pUnk;
		return 1;
	}
	BOOL Remove(_In_ DWORD dwCookie)
	{
		ATLASSERT(dwCookie == 1);
		if (dwCookie == 1 && m_arr[0] != NULL)
		{
			m_arr[0] = NULL;
			return TRUE;
		}
		else
			return FALSE;
	}
	DWORD WINAPI GetCookie(_In_opt_ IUnknown** /* pp */)
	{
		return 1;
	}
	IUnknown* WINAPI GetUnknown(_In_ DWORD dwCookie)
	{
		ATLASSERT(dwCookie == 1);
		if (dwCookie == 1)
			return m_arr[0];
		else 
			return NULL;
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return (&m_arr[0])+1;
	}
protected:
	IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
	CComDynamicUnkArray()
	{
		m_nSize = 0;
		m_ppUnk = NULL;
	}

	~CComDynamicUnkArray()
	{
		if (m_nSize > 0)
			free(m_ppUnk);
	}
	DWORD Add(_In_ IUnknown* pUnk);
	BOOL Remove(_In_ DWORD dwCookie);
	// If there is more than one instance of the same IUnknown*,
	// this function returns the cookie for the first one.
	DWORD WINAPI GetCookie(_In_ IUnknown** ppFind)
	{
		ATLASSERT(ppFind && *ppFind);
		if (ppFind && *ppFind)
		{
			IUnknown** ppUnk = NULL;
			DWORD dwCookie = 1;
			// find IUnknown* in array
			for (ppUnk = begin(); ppUnk < end(); ppUnk++)
			{
				if (*ppUnk == *ppFind)
					return dwCookie; // cookie minus one is an index into the array
				dwCookie++;
			}
		}
		return 0;
	}
	IUnknown* WINAPI GetUnknown(_In_ DWORD dwCookie)
	{
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
		ATLASSERT(dwCookie != 0 && dwCookie <= (DWORD)m_nSize);
#endif
		if (dwCookie != 0 && dwCookie <= (DWORD)m_nSize)
			return GetAt(dwCookie-1); // cookie minus one is an index into the array
		else
			return NULL;
	}
	IUnknown** begin()
	{
		return m_ppUnk;
	}
	IUnknown** end()
	{
		return &m_ppUnk[m_nSize];
	}

	IUnknown* GetAt(_In_ int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex >= 0 && nIndex < m_nSize)
			return m_ppUnk[nIndex];
		else
			return NULL;

	}
	int GetSize() const
	{
		return m_nSize;
	}
	void clear()
	{
		if (m_nSize > 0)
		{
			free(m_ppUnk);
			m_ppUnk = 0;
		}
		m_nSize = 0;
	}
protected:
	IUnknown** m_ppUnk;
	int m_nSize;
};

inline DWORD CComDynamicUnkArray::Add(_In_ IUnknown* pUnk)
{
	IUnknown** pp = NULL;
	if (m_nSize == 0)
	{
		// Create array with _DEFAULT_VECTORLENGTH number of items.
		ATLTRY(pp = (IUnknown**)calloc(sizeof(IUnknown*),_DEFAULT_VECTORLENGTH));
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	// Walk array and use empty slots if any.
	DWORD dwCookie = 1;
	for (pp = begin(); pp < end(); pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return dwCookie; // cookie mi	nus one is index into array
		}
		dwCookie++;
	}
	// No empty slots so resize array.
	// # of new slots is double of current size.
#ifdef _WIN64
	int nAlloc = 0;
	HRESULT hr = AtlMultiply(&nAlloc, m_nSize, 2);
	if (FAILED(hr))
	{
		return 0;
	}
#else
	int nAlloc = m_nSize*2;
#endif
	pp = (IUnknown**)_recalloc(m_ppUnk, sizeof(IUnknown*),nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
	dwCookie = m_nSize+1;
	m_nSize = nAlloc;
	return dwCookie; // cookie minus one is index into array
}

inline BOOL CComDynamicUnkArray::Remove(_In_ DWORD dwCookie)
{
	DWORD idx = dwCookie -1;
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
	ATLASSERT(idx < dwCookie && idx < (DWORD)m_nSize);
#endif
	if (idx < dwCookie && idx < (DWORD)m_nSize)
	{
		// cookie minus one is index into array
		if (m_ppUnk[idx] == NULL)
			return FALSE;
		m_ppUnk[idx] = NULL;
		return TRUE;
	}
	else
		return FALSE;
}

template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
public:
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocCPQueryInterface)(
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : 
	public _ICPLocator<piid>
{
	typedef CComEnum<IEnumConnections, &__uuidof(IEnumConnections), CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
	typedef CDV _CDV;
public:
	~IConnectionPointImpl();
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(_LocCPQueryInterface)(
		_In_ REFIID riid, 
		_Deref_out_ void** ppvObject)
	{
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
		ATLASSERT(ppvObject != NULL);
#endif
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		if (InlineIsEqualGUID(riid, __uuidof(IConnectionPoint)) || InlineIsEqualUnknown(riid))
		{
			*ppvObject = this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_AtlDebugInterfacesModule.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(GetConnectionInterface)(_Out_ IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(
		_Deref_out_ IConnectionPointContainer** ppCPC)
	{
		T* pT = static_cast<T*>(this);
		// No need to check ppCPC for NULL since QI will do that for us
		return pT->QueryInterface(__uuidof(IConnectionPointContainer), (void**)ppCPC);
	}
	STDMETHOD(Advise)(
		_Inout_ IUnknown* pUnkSink, 
		_Out_ DWORD* pdwCookie);
	STDMETHOD(Unadvise)(_In_ DWORD dwCookie);
	STDMETHOD(EnumConnections)(_Deref_out_ IEnumConnections** ppEnum);
	
	CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
	IUnknown** pp = m_vec.begin();
	while (pp < m_vec.end())
	{
		if (*pp != NULL)
			(*pp)->Release();
		pp++;
	}
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(
	_Inout_ IUnknown* pUnkSink,
	_Out_ DWORD* pdwCookie)
{
	T* pT = static_cast<T*>(this);
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pdwCookie != NULL)
		*pdwCookie = 0;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
	IID iid;
	GetConnectionInterface(&iid);
	hRes = pUnkSink->QueryInterface(iid, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		pT->Lock();
		*pdwCookie = m_vec.Add(p);
		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
		pT->Unlock();
		if (hRes != S_OK)
			p->Release();
	}
	else if (hRes == E_NOINTERFACE)
		hRes = CONNECT_E_CANNOTCONNECT;
	if (FAILED(hRes))
		*pdwCookie = 0;
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(_In_ DWORD dwCookie)
{
	T* pT = static_cast<T*>(this);
	pT->Lock();
	IUnknown* p = m_vec.GetUnknown(dwCookie);
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	pT->Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

ATLPREFAST_SUPPRESS(6014 6211)
template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
	_Deref_out_ IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	T* pT = static_cast<T*>(this);
	pT->Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[m_vec.end()-m_vec.begin()])
	if (pcd == NULL)
	{
		delete pEnum;
		pT->Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
	{
		if (*pp != NULL)
		{
			(*pp)->AddRef();
			pend->pUnk = *pp;
			pend->dwCookie = m_vec.GetCookie(pp);
			pend++;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	pT->Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(__uuidof(IEnumConnections), (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}
ATLPREFAST_UNSUPPRESS()

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl
template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl : 
	public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&__uuidof(IEnumConnectionPoints), IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	
ATLPREFAST_SUPPRESS(6014 6211 6387)
	STDMETHOD(EnumConnectionPoints)(
		_Deref_out_ IEnumConnectionPoints** ppEnum)
	{
		if (ppEnum == NULL)
			return E_POINTER;
		*ppEnum = NULL;
		CComEnumConnectionPoints* pEnum = NULL;
		ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
		if (pEnum == NULL)
			return E_OUTOFMEMORY;

		int nCPCount;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);

		// allocate an initialize a vector of connection point object pointers
		USES_ATL_SAFE_ALLOCA;
		if ((nCPCount < 0) || (nCPCount > (INT_MAX / sizeof(IConnectionPoint*))))
			return E_OUTOFMEMORY;
		size_t nBytes=0;
		HRESULT hr=S_OK;
		if( FAILED(hr=::ATL::AtlMultiply(&nBytes, sizeof(IConnectionPoint*), static_cast<size_t>(nCPCount))))
		{
			return hr;
		}
		IConnectionPoint** ppCP = (IConnectionPoint**)_ATL_SAFE_ALLOCA(nBytes, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
		if (ppCP == NULL)
		{
			delete pEnum;
			return E_OUTOFMEMORY;
		}

		int i = 0;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			if (pEntry->dwOffset == (DWORD_PTR)-2)
			{
				pEntry++;
				const _ATL_CONNMAP_ENTRY* (*pFunc)(int*) =  (const _ATL_CONNMAP_ENTRY* (*)(int*))(pEntry->dwOffset);
				pEntry = pFunc(NULL);
				continue;
			}
			ppCP[i++] = (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			pEntry++;
		}

		// copy the pointers: they will AddRef this object
		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
			(IConnectionPoint**)&ppCP[nCPCount],
			reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
		if (FAILED(hRes))
		{
			delete pEnum;
			return hRes;
		}
		hRes = pEnum->QueryInterface(__uuidof(IEnumConnectionPoints), (void**)ppEnum);
		if (FAILED(hRes))
			delete pEnum;
				
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()

	STDMETHOD(FindConnectionPoint)(
		_In_ REFIID riid, 
		_Deref_out_ IConnectionPoint** ppCP)
	{
		if (ppCP == NULL)
			return E_POINTER;
		*ppCP = NULL;
		HRESULT hRes = CONNECT_E_NOCONNECTION;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
		IID iid;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			if (pEntry->dwOffset == (DWORD_PTR)-2)
			{
				pEntry++;
				const _ATL_CONNMAP_ENTRY* (*pFunc)(int*) =  (const _ATL_CONNMAP_ENTRY* (*)(int*))(pEntry->dwOffset);
				pEntry = pFunc(NULL);
				continue;
			}
			IConnectionPoint* pCP =
				(IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
				InlineIsEqualGUID(riid, iid))
			{
				*ppCP = pCP;
				pCP->AddRef();
				hRes = S_OK;
				break;
			}
			pEntry++;
		}
		return hRes;
	}
};

#endif //!_ATL_NO_CONNECTION_POINTS

/////////////////////////////////////////////////////////////////////////////
// IExternalConnectionImpl

// An object that implements IExternalConnection should explicitly call 
// CoDisconnectObject on itself when its external reference count drops to 0. 
// This call will cause the stub manager to call Release on the object so the 
// object can destroy itself.

template <class T> 
class IExternalConnectionImpl : 
	public IExternalConnection
{
public:
	IExternalConnectionImpl(void) : m_nStrongLocks(0) 
	{
	}
	STDMETHODIMP_(DWORD) AddConnection(
		_In_ DWORD extconn, 
		_In_ DWORD /*dwReserved*/)
	{
		DWORD dw = 0;
		if (extconn & EXTCONN_STRONG)
		{
			dw = T::_ThreadModel::Increment(&m_nStrongLocks);
			static_cast<T*>(this)->OnAddConnection(dw == 1);
		}
		return dw;
	}
	STDMETHODIMP_(DWORD) ReleaseConnection(
		_In_ DWORD extconn, 
		_In_ DWORD /*dwReserved*/, 
		_In_ BOOL bLastUnlockReleases)
	{
		DWORD dw = 0;
		if (extconn & EXTCONN_STRONG)
		{
			dw = T::_ThreadModel::Decrement(&m_nStrongLocks);
			static_cast<T*>(this)->OnReleaseConnection(dw == 0, !!bLastUnlockReleases);
		}
		return dw;
	}

	// Services provided by this class
	bool DoIHaveAStub() 
	{ 
		return m_nStrongLocks != 0; 
	}
	LONG GetStrongConnectionCount() 
	{ 
		return m_nStrongLocks; 
	}
	// Extensibility points provided by this class
	void OnAddConnection(_In_ bool bThisIsFirstLock) {}
	void OnReleaseConnection(_In_ bool bThisIsLastUnlock, _In_ bool bLastUnlockReleases)
	{
		if (bThisIsLastUnlock && bLastUnlockReleases)
			CoDisconnectObject(static_cast<T*>(this)->GetUnknown(), 0);
	}
	// Implementation
	LONG m_nStrongLocks;
};

#pragma pack(pop)

// All exports go here
#ifndef _ATL_DLL

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(
	_In_ const CLSID& clsid, 
	_In_z_ LPCOLESTR lpszDesc, 
	_In_ DWORD dwHelpID,
	_In_opt_z_ LPCOLESTR lpszHelpFile, 
	_In_ const IID& iid, 
	_In_ HRESULT hRes, 
	_In_opt_ HINSTANCE hInst)
{
	USES_CONVERSION_EX;
	TCHAR szDesc[1024];
	szDesc[0] = _T('\0');
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (IS_INTRESOURCE(lpszDesc)) //id
	{
		UINT nID = LOWORD((DWORD_PTR)lpszDesc);
		ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			ATLASSERT(FALSE);
			Checked::tcscpy_s(szDesc, _countof(szDesc), _T("Unknown Error"));
		}
		lpszDesc = T2OLE_EX(szDesc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
		if(lpszDesc == NULL) 
			return E_OUTOFMEMORY;
#endif			
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(__uuidof(IErrorInfo), (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IPersist* helpers.

ATLINLINE ATLAPI AtlIPersistStreamInit_Load(
	_Inout_ LPSTREAM pStm, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
	if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
	{
		return E_INVALIDARG;
	}
	
	ULONG cbRead = 0;
	DWORD dwVer;
	HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &cbRead);

	if (FAILED(hr))
	{
		return hr;
	}
	else if (sizeof(DWORD) != cbRead)
	{
		return E_FAIL;
	}
	
	if (dwVer > _ATL_VER)
	{
		return E_FAIL;
	}

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	
ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
ATLPREFAST_UNSUPPRESS()
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			// call CComBSTR::ReadFromStream for BSTRs
			if (pMap[i].vt == VT_BSTR)
			{
				CComBSTR bstrRead;
				hr = bstrRead.ReadFromStream(pStm);
				(*(BSTR*)pData) = bstrRead.Detach();
			}
			else
			{
				hr = pStm->Read(pData, pMap[i].dwSizeData, &cbRead);
				
				if (SUCCEEDED(hr) && cbRead != pMap[i].dwSizeData)
				{
					return E_FAIL;
				}
			}
			
			if (FAILED(hr))
			{
				return hr;
			}
			continue;
		}

		CComVariant var;
		
		hr = var.ReadFromStream(pStm, pMap[i].vt, pMap[i].rgclsidAllowed, pMap[i].cclsidAllowed);
		if (FAILED(hr))
			break;

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			ATLENSURE_RETURN(pMap[i].piidDispatch);
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);	
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(pDispatch.PutProperty(pMap[i].dispid, &var)))
		{
			ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}

ATLINLINE ATLAPI AtlIPersistStreamInit_Save(
	_Inout_ LPSTREAM pStm,
	_In_ BOOL /* fClearDirty */, 
	_In_ const ATL_PROPMAP_ENTRY* pMap,
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
	if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
		return E_INVALIDARG;

	DWORD dw = _ATL_VER;
	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
ATLPREFAST_UNSUPPRESS()
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			// call CComBSTR::WriteToStream for BSTRs
			if (pMap[i].vt == VT_BSTR)
			{
				CComBSTR bstrWrite;
				bstrWrite.Attach(*(BSTR*)pData);
				hr = bstrWrite.WriteToStream(pStm);
				bstrWrite.Detach();
			}
			else
				hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			ATLENSURE_RETURN(pMap[i].piidDispatch);
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(pDispatch.GetProperty(pMap[i].dispid, &var)))
		{
			ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}

		hr = var.WriteToStream(pStm, pMap[i].vt);
		if (FAILED(hr))
			break;
	}
	return hr;
}
ATLINLINE ATLAPI AtlIPersistPropertyBag_Load(
	_Inout_ LPPROPERTYBAG pPropBag, 
	_Inout_ LPERRORLOG pErrorLog, 
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk)
{
	if (pPropBag == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;

ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
ATLPREFAST_UNSUPPRESS()
	{
		if (pMap[i].szDesc == NULL)
			continue;

		CComVariant var;

		if (pMap[i].dwSizeData != 0)
		{			
			var.vt = pMap[i].vt; 
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
			if (SUCCEEDED(hr))
			{
				// check the type - we only deal with limited set
				switch (pMap[i].vt)
				{
				case VT_UI1:
				case VT_I1:
					*((BYTE*)pData) = var.bVal;
					break;
				case VT_BOOL:
					*((VARIANT_BOOL*)pData) = var.boolVal;
					break;
				case VT_I2:
				case VT_UI2:
					*((short*)pData) = var.iVal;
					break;
				case VT_I4:
				case VT_UI4:
				case VT_INT:
				case VT_UINT:
					*((long*)pData) = var.lVal;
					break;
				case VT_BSTR:									
					*((BSTR*)pData) = var.bstrVal;
					var.vt = VT_EMPTY;
					break;
				}
			}
			else
			{
				var.vt = VT_EMPTY;
			}			
			
			continue;
		}

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			ATLENSURE_RETURN(pMap[i].piidDispatch);
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		VARTYPE vt = pMap[i].vt;
		if (vt == VT_EMPTY)
		{
			if (FAILED(pDispatch.GetProperty(pMap[i].dispid, &var)))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
				return E_FAIL;
			}
			vt = var.vt;
			var.Clear();
		}
		
		var.vt = vt;

		HRESULT hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		if (FAILED(hr))
		{
#ifdef _DEBUG
            COLE2CT strDesc(pMap[i].szDesc);
			LPCTSTR lp = static_cast<LPCTSTR>(strDesc);

			if (hr == E_INVALIDARG)
			{
				if (lp == NULL)
					ATLTRACE(atlTraceCOM, 0, _T("Property not in Bag\n"));
				else
					ATLTRACE(atlTraceCOM, 0, _T("Property %s not in Bag\n"), lp);
			}
			else
			{
				// Many containers return different ERROR values for Member not found
				if (lp == NULL)
					ATLTRACE(atlTraceCOM, 0, _T("Error attempting to read Property from PropertyBag \n"));
				else
					ATLTRACE(atlTraceCOM, 0, _T("Error attempting to read Property %s from PropertyBag \n"), lp);
			}
#endif			
			var.vt = VT_EMPTY;
			continue;
		}

		if (FAILED(pDispatch.PutProperty(pMap[i].dispid, &var)))
		{
			ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}
	}
	return S_OK;
}
ATLINLINE ATLAPI AtlIPersistPropertyBag_Save(
	_Inout_ LPPROPERTYBAG pPropBag,
	_In_ BOOL /* fClearDirty */, 
	_In_ BOOL /* fSaveAllProperties */,
	_In_ const ATL_PROPMAP_ENTRY* pMap, 
	_Inout_ void* pThis, 
	_Inout_ IUnknown* pUnk)
{
	if (pPropBag == NULL)
	{
		ATLTRACE(atlTraceCOM, 0, _T("PropBag pointer passed in was invalid\n"));
		return E_INVALIDARG;
	}
	if (pMap == NULL || pThis == NULL || pUnk == NULL)
		return E_INVALIDARG;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;

ATLPREFAST_SUPPRESS(6385) // Invalid data accessing
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
ATLPREFAST_UNSUPPRESS()
	{
		if (pMap[i].szDesc == NULL)
			continue;

		CComVariant var;

		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			// check the type - we only deal with limited set
			bool bTypeOK = false;
			switch (pMap[i].vt)
			{
			case VT_UI1:
			case VT_I1:
				var.bVal = *((BYTE*)pData);
				bTypeOK = true;
				break;
			case VT_BOOL:
				var.boolVal = *((VARIANT_BOOL*)pData);
				bTypeOK = true;
				break;
			case VT_UI2:
				var.iVal = *((short*)pData);
				bTypeOK = true;
				break;
			case VT_UI4:
			case VT_INT:
			case VT_UINT:
				var.lVal = *((long*)pData);
				bTypeOK = true;
				break;
			case VT_BSTR:
				var.bstrVal = ::SysAllocString(*((BSTR*)pData));
				if (var.bstrVal == NULL && *((BSTR*)pData) != NULL)
					return E_OUTOFMEMORY;
				bTypeOK = true;
				break;
			}
			if (bTypeOK)
			{
				var.vt = pMap[i].vt;
				HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
				if (FAILED(hr))
					return hr;
			}
			continue;
		}

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			ATLENSURE_RETURN(pMap[i].piidDispatch);
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(pDispatch.GetProperty(pMap[i].dispid, &var)))
		{
			ATLTRACE(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		if (pMap[i].vt != VT_EMPTY && pMap[i].vt != var.vt)
		{
			HRESULT hr = var.ChangeType(pMap[i].vt);
			if (FAILED(hr))
				return hr;
		}

		if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		{
			if (var.punkVal == NULL)
			{
				ATLTRACE(atlTraceCOM, 2, _T("Warning skipping empty IUnknown in Save\n"));
				continue;
			}
		}

		HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Sink Helper

ATLINLINE ATLAPI AtlGetObjectSourceInterface(
	_Inout_ IUnknown* punkObj, 
	_Out_ GUID* plibid, 
	_Out_ IID* piid, 
	_Out_ unsigned short* pdwMajor, 
	_Out_ unsigned short* pdwMinor)
{
	if (plibid == NULL || piid == NULL || pdwMajor == NULL || pdwMinor == NULL)
		return E_POINTER;
		
	*plibid = GUID_NULL;
	*piid = IID_NULL;
	*pdwMajor = 0;
	*pdwMinor = 0;	

	HRESULT hr = E_FAIL;
	if (punkObj != NULL)
	{
		CComPtr<IDispatch> spDispatch;
		hr = punkObj->QueryInterface(__uuidof(IDispatch), (void**)&spDispatch);
		if (SUCCEEDED(hr))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hr = spDispatch->GetTypeInfo(0, 0, &spTypeInfo);
			if (SUCCEEDED(hr))
			{
				CComPtr<ITypeLib> spTypeLib;
				hr = spTypeInfo->GetContainingTypeLib(&spTypeLib, 0);
				if (SUCCEEDED(hr))
				{
					TLIBATTR* plibAttr;
					hr = spTypeLib->GetLibAttr(&plibAttr);
					if (SUCCEEDED(hr))
					{
						Checked::memcpy_s(plibid, sizeof(GUID), &plibAttr->guid, sizeof(GUID));
						*pdwMajor = plibAttr->wMajorVerNum;
						*pdwMinor = plibAttr->wMinorVerNum;
						spTypeLib->ReleaseTLibAttr(plibAttr);
						// First see if the object is willing to tell us about the
						// default source interface via IProvideClassInfo2
						CComPtr<IProvideClassInfo2> spProvideClassInfo;
						hr = punkObj->QueryInterface(__uuidof(IProvideClassInfo2), (void**)&spProvideClassInfo);
						if (SUCCEEDED(hr) && spProvideClassInfo != NULL)
							hr = spProvideClassInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
						else
						{
							// No, we have to go hunt for it
							CComPtr<ITypeInfo> spInfoCoClass;
							// If we have a clsid, use that
							// Otherwise, try to locate the clsid from IPersist
							CComPtr<IPersist> spPersist;
							CLSID clsid;
							hr = punkObj->QueryInterface(__uuidof(IPersist), (void**)&spPersist);
							if (SUCCEEDED(hr))
							{
								hr = spPersist->GetClassID(&clsid);
								if (SUCCEEDED(hr))
								{
									hr = spTypeLib->GetTypeInfoOfGuid(clsid, &spInfoCoClass);
									if (SUCCEEDED(hr))
									{
										TYPEATTR* pAttr=NULL;
										spInfoCoClass->GetTypeAttr(&pAttr);
										if (pAttr != NULL)
										{
											HREFTYPE hRef;
											for (int i = 0; i < pAttr->cImplTypes; i++)
											{
												int nType;
												hr = spInfoCoClass->GetImplTypeFlags(i, &nType);
												if (SUCCEEDED(hr))
												{
													if (nType == (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE))
													{
														// we found it
														hr = spInfoCoClass->GetRefTypeOfImplType(i, &hRef);
														if (SUCCEEDED(hr))
														{
															CComPtr<ITypeInfo> spInfo;
															hr = spInfoCoClass->GetRefTypeInfo(hRef, &spInfo);
															if (SUCCEEDED(hr))
															{
																TYPEATTR* pAttrIF;
																spInfo->GetTypeAttr(&pAttrIF);
																if (pAttrIF != NULL)
																{
																	Checked::memcpy_s(piid, sizeof(GUID), &pAttrIF->guid, sizeof(GUID));
																	spInfo->ReleaseTypeAttr(pAttrIF);
																}
															}
														}
														break;
													}
												}
											}
											spInfoCoClass->ReleaseTypeAttr(pAttr);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}

#endif	// !_ATL_DLL

}	// namespace ATL
#pragma pack(pop)

#ifdef _ATL_ALL_WARNINGS
#pragma warning(pop)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlcomcli.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLCOMCLI_H__
#define __ATLCOMCLI_H__

#pragma once

#include <atlcore.h>
#include <ole2.h>
#include <olectl.h>

#pragma warning (push)
#pragma warning (disable: 4127)  // conditional expression constant
#pragma warning (disable: 4571)  //catch(...) blocks compiled with /EHs do NOT catch or re-throw Structured Exceptions


#pragma pack(push,_ATL_PACKING)
namespace ATL
{
/////////////////////////////////////////////////////////////////////////////
// Error to HRESULT helpers

ATL_NOINLINE inline HRESULT AtlHresultFromLastError() throw()
{
	DWORD dwErr = ::GetLastError();
	return HRESULT_FROM_WIN32(dwErr);
}

ATL_NOINLINE inline HRESULT AtlHresultFromWin32(_In_ DWORD nError) throw()
{
	return( HRESULT_FROM_WIN32( nError ) );
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(
	_Inout_opt_ _Deref_pre_maybenull_ _Deref_post_maybenull_ IUnknown** pp, 
	_In_opt_ IUnknown* lp);

ATLAPI_(IUnknown*) AtlComQIPtrAssign(
	_Inout_opt_ _Deref_pre_maybenull_ _Deref_post_maybenull_ IUnknown** pp, 
	_In_opt_ IUnknown* lp, 
	_In_ REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Safe Ole Object Reading 

union ClassesAllowedInStream 
{
	const CLSID *rgclsidAllowed;
	HRESULT (*pfnClsidAllowed)(
		_In_ const CLSID& clsid, 
		_In_ REFIID iidInterface, 
		_Deref_out_opt_ void** ppvObj);
};

_Check_return_ inline HRESULT AtlInternalOleLoadFromStream(
	_Inout_ IStream* pStm, 
	_In_ REFIID iidInterface, 
	_Deref_out_ void** ppvObj, 
	_In_ ClassesAllowedInStream rgclsidAllowed, 
	_In_ DWORD cclsidAllowed);


#ifndef _ATL_DLL

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(
	_Inout_opt_ _Deref_pre_maybenull_ _Deref_post_maybenull_ IUnknown** pp, 
	_In_opt_ IUnknown* lp)
{
	if (pp == NULL)
		return NULL;
		
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(
	_Inout_opt_ _Deref_pre_maybenull_ _Deref_post_maybenull_ IUnknown** pp, 
	_In_opt_ IUnknown* lp, 
	_In_ REFIID riid)
{
	if (pp == NULL)
		return NULL;

	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

#endif // _ATL_DLL

/////////////////////////////////////////////////////////////////////////////
// COM Smart pointers

template <class T>
class _NoAddRefReleaseOnCComPtr : 
	public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

_Check_return_ inline HRESULT AtlSetChildSite(
	_Inout_ IUnknown* punkChild, 
	_Inout_opt_ IUnknown* punkParent)
{
	if (punkChild == NULL)
		return E_POINTER;

	HRESULT hr;
	IObjectWithSite* pChildSite = NULL;
	hr = punkChild->QueryInterface(__uuidof(IObjectWithSite), (void**)&pChildSite);
	if (SUCCEEDED(hr) && pChildSite != NULL)
	{
		hr = pChildSite->SetSite(punkParent);
		pChildSite->Release();
	}
	return hr;
}


//CComPtrBase provides the basis for all other smart pointers
//The other smartpointers add their own constructors and operators
template <class T>
class CComPtrBase
{
protected:
	CComPtrBase() throw()
	{
		p = NULL;
	}
	CComPtrBase(_Inout_opt_ T* lp) throw()
	{
		p = lp;
		if (p != NULL)
			p->AddRef();
	}
public:
	typedef T _PtrClass;
	~CComPtrBase() throw()
	{
		if (p)
			p->Release();
	}
	operator T*() const throw()
	{
		return p;
	}
	T& operator*() const
	{
		ATLENSURE(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&() throw()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const throw()
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	bool operator!() const throw()
	{	
		return (p == NULL);
	}
	bool operator<(_In_opt_ T* pT) const throw()
	{
		return p < pT;
	}
	bool operator!=(_In_opt_ T* pT) const
	{
		return !operator==(pT);
	}
	bool operator==(_In_opt_ T* pT) const throw()
	{
		return p == pT;
	}

	// Release the interface and set to NULL
	void Release() throw()
	{
		T* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	// Compare two objects for equivalence
	bool IsEqualObject(_Inout_opt_ IUnknown* pOther) throw()
	{
		if (p == NULL && pOther == NULL)
			return true;	// They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false;	// One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);
		pOther->QueryInterface(__uuidof(IUnknown), (void**)&punk2);
		return punk1 == punk2;
	}
	// Attach to an existing interface (does not AddRef)
	void Attach(_In_opt_ T* p2) throw()
	{
		if (p)
			p->Release();
		p = p2;
	}
	// Detach the interface (does not Release)
	T* Detach() throw()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	_Check_return_ HRESULT CopyTo(_Deref_out_opt_ T** ppT) throw()
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	_Check_return_ HRESULT SetSite(_Inout_opt_ IUnknown* punkParent) throw()
	{
		return AtlSetChildSite(p, punkParent);
	}
	_Check_return_ HRESULT Advise(
		_Inout_ IUnknown* pUnk, 
		_In_ const IID& iid, 
		_Out_ LPDWORD pdw) throw()
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	_Check_return_ HRESULT CoCreateInstance(
		_In_ REFCLSID rclsid, 
		_Inout_opt_ LPUNKNOWN pUnkOuter = NULL, 
		_In_ DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	_Check_return_ HRESULT CoCreateInstance(
		_In_z_ LPCOLESTR szProgID, 
		_Inout_opt_ LPUNKNOWN pUnkOuter = NULL, 
		_In_ DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	_Check_return_ HRESULT QueryInterface(_Deref_out_ Q** pp) const throw()
	{
		ATLASSERT(pp != NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};

template <class T>
class CComPtr : 
	public CComPtrBase<T>
{
public:
	CComPtr() throw()
	{
	}
	CComPtr(_Inout_opt_ T* lp) throw() :
		CComPtrBase<T>(lp)
	{
	}
	CComPtr(_Inout_ const CComPtr<T>& lp) throw() :
		CComPtrBase<T>(lp.p)
	{	
	}
	T* operator=(_Inout_opt_ T* lp) throw()
	{
        if(*this!=lp)
        {
    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
        }
        return *this;
	}
	template <typename Q>
	T* operator=(_Inout_ const CComPtr<Q>& lp) throw()
	{
        if( !IsEqualObject(lp) )
        {
    		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T)));
        }
        return *this;
	}
	T* operator=(_Inout_ const CComPtr<T>& lp) throw()
	{
        if(*this!=lp)
        {
    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
        }
        return *this;
	}	
	CComPtr(_Inout_ CComPtr<T>&& lp) throw() :	
		CComPtrBase<T>()
	{	
		p = lp.p;		
		lp.p = NULL;
	}	
	T* operator=(_Inout_ CComPtr<T>&& lp) throw()
	{			
		if (*this != lp)
		{
			if (p != NULL)			
				p->Release();
			
			p = lp.p;
			lp.p = NULL;
		}
		return *this;		
	}
};

//specialization for IDispatch
template <>
class CComPtr<IDispatch> : 
	public CComPtrBase<IDispatch>
{
public:
	CComPtr() throw()
	{
	}
	CComPtr(_Inout_opt_ IDispatch* lp) throw() :
		CComPtrBase<IDispatch>(lp)
	{
	}
	CComPtr(_Inout_ const CComPtr<IDispatch>& lp) throw() :
		CComPtrBase<IDispatch>(lp.p)
	{
	}		
	IDispatch* operator=(_Inout_opt_ IDispatch* lp) throw()
	{
        if(*this!=lp)
        {
            return static_cast<IDispatch*>(AtlComPtrAssign((IUnknown**)&p, lp));
        }
        return *this;
	}
	IDispatch* operator=(_Inout_ const CComPtr<IDispatch>& lp) throw()
	{
        if(*this!=lp)
        {
    		return static_cast<IDispatch*>(AtlComPtrAssign((IUnknown**)&p, lp.p));
        }
        return *this;
	}	
	CComPtr(_Inout_ CComPtr<IDispatch>&& lp) throw() :	
		CComPtrBase<IDispatch>()
	{		
		p = lp.p;		
		lp.p = NULL;
	}
	IDispatch* operator=(_Inout_ CComPtr<IDispatch>&& lp) throw()
	{		
		if (*this != lp)
		{
			if (p != NULL)			
				p->Release();
			
			p = lp.p;
			lp.p = NULL;
		}		
		return *this;
	}	
// IDispatch specific stuff
	_Check_return_ HRESULT GetPropertyByName(
		_In_z_ LPCOLESTR lpsz, 
		_Out_ VARIANT* pVar) throw()
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = GetProperty(dwDispID, pVar);
		return hr;
	}
	_Check_return_ HRESULT GetProperty(
		_In_ DISPID dwDispID, 
		_Out_ VARIANT* pVar) throw()
	{
		return GetProperty(p, dwDispID, pVar);
	}
	_Check_return_ HRESULT PutPropertyByName(
		_In_z_ LPCOLESTR lpsz, 
		_In_ VARIANT* pVar) throw()
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = PutProperty(dwDispID, pVar);
		return hr;
	}
	_Check_return_ HRESULT PutProperty(
		_In_ DISPID dwDispID, 
		_In_ VARIANT* pVar) throw()
	{
		return PutProperty(p, dwDispID, pVar);
	}
	_Check_return_ HRESULT GetIDOfName(
		_In_z_ LPCOLESTR lpsz, 
		_Out_ DISPID* pdispid) throw()
	{
		return p->GetIDsOfNames(IID_NULL, const_cast<LPOLESTR*>(&lpsz), 1, LOCALE_USER_DEFAULT, pdispid);
	}
	// Invoke a method by DISPID with no parameters
	_Check_return_ HRESULT Invoke0(
		_In_ DISPID dispid, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		DISPPARAMS dispparams = { NULL, NULL, 0, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with no parameters
	_Check_return_ HRESULT Invoke0(
		_In_z_ LPCOLESTR lpszName, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke0(dispid, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with a single parameter
	_Check_return_ HRESULT Invoke1(
		_In_ DISPID dispid, 
		_In_ VARIANT* pvarParam1, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with a single parameter
	_Check_return_ HRESULT Invoke1(
		_In_z_ LPCOLESTR lpszName, 
		_In_ VARIANT* pvarParam1, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{		 
		DISPID dispid;
		HRESULT hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke1(dispid, pvarParam1, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with two parameters
	_Check_return_ HRESULT Invoke2(
		_In_ DISPID dispid, 
		_In_ VARIANT* pvarParam1, 
		_In_ VARIANT* pvarParam2, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw();
	// Invoke a method by name with two parameters
	_Check_return_ HRESULT Invoke2(
		_In_z_ LPCOLESTR lpszName, 
		_In_ VARIANT* pvarParam1, 
		_In_ VARIANT* pvarParam2, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		DISPID dispid;
		HRESULT hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with N parameters
	_Check_return_ HRESULT InvokeN(
		_In_ DISPID dispid, 
		_In_ VARIANT* pvarParams, 
		_In_ int nParams, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with Nparameters
	_Check_return_ HRESULT InvokeN(
		_In_z_ LPCOLESTR lpszName, 
		_In_ VARIANT* pvarParams, 
		_In_ int nParams, 
		_Out_opt_ VARIANT* pvarRet = NULL) throw()
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
		return hr;
	}
	_Check_return_ static HRESULT PutProperty(
		_In_ IDispatch* p, 
		_In_ DISPID dwDispID, 
		_In_ VARIANT* pVar) throw()
	{
		ATLASSERT(p);
		ATLASSERT(pVar != NULL);
		if (pVar == NULL)
			return E_POINTER;
		
		if(p == NULL)
			return E_INVALIDARG;
		
		ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::PutProperty\n"));
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
			(pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
		{
			HRESULT hr = p->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
				&dispparams, NULL, NULL, NULL);
			if (SUCCEEDED(hr))
				return hr;
		}
		return p->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}
	_Check_return_ static HRESULT GetProperty(
		_In_ IDispatch* p, 
		_In_ DISPID dwDispID, 
		_Out_ VARIANT* pVar) throw()
	{
		ATLASSERT(p);
		ATLASSERT(pVar != NULL);
		if (pVar == NULL)
			return E_POINTER;
		
		if(p == NULL)
			return E_INVALIDARG;
			
		ATLTRACE(atlTraceCOM, 2, _T("CPropertyHelper::GetProperty\n"));
		DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
		return p->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
				&dispparamsNoArgs, pVar, NULL, NULL);
	}
};

template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr : 
	public CComPtr<T>
{
public:
	CComQIPtr() throw()
	{
	}
	CComQIPtr(_Inout_opt_ T* lp) throw() :
		CComPtr<T>(lp)
	{
	}
	CComQIPtr(_Inout_ const CComQIPtr<T,piid>& lp) throw() :
		CComPtr<T>(lp.p)
	{
	}
	CComQIPtr(_Inout_opt_ IUnknown* lp) throw()
	{
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	T* operator=(_Inout_opt_ T* lp) throw()
	{
        if(*this!=lp)
        {
		    return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
        }
        return *this;
	}
	T* operator=(_Inout_ const CComQIPtr<T,piid>& lp) throw()
	{
        if(*this!=lp)
        {
    		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp.p));
        }
        return *this;
	}
	T* operator=(_Inout_opt_ IUnknown* lp) throw()
	{
        if(*this!=lp)
        {
    		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, *piid));
        }
        return *this;
	}
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown> : 
	public CComPtr<IUnknown>
{
public:
	CComQIPtr() throw()
	{
	}
	CComQIPtr(_Inout_opt_ IUnknown* lp) throw()
	{
		//Actually do a QI to get identity
		if (lp != NULL)
			lp->QueryInterface(__uuidof(IUnknown), (void **)&p);
	}
	CComQIPtr(_Inout_ const CComQIPtr<IUnknown,&IID_IUnknown>& lp) throw() :
		CComPtr<IUnknown>(lp.p)
	{
	}
	IUnknown* operator=(_Inout_opt_ IUnknown* lp) throw()
	{
        if(*this!=lp)
        {
		    //Actually do a QI to get identity
		    return AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(IUnknown));
        }
        return *this;
	}

	IUnknown* operator=(_Inout_ const CComQIPtr<IUnknown,&IID_IUnknown>& lp) throw()
	{
        if(*this!=lp)
        {
    		return AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        return *this;
	}
};

typedef CComQIPtr<IDispatch, &__uuidof(IDispatch)> CComDispatchDriver;

#define com_cast ATL::CComQIPtr
#ifndef _ATL_STREAM_MAX_SIZE
#define _ATL_STREAM_MAX_SIZE  0x100000
#endif

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;

	CComBSTR() throw()
	{
		m_str = NULL;
	}

#ifdef _ATL_CCOMBSTR_EXPLICIT_CONSTRUCTORS
	explicit CComBSTR(_In_ int nSize)
#else
	CComBSTR(_In_ int nSize)
#endif
	{
		if (nSize < 0)
		{
			AtlThrow(E_INVALIDARG);
		}
		
		if (nSize == 0)
		{
			m_str = NULL;
		}
		else
		{
			m_str = ::SysAllocStringLen(NULL, nSize);
			if (!*this)
            {
				AtlThrow(E_OUTOFMEMORY);
            }
		}
	}

	CComBSTR(_In_ int nSize, _In_opt_count_(nSize) LPCOLESTR sz)
	{
		if (nSize < 0)
		{
			AtlThrow(E_INVALIDARG);
		}
		
		if (nSize == 0)
        {
			m_str = NULL;
        }
		else
		{
			m_str = ::SysAllocStringLen(sz, nSize);
			if (!*this)
            {
				AtlThrow(E_OUTOFMEMORY);
            }
		}
	}

	CComBSTR(_In_opt_z_ LPCOLESTR pSrc)
	{
		if (pSrc == NULL)
        {
			m_str = NULL;
        }
		else
		{
			m_str = ::SysAllocString(pSrc);
			if (!*this)
            {
				AtlThrow(E_OUTOFMEMORY);
            }
		}
	}

	CComBSTR(_In_ const CComBSTR& src)
	{
		m_str = src.Copy();
		if (!!src && !*this)
        {
			AtlThrow(E_OUTOFMEMORY);
        }
	}	

	CComBSTR(_In_ REFGUID guid)
	{
		OLECHAR szGUID[64];
		::StringFromGUID2(guid, szGUID, 64);
		m_str = ::SysAllocString(szGUID);
		if (!*this)
        {
			AtlThrow(E_OUTOFMEMORY);
        }
	}

	CComBSTR& operator=(_In_ const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			::SysFreeString(m_str);
			m_str = src.Copy();
			if (!!src && !*this)
            {
				AtlThrow(E_OUTOFMEMORY);
            }
		}
		return *this;
	}

	CComBSTR& operator=(_In_opt_z_ LPCOLESTR pSrc)
	{
		if (pSrc != m_str)
		{
			::SysFreeString(m_str);
			if (pSrc != NULL)
			{
				m_str = ::SysAllocString(pSrc);
				if (!*this)
                {
					AtlThrow(E_OUTOFMEMORY);
                }
			}
			else
            {
				m_str = NULL;
            }
		}
		return *this;
	}
	CComBSTR(_Inout_ CComBSTR&& src)
	{
		m_str = src.m_str;
		src.m_str = NULL;
	}
	
	CComBSTR& operator=(_Inout_ CComBSTR&& src)
	{
		if (m_str != src.m_str)
		{
			::SysFreeString(m_str);
			m_str = src.m_str;
			src.m_str = NULL;
		}
		return *this;
	}
	
	~CComBSTR() throw();

	unsigned int Length() const throw()
	{
        return ::SysStringLen(m_str);
	}

	unsigned int ByteLength() const throw()
	{
        return ::SysStringByteLen(m_str);
	}

	operator BSTR() const throw()
	{
		return m_str;
	}


#ifndef ATL_CCOMBSTR_ADDRESS_OF_ASSERT
// Temp disable CComBSTR::operator& Assert
#define ATL_NO_CCOMBSTR_ADDRESS_OF_ASSERT
#endif


	BSTR* operator&() throw()
	{
#ifndef ATL_NO_CCOMBSTR_ADDRESS_OF_ASSERT
		ATLASSERT(!*this);
#endif
		return &m_str;
	}

	_Ret_opt_z_ BSTR Copy() const throw()
	{
		if (!*this)
		{
			return NULL;
		}
		else if (m_str != NULL)
		{
			return ::SysAllocStringByteLen((char*)m_str, ::SysStringByteLen(m_str));
		}
		else
		{
			return ::SysAllocStringByteLen(NULL, 0);
		}
	}

	_Check_return_ HRESULT CopyTo(_Deref_out_opt_z_ BSTR* pbstr) const throw()
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
        {
			return E_POINTER;
        }
		*pbstr = Copy();

		if ((*pbstr == NULL) && (m_str != NULL))
        {
			return E_OUTOFMEMORY;
        }
		return S_OK;
	}

	// copy BSTR to VARIANT
	_Check_return_ HRESULT CopyTo(_Out_ VARIANT *pvarDest) const throw()
	{
		ATLASSERT(pvarDest != NULL);
		HRESULT hRes = E_POINTER;
		if (pvarDest != NULL)
		{
			pvarDest->vt = VT_BSTR;
			pvarDest->bstrVal = Copy();

			if (pvarDest->bstrVal == NULL && m_str != NULL)
            {
				hRes = E_OUTOFMEMORY;
            }
			else
            {
				hRes = S_OK;
            }
		}
		return hRes;
	}

	void Attach(_In_opt_z_ BSTR src) throw()
	{
		if (m_str != src)
		{
			::SysFreeString(m_str);
			m_str = src;
		}
	}

	_Ret_opt_z_ BSTR Detach() throw()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}

	void Empty() throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}

	bool operator!() const throw()
	{
		return (m_str == NULL);
	}

	_Check_return_ HRESULT Append(_In_ const CComBSTR& bstrSrc) throw()
	{
		return AppendBSTR(bstrSrc.m_str);
	}

	_Check_return_ HRESULT Append(_In_z_ LPCOLESTR lpsz) throw()
	{		
		return Append(lpsz, UINT(ocslen(lpsz)));
	}

	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	_Check_return_ HRESULT AppendBSTR(_In_opt_z_ BSTR p) throw()
	{
        if (::SysStringLen(p) == 0)
        {
			return S_OK;
        }
		BSTR bstrNew = NULL;
		HRESULT hr;
		__analysis_assume(p);
		hr = VarBstrCat(m_str, p, &bstrNew);
		if (SUCCEEDED(hr))
		{
			::SysFreeString(m_str);
			m_str = bstrNew;
		}
		return hr;
	}

	_Check_return_ HRESULT Append(_In_opt_count_(nLen) LPCOLESTR lpsz, _In_ int nLen) throw()
	{
		if (lpsz == NULL || (m_str != NULL && nLen == 0))
		{
			return S_OK;
		}
		else if (nLen < 0)
		{
			return E_INVALIDARG;
		}
		
		const unsigned int n1 = Length();
		unsigned int n1Bytes = 0;
		unsigned int nSize = 0;
		unsigned int nSizeBytes = 0;
		
		HRESULT hr = AtlAdd<unsigned int>(&nSize, n1, nLen);
		if (FAILED(hr))
		{
			return hr;
		}
		
		hr = AtlMultiply<unsigned int>(&nSizeBytes, nSize, sizeof(OLECHAR));
		if (FAILED(hr))
		{
			return hr;
		}
		
		hr = AtlMultiply<unsigned int>(&n1Bytes, n1, sizeof(OLECHAR));
		if (FAILED(hr))
		{
			return hr;
		}
		
		BSTR b = ::SysAllocStringLen(NULL, nSize);
		if (b == NULL)
		{
			return E_OUTOFMEMORY;
		}
		
		if(::SysStringLen(m_str) > 0)
		{
			__analysis_assume(m_str); // ::SysStringLen(m_str) guarantees that m_str != NULL
			Checked::memcpy_s(b, nSizeBytes, m_str, n1Bytes);
		}
				
		Checked::memcpy_s(b+n1, nLen*sizeof(OLECHAR), lpsz, nLen*sizeof(OLECHAR));
		b[nSize] = '\0';
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}

	_Check_return_ HRESULT Append(_In_ char ch) throw()
	{
		OLECHAR chO = ch;

		return( Append( &chO, 1 ) );
	}

	_Check_return_ HRESULT Append(_In_ wchar_t ch) throw()
	{
		return( Append( &ch, 1 ) );
	}

	_Check_return_ HRESULT AppendBytes(
		_In_opt_count_(nLen) const char* lpsz, 
		_In_ int nLen) throw()
	{
		if (lpsz == NULL || nLen == 0)
		{
			return S_OK;
		}
		else if (nLen < 0)
		{
			return E_INVALIDARG;
		}
				
		const unsigned int n1 = ByteLength();		
		unsigned int nSize = 0;
		HRESULT hr = AtlAdd<unsigned int>(&nSize, n1, nLen);
		if (FAILED(hr))
		{
			return hr;
		}
						 
		BSTR b = ::SysAllocStringByteLen(NULL, nSize);
		if (b == NULL)
        {
			return E_OUTOFMEMORY;
        }
		
		Checked::memcpy_s(b, nSize, m_str, n1);
		Checked::memcpy_s(((char*)b) + n1, nLen, lpsz, nLen);
		
		*((OLECHAR*)(((char*)b) + nSize)) = '\0';
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}

	_Check_return_ HRESULT AssignBSTR(_In_opt_z_ const BSTR bstrSrc) throw()
	{
		HRESULT hr = S_OK;
		if (m_str != bstrSrc)
		{
			::SysFreeString(m_str);
			if (bstrSrc != NULL)
			{
				m_str = ::SysAllocStringByteLen((char*)bstrSrc, ::SysStringByteLen(bstrSrc));
				if (!*this)
                {
					hr = E_OUTOFMEMORY;
                }
			}
			else
            {
				m_str = NULL;
            }
		}

		return hr;
	}

	_Check_return_ HRESULT ToLower() throw()
	{
		if (::SysStringLen(m_str) > 0)
		{
#ifdef _UNICODE
			// Convert in place
			CharLowerBuff(m_str, Length());
#else
			// Cannot use conversion macros due to possible embedded NULLs
			UINT _acp = _AtlGetConversionACP();
			int _convert = WideCharToMultiByte(_acp, 0, m_str, Length(), NULL, 0, NULL, NULL);
			CTempBuffer<char> pszA;
			ATLTRY(pszA.Allocate(_convert));
			if (pszA == NULL)
				return E_OUTOFMEMORY;

			int nRet = WideCharToMultiByte(_acp, 0, m_str, Length(), pszA, _convert, NULL, NULL);
			if (nRet == 0)
			{
				ATLASSERT(0);
				return AtlHresultFromLastError();
			}

			CharLowerBuff(pszA, nRet);

			_convert = MultiByteToWideChar(_acp, 0, pszA, nRet, NULL, 0);

			CTempBuffer<WCHAR> pszW;
			ATLTRY(pszW.Allocate(_convert));
			if (pszW == NULL)
				return E_OUTOFMEMORY;

			nRet = MultiByteToWideChar(_acp, 0, pszA, nRet, pszW, _convert);
			if (nRet <= 0)
			{
				ATLASSERT(0);
				return AtlHresultFromLastError();
			}

			UINT nBytes=0;	
			HRESULT hr=S_OK;
			if( FAILED(hr=::ATL::AtlMultiply(&nBytes, static_cast<UINT>(nRet), static_cast<UINT>(sizeof(OLECHAR)))))
			{
				return hr;
			}
			BSTR b = ::SysAllocStringByteLen((LPCSTR) (LPWSTR) pszW, nBytes);
			if (b == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
#endif
		}
		return S_OK;
	}
	_Check_return_ HRESULT ToUpper() throw()
	{
		if (::SysStringLen(m_str) > 0)
		{
#ifdef _UNICODE
			// Convert in place
			CharUpperBuff(m_str, Length());
#else
			// Cannot use conversion macros due to possible embedded NULLs
			UINT _acp = _AtlGetConversionACP();
			int _convert = WideCharToMultiByte(_acp, 0, m_str, Length(), NULL, 0, NULL, NULL);
			CTempBuffer<char> pszA;
			ATLTRY(pszA.Allocate(_convert));
			if (pszA == NULL)
				return E_OUTOFMEMORY;

			int nRet = WideCharToMultiByte(_acp, 0, m_str, Length(), pszA, _convert, NULL, NULL);
			if (nRet == 0)
			{
				ATLASSERT(0);
				return AtlHresultFromLastError();
			}

			CharUpperBuff(pszA, nRet);

			_convert = MultiByteToWideChar(_acp, 0, pszA, nRet, NULL, 0);

			CTempBuffer<WCHAR> pszW;
			ATLTRY(pszW.Allocate(_convert));
			if (pszW == NULL)
				return E_OUTOFMEMORY;

			nRet = MultiByteToWideChar(_acp, 0, pszA, nRet, pszW, _convert);
			if (nRet <= 0)
			{
				ATLASSERT(0);
				return AtlHresultFromLastError();
			}

			UINT nBytes=0;
			HRESULT hr=S_OK;
			if( FAILED(hr=::ATL::AtlMultiply(&nBytes, static_cast<UINT>(nRet), static_cast<UINT>(sizeof(OLECHAR)))))
			{		
				return hr;
			}
			BSTR b = ::SysAllocStringByteLen((LPCSTR) (LPWSTR) pszW, nBytes);
			if (b == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
#endif
		}
		return S_OK;
	}

	bool LoadString(
		_In_ HINSTANCE hInst, 
		_In_ UINT nID) throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
		return LoadStringResource(hInst, nID, m_str);
	}

	bool LoadString(_In_ UINT nID) throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
		return LoadStringResource(nID, m_str);
	}

	CComBSTR& operator+=(_In_ const CComBSTR& bstrSrc)
	{
		HRESULT hr;
		hr = AppendBSTR(bstrSrc.m_str);
		if (FAILED(hr))
			AtlThrow(hr);
		return *this;
	}

	CComBSTR& operator+=(_In_z_ LPCOLESTR pszSrc)
	{
		HRESULT hr;
		hr = Append(pszSrc);
		if (FAILED(hr))
			AtlThrow(hr);
		return *this;
	}

	bool operator<(_In_ const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == static_cast<HRESULT>(VARCMP_LT);
	}
	bool operator<(_In_z_ LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator<(bstr2);
	}
	bool operator<(_In_z_ LPOLESTR pszSrc) const
	{
		return operator<((LPCOLESTR)pszSrc);
	}

	bool operator>(_In_ const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == static_cast<HRESULT>(VARCMP_GT);
	}
	bool operator>(_In_z_ LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator>(bstr2);
	}
	bool operator>(_In_z_ LPOLESTR pszSrc) const
	{
		return operator>((LPCOLESTR)pszSrc);
	}
	
	bool operator!=(_In_ const CComBSTR& bstrSrc) const throw()
	{
		return !operator==(bstrSrc);
	}
	bool operator!=(_In_z_ LPCOLESTR pszSrc) const
	{
		return !operator==(pszSrc);
	}
	bool operator!=(_In_ int nNull) const throw()
	{
		return !operator==(nNull);
	}
	bool operator!=(_In_z_ LPOLESTR pszSrc) const
	{
		return operator!=((LPCOLESTR)pszSrc);
	}
	bool operator==(_In_ const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == static_cast<HRESULT>(VARCMP_EQ);
	}
	bool operator==(LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator==(bstr2);
	}
	bool operator==(_In_z_ LPOLESTR pszSrc) const
	{
		return operator==((LPCOLESTR)pszSrc);
	}
	
	bool operator==(_In_ int nNull) const throw()
	{
		ATLASSERT(nNull == 0);
		(void)nNull;
		return (!*this);
	}

#if defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_ATL)
	#ifdef _M_CEE
		CComBSTR(decltype(__nullptr)) 
		{
			m_str = NULL; 
		}
		bool operator==(decltype(__nullptr)) const throw() 
		{
			return *this == 0; 
		}
		bool operator!=(decltype(__nullptr)) const throw() 
		{
			return *this != 0; 
		}
	#else // _M_CEE
		CComBSTR(decltype(nullptr)) 
		{
			m_str = NULL; 
		}
		bool operator==(decltype(nullptr)) const throw() 
		{ 
			return *this == 0; 
		}
		bool operator!=(decltype(nullptr)) const throw() 
		{
			return *this != 0; 
		}
	#endif // _M_CEE
#endif // defined(_NATIVE_NULLPTR_SUPPORTED) && !defined(_DO_NOT_USE_NULLPTR_IN_ATL)

	CComBSTR(_In_opt_z_ LPCSTR pSrc)
	{
		if (pSrc != NULL)
		{
			m_str = A2WBSTR(pSrc);
			if (!*this)
            {
				AtlThrow(E_OUTOFMEMORY);
            }
		}
		else
        {
			m_str = NULL;
        }
	}

	CComBSTR(_In_ int nSize, _In_opt_count_(nSize) LPCSTR sz)
	{
		if (nSize < 0)
		{
			AtlThrow(E_INVALIDARG);
		}
		
		if (nSize != 0 && sz == NULL)
		{
			m_str = ::SysAllocStringLen(NULL, nSize);
			if (!*this)
			{
				AtlThrow(E_OUTOFMEMORY);
			}
			return;
		}

		m_str = A2WBSTR(sz, nSize);
		if (!*this && nSize != 0)
        {
			AtlThrow(E_OUTOFMEMORY);
        }
	}

	_Check_return_ HRESULT Append(_In_opt_z_ LPCSTR lpsz) throw()
	{
		if (lpsz == NULL)
			return S_OK;

		CComBSTR bstrTemp;
		ATLTRY(bstrTemp = lpsz);
		if (!bstrTemp)
        {
			return E_OUTOFMEMORY;
        }
		return Append(bstrTemp);
	}

	CComBSTR& operator=(_In_opt_z_ LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		if (!*this && pSrc != NULL)
        {
			AtlThrow(E_OUTOFMEMORY);
        }
		return *this;
	}

	bool operator<(_In_opt_z_ LPCSTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator<(bstr2);
	}
	bool operator>(_In_opt_z_ LPCSTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator>(bstr2);
	}
	bool operator!=(_In_opt_z_ LPCSTR pszSrc) const
	{
		return !operator==(pszSrc);
	}
	bool operator==(_In_opt_z_ LPCSTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator==(bstr2);
	}

	_Check_return_ HRESULT WriteToStream(_Inout_ IStream* pStream) throw()
	{
		ATLASSERT(pStream != NULL);
		if(pStream == NULL)
		{
			return E_INVALIDARG;
		}
		
		ULONG cb;
		ULONG cbStrLen = CComBSTR::GetStreamSize(m_str);		
		ATLASSERT(cbStrLen >= sizeof(ULONG));
		cbStrLen -= sizeof(ULONG);
			
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
		{
			return hr;
		}
		
		if (cbStrLen == 0)
		{
			return S_OK;
		}			
		return pStream->Write((void*) m_str, cbStrLen, &cb);
	}

	_Check_return_ HRESULT ReadFromStream(_Inout_ IStream* pStream) throw()
	{
		ATLASSERT(pStream != NULL);
		if(pStream == NULL)
		{
			return E_INVALIDARG;
		}

		ATLASSERT(!*this); // should be empty
		Empty();
		
		HRESULT hrSeek;
		ULARGE_INTEGER nBegOffset;
		{
			LARGE_INTEGER nZeroOffset;
			nZeroOffset.QuadPart = 0L;
			hrSeek = pStream->Seek(nZeroOffset, STREAM_SEEK_CUR, &nBegOffset);
		}

		ULONG cbRead = 0;
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read(reinterpret_cast<void*>(&cbStrLen), sizeof(cbStrLen), &cbRead);

		if (SUCCEEDED(hr))
		{
			// invalid data size
			if (sizeof(cbStrLen) != cbRead)
			{
				ATLTRACE(atlTraceCOM, 0, _T("Input stream is corrupted."));
				hr = E_FAIL;
			}
			// read NULL string
			else if (cbStrLen == 0)
			{				
			}
			// invalid data length	
			else if (cbStrLen < sizeof(OLECHAR))
			{
				ATLTRACE(atlTraceCOM, 0, _T("Input stream is corrupted."));
				hr = E_FAIL;
			}
			// security checks when system hang for huge stream of data
			else if (cbStrLen > _ATL_STREAM_MAX_SIZE)
			{
				ATLTRACE(atlTraceCOM, 0, _T("String exceeded the maximum allowed size see _ATL_STREAM_MAX_SIZE."));
				hr = E_ACCESSDENIED;
			}
			else 
			{
				//subtract size for terminating NULL which we wrote out
				cbStrLen -= sizeof(OLECHAR);

				m_str = ::SysAllocStringByteLen(NULL, cbStrLen);
				if (!*this)
				{
					hr = E_OUTOFMEMORY;
				}
				else
				{
					hr = pStream->Read(reinterpret_cast<void*>(m_str), cbStrLen, &cbRead);

					if (SUCCEEDED(hr))
					{
						if (cbRead != cbStrLen)
						{
							ATLTRACE(atlTraceCOM, 0, _T("Length of string data is different than expected."));
							hr = E_FAIL;
						}
						else
						{
							OLECHAR ch;
							hr = pStream->Read(reinterpret_cast<void*>(&ch), sizeof(OLECHAR), &cbRead);	

							if (SUCCEEDED(hr))
							{								
#ifndef _ATL_CCOMBSTR_READFROMSTREAM_INSECURE
								if (cbRead != sizeof(OLECHAR) || ch != L'\0')
#else
								if (cbRead != sizeof(OLECHAR))
#endif
								{
									ATLTRACE(atlTraceCOM, 0, _T("Cannot read NULL terminator from stream."));
									hr = E_FAIL; 									
								}								
							}
						}
					}			
						
					if (FAILED(hr))
					{
						::SysFreeString(m_str);
						m_str = NULL;
					}
				}
			}
		}
		
		// If SysAllocStringByteLen or IStream::Read failed, reset seek 
		// pointer to start of BSTR size.
		if (FAILED(hr) && SUCCEEDED(hrSeek))
		{
			LARGE_INTEGER nOffset;
			nOffset.QuadPart = static_cast<LONGLONG>(nBegOffset.QuadPart);
			pStream->Seek(nOffset, STREAM_SEEK_SET, NULL);				
		}
	
		return hr;
	}

	static bool LoadStringResource(
		_In_ HINSTANCE hInstance, 
		_In_ UINT uID, 
		_Deref_out_opt_z_ BSTR& bstrText) throw()
	{
ATLPREFAST_SUPPRESS(6001) // Using uninitialized memory
		ATLASSERT(bstrText == NULL);
ATLPREFAST_UNSUPPRESS()
	
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage(hInstance, uID);
		if (pImage != NULL)
		{
			bstrText = ::SysAllocStringLen(pImage->achString, pImage->nLength);
		}
		else 
		{
			bstrText = NULL;
		}
		return (bstrText != NULL) ? true : false;
	}

	static bool LoadStringResource(
		_In_ UINT uID, 
		_Deref_out_opt_z_ BSTR& bstrText) throw()
	{
ATLPREFAST_SUPPRESS(6001) // Using uninitialized memory
		ATLASSERT(bstrText == NULL);
ATLPREFAST_UNSUPPRESS()
	
		const ATLSTRINGRESOURCEIMAGE* pImage = AtlGetStringResourceImage(uID);	
		if (pImage != NULL)
		{
			bstrText = ::SysAllocStringLen(pImage->achString, pImage->nLength);
		}
		else 
		{
			bstrText = NULL;
		}

		return (bstrText != NULL) ? true : false;
	}

	// each character in BSTR is copied to each element in SAFEARRAY
	HRESULT BSTRToArray(_Deref_out_ LPSAFEARRAY *ppArray) throw()
	{
		return VectorFromBstr(m_str, ppArray);
	}

	// first character of each element in SAFEARRAY is copied to BSTR
	_Check_return_ HRESULT ArrayToBSTR(_In_ const SAFEARRAY *pSrc) throw()
	{
		::SysFreeString(m_str);
		return BstrFromVector((LPSAFEARRAY)pSrc, &m_str);
	}
	static ULONG GetStreamSize(_In_opt_z_ BSTR bstr)
	{
		ULONG ulSize = sizeof(ULONG);
		if (bstr != NULL)
		{
			ulSize += SysStringByteLen(bstr) + sizeof(OLECHAR);			
		}		
		
		return ulSize;
	}
};

inline CComBSTR::~CComBSTR() throw()
	{
		::SysFreeString(m_str);
	}

inline void SysFreeStringHelper(_In_ CComBSTR& bstr)
{
	bstr.Empty();
}

inline void SysFreeStringHelper(_In_opt_z_ BSTR bstr)
{
	::SysFreeString(bstr);
}

_Check_return_ inline HRESULT SysAllocStringHelper(
	_Out_ CComBSTR& bstrDest,
	_In_opt_z_ BSTR bstrSrc)
{
	bstrDest=bstrSrc;
	return !bstrDest ? E_OUTOFMEMORY : S_OK;
}

_Check_return_ inline HRESULT SysAllocStringHelper(
	_Out_ BSTR& bstrDest,
	_In_opt_z_ BSTR bstrSrc)
{
	bstrDest=::SysAllocString(bstrSrc);

	return bstrDest==NULL ? E_OUTOFMEMORY : S_OK;
}

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
	CAdapt()
	{
	}
	CAdapt(_In_ const T& rSrc) :
		m_T( rSrc )
	{
	}	
	CAdapt(_In_ const CAdapt& rSrCA) :
		m_T( rSrCA.m_T )
	{	
	}	
	CAdapt& operator=(_In_ const T& rSrc)
	{		
		m_T = rSrc;

		return *this;
	}	
	CAdapt& operator=(_In_ const CAdapt<T>& rSrc)
	{		
		if (this != &rSrc)
		{
			m_T = rSrc.m_T;			
		}		
		return *this;
	}	
	CAdapt(_Inout_ T&& rSrc) :
		m_T( static_cast<T&&>(rSrc) )
	{
	}
	CAdapt(_Inout_ CAdapt&& rSrCA) : 
		m_T( static_cast<T&&>(rSrCA.m_T) )
	{		
	}
	CAdapt& operator=(_Inout_ T&& rSrc)
	{	
		m_T = static_cast<T&&>(rSrc);	
				
		return *this;
	}
	CAdapt& operator=(_Inout_ CAdapt<T>&& rSrc)
	{			
		if (this != &rSrc)
		{
			m_T = static_cast<T&&>( rSrc.m_T );
		}		
		return *this;
	}	
	bool operator<(_In_ const T& rSrc) const
	{
		return m_T < rSrc;
	}
	bool operator==(_In_ const T& rSrc) const
	{
		return m_T == rSrc;
	}
	operator T&()
	{
		return m_T;
	}

	operator const T&() const
	{
		return m_T;
	}

	T& operator->()
	{
		return m_T;
	}

	const T& operator->() const
	{
		return m_T;
	}

	T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant


#define ATL_VARIANT_TRUE VARIANT_BOOL( -1 )
#define ATL_VARIANT_FALSE VARIANT_BOOL( 0 )

template< typename T > 
class CVarTypeInfo
{
//	static const VARTYPE VT;  // VARTYPE corresponding to type T
//	static T VARIANT::* const pmField;  // Pointer-to-member of corresponding field in VARIANT struct
};

template<>
class CVarTypeInfo< char >
{
public:
#ifdef _CHAR_UNSIGNED
	ATLSTATIC_ASSERT(false, "CVarTypeInfo< char > cannot be compiled with /J or _CHAR_UNSIGNED flag enabled");
#endif
	static const VARTYPE VT = VT_I1;
	static char VARIANT::* const pmField;
};

__declspec( selectany ) char VARIANT::* const CVarTypeInfo< char >::pmField = &VARIANT::cVal;

template<>
class CVarTypeInfo< unsigned char >
{
public:
	static const VARTYPE VT = VT_UI1;
	static unsigned char VARIANT::* const pmField;
};

__declspec( selectany ) unsigned char VARIANT::* const CVarTypeInfo< unsigned char >::pmField = &VARIANT::bVal;

template<>
class CVarTypeInfo< char* >
{
public:
#ifdef _CHAR_UNSIGNED
	ATLSTATIC_ASSERT(false, "CVarTypeInfo< char* > cannot be compiled with /J or _CHAR_UNSIGNED flag enabled");
#endif
	static const VARTYPE VT = VT_I1|VT_BYREF;
	static char* VARIANT::* const pmField;
};

__declspec( selectany ) char* VARIANT::* const CVarTypeInfo< char* >::pmField = &VARIANT::pcVal;

template<>
class CVarTypeInfo< unsigned char* >
{
public:
	static const VARTYPE VT = VT_UI1|VT_BYREF;
	static unsigned char* VARIANT::* const pmField;
};

__declspec( selectany ) unsigned char* VARIANT::* const CVarTypeInfo< unsigned char* >::pmField = &VARIANT::pbVal;

template<>
class CVarTypeInfo< short >
{
public:
	static const VARTYPE VT = VT_I2;
	static short VARIANT::* const pmField;
};

__declspec( selectany ) short VARIANT::* const CVarTypeInfo< short >::pmField = &VARIANT::iVal;

template<>
class CVarTypeInfo< short* >
{
public:
	static const VARTYPE VT = VT_I2|VT_BYREF;
	static short* VARIANT::* const pmField;
};

__declspec( selectany ) short* VARIANT::* const CVarTypeInfo< short* >::pmField = &VARIANT::piVal;

template<>
class CVarTypeInfo< unsigned short >
{
public:
	static const VARTYPE VT = VT_UI2;
	static unsigned short VARIANT::* const pmField;
};

__declspec( selectany ) unsigned short VARIANT::* const CVarTypeInfo< unsigned short >::pmField = &VARIANT::uiVal;

#ifdef _NATIVE_WCHAR_T_DEFINED  // Only treat unsigned short* as VT_UI2|VT_BYREF if BSTR isn't the same as unsigned short*
template<>
class CVarTypeInfo< unsigned short* >
{
public:
	static const VARTYPE VT = VT_UI2|VT_BYREF;
	static unsigned short* VARIANT::* const pmField;
};

__declspec( selectany ) unsigned short* VARIANT::* const CVarTypeInfo< unsigned short* >::pmField = &VARIANT::puiVal;
#endif  // _NATIVE_WCHAR_T_DEFINED

template<>
class CVarTypeInfo< int >
{
public:
	static const VARTYPE VT = VT_I4;
	static int VARIANT::* const pmField;
};

__declspec( selectany ) int VARIANT::* const CVarTypeInfo< int >::pmField = &VARIANT::intVal;

template<>
class CVarTypeInfo< int* >
{
public:
	static const VARTYPE VT = VT_I4|VT_BYREF;
	static int* VARIANT::* const pmField;
};

__declspec( selectany ) int* VARIANT::* const CVarTypeInfo< int* >::pmField = &VARIANT::pintVal;

template<>
class CVarTypeInfo< unsigned int >
{
public:
	static const VARTYPE VT = VT_UI4;
	static unsigned int VARIANT::* const pmField;
};

__declspec( selectany ) unsigned int VARIANT::* const CVarTypeInfo< unsigned int >::pmField = &VARIANT::uintVal;

template<>
class CVarTypeInfo< unsigned int* >
{
public:
	static const VARTYPE VT = VT_UI4|VT_BYREF;
	static unsigned int* VARIANT::* const pmField;
};

__declspec( selectany ) unsigned int* VARIANT::* const CVarTypeInfo< unsigned int* >::pmField = &VARIANT::puintVal;

template<>
class CVarTypeInfo< long >
{
public:
	static const VARTYPE VT = VT_I4;
	static long VARIANT::* const pmField;
};

__declspec( selectany ) long VARIANT::* const CVarTypeInfo< long >::pmField = &VARIANT::lVal;

template<>
class CVarTypeInfo< long* >
{
public:
	static const VARTYPE VT = VT_I4|VT_BYREF;
	static long* VARIANT::* const pmField;
};

__declspec( selectany ) long* VARIANT::* const CVarTypeInfo< long* >::pmField = &VARIANT::plVal;

template<>
class CVarTypeInfo< unsigned long >
{
public:
	static const VARTYPE VT = VT_UI4;
	static unsigned long VARIANT::* const pmField;
};

__declspec( selectany ) unsigned long VARIANT::* const CVarTypeInfo< unsigned long >::pmField = &VARIANT::ulVal;

template<>
class CVarTypeInfo< unsigned long* >
{
public:
	static const VARTYPE VT = VT_UI4|VT_BYREF;
	static unsigned long* VARIANT::* const pmField;
};

__declspec( selectany ) unsigned long* VARIANT::* const CVarTypeInfo< unsigned long* >::pmField = &VARIANT::pulVal;

template<>
class CVarTypeInfo< __int64 >
{
public:
	static const VARTYPE VT = VT_I8;
	static __int64 VARIANT::* const pmField;
};

__declspec( selectany ) __int64 VARIANT::* const CVarTypeInfo< __int64 >::pmField = &VARIANT::llVal;

template<>
class CVarTypeInfo< __int64* >
{
public:
	static const VARTYPE VT = VT_I8|VT_BYREF;
	static __int64* VARIANT::* const pmField;
};

__declspec( selectany ) __int64* VARIANT::* const CVarTypeInfo< __int64* >::pmField = &VARIANT::pllVal;

template<>
class CVarTypeInfo< unsigned __int64 >
{
public:
	static const VARTYPE VT = VT_UI8;
	static unsigned __int64 VARIANT::* const pmField;
};

__declspec( selectany ) unsigned __int64 VARIANT::* const CVarTypeInfo< unsigned __int64 >::pmField = &VARIANT::ullVal;

template<>
class CVarTypeInfo< unsigned __int64* >
{
public:
	static const VARTYPE VT = VT_UI8|VT_BYREF;
	static unsigned __int64* VARIANT::* const pmField;
};

__declspec( selectany ) unsigned __int64* VARIANT::* const CVarTypeInfo< unsigned __int64* >::pmField = &VARIANT::pullVal;

template<>
class CVarTypeInfo< float >
{
public:
	static const VARTYPE VT = VT_R4;
	static float VARIANT::* const pmField;
};

__declspec( selectany ) float VARIANT::* const CVarTypeInfo< float >::pmField = &VARIANT::fltVal;

template<>
class CVarTypeInfo< float* >
{
public:
	static const VARTYPE VT = VT_R4|VT_BYREF;
	static float* VARIANT::* const pmField;
};

__declspec( selectany ) float* VARIANT::* const CVarTypeInfo< float* >::pmField = &VARIANT::pfltVal;

template<>
class CVarTypeInfo< double >
{
public:
	static const VARTYPE VT = VT_R8;
	static double VARIANT::* const pmField;
};

__declspec( selectany ) double VARIANT::* const CVarTypeInfo< double >::pmField = &VARIANT::dblVal;

template<>
class CVarTypeInfo< double* >
{
public:
	static const VARTYPE VT = VT_R8|VT_BYREF;
	static double* VARIANT::* const pmField;
};

__declspec( selectany ) double* VARIANT::* const CVarTypeInfo< double* >::pmField = &VARIANT::pdblVal;

template<>

class CVarTypeInfo< VARIANT* >
{
public:
	static const VARTYPE VT = VT_VARIANT|VT_BYREF;
};

template<>
class CVarTypeInfo< BSTR >
{
public:
	static const VARTYPE VT = VT_BSTR;
	static BSTR VARIANT::* const pmField;
};

__declspec( selectany ) BSTR VARIANT::* const CVarTypeInfo< BSTR >::pmField = &VARIANT::bstrVal;

template<>
class CVarTypeInfo< BSTR* >
{
public:
	static const VARTYPE VT = VT_BSTR|VT_BYREF;
	static BSTR* VARIANT::* const pmField;
};

__declspec( selectany ) BSTR* VARIANT::* const CVarTypeInfo< BSTR* >::pmField = &VARIANT::pbstrVal;

template<>
class CVarTypeInfo< IUnknown* >
{
public:
	static const VARTYPE VT = VT_UNKNOWN;
	static IUnknown* VARIANT::* const pmField;
};

__declspec( selectany ) IUnknown* VARIANT::* const CVarTypeInfo< IUnknown* >::pmField = &VARIANT::punkVal;

template<>
class CVarTypeInfo< IUnknown** >
{
public:
	static const VARTYPE VT = VT_UNKNOWN|VT_BYREF;
	static IUnknown** VARIANT::* const pmField;
};

__declspec( selectany ) IUnknown** VARIANT::* const CVarTypeInfo< IUnknown** >::pmField = &VARIANT::ppunkVal;

template<>
class CVarTypeInfo< IDispatch* >
{
public:
	static const VARTYPE VT = VT_DISPATCH;
	static IDispatch* VARIANT::* const pmField;
};

__declspec( selectany ) IDispatch* VARIANT::* const CVarTypeInfo< IDispatch* >::pmField = &VARIANT::pdispVal;

template<>
class CVarTypeInfo< IDispatch** >
{
public:
	static const VARTYPE VT = VT_DISPATCH|VT_BYREF;
	static IDispatch** VARIANT::* const pmField;
};

__declspec( selectany ) IDispatch** VARIANT::* const CVarTypeInfo< IDispatch** >::pmField = &VARIANT::ppdispVal;

template<>
class CVarTypeInfo< CY >
{
public:
	static const VARTYPE VT = VT_CY;
	static CY VARIANT::* const pmField;
};

__declspec( selectany ) CY VARIANT::* const CVarTypeInfo< CY >::pmField = &VARIANT::cyVal;

template<>
class CVarTypeInfo< CY* >
{
public:
	static const VARTYPE VT = VT_CY|VT_BYREF;
	static CY* VARIANT::* const pmField;
};

__declspec( selectany ) CY* VARIANT::* const CVarTypeInfo< CY* >::pmField = &VARIANT::pcyVal;

#ifdef _ATL_NO_VARIANT_THROW
#define ATLVARIANT_THROW()		throw()
#else
#define ATLVARIANT_THROW()
#endif

class CComVariant : 
	public tagVARIANT
{
// Constructors
public:
	CComVariant() throw()
	{
		::VariantInit(this);
	}
	~CComVariant() throw()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		(hr);
	}
	CComVariant(_In_ const VARIANT& varSrc) ATLVARIANT_THROW()
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}
	CComVariant(_In_ const CComVariant& varSrc) ATLVARIANT_THROW()
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}
	CComVariant(_In_z_ LPCOLESTR lpszSrc) ATLVARIANT_THROW()
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
	CComVariant(_In_z_ LPCSTR lpszSrc) ATLVARIANT_THROW()
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
	CComVariant(_In_ bool bSrc) throw()
	{
		vt = VT_BOOL;
		boolVal = bSrc ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
	}

	CComVariant(_In_ int nSrc, _In_ VARTYPE vtSrc = VT_I4) ATLVARIANT_THROW()
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_INT);
		if (vtSrc == VT_I4 || vtSrc == VT_INT)
		{
			vt = vtSrc;
			intVal = nSrc;
		}
		else
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif			
		}
	}

	CComVariant(_In_ BYTE nSrc) throw()
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(_In_ short nSrc) throw()
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(_In_ long nSrc, _In_ VARTYPE vtSrc = VT_I4) ATLVARIANT_THROW()
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		if (vtSrc == VT_I4 || vtSrc == VT_ERROR)
		{
			vt = vtSrc;
			lVal = nSrc;
		}
		else
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif
		}
	}

	CComVariant(_In_ float fltSrc) throw()
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(_In_ double dblSrc, _In_ VARTYPE vtSrc = VT_R8) ATLVARIANT_THROW()
	{
		ATLASSERT(vtSrc == VT_R8 || vtSrc == VT_DATE);
		if (vtSrc == VT_R8 || vtSrc == VT_DATE)
		{
			vt = vtSrc;
			dblVal = dblSrc;
		}
		else
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif
		}
	}

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	CComVariant(_In_ LONGLONG nSrc) throw()
	{
		vt = VT_I8;
		llVal = nSrc;
	}
	CComVariant(_In_ ULONGLONG nSrc) throw()
	{
		vt = VT_UI8;
		ullVal = nSrc;
	}
#endif
	CComVariant(_In_ CY cySrc) throw()
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(_In_opt_ IDispatch* pSrc) throw()
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(_In_opt_ IUnknown* pSrc) throw()
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}
	CComVariant(_In_ char cSrc) throw()
	{
		vt = VT_I1;
		cVal = cSrc;
	}
	CComVariant(_In_ unsigned short nSrc) throw()
	{
		vt = VT_UI2;
		uiVal = nSrc;
	}
	CComVariant(_In_ unsigned long nSrc) throw()
	{
		vt = VT_UI4;
		ulVal = nSrc;
	}
	CComVariant(_In_ unsigned int nSrc, _In_ VARTYPE vtSrc = VT_UI4) ATLVARIANT_THROW()
	{
		ATLASSERT(vtSrc == VT_UI4 || vtSrc == VT_UINT);
		if (vtSrc == VT_UI4 || vtSrc == VT_UINT)
		{
			vt = vtSrc;
			uintVal= nSrc;
		}
		else
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif
		}		
	}
	CComVariant(_In_ const CComBSTR& bstrSrc) ATLVARIANT_THROW()
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(_In_ const SAFEARRAY *pSrc) ATLVARIANT_THROW()
	{		
		ATLASSERT(pSrc != NULL);
		if (pSrc == NULL)
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif			
		}
		else
		{
			LPSAFEARRAY pCopy;
			HRESULT hRes = ::SafeArrayCopy((LPSAFEARRAY)pSrc, &pCopy);
			if (SUCCEEDED(hRes))
			{
				::ATL::AtlSafeArrayGetActualVartype((LPSAFEARRAY)pSrc, &vt);
				vt |= VT_ARRAY;
				parray = pCopy;
			}
			else
			{
				vt = VT_ERROR;
				scode = hRes;
#ifndef _ATL_NO_VARIANT_THROW
				if(hRes == E_OUTOFMEMORY)
				{
					AtlThrow(E_OUTOFMEMORY);
				}
				else
				{
					ATLENSURE_THROW(FALSE, hRes);
				}
#endif
			}
		}
	}
// Assignment Operators
public:
	CComVariant& operator=(_In_ const CComVariant& varSrc) ATLVARIANT_THROW()
	{
        if(this!=&varSrc)
        {
		    InternalCopy(&varSrc);
        }
		return *this;
	}
	CComVariant& operator=(_In_ const VARIANT& varSrc) ATLVARIANT_THROW()
	{
        if(static_cast<VARIANT *>(this)!=&varSrc)
        {
		    InternalCopy(&varSrc);
        }
		return *this;
	}

	CComVariant& operator=(_In_ const CComBSTR& bstrSrc) ATLVARIANT_THROW()
	{
		ClearThrow();

		vt = VT_BSTR;
		bstrVal = bstrSrc.Copy();

		if (bstrVal == NULL && bstrSrc.m_str != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_OUTOFMEMORY);
#endif
		}

		return *this;
	}

	CComVariant& operator=(_In_z_ LPCOLESTR lpszSrc) ATLVARIANT_THROW()
	{
		ClearThrow();

		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_OUTOFMEMORY);
#endif

		}
		return *this;
	}

	CComVariant& operator=(_In_z_ LPCSTR lpszSrc) ATLVARIANT_THROW()
	{
		USES_CONVERSION_EX;
		ClearThrow();

		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE_EX(lpszSrc, _ATL_SAFE_ALLOCA_DEF_THRESHOLD));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_OUTOFMEMORY);
#endif
		}
		return *this;
	}

	CComVariant& operator=(_In_ bool bSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_BOOL)
		{
			ClearThrow();
			vt = VT_BOOL;
		}
		boolVal = bSrc ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE;
		return *this;
	}

	CComVariant& operator=(_In_ int nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_I4)
		{
			ClearThrow();
			vt = VT_I4;
		}
		intVal = nSrc;

		return *this;
	}

	CComVariant& operator=(_In_ BYTE nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_UI1)
		{
			ClearThrow();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ short nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_I2)
		{
			ClearThrow();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ long nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_I4)
		{
			ClearThrow();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ float fltSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_R4)
		{
			ClearThrow();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(_In_ double dblSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_R8)
		{
			ClearThrow();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(_In_ CY cySrc) ATLVARIANT_THROW()
	{
		if (vt != VT_CY)
		{
			ClearThrow();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(_Inout_opt_ IDispatch* pSrc) ATLVARIANT_THROW()
	{
		ClearThrow();
		
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(_Inout_opt_ IUnknown* pSrc) ATLVARIANT_THROW()
	{
		ClearThrow();
		
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}

	CComVariant& operator=(_In_ char cSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_I1)
		{
			ClearThrow();
			vt = VT_I1;
		}
		cVal = cSrc;
		return *this;
	}

	CComVariant& operator=(_In_ unsigned short nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_UI2)
		{
			ClearThrow();
			vt = VT_UI2;
		}
		uiVal = nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ unsigned long nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_UI4)
		{
			ClearThrow();
			vt = VT_UI4;
		}
		ulVal = nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ unsigned int nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_UI4)
		{
			ClearThrow();
			vt = VT_UI4;
		}
		uintVal= nSrc;
		return *this;
	}

	CComVariant& operator=(_In_ BYTE* pbSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_UI1|VT_BYREF))
		{
			ClearThrow();
			vt = VT_UI1|VT_BYREF;
		}
		pbVal = pbSrc;
		return *this;
	}

	CComVariant& operator=(_In_ short* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_I2|VT_BYREF))
		{
			ClearThrow();
			vt = VT_I2|VT_BYREF;
		}
		piVal = pnSrc;
		return *this;
	}

#ifdef _NATIVE_WCHAR_T_DEFINED
	CComVariant& operator=(_In_ USHORT* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_UI2|VT_BYREF))
		{
			ClearThrow();
			vt = VT_UI2|VT_BYREF;
		}
		puiVal = pnSrc;
		return *this;
	}
#endif

	CComVariant& operator=(_In_ int* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_I4|VT_BYREF))
		{
			ClearThrow();			
			vt = VT_I4|VT_BYREF;
		}
		pintVal = pnSrc;
		return *this;
	}

	CComVariant& operator=(_In_ UINT* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_UI4|VT_BYREF))
		{
			ClearThrow();
			vt = VT_UI4|VT_BYREF;
		}
		puintVal = pnSrc;
		return *this;
	}

	CComVariant& operator=(_In_ long* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_I4|VT_BYREF))
		{
			ClearThrow();
			vt = VT_I4|VT_BYREF;
		}
		plVal = pnSrc;
		return *this;
	}

	CComVariant& operator=(_In_ ULONG* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_UI4|VT_BYREF))
		{
			ClearThrow();
			vt = VT_UI4|VT_BYREF;
		}
		pulVal = pnSrc;
		return *this;
	}

#if (_WIN32_WINNT >= 0x0501) || defined(_ATL_SUPPORT_VT_I8)
	CComVariant& operator=(_In_ LONGLONG nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_I8)
		{
			ClearThrow();
			vt = VT_I8;
		}
		llVal = nSrc;

		return *this;
	}

	CComVariant& operator=(_In_ LONGLONG* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_I8|VT_BYREF))
		{
			ClearThrow();
			vt = VT_I8|VT_BYREF;
		}
		pllVal = pnSrc;
		return *this;
	}

	CComVariant& operator=(_In_ ULONGLONG nSrc) ATLVARIANT_THROW()
	{
		if (vt != VT_UI8)
		{
			ClearThrow();
			vt = VT_UI8;
		}
		ullVal = nSrc;

		return *this;
	}

	CComVariant& operator=(_In_ ULONGLONG* pnSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_UI8|VT_BYREF))
		{
			ClearThrow();
			vt = VT_UI8|VT_BYREF;
		}
		pullVal = pnSrc;
		return *this;
	}
#endif

	CComVariant& operator=(_In_ float* pfSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_R4|VT_BYREF))
		{
			ClearThrow();
			vt = VT_R4|VT_BYREF;
		}
		pfltVal = pfSrc;
		return *this;
	}

	CComVariant& operator=(_In_ double* pfSrc) ATLVARIANT_THROW()
	{
		if (vt != (VT_R8|VT_BYREF))
		{
			ClearThrow();
			vt = VT_R8|VT_BYREF;
		}
		pdblVal = pfSrc;
		return *this;
	}

	CComVariant& operator=(_In_ const SAFEARRAY *pSrc) ATLVARIANT_THROW()
	{
		ATLASSERT(pSrc != NULL);
		ClearThrow();
		
		if (pSrc == NULL)
		{
			vt = VT_ERROR;
			scode = E_INVALIDARG;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(E_INVALIDARG);
#endif
		}
		else 
		{			
			LPSAFEARRAY pCopy;
			HRESULT hr = ::SafeArrayCopy((LPSAFEARRAY)pSrc, &pCopy);
			if (SUCCEEDED(hr))
			{
				::ATL::AtlSafeArrayGetActualVartype((LPSAFEARRAY)pSrc, &vt);
				vt |= VT_ARRAY;
				parray = pCopy;
			}
			else
			{
				vt = VT_ERROR;
				scode = hr;
#ifndef _ATL_NO_VARIANT_THROW
				if(hr == E_OUTOFMEMORY)
				{
					AtlThrow(E_OUTOFMEMORY);
				}
				else
				{
					ATLENSURE_THROW(FALSE, hr);
				}
#endif
			}
		}
		
		return *this;
	}

// Comparison Operators
public:
	bool operator==(_In_ const VARIANT& varSrc) const throw()
	{
		// For backwards compatibility
		if (vt == VT_NULL && varSrc.vt == VT_NULL)
		{
			return true;
		}
		// Variants not equal if types don't match
		if (vt != varSrc.vt)
		{
			return false;
		}
		return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0) == static_cast<HRESULT>(VARCMP_EQ);
	}

	bool operator!=(_In_ const VARIANT& varSrc) const throw()
	{
		return !operator==(varSrc);
	}

	bool operator<(_In_ const VARIANT& varSrc) const throw()
	{
		if (vt == VT_NULL && varSrc.vt == VT_NULL)
			return false;
		return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)== static_cast<HRESULT>(VARCMP_LT);
	}

	bool operator>(_In_ const VARIANT& varSrc) const throw()
	{
		if (vt == VT_NULL && varSrc.vt == VT_NULL)
			return false;
		return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)== static_cast<HRESULT>(VARCMP_GT);
	}

private:
	inline HRESULT VarCmp(
		_In_ LPVARIANT pvarLeft, 
		_In_ LPVARIANT pvarRight, 
		_In_ LCID lcid, 
		_In_ ULONG dwFlags) const throw();

// Operations
public:
	HRESULT Clear()
	{ 
		return ::VariantClear(this); 
	}	
	HRESULT Copy(_In_ const VARIANT* pSrc)
	{ 
		return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); 
	}
	
ATLPREFAST_SUPPRESS(6387)
	// copy VARIANT to BSTR
	HRESULT CopyTo(_Deref_out_z_ BSTR *pstrDest) const
	{
		ATLASSERT(pstrDest != NULL && vt == VT_BSTR);
		HRESULT hRes = E_POINTER;
		if (pstrDest != NULL && vt == VT_BSTR)
		{
			*pstrDest = ::SysAllocStringByteLen((char*)bstrVal, ::SysStringByteLen(bstrVal));
			if (*pstrDest == NULL)
				hRes = E_OUTOFMEMORY;
			else
				hRes = S_OK;
		}
		else if (vt != VT_BSTR)
			hRes = DISP_E_TYPEMISMATCH;
				
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	HRESULT Attach(_In_ VARIANT* pSrc)
	{
		if(pSrc == NULL)
			return E_INVALIDARG;
			
		// Clear out the variant
		HRESULT hr = Clear();
		if (SUCCEEDED(hr))
		{
			// Copy the contents and give control to CComVariant
			Checked::memcpy_s(this, sizeof(CComVariant), pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(_Out_ VARIANT* pDest)
	{
		ATLASSERT(pDest != NULL);
		if(pDest == NULL)
			return E_POINTER;
			
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (SUCCEEDED(hr))
		{
			// Copy the contents and remove control from CComVariant
			Checked::memcpy_s(pDest, sizeof(VARIANT), this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(_In_ VARTYPE vtNew, _In_opt_ const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	template< typename T >
	void SetByRef(_In_ T* pT) ATLVARIANT_THROW()
	{
		ClearThrow();
		vt = CVarTypeInfo< T* >::VT;
		byref = pT;
	}

	_Check_return_ HRESULT WriteToStream(_Inout_ IStream* pStream);
	_Check_return_ HRESULT WriteToStream(
		_Inout_ IStream* pStream, 
		_In_ VARTYPE vtWrite)
	{
		if (vtWrite != VT_EMPTY && vtWrite != vt)
		{
			CComVariant varConv;
			HRESULT hr = varConv.ChangeType(vtWrite, this);
			if (FAILED(hr))
			{
				return hr;
			}
			return varConv.WriteToStream(pStream);
		}
		return WriteToStream(pStream);
	}

	_Check_return_ HRESULT ReadFromStream(
		_Inout_ IStream* pStream, 
		_In_ VARTYPE vtExpected = VT_EMPTY);

	_Check_return_ HRESULT ReadFromStream(
		_Inout_ IStream* pStream, 
		_In_ VARTYPE vtExpected,
		_In_ ClassesAllowedInStream rgclsidAllowed, 
		_In_ DWORD cclsidAllowed);

	// Return the size in bytes of the current contents
	ULONG GetSize() const;
	HRESULT GetSizeMax(_Out_ ULARGE_INTEGER* pcbSize) const;

// Implementation
private:
	void ClearThrow() ATLVARIANT_THROW()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		(hr);
#ifndef _ATL_NO_VARIANT_THROW
		if (FAILED(hr))
		{
			AtlThrow(hr);
		}
#endif
	}
	
public:
	_Check_return_ HRESULT InternalClear() ATLVARIANT_THROW()
	{
		HRESULT hr = Clear();		
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(hr);
#endif
		}
		return hr;
	}

	void InternalCopy(_In_ const VARIANT* pSrc) ATLVARIANT_THROW()
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
#ifndef _ATL_NO_VARIANT_THROW
			AtlThrow(hr);
#endif
		}
	}
};

#pragma warning(push)
#pragma warning(disable: 4702)
_Check_return_ inline HRESULT CComVariant::WriteToStream(_Inout_ IStream* pStream)
{
	if(pStream == NULL)
		return E_INVALIDARG;
		
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);
				if (FAILED(hr))
				{
					hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);
					if (FAILED(hr))
						return hr;
				}
			}
			if (spStream != NULL)
				return OleSaveToStream(spStream, pStream);
			return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_I8:
	case VT_UI8:
		cbWrite = sizeof(LONGLONG);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite.Attach(varBSTR.bstrVal);
	}
	else
		bstrWrite.Attach(bstrVal);

	hr = bstrWrite.WriteToStream(pStream);
	bstrWrite.Detach();
	return hr;
}
#pragma warning(pop)	// C4702


_Check_return_ inline HRESULT CComVariant::ReadFromStream(
	_Inout_ IStream* pStream, 
	_In_ VARTYPE vtExpected /* = VT_EMPTY */)
{
	ClassesAllowedInStream allowed;
	allowed.rgclsidAllowed = NULL;

	return ReadFromStream(pStream, vtExpected, allowed, 0);
}

_Check_return_ inline HRESULT CComVariant::ReadFromStream(
	_Inout_ IStream* pStream, 
	_In_ VARTYPE vtExpected, 
	_In_ ClassesAllowedInStream rgclsidAllowed, 
	_In_ DWORD cclsidAllowed)
{
	ATLASSERT(pStream != NULL);
	if(pStream == NULL)
		return E_INVALIDARG;
		
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead = VT_EMPTY;
	ULONG cbRead = 0;

	hr = pStream->Read(&vtRead, sizeof(VARTYPE), &cbRead);
	if (hr == S_FALSE || (cbRead != sizeof(VARTYPE) && hr == S_OK))
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;
	if (vtExpected != VT_EMPTY && vtRead != vtExpected)
		return E_FAIL;

	vt = vtRead;
	cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = AtlInternalOleLoadFromStream(pStream,
				(vtRead == VT_UNKNOWN) ? __uuidof(IUnknown) : __uuidof(IDispatch),
				(void**)&punkVal, rgclsidAllowed, cclsidAllowed);
			// If IPictureDisp or IFontDisp property is not set, 
			// OleLoadFromStream() will return REGDB_E_CLASSNOTREG.
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return hr;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_I8:
	case VT_UI8:
		cbRead = sizeof(LONGLONG);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
	{
		// If CComBSTR::ReadFromStream failed, reset seek pointer to start of
		// variant type.
		LARGE_INTEGER nOffset;
		nOffset.QuadPart = -(static_cast<LONGLONG>(sizeof(VARTYPE)));
		pStream->Seek(nOffset, STREAM_SEEK_CUR, NULL);
		vt = VT_EMPTY;
		return hr;
	}
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

inline HRESULT CComVariant::GetSizeMax(_Out_ ULARGE_INTEGER* pcbSize) const
{
	ATLASSERT(pcbSize != NULL);
	if (pcbSize == NULL)
	{
		return E_INVALIDARG;
	}
	
	HRESULT hr = S_OK;
	ULARGE_INTEGER nSize;
	nSize.QuadPart = sizeof(VARTYPE);	
	
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{	
			nSize.LowPart += sizeof(CLSID);
			
			if (punkVal != NULL)
			{
				CComPtr<IPersistStream> spStream;
				
				hr = punkVal->QueryInterface(__uuidof(IPersistStream), (void**)&spStream);
				if (FAILED(hr))
				{
					hr = punkVal->QueryInterface(__uuidof(IPersistStreamInit), (void**)&spStream);
					if (FAILED(hr))
					{
						break;
					}
				}
				
				ULARGE_INTEGER nPersistSize;
				nPersistSize.QuadPart = 0;
				
				ATLASSERT(spStream != NULL);
				hr = spStream->GetSizeMax(&nPersistSize);				
				if (SUCCEEDED(hr))
				{
					hr = AtlAdd(&nSize.QuadPart, nSize.QuadPart, nPersistSize.QuadPart);
				}				
			}			
		}
		break;
	case VT_UI1:
	case VT_I1:
		nSize.LowPart += sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		nSize.LowPart += sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		nSize.LowPart += sizeof(long);
		break;
	case VT_I8:
	case VT_UI8:
		nSize.LowPart += sizeof(LONGLONG);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		nSize.LowPart += sizeof(double);
		break;
	default:
		{
			VARTYPE vtTmp = vt;
			BSTR bstr = NULL;
			CComVariant varBSTR;
			if (vtTmp != VT_BSTR)
			{
				hr = VariantChangeType(&varBSTR, const_cast<VARIANT*>((const VARIANT*)this), VARIANT_NOVALUEPROP, VT_BSTR);
				if (SUCCEEDED(hr))
				{
					bstr = varBSTR.bstrVal;
					vtTmp = VT_BSTR;
				}
			} 
			else
			{
				bstr = bstrVal;
			}

			if (vtTmp == VT_BSTR)
			{
				// Add the size of the length + string (in bytes) + NULL terminator.				
				nSize.QuadPart += CComBSTR::GetStreamSize(bstr);
			}
		}		
	}
	
	if (SUCCEEDED(hr))
	{
		pcbSize->QuadPart = nSize.QuadPart;
	}
	
	return hr;
}

inline ATL_DEPRECATED("GetSize has been replaced by GetSizeMax")
ULONG CComVariant::GetSize() const
{
	ULARGE_INTEGER nSize;
	HRESULT hr = GetSizeMax(&nSize);
	
	if (SUCCEEDED(hr) && nSize.QuadPart <= ULONG_MAX)
	{
		return nSize.LowPart;	
	}
	
	return sizeof(VARTYPE);
}

_Check_return_ inline HRESULT CComPtr<IDispatch>::Invoke2(
	_In_ DISPID dispid, 
	_In_ VARIANT* pvarParam1, 
	_In_ VARIANT* pvarParam2, 
	_Out_opt_ VARIANT* pvarRet) throw()
{
	if(pvarParam1 == NULL || pvarParam2 == NULL)
		return E_INVALIDARG;
			
	CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
	DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
	return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
}

/*
	Workaround for VarCmp function which does not compare VT_I1, VT_UI2, VT_UI4, VT_UI8 values
*/
inline HRESULT CComVariant::VarCmp(
	_In_ LPVARIANT pvarLeft, 
	_In_ LPVARIANT pvarRight, 
	_In_ LCID lcid, 
	_In_ ULONG dwFlags) const throw()
{			
	switch(vt) 
	{
		case VT_I1:
			if (pvarLeft->cVal == pvarRight->cVal)
			{
				return VARCMP_EQ;
			}
			return pvarLeft->cVal > pvarRight->cVal ? VARCMP_GT : VARCMP_LT;			
		case VT_UI2:
			if (pvarLeft->uiVal == pvarRight->uiVal)
			{
				return VARCMP_EQ;
			}
			return pvarLeft->uiVal > pvarRight->uiVal ? VARCMP_GT : VARCMP_LT;

		case VT_UI4:
			if (pvarLeft->uintVal == pvarRight->uintVal) 
			{
				return VARCMP_EQ;
			}
			return pvarLeft->uintVal > pvarRight->uintVal ? VARCMP_GT : VARCMP_LT;				

		case VT_UI8:
			if (pvarLeft->ullVal == pvarRight->ullVal)
			{
				return VARCMP_EQ;
			}
			return pvarLeft->ullVal > pvarRight->ullVal ? VARCMP_GT : VARCMP_LT;

		default:
			return ::VarCmp(pvarLeft, pvarRight, lcid, dwFlags);
	}
}

ATLPREFAST_SUPPRESS(6387)
_Check_return_ inline HRESULT AtlInternalOleLoadFromStream(
	_Inout_ IStream* pStm, 
	_In_ REFIID iidInterface, 
	_Deref_out_ void** ppvObj, 
	_In_ ClassesAllowedInStream rgclsidAllowed, 
	_In_ DWORD cclsidAllowed)
{
	ATLASSUME(pStm != NULL);
	*ppvObj = NULL;
	CLSID clsid;

	HRESULT hr = ReadClassStm(pStm, &clsid);

	if (FAILED(hr))
	{		
		return hr;
	}
	
	CComPtr<IUnknown> punkVal;

	if (cclsidAllowed != 0)
	{
		ATLASSUME(rgclsidAllowed.rgclsidAllowed != NULL);
		hr = E_ACCESSDENIED;
		
		for(DWORD i = 0; i < cclsidAllowed; i++)
		{
			if (IsEqualCLSID(clsid, rgclsidAllowed.rgclsidAllowed[i]))
			{
				hr = S_OK;
				break;
			}
		}		
	}
	else if (rgclsidAllowed.pfnClsidAllowed != NULL) 
	{
		hr = rgclsidAllowed.pfnClsidAllowed(clsid, iidInterface, reinterpret_cast<void**>(&punkVal));
	}
	
	if (FAILED(hr))
	{
		return hr;
	}

	if (punkVal == NULL)
	{
		hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, iidInterface, reinterpret_cast<void**>(&punkVal));
		if (FAILED(hr))
		{		
			return hr;
		}
	}

	CComPtr<IPersistStream> pPersistStm;
	hr = punkVal->QueryInterface(&pPersistStm);
	
	if (SUCCEEDED(hr))
	{
		hr = pPersistStm->Load(pStm);
		
		if (SUCCEEDED(hr))
		{
			*ppvObj = punkVal.Detach();			
		}
	}
	
	return hr;
}
ATLPREFAST_UNSUPPRESS()

}	// namespace ATL
#pragma pack(pop)

#pragma warning (pop)	

#ifndef _ATL_NO_AUTOMATIC_NAMESPACE
using namespace ATL;
#endif //!_ATL_NO_AUTOMATIC_NAMESPACE

#endif	// __ATLCOMCLI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\ATLComTime.inl ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOMTIME_INL__
#define __ATLCOMTIME_INL__

#pragma once

#ifndef __ATLCOMTIME_H__
#error ATLComTime.inl requires ATLComTime.h to be included first
#endif

#include <math.h>
#include <oleauto.h>

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// COleDateTimeSpan
/////////////////////////////////////////////////////////////////////////////

ATLCOMTIME_INLINE COleDateTimeSpan::COleDateTimeSpan() throw() : m_span(0), m_status(valid)
{
}

ATLCOMTIME_INLINE COleDateTimeSpan::COleDateTimeSpan(_In_ double dblSpanSrc) throw() : 
	m_span(dblSpanSrc), m_status(valid)
{
	CheckRange();
}

ATLCOMTIME_INLINE COleDateTimeSpan::COleDateTimeSpan(
	_In_ LONG lDays, 
	_In_ int nHours, 
	_In_ int nMins, 
	_In_ int nSecs) throw()
{
	SetDateTimeSpan(lDays, nHours, nMins, nSecs);
}

ATLCOMTIME_INLINE void COleDateTimeSpan::SetStatus(_In_ DateTimeSpanStatus status) throw()
{
	m_status = status;
}

ATLCOMTIME_INLINE COleDateTimeSpan::DateTimeSpanStatus COleDateTimeSpan::GetStatus() const throw()
{
	return m_status;
}

__declspec(selectany) const double
	COleDateTimeSpan::OLE_DATETIME_HALFSECOND =
	1.0 / (2.0 * (60.0 * 60.0 * 24.0));

ATLCOMTIME_INLINE double COleDateTimeSpan::GetTotalDays() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return (double)LONGLONG(m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND));
}

ATLCOMTIME_INLINE double COleDateTimeSpan::GetTotalHours() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return (double)LONGLONG((m_span + (m_span < 0 ? 
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * 24);
}

ATLCOMTIME_INLINE double COleDateTimeSpan::GetTotalMinutes() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return (double)LONGLONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60));
}

ATLCOMTIME_INLINE double COleDateTimeSpan::GetTotalSeconds() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return (double)LONGLONG((m_span + (m_span < 0 ?
		-OLE_DATETIME_HALFSECOND : OLE_DATETIME_HALFSECOND)) * (24 * 60 * 60));
}

ATLCOMTIME_INLINE LONG COleDateTimeSpan::GetDays() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return LONG(GetTotalDays());
}

ATLCOMTIME_INLINE LONG COleDateTimeSpan::GetHours() const throw()
{
	return LONG(GetTotalHours()) % 24;
}

ATLCOMTIME_INLINE LONG COleDateTimeSpan::GetMinutes() const throw()
{
	return LONG(GetTotalMinutes()) % 60;
}

ATLCOMTIME_INLINE LONG COleDateTimeSpan::GetSeconds() const throw()
{
	return LONG(GetTotalSeconds()) % 60;
}

ATLCOMTIME_INLINE COleDateTimeSpan& COleDateTimeSpan::operator=(_In_ double dblSpanSrc) throw()
{
	m_span = dblSpanSrc;
	m_status = valid;
	CheckRange();
	return *this;
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator==(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	if(GetStatus() == dateSpan.GetStatus())
	{
		if(GetStatus() == valid)
		{
			// it has to be in precision range to say that it as equal	
			if (m_span + OLE_DATETIME_HALFSECOND > dateSpan.m_span &&
					m_span - OLE_DATETIME_HALFSECOND < dateSpan.m_span)
			{
				return true;
			}
			else
			{
				return false;
			}			
		}
		
		return (GetStatus() == null);
	}

	return false;
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator!=(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	return !operator==(dateSpan);
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator<(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	if( (GetStatus() == valid) && (GetStatus() == dateSpan.GetStatus()) )
		return m_span < dateSpan.m_span;

	return false;
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator>(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	if( (GetStatus() == valid) && (GetStatus() == dateSpan.GetStatus()) )
		return m_span > dateSpan.m_span ;

	return false;
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator<=(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	return operator<(dateSpan) || operator==(dateSpan);
}

ATLCOMTIME_INLINE bool COleDateTimeSpan::operator>=(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	return operator>(dateSpan) || operator==(dateSpan);
}

ATLCOMTIME_INLINE COleDateTimeSpan COleDateTimeSpan::operator+(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Add spans and validate within legal range
	dateSpanTemp.m_span = m_span + dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

ATLCOMTIME_INLINE COleDateTimeSpan COleDateTimeSpan::operator-(
	_In_ const COleDateTimeSpan& dateSpan) const throw()
{
	COleDateTimeSpan dateSpanTemp;

	// If either operand Null, result Null
	if (GetStatus() == null || dateSpan.GetStatus() == null)
	{
		dateSpanTemp.SetStatus(null);
		return dateSpanTemp;
	}

	// If either operand Invalid, result Invalid
	if (GetStatus() == invalid || dateSpan.GetStatus() == invalid)
	{
		dateSpanTemp.SetStatus(invalid);
		return dateSpanTemp;
	}

	// Subtract spans and validate within legal range
	dateSpanTemp.m_span = m_span - dateSpan.m_span;
	dateSpanTemp.CheckRange();

	return dateSpanTemp;
}

ATLCOMTIME_INLINE COleDateTimeSpan& COleDateTimeSpan::operator+=(
	_In_ const COleDateTimeSpan dateSpan) throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this + dateSpan;
	CheckRange();
	return *this;
}

ATLCOMTIME_INLINE COleDateTimeSpan& COleDateTimeSpan::operator-=(
	_In_ const COleDateTimeSpan dateSpan) throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	*this = *this - dateSpan;
	CheckRange();
	return *this;
}

ATLCOMTIME_INLINE COleDateTimeSpan COleDateTimeSpan::operator-() const throw()
{
	return -this->m_span;
}

ATLCOMTIME_INLINE COleDateTimeSpan::operator double() const throw()
{
	return m_span;
}

ATLCOMTIME_INLINE void COleDateTimeSpan::SetDateTimeSpan(
	_In_ LONG lDays, 
	_In_ int nHours, 
	_In_ int nMins, 
	_In_ int nSecs) throw()
{
	// Set date span by breaking into fractional days (all input ranges valid)
	m_span = lDays + ((double)nHours)/24 + ((double)nMins)/(24*60) +
		((double)nSecs)/(24*60*60);
	m_status = valid;
	CheckRange();
}

ATLCOMTIME_INLINE void COleDateTimeSpan::CheckRange()
{
	if(m_span < -maxDaysInSpan || m_span > maxDaysInSpan)
	{
		m_status = invalid;
	}
}

/////////////////////////////////////////////////////////////////////////////
// COleDateTime
/////////////////////////////////////////////////////////////////////////////

ATLCOMTIME_INLINE COleDateTime WINAPI COleDateTime::GetCurrentTime() throw()
{
	return COleDateTime(::_time64(NULL));
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime() throw() :
	m_dt( 0 ), m_status(valid)
{
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ const VARIANT& varSrc) throw() :
	m_dt( 0 ), m_status(valid)
{
	*this = varSrc;
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ DATE dtSrc) throw() :
	m_dt( dtSrc ), m_status(valid)
{
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ __time32_t timeSrc) throw() :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ __time64_t timeSrc) throw() :
	m_dt( 0 ), m_status(valid)
{
	*this = timeSrc;
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ const SYSTEMTIME& systimeSrc) throw() :
	m_dt( 0 ), m_status(valid)
{
	*this = systimeSrc;
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(_In_ const FILETIME& filetimeSrc) throw() :
	m_dt( 0 ), m_status(valid)
{
	*this = filetimeSrc;
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(
	_In_ int nYear, 
	_In_ int nMonth, 
	_In_ int nDay,
	_In_ int nHour, 
	_In_ int nMin, 
	_In_ int nSec) throw()
{
	SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec);
}

ATLCOMTIME_INLINE COleDateTime::COleDateTime(
	_In_ WORD wDosDate, 
	_In_ WORD wDosTime) throw()
{
	m_status = ::DosDateTimeToVariantTime(wDosDate, wDosTime, &m_dt) ?
		valid : invalid;
}

ATLCOMTIME_INLINE void COleDateTime::SetStatus(_In_ DateTimeStatus status) throw()
{
	m_status = status;
}

ATLCOMTIME_INLINE COleDateTime::DateTimeStatus COleDateTime::GetStatus() const throw()
{
	return m_status;
}

ATLCOMTIME_INLINE bool COleDateTime::GetAsSystemTime(_Out_ SYSTEMTIME& sysTime) const throw()
{
	return GetStatus() == valid && ::VariantTimeToSystemTime(m_dt, &sysTime);
}

ATLCOMTIME_INLINE bool COleDateTime::GetAsUDATE(_Out_ UDATE &udate) const throw()
{
	return SUCCEEDED(::VarUdateFromDate(m_dt, 0, &udate));
}

ATLCOMTIME_INLINE int COleDateTime::GetYear() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wYear : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetMonth() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMonth : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetDay() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDay : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetHour() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wHour : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetMinute() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wMinute : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetSecond() const throw()
{ 
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wSecond : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetDayOfWeek() const throw()
{
	SYSTEMTIME st;
	return GetAsSystemTime(st) ? st.wDayOfWeek + 1 : error;
}

ATLCOMTIME_INLINE int COleDateTime::GetDayOfYear() const throw()
{
	UDATE udate;
	return GetAsUDATE(udate) ? udate.wDayOfYear : error;
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator=(_In_ const VARIANT& varSrc) throw()
{
	if (varSrc.vt != VT_DATE)
	{
		VARIANT varDest;
		varDest.vt = VT_EMPTY;
		if(SUCCEEDED(::VariantChangeType(&varDest, const_cast<VARIANT *>(&varSrc), 0, VT_DATE)))
		{
			m_dt = varDest.date;
			m_status = valid;
		}
		else
			m_status = invalid;
	}
	else
	{
		m_dt = varSrc.date;
		m_status = valid;
	}

	return *this;
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator=(_In_ DATE dtSrc) throw()
{
	m_dt = dtSrc;
	m_status = valid;
	return *this;
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator=(_In_ const __time32_t& timeSrc) throw()
{
    return operator=(static_cast<__time64_t>(timeSrc));
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator=(_In_ const __time64_t& timeSrc) throw()
{
	SYSTEMTIME st;
	CTime tmp(timeSrc);

	m_status = tmp.GetAsSystemTime(st) &&
			   ConvertSystemTimeToVariantTime(st) ? valid : invalid;	
	return *this;
}

ATLCOMTIME_INLINE COleDateTime &COleDateTime::operator=(_In_ const SYSTEMTIME &systimeSrc) throw()
{
	m_status = ConvertSystemTimeToVariantTime(systimeSrc) ?	valid : invalid;
	return *this;
}

ATLCOMTIME_INLINE COleDateTime &COleDateTime::operator=(_In_ const FILETIME &filetimeSrc) throw()
{
	FILETIME ftl;
	SYSTEMTIME st;

	m_status =  ::FileTimeToLocalFileTime(&filetimeSrc, &ftl) && 
				::FileTimeToSystemTime(&ftl, &st) &&
				ConvertSystemTimeToVariantTime(st) ? valid : invalid;

	return *this;
}

ATLCOMTIME_INLINE BOOL COleDateTime::ConvertSystemTimeToVariantTime(_In_ const SYSTEMTIME& systimeSrc)
{
	return AtlConvertSystemTimeToVariantTime(systimeSrc,&m_dt);	
}
ATLCOMTIME_INLINE COleDateTime &COleDateTime::operator=(const UDATE &udate) throw()
{
	m_status = (S_OK == VarDateFromUdate((UDATE*)&udate, 0, &m_dt)) ? valid : invalid;

	return *this;
}

ATLCOMTIME_INLINE bool COleDateTime::operator==(_In_ const COleDateTime& date) const throw()
{
	if(GetStatus() == date.GetStatus())
	{
		if(GetStatus() == valid)
		{
			// it has to be in precision range to say that it as equal			
			if (m_dt + COleDateTimeSpan::OLE_DATETIME_HALFSECOND > date.m_dt &&
					m_dt - COleDateTimeSpan::OLE_DATETIME_HALFSECOND < date.m_dt)
			{
				return true;
			}
			else
			{
				return false;
			}			
		}

		return (GetStatus() == null);
	}
	return false;

}

ATLCOMTIME_INLINE bool COleDateTime::operator!=(_In_ const COleDateTime& date) const throw()
{
	return !operator==(date);
}

ATLCOMTIME_INLINE bool COleDateTime::operator<(_In_ const COleDateTime& date) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	if( (GetStatus() == valid) && (GetStatus() == date.GetStatus()) )
		return( DoubleFromDate( m_dt ) < DoubleFromDate( date.m_dt ) );

	return false;
}

ATLCOMTIME_INLINE bool COleDateTime::operator>(_In_ const COleDateTime& date) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	if( (GetStatus() == valid) && (GetStatus() == date.GetStatus()) )
		return( DoubleFromDate( m_dt ) > DoubleFromDate( date.m_dt ) );

	return false;		
}

ATLCOMTIME_INLINE bool COleDateTime::operator<=(_In_ const COleDateTime& date) const throw()
{
	return operator<(date) || operator==(date);
}

ATLCOMTIME_INLINE bool COleDateTime::operator>=(_In_ const COleDateTime& date) const throw()
{
	return operator>(date) || operator==(date);
}

ATLCOMTIME_INLINE COleDateTime COleDateTime::operator+(_In_ COleDateTimeSpan dateSpan) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan ) ) );
}

ATLCOMTIME_INLINE COleDateTime COleDateTime::operator-(_In_ COleDateTimeSpan dateSpan) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	return( COleDateTime( DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan ) ) );
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator+=(_In_ COleDateTimeSpan dateSpan) throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )+(double)dateSpan );
	return( *this );
}

ATLCOMTIME_INLINE COleDateTime& COleDateTime::operator-=(_In_ COleDateTimeSpan dateSpan) throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(dateSpan.GetStatus() == valid);
	m_dt = DateFromDouble( DoubleFromDate( m_dt )-(double)dateSpan );
	return( *this );
}

ATLCOMTIME_INLINE COleDateTimeSpan COleDateTime::operator-(_In_ const COleDateTime& date) const throw()
{
	ATLASSERT(GetStatus() == valid);
	ATLASSERT(date.GetStatus() == valid);
	return DoubleFromDate(m_dt) - DoubleFromDate(date.m_dt);
}

ATLCOMTIME_INLINE COleDateTime::operator DATE() const throw()
{
	ATLASSERT(GetStatus() == valid);
	return( m_dt );
}

ATLCOMTIME_INLINE int COleDateTime::SetDateTime(
	_In_ int nYear, 
	_In_ int nMonth, 
	_In_ int nDay,
	_In_ int nHour, 
	_In_ int nMin, 
	_In_ int nSec) throw()
{
	SYSTEMTIME st;
	::ZeroMemory(&st, sizeof(SYSTEMTIME));

	st.wYear = WORD(nYear);
	st.wMonth = WORD(nMonth);
	st.wDay = WORD(nDay);
	st.wHour = WORD(nHour);
	st.wMinute = WORD(nMin);
	st.wSecond = WORD(nSec);

	m_status = ConvertSystemTimeToVariantTime(st) ? valid : invalid;
	return m_status;
}

ATLCOMTIME_INLINE int COleDateTime::SetDate(_In_ int nYear, _In_ int nMonth, _In_ int nDay) throw()
{
	return SetDateTime(nYear, nMonth, nDay, 0, 0, 0);
}

ATLCOMTIME_INLINE int COleDateTime::SetTime(_In_ int nHour, _In_ int nMin, _In_ int nSec) throw()
{
	// Set date to zero date - 12/30/1899
	return SetDateTime(1899, 12, 30, nHour, nMin, nSec);
}

ATLCOMTIME_INLINE double WINAPI COleDateTime::DoubleFromDate(_In_ DATE date) throw()
{	
	// We treat it as positive from -OLE_DATETIME_HALFSECOND because of numeric errors
	// If value is positive it doesn't need conversion
	if(date > -COleDateTimeSpan::OLE_DATETIME_HALFSECOND)
	{
		return date;
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -1.25 to -.75, -1.50 to -.50, -1.75 to -.25)
	double fTemp = ceil(date);

	return fTemp - (date - fTemp);
}

ATLCOMTIME_INLINE DATE WINAPI COleDateTime::DateFromDouble(_In_ double f) throw()
{	
	// We treat it as positive from -OLE_DATETIME_HALFSECOND because of numeric errors
	// If value is positive it doesn't need conversion
	if(f > -COleDateTimeSpan::OLE_DATETIME_HALFSECOND )
	{
		return f;
	}

	// If negative, must convert since negative dates not continuous
	// (examples: -.75 to -1.25, -.50 to -1.50, -.25 to -1.75)
	double fTemp = floor(f); // fTemp is now whole part

	return fTemp + (fTemp - f);
}

ATLCOMTIME_INLINE void COleDateTime::CheckRange()
{
	// About year 100 to about 9999
	if(m_dt > VTDATEGRE_MAX || m_dt < VTDATEGRE_MIN)
	{
		SetStatus(invalid);    
	}
}


}	// namespace ATL

#endif	// __ATLCOMTIME_INL__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlconv.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlconv.cpp is obsolete. Please remove it from your project.")

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\ATLComTime.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOMTIME_H__
#define __ATLCOMTIME_H__

#pragma once

#pragma warning(push)
#pragma warning( disable : 4159 ) //pragma has popped previously pushed identifier
#pragma warning( disable : 4127 ) //constant expression

#include <atltime.h>

#ifndef __oledb_h__
#include <oledb.h>
#endif // __oledb_h__

#if defined(_M_IX86)
#pragma pack(push, 4)
#else
#pragma pack(push, ATL_PACKING)
#endif

struct tagVARIANT;
typedef tagVARIANT VARIANT;

typedef double DATE;
 
namespace ATL
{

class COleDateTimeSpan
{
// Constructors
public:
	COleDateTimeSpan() throw();

	COleDateTimeSpan(_In_ double dblSpanSrc) throw();
	COleDateTimeSpan(
		_In_ LONG lDays, 
		_In_ int nHours, 
		_In_ int nMins, 
		_In_ int nSecs) throw();

// Attributes
	enum DateTimeSpanStatus
	{
		valid = 0,
		invalid = 1,    // Invalid span (out of range, etc.)
		null = 2,       // Literally has no value
	};

	double m_span;
	DateTimeSpanStatus m_status;

	void SetStatus(_In_ DateTimeSpanStatus status) throw();
	DateTimeSpanStatus GetStatus() const throw();

	double GetTotalDays() const throw();    // span in days (about -3.65e6 to 3.65e6)
	double GetTotalHours() const throw();   // span in hours (about -8.77e7 to 8.77e6)
	double GetTotalMinutes() const throw(); // span in minutes (about -5.26e9 to 5.26e9)
	double GetTotalSeconds() const throw(); // span in seconds (about -3.16e11 to 3.16e11)

	LONG GetDays() const throw();       // component days in span
	LONG GetHours() const throw();      // component hours in span (-23 to 23)
	LONG GetMinutes() const throw();    // component minutes in span (-59 to 59)
	LONG GetSeconds() const throw();    // component seconds in span (-59 to 59)

// Operations
	COleDateTimeSpan& operator=(_In_ double dblSpanSrc) throw();

	bool operator==(_In_ const COleDateTimeSpan& dateSpan) const throw();
	bool operator!=(_In_ const COleDateTimeSpan& dateSpan) const throw();
	bool operator<(_In_ const COleDateTimeSpan& dateSpan) const throw();
	bool operator>(_In_ const COleDateTimeSpan& dateSpan) const throw();
	bool operator<=(_In_ const COleDateTimeSpan& dateSpan) const throw();
	bool operator>=(_In_ const COleDateTimeSpan& dateSpan) const throw();

	// DateTimeSpan math
	COleDateTimeSpan operator+(_In_ const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan operator-(_In_ const COleDateTimeSpan& dateSpan) const throw();
	COleDateTimeSpan& operator+=(_In_ const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan& operator-=(_In_ const COleDateTimeSpan dateSpan) throw();
	COleDateTimeSpan operator-() const throw();

	operator double() const throw();

	void SetDateTimeSpan(
		_In_ LONG lDays, 
		_In_ int nHours, 
		_In_ int nMins, 
		_In_ int nSecs) throw();

	// formatting
	CString Format(_In_z_ LPCTSTR pFormat) const;
	CString Format(_In_ UINT nID) const;

// Implementation
	void CheckRange();

	static const double OLE_DATETIME_HALFSECOND;
};

class COleDateTime
{
// Constructors
public:
	static COleDateTime WINAPI GetCurrentTime() throw();

	COleDateTime() throw();

	COleDateTime(_In_ const VARIANT& varSrc) throw();
	COleDateTime(_In_ DATE dtSrc) throw();

	COleDateTime(_In_ __time32_t timeSrc) throw();
	COleDateTime(_In_ __time64_t timeSrc) throw();

	COleDateTime(_In_ const SYSTEMTIME& systimeSrc) throw();
	COleDateTime(_In_ const FILETIME& filetimeSrc) throw();

	COleDateTime(
		_In_ int nYear, 
		_In_ int nMonth, 
		_In_ int nDay,
		_In_ int nHour, 
		_In_ int nMin, 
		_In_ int nSec) throw();
	COleDateTime(_In_ WORD wDosDate, _In_ WORD wDosTime) throw();

	COleDateTime(_In_ const DBTIMESTAMP& dbts) throw();
	bool GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const throw();

// Attributes
	enum DateTimeStatus
	{
		error = -1,
		valid = 0,
		invalid = 1,    // Invalid date (out of range, etc.)
		null = 2,       // Literally has no value
	};

	DATE m_dt;
	DateTimeStatus m_status;

	void SetStatus(_In_ DateTimeStatus status) throw();
	DateTimeStatus GetStatus() const throw();

	bool GetAsSystemTime(_Out_ SYSTEMTIME& sysTime) const throw();
	bool GetAsUDATE(_Out_ UDATE& udate) const throw();

	int GetYear() const throw();
	// Month of year (1 = January)
	int GetMonth() const throw();
	// Day of month (1-31)
	int GetDay() const throw();
	// Hour in day (0-23)
	int GetHour() const throw();
	// Minute in hour (0-59)
	int GetMinute() const throw();
	// Second in minute (0-59)
	int GetSecond() const throw();
	// Day of week (1 = Sunday, 2 = Monday, ..., 7 = Saturday)
	int GetDayOfWeek() const throw();
	// Days since start of year (1 = January 1)
	int GetDayOfYear() const throw();

// Operations
	COleDateTime& operator=(_In_ const VARIANT& varSrc) throw();
	COleDateTime& operator=(_In_ DATE dtSrc) throw();

	COleDateTime& operator=(_In_ const __time32_t& timeSrc) throw();
	COleDateTime& operator=(_In_ const __time64_t& timeSrc) throw();

	COleDateTime& operator=(_In_ const SYSTEMTIME& systimeSrc) throw();
	COleDateTime& operator=(_In_ const FILETIME& filetimeSrc) throw();
	COleDateTime& operator=(_In_ const UDATE& udate) throw();

	bool operator==(_In_ const COleDateTime& date) const throw();
	bool operator!=(_In_ const COleDateTime& date) const throw();
	bool operator<(_In_ const COleDateTime& date) const throw();
	bool operator>(_In_ const COleDateTime& date) const throw();
	bool operator<=(_In_ const COleDateTime& date) const throw();
	bool operator>=(_In_ const COleDateTime& date) const throw();

	// DateTime math
	COleDateTime operator+(_In_ COleDateTimeSpan dateSpan) const throw();
	COleDateTime operator-(_In_ COleDateTimeSpan dateSpan) const throw();
	COleDateTime& operator+=(_In_ COleDateTimeSpan dateSpan) throw();
	COleDateTime& operator-=(_In_ COleDateTimeSpan dateSpan) throw();

	// DateTimeSpan math
	COleDateTimeSpan operator-(_In_ const COleDateTime& date) const throw();

	operator DATE() const throw();

	int SetDateTime(
		_In_ int nYear, 
		_In_ int nMonth, 
		_In_ int nDay,
		_In_ int nHour, 
		_In_ int nMin, 
		_In_ int nSec) throw();
	int SetDate(_In_ int nYear, _In_ int nMonth, _In_ int nDay) throw();
	int SetTime(_In_ int nHour, _In_ int nMin, _In_ int nSec) throw();
	bool ParseDateTime(
		_In_opt_z_ LPCTSTR lpszDate, 
		_In_ DWORD dwFlags = 0,
		_In_ LCID lcid = LANG_USER_DEFAULT) throw();

	// formatting
	CString Format(_In_ DWORD dwFlags = 0, _In_ LCID lcid = LANG_USER_DEFAULT) const;
	CString Format(_In_z_ LPCTSTR lpszFormat) const;
	CString Format(_In_ UINT nFormatID) const;

protected:
	static double WINAPI DoubleFromDate(_In_ DATE date) throw();
	static DATE WINAPI DateFromDouble(_In_ double f) throw();

	void CheckRange();	
	BOOL ConvertSystemTimeToVariantTime(_In_ const SYSTEMTIME& systimeSrc);
};

}	// namespace ATL
 
#ifndef _DEBUG
#define ATLCOMTIME_INLINE inline
#include <atlcomtime.inl>
#endif
 
namespace ATL
{

inline bool COleDateTime::ParseDateTime(
	_In_opt_z_ LPCTSTR lpszDate, 
	_In_ DWORD dwFlags, 
	_In_ LCID lcid) throw()
{
	USES_CONVERSION_EX;
	LPCTSTR pszDate = ( lpszDate == NULL ) ? _T("") : lpszDate;

	HRESULT hr;
	LPOLESTR p = T2OLE_EX((LPTSTR)pszDate, _ATL_SAFE_ALLOCA_DEF_THRESHOLD);
#ifndef _UNICODE
	if( p == NULL )
	{
		m_dt = 0;
		m_status = invalid;
		return false;
	}
#endif // _UNICODE

	if (FAILED(hr = VarDateFromStr( p, lcid, dwFlags, &m_dt )))
	{
		if (hr == DISP_E_TYPEMISMATCH)
		{
			// Can't convert string to date, set 0 and invalidate
			m_dt = 0;
			m_status = invalid;
			return false;
		}
		else if (hr == DISP_E_OVERFLOW)
		{
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
		else
		{
			ATLTRACE(atlTraceTime, 0, _T("\nCOleDateTime VarDateFromStr call failed.\n\t"));
			// Can't convert string to date, set -1 and invalidate
			m_dt = -1;
			m_status = invalid;
			return false;
		}
	}

	m_status = valid;
	return true;
}

inline CString COleDateTimeSpan::Format(_In_z_ LPCTSTR pFormat) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	CTimeSpan tmp(GetDays(), GetHours(), GetMinutes(), GetSeconds());
	return tmp.Format(pFormat);
}

inline CString COleDateTimeSpan::Format(_In_ UINT nFormatID) const
{
	CString strFormat;
	if (!strFormat.LoadString(nFormatID))
		AtlThrow(E_INVALIDARG);
	return Format(strFormat);
}

inline CString COleDateTime::Format(
	_In_ DWORD dwFlags, 
	_In_ LCID lcid) const
{
	// If null, return empty string
	if (GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if (GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CComBSTR bstr;
	if (FAILED(::VarBstrFromDate(m_dt, lcid, dwFlags, &bstr)))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	CString tmp = CString(bstr);
	return tmp;
}

inline CString COleDateTime::Format(_In_z_ LPCTSTR pFormat) const
{
	ATLENSURE_THROW(pFormat != NULL, E_INVALIDARG);
	
	// If null, return empty string
	if(GetStatus() == null)
		return _T("");

	// If invalid, return DateTime global string
	if(GetStatus() == invalid)
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	UDATE ud;
	if (S_OK != VarUdateFromDate(m_dt, 0, &ud))
	{
		CString str;
		if(str.LoadString(ATL_IDS_DATETIME_INVALID))
			return str;
		return szInvalidDateTime;
	}

	struct tm tmTemp;
	tmTemp.tm_sec	= ud.st.wSecond;
	tmTemp.tm_min	= ud.st.wMinute;
	tmTemp.tm_hour	= ud.st.wHour;
	tmTemp.tm_mday	= ud.st.wDay;
	tmTemp.tm_mon	= ud.st.wMonth - 1;
	tmTemp.tm_year	= ud.st.wYear - 1900;
	tmTemp.tm_wday	= ud.st.wDayOfWeek;
	tmTemp.tm_yday	= ud.wDayOfYear - 1;
	tmTemp.tm_isdst	= 0;

	CString strDate;
	LPTSTR lpszTemp = strDate.GetBufferSetLength(256);
	_tcsftime(lpszTemp, strDate.GetLength(), pFormat, &tmTemp);
	strDate.ReleaseBuffer();

	return strDate;
}

inline CString COleDateTime::Format(_In_ UINT nFormatID) const
{
	CString strFormat;
	ATLENSURE(strFormat.LoadString(nFormatID));
	return Format(strFormat);
}

inline COleDateTime::COleDateTime(_In_ const DBTIMESTAMP& dbts)
{
	SYSTEMTIME st;
	::ZeroMemory(&st, sizeof(SYSTEMTIME));

	st.wYear = WORD(dbts.year);
	st.wMonth = WORD(dbts.month);
	st.wDay = WORD(dbts.day);
	st.wHour = WORD(dbts.hour);
	st.wMinute = WORD(dbts.minute);
	st.wSecond = WORD(dbts.second);

	m_status = ::SystemTimeToVariantTime(&st, &m_dt) ? valid : invalid;
}

inline bool COleDateTime::GetAsDBTIMESTAMP(_Out_ DBTIMESTAMP& dbts) const
{
	UDATE ud;
	if (S_OK != VarUdateFromDate(m_dt, 0, &ud))
		return false;

	dbts.year = (SHORT) ud.st.wYear;
	dbts.month = (USHORT) ud.st.wMonth;
	dbts.day = (USHORT) ud.st.wDay;
	dbts.hour = (USHORT) ud.st.wHour;
	dbts.minute = (USHORT) ud.st.wMinute;
	dbts.second = (USHORT) ud.st.wSecond;
	dbts.fraction = 0;

	return true;
}

}	// namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#endif	// __ATLCOMTIME_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\ATLComMem.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOMMEM_H__
#define __ATLCOMMEM_H__

#pragma once

#ifndef __ATLMEM_H__
	#error ATLComMem.h requires atlmem.h to be included first
#endif	// __ATLMEM_H__

#include <atlcomcli.h>

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

class CComHeap :
	public IAtlMemMgr
{
// IAtlMemMgr
public:
	_Ret_opt_bytecap_(nBytes) virtual void* Allocate(_In_ size_t nBytes) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return( ::CoTaskMemAlloc( ULONG( nBytes ) ) );
	}
	virtual void Free(_In_opt_ void* p) throw()
	{
		::CoTaskMemFree( p );
	}
	_Ret_opt_bytecap_(nBytes) virtual void* Reallocate(
		_In_opt_ void* p,
		_In_ size_t nBytes) throw()
	{
#ifdef _WIN64
		if( nBytes > INT_MAX )
		{
			return( NULL );
		}
#endif
		return( ::CoTaskMemRealloc( p, ULONG( nBytes ) ) );
	}
	virtual size_t GetSize(_In_opt_ void* p) throw()
	{
		CComPtr< IMalloc > pMalloc;

		HRESULT hr = ::CoGetMalloc( 1, &pMalloc );
		if (FAILED(hr))
			return 0;

		return( pMalloc->GetSize( p ) );
	}
};

/////////////////////////////////////////////////////////////////////////////
// OLE task memory allocation support

inline LPWSTR AtlAllocTaskWideString(
	_In_opt_z_ LPCWSTR lpszString) throw()
{
	if (lpszString == NULL)
	{
		return NULL;
	}
	UINT nSize = (UINT)((wcslen(lpszString)+1) * sizeof(WCHAR));
	LPWSTR lpszResult = (LPWSTR)CoTaskMemAlloc(nSize);
	if (lpszResult == NULL)
	{
		return NULL;
	}

	if(0 != memcpy_s(lpszResult, nSize, lpszString, nSize))
	{
		CoTaskMemFree(lpszResult);
		return NULL;
	}

	return lpszResult;
}

inline LPWSTR AtlAllocTaskWideString(
	_In_opt_z_ LPCSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nLen = lstrlenA(lpszString)+1;
	LPWSTR lpszResult = (LPWSTR)::ATL::AtlCoTaskMemCAlloc(nLen, static_cast<ULONG>(sizeof(WCHAR)));
	if (lpszResult != NULL)
	{
		int nRet = MultiByteToWideChar(CP_ACP, 0, lpszString, -1, lpszResult, nLen);
		ATLASSERT(nRet != 0);
		if (nRet == 0)
		{
			CoTaskMemFree(lpszResult);
			lpszResult = NULL;
		}
	}
	return lpszResult;
}

inline LPSTR AtlAllocTaskAnsiString(
	_In_opt_z_ LPCWSTR lpszString) throw()
{
	if (lpszString == NULL)
		return NULL;
	UINT nBytes = (UINT)((wcslen(lpszString)+1)*2);
	LPSTR lpszResult = (LPSTR)CoTaskMemAlloc(nBytes);
	if (lpszResult != NULL)
	{
		int nRet = WideCharToMultiByte(CP_ACP, 0, lpszString, -1, lpszResult, nBytes, NULL, NULL);
		ATLASSERT(nRet != 0);
		if (nRet == 0)
		{
			CoTaskMemFree(lpszResult);
			lpszResult = NULL;
		}
	}
	return lpszResult;
}

inline LPSTR AtlAllocTaskAnsiString(
	_In_opt_z_ LPCSTR lpszString) throw()
{
	if (lpszString == NULL)
	{
		return NULL;
	}
	UINT nSize = lstrlenA(lpszString)+1;
	LPSTR lpszResult = (LPSTR)CoTaskMemAlloc(nSize);
	if (lpszResult == NULL)
	{
		return NULL;
	}

	if(0 != memcpy_s(lpszResult, nSize, lpszString, nSize))
	{
		CoTaskMemFree(lpszResult);
		return NULL;
	}
	return lpszResult;
}

#ifdef _UNICODE
	#define AtlAllocTaskString(x) AtlAllocTaskWideString(x)
#else
	#define AtlAllocTaskString(x) AtlAllocTaskAnsiString(x)
#endif

#define AtlAllocTaskOleString(x) AtlAllocTaskWideString(x)

}	// namespace ATL
#pragma pack(pop)

#endif	// __ATLCOMMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlctl.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma message("atlctl.cpp is obsolete. Please remove it from your project.")

///////////////////////////////////////
// No longer used
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlcore.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCORE_H__
#define __ATLCORE_H__

#pragma once

#ifdef _ATL_ALL_WARNINGS
#pragma warning( push )
#endif

#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4127) // constant expression

#include <atldef.h>
#include <windows.h>
#include <ole2.h>

#include <limits.h>
#include <tchar.h>
#include <mbstring.h>

#include <atlchecked.h>
#include <atlsimpcoll.h>

#if _WIN32_WINNT < 0x0403
#error This file requires _WIN32_WINNT to be #defined at least to 0x0403. Value 0x0501 or higher is recommended.
#endif

#pragma pack(push,_ATL_PACKING)
namespace ATL
{
/////////////////////////////////////////////////////////////////////////////
// Verify that a null-terminated string points to valid memory
inline BOOL AtlIsValidString(
	_In_z_count_(nMaxLength) LPCWSTR psz,
	_In_ size_t nMaxLength = INT_MAX)
{
	(nMaxLength);
	return (psz != NULL);
}

// Verify that a null-terminated string points to valid memory
inline BOOL AtlIsValidString(
	_In_z_count_(nMaxLength) LPCSTR psz,
	_In_ size_t nMaxLength = UINT_MAX)
{
	(nMaxLength);
	return (psz != NULL);
}

// Verify that a pointer points to valid memory
inline BOOL AtlIsValidAddress(
	_In_opt_bytecount_(nBytes) const void* p,
	_In_ size_t nBytes,
	_In_ BOOL bReadWrite = TRUE)
{
	(bReadWrite);
	(nBytes);
	return (p != NULL);
}

template<typename T>
inline void AtlAssertValidObject(
	_In_opt_ _Prepost_opt_bytecount_x_(sizeof(T)) const T *pOb)
{
	ATLASSERT(pOb);
	ATLASSERT(AtlIsValidAddress(pOb, sizeof(T)));
	if(pOb)
		pOb->AssertValid();
}
#ifdef _DEBUG
#define ATLASSERT_VALID(x) ATL::AtlAssertValidObject(x)
#else
#define ATLASSERT_VALID(x) __noop;
#endif

// COM Sync Classes
class CComCriticalSection
{
public:
	CComCriticalSection() throw()
	{
		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
	}
	~CComCriticalSection()
	{
	}
	HRESULT Lock() throw()
	{
		EnterCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Unlock() throw()
	{
		LeaveCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Init() throw()
	{
		HRESULT hRes = S_OK;

		if (!InitializeCriticalSectionAndSpinCount(&m_sec, 0))
		{
			hRes = HRESULT_FROM_WIN32(GetLastError());
		}

		return hRes;
	}

	HRESULT Term() throw()
	{
		DeleteCriticalSection(&m_sec);
		return S_OK;
	}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection : 
	public CComCriticalSection
{
public:
	CComAutoCriticalSection()
	{
		HRESULT hr = CComCriticalSection::Init();
		if (FAILED(hr))
			AtlThrow(hr);
	}
	~CComAutoCriticalSection() throw()
	{
		CComCriticalSection::Term();
	}
private :
	HRESULT Init(); // Not implemented. CComAutoCriticalSection::Init should never be called
	HRESULT Term(); // Not implemented. CComAutoCriticalSection::Term should never be called
};

class CComSafeDeleteCriticalSection : 
	public CComCriticalSection
{
public:
	CComSafeDeleteCriticalSection(): m_bInitialized(false)
	{
	}

	~CComSafeDeleteCriticalSection() throw()
	{
		if (!m_bInitialized)
		{
			return;
		}
		m_bInitialized = false;
		CComCriticalSection::Term();
	}

	HRESULT Init() throw()
	{
		ATLASSERT( !m_bInitialized );
		HRESULT hr = CComCriticalSection::Init();
		if (SUCCEEDED(hr))
		{
			m_bInitialized = true;
		}
		return hr;
	}

	HRESULT Term() throw()
	{
		if (!m_bInitialized)
		{
			return S_OK;
		}
		m_bInitialized = false;
		return CComCriticalSection::Term();
	}

	HRESULT Lock()
	{
		// CComSafeDeleteCriticalSection::Init or CComAutoDeleteCriticalSection::Init
		// not called or failed.
		// m_critsec member of CComObjectRootEx is now of type
		// CComAutoDeleteCriticalSection. It has to be initialized
		// by calling CComObjectRootEx::_AtlInitialConstruct
		ATLASSUME(m_bInitialized);
		return CComCriticalSection::Lock();
	}

private:
	bool m_bInitialized;
};

class CComAutoDeleteCriticalSection : 
	public CComSafeDeleteCriticalSection
{
private:
	// CComAutoDeleteCriticalSection::Term should never be called
	HRESULT Term() throw();
};

class CComFakeCriticalSection
{
public:
	HRESULT Lock() throw()
	{
		return S_OK;
	}
	HRESULT Unlock() throw()
	{
		return S_OK;
	}
	HRESULT Init() throw()
	{
		return S_OK;
	}
	HRESULT Term() throw()
	{
		return S_OK;
	}
};

/////////////////////////////////////////////////////////////////////////////
// Module

// Used by any project that uses ATL
struct _ATL_BASE_MODULE70
{
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	DWORD dwAtlBuildVer;
	const GUID* pguidVer;
	CComCriticalSection m_csResource;
	CSimpleArray<HINSTANCE> m_rgResourceInstance;
};
typedef _ATL_BASE_MODULE70 _ATL_BASE_MODULE;

class CAtlBaseModule : 
	public _ATL_BASE_MODULE
{
public :
	static bool m_bInitFailed;
	CAtlBaseModule() throw();
	~CAtlBaseModule() throw ();

	HINSTANCE GetModuleInstance() throw()
	{
		return m_hInst;
	}
	HINSTANCE GetResourceInstance() throw()
	{
		return m_hInstResource;
	}
	HINSTANCE SetResourceInstance(_In_ HINSTANCE hInst) throw()
	{
		return static_cast< HINSTANCE >(InterlockedExchangePointer((void**)&m_hInstResource, hInst));
	}

	bool AddResourceInstance(_In_ HINSTANCE hInst) throw();
	bool RemoveResourceInstance(_In_ HINSTANCE hInst) throw();
	HINSTANCE GetHInstanceAt(_In_ int i) throw();
};

__declspec(selectany) bool CAtlBaseModule::m_bInitFailed = false;
extern CAtlBaseModule _AtlBaseModule;

/////////////////////////////////////////////////////////////////////////////
// String resource helpers

#pragma warning(push)
#pragma warning(disable: 4200)
	struct ATLSTRINGRESOURCEIMAGE
	{
		WORD nLength;
		WCHAR achString[];
	};
#pragma warning(pop)	// C4200

inline const ATLSTRINGRESOURCEIMAGE* _AtlGetStringResourceImage(
	_In_ HINSTANCE hInstance,
	_In_ HRSRC hResource,
	_In_ UINT id) throw()
{
	const ATLSTRINGRESOURCEIMAGE* pImage;
	const ATLSTRINGRESOURCEIMAGE* pImageEnd;
	ULONG nResourceSize;
	HGLOBAL hGlobal;
	UINT iIndex;

	hGlobal = ::LoadResource( hInstance, hResource );
	if( hGlobal == NULL )
	{
		return( NULL );
	}

	pImage = (const ATLSTRINGRESOURCEIMAGE*)::LockResource( hGlobal );
	if( pImage == NULL )
	{
		return( NULL );
	}

	nResourceSize = ::SizeofResource( hInstance, hResource );
	pImageEnd = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+nResourceSize);
	iIndex = id&0x000f;

	while( (iIndex > 0) && (pImage < pImageEnd) )
	{
		pImage = (const ATLSTRINGRESOURCEIMAGE*)(LPBYTE( pImage )+(sizeof( ATLSTRINGRESOURCEIMAGE )+(pImage->nLength*sizeof( WCHAR ))));
		iIndex--;
	}
	if( pImage >= pImageEnd )
	{
		return( NULL );
	}
	if( pImage->nLength == 0 )
	{
		return( NULL );
	}

	return( pImage );
}

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage(
	_In_ HINSTANCE hInstance,
	_In_ UINT id) throw()
{
	HRSRC hResource;
	/*
		The and operation (& static_cast<WORD>(~0)) protects the expression from being greater
		than WORD - this would cause a runtime error when the application is compiled with /RTCc flag.
	*/
	hResource = ::FindResourceW(hInstance, MAKEINTRESOURCEW( (((id>>4)+1) & static_cast<WORD>(~0)) ), (LPWSTR) RT_STRING);
	if( hResource == NULL )
	{
		return( NULL );
	}

	return _AtlGetStringResourceImage( hInstance, hResource, id );
}

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage(
	_In_ HINSTANCE hInstance,
	_In_ UINT id,
	_In_ WORD wLanguage) throw()
{
	HRSRC hResource;
	/*
		The and operation (& static_cast<WORD>(~0)) protects the expression from being greater
		than WORD - this would cause a runtime error when the application is compiled with /RTCc flag.
	*/
	hResource = ::FindResourceExW(hInstance, (LPWSTR) RT_STRING, MAKEINTRESOURCEW( (((id>>4)+1) & static_cast<WORD>(~0)) ), wLanguage);
	if( hResource == NULL )
	{
		return( NULL );
	}

	return _AtlGetStringResourceImage( hInstance, hResource, id );
}

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage(_In_ UINT id) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		p = AtlGetStringResourceImage(hInst, id);
	}
	return p;
}

inline const ATLSTRINGRESOURCEIMAGE* AtlGetStringResourceImage(
	_In_ UINT id,
	_In_ WORD wLanguage) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		p = AtlGetStringResourceImage(hInst, id, wLanguage);
	}
	return p;
}

inline int AtlLoadString(
	_In_ UINT nID,
	_Out_z_cap_post_count_(nBufferMax, return + 1) LPTSTR lpBuffer,
	_In_ int nBufferMax) throw()
{
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);
	int nRet = 0;

	for (int i = 1; hInst != NULL && nRet == 0; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		nRet = LoadString(hInst, nID, lpBuffer, nBufferMax);
	}
	return nRet;
}

inline HINSTANCE AtlFindResourceInstance(
	_In_z_ LPCTSTR lpName,
	_In_z_ LPCTSTR lpType,
	_In_ WORD wLanguage = 0) throw()
{
	ATLASSERT(lpType != RT_STRING);	// Call AtlFindStringResourceInstance to find the string
	if (lpType == RT_STRING)
		return NULL;

	if (ATL_IS_INTRESOURCE(lpType))
	{
		/* Prefast false warnings caused by bad-shaped definition of MAKEINTRESOURCE macro from PSDK */
		if (lpType == ATL_RT_ICON)
		{
			lpType = ATL_RT_GROUP_ICON;
		}
		else if (lpType == ATL_RT_CURSOR)
		{
			lpType = ATL_RT_GROUP_CURSOR;
		}
	}

	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);
	HRSRC hResource = NULL;

	for (int i = 1; hInst != NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		hResource = ::FindResourceEx(hInst, lpType, lpName, wLanguage);
		if (hResource != NULL)
		{
			return hInst;
		}
	}

	return NULL;
}

inline HINSTANCE AtlFindResourceInstance(
	_In_ UINT nID,
	_In_z_ LPCTSTR lpType,
	_In_ WORD wLanguage = 0) throw()
{
	/*
		The and operation (& static_cast<WORD>(~0)) protects the expression from being greater
		than WORD - this would cause a runtime error when the application is compiled with /RTCc flag.
	*/
	return AtlFindResourceInstance(MAKEINTRESOURCE(nID & static_cast<WORD>(~0)), lpType, wLanguage);
}

inline HINSTANCE AtlFindStringResourceInstance(
	_In_ UINT nID,
	_In_ WORD wLanguage = 0) throw()
{
	const ATLSTRINGRESOURCEIMAGE* p = NULL;
	HINSTANCE hInst = _AtlBaseModule.GetHInstanceAt(0);

	for (int i = 1; hInst != NULL && p == NULL; hInst = _AtlBaseModule.GetHInstanceAt(i++))
	{
		p = AtlGetStringResourceImage(hInst, nID, wLanguage);
		if (p != NULL)
			return hInst;
	}

	return NULL;
}

/*
Needed by both atlcomcli and atlsafe, so needs to be in here
*/
inline HRESULT AtlSafeArrayGetActualVartype(
    _In_ SAFEARRAY *psaArray,
    _Out_ VARTYPE *pvtType)
{
    HRESULT hrSystem=::SafeArrayGetVartype(psaArray, pvtType);

    if(FAILED(hrSystem))
    {
        return hrSystem;
    }

    /*
    When Windows has a SAFEARRAY of type VT_DISPATCH with FADF_HAVEIID,
    it returns VT_UNKNOWN instead of VT_DISPATCH. We patch the value to be correct
    */
    if(pvtType && *pvtType==VT_UNKNOWN)
    {
        if(psaArray && ((psaArray->fFeatures & FADF_HAVEIID)!=0))
        {
            if(psaArray->fFeatures & FADF_DISPATCH)
            {
                *pvtType=VT_DISPATCH;
            }
        }
    }

    return hrSystem;
}
template <typename _CharType>
inline _CharType* AtlCharNext(_In_ const _CharType* p) throw()
{
	ATLASSUME(p != NULL);	// Too expensive to check separately here
	if (*p == '\0')  // ::CharNextA won't increment if we're at a \0 already
		return const_cast<_CharType*>(p+1);
	else
		return ::CharNextA(p);
}

template <>
inline wchar_t* AtlCharNext<wchar_t>(_In_ const wchar_t* p) throw()
{
	return const_cast< wchar_t* >( p+1 );
}
template<typename CharType>
inline const CharType* AtlstrchrT(
	_In_z_ const CharType* p,
	_In_ CharType ch) throw()
{
	ATLASSERT(p != NULL);
	if(p==NULL)
	{
		return NULL;
	}
	while( *p != 0 )
	{
		if (*p == ch)
		{
			return p;
		}
		p = AtlCharNext(p);
	}
	//strchr for '\0' should succeed - the while loop terminates
	//*p == 0, but ch also == 0, so NULL terminator address is returned
	return (*p == ch) ? p : NULL;
}
//Ansi and Unicode versions of printf, used with templated CharType trait classes.
#pragma warning(push)
#pragma warning(disable : 4793)
template<typename CharType>
inline int AtlprintfT(_In_z_ _Printf_format_string_ const CharType* pszFormat,...) throw()
{
	int retval=0;
	va_list argList;
	va_start( argList, pszFormat );
	retval=vprintf(pszFormat,argList);
	va_end( argList );
	return retval;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4793)
template<>
inline int AtlprintfT(_In_z_ _Printf_format_string_ const wchar_t* pszFormat,... ) throw()
{
	int retval=0;
	va_list argList;
	va_start( argList, pszFormat );
	retval=vwprintf(pszFormat,	argList);
	va_end( argList );
	return retval;
}
#pragma warning(pop)

inline BOOL AtlConvertSystemTimeToVariantTime(
	_In_ const SYSTEMTIME& systimeSrc,
	_Out_ double* pVarDtTm)
{
	ATLENSURE(pVarDtTm!=NULL);
	//Convert using ::SystemTimeToVariantTime and store the result in pVarDtTm then
	//convert variant time back to system time and compare to original system time.
	BOOL ok = ::SystemTimeToVariantTime(const_cast<SYSTEMTIME*>(&systimeSrc), pVarDtTm);
	SYSTEMTIME sysTime;
	::ZeroMemory(&sysTime, sizeof(SYSTEMTIME));

	ok = ok && ::VariantTimeToSystemTime(*pVarDtTm, &sysTime);
	ok = ok && (systimeSrc.wYear == sysTime.wYear &&
			systimeSrc.wMonth == sysTime.wMonth &&
			systimeSrc.wDay == sysTime.wDay &&
			systimeSrc.wHour == sysTime.wHour &&
			systimeSrc.wMinute == sysTime.wMinute &&
			systimeSrc.wSecond == sysTime.wSecond);

	return ok;
}
/////////////////////////////////////////////////////////////////////////////

}	// namespace ATL
#pragma pack(pop)

#ifdef _ATL_ALL_WARNINGS
#pragma warning( pop )
#endif

#endif	// __ATLCORE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4127) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>
#include <stddef.h>
#include <atlalloc.h>

#ifndef __wtypes_h__

#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>

#if !defined(OLE2ANSI)

typedef WCHAR OLECHAR;
typedef OLECHAR  *LPOLESTR;
typedef const OLECHAR  *LPCOLESTR;
#define OLESTR(str) L##str

#else

typedef char      OLECHAR;
typedef LPSTR     LPOLESTR;
typedef LPCSTR    LPCOLESTR;
#define OLESTR(str) str

#endif	// !OLE2ANSI
#endif	// __wtypes_h__

#ifndef _OLEAUTO_H_
typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h

extern "C"
{
__declspec(dllimport) _Ret_opt_z_ BSTR __stdcall SysAllocString(_In_opt_z_ const OLECHAR *);
__declspec(dllimport) _Ret_opt_z_ BSTR __stdcall SysAllocStringLen(
	_In_z_count_(nLen) const OLECHAR *, 
	_In_ UINT nLen);
__declspec(dllimport) INT  __stdcall SysReAllocStringLen(
	_Deref_out_opt_z_ BSTR*, 
	_In_opt_z_count_(nLen) const OLECHAR *, 
	_In_ UINT nLen);
__declspec(dllimport) void __stdcall SysFreeString(_In_opt_z_ BSTR);
}
#endif

// we use our own implementation of InterlockedExchangePointer because of problems with the one in system headers
#ifdef _M_IX86
#undef InterlockedExchangePointer
inline void* WINAPI InterlockedExchangePointer(
	_Inout_ void** pp, 
	_In_opt_ void* pNew) throw()
{
	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(
		::InterlockedExchange(reinterpret_cast<LONG*>(pp), 
			static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );
}
#endif

#define ATLCONV_DEADLAND_FILL _SECURECRT_FILL_BUFFER_PATTERN

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline UINT WINAPI _AtlGetConversionACP() throw()
{
#ifdef _CONVERSION_DONT_USE_THREAD_LOCALE
	return CP_ACP;
#else
	return CP_THREAD_ACP;
#endif
}

template <class _CharType>
inline void AtlConvAllocMemory(
	_Inout_ _Deref_post_cap_(nLength) _CharType** ppBuff,
	_In_ int nLength,
	_Inout_cap_(nFixedBufferLength) _CharType* pszFixedBuffer,
	_In_ int nFixedBufferLength)
{
	ATLENSURE_THROW(ppBuff != NULL, E_INVALIDARG);
	ATLENSURE_THROW(nLength >= 0, E_INVALIDARG);
	ATLENSURE_THROW(pszFixedBuffer != NULL, E_INVALIDARG);

	//if buffer malloced, try to realloc.
	if (*ppBuff != pszFixedBuffer)
	{
		if( nLength > nFixedBufferLength )
		{
			_CharType* ppReallocBuf = static_cast< _CharType* >( _recalloc(*ppBuff, nLength,sizeof( _CharType ) ) );
			if (ppReallocBuf == NULL) 
			{
				AtlThrow( E_OUTOFMEMORY );
			}
			*ppBuff = ppReallocBuf;
		} else
		{
			free(*ppBuff);
			*ppBuff=pszFixedBuffer;
		}

	} else //Buffer is not currently malloced.
	{
		if( nLength > nFixedBufferLength )
		{
			*ppBuff = static_cast< _CharType* >( calloc(nLength,sizeof( _CharType ) ) );
		} else
		{			
			*ppBuff=pszFixedBuffer;
		}
	}

	if (*ppBuff == NULL)
	{
		AtlThrow( E_OUTOFMEMORY );
	}
}

template <class _CharType>
inline void AtlConvFreeMemory(
	_Inout_ _CharType* pBuff,
	_Inout_cap_(nFixedBufferLength) _CharType* pszFixedBuffer,
	_In_ int nFixedBufferLength)
{
	(nFixedBufferLength);
	if( pBuff != pszFixedBuffer )
	{
		free( pBuff );
	} 	
#ifdef _DEBUG
	else
	{		
		memset(pszFixedBuffer,ATLCONV_DEADLAND_FILL,nFixedBufferLength*sizeof(_CharType));
	}
#endif
}

template< int t_nBufferLength = 128 >
class CW2WEX
{
public:
	CW2WEX(_In_z_ LPCWSTR psz) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CW2WEX(
			_In_z_ LPCWSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CW2WEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	_Ret_z_ operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init(_In_z_ LPCWSTR psz) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenW( psz )+1;
		AtlConvAllocMemory(&m_psz,nLength,m_szBuffer,t_nBufferLength);
		ATLASSUME(m_psz != NULL);
		Checked::memcpy_s( m_psz, nLength*sizeof( wchar_t ), psz, nLength*sizeof( wchar_t ));
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CW2WEX(_In_ const CW2WEX&) throw();
	CW2WEX& operator=(_In_ const CW2WEX&) throw();
};
typedef CW2WEX<> CW2W;

template< int t_nBufferLength = 128 >
class CA2AEX
{
public:
	CA2AEX(_In_z_ LPCSTR psz) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CA2AEX(
			_In_z_ LPCSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CA2AEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	_Ret_z_ operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init(_In_z_ LPCSTR psz) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenA( psz )+1;
		AtlConvAllocMemory(&m_psz,nLength,m_szBuffer,t_nBufferLength);		
		Checked::memcpy_s( m_psz, nLength*sizeof( char ), psz, nLength*sizeof( char ));
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CA2AEX(_In_ const CA2AEX&) throw();
	CA2AEX& operator=(_In_ const CA2AEX&) throw();
};
typedef CA2AEX<> CA2A;

template< int t_nBufferLength = 128 >
class CA2CAEX
{
public:
	CA2CAEX(_In_z_ LPCSTR psz) throw(...) :
		m_psz( psz )
	{
	}
	CA2CAEX(
			_In_z_ LPCSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CA2CAEX() throw()
	{
	}
	
	_Ret_z_ operator LPCSTR() const throw()
	{
		return( m_psz );
	}
	
public:
	LPCSTR m_psz;

private:
	CA2CAEX(_In_ const CA2CAEX&) throw();
	CA2CAEX& operator=(_In_ const CA2CAEX&) throw();
};
typedef CA2CAEX<> CA2CA;

template< int t_nBufferLength = 128 >
class CW2CWEX
{
public:
	CW2CWEX(_In_z_ LPCWSTR psz) throw(...) :
		m_psz( psz )
	{
	}
	CW2CWEX(
			_In_z_ LPCWSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( psz )
	{		
		UNREFERENCED_PARAMETER(nCodePage);
	}
	~CW2CWEX() throw()
	{
	}

	_Ret_z_ operator LPCWSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCWSTR m_psz;

private:
	CW2CWEX(_In_ const CW2CWEX&) throw();
	CW2CWEX& operator=(_In_ const CW2CWEX&) throw();
};
typedef CW2CWEX<> CW2CW;

template< int t_nBufferLength = 128 >
class CA2WEX
{
public:
	CA2WEX(_In_z_ LPCSTR psz) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CA2WEX(
			_In_z_ LPCSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CA2WEX() throw()
	{
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	_Ret_z_ operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init(
		_In_z_ LPCSTR psz, 
		_In_ UINT nCodePage) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthA = lstrlenA( psz )+1;
		int nLengthW = nLengthA;

		AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);

		BOOL bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );
		if (bFailed)
		{
			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
			{
				nLengthW = ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, NULL, 0);
				AtlConvAllocMemory(&m_psz,nLengthW,m_szBuffer,t_nBufferLength);
				bFailed=(0 == ::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW ) );
			}			
		}
		if (bFailed)
		{
			AtlThrowLastWin32();
		}		
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CA2WEX(_In_ const CA2WEX&) throw();
	CA2WEX& operator=(_In_ const CA2WEX&) throw();
};
typedef CA2WEX<> CA2W;

template< int t_nBufferLength = 128 >
class CW2AEX
{
public:
	CW2AEX(_In_z_ LPCWSTR psz) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CW2AEX(
			_In_z_ LPCWSTR psz, 
			_In_ UINT nCodePage) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CW2AEX() throw()
	{		
		AtlConvFreeMemory(m_psz,m_szBuffer,t_nBufferLength);
	}

	_Ret_z_ operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init(
		_In_z_ LPCWSTR psz, 
		_In_ UINT nConvertCodePage) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthW = lstrlenW( psz )+1;		 
		int nLengthA = nLengthW*4;
		
		AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);

		BOOL bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));
		if (bFailed)
		{
			if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
			{
				nLengthA = ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, NULL, 0, NULL, NULL );
				AtlConvAllocMemory(&m_psz,nLengthA,m_szBuffer,t_nBufferLength);
				bFailed=(0 == ::WideCharToMultiByte( nConvertCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL ));
			}			
		}
		if (bFailed)
		{
			AtlThrowLastWin32();
		}
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CW2AEX(_In_ const CW2AEX&) throw();
	CW2AEX& operator=(_In_ const CW2AEX&) throw();
};
typedef CW2AEX<> CW2A;

#ifdef _UNICODE

#define CW2T CW2W
#define CW2TEX CW2WEX
#define CW2CT CW2CW
#define CW2CTEX CW2CWEX
#define CT2W CW2W
#define CT2WEX CW2WEX
#define CT2CW CW2CW
#define CT2CWEX CW2CWEX

#define CA2T CA2W
#define CA2TEX CA2WEX
#define CA2CT CA2W
#define CA2CTEX CA2WEX
#define CT2A CW2A
#define CT2AEX CW2AEX
#define CT2CA CW2A
#define CT2CAEX CW2AEX

#else  // !_UNICODE

#define CW2T CW2A
#define CW2TEX CW2AEX
#define CW2CT CW2A
#define CW2CTEX CW2AEX
#define CT2W CA2W
#define CT2WEX CA2WEX
#define CT2CW CA2W
#define CT2CWEX CA2WEX

#define CA2T CA2A
#define CA2TEX CA2AEX
#define CA2CT CA2CA
#define CA2CTEX CA2CAEX
#define CT2A CA2A
#define CT2AEX CA2AEX
#define CT2CA CA2CA
#define CT2CAEX CA2CAEX

#endif  // !_UNICODE

#define COLE2T CW2T
#define COLE2TEX CW2TEX
#define COLE2CT CW2CT
#define COLE2CTEX CW2CTEX
#define CT2OLE CT2W
#define CT2OLEEX CT2WEX
#define CT2COLE CT2CW
#define CT2COLEEX CT2CWEX

};  // namespace ATL
#pragma pack(pop)

#pragma pack(push,8)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
	#define USES_CONVERSION int _convert; (_convert); UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; (_acp); LPCWSTR _lpw; (_lpw); LPCSTR _lpa; (_lpa)
#else
	#define USES_CONVERSION int _convert = 0; (_convert); UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; (_acp); LPCWSTR _lpw = NULL; (_lpw); LPCSTR _lpa = NULL; (_lpa)
#endif

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#ifndef _DEBUG
	#define USES_CONVERSION_EX int _convert_ex; (_convert_ex); UINT _acp_ex = ATL::_AtlGetConversionACP(); (_acp_ex); LPCWSTR _lpw_ex; (_lpw_ex); LPCSTR _lpa_ex; (_lpa_ex); USES_ATL_SAFE_ALLOCA
#else
	#define USES_CONVERSION_EX int _convert_ex = 0; (_convert_ex); UINT _acp_ex = ATL::_AtlGetConversionACP(); (_acp_ex); LPCWSTR _lpw_ex = NULL; (_lpw_ex); LPCSTR _lpa_ex = NULL; (_lpa_ex); USES_ATL_SAFE_ALLOCA
#endif

#ifdef _WINGDI_
	ATLAPI_(LPDEVMODEA) AtlDevModeW2A(_Inout_opt_ LPDEVMODEA lpDevModeA, _In_ const DEVMODEW* lpDevModeW);
#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
_Ret_opt_z_cap_(nChars) inline LPWSTR WINAPI AtlA2WHelper(
	_Out_opt_z_cap_(nChars) LPWSTR lpw, 
	_In_opt_z_ LPCSTR lpa, 
	_In_ int nChars, 
	_In_ UINT acp) throw()
{	
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	if (lpw == NULL || lpa == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	*lpw = '\0';
	int ret = MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	if(ret == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}		
	return lpw;
}

_Ret_opt_z_cap_(nChars) inline LPSTR WINAPI AtlW2AHelper(
	_Out_opt_z_cap_(nChars) LPSTR lpa, 
	_In_opt_z_ LPCWSTR lpw, 
	_In_ int nChars, 
	_In_ UINT acp) throw()
{
	ATLASSERT(lpw != NULL);
	ATLASSERT(lpa != NULL);
	if (lpa == NULL || lpw == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	*lpa = '\0';
	int ret = WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	if(ret == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
	return lpa;
}
_Ret_opt_z_cap_(nChars) inline LPWSTR WINAPI AtlA2WHelper(
	_Out_opt_z_cap_(nChars) LPWSTR lpw, 
	_In_opt_z_ LPCSTR lpa, 
	_In_ int nChars) throw()
{
	return AtlA2WHelper(lpw, lpa, nChars, CP_ACP);
}

_Ret_opt_z_cap_(nChars) inline LPSTR WINAPI AtlW2AHelper(
	_Out_opt_z_cap_(nChars) LPSTR lpa, 
	_In_opt_z_ LPCWSTR lpw, 
	_In_ int nChars) throw()
{
	return AtlW2AHelper(lpa, lpw, nChars, CP_ACP);
}

#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
	#ifdef ATLA2WHELPER
		#undef ATLA2WHELPER
		#undef ATLW2AHELPER
	#endif
	#define ATLA2WHELPER AtlA2WHelper
	#define ATLW2AHELPER AtlW2AHelper
#else
	#ifndef ATLA2WHELPER
		#define ATLA2WHELPER AtlA2WHelper
		#define ATLW2AHELPER AtlW2AHelper
	#endif
#endif

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2W(lpa) (\
	((_lpa = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpa)+1),\
		(INT_MAX/2<_convert)? NULL :  \
		ATLA2WHELPER((LPWSTR) alloca(_convert*sizeof(WCHAR)), _lpa, _convert, _acp)))

#define W2A(lpw) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		(_convert = (lstrlenW(_lpw)+1), \
		(_convert>INT_MAX/2) ? NULL : \
		ATLW2AHELPER((LPSTR) alloca(_convert*sizeof(WCHAR)), _lpw, _convert*sizeof(WCHAR), _acp))))

#define A2W_CP(lpa, cp) (\
	((_lpa = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpa)+1),\
		(INT_MAX/2<_convert)? NULL : \
		ATLA2WHELPER((LPWSTR) alloca(_convert*sizeof(WCHAR)), _lpa, _convert, (cp))))

#define W2A_CP(lpw, cp) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		(_convert = (lstrlenW(_lpw)+1), \
		(_convert>INT_MAX/2) ? NULL : \
		ATLW2AHELPER((LPSTR) alloca(_convert*sizeof(WCHAR)), _lpw, _convert*sizeof(WCHAR), (cp)))))

#endif

// The call to _alloca will not cause stack overflow if _AtlVerifyStackAvailable returns TRUE.
// Notice that nChars is never used in these conversion functions. We cannot change the behavior of
// these functions to actually use nChars because we could potentially break a lot of legacy code.
#define A2W_EX(lpa, nChars) (\
	((_lpa_ex = lpa) == NULL) ? NULL : (\
		_convert_ex = (lstrlenA(_lpa_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLA2WHELPER(	\
			(LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpa_ex, \
			_convert_ex / sizeof(WCHAR), \
			_acp_ex)))

#define A2W_EX_DEF(lpa) A2W_EX(lpa, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)

#define W2A_EX(lpw, nChars) (\
	((_lpw_ex = lpw) == NULL) ? NULL : (\
		_convert_ex = (lstrlenW(_lpw_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLW2AHELPER(	\
			(LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpw_ex, \
			_convert_ex, \
			_acp_ex)))

#define W2A_EX_DEF(lpa) W2A_EX(lpa, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)

#define A2W_CP_EX(lpa, nChars, cp) (\
	((_lpa_ex = lpa) == NULL) ? NULL : (\
		_convert_ex = (lstrlenA(_lpa_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLA2WHELPER(	\
			(LPWSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpa_ex, \
			_convert_ex / sizeof(WCHAR), \
			(cp))))

#define W2A_CP_EX(lpw, nChars, cp) (\
	((_lpw_ex = lpw) == NULL) ? NULL : (\
		_convert_ex = (lstrlenW(_lpw_ex)+1),\
		FAILED(::ATL::AtlMultiply(&_convert_ex, _convert_ex, static_cast<int>(sizeof(WCHAR)))) ? NULL : \
		ATLW2AHELPER(	\
			(LPSTR)_ATL_SAFE_ALLOCA(_convert_ex, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), \
			_lpw_ex, \
			_convert_ex, \
			(cp))))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#define A2CW_CP(lpa, cp) ((LPCWSTR)A2W_CP(lpa, (cp)))
#define W2CA_CP(lpw, cp) ((LPCSTR)W2A_CP(lpw, (cp)))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#define A2CW_EX(lpa, nChar) ((LPCWSTR)A2W_EX(lpa, nChar))
#define A2CW_EX_DEF(lpa) ((LPCWSTR)A2W_EX_DEF(lpa))
#define W2CA_EX(lpw, nChar) ((LPCSTR)W2A_EX(lpw, nChar))
#define W2CA_EX_DEF(lpw) ((LPCSTR)W2A_EX_DEF(lpw))

#define A2CW_CP_EX(lpa, nChar, cp) ((LPCWSTR)A2W_CP_EX(lpa, nChar, (cp)))
#define W2CA_CP_EX(lpw, nChar, cp) ((LPCSTR)W2A_CP_EX(lpw, nChar, (cp)))

inline int ocslen(_In_z_ LPCOLESTR x) throw() 
{ 
	return lstrlenW(x); 
}

inline bool ocscpy_s(
	_Out_z_cap_(maxSize) LPOLESTR dest, 
	_In_ size_t maxSize, 
	_In_z_ LPCOLESTR src) throw() 
{ 
	return 0 == memcpy_s(dest, maxSize*sizeof(WCHAR), src, (ocslen(src)+1)*sizeof(WCHAR)); 
}

inline bool ocscat_s(
	_Inout_z_cap_(maxSize) LPOLESTR dest, 
	_In_ size_t maxSize, 
	_In_z_ LPCOLESTR src) throw() 
{ 
	return 0 == wcscat_s(dest, maxSize,src); 
}

#if defined(_UNICODE)

// in these cases the default (TCHAR) is the same as OLECHAR

_ATL_INSECURE_DEPRECATE("ocscpy is not safe. Intead, use ocscpy_s")
inline OLECHAR* ocscpy(
	_Inout_ _Post_z_ LPOLESTR dest, 
	_In_z_ LPCOLESTR src) throw()
{
#pragma warning(push)
#pragma warning(disable:4996)
	return wcscpy(dest, src);
#pragma warning(pop)
}

_ATL_INSECURE_DEPRECATE("ocscat is not safe. Intead, use ocscat_s")
inline OLECHAR* ocscat(
	_Inout_ _Post_z_ LPOLESTR dest, 
	_In_z_ LPCOLESTR src) throw()
{
#pragma warning(push)
#pragma warning(disable:4996)
	return wcscat(dest, src);
#pragma warning(pop)
}

_Ret_z_ inline LPCOLESTR T2COLE_EX(
	_In_z_ LPCTSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCOLESTR T2COLE_EX_DEF(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR OLE2CT_EX(
	_In_z_ LPCOLESTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR OLE2CT_EX_DEF(_In_z_ LPCOLESTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPOLESTR T2OLE_EX(
	_In_z_ LPTSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPOLESTR T2OLE_EX_DEF(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR OLE2T_EX(
	_In_z_ LPOLESTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}	
_Ret_z_ inline LPTSTR OLE2T_EX_DEF(_In_z_ LPOLESTR lp) 
{ 
	return lp; 
}	

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

_Ret_z_ inline LPCOLESTR T2COLE(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR OLE2CT(_In_z_ LPCOLESTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPOLESTR T2OLE(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR OLE2T(_In_z_ LPOLESTR lp) 
{ 
	return lp; 
}

#endif	 // _ATL_EX_CONVERSION_MACROS_ONLY

#else // !defined(_UNICODE)

_ATL_INSECURE_DEPRECATE("ocscpy is not safe. Intead, use ocscpy_s")
inline OLECHAR* ocscpy(
	_Inout_ _Post_z_ LPOLESTR dest, 
	_In_z_ LPCOLESTR src) throw()
{
#pragma warning(push)
#pragma warning(disable:4996)
	return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));
#pragma warning(pop)
}

_ATL_INSECURE_DEPRECATE("ocscat is not safe. Intead, use ocscat_s")
inline OLECHAR* ocscat(
	_Inout_ _Post_z_ LPOLESTR dest, 
	_In_z_ LPCOLESTR src) throw()
{
#pragma warning(push)
#pragma warning(disable:4996)
	return ocscpy(dest+ocslen(dest), src);
#pragma warning(pop)
}

#define T2COLE_EX(lpa, nChar) A2CW_EX(lpa, nChar)
#define T2COLE_EX_DEF(lpa) A2CW_EX_DEF(lpa)
#define T2OLE_EX(lpa, nChar) A2W_EX(lpa, nChar)
#define T2OLE_EX_DEF(lpa) A2W_EX_DEF(lpa)
#define OLE2CT_EX(lpo, nChar) W2CA_EX(lpo, nChar)
#define OLE2CT_EX_DEF(lpo) W2CA_EX_DEF(lpo)
#define OLE2T_EX(lpo, nChar) W2A_EX(lpo, nChar)
#define OLE2T_EX_DEF(lpo) W2A_EX_DEF(lpo)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define T2COLE(lpa) A2CW(lpa)
#define T2OLE(lpa) A2W(lpa)
#define OLE2CT(lpo) W2CA(lpo)
#define OLE2T(lpo) W2A(lpo)

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // defined(_UNICODE)

_Ret_z_ inline LPOLESTR W2OLE_EX(
	_In_z_ LPWSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPOLESTR W2OLE_EX_DEF(_In_z_ LPWSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPWSTR OLE2W_EX(
	_In_z_ LPOLESTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPWSTR OLE2W_EX_DEF(_In_z_ LPOLESTR lp) 
{ 
	return lp; 
}

#define A2OLE_EX A2W_EX
#define A2OLE_EX_DEF A2W_EX_DEF
#define OLE2A_EX W2A_EX
#define OLE2A_EX_DEF W2A_EX_DEF

_Ret_z_ inline LPCOLESTR W2COLE_EX(
	_In_z_ LPCWSTR lp,
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCOLESTR W2COLE_EX_DEF(_In_z_ LPCWSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCWSTR OLE2CW_EX(
	_In_z_ LPCOLESTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCWSTR OLE2CW_EX_DEF(_In_z_ LPCOLESTR lp) 
{ 
	return lp; 
}

#define A2COLE_EX A2CW_EX
#define A2COLE_EX_DEF A2CW_EX_DEF
#define OLE2CA_EX W2CA_EX
#define OLE2CA_EX_DEF W2CA_EX_DEF

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

_Ret_z_ inline LPOLESTR W2OLE(_In_z_ LPWSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPWSTR OLE2W(_In_z_ LPOLESTR lp) 
{ 
	return lp; 
}

#define A2OLE A2W
#define OLE2A W2A

_Ret_z_ inline LPCOLESTR W2COLE(_In_z_ LPCWSTR lp) 
{
	return lp; 
}
_Ret_z_ inline LPCWSTR OLE2CW(_In_z_ LPCOLESTR lp) 
{ 
	return lp; 
}

#define A2COLE A2CW
#define OLE2CA W2CA

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#if defined(_UNICODE)

#define T2A_EX W2A_EX
#define T2A_EX_DEF W2A_EX_DEF
#define A2T_EX A2W_EX
#define A2T_EX_DEF A2W_EX_DEF

_Ret_z_ inline LPWSTR T2W_EX(
	_In_z_ LPTSTR lp,
	_In_ UINT) 
{	
	return lp; 
}
_Ret_z_ inline LPWSTR T2W_EX_DEF(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR W2T_EX(
	_In_z_ LPWSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR W2T_DEF(_In_z_ LPWSTR lp) 
{ 
	return lp; 
}

#define T2CA_EX W2CA_EX
#define T2CA_EX_DEF W2CA_EX_DEF
#define A2CT_EX A2CW_EX
#define A2CT_EX_DEF A2CW_EX_DEF

_Ret_z_ inline LPCWSTR T2CW_EX(
	_In_z_ LPCTSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCWSTR T2CW_EX_DEF(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR W2CT_EX(
	_In_z_ LPCWSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR W2CT_EX_DEF(_In_z_ LPCWSTR lp) 
{ 
	return lp; 
}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define T2A W2A
#define A2T A2W

_Ret_z_ inline LPWSTR T2W(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR W2T(_In_z_ LPWSTR lp) 
{ 
	return lp; 
}

#define T2CA W2CA
#define A2CT A2CW

_Ret_z_ inline LPCWSTR T2CW(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR W2CT(_In_z_ LPCWSTR lp) 
{ 
	return lp; 
}

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY
	
#else // !defined(_UNICODE)

#define T2W_EX A2W_EX
#define T2W_EX_DEF A2W_EX_DEF
#define W2T_EX W2A_EX
#define W2T_EX_DEF W2A_EX_DEF

_Ret_z_ inline LPSTR T2A_EX(
	_In_z_ LPTSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPSTR T2A_EX_DEF(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR A2T_EX(
	_In_z_ LPSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR A2T_EX_DEF(_In_z_ LPSTR lp) 
{ 
	return lp; 
}

#define T2CW_EX A2CW_EX
#define T2CW_EX_DEF A2CW_EX_DEF
#define W2CT_EX W2CA_EX
#define W2CT_EX_DEF W2CA_EX_DEF

_Ret_z_ inline LPCSTR T2CA_EX(
	_In_z_ LPCTSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCSTR T2CA_EX_DEF(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR A2CT_EX(
	_In_z_ LPCSTR lp, 
	_In_ UINT) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR A2CT_EX_DEF(_In_z_ LPCSTR lp) 
{ 
	return lp; 
}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define T2W A2W
#define W2T W2A
_Ret_z_ inline LPSTR T2A(_In_z_ LPTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPTSTR A2T(_In_z_ LPSTR lp) 
{ 
	return lp; 
}
#define T2CW A2CW
#define W2CT W2CA
_Ret_z_ inline LPCSTR T2CA(_In_z_ LPCTSTR lp) 
{ 
	return lp; 
}
_Ret_z_ inline LPCTSTR A2CT(_In_z_ LPCSTR lp) 
{ 
	return lp; 
}

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // defined(_UNICODE)

_Check_return_ _Ret_opt_z_ inline BSTR A2WBSTR(
	_In_opt_z_ LPCSTR lp, 
	_In_ int nLen = -1)
{
	if (lp == NULL || nLen == 0)
		return NULL;
	USES_CONVERSION_EX;
	BSTR str = NULL;

ATLPREFAST_SUPPRESS(6385)
	int nConvertedLen = MultiByteToWideChar(_acp_ex, 0, lp, nLen, NULL, 0);
ATLPREFAST_UNSUPPRESS()
	int nAllocLen = nConvertedLen;
	if (nLen == -1)
		nAllocLen -= 1;  // Don't allocate terminating '\0'
	str = ::SysAllocStringLen(NULL, nAllocLen);

	if (str != NULL)
	{
		int nResult;
		nResult = MultiByteToWideChar(_acp_ex, 0, lp, nLen, str, nConvertedLen);
		ATLASSERT(nResult == nConvertedLen);
		if(nResult != nConvertedLen)
		{
			SysFreeString(str);
			return NULL;
		}

	}
	return str;
}

_Ret_opt_z_ inline BSTR OLE2BSTR(_In_opt_z_ LPCOLESTR lp) 
{
	return ::SysAllocString(lp);
}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
_Ret_opt_z_ inline BSTR T2BSTR_EX(_In_opt_z_ LPCTSTR lp) 
{
	return ::SysAllocString(lp);
}
_Ret_opt_z_ inline BSTR A2BSTR_EX(_In_opt_z_ LPCSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR W2BSTR_EX(_In_opt_z_ LPCWSTR lp) 
{
	return ::SysAllocString(lp);
}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

_Ret_opt_z_ inline BSTR T2BSTR(_In_opt_z_ LPCTSTR lp) 
{
	return ::SysAllocString(lp);
}
_Ret_opt_z_ inline BSTR A2BSTR(_In_opt_z_ LPCSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR W2BSTR(_In_opt_z_ LPCWSTR lp) 
{
	return ::SysAllocString(lp);
}
	
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#else // !defined(_UNICODE)
_Ret_opt_z_ inline BSTR T2BSTR_EX(_In_opt_z_ LPCTSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR A2BSTR_EX(_In_opt_z_ LPCSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR W2BSTR_EX(_In_opt_z_ LPCWSTR lp) 
{
	return ::SysAllocString(lp);
}
	
#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

_Ret_opt_z_ inline BSTR T2BSTR(_In_opt_z_ LPCTSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR A2BSTR(_In_opt_z_ LPCSTR lp) 
{
	return A2WBSTR(lp);
}
_Ret_opt_z_ inline BSTR W2BSTR(_In_opt_z_ LPCWSTR lp) 
{
	return ::SysAllocString(lp);
}

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#endif // defined(_UNICODE)

#ifdef _WINGDI_
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPDEVMODEW AtlDevModeA2W(
	_Inout_ LPDEVMODEW lpDevModeW, 
	_In_ const DEVMODEA* lpDevModeA)
{
	USES_CONVERSION_EX;
	ATLASSERT(lpDevModeW != NULL);
	if (lpDevModeA == NULL || lpDevModeW == NULL)
	{
		return NULL;
	}

	AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32, _acp_ex);

	if(0 != memcpy_s(&lpDevModeW->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion),
		&lpDevModeA->dmSpecVersion, offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion)))
	{
		return NULL;
	}

	AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32, _acp_ex);

	if(0 != memcpy_s(&lpDevModeW->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels),
		&lpDevModeA->dmLogPixels, sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels)))
	{
		return NULL;
	}

	if (lpDevModeA->dmDriverExtra != 0)
	{
		// lpDevModeW holds more info
#pragma warning(push)
#pragma warning(disable:26000)
		if(0 != memcpy_s(lpDevModeW+1, lpDevModeA->dmDriverExtra, lpDevModeA+1, lpDevModeA->dmDriverExtra))
		{
			return NULL;
		}
#pragma warning(pop)
	}
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(
	_Out_ LPTEXTMETRICW lptmW, 
	_In_ LPTEXTMETRICA lptmA)
{
	USES_CONVERSION_EX;
	ATLASSERT(lptmW != NULL);
	if (lptmA == NULL || lptmW == NULL)
		return NULL;

	if(0 != memcpy_s(lptmW, sizeof(LONG) * 11, lptmA, sizeof(LONG) * 11))
	{
		return NULL;
	}

	if(0 != memcpy_s(&lptmW->tmItalic, sizeof(BYTE) * 5, &lptmA->tmItalic, sizeof(BYTE) * 5))
	{
		return NULL;
	}

	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1)== 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
		
	if(MultiByteToWideChar(_acp_ex, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}
	
	return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(
	_Out_ LPTEXTMETRICA lptmA, 
	_In_ LPTEXTMETRICW lptmW)
{
	USES_CONVERSION_EX;
	ATLASSERT(lptmA != NULL);
	if (lptmW == NULL || lptmA == NULL)
	{
		return NULL;
	}

	if(0 != memcpy_s(lptmA, sizeof(LONG) * 11, lptmW, sizeof(LONG) * 11))
	{
		return NULL;
	}

	if(0 != memcpy_s(&lptmA->tmItalic, sizeof(BYTE) * 5, &lptmW->tmItalic, sizeof(BYTE) * 5))
	{
		return NULL;
	}
	
	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	if(WideCharToMultiByte(_acp_ex, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL) == 0)
	{
		ATLASSERT(FALSE);
		return NULL;
	}

	return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

// Requires USES_CONVERSION_EX or USES_ATL_SAFE_ALLOCA macro before using the _EX versions of the macros
#define DEVMODEW2A_EX(lpw)\
	(((lpw) == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)_ATL_SAFE_ALLOCA(sizeof(DEVMODEA)+(lpw)->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lpw)))
#define DEVMODEA2W_EX(lpa)\
	(((lpa) == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)_ATL_SAFE_ALLOCA(sizeof(DEVMODEW)+(lpa)->dmDriverExtra, _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lpa)))
#define TEXTMETRICW2A_EX(lptmw)\
	(((lptmw) == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICA), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lptmw)))
#define TEXTMETRICA2W_EX(lptma)\
	(((lptma) == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)_ATL_SAFE_ALLOCA(sizeof(TEXTMETRICW), _ATL_SAFE_ALLOCA_DEF_THRESHOLD), (lptma)))

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEW2A(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEOLE DEVMODEW
#define LPDEVMODEOLE LPDEVMODEW
#define TEXTMETRICOLE TEXTMETRICW
#define LPTEXTMETRICOLE LPTEXTMETRICW

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
inline LPDEVMODEW DEVMODEOLE2T_EX(_In_opt_ LPDEVMODEOLE lp) 
{ 
	return lp; 
}
inline LPDEVMODEOLE DEVMODET2OLE_EX(_In_opt_ LPDEVMODEW lp) 
{ 
	return lp; 
}
inline LPTEXTMETRICW TEXTMETRICOLE2T_EX(_In_ LPTEXTMETRICOLE lp) 
{ 
	return lp; 
}
inline LPTEXTMETRICOLE TEXTMETRICT2OLE_EX(_In_ LPTEXTMETRICW lp) 
{ 
	return lp; 
}

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY
inline LPDEVMODEW DEVMODEOLE2T(_In_ LPDEVMODEOLE lp) 
{ 
	return lp; 
}
inline LPDEVMODEOLE DEVMODET2OLE(_In_ LPDEVMODEW lp) 
{ 
	return lp; 
}
inline LPTEXTMETRICW TEXTMETRICOLE2T(_In_ LPTEXTMETRICOLE lp) 
{ 
	return lp; 
}
inline LPTEXTMETRICOLE TEXTMETRICT2OLE(_In_ LPTEXTMETRICW lp) 
{ 
	return lp; 
}
#endif	// _ATL_EX_CONVERSION_MACROS_ONLY
	
#else // !defined(_UNICODE)

#define DEVMODEOLE2T_EX(lpo) DEVMODEW2A_EX(lpo)
#define DEVMODET2OLE_EX(lpa) DEVMODEA2W_EX(lpa)
#define TEXTMETRICOLE2T_EX(lptmw) TEXTMETRICW2A_EX(lptmw)
#define TEXTMETRICT2OLE_EX(lptma) TEXTMETRICA2W_EX(lptma)

#ifndef _ATL_EX_CONVERSION_MACROS_ONLY

#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)

#endif	// _ATL_EX_CONVERSION_MACROS_ONLY	

#endif // defined(_UNICODE)

#endif //_WINGDI_

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////

#ifndef _ATL_DLL

#ifdef _WINGDI_

ATLINLINE ATLAPI_(LPDEVMODEA) AtlDevModeW2A(
	_Inout_opt_ LPDEVMODEA lpDevModeA, 
	_In_ const DEVMODEW* lpDevModeW)
{
	USES_CONVERSION_EX;
	ATLASSERT(lpDevModeA != NULL);
	if (lpDevModeW == NULL || lpDevModeA == NULL)
		return NULL;

	AtlW2AHelper((LPSTR)lpDevModeA->dmDeviceName, lpDevModeW->dmDeviceName, 32, _acp_ex);

	if(0 != memcpy_s(&lpDevModeA->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion), 
		&lpDevModeW->dmSpecVersion, offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion)))
	{
		return NULL;
	}

	AtlW2AHelper((LPSTR)lpDevModeA->dmFormName, lpDevModeW->dmFormName, 32, _acp_ex);

	if(0 != memcpy_s(&lpDevModeA->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels),
		&lpDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels)))
	{
		return NULL;
	}

	if (lpDevModeW->dmDriverExtra != 0)
	{
		// lpDevModeW holds more info
#pragma warning(push)
#pragma warning(disable:26000)
		if(0 != memcpy_s(lpDevModeA+1, lpDevModeW->dmDriverExtra, lpDevModeW+1, lpDevModeW->dmDriverExtra))
		{
			return NULL;
		}
#pragma warning(pop)
	}
	
	lpDevModeA->dmSize = sizeof(DEVMODEA);
	return lpDevModeA;
}

#endif //_WINGDI

#endif // !_ATL_DLL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // __ATLCONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702)  // unreachable code
#pragma warning(disable: 4512)  // assignment operator could not be generated
#pragma warning(disable: 4127)  // conditional expression constant
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>

#include <objsafe.h>
#include <urlmon.h>

#ifndef _ATL_NO_DEFAULT_LIBS
#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")
#endif  // !_ATL_NO_DEFAULT_LIBS

#pragma pack(push, _ATL_PACKING)

#define DECLARE_VIEW_STATUS(statusFlags) \
	DWORD _GetViewStatus() \
	{ \
		return statusFlags; \
	}

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#include "atliface.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

#define REFLECTOR_MAP_ID 69

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

namespace ATL
{

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T, class WinBase> class CComControl;

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent


// Helper functions for safely communicating with objects who sink IPropertyNotifySink
class CFirePropNotifyEvent
{
public:
	// Ask any objects sinking the IPropertyNotifySink notification if it is ok to edit a specified property
	static HRESULT FireOnRequestEdit(
		_Inout_ IUnknown* pUnk, 
		_In_ DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &__uuidof(IConnectionPointContainer)> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				HRESULT hr = S_OK;
				CComQIPtr<IPropertyNotifySink, &__uuidof(IPropertyNotifySink)> pSink(cd.pUnk);
#ifdef _DEBUG
				if (pSink == NULL)
				{
					ATLTRACE(atlTraceControls,2,_T("QI for IPropertyNotifySink failed in CFirePropNotifyEvent::FireOnRequestEdit\n"));
				}
#endif
				if (pSink != NULL)
					hr = pSink->OnRequestEdit(dispID);

				cd.pUnk->Release();
				if (hr == S_FALSE)
					return S_FALSE;
			}
		}
		return S_OK;
	}
	// Notify any objects sinking the IPropertyNotifySink notification that a property has changed
	static HRESULT FireOnChanged(
		_Inout_ IUnknown* pUnk, 
		_In_ DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &__uuidof(IConnectionPointContainer)> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				CComQIPtr<IPropertyNotifySink, &__uuidof(IPropertyNotifySink)> pSink(cd.pUnk);
#ifdef _DEBUG
				if (pSink == NULL)
				{
					ATLTRACE(atlTraceControls,2,_T("QI for IPropertyNotifySink failed in CFirePropNotifyEvent::FireOnChanged\n"));
				}
#endif
				if (pSink != NULL)
					pSink->OnChanged(dispID);
				cd.pUnk->Release();
			}
		}
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComControlBase

// Holds the essential data members for an ActiveX control and useful helper functions
class ATL_NO_VTABLE CComControlBase
{
public:
	typedef short AppearanceType;  // Override in derived class if your 
		// m_nAppearance stock property isn't of type 'short'
public:
	CComControlBase(_Inout_ HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	virtual ~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE(atlTraceControls,2,_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here non-virtuals only please

	// Mark the control 'dirty' so the container will save it
	void SetDirty(_In_ BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	// Obtain the dirty state for the control 
	BOOL GetDirty()
	{
		return m_bRequiresSave;
	}
	// Get the zoom factor (numerator & denominator) which is factor of the natural extent
	void GetZoomInfo(_Inout_ ATL_DRAWINFO& di);
	// Sends a notification that the moniker for the control has changed
	HRESULT SendOnRename(_Inout_ IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	// Sends a notification that the control has just saved its data
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	// Sends a notification that the control has closed its advisory sinks
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	// Sends a notification that the control's data has changed
	HRESULT SendOnDataChange(_In_ DWORD advf = 0);
	// Sends a notification that the control's representation has changed
	HRESULT SendOnViewChange(_In_ DWORD dwAspect, _In_ LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	// Sends a notification to the container that the control has received focus
	LRESULT OnSetFocus(
		_In_ UINT /*uMsg*/, 
		_In_ WPARAM /*wParam*/, 
		_In_ LPARAM /*lParam*/, 
		_Out_ BOOL& bHandled)
	{
		if (m_bInPlaceActive)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
			CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);
			if (m_bInPlaceActive && spSite != NULL)
				spSite->OnFocus(TRUE);
		}
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnKillFocus(
		_In_ UINT /*uMsg*/, 
		_In_ WPARAM /*wParam*/, 
		_In_ LPARAM /*lParam*/, 
		_Out_ BOOL& bHandled)
	{
		CComQIPtr<IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
			spSite->OnFocus(FALSE);
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnMouseActivate(
		_In_ UINT /*uMsg*/, 
		_In_ WPARAM /*wParam*/, 
		_In_ LPARAM /*lParam*/, 
		_Out_ BOOL& bHandled)
	{
		BOOL bUserMode = TRUE;
		HRESULT hRet = GetAmbientUserMode(bUserMode);
		// UI activate if in user mode only
		// allow activation if we can't determine mode
		if (FAILED(hRet) || bUserMode)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(__uuidof(IOleObject), (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
		}
		bHandled = FALSE;
		return 1;
	}
	BOOL PreTranslateAccelerator(
		_In_opt_ LPMSG /*pMsg*/, 
		_In_ HRESULT& /*hRet*/)
	{
		return FALSE;
	}

	HRESULT GetAmbientProperty(
		_In_ DISPID dispid, 
		_Out_ VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(_Out_ short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		ATLASSERT(var.vt == VT_I2 || var.vt == VT_UI2 || var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		if (SUCCEEDED(hRes))
		{
			if (var.vt == VT_EMPTY)
				hRes = E_FAIL;
			else
			{
				nAppearance = var.iVal;
			}
		}
		return hRes;
	}
	HRESULT GetAmbientBackColor(_Out_ OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(_Inout_ _Deref_post_opt_z_ BSTR& bstrDisplayName)
	{
		CComVariant var;		

		if (bstrDisplayName)
		{
			SysFreeString(bstrDisplayName);
			bstrDisplayName = NULL;
		}

		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrDisplayName = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetAmbientFont(_Deref_out_ IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(__uuidof(IFont), (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
ATLPREFAST_SUPPRESS(6387)
	HRESULT GetAmbientFontDisp(_Deref_out_ IFontDisp** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(__uuidof(IFontDisp), (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	HRESULT GetAmbientForeColor(_Out_ OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(_Out_ LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		ATLASSERT((var.vt == VT_UI4 || var.vt == VT_I4) || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(_Inout_ _Deref_post_opt_z_ BSTR& bstrScaleUnits)
	{
		CComVariant var;		

		if (bstrScaleUnits)
		{
			SysFreeString(bstrScaleUnits);
			bstrScaleUnits = NULL;
		}

		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrScaleUnits = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}
	HRESULT GetAmbientTextAlign(_Out_ short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		ATLASSERT(var.vt == VT_I2 || FAILED(hRes));
		if (SUCCEEDED(hRes))
		{
			if (var.vt == VT_EMPTY)
				hRes = E_FAIL;
			else
				nTextAlign = var.iVal;
		}
		return hRes;
	}
	HRESULT GetAmbientUserMode(_Out_ BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bUserMode = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientUIDead(_Out_ BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bUIDead = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(_Out_ BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bShowGrabHandles = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientShowHatching(_Out_ BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bShowHatching = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(_Out_ BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bMessageReflect = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientAutoClip(_Out_ BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bAutoClip = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(_Out_ BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bDisplaysDefault = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(_Out_ BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bSupportMnemonics = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}
	HRESULT GetAmbientPalette(_Out_ HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
#ifdef _WIN64
		ATLASSERT(var.vt == VT_I8 || var.vt == VT_UI8 || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(static_cast<LONG_PTR>(var.llVal));
#else
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(static_cast<LONG_PTR>(var.lVal));
#endif
		return hRes;
	}

	HRESULT GetAmbientCodePage(_Out_ ULONG& ulCodePage)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_CODEPAGE, var);
		ATLASSERT(var.vt == VT_UI4 || FAILED(hRes));
		ulCodePage = var.ulVal;
		return hRes;
	}

	HRESULT GetAmbientCharSet(_Inout_ _Deref_post_opt_z_ BSTR& bstrCharSet)
	{
		CComVariant var;

		if (bstrCharSet)
		{
			SysFreeString(bstrCharSet);
			bstrCharSet = NULL;
		}

		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_CHARSET, var);
		ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrCharSet = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}

	HRESULT GetAmbientRightToLeft(_Out_ BOOL& bRightToLeft)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_RIGHTTOLEFT, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bRightToLeft = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}

	HRESULT GetAmbientTopToBottom(_Out_ BOOL& bTopToBottom)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TOPTOBOTTOM, var);
		if(SUCCEEDED(hRes))
		{
			ATLASSERT(var.vt == VT_BOOL);
			if(var.vt != VT_BOOL)
				return DISP_E_TYPEMISMATCH;
			bTopToBottom = (var.boolVal != ATL_VARIANT_FALSE) ? TRUE : FALSE;
		}
		return hRes;
	}

ATLPREFAST_SUPPRESS(6387)
	HRESULT InternalGetSite(
		_In_ REFIID riid, 
		_Deref_out_ void** ppUnkSite)
	{
		ATLASSERT(ppUnkSite != NULL);
		if (ppUnkSite == NULL)
			return E_POINTER;
		if (m_spClientSite == NULL)
		{
			*ppUnkSite = NULL;
			return E_FAIL;
		}
		return m_spClientSite->QueryInterface(riid, ppUnkSite);
	}
ATLPREFAST_UNSUPPRESS()
	
	BOOL DoesVerbUIActivate(_In_ LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(_In_ LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(_In_ BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(
		_In_ QACONTAINER *pQACont, 
		_Inout_ QACONTROL *pQACtrl);
	HRESULT DoVerbProperties(
		_In_opt_ LPCRECT /* prcPosRect */, 
		_In_ HWND hwndParent);
	HRESULT InPlaceActivate(
		_In_ LONG iVerb, 
		_In_opt_ const RECT* prcPosRect = NULL);

	HRESULT IOleObject_SetClientSite(_Inout_opt_ IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(_Deref_out_opt_ IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(
		_Inout_ IAdviseSink *pAdvSink, 
		_Out_ DWORD *pdwConnection);
	HRESULT IOleObject_Close(_In_ DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(
		_In_ DWORD dwDrawAspect, 
		_In_bytecount_c_(sizeof(SIZE)) SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(
		_In_ LPCRECT prcPos, 
		_In_ LPCRECT prcClip);
	HRESULT IViewObject_Draw(
		_In_ DWORD dwDrawAspect, 
		_In_ LONG lindex, 
		_In_opt_ void *pvAspect,
		_In_opt_ DVTARGETDEVICE *ptd, 
		_In_ HDC hicTargetDev, 
		_In_ HDC hdcDraw,
		_In_opt_ LPCRECTL prcBounds, 
		_In_opt_ LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(
		_In_ FORMATETC *pformatetcIn, 
		_Out_ STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(
		_In_ UINT uMsg, 
		_In_ WPARAM wParam,
		_In_ LPARAM lParam, 
		_In_ BOOL& lResult);

	virtual HWND CreateControlWindow(
		_In_ HWND hWndParent, 
		_In_ RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(
		_In_ const IID& iid, 
		_Deref_out_ void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(_Inout_ ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(_In_ ATL_DRAWINFO& di)
	{
		::SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
		LPCTSTR pszText = _T("ATL ") _T(_ATL_VER_RBLD);
		::TextOut(di.hdcDraw, di.prcBounds->left + (di.prcBounds->right - di.prcBounds->left) / 2, di.prcBounds->top + (di.prcBounds->bottom - di.prcBounds->top) / 2, pszText, lstrlen(pszText));

		return S_OK;
	}

// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
#pragma warning(push)
#pragma warning(disable: 4510 4610) // unnamed union
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
#pragma warning(pop)

	int m_nFreezeEvents; // count of freezes versus thaws
	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels

	DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE)
};

inline HRESULT CComControlBase::IQuickActivate_QuickActivate(
	_In_ QACONTAINER *pQACont,
	_Inout_ QACONTROL *pQACtrl)
{
	ATLASSERT(pQACont != NULL);
	ATLASSERT(pQACtrl != NULL);
	if (!pQACont || !pQACtrl)
		return E_POINTER;

	HRESULT hRes;
	ULONG uCB = pQACtrl->cbSize;
	memset(pQACtrl, 0, uCB);
	pQACtrl->cbSize = uCB;

	// get all interfaces we are going to need
	CComPtr<IOleObject> pOO;
	ControlQueryInterface(__uuidof(IOleObject), (void**)&pOO);
	CComPtr<IViewObjectEx> pVOEX;
	ControlQueryInterface(__uuidof(IViewObjectEx), (void**)&pVOEX);
	CComPtr<IPointerInactive> pPI;
	ControlQueryInterface(__uuidof(IPointerInactive), (void**)&pPI);
	CComPtr<IProvideClassInfo2> pPCI;
	ControlQueryInterface(__uuidof(IProvideClassInfo2), (void**)&pPCI);

	if (pOO == NULL || pVOEX == NULL)
		return E_FAIL;

	pOO->SetClientSite(pQACont->pClientSite);

	if (pQACont->pAdviseSink != NULL)
	{
		ATLTRACE(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
	}

	CComPtr<IConnectionPointContainer> pCPC;
	ControlQueryInterface(__uuidof(IConnectionPointContainer), (void**)&pCPC);

	if (pQACont->pPropertyNotifySink)
	{
		ATLTRACE(atlTraceControls,2,_T("Setting up PropNotify CP\n"));
		CComPtr<IConnectionPoint> pCP;
		if (pCPC != NULL)
		{
			hRes = pCPC->FindConnectionPoint(__uuidof(IPropertyNotifySink), &pCP);
			if (SUCCEEDED(hRes))
				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
		}
	}

	if (pPCI)
	{
		GUID iidDefaultSrc;
		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
			&iidDefaultSrc)))
		{
			if (pQACont->pUnkEventSink)
			{
				ATLTRACE(atlTraceControls,2,_T("Setting up Default Out Going Interface\n"));
				CComPtr<IConnectionPoint> pCP;
				if (pCPC != NULL)
				{
					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
					if (SUCCEEDED(hRes))
						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
				}
			}
		}
	}
	// give information to container
	if (pOO != NULL)
		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

	if (pVOEX != NULL)
		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

	if (pPI != NULL)
		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
	return S_OK;
}

inline BOOL CComControlBase::SetControlFocus(_In_ BOOL bGrab)
{
	if (m_bWndLess)
	{
		if (!m_bUIActive && bGrab)
			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
				return FALSE;

		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
	}
	else
	{
		// we've got a window.
		//
		if (m_bInPlaceActive)
		{
			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
			if (!m_bUIActive && bGrab)
				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
			else
			{
				if (!::IsChild(hwnd, ::GetFocus()))
					::SetFocus(hwnd);
				return TRUE;
			}
		}
	}
	return FALSE;
}

inline HRESULT CComControlBase::DoVerbProperties(
	_In_opt_ LPCRECT /* prcPosRect */, 
	_In_ HWND hwndParent)
{
	HRESULT hr = S_OK;
	CComQIPtr <ISpecifyPropertyPages, &__uuidof(ISpecifyPropertyPages)> spPages;
	CComQIPtr <IOleObject, &__uuidof(IOleObject)> spObj;
	CComQIPtr <IOleControlSite, &__uuidof(IOleControlSite)> spSite(m_spClientSite);

	if (spSite)
	{
		hr = spSite->ShowPropertyFrame();
		if (SUCCEEDED(hr))
			return hr;
	}

	CComPtr<IUnknown> pUnk;
	ControlQueryInterface(__uuidof(IUnknown), (void**)&pUnk);
	ATLASSERT(pUnk != NULL);
	CAUUID pages;
	spPages = pUnk;
	if (spPages)
	{
		hr = spPages->GetPages(&pages);
		if (SUCCEEDED(hr))
		{
			spObj = pUnk;
			if (spObj)
			{
				LPOLESTR szTitle = NULL;

				spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

				LCID lcid;
				if (FAILED(GetAmbientLocaleID(lcid)))
					lcid = LOCALE_USER_DEFAULT;

				hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
					1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);

				CoTaskMemFree(szTitle);
			}
			else
			{
				hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
			}
			CoTaskMemFree(pages.pElems);
		}
	}
	else
	{
		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
	}

	return hr;
}

inline HRESULT CComControlBase::InPlaceActivate(
	_In_ LONG iVerb, 
	_In_opt_ const RECT* /*prcPosRect*/)
{	
	HRESULT hr;

	if (m_spClientSite == NULL)
		return S_OK;

	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bNegotiatedWnd)
	{
		if (!m_bWindowOnly)
			// Try for windowless site
			hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteWindowless), (void **)&m_spInPlaceSite);

		if (m_spInPlaceSite)
		{
			m_bInPlaceSiteEx = TRUE;
			// CanWindowlessActivate returns S_OK or S_FALSE
			if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
			{
				m_bWndLess = TRUE;
				m_bWasOnceWindowless = TRUE;
			}
			else
			{
				m_bWndLess = FALSE;
			}
		}
		else
		{
			m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSiteEx), (void **)&m_spInPlaceSite);
			if (m_spInPlaceSite)
				m_bInPlaceSiteEx = TRUE;
			else
				hr = m_spClientSite->QueryInterface(__uuidof(IOleInPlaceSite), (void **)&m_spInPlaceSite);
		}
	}

	ATLASSUME(m_spInPlaceSite);
	if (!m_spInPlaceSite)
		return E_FAIL;

	m_bNegotiatedWnd = TRUE;

	if (!m_bInPlaceActive)
	{

		BOOL bNoRedraw = FALSE;
		if (m_bWndLess)
			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
		else
		{
			if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					return hr;
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   return( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}
		}
	}

	m_bInPlaceActive = TRUE;

	// get location in the parent window,
	// as well as some information about the parent
	//
	OLEINPLACEFRAMEINFO frameInfo;
	RECT rcPos, rcClip;
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	HWND hwndParent;
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

		if (!m_bWndLess)
		{
			if (m_hWndCD)
				ShowWindow(m_hWndCD, SW_SHOW);
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				if(h == NULL)
					return E_FAIL;
			}
		}

		pIPO->SetObjectRects(&rcPos, &rcClip);
	}

	CComPtr<IOleInPlaceActiveObject> spActiveObject;
	ControlQueryInterface(__uuidof(IOleInPlaceActiveObject), (void**)&spActiveObject);

	// Gone active by now, take care of UIACTIVATE
	if (DoesVerbUIActivate(iVerb))
	{
		if (!m_bUIActive)
		{
			m_bUIActive = TRUE;
			hr = m_spInPlaceSite->OnUIActivate();
			if (FAILED(hr))
			{
				m_bUIActive = FALSE;
				return hr;
			}

			SetControlFocus(TRUE);
			// set ourselves up in the host.
			//
			if (spActiveObject)
			{
				if (spInPlaceFrame)
					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
				if (spInPlaceUIWindow)
					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
			}

			if (spInPlaceFrame)
				spInPlaceFrame->SetBorderSpace(NULL);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetBorderSpace(NULL);
		}
	}

	m_spClientSite->ShowObject();

	return S_OK;
}

inline HRESULT CComControlBase::SendOnDataChange(_In_ DWORD advf)
{
	HRESULT hRes = S_OK;
	if (m_spDataAdviseHolder)
	{
		CComPtr<IDataObject> pdo;
		if (SUCCEEDED(ControlQueryInterface(__uuidof(IDataObject), (void**)&pdo)))
			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
	}
	return hRes;
}

inline HRESULT CComControlBase::IOleObject_SetClientSite(_Inout_opt_ IOleClientSite *pClientSite)
{
	ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
	m_spClientSite = pClientSite;
	m_spAmbientDispatch.Release();
	if (m_spClientSite != NULL)
	{
		m_spClientSite->QueryInterface(__uuidof(IDispatch),
			(void**) &m_spAmbientDispatch.p);
	}
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_GetClientSite(_Deref_out_opt_ IOleClientSite **ppClientSite)
{
	ATLASSERT(ppClientSite);
	if (ppClientSite == NULL)
		return E_POINTER;

	*ppClientSite = m_spClientSite;
	if (m_spClientSite != NULL)
		m_spClientSite.p->AddRef();
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_Advise(
	_Inout_ IAdviseSink *pAdvSink,
	_Out_ DWORD *pdwConnection)
{
	HRESULT hr = S_OK;
	if (m_spOleAdviseHolder == NULL)
		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
	if (SUCCEEDED(hr))
		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
	return hr;
}

inline HRESULT CComControlBase::IOleObject_Close(_In_ DWORD dwSaveOption)
{
	if (m_hWndCD)
	{
		if (m_spClientSite)
			m_spClientSite->OnShowWindow(FALSE);
	}

	if (m_bInPlaceActive)
	{
		CComPtr<IOleInPlaceObject> pIPO;
		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
		ATLASSERT(pIPO != NULL);
		HRESULT hr = pIPO->InPlaceDeactivate();
		if (FAILED(hr))
			return hr;
		ATLASSERT(!m_bInPlaceActive);
	}
	if (m_hWndCD)
	{
		ATLTRACE(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	// handle the save flag.
	//
	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
	{
		if (m_spClientSite)
			m_spClientSite->SaveObject();
		SendOnSave();
	}

	m_spInPlaceSite.Release();
	m_bNegotiatedWnd = FALSE;
	m_bWndLess = FALSE;
	m_bInPlaceSiteEx = FALSE;
	m_spAdviseSink.Release();
	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
	if (!m_bInPlaceActive)
		return S_OK;

	if(m_bUIActive) {
		CComPtr<IOleInPlaceObject> pIPO;
		ControlQueryInterface(__uuidof(IOleInPlaceObject), (void**)&pIPO);
		ATLENSURE(pIPO != NULL);
		pIPO->UIDeactivate();
	}

	m_bInPlaceActive = FALSE;

	// if we have a window, tell it to go away.
	//
	if (m_hWndCD)
	{
		ATLTRACE(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	if (m_spInPlaceSite)
		m_spInPlaceSite->OnInPlaceDeactivate();

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
	// if we're not UIActive, not much to do.
	if (!m_bUIActive)
		return S_OK;

	m_bUIActive = FALSE;

	HWND hwndParent; 
	// This call to GetWindow is a fix for Delphi
	if (m_spInPlaceSite)
	{
		if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
		{
			// notify frame windows, if appropriate, that we're no longer ui-active.
			CComPtr<IOleInPlaceFrame> spInPlaceFrame;
			CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
			OLEINPLACEFRAMEINFO frameInfo;
			frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
			RECT rcPos, rcClip;

			m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
				&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetActiveObject(NULL, NULL);
			if (spInPlaceFrame)
				spInPlaceFrame->SetActiveObject(NULL, NULL);
		}
		// we don't need to explicitly release the focus here since somebody
		// else grabbing the focus is what is likely to cause us to get lose it
		m_spInPlaceSite->OnUIDeactivate(FALSE);
	}
	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(
	_In_ LPCRECT prcPos, 
	_In_ LPCRECT prcClip)
{
	if (prcPos == NULL || prcClip == NULL)
		return E_POINTER;

	m_rcPos = *prcPos;
	if (m_hWndCD)
	{
		// the container wants us to clip, so figure out if we really
		// need to
		//
		RECT rcIXect;
		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
		HRGN tempRgn = NULL;
		if (b && !EqualRect(&rcIXect, prcPos))
		{
			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
			tempRgn = CreateRectRgnIndirect(&rcIXect);
		}

		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

		// set our control's location, but don't change it's size at all
		// [people for whom zooming is important should set that up here]
		//
		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
		SetWindowPos(m_hWndCD, NULL, prcPos->left,
					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_SetExtent(
	_In_ DWORD dwDrawAspect, 
	_In_bytecount_c_(sizeof(SIZE)) SIZEL *psizel)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;
	if (psizel == NULL)
		return E_POINTER;

	BOOL bSizeMatchesNatural =
		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

	if (m_bAutoSize) //object can't do any other size
		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

	BOOL bResized = FALSE;
	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
	{
		m_sizeExtent = *psizel;
		bResized = TRUE;
	}
	if (m_bResizeNatural && !bSizeMatchesNatural)
	{
		m_sizeNatural = *psizel;
		bResized = TRUE;
	}

	if (m_bRecomposeOnResize && bResized)
	{
		SendOnDataChange();
		FireViewChange();
	}
	return S_OK;
}

inline HRESULT CComControlBase::IViewObject_Draw(
	_In_ DWORD dwDrawAspect, 
	_In_ LONG lindex,
	_In_opt_ void *pvAspect, 
	_In_opt_ DVTARGETDEVICE *ptd, 
	_In_ HDC hicTargetDev, 
	_In_ HDC hdcDraw,
	_In_opt_ LPCRECTL prcBounds, 
	_In_opt_ LPCRECTL prcWBounds)
{
	ATLTRACE(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
		dwDrawAspect, lindex, reinterpret_cast<int>(ptd), 
			reinterpret_cast<int>(hicTargetDev), reinterpret_cast<int>(hdcDraw));
#ifdef _DEBUG
	if (prcBounds == NULL)
		ATLTRACE(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
	else
		ATLTRACE(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
			prcBounds->top, prcBounds->right, prcBounds->bottom);
	if (prcWBounds == NULL)
		ATLTRACE(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
	else
		ATLTRACE(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif

	if (prcBounds == NULL)
	{
		if (!m_bWndLess)
			return E_INVALIDARG;
		prcBounds = (RECTL*)&m_rcPos;
	}

	// support the aspects required for multi-pass drawing
	switch (dwDrawAspect)
	{
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			ATLASSERT(FALSE);
			return DV_E_DVASPECT;
			break;
	}

	// make sure nobody forgets to do this
	if (ptd == NULL)
		hicTargetDev = NULL;

	BOOL bOptimize = FALSE;
	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = dwDrawAspect;
	di.lindex = lindex;
	di.ptd = ptd;
	di.hicTargetDev = hicTargetDev;
	di.hdcDraw = hdcDraw;
	di.prcBounds = prcBounds;
	di.prcWBounds = prcWBounds;
	di.bOptimize = bOptimize;
	return OnDrawAdvanced(di);
}

inline HRESULT CComControlBase::IDataObject_GetData(
	_In_ FORMATETC *pformatetcIn,
	_Out_ STGMEDIUM *pmedium)
{
	if (pmedium == NULL)
		return E_POINTER;
	memset(pmedium, 0, sizeof(STGMEDIUM));
	ATLTRACE(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
	ATLTRACE(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);

	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
		return DATA_E_FORMATETC;

	SIZEL sizeMetric, size;
	if (m_bDrawFromNatural)
		sizeMetric = m_sizeNatural;
	else
		sizeMetric = m_sizeExtent;
	if (!m_bDrawGetDataInHimetric)
		AtlHiMetricToPixel(&sizeMetric, &size);
	else
		size = sizeMetric;
	RECTL rectl = {0 ,0, size.cx, size.cy};

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.ptd = NULL;
	di.hicTargetDev = NULL;
	di.prcBounds = &rectl;
	di.prcWBounds = &rectl;
	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
	di.bRectInHimetric = m_bDrawGetDataInHimetric;
	// create appropriate memory metafile DC
	di.hdcDraw = CreateMetaFile(NULL);

	// create attribute DC according to pformatetcIn->ptd

	SaveDC(di.hdcDraw);
	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
	OnDrawAdvanced(di);
	RestoreDC(di.hdcDraw, -1);

	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
	if (hMF == NULL)
		return E_UNEXPECTED;

	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

	if (NULL==hMem)
	{
		DeleteMetaFile(hMF);
		return ResultFromScode(STG_E_MEDIUMFULL);
	}

	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
	ATLENSURE(pMF);
	pMF->hMF=hMF;
	pMF->mm=MM_ANISOTROPIC;
	pMF->xExt=sizeMetric.cx;
	pMF->yExt=sizeMetric.cy;
	GlobalUnlock(hMem);

	pmedium->tymed = TYMED_MFPICT;
	pmedium->hGlobal = hMem;
	pmedium->pUnkForRelease = NULL;

	return S_OK;
}

inline HRESULT CComControlBase::FireViewChange()
{
	if (m_bInPlaceActive)
	{
		// Active
		if (m_hWndCD != NULL)
			::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based
		else if (m_bWndLess && m_spInPlaceSite != NULL)
			m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
	}
	else // Inactive
		SendOnViewChange(DVASPECT_CONTENT);
	return S_OK;
}

inline void CComControlBase::GetZoomInfo(_Inout_ ATL_DRAWINFO& di)
{
	const RECTL& rcPos = *di.prcBounds;
	SIZEL sizeDen;
	if (m_bDrawFromNatural)
		sizeDen = m_sizeNatural;
	else
		sizeDen = m_sizeExtent;
	if (!di.bRectInHimetric)
		AtlHiMetricToPixel(&sizeDen, &sizeDen);
	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
	di.ZoomNum.cx = sizeNum.cx;
	di.ZoomNum.cy = sizeNum.cy;
	di.ZoomDen.cx = sizeDen.cx;
	di.ZoomDen.cy = sizeDen.cy;
	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
		sizeNum.cx == 0 || sizeNum.cy == 0)
	{
		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
		di.bZoomed = FALSE;
	}
	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
		di.bZoomed = TRUE;
	else
		di.bZoomed = FALSE;
}

inline HRESULT CComControlBase::OnDrawAdvanced(_Inout_ ATL_DRAWINFO& di)
{
	BOOL bDeleteDC = FALSE;
	if (di.hicTargetDev == NULL)
	{
		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
		bDeleteDC = (di.hicTargetDev != di.hdcDraw);
	}
	RECTL rectBoundsDP = *di.prcBounds;
	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
	if (!bMetafile)
	{
		::LPtoDP(di.hdcDraw, (LPPOINT)&rectBoundsDP, 2);
		SaveDC(di.hdcDraw);
		SetMapMode(di.hdcDraw, MM_TEXT);
		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
		di.bOptimize = TRUE; //since we save the DC we can do this
	}
	di.prcBounds = &rectBoundsDP;
	GetZoomInfo(di);

	HRESULT hRes = OnDraw(di);
	if (bDeleteDC)
		::DeleteDC(di.hicTargetDev);
	if (!bMetafile)
		RestoreDC(di.hdcDraw, -1);
	return hRes;
}

inline LRESULT CComControlBase::OnPaint(
	_In_ UINT /* uMsg */, 
	_In_ WPARAM wParam,
	_In_ LPARAM /* lParam */, 
	_In_ BOOL& /* lResult */)
{
	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != 0) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
	di.prcBounds = (LPCRECTL)&rc;

	OnDrawAdvanced(di);
	if (wParam == 0)
		::EndPaint(m_hWndCD, &ps);
	return 0;
}


template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl : 
	public CComControlBase, 
	public WinBase
{
public:
	CComControl() : CComControlBase(m_hWnd) {}

	virtual HWND CreateControlWindow(
		_In_ HWND hWndParent, 
		_In_ RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}

	HRESULT FireOnRequestEdit(_In_ DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(_In_ DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}

	virtual HRESULT ControlQueryInterface(
		_In_ const IID& iid, 
		_Deref_out_ void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->GetUnknown()->QueryInterface(iid, ppv);
	}

	int MessageBox(
		_In_z_ LPCTSTR lpszText, 
		_In_opt_z_ LPCTSTR lpszCaption = _T(""), 
		_In_ UINT nType = MB_OK)
	{
		if (::IsWindow(m_hWndCD))
			return ::MessageBox(m_hWndCD, lpszText, lpszCaption, nType);
		HWND hwndParent;
		if (m_spInPlaceSite && m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
			return ::MessageBox(hwndParent, lpszText, lpszCaption, nType);
		return ::MessageBox(NULL, lpszText, lpszCaption, nType);
	}

	typedef CComControl< T, WinBase >	thisClass;
	typedef WinBase						baseWinClass;
	BEGIN_MSG_MAP(thisClass)
		__if_not_exists(WinBase::m_wndReflector)
		{
		MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)
		}
		MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)
		__if_exists(WinBase::m_wndReflector)
		{
			CHAIN_MSG_MAP(baseWinClass)
		}
	END_MSG_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CComCompositeControl

#ifndef _ATL_NO_HOSTING
template <class T>
class CComCompositeControl : 
	public CComControl< T, CAxDialogImpl< T > >
{
public:
	CComCompositeControl()
	{
		m_hbrBackground = NULL;
		m_hWndFocus = NULL;
	}
	virtual ~CComCompositeControl()
	{
		DeleteObject(m_hbrBackground);
	}
	HRESULT AdviseSinkMap(_In_ bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE(atlTraceControls, 1, _T("CComCompositeControl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		T* pT = static_cast<T*>(this);
		return AtlAdviseSinkMap(pT, bAdvise);
	}
	HBRUSH m_hbrBackground;
	HRESULT SetBackgroundColorFromAmbient()
	{
		if (m_hbrBackground != NULL)
		{
			DeleteObject(m_hbrBackground);
			m_hbrBackground = NULL;
		}
		OLE_COLOR clr;
		HRESULT hr = GetAmbientBackColor(clr);
		if (SUCCEEDED(hr))
		{
			COLORREF rgb;
			::OleTranslateColor(clr, NULL, &rgb);
			m_hbrBackground = ::CreateSolidBrush(rgb);
			EnumChildWindows(m_hWnd, (WNDENUMPROC)BackgroundColorEnumProc, (LPARAM) clr);
		}
		return hr;
	}
	static BOOL CALLBACK BackgroundColorEnumProc(_In_ HWND hwnd, _In_ LPARAM l)
	{
		CAxWindow wnd(hwnd);
		CComPtr<IAxWinAmbientDispatch> spDispatch;
		wnd.QueryHost(&spDispatch);
		if (spDispatch != NULL)
			spDispatch->put_BackColor((OLE_COLOR)l);
		return TRUE;
	}
	LRESULT OnDialogColor(
		_In_ UINT, 
		_In_ WPARAM w, 
		_In_ LPARAM, 
		_In_ BOOL&)
	{
		HIGHCONTRAST contrastMode;
		memset(&contrastMode, 0, sizeof(HIGHCONTRAST));
		contrastMode.cbSize = sizeof(HIGHCONTRAST);

		if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &contrastMode, 0) && 
			(contrastMode.dwFlags & HCF_HIGHCONTRASTON) != 0)

			return DefWindowProc();

		HDC dc = (HDC) w;
		LOGBRUSH lb;
		::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
		::SetBkColor(dc, lb.lbColor);
		return (LRESULT)m_hbrBackground;
	}
	HWND Create(
		_In_ HWND hWndParent, 
		_In_ RECT& /*rcPos*/, 
		_In_ LPARAM dwInitParam = NULL)
	{
		CComControl< T, CAxDialogImpl< T > >::Create(hWndParent, dwInitParam);
		if (m_hWnd != NULL)
		{
			SetBackgroundColorFromAmbient();
			ShowWindow(SW_SHOWNOACTIVATE);
		}
		return m_hWnd;
	}
	BOOL CalcExtent(_Inout_ SIZE& size)
	{
		HINSTANCE hInstance = _AtlBaseModule.GetResourceInstance();
		LPCTSTR lpTemplateName = MAKEINTRESOURCE(static_cast<T*>(this)->IDD);
		HRSRC hDlgTempl = FindResource(hInstance, lpTemplateName, RT_DIALOG);
		if (hDlgTempl == NULL)
			return FALSE;
		HGLOBAL hResource = LoadResource(hInstance, hDlgTempl);
		if (hResource == NULL)
			return FALSE;
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hResource);
		if (pDlgTempl == NULL)
			return FALSE;
		AtlGetDialogSize(pDlgTempl, &size);
		AtlPixelToHiMetric(&size, &size);
		return TRUE;
	}
//Implementation
	BOOL PreTranslateAccelerator(
		_In_ LPMSG pMsg, 
		_Out_ HRESULT& hRet)
	{
		hRet = S_OK;

		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;
		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// special handling for keyboard messages
		LRESULT dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0);
		switch(pMsg->message)
		{
		case WM_CHAR:
			if(dwDlgCode == 0)	// no dlgcode, possibly an ActiveX control
				return FALSE;	// let the container process this
			break;
		case WM_KEYDOWN:
			switch(LOWORD(pMsg->wParam))
			{
			case VK_TAB:
				// prevent tab from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTTAB) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_LEFT:
			case VK_UP:
			case VK_RIGHT:
			case VK_DOWN:
				// prevent arrows from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTARROWS) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)	// going forward
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_RETURN:
				break;
			case VK_EXECUTE:
			case VK_ESCAPE:
			case VK_CANCEL:
				// we don't want to handle these, let the container do it
				return FALSE;
			}
			break;
		}

		BOOL bRet;
		//Process accel msg
		if ( (pMsg->message == WM_SYSCHAR) || (pMsg->message == WM_SYSKEYDOWN) || (pMsg->message == WM_SYSKEYUP) )
		{
			T* pT = static_cast<T*>(this);

			CONTROLINFO ci;
			HRESULT hr = pT->GetControlInfo(&ci);
			if (SUCCEEDED(hr))
			{
				if (ci.cAccel > 0)
				{
					ACCEL* pAccel = new ACCEL[ci.cAccel];
					if (pAccel == NULL)
					{
						//Out of memory, don't send to control site
						hRet = E_OUTOFMEMORY;
						return TRUE;
					}
					int cAccel = CopyAcceleratorTable(ci.hAccel, pAccel, ci.cAccel);
					ATLASSERT(cAccel == ci.cAccel);
					bRet = FALSE;	//Accel not processed (invalid)
					WORD fVert = (pMsg->message == WM_SYSCHAR) ? FALT : 0;
					WORD key = LOWORD(pMsg->wParam);
					for (int i = 0; i < cAccel; i++)
					{
						if (((pAccel[i].fVirt & ~FNOINVERT & ~FVIRTKEY) == fVert) &&
							((pAccel[i].key == _toupper(key)) || pAccel[i].key == _tolower(key)))
						{
							bRet = ::IsDialogMessage(m_hWnd, pMsg);	//Accel is valid, process
							break;
						}
					}
					delete [] pAccel;
				}
				else
					bRet = FALSE;	//No accels to process, let the container handle
			}
			else
			{
				bRet = ::IsDialogMessage(m_hWnd, pMsg);	//Backward compt. (not impl GetControlInfo)
			}
		}
		else
		{
			bRet = ::IsDialogMessage(m_hWnd, pMsg);	//Not an accelerator msg
		}

		if (bRet)
		{
			HWND hWndCtlNewFocus = ::GetFocus();
			if (IsChild(hWndCtlNewFocus))
				m_hWndFocus = hWndCtlNewFocus;
			else
				m_hWndFocus = NULL;
			if (IsChild(hWndCtlNewFocus) && ::GetParent(hWndCtlNewFocus) != m_hWnd)
			{
				do
				{
					hWndCtlNewFocus = ::GetParent(hWndCtlNewFocus);
				}
				while (::GetParent(hWndCtlNewFocus) != m_hWnd);
			}

			if (IsChild(hWndCtlNewFocus)  && IsChild(hWndCtl) && hWndCtl != hWndCtlNewFocus)
			{
				CComPtr<IUnknown> spUnknown;
				HRESULT hr = AtlAxGetControl(hWndCtl, &spUnknown);
				if (SUCCEEDED(hr))
				{
					CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
					hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
					if (SUCCEEDED(hr))
						spIOleInPlaceObject->UIDeactivate();
				}
			}
		}
		return bRet;
	}
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void)
	{
		AdviseSinkMap(false); //unadvise
		return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_InPlaceDeactivate();
	}
	HRESULT IOleInPlaceObject_UIDeactivate(void)
	{
		if (m_hWndFocus != NULL)
		{
			HWND hWnd = m_hWndFocus;
			do
			{
				hWnd = ::GetParent(hWnd);
			}
			while (hWnd != NULL && ::GetParent(hWnd) != m_hWnd);
			if (hWnd != m_hWndFocus)
			{
				ATLASSUME(hWnd != NULL);
				CComPtr<IUnknown> spUnknown;
				HRESULT hr = AtlAxGetControl(hWnd, &spUnknown);
				if (SUCCEEDED(hr))
				{
					CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
					hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
					if (SUCCEEDED(hr))
						spIOleInPlaceObject->UIDeactivate();
				}
			}
		}
		m_hWndFocus = NULL;
		return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_UIDeactivate();
		return S_OK;
	}

	virtual HWND CreateControlWindow(
		_In_ HWND hWndParent, 
		_In_ RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		HWND h = pT->Create(hWndParent, rcPos);
		if (h != NULL)
			AdviseSinkMap(true);
		return h;
	}
	virtual HRESULT OnDraw(_In_ ATL_DRAWINFO& di)
	{
		if(!m_bInPlaceActive)
		{
			HPEN hPen = (HPEN)::GetStockObject(BLACK_PEN);
			HBRUSH hBrush = (HBRUSH)::GetStockObject(GRAY_BRUSH);
			::SelectObject(di.hdcDraw, hPen);
			::SelectObject(di.hdcDraw, hBrush);
			::Rectangle(di.hdcDraw, di.prcBounds->left, di.prcBounds->top, di.prcBounds->right, di.prcBounds->bottom);
			::SetTextColor(di.hdcDraw, ::GetSysColor(COLOR_WINDOWTEXT));
			::SetBkMode(di.hdcDraw, TRANSPARENT);
			::DrawText(di.hdcDraw, _T("ATL Composite Control"), -1, (LPRECT)di.prcBounds, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
		}
		return S_OK;
	}
	LRESULT OnInitDialog(
		_In_ UINT /*uMsg*/, 
		_In_ WPARAM /*wParam*/, 
		_In_ LPARAM /*lParam*/, 
		_Out_  BOOL& bHandled)
	{
		// initialize controls in dialog with DLGINIT resource section
		ExecuteDlgInit(static_cast<T*>(this)->IDD);
		bHandled = TRUE;
		return 1;
	}
	// save HWND of child that last had focus
	LRESULT OnChildKillFocus(
		_In_ WORD /*wNotifyCode*/, 
		_In_ WORD /*wID*/, 
		_In_ HWND hWndCtl, 
		_Out_ BOOL& bHandled)
	{
		m_hWndFocus = hWndCtl;
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnNMKillFocus(
		_In_ int /*idCtrl*/, 
		_In_ LPNMHDR pnmh, 
		_Out_ BOOL& bHandled)
	{
		m_hWndFocus = pnmh->hwndFrom;
		bHandled = FALSE;
		return 0;
	}
	LRESULT OnSetFocus(
		_In_ UINT /*uMsg*/, 
		_In_ WPARAM /*wParam*/, 
		_In_ LPARAM /*lParam*/, 
		_Out_ BOOL& bHandled)
	{
		// Call base class OnSetFocus so control is UI-activated.
		baseClass::OnSetFocus(0, 0, 0, bHandled);
		// Shift-tab, up or left arrow was pressed, set focus to last control.
		if ((GetKeyState(VK_SHIFT) < 0 && GetKeyState(VK_TAB) < 0) ||
			(GetKeyState(VK_UP) < 0) || (GetKeyState(VK_LEFT) < 0))
		{
			::SetFocus(::GetWindow(::GetWindow(m_hWnd, GW_CHILD), GW_HWNDLAST));
		}
		// Tab, down or right arrow was pressed, set focus to first control.
		else if (GetKeyState(VK_TAB) < 0 || GetKeyState(VK_DOWN) < 0 ||
				GetKeyState(VK_RIGHT) < 0)
		{
			::SetFocus(::GetWindow(m_hWnd, GW_CHILD));
		}
		else
		{
			if (!::IsWindow(m_hWndFocus) || !::IsChild(m_hWnd, m_hWndFocus))
				m_hWndFocus = ::GetWindow(m_hWnd, GW_CHILD);
			// set focus to last child window that had focus
			::SetFocus(m_hWndFocus);
		}

		bHandled = TRUE;
		return 0;
	}
	typedef CComControl< T, CAxDialogImpl< T > >	baseClass;
	LRESULT OnMouseActivate(
		_In_ UINT uMsg, 
		_In_ WPARAM wParam, 
		_In_ LPARAM lParam, 
		_Out_ BOOL& bHandled)
	{
		ATLTRACE(_T("CComCompositeControl::OnMouseActivate\n"));
		HWND hWndFocus = GetFocus();
		if (m_hWndFocus != NULL)
		{
			if (m_hWndFocus != m_hWnd && hWndFocus != m_hWndFocus)
			{
				HWND hWnd = m_hWndFocus;
				do
				{
					hWnd = ::GetParent(hWnd);
				}
				while (hWnd != NULL && ::GetParent(hWnd) != m_hWnd);

				if (hWnd != m_hWndFocus)
				{
					CComPtr<IUnknown> spUnknown;
					HRESULT hr = AtlAxGetControl(hWnd, &spUnknown);
					if (SUCCEEDED(hr))
					{
						CComPtr<IOleInPlaceObject> spIOleInPlaceObject;
						hr = spUnknown->QueryInterface(&spIOleInPlaceObject);
						if (SUCCEEDED(hr))
							spIOleInPlaceObject->UIDeactivate();
					}
				}
			}
		}
		if (IsChild(hWndFocus))
			m_hWndFocus = hWndFocus;
		else
			m_hWndFocus = NULL;

		return baseClass::OnMouseActivate(uMsg, wParam, lParam, bHandled);
	}

	BEGIN_MSG_MAP(CComCompositeControl< T >)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
		COMMAND_CODE_HANDLER(EN_KILLFOCUS, OnChildKillFocus)
		COMMAND_CODE_HANDLER(BN_KILLFOCUS, OnChildKillFocus)
		COMMAND_CODE_HANDLER(LBN_KILLFOCUS, OnChildKillFocus)
		COMMAND_CODE_HANDLER(CBN_KILLFOCUS, OnChildKillFocus)
		NOTIFY_CODE_HANDLER(NM_KILLFOCUS, OnNMKillFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, baseClass::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
	END_MSG_MAP()

	BEGIN_SINK_MAP(T)
	END_SINK_MAP()

	HWND m_hWndFocus;
};
#endif //_ATL_NO_HOSTING

// Forward declarations
//
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;
template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T, int nBindFlags> class CBindStatusCallback;


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl : 
	public IOleControl
{
public:
	STDMETHOD(GetControlInfo)(_In_ LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(_In_ LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(_In_ DISPID dispid)
	{
		UNREFERENCED_PARAMETER(dispid);
		ATLTRACE(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE(atlTraceControls,2,_T(" -- DISPID = %d\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(_In_ BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl : 
	public IQuickActivate
{
public:
	STDMETHOD(QuickActivate)(
		_In_ QACONTAINER *pQACont, 
		_Inout_ QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
		__if_exists(T::m_clrForeColor)
		{
			pT->m_clrForeColor = pQACont->colorFore;
		}
		__if_exists(T::m_clrBackColor)
		{
			pT->m_clrBackColor = pQACont->colorBack;
		}
		__if_exists(T::m_nAppearance)
		{
			// If you've declared m_nAppearance as something other than
			// 'short', you'll need to typedef AppearanceType to that type
			// in your derived class T.
			pT->m_nAppearance = static_cast<T::AppearanceType>(pQACont->dwAppearance);
		}
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(_In_ LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(_Out_ LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl : 
	public IOleObject
{
public:
	STDMETHOD(SetClientSite)(_Inout_opt_ IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(_Deref_out_opt_ IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(
		_In_opt_z_ LPCOLESTR /* szContainerApp */, 
		_In_opt_z_ LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(_In_ DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(
		_In_ DWORD /* dwWhichMoniker */, 
		_In_opt_ IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(
		_In_ DWORD /* dwAssign */, 
		_In_ DWORD /* dwWhichMoniker */, 
		_In_opt_ IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(
		_In_ IDataObject* /* pDataObject */, 
		_In_ BOOL /* fCreation */, 
		_In_ DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(
		_In_ DWORD /* dwReserved */, 
		_In_opt_ IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(
		_In_ LPCRECT prcPosRect, 
		_In_ HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(
		_In_ LPCRECT prcPosRect, 
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
	HRESULT DoVerbInPlaceActivate(
		_In_ LPCRECT prcPosRect, 
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbInPlaceActivate();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbInPlaceActivate();
			if (SUCCEEDED(hr))
				pT->FireViewChange();
		}
		return hr;
	}
	HRESULT DoVerbUIActivate(
		_In_ LPCRECT prcPosRect, 
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (!pT->m_bUIActive)
		{
			hr = pT->OnPreVerbUIActivate();
			if (SUCCEEDED(hr))
			{
				hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
				if (SUCCEEDED(hr))
					hr = pT->OnPostVerbUIActivate();
			}
		}
		return hr;
	}
	HRESULT DoVerbHide(
		_In_opt_ LPCRECT /* prcPosRect */,
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbHide();
		if (SUCCEEDED(hr))
		{
			pT->UIDeactivate();
			if (pT->m_hWnd)
				pT->ShowWindow(SW_HIDE);
			hr = pT->OnPostVerbHide();
		}
		return hr;
	}
	HRESULT DoVerbOpen(
		_In_opt_ LPCRECT /* prcPosRect */, 
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbOpen();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbOpen();
		return hr;
	}
	HRESULT DoVerbDiscardUndo(
		_In_opt_ LPCRECT /* prcPosRect */, 
		_In_ HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbDiscardUndo();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbDiscardUndo();
		return hr;
	}
	STDMETHOD(DoVerb)(
		_In_ LONG iVerb, 
		_In_opt_ LPMSG /* pMsg */, 
		_Inout_ IOleClientSite* pActiveSite, 
		_In_ LONG /* lindex */,
		_In_ HWND hwndParent, 
		_In_ LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
		ATLASSERT(pT->m_spClientSite);

		// We don't support getting a different site from the one passed into SetClientSite.
			if (!pT->m_spClientSite.IsEqualObject(pActiveSite))
		{
			return E_UNEXPECTED;
		}

		HRESULT hr;
		if (iVerb > 0)
		{
			pT->DoVerbPrimary(lprcPosRect, hwndParent);
			hr = OLEOBJ_S_INVALIDVERB;
		}
		else
		{
			hr = E_NOTIMPL;
			switch (iVerb)
			{
			case OLEIVERB_PRIMARY:
				hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_SHOW:
				hr = pT->DoVerbShow(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_INPLACEACTIVATE:
				hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_UIACTIVATE:
				hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_HIDE:
				hr = pT->DoVerbHide(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_OPEN:
				hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_DISCARDUNDOSTATE:
				hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
				break;
			case OLEIVERB_PROPERTIES:
				hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
			}
		}
		return hr;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(EnumVerbs)(_Deref_out_ IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
		ATLASSERT(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(Update)(void)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(_Out_ CLSID *pClsid)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
		ATLASSERT(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetUserType)(
		_In_ DWORD dwFormOfType, 
		_Deref_out_z_ LPOLESTR *pszUserType)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(SetExtent)(
		_In_ DWORD dwDrawAspect, 
		_In_ SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(
		_In_ DWORD dwDrawAspect, 
		_Out_ SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(
		_Inout_ IAdviseSink *pAdvSink, 
		_Out_ DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(_In_ DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(EnumAdvise)(_Deref_out_ IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
		ATLASSERT(ppenumAdvise != NULL);
		if (ppenumAdvise == NULL)
			return E_POINTER;
		*ppenumAdvise = NULL;
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
				
		return hRes;
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(GetMiscStatus)(
		_In_ DWORD dwAspect, 
		_Out_ DWORD *pdwStatus)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(_In_opt_ LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
// Implementation
public:
	HRESULT OnPreVerbShow() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbShow() 
	{
		return S_OK; 
	}
	HRESULT OnPreVerbInPlaceActivate() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbInPlaceActivate() 
	{
		return S_OK; 
	}
	HRESULT OnPreVerbUIActivate() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbUIActivate() 
	{
		return S_OK; 
	}
	HRESULT OnPreVerbHide() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbHide() 
	{
		return S_OK; 
	}
	HRESULT OnPreVerbOpen() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbOpen() 
	{
		return S_OK; 
	}
	HRESULT OnPreVerbDiscardUndo() 
	{
		return S_OK; 
	}
	HRESULT OnPostVerbDiscardUndo() 
	{
		return S_OK; 
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl : 
	public IPropertyPage
{

public:
	void SetDirty(_In_ BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_bDirty != bDirty)
		{
			pT->m_bDirty = bDirty;
			pT->m_pPageSite->OnStatusChange(bDirty ? PROPPAGESTATUS_DIRTY : PROPPAGESTATUS_CLEAN);
		}
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	virtual ~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(_Inout_ IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			pT->m_pPageSite = NULL;
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE(atlTraceControls,2,_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(
		_In_ HWND hWndParent, 
		_In_ LPCRECT pRect, 
		_In_ BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE(atlTraceControls,2,_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(_Inout_ PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_AtlBaseModule.GetResourceInstance(),
									MAKEINTRESOURCE(static_cast<T*>(this)->IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_AtlBaseModule.GetResourceInstance(), hRsrc);
		if (hGlob == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hGlob);
		if (pDlgTempl == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		AtlGetDialogSize(pDlgTempl, &m_size, true);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(
		_In_ ULONG nObjects, 
		_Inout_ _Deref_pre_opt_valid_ IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(_In_ UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(_In_ LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(_In_z_ LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION_EX;

		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::Help\n"));
		CComBSTR szFullFileName(pszHelpDir);
		CComHeapPtr< OLECHAR > pszFileName(LoadStringHelper(pT->m_dwHelpFileID));
		if (pszFileName == NULL)
			return E_OUTOFMEMORY;
		HRESULT hr=szFullFileName.Append(OLESTR("\\"));
		if(FAILED(hr))
		{
			return hr;
		}
		hr=szFullFileName.Append(pszFileName);
		if(FAILED(hr))
		{
			return hr;
		}
		WinHelp(pT->m_hWnd, OLE2CT_EX_DEF(szFullFileName), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(_In_ MSG *pMsg)
	{
		ATLTRACE(atlTraceControls,2,_T("IPropertyPageImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(
		_In_ UINT, 
		_In_ WPARAM wParam, 
		_In_ LPARAM lParam, 
		_In_ BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(_In_ UINT idRes)
	{
		const ATLSTRINGRESOURCEIMAGE* pString = AtlGetStringResourceImage( 
			_AtlBaseModule.GetResourceInstance(), idRes);
		if (pString == NULL)
		{
			ATLTRACE(atlTraceControls,2,_T("Error : Failed to load string from res\n"));
			return NULL;
		}

		CComHeapPtr< OLECHAR > psz;

		psz.Allocate( pString->nLength+1 );
		if (psz != NULL)
		{
			Checked::memcpy_s(psz, (pString->nLength+1)*sizeof(OLECHAR), pString->achString, pString->nLength*sizeof(OLECHAR));
			psz[pString->nLength] = L'\0';
		}

		return psz.Detach();
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : 
	public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(_In_ DISPID /*dispID*/)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl :
	public IPerPropertyBrowsing
{
public:
	// declare empty map in case derived classes doesn't want to specify one
	DECLARE_EMPTY_PROP_VAL_MAP()

	STDMETHOD(GetDisplayString)(
		_In_ DISPID dispID, 
		_Deref_out_opt_z_ BSTR *pBstr)
	{
		ATLTRACE(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		if (pBstr == NULL)
			return E_POINTER;

		T* pT = static_cast<T*>(this);
		*pBstr = NULL;
		CComVariant var;

		//---- get current value of property ----
		IDispatch *pdisp = NULL;
		pT->QueryInterface(__uuidof(IDispatch), (void **)&pdisp);
		if (! pdisp)
			return S_FALSE;
		HRESULT hr = CComDispatchDriver::GetProperty(pdisp, dispID, &var);
		pdisp->Release();
		if (FAILED(hr))
			return S_FALSE;

		//---- try finding a match in the PROP_VAL_MAP ----
		ATL_PROPVALMAP_ENTRY *valmap;
		int i, cnt;
		BSTR bstrSrc;

		valmap = pT->GetPropValMap(&cnt);
		if ((valmap) && (cnt))
		{
			for (i=0; i < cnt; i++)
			{
				if ((valmap[i].dispid == dispID) && (var == valmap[i].val))
				{
					bstrSrc = (BSTR)valmap[i].szDesc;
					*pBstr = SysAllocString(bstrSrc);
					if (*pBstr == NULL && bstrSrc != NULL)
						return E_OUTOFMEMORY;
					return S_OK;
				}
			}
		}

		//---- not in our PROP_VAL_MAP - let it get standard host treatment ----
		return S_FALSE;
	}

	STDMETHOD(MapPropertyToPage)(
		_In_ DISPID dispID, 
		_Out_ CLSID *pClsid)
	{
		ATLTRACE(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		if (pClsid == NULL)
			return E_POINTER;

		const ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		if(!pMap)
		{
			return E_FAIL;
		}
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;

			// reject data entry types
			if (pMap[i].dwSizeData != 0)
				continue;

			if (pMap[i].dispid == dispID)
			{
				ATLASSERT(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				// Does this property have a page?  CLSID_NULL means it does not
				if (InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
					return PERPROP_E_NOPAGEAVAILABLE;
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}

	STDMETHOD(GetPredefinedStrings)(
		_In_ DISPID dispID, 
		_Out_ CALPOLESTR *pCaStringsOut, 
		_Out_ CADWORD *pCaCookiesOut)
	{
		ATL_PROPVALMAP_ENTRY *valmap;
		int i, cnt, matches, addcnt = 0;

		ATLTRACE(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		valmap = T::GetPropValMap(&cnt);
		if ((! valmap) || (! cnt))
			ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedStrings"));

		//---- first pass thru - count matches ----
		matches = 0;
		for (i=0; i < cnt; i++)
		{
			if (dispID == valmap[i].dispid)
				matches++;
		}

		DWORD *pCookies = NULL;
		LPOLESTR *pStrings = NULL;

		//---- set up the collections to be returned ----
		pCookies = (DWORD *)::ATL::AtlCoTaskMemCAlloc(matches,static_cast<ULONG>(sizeof(DWORD)));
		if (! pCookies)
			goto outofmem;

		pStrings = (LPOLESTR *)::ATL::AtlCoTaskMemCAlloc(matches,static_cast<ULONG>(sizeof(LPOLESTR)));
		if (! pStrings)
			goto outofmem;

		//---- second pass thru - collect the items ----
		for (i=0; i < cnt; i++)
		{
			if (dispID == valmap[i].dispid)
			{
				LPCOLESTR src;
				LPOLESTR dst;

				// store cookie
				pCookies[addcnt] = i;
				// allocate and store string
				src = valmap[i].szDesc;
				size_t len = lstrlenW(src)+1;
				if(len>ULONG_MAX)
				{
					goto outofmem;
				}
				dst = (LPOLESTR)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(len),static_cast<ULONG>(sizeof(WCHAR)));
				if (! dst)
					goto outofmem;
				
				if(!ocscpy_s(dst, len, src))
				{
					goto outofmem;
				}
				pStrings[addcnt] = dst;
				addcnt++;
			}
		}

		pCaCookiesOut->cElems = matches;
		pCaCookiesOut->pElems = pCookies;
		pCaStringsOut->cElems = matches;
		pCaStringsOut->pElems = pStrings;

		return S_OK;

outofmem:
		CoTaskMemFree(pCookies);
		if (pStrings)
		{
			for (i=0; i < addcnt; i++)
				CoTaskMemFree(pStrings[i]);
			CoTaskMemFree(pStrings);
		}

		return E_OUTOFMEMORY;
	}

	STDMETHOD(GetPredefinedValue)(
		_In_ DISPID /* dispID */, 
		_In_ DWORD dwCookie, 
		_Out_ VARIANT* pVarOut)
	{
		ATL_PROPVALMAP_ENTRY *valmap;
		int cnt, index;

		ATLTRACE(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedValue\n"));
		if (pVarOut == NULL)
			return E_POINTER;

		valmap = T::GetPropValMap(&cnt);
		if ((! valmap) || (! cnt))
			ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));

		index = (int) dwCookie;
		if ((index < 0) || (index >= cnt))
			return E_INVALIDARG;

		return VariantCopy(pVarOut, &valmap[index].val);
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl : 
	public IViewObjectEx
{
public:
	STDMETHOD(Draw)(
		_In_ DWORD dwDrawAspect,
		_In_ LONG lindex,
		_In_opt_ void *pvAspect,
		_In_opt_ DVTARGETDEVICE *ptd,
		_In_ HDC hicTargetDev,
		_In_ HDC hdcDraw,
		_In_opt_ LPCRECTL prcBounds, 
		_In_ LPCRECTL prcWBounds, 
		/* _In_opt_ */ BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
		_In_ DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}
	STDMETHOD(GetColorSet)(
		_In_ DWORD /* dwDrawAspect */, 
		_In_ LONG /* lindex */, 
		_In_opt_ void* /* pvAspect */, 
		_In_opt_ DVTARGETDEVICE* /* ptd */, 
		_In_ HDC /* hicTargetDev */, 
		_In_opt_ LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(
		_In_ DWORD /* dwDrawAspect */, 
		_In_ LONG /* lindex */, 
		_In_opt_ void* /* pvAspect */, 
		_In_ DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(_In_ DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(
		_In_ DWORD /* aspects */, 
		_In_ DWORD /* advf */, 
		_Inout_ IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(
		_In_opt_  DWORD* /* pAspects */, 
		_In_opt_  DWORD* /* pAdvf */, 
		_Deref_out_opt_ IAdviseSink** ppAdvSink)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
		ATLASSERT(ppAdvSink != NULL);

		HRESULT hr = E_POINTER;
		if (ppAdvSink != NULL)
		{
			T* pT = static_cast<T*>(this);
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
			hr = S_OK;
		}
		return hr;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(
		_In_ DWORD /* dwDrawAspect */, 
		_In_ LONG /* lindex */, 
		_In_ DVTARGETDEVICE* /* ptd */, 
		_Out_ LPSIZEL lpsizel)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
		ATLASSERT(lpsizel != NULL);
		if (lpsizel == NULL)
			return E_POINTER;

		T* pT = static_cast<T*>(this);
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(
		_In_ DWORD /* dwAspect */, 
		_In_opt_ LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}

	STDMETHOD(GetViewStatus)(_Out_ DWORD* pdwStatus)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
		ATLASSERT(pdwStatus != NULL);
		if (pdwStatus == NULL)
			return E_POINTER;

		T* pT = static_cast<T*>(this);
		*pdwStatus = pT->_GetViewStatus();
		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(
		_In_ DWORD dwAspect, 
		_In_ LPCRECT pRectBounds, 
		_In_ POINT ptlLoc, 
		_In_ LONG /* lCloseHint */, 
		_Out_ DWORD *pHitResult)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
		ATLASSERT(pHitResult != NULL);
		if (pHitResult == NULL)
			return E_POINTER;

		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		*pHitResult = NULL;
		ATLTRACE(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(
		_In_ DWORD dwAspect, 
		_In_ LPCRECT pRectBounds, 
		_In_ LPCRECT prcLoc, 
		_In_ LONG /* lCloseHint */, 
		_Out_ DWORD* pHitResult)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
		ATLASSERT(pHitResult != NULL);
		if (pHitResult == NULL)
			return E_POINTER;

		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		*pHitResult = NULL;
		ATLTRACE(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(
		_In_ DWORD dwAspect, 
		_In_ LONG /* lindex */, 
		_In_opt_ DVTARGETDEVICE* /* ptd */, 
		_In_ HDC /* hicTargetDev */, 
		_In_ DVEXTENTINFO* pExtentInfo , 
		_Out_ LPSIZEL psizel)
	{
		ATLTRACE(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
		ATLASSERT(pExtentInfo != NULL);
		ATLASSERT(psizel != NULL);
		if ((pExtentInfo == NULL) || (psizel == NULL))
			return E_POINTER;

		HRESULT hRes = E_FAIL;
		T* pT = static_cast<T*>(this);
		if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl : 
	public IOleInPlaceObjectWindowless
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(_Out_ HWND* phwnd)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(_In_ BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(
		_In_ LPCRECT prcPos,
		_In_ LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(
		_In_ UINT msg, 
		_In_ WPARAM wParam, 
		_In_ LPARAM lParam, 
		_Inout_ LRESULT *plResult)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		_ATL_MSG message(NULL, msg, wParam, lParam);
		const _ATL_MSG* pOldMsg = pT->m_pCurrentMsg;
		pT->m_pCurrentMsg = &message;
		BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);
		// restore saved value for the current message
		ATLASSERT(pT->m_pCurrentMsg == &message);
		pT->m_pCurrentMsg = pOldMsg;
		return b ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(_In_opt_ IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl : 
	public IOleInPlaceActiveObject
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(_Out_ HWND *phwnd)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(_In_ BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(_In_ LPMSG pMsg)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRet = S_OK;
		MSG msg = *pMsg; 
		if (pT->PreTranslateAccelerator(&msg, hRet))
		{
			return hRet;
		}

		CComPtr<IOleControlSite> spCtlSite;
		hRet = pT->InternalGetSite(__uuidof(IOleControlSite), (void**)&spCtlSite);
		if (SUCCEEDED(hRet))
		{
			if (spCtlSite != NULL)
			{
				DWORD dwKeyMod = 0;
				if (::GetKeyState(VK_SHIFT) < 0)
					dwKeyMod += 1;	// KEYMOD_SHIFT
				if (::GetKeyState(VK_CONTROL) < 0)
					dwKeyMod += 2;	// KEYMOD_CONTROL
				if (::GetKeyState(VK_MENU) < 0)
					dwKeyMod += 4;	// KEYMOD_ALT
				hRet = spCtlSite->TranslateAccelerator(&msg, dwKeyMod);
			}
			else
				hRet = S_FALSE;
		}
		return (hRet == S_OK) ? S_OK : S_FALSE;
	}
	STDMETHOD(OnFrameWindowActivate)(_In_ BOOL /* fActivate */)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(_In_ BOOL fActivate)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		T* pT = static_cast<T*>(this);
		if (fActivate == FALSE)
			pT->IOleInPlaceObject_UIDeactivate();
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(
		_In_ LPCRECT /* prcBorder */, 
		_In_opt_ IOleInPlaceUIWindow* /* pUIWindow */, 
		_In_ BOOL /* fFrameWindow */)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(_In_ BOOL /* fEnable */)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl : 
	public IPointerInactive
{
public:
	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(_In_opt_ DWORD* /*pdwPolicy*/)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(
		_In_ LPCRECT /*pRectBounds*/, 
		_In_ long /*x*/, 
		_In_ long /*y*/, 
		_In_ DWORD /*dwMouseMsg*/)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(
		_In_ LPCRECT /*pRectBounds*/, 
		_In_ long /*x*/, 
		_In_ long /*y*/, 
		_In_ DWORD /*dwMouseMsg*/, 
		_In_ BOOL /*fSetAlways*/)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl : 
	public IRunnableObject
{
public:
	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(_Out_ LPCLSID lpClsid)
	{
		ATLTRACE(atlTraceControls,2,_T("IRunnableObjectImpl::GetRunningClass\n"));
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(_In_opt_ LPBINDCTX)
	{
		ATLTRACE(atlTraceControls,2,_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE(atlTraceControls,2,_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(
		_In_ BOOL /*fLock*/, 
		_In_ BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE(atlTraceControls,2,_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(_In_ BOOL /*fContained*/)
	{
		ATLTRACE(atlTraceControls,2,_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
ATLPREFAST_SUPPRESS(6387)
template <class T>
class ATL_NO_VTABLE IDataObjectImpl : 
	public IDataObject
{
public:
	STDMETHOD(GetData)(
		_In_ FORMATETC *pformatetcIn, 
		_Out_ STGMEDIUM *pmedium)
	{
		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(
		_In_opt_ FORMATETC* /* pformatetc */, 
		_In_opt_ /* _Inout_ */ STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(_In_opt_ FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(
		_In_opt_ FORMATETC* /* pformatectIn */, 
		_In_opt_ FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(
		_In_opt_ FORMATETC* /* pformatetc */, 
		_In_opt_ STGMEDIUM* /* pmedium */, 
		_In_ BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(
		_In_ DWORD /* dwDirection */, 
		_In_opt_ IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(
		_In_ FORMATETC *pformatetc, 
		_In_ DWORD advf, 
		_Inout_ IAdviseSink *pAdvSink,
		_Out_ DWORD *pdwConnection)
	{
		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(_In_ DWORD dwConnection)
	{
		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	
	STDMETHOD(EnumDAdvise)(_Deref_out_ IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
		ATLASSERT(ppenumAdvise != NULL);
		if (ppenumAdvise == NULL)
			return E_POINTER;
		*ppenumAdvise = NULL;

		T* pT = static_cast<T*>(this);
		if (pT->m_spDataAdviseHolder != NULL)
			return pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return E_FAIL;
	}
};
ATLPREFAST_UNSUPPRESS()

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent __ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//
// 2nd template parameter is the supported safety e.g.
// INTERFACESAFE_FOR_UNTRUSTED_CALLER - safe for scripting
// INTERFACESAFE_FOR_UNTRUSTED_DATA   - safe for initialization from data
template <class T, DWORD dwSupportedSafety>
class ATL_NO_VTABLE IObjectSafetyImpl : 
	public IObjectSafety
{
protected:
	virtual BOOL FAccessAllowed()
	{
		return TRUE;
	}
public:
	IObjectSafetyImpl() : m_dwCurrentSafety(0)
	{
		ATLSTATIC_ASSERT((dwSupportedSafety != 0 && 
				(~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA) & dwSupportedSafety) == 0), 				
					"Only INTERFACESAFE_FOR_UNTRUSTED_CALLER and/or INTERFACESAFE_FOR_UNTRUSTED_DATA are supported for dwSupportedSafety parameter.");		
	}

	STDMETHOD(GetInterfaceSafetyOptions)(
		_In_ REFIID riid, 
		_Out_ DWORD *pdwSupportedOptions, 
		_Out_ DWORD *pdwEnabledOptions)
	{
		ATLTRACE(atlTraceControls,2,_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;

		HRESULT hr;
		IUnknown* pUnk;
		// Check if we support this interface
		hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);
		if (SUCCEEDED(hr))
		{
			// We support this interface so set the safety options accordingly
			pUnk->Release();	// Release the interface we just acquired
			*pdwSupportedOptions = dwSupportedSafety;
			
			if (FAccessAllowed())
			{
				*pdwEnabledOptions   = m_dwCurrentSafety;
			}
			else 
			{
				*pdwEnabledOptions   = 0;
			}
		}
		else
		{
			// We don't support this interface
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions   = 0;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(
		_In_ REFIID riid, 
		_In_ DWORD dwOptionSetMask, 
		_In_ DWORD dwEnabledOptions)
	{
		ATLTRACE(atlTraceControls,2,_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		IUnknown* pUnk;

		// Check if we support the interface and return E_NOINTEFACE if we don't
		if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))
			return E_NOINTERFACE;
		pUnk->Release();	// Release the interface we just acquired

		// If we are asked to set options we don't support then fail
		if (dwOptionSetMask & ~dwSupportedSafety)
			return E_FAIL;

		DWORD dwNewSafety = (m_dwCurrentSafety & ~dwOptionSetMask) | (dwOptionSetMask & dwEnabledOptions);
			
		if (m_dwCurrentSafety == dwNewSafety)
		{
			return S_OK;
		}
		
		if (!FAccessAllowed())
		{
			return E_ACCESSDENIED;
		}
		// Set the safety options we have been asked to
		m_dwCurrentSafety = dwNewSafety;	
		
		return S_OK;
	}
	DWORD m_dwCurrentSafety;
};

template <class T>
class ATL_NO_VTABLE IOleLinkImpl : 
	public IOleLink
{
	STDMETHOD(SetUpdateOptions)(_In_ DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(_In_ DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(
		_Inout_opt_ IMoniker* /* pmk */, 
		_In_ REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(_In_opt_ IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(_In_opt_z_ LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(
		_Deref_out_opt_z_ LPOLESTR *ppszDisplayName)
	{
		ATLTRACE(atlTraceControls,2,_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(
		_In_ DWORD /* bindflags */,
		_In_opt_ IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE(atlTraceControls,2,_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(_In_opt_ IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(_In_opt_ IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};

template <class T, int nBindFlags = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<typename T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallback
{
public:
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T, nBindFlags>* pbsc, BYTE* pBytes, DWORD dwSize);
	typedef CBindStatusCallback<T, nBindFlags> thisClass;

BEGIN_COM_MAP(thisClass)
	COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	virtual ~CBindStatusCallback()
	{
		ATLTRACE(atlTraceControls,2,_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(
		_In_ DWORD /*dwReserved*/, 
		_In_opt_ IBinding *pBinding)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(_Out_ LONG *pnPriority)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::GetPriority"));
		HRESULT hr = S_OK;
		if (pnPriority)
			*pnPriority = THREAD_PRIORITY_NORMAL;
		else
			hr = E_INVALIDARG;
		return S_OK;
	}

	STDMETHOD(OnLowResource)(_In_ DWORD /*reserved*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnLowResource"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(
		_In_ ULONG /*ulProgress*/, 
		_In_ ULONG /*ulProgressMax*/, 
		_In_ ULONG /*ulStatusCode*/, 
		_In_opt_z_ LPCWSTR /*szStatusText*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnProgress"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(
		_In_ HRESULT hresult, 
		_In_opt_z_ LPCWSTR /*szError*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnStopBinding\n"));
		// Pass NULL as the array of bytes to signify the end.
		// Pass the HRESULT for the dwSize parameter
		(m_pT->*m_pFunc)(this, NULL, hresult);
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(
		_Out_ DWORD *pgrfBINDF, 
		_Inout_ BINDINFO *pbindInfo)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = nBindFlags;

		ULONG cbSize = pbindInfo->cbSize;		  // remember incoming cbSize		
		memset(pbindInfo, 0, sizeof(*pbindInfo)); // zero out structure
		pbindInfo->cbSize = cbSize;				  // restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	  // set verb
		
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(
		_In_ DWORD grfBSCF, 
		_In_ DWORD dwSize, 
		_In_opt_ FORMATETC * /*pformatetc*/, 
		_In_ STGMEDIUM *pstgmed)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
				{
					// Before returning m_spStream should be released if grfBSCF is BSCF_LASTDATANOTIFICATION
					hr = E_OUTOFMEMORY;
				}
				else
				{
					hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
					if (SUCCEEDED(hr))
					{
						pBytes[dwActuallyRead] = 0;
						if (dwActuallyRead>0)
						{
							(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
							m_dwTotalRead += dwActuallyRead;
						}
					}
					delete[] pBytes;
				}
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(
		_In_ REFIID /*riid*/, 
		_In_opt_ IUnknown * /*punk*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CBindStatusCallback::OnObjectAvailable"));
		return S_OK;
	}

	HRESULT _StartAsyncDownload(
		_In_z_ BSTR bstrURL, 
		_Inout_opt_ IUnknown* pUnkContainer, 
		_In_ BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &__uuidof(IServiceProvider)> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, __uuidof(IBindHost), (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, __uuidof(IStream), (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), __uuidof(IStream), (void**)&spStream);
				ATLTRACE(atlTraceControls,2,_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(
		_In_ T* pT, 
		_In_ ATL_PDATAAVAILABLE pFunc, 
		_In_z_ BSTR bstrURL, 
		_Inout_opt_ IUnknown* pUnkContainer = NULL, 
		_In_ BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(
		_In_ T* pT, 
		_In_ ATL_PDATAAVAILABLE pFunc, 
		_In_z_ BSTR bstrURL, 
		_Inout_opt_ IUnknown* pUnkContainer = NULL, 
		_In_ BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T, nBindFlags> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T, nBindFlags> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;

		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(_In_ type pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
			T* pT = (T*) this; \
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(dispid) == S_FALSE) \
				return S_FALSE; \
			pT->m_##pname = pname; \
			pT->m_bRequiresSave = TRUE; \
			if (pT->m_nFreezeEvents == 0) \
				pT->FireOnChanged(dispid); \
			__if_exists(T::On##fname##Changed) \
			{ \
				pT->On##fname##Changed(); \
			} \
			pT->FireViewChange(); \
			pT->SendOnDataChange(NULL); \
		} \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(_Out_ type* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = pT->m_##pname; \
		} \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(_In_ VARIANT_BOOL pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
			T* pT = (T*) this; \
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(dispid) == S_FALSE) \
				return S_FALSE; \
			pT->m_##pname = pname; \
			pT->m_bRequiresSave = TRUE; \
			if (pT->m_nFreezeEvents == 0) \
				pT->FireOnChanged(dispid); \
			__if_exists(T::On##fname##Changed) \
			{ \
				pT->On##fname##Changed(); \
			} \
			pT->FireViewChange(); \
			pT->SendOnDataChange(NULL); \
		} \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(_Out_ VARIANT_BOOL* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = pT->m_##pname ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE; \
		} \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(_In_z_ BSTR pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
			T* pT = (T*) this; \
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(dispid) == S_FALSE) \
				return S_FALSE; \
			SysFreeStringHelper(pT->m_##pname); \
			HRESULT hr=SysAllocStringHelper(pT->m_##pname,pname); \
			if (FAILED(hr) && pname != NULL) \
				return E_OUTOFMEMORY; \
			pT->m_bRequiresSave = TRUE; \
			if (pT->m_nFreezeEvents == 0) \
				pT->FireOnChanged(dispid); \
			__if_exists(T::On##fname##Changed) \
			{ \
				pT->On##fname##Changed(); \
			} \
			pT->FireViewChange(); \
			pT->SendOnDataChange(NULL); \
		} \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(_Out_ BSTR* p##pname) \
	{ \
		__if_exists(T::m_##pname) \
		{ \
			ATLTRACE(ATL::atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
			ATLASSERT(p##pname != NULL); \
			if (p##pname == NULL) \
				return E_POINTER; \
			T* pT = (T*) this; \
			*p##pname = SysAllocString(pT->m_##pname); \
			if (*p##pname == NULL && pT->m_##pname != NULL) \
				return E_OUTOFMEMORY; \
		} \
		return S_OK; \
	}


template < class T, class InterfaceName, const IID* piid = &_ATL_IIDOF(InterfaceName), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE CStockPropImpl : 
	public IDispatchImpl< InterfaceName, piid, plibid, wMajor, wMinor, tihclass >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(_In_ IFontDisp* pFontDisp)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
				return S_FALSE;
			pT->m_pFont = 0;
			if (pFontDisp)
			{
				CComQIPtr<IFont, &__uuidof(IFont)> p(pFontDisp);
				if (p)
				{
					CComPtr<IFont> pFont;
					p->Clone(&pFont);
					if (pFont)
					{
						pFont->QueryInterface(__uuidof(IFontDisp), (void**) &pT->m_pFont);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_FONT);
			__if_exists(T::OnFontChanged) 
			{
				pT->OnFontChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(_In_ IFontDisp* pFont)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
				return S_FALSE;
			pT->m_pFont = pFont;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_FONT);
			__if_exists(T::OnFontChanged) 
			{
				pT->OnFontChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(
		_Deref_out_opt_ IFontDisp** ppFont)
	{
		__if_exists(T::m_pFont) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
			ATLASSERT(ppFont != NULL);
			if (ppFont == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppFont = pT->m_pFont;
			if (*ppFont != NULL)
				(*ppFont)->AddRef();
		}
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(_In_ IPictureDisp* pPicture)
	{
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
				return S_FALSE;
			pT->m_pPicture = 0;
			if (pPicture)
			{
				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
				if (p)
				{
					ULARGE_INTEGER l;
					p->GetSizeMax(&l);
					HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
					if (hGlob)
					{
						CComPtr<IStream> spStream;
						CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
						if (spStream)
						{
							if (SUCCEEDED(p->Save(spStream, FALSE)))
							{
								LARGE_INTEGER l;
								l.QuadPart = 0;
								spStream->Seek(l, STREAM_SEEK_SET, NULL);
								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pPicture);
							}
							spStream.Release();
						}
						GlobalFree(hGlob);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_PICTURE);
			__if_exists(T::OnPictureChanged) 
			{
				pT->OnPictureChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(_In_ IPictureDisp* pPicture)
	{
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
				return S_FALSE;
			pT->m_pPicture = pPicture;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_PICTURE);
			__if_exists(T::OnPictureChanged) 
			{
				pT->OnPictureChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(
		_Deref_out_opt_ IPictureDisp** ppPicture)
	{
		__if_exists(T::m_pPicture) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
			ATLASSERT(ppPicture != NULL);
			if (ppPicture == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppPicture = pT->m_pPicture;
			if (*ppPicture != NULL)
				(*ppPicture)->AddRef();
		}
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(_In_ IPictureDisp* pPicture)
	{
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
				return S_FALSE;
			pT->m_pMouseIcon = 0;
			if (pPicture)
			{
				CComQIPtr<IPersistStream, &__uuidof(IPersistStream)> p(pPicture);
				if (p)
				{
					ULARGE_INTEGER l;
					p->GetSizeMax(&l);
					HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
					if (hGlob)
					{
						CComPtr<IStream> spStream;
						CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
						if (spStream)
						{
							if (SUCCEEDED(p->Save(spStream, FALSE)))
							{
								LARGE_INTEGER l;
								l.QuadPart = 0;
								spStream->Seek(l, STREAM_SEEK_SET, NULL);
								OleLoadPicture(spStream, l.LowPart, FALSE, __uuidof(IPictureDisp), (void**)&pT->m_pMouseIcon);
							}
							spStream.Release();
						}
						GlobalFree(hGlob);
					}
				}
			}
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_MOUSEICON);
			__if_exists(T::OnMouseIconChanged) 
			{
				pT->OnMouseIconChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(_In_ IPictureDisp* pPicture)
	{
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
			T* pT = (T*) this;
			if (pT->m_nFreezeEvents == 0 && pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
				return S_FALSE;
			pT->m_pMouseIcon = pPicture;
			pT->m_bRequiresSave = TRUE;
			if (pT->m_nFreezeEvents == 0)
				pT->FireOnChanged(DISPID_MOUSEICON);
			__if_exists(T::OnMouseIconChanged) 
			{
				pT->OnMouseIconChanged();
			}
			pT->FireViewChange();
			pT->SendOnDataChange(NULL);
		}
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(
		_Deref_out_opt_ IPictureDisp** ppPicture)
	{
		__if_exists(T::m_pMouseIcon) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
			ATLASSERT(ppPicture != NULL);
			if (ppPicture == NULL)
				return E_POINTER;

			T* pT = (T*) this;
			*ppPicture = pT->m_pMouseIcon;
			if (*ppPicture != NULL)
				(*ppPicture)->AddRef();
		}
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
	IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(_In_ LONG_PTR hWnd)
	{
		return put_HWND(hWnd);
	}
	HRESULT STDMETHODCALLTYPE get_Window(_Out_ LONG_PTR* phWnd)
	{
		return get_HWND(phWnd);
	}
	HRESULT STDMETHODCALLTYPE put_HWND(_In_ LONG_PTR /*hWnd*/)
	{
		ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::put_HWND\n"));
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_HWND(_Out_ LONG_PTR* phWnd)
	{
		__if_exists(T::m_hWnd) 
		{ 
			ATLTRACE(atlTraceControls,2,_T("CStockPropImpl::get_HWND\n"));
			ATLASSERT(phWnd != NULL);
			if (phWnd == NULL)
				return E_POINTER;
			T* pT = (T*) this;
			*phWnd = reinterpret_cast<LONG_PTR>(pT->m_hWnd);
		}
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldbgmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#if defined(__ATLBASE_H__) || defined (_INC_CRTDBG)
#error <atldbgmem.h> must be included before other ATL and CRT headers
#endif

#ifdef __AFX_H__
#error <atldbgmem.h> cannot be used in MFC projects. See AfxEnableMemoryTracking
#endif

#ifndef __ATLDBGMEM_H__
#define __ATLDBGMEM_H__

#pragma once

#pragma warning(push)

#pragma warning(disable: 4273)
#pragma warning(disable: 4127) // conditional expression is constant

#define _MFC_OVERRIDES_NEW
#define _CRTDBG_MAP_ALLOC
#include <new.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <crtdbg.h>
#include <stddef.h>
#include <tchar.h>
#include <atltrace.h>
#include <atlchecked.h>

#define ATLDBG_UNUSED(x) x

#pragma pack(push,_ATL_PACKING)
namespace ATL
{

const DWORD atlDbgMemTrackIndividualAllocations = 0x1;
const DWORD atlDbgMemTrackAggregateStats        = 0x2;
const DWORD atlDbgMemTrackAll                   = 0x3;

struct AtlAllocRecord
{
	char szPath[MAX_PATH];
	int nLine;
	size_t nSize;
	int nAllocations;
};

__declspec(selectany) DWORD g_dwFlags = atlDbgMemTrackIndividualAllocations;
__declspec(selectany) HANDLE g_hReportFile = INVALID_HANDLE_VALUE;
__declspec(selectany) HANDLE g_hMemMutex = NULL;
__declspec(selectany) AtlAllocRecord* g_pMemStats = NULL;
__declspec(selectany) int g_nAllocedRecords = 0;
__declspec(selectany) int g_nRecords = 0;

inline int __cdecl AtlNewHandler(_In_ size_t /* nSize */)
{
	return 0;
}

__declspec(selectany) _PNH _atlNewHandler = &AtlNewHandler;

inline _PNH AtlGetNewHandler(void)
{
	return _atlNewHandler;
}

inline _PNH AtlSetNewHandler(_In_ _PNH pfnNewHandler)
{
	_PNH pfnOldHandler = _atlNewHandler;
	_atlNewHandler = pfnNewHandler;
	return pfnOldHandler;
}

extern __declspec(selectany) const _PNH _pfnUninitialized = (_PNH)-1;

}; // namespace ATL
#pragma pack(pop)

inline void* __cdecl operator new(size_t nSize)
{
	void* pResult;
	for (;;)
	{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		pResult = _malloc_dbg(nSize, _NORMAL_BLOCK, NULL, 0);
#else
		pResult = malloc(nSize);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
}

inline void __cdecl operator delete(void* p)
{
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, _NORMAL_BLOCK);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](size_t nSize)
{
	return ::operator new(nSize);
}

inline void __cdecl operator delete[](void* p)
{
	::operator delete(p);
}

inline void* __cdecl operator new(
	_In_ size_t nSize,
	_In_ int nType,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	ATLDBG_UNUSED(nType);
	ATLDBG_UNUSED(lpszFileName);
	ATLDBG_UNUSED(nLine);

#ifdef _ATL_NO_DEBUG_CRT
	return ::operator new(nSize);
#else
	void* pResult;
	for (;;)
	{
		pResult = _malloc_dbg(nSize, nType, lpszFileName, nLine);
		if (pResult != NULL)
			return pResult;

		if (ATL::_atlNewHandler == NULL || (*ATL::_atlNewHandler)(nSize) == 0)
			break;
	}
	return pResult;
#endif // _ATL_NO_DEBUG_CRT
}

inline void __cdecl operator delete(
	_Inout_opt_ void* p,
	_In_ int nType,
	_In_opt_z_ LPCSTR /* lpszFileName */,
	_In_ int /* nLine */)
{
	ATLDBG_UNUSED(nType);
#if !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
		_free_dbg(p, nType);
#else
		free(p);
#endif // !defined(_ATL_NO_DEBUG_CRT) && defined(_DEBUG)
}

inline void* __cdecl operator new[](
	_In_ size_t nSize,
	_In_ int nType,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	return ::operator new(nSize, nType, lpszFileName, nLine);
}

inline void __cdecl operator delete[](
	_Inout_opt_ void* p,
	_In_ int nType,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	::operator delete(p, nType, lpszFileName, nLine);
}

inline void* __cdecl operator new(
	_In_ size_t nSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	return ::operator new(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void* __cdecl operator new[](
	_In_ size_t nSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	return ::operator new[](nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void __cdecl operator delete(
	_Inout_opt_ void* pData,
	_In_opt_z_ LPCSTR /* lpszFileName */,
	_In_ int /* nLine */)
{
	::operator delete(pData);
}

inline void __cdecl operator delete[](
	_Inout_opt_ void* pData,
	_In_opt_z_ LPCSTR /* lpszFileName */,
	_In_ int /* nLine */)
{
	::operator delete(pData);
}


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline void* AtlAllocMemoryDebug(
	_In_ size_t nSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	ATLDBG_UNUSED(nSize);
	ATLDBG_UNUSED(lpszFileName);
	ATLDBG_UNUSED(nLine);
	return _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
}

inline void AtlFreeMemoryDebug(
	_Inout_opt_ void* pbData)
{
	_free_dbg(pbData, _NORMAL_BLOCK);
}

#define new new(__FILE__, __LINE__)

/////////////////////////////////////////////////////////////////////////////
// allocation failure hook, tracking turn on

inline void _AtlDbgMemTrace(
	_In_z_count_(nLen) LPCSTR szBuf,
	_In_ int nLen)
{
	ATLTRACE(atlTraceAllocation, 0, szBuf);

	if (g_hReportFile != INVALID_HANDLE_VALUE)
	{
		 DWORD dwRet = WaitForSingleObject(g_hMemMutex, INFINITE);
		 if (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED)
		{
			DWORD bytes;
			WriteFile(g_hReportFile, szBuf, nLen, &bytes, NULL);
			ReleaseMutex(g_hMemMutex);
		}
	}
}

inline void _AtlRecordAllocation(
	_In_opt_z_ LPCSTR szFileName,
	_In_ int nLine,
	_In_z_ LPCSTR szAllocType,
	_In_ size_t nSize,
	_In_ int nRequest = 0)
{
	const int c_nSize = 512;
	char szBuf[c_nSize];
	int nLen;

	if (szFileName)
	{
#ifdef _WIN64
		nLen = sprintf_s(szBuf, c_nSize, "%s(%d): Memory operation: %s a %I64d-byte block (# %ld)\r\n",	szFileName, nLine, szAllocType, nSize, nRequest);
#else
		nLen = sprintf_s(szBuf, c_nSize, "%s(%d): Memory operation: %s a %d-byte block (# %ld)\r\n", szFileName, nLine, szAllocType, nSize, nRequest);
#endif
	}
	else
	{
#ifdef _WIN64
		nLen = sprintf_s(szBuf, c_nSize, "Memory operation: %s a %I64d-byte block (# %ld)\r\n", szAllocType, nSize, nRequest);
#else
		nLen = sprintf_s(szBuf, c_nSize, "Memory operation: %s a %d-byte block (# %ld)\r\n", szAllocType, nSize, nRequest);
#endif
	}


	if(nLen == -1 || nLen >= c_nSize)
	{
		// Truncate it
		szBuf[c_nSize -1] = '\0';
	}

	if (g_dwFlags & atlDbgMemTrackIndividualAllocations)
		_AtlDbgMemTrace(szBuf, nLen);

	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		if (!szFileName)
			szFileName = "(null)";
		int nIndex = 0;
		while (nIndex < g_nRecords)
		{
			if (strncmp(g_pMemStats[nIndex].szPath, szFileName, MAX_PATH) == 0 && g_pMemStats[nIndex].nLine == nLine && g_pMemStats[nIndex].nSize == nSize)
			{
				g_pMemStats[nIndex].nAllocations++;
				break;
			}
			nIndex++;
		}

		if (nIndex == g_nRecords)
		{
			if (g_nAllocedRecords == g_nRecords)
			{
				int nNewAllocSize = g_nAllocedRecords * 2;
				if ((nNewAllocSize<0) ||
					(nNewAllocSize>(INT_MAX/sizeof(AtlAllocRecord))))
				{
					ATLASSERT(FALSE);
					ReleaseMutex(g_hMemMutex);
					return; // out of memory
				}
				AtlAllocRecord* p = (AtlAllocRecord*) HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_pMemStats, nNewAllocSize*sizeof(AtlAllocRecord));
				if (p == NULL)
				{
					ATLASSERT(FALSE);
					ReleaseMutex(g_hMemMutex);
					return; // out of memory
				}
				g_pMemStats = p;
				g_nAllocedRecords = nNewAllocSize;
			}
			Checked::strncpy_s(g_pMemStats[nIndex].szPath, MAX_PATH, szFileName, _TRUNCATE);
			g_pMemStats[nIndex].szPath[MAX_PATH-1] = 0;
			g_pMemStats[nIndex].nLine = nLine;
			g_pMemStats[nIndex].nSize = nSize;
			g_pMemStats[nIndex].nAllocations = 1;
			g_nRecords++;
		}

		ReleaseMutex(g_hMemMutex);
	}
}

inline int __cdecl _AtlAllocReportHook(
	_In_ int nAllocType,
	_In_opt_ void* /* pvData */,
	_In_ size_t nSize,
	_In_ int nBlockUse,
	_In_ long lRequest,
	_In_z_ const unsigned char* szFileName,
	_In_ int nLine)
{
	char *operation[] = { "", "allocating", "re-allocating", "freeing" };

	if (nBlockUse == _CRT_BLOCK)   // Ignore internal C runtime library allocations
		return TRUE;

#pragma warning(disable: 4127)
	_ASSERTE((nAllocType > 0) && (nAllocType < 4));
	_ASSERTE((nBlockUse >= 0) && (nBlockUse < 5));

	_AtlRecordAllocation((LPCSTR) szFileName, nLine, operation[nAllocType], nSize, lRequest);

	return TRUE;         // Allow the memory operation to proceed
}

extern __declspec(selectany) _CRT_ALLOC_HOOK pfnCrtAllocHook = NULL;

inline void AtlSetAllocHook()
{
	if (pfnCrtAllocHook == NULL)
		pfnCrtAllocHook = _CrtSetAllocHook(_AtlAllocReportHook);
}

inline void AtlSetReportFile(_In_ HANDLE hReportFile)
{
	if (g_hMemMutex == NULL)
		g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

	if (g_hMemMutex != NULL)
		g_hReportFile = hReportFile;
}

inline void AtlEnableAllocationTracking(_In_ DWORD dwFlags = atlDbgMemTrackAll)
{
	g_dwFlags = dwFlags;

	if (dwFlags & atlDbgMemTrackAggregateStats)
	{
		if (g_hMemMutex == NULL)
			g_hMemMutex = CreateMutex(NULL, FALSE, NULL);

		if (g_pMemStats == NULL && g_hMemMutex != NULL)
		{
			g_pMemStats = (AtlAllocRecord*) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 128*sizeof(AtlAllocRecord));
			g_nAllocedRecords = 128;
			g_nRecords = 0;
		}
	}
}

inline BOOL AtlDumpMemoryStats()
{
	if (g_pMemStats && WaitForSingleObject(g_hMemMutex, INFINITE) == WAIT_OBJECT_0)
	{
		const int nSize = 512;
		char szBuf[nSize];

		int nLen = sprintf_s(szBuf, nSize, "%d records in dump:\r\n", g_nRecords);
		if(nLen == -1 || nLen >= _countof(szBuf))
		{
			szBuf[nSize - 1] = '\0';
		}
		_AtlDbgMemTrace(szBuf, nLen);

		for (int n=0; n<g_nRecords; n++)
		{
#ifdef _WIN64
			nLen = sprintf_s(szBuf, nSize, "%s(%d): %d operations of size %I64d\r\n",
				g_pMemStats[n].szPath,
				g_pMemStats[n].nLine,
				g_pMemStats[n].nAllocations,
				g_pMemStats[n].nSize);

#else
			nLen = sprintf_s(szBuf, nSize, "%s(%d): %d operations of size %d\r\n",
				g_pMemStats[n].szPath,
				g_pMemStats[n].nLine,
				g_pMemStats[n].nAllocations,
				g_pMemStats[n].nSize);
#endif

			if(nLen == -1 || nLen >= _countof(szBuf))
			{
				szBuf[nSize - 1] = '\0';
			}

			_AtlDbgMemTrace(szBuf, nLen);
		}
		ReleaseMutex(g_hMemMutex);
	}

	return TRUE;
}

// This can be set to TRUE to override all AtlEnableMemoryTracking calls,
// allowing all allocations to be tracked.
__declspec(selectany) BOOL _atlMemoryLeakOverride = FALSE;

inline BOOL AtlEnableMemoryTracking(_In_ BOOL bTrack)
{
	if (_atlMemoryLeakOverride)
		return TRUE;

	int nOldState = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
	if (bTrack)
		_CrtSetDbgFlag(nOldState | _CRTDBG_ALLOC_MEM_DF);
	else
		_CrtSetDbgFlag(nOldState & ~_CRTDBG_ALLOC_MEM_DF);
	return nOldState & _CRTDBG_ALLOC_MEM_DF;
}

/////////////////////////////////////////////////////////////////////////////
// stop on a specific memory request

// Obsolete API
inline void AtlSetAllocStop(_In_ LONG lRequestNumber)
{
	ATLDBG_UNUSED(lRequestNumber);
	_CrtSetBreakAlloc(lRequestNumber);
}

// check all of memory (look for memory tromps)
inline BOOL AtlCheckMemory()
{
	return _CrtCheckMemory();
}

// -- true if block of exact size, allocated on the heap
// -- set *plRequestNumber to request number (or 0)
inline BOOL AtlIsMemoryBlock(
	_In_ const void* pData,
	_In_ UINT nBytes,
	_Out_opt_ LONG* plRequestNumber)
{
	ATLDBG_UNUSED(plRequestNumber);
	ATLDBG_UNUSED(nBytes);
	ATLDBG_UNUSED(pData);
	return _CrtIsMemoryBlock(pData, nBytes, plRequestNumber, NULL, NULL);
}

inline BOOL AtlDumpMemoryLeaks()
{
	return _CrtDumpMemoryLeaks();
}

/////////////////////////////////////////////////////////////////////////////

inline HANDLE __stdcall _AtlHeapCreate(
	_In_ DWORD flOptions,
	_In_ SIZE_T dwInitialSize,
	_In_ SIZE_T dwMaximumSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapCreate", 0);
	return HeapCreate(flOptions, dwInitialSize, dwMaximumSize);
}

inline BOOL __stdcall _AtlHeapDestroy(
	_In_ HANDLE hHeap,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapDestroy", 0);
	return HeapDestroy(hHeap);
}

inline LPVOID __stdcall _AtlHeapAlloc(
	_In_ HANDLE hHeap,
	_In_ DWORD dwFlags,
	_In_ SIZE_T nSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _malloc_dbg(nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapAlloc(hHeap, dwFlags, nSize);
#endif
	_AtlRecordAllocation(lpszFileName, nLine, "HeapAlloc", nSize);
	return p;
}

inline LPVOID __stdcall _AtlHeapReAlloc(
	_In_ HANDLE hHeap,
	_In_ DWORD dwFlags,
	_Inout_opt_ LPVOID lpMem,
	_In_ SIZE_T nSize,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	LPVOID p = NULL;
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	p = _realloc_dbg(lpMem, nSize, _NORMAL_BLOCK, lpszFileName, nLine);
#else
	p = HeapReAlloc(hHeap, dwFlags, lpMem, nSize);
#endif

	_AtlRecordAllocation(lpszFileName, nLine, "HeapReAlloc", nSize);
	return p;
}

inline BOOL __stdcall _AtlHeapFree(
	_In_ HANDLE hHeap,
	_In_ DWORD dwFlags,
	_Inout_opt_ LPVOID lpMem,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapFree", 0);
#ifndef _ATL_NO_TRACK_HEAP
	hHeap; // unused
	dwFlags; // unused
	_free_dbg(lpMem, _NORMAL_BLOCK);
	return TRUE;
#else
	return HeapFree(hHeap, dwFlags, lpMem);
#endif
}

inline SIZE_T __stdcall _AtlHeapSize(
	_In_ HANDLE hHeap,
	_In_ DWORD dwFlags,
	_In_ LPCVOID lpMem,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapSize", 0);
	return HeapSize(hHeap, dwFlags, lpMem);
}

inline BOOL __stdcall _AtlHeapValidate(
	_In_ HANDLE hHeap,
	_In_ DWORD dwFlags,
	_In_opt_ LPCVOID lpMem,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "HeapValidate", 0);
	return HeapValidate(hHeap, dwFlags, lpMem);
}

inline LPVOID __stdcall _AtlVirtualAlloc(
	_In_ LPVOID lpAddress,
	_In_ SIZE_T dwSize,
	_In_ DWORD flAllocationType,
	_In_ DWORD flProtect,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualAlloc", dwSize);
	return VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect);
}

inline BOOL __stdcall _AtlVirtualFree(
	_In_ LPVOID lpAddress,
	_In_ SIZE_T dwSize,
	_In_ DWORD dwFreeType,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualFree", 0);
	return VirtualFree(lpAddress, dwSize, dwFreeType);
}

inline SIZE_T __stdcall _AtlVirtualQuery(
	_In_ LPCVOID lpAddress,
	_Out_ PMEMORY_BASIC_INFORMATION lpBuffer,
	_In_ DWORD dwLength,
	_In_z_ LPCSTR lpszFileName,
	_In_ int nLine)
{
	_AtlRecordAllocation(lpszFileName, nLine, "VirtualQuery", 0);
	return VirtualQuery(lpAddress, lpBuffer, dwLength);
}

#define HeapCreate(flOptions, dwInitialSize, dwMaximumSize) ATL	::_AtlHeapCreate(flOptions, dwInitialSize, dwMaximumSize, __FILE__, __LINE__)
#define HeapDestroy(hHeap) ATL::_AtlHeapDestroy(hHeap, __FILE__, __LINE__)
#define HeapAlloc(hHeap, dwFlags, nSize) ATL::_AtlHeapAlloc(hHeap, dwFlags, nSize, __FILE__, __LINE__)
#define HeapReAlloc(hHeap, dwFlags, lpMem, nSize) ATL::_AtlHeapReAlloc(hHeap, dwFlags, lpMem, nSize, __FILE__, __LINE__)
#define HeapFree(hHeap, dwFlags, lpMem) ATL::_AtlHeapFree(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapSize(hHeap, dwFlags, lpMem) ATL::_AtlHeapSize(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define HeapValidate(hHeap, dwFlags, lpMem) ATL::_AtlHeapValidate(hHeap, dwFlags, lpMem, __FILE__, __LINE__)
#define VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect) ATL::_AtlVirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect, __FILE__, __LINE__)
#define VirtualFree(lpAddress,  dwSize, dwFreeType) ATL::_AtlVirtualFree(lpAddress,  dwSize, dwFreeType, __FILE__, __LINE__)
#define VirtualQuery(lpAddress, lpBuffer, dwLength) ATL::_AtlVirtualQuery(lpAddress, lpBuffer, dwLength, __FILE__, __LINE__)

}; // namespace ATL
#pragma pack(pop)

#pragma warning(pop)

#undef ATLDBG_UNUSED

#endif // __ATLDBGMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\VC\atlmfc\include\atldb.h ===
// This is a part of the Active Template Library.
// Copyright (C) Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDB_H__
#define __ATLDB_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

// OLE DB Provider Support

// Interface Impl Classes
//
// Data Source Object
//
// -Mandatory Interfaces:
//	IDBCreateSession
//	IDBInitialize
//	IDBProperties
//	IPersist
//
// Session Object
//
// -Mandatory Interfaces:
//	IGetDataSource
//	IOpenRowset
//	ISessionProperties
//
// -Optional Interfaces:
//	IDBCreateCommand
//	IDBSchemaRowset
//
// Rowset Object
//
// -Mandatory Interfaces:
//	IAccessor
//	IColumnsInfo
//	IConvertType
//	IRowset
//	IRowsetInfo
//
// -Optional Interfaces:
//	IRowsetIdentity
//
// Command Object
//
// -Mandatory Interfaces:
// ICommand)
// IAccessor)
// ICommandProperties
// ICommandText - derives from ICommand
// IColumnsInfo
// IConvertType

#include <oledb.h>
#include <limits.h>
#include <oledberr.h>
#include <msdadc.h>
#include <atldbcli.h>
#include <atlcoll.h>

#pragma warning(disable: 4244)


#pragma pack(push,_ATL_PACKING)
namespace ATL
{

inline DBROWCOUNT AbsVal(_In_ DBROWCOUNT val)
{
	if( val < 0 )
		return -val;
	else
		return val;
}

///////////////////////////////////////////////////////////////////////////
// Forwards
template <class T> class CUtlPropInfo;
class CColumnIds;

///////////////////////////////////////////////////////////////////////////
// Additional Property Flag needed internally
const int	DBPROPFLAGS_CHANGE	= 0x40000000;

///////////////////////////////////////////////////////////////////////////
// ATL Provider Property Definitions
#define ATLDB_NO_STRING		0x01000011	// Arbitrary value for AtlDumpProperty

///////////////////////////////////////////////////////////////////////////
// ATL Provider Property Debugging Support

inline void WINAPI AtlDumpPropsetIID(
	_In_ REFIID iid,
	_In_ DWORD dwStatus)
{
	USES_CONVERSION_EX;
	// Handle the most common ones
	TCHAR szPropertySetName[100];

	if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEALL -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEINFOALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEINFOALL -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_ROWSETALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_ROWSETALL -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_DBINITALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DBINITALL -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_SESSIONALL))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_SESSIONALL -"));
	}
	if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCE))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCE -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_DATASOURCEINFO))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DATASOURCEINFO -"));
	}
	else if(InlineIsEqualGUID(iid, DBPROPSET_ROWSET))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_ROWSET -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_DBINIT))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_DBINIT -"));
	}
	else if(InlineIsEqualGUID(iid,DBPROPSET_SESSION))
	{
		Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName),_T("DBPROPSET_SESSION -"));
	}
	else
	{
		LPOLESTR lpszName = NULL;
		if (SUCCEEDED(StringFromCLSID(iid, &lpszName)))
		{
			Checked::tcscpy_s(szPropertySetName,
							  _countof(szPropertySetName),
							  SAL_Assume_notnull_for_opt_z_(OLE2T_EX(lpszName, _ATL_SAFE_ALLOCA_DEF_THRESHOLD)));
		}
		else
		{
			Checked::tcscpy_s(szPropertySetName, _countof(szPropertySetName), _T("Unknown DBPROPSET -"));
		}
	}

	if (dwStatus & 0x04 /* GETPROP_ERRORSOCCURRED */)
	{
		Checked::tcscat_s(szPropertySetName, _countof(szPropertySetName), _T(" NOT FOUND\n"));
	}
	else
	{
		Checked::tcscat_s(szPropertySetName, _countof(szPropertySetName), _T(" FOUND\n"));
	}

	OutputDebugString(szPropertySetName);
}


inline void WINAPI AtlDumpProperty(
	_In_ DWORD dwPropertyID,
	_In_ DWORD dwStatus)
{
	TCHAR szProperty[100];
	TCHAR szStatus[24];

	switch(dwStatus)
	{
	case DBPROPSTATUS_OK:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("FOUND"));
		break;
	case DBPROPSTATUS_NOTSUPPORTED:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SUPPORTED"));
		break;
	case DBPROPSTATUS_BADVALUE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD VALUE"));
		break;
	case DBPROPSTATUS_BADOPTION:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD OPTION"));
		break;
	case DBPROPSTATUS_BADCOLUMN:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("BAD COLUMN"));
		break;
	case DBPROPSTATUS_NOTALLSETTABLE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT ALL SETTABLE"));
		break;
	case DBPROPSTATUS_NOTSETTABLE:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SETTABLE"));
		break;
	case DBPROPSTATUS_NOTSET:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("NOT SET"));
		break;
	case DBPROPSTATUS_CONFLICTING:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("CONFLICTED"));
		break;
	case ATLDB_NO_STRING:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("WARNING!  NO RESOURCE STRING FOR THIS PROPERTY!  ADD IDS_<PROP_NAME>"));
		break;
	default:
		Checked::tcscpy_s(szStatus, _countof(szStatus), _T("INDETERMINATE"));
		break;
	}

	_stprintf_s(szProperty, _countof(szProperty), _T("Property 0x%lxL -- %s\n"), dwPropertyID, szStatus);
	OutputDebugString(szProperty);
}


///////////////////////////////////////////////////////////////////////////
// Defines for debugging properties

#ifdef _ATL_DEBUG_PROVIDER_PROPS
#define _ATLDUMPPROPSETIID(iid, dwStatus)	AtlDumpPropsetIID(iid, dwStatus)
#define _ATLDUMPPROPERTY(dwPropertyID, dwStatus) AtlDumpProperty(dwPropertyID, dwStatus)
#else
#define _ATLDUMPPROPSETIID(iid, dwStatus)
#define _ATLDUMPPROPERTY(dwPropertyID, dwStatus)
#endif // _ATL_DEBUG_PROVIDER_PROPS

// -------------  STRUCTURE DEFINITIONS -----------------------------------

struct UPROPVAL
{
	DBPROPOPTIONS	dwOption;
	CColumnIds*		pCColumnIds;
	DWORD			dwFlags;
	VARIANT			vValue;
};

struct UPROPINFO
{
	DBPROPID	dwPropId;
	ULONG		ulIDS;
	VARTYPE		VarType;
	DBPROPFLAGS	dwFlags;
	union
	{
		DWORD_PTR dwVal;
		LPOLESTR szVal;
	};
	DBPROPOPTIONS dwOption;
};

struct UPROP
{
	ULONG			cPropIds;
	UPROPINFO**		rgpUPropInfo;
	UPROPVAL*		pUPropVal;
};

struct PROPCOLID
{
	DBID			dbidProperty;	// The column id information
	DBPROPOPTIONS	dwOption;
	VARIANT			vValue;
};

typedef PROPCOLID* PPROPCOLID;

struct UPROPSET
{
	const GUID* pPropSet;
	ULONG cUPropInfo;
	UPROPINFO* pUPropInfo;
	DWORD dwFlags;
	bool bIsChained;
};

struct ATLBINDINGS
{
	DBBINDING* pBindings;
	DWORD dwRef;//DBREFCOUNT dwRef;
	DBCOUNTITEM cBindings;
	DBACCESSORFLAGS dwAccessorFlags;
};

struct ATLCOLUMNINFO
{
	LPOLESTR pwszName;
	ITypeInfo *pTypeInfo;
	DBORDINAL iOrdinal;
	DBCOLUMNFLAGS dwFlags;
	DBLENGTH ulColumnSize;
	DBTYPE wType;
	BYTE bPrecision;
	BYTE bScale;
	DBID columnid;
	DBBYTEOFFSET cbOffset;
};

//
// The following very large sections of defines are to implement auto determination
// of Property map constants based on a stringized prop name.  There is one set for
// Type (VT_), one for Init Value, and one for Property flags.
//

#define ABORTPRESERVE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ACTIVESESSIONS_Flags  ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define APPENDONLY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ASYNCTXNABORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ASYNCTXNCOMMIT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define AUTH_CACHE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_ENCRYPT_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_INTEGRATED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_MASK_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PASSWORD_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PERSIST_ENCRYPTED_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define AUTH_USERID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define BLOCKINGSTORAGEOBJECTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define BOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define BOOKMARKSKIPPED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define BOOKMARKTYPE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define BYREFACCESSORS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CACHEDEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANFETCHBACKWARDS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANHOLDROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CANSCROLLBACKWARDS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define CATALOGLOCATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CATALOGTERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CATALOGUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CHANGEINSERTEDROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE )
#define COL_AUTOINCREMENT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_DEFAULT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_DESCRIPTION_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_FIXEDLENGTH_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_NULLABLE_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_PRIMARYKEY_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_UNIQUE_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COLUMNDEFINITION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COLUMNRESTRICT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define COMMANDTIMEOUT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COMMITPRESERVE_Flags ( DBPROPFLAGS_ROWSET| DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define CONCATNULLBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CURRENTCATALOG_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DATASOURCENAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DATASOURCEREADONLY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DBMSNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DBMSVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define DEFERRED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DELAYSTORAGEOBJECTS_Flags  ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DSOTHREADMODEL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define GROUPBY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define HETEROGENEOUSTABLES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IAccessor_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IColumnsInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IColumnsRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IConnectionPointContainer_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define IConvertType_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetChange_Flags  ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetIdentity_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetIndex_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetLocate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define IRowsetResynch_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IRowsetScroll_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define IRowsetUpdate_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define ISupportErrorInfo_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ILockBytes_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ISequentialStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IStorage_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IStream_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IMMOBILEROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_AUTOUPDATE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_CLUSTERED_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_FILLFACTOR_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_INITIALSIZE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_NULLCOLLATION_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_NULLS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_PRIMARYKEY_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_SORTBOOKMARKS_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_TEMPINDEX_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_TYPE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INDEX_UNIQUE_Flags ( DBPROPFLAGS_INDEX | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_DATASOURCE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_HWND_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_IMPERSONATION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LCID_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LOCATION_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_MODE_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROMPT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROTECTION_LEVEL_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_PROVIDERSTRING_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_TIMEOUT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define LITERALBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define LITERALIDENTITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXINDEXSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXOPENROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define MAXPENDINGROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define MAXROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MAXROWSIZE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXROWSIZEINCLUDESBLOB_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXTABLESINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAYWRITECOLUMN_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MEMORYUSAGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MULTIPLEPARAMSETS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTIPLERESULTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTIPLESTORAGEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MULTITABLEUPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NOTIFICATIONGRANULARITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define NOTIFICATIONPHASES_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYCOLUMNSET_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWFIRSTCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWRESYNCH_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWSETRELEASE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWUNDOCHANGE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWUNDODELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWUNDOINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NOTIFYROWUPDATE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define NULLCOLLATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define OLEOBJECTS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ORDERBYCOLUMNSINSELECT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ORDEREDBOOKMARKS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OTHERINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OTHERUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OUTPUTPARAMETERAVAILABILITY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define OWNINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OWNUPDATEDELETE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define PERSISTENTIDTYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PREPAREABORTBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PREPARECOMMITBEHAVIOR_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROCEDURETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDEROLEDBVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define PROVIDERVER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define QUICKRESTART_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define QUOTEDIDENTIFIERCASE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define REENTRANTEVENTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define REMOVEDELETED_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define REPORTMULTIPLECHANGES_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_CHANGE )
#define RETURNPENDINGINSERTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ROWRESTRICT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define ROWSETCONVERSIONSONCOMMAND_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ROWTHREADMODEL_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define SCHEMATERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SCHEMAUSAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SERVERCURSOR_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SESS_AUTOCOMMITISOLEVELS_Flags ( DBPROPFLAGS_SESSION | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE)
#define SQLSUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define STRONGIDENTITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define STRUCTUREDSTORAGE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUBQUERIES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNDDL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNISOLEVELS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SUPPORTEDTXNISORETAIN_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define TABLETERM_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define TBL_TEMPTABLE_Flags ( DBPROPFLAGS_TABLE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TRANSACTEDOBJECT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define UPDATABILITY_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define USERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
// 1.5
#define FILTERCOMPAREOPS_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define FINDCOMPAREOPS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define IChapteredRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IDBAsynchStatus_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetFind_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetView_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewChapter_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewFilter_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewRowset_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IViewSort_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_ASYNCH_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MAXOPENCHAPTERS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MAXORSINFILTER_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define MAXSORTCOLUMNS_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
#define ROWSET_ASYNCH_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SORTONINDEX_Flags ( DBPROPFLAGS_VIEW | DBPROPFLAGS_READ )
// 2.0
#define IMultipleResults_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define DATASOURCE_TYPE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//MDPROP
#define AXES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define FLATTENING_SUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_JOINCUBES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define NAMED_LEVELS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define RANGEROWSET_Flags (  )
#define MDX_SLICER_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define MDX_CUBEQUALIFICATION_Flags (  )
#define MDX_OUTERREFERENCE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_QUERYBYPROPERTY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_CASESUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_STRING_COMPOP_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_DESCFLAGS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_SET_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_MEMBER_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_NUMERIC_FUNCTIONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_FORMULAS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define AGGREGATECELL_UPDATE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define MDX_AGGREGATECELL_UPDATE_Flags (  )
#define MDX_OBJQUALIFICATION_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define MDX_NONMEASURE_EXPRESSONS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
// DBPROP
#define ACCESSORDER_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define BOOKMARKINFO_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define INIT_CATALOG_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ROW_BULKOPS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE ) //!!!
#define PROVIDERFRIENDLYNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define LOCKMODE_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define MULTIPLECONNECTIONS_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define UNIQUEROWS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SERVERDATAONINSERT_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
//#define STORAGEFLAGS_Flags (  )
#define CONNECTIONSTATUS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define ALTERCOLUMN_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COLUMNLCID_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ )
#define RESETDATASOURCE_Flags ( DBPROPFLAGS_DATASOURCE | DBPROPFLAGS_WRITE )
#define INIT_OLEDBSERVICES_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetRefresh_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define SERVERNAME_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define IParentRowset_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define HIDDENCOLUMNS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ )
#define PROVIDERMEMORY_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define CLIENTCURSOR_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
// 2.1
#define TRUSTEE_USERNAME_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TRUSTEE_AUTHENTICATION_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_WRITE )
#define TRUSTEE_NEWAUTHENTICATION_Flags ( DBPROPFLAGS_TRUSTEE | DBPROPFLAGS_WRITE )
#define IRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowChange_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowSchemaChange_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IGetRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IScopedOperations_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IBindResource_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define ICreateRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_BINDFLAGS_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_LOCKOWNER_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define GENERATEURL_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
//#define IDBBinderProperties_Flags (  )
#define IColumnsInfo2_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
//#define IRegisterProvider_Flags (  )
#define IGetSession_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IGetSourceRow_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetCurrentIndex_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OPENROWSETSUPPORT_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define COL_ISLONG_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
// 2.5
#define COL_SEED_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COL_INCREMENT_Flags ( DBPROPFLAGS_COLUMN | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define INIT_GENERALTIMEOUT_Flags ( DBPROPFLAGS_DBINIT | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define COMSERVICES_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
// 2.6
#define OUTPUTSTREAM_Flags ( DBPROPFLAGS_STREAM | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define OUTPUTENCODING_Flags ( DBPROPFLAGS_STREAM | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define TABLESTATISTICS_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_READ )
#define SKIPROWCOUNTRESULTS_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define IRowsetBookmark_Flags ( DBPROPFLAGS_ROWSET | DBPROPFLAGS_READ | DBPROPFLAGS_WRITE )
#define VISUALMODE_Flags ( DBPROPFLAGS_DATASOURCEINFO | DBPROPFLAGS_WRITE )


#define ABORTPRESERVE_Type VT_BOOL
#define ACTIVESESSIONS_Type VT_I4
#define APPENDONLY_Type VT_BOOL
#define ASYNCTXNABORT_Type VT_BOOL
#define ASYNCTXNCOMMIT_Type VT_BOOL
#define AUTH_CACHE_AUTHINFO_Type VT_BOOL
#define AUTH_ENCRYPT_PASSWORD_Type VT_BOOL
#define AUTH_INTEGRATED_Type VT_BSTR
#define AUTH_MASK_PASSWORD_Type VT_BOOL
#define AUTH_PASSWORD_Type VT_BSTR
#define AUTH_PERSIST_ENCRYPTED_Type VT_BOOL
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Type VT_BOOL
#define AUTH_USERID_Type VT_BSTR
#define BLOCKINGSTORAGEOBJECTS_Type VT_BOOL
#define BOOKMARKS_Type VT_BOOL
#define BOOKMARKSKIPPED_Type VT_BOOL
#define BOOKMARKTYPE_Type VT_I4
#define BYREFACCESSORS_Type VT_BOOL
#define CACHEDEFERRED_Type VT_BOOL
#define CANFETCHBACKWARDS_Type VT_BOOL
#define CANHOLDROWS_Type VT_BOOL
#define CANSCROLLBACKWARDS_Type VT_BOOL
#define CATALOGLOCATION_Type VT_I4
#define CATALOGTERM_Type VT_BSTR
#define CATALOGUSAGE_Type VT_I4
#define CHANGEINSERTEDROWS_Type VT_BOOL
#define COL_AUTOINCREMENT_Type VT_BOOL
#define COL_DEFAULT_Type VT_BSTR
#define COL_DESCRIPTION_Type VT_BSTR
#define COL_FIXEDLENGTH_Type VT_BOOL
#define COL_NULLABLE_Type VT_BOOL
#define COL_PRIMARYKEY_Type VT_BOOL
#define COL_UNIQUE_Type VT_BOOL
#define COLUMNDEFINITION_Type VT_I4
#define COLUMNRESTRICT_Type VT_BOOL
#define COMMANDTIMEOUT_Type VT_I4
#define COMMITPRESERVE_Type VT_BOOL
#define CONCATNULLBEHAVIOR_Type VT_I4
#define CURRENTCATALOG_Type VT_BSTR
#define DATASOURCENAME_Type VT_BSTR
#define DATASOURCEREADONLY_Type VT_BOOL
#define DBMSNAME_Type VT_BSTR
#define DBMSVER_Type VT_BSTR
#define DEFERRED_Type VT_BOOL
#define DELAYSTORAGEOBJECTS_Type VT_BOOL
#define DSOTHREADMODEL_Type VT_I4
#define GROUPBY_Type VT_I4
#define HETEROGENEOUSTABLES_Type VT_I4
#define IAccessor_Type VT_BOOL
#define IColumnsInfo_Type VT_BOOL
#define IColumnsRowset_Type VT_BOOL
#define IConnectionPointContainer_Type VT_BOOL
#define IConvertType_Type VT_BOOL
#define IRowset_Type VT_BOOL
#define IRowsetChange_Type VT_BOOL
#define IRowsetIdentity_Type VT_BOOL
#define IRowsetIndex_Type VT_BOOL
#define IRowsetInfo_Type VT_BOOL
#define IRowsetLocate_Type VT_BOOL
#define IRowsetResynch_Type VT_BOOL
#define IRowsetScroll_Type VT_BOOL
#define IRowsetUpdate_Type VT_BOOL
#define ISupportErrorInfo_Type VT_BOOL
#define ILockBytes_Type VT_BOOL
#define ISequentialStream_Type VT_BOOL
#define IStorage_Type VT_BOOL
#define IStream_Type VT_BOOL
#define IDENTIFIERCASE_Type VT_I4
#define IMMOBILEROWS_Type VT_BOOL
#define INDEX_AUTOUPDATE_Type VT_BOOL
#define INDEX_CLUSTERED_Type VT_BOOL
#define INDEX_FILLFACTOR_Type VT_I4
#define INDEX_INITIALSIZE_Type VT_I4
#define INDEX_NULLCOLLATION_Type VT_I4
#define INDEX_NULLS_Type VT_I4
#define INDEX_PRIMARYKEY_Type VT_BOOL
#define INDEX_SORTBOOKMARKS_Type VT_BOOL
#define INDEX_TEMPINDEX_Type VT_BOOL
#define INDEX_TYPE_Type VT_I4
#define INDEX_UNIQUE_Type VT_BOOL
#define INIT_DATASOURCE_Type VT_BSTR
#define INIT_HWND_Type VT_I4
#define INIT_IMPERSONATION_LEVEL_Type VT_I4
#define INIT_LCID_Type VT_I4
#define INIT_LOCATION_Type VT_BSTR
#define INIT_MODE_Type VT_I4
#define INIT_PROMPT_Type VT_I2
#define INIT_PROTECTION_LEVEL_Type VT_I4
#define INIT_PROVIDERSTRING_Type VT_BSTR
#define INIT_TIMEOUT_Type VT_I4
#define LITERALBOOKMARKS_Type VT_BOOL
#define LITERALIDENTITY_Type VT_BOOL
#define MAXINDEXSIZE_Type VT_I4
#define MAXOPENROWS_Type VT_I4
#define MAXPENDINGROWS_Type VT_I4
#define MAXROWS_Type VT_I4
#define MAXROWSIZE_Type VT_I4
#define MAXROWSIZEINCLUDESBLOB_Type VT_BOOL
#define MAXTABLESINSELECT_Type VT_I4
#define MAYWRITECOLUMN_Type VT_BOOL
#define MEMORYUSAGE_Type VT_I4
#define MULTIPLEPARAMSETS_Type VT_BOOL
#define MULTIPLERESULTS_Type VT_I4
#define MULTIPLESTORAGEOBJECTS_Type VT_BOOL
#define MULTITABLEUPDATE_Type VT_BOOL
#define NOTIFICATIONGRANULARITY_Type VT_I4
#define NOTIFICATIONPHASES_Type VT_I4
#define NOTIFYCOLUMNSET_Type VT_I4
#define NOTIFYROWDELETE_Type VT_I4
#define NOTIFYROWFIRSTCHANGE_Type VT_I4
#define NOTIFYROWINSERT_Type VT_I4
#define NOTIFYROWRESYNCH_Type VT_I4
#define NOTIFYROWSETRELEASE_Type VT_I4
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Type VT_I4
#define NOTIFYROWUNDOCHANGE_Type VT_I4
#define NOTIFYROWUNDODELETE_Type VT_I4
#define NOTIFYROWUNDOINSERT_Type VT_I4
#define NOTIFYROWUPDATE_Type VT_I4
#define NULLCOLLATION_Type VT_I4
#define OLEOBJECTS_Type VT_I4
#define ORDERBYCOLUMNSINSELECT_Type VT_BOOL
#define ORDEREDBOOKMARKS_Type VT_BOOL
#define OTHERINSERT_Type VT_BOOL
#define OTHERUPDATEDELETE_Type VT_BOOL
#define OUTPUTPARAMETERAVAILABILITY_Type VT_I4
#define OWNINSERT_Type VT_BOOL
#define OWNUPDATEDELETE_Type VT_BOOL
#define PERSISTENTIDTYPE_Type VT_I4
#define PREPAREABORTBEHAVIOR_Type VT_I4
#define PREPARECOMMITBEHAVIOR_Type VT_I4
#define PROCEDURETERM_Type VT_BSTR
#define PROVIDERNAME_Type VT_BSTR
#define PROVIDEROLEDBVER_Type VT_BSTR
#define PROVIDERVER_Type VT_BSTR
#define QUICKRESTART_Type VT_BOOL
#define QUOTEDIDENTIFIERCASE_Type VT_I4
#define REENTRANTEVENTS_Type VT_BOOL
#define REMOVEDELETED_Type VT_BOOL
#define REPORTMULTIPLECHANGES_Type VT_BOOL
#define RETURNPENDINGINSERTS_Type VT_BOOL
#define ROWRESTRICT_Type VT_BOOL
#define ROWSETCONVERSIONSONCOMMAND_Type VT_BOOL
#define ROWTHREADMODEL_Type VT_I4
#define SCHEMATERM_Type VT_BSTR
#define SCHEMAUSAGE_Type VT_I4
#define SERVERCURSOR_Type VT_BOOL
#define SESS_AUTOCOMMITISOLEVELS_Type VT_I4
#define SQLSUPPORT_Type VT_I4
#define STRONGIDENTITY_Type VT_BOOL
#define STRUCTUREDSTORAGE_Type VT_I4
#define SUBQUERIES_Type VT_I4
#define SUPPORTEDTXNDDL_Type VT_I4
#define SUPPORTEDTXNISOLEVELS_Type VT_I4
#define SUPPORTEDTXNISORETAIN_Type VT_I4
#define TABLETERM_Type VT_BSTR
#define TBL_TEMPTABLE_Type VT_BOOL
#define TRANSACTEDOBJECT_Type VT_BOOL
#define UPDATABILITY_Type VT_I4
#define USERNAME_Type VT_BSTR
// 1.5
#define FILTERCOMPAREOPS_Type VT_I4
#define FINDCOMPAREOPS_Type VT_I4
#define IChapteredRowset_Type VT_BOOL
#define IDBAsynchStatus_Type VT_BOOL
#define IRowsetFind_Type VT_BOOL
#define IRowsetView_Type VT_BOOL
#define IViewChapter_Type VT_BOOL
#define IViewFilter_Type VT_BOOL
#define IViewRowset_Type VT_BOOL
#define IViewSort_Type VT_BOOL
#define INIT_ASYNCH_Type VT_I4
#define MAXOPENCHAPTERS_Type VT_I4
#define MAXORSINFILTER_Type VT_I4
#define MAXSORTCOLUMNS_Type VT_I4
#define ROWSET_ASYNCH_Type VT_I4
#define SORTONINDEX_Type VT_BOOL
// 2.0
#define IMultipleResults_Flags_Type VT_BOOL
#define DATASOURCE_TYPE_Flags_Type VT_I4
//MDPROP
#define AXES_Type VT_I4
#define FLATTENING_SUPPORT_Type VT_I4
#define MDX_JOINCUBES_Type VT_I4
#define NAMED_LEVELS_Type VT_I4
//#define RANGEROWSET_Type
#define MDX_SLICER_Type VT_I4
//#define MDX_CUBEQUALIFICATION_Type
#define MDX_OUTERREFERENCE_Type VT_I4
#define MDX_QUERYBYPROPERTY_Type VT_BOOL
#define MDX_CASESUPPORT_Type VT_I4
#define MDX_STRING_COMPOP_Type VT_I4
#define MDX_DESCFLAGS_Type VT_I4
#define MDX_SET_FUNCTIONS_Type VT_I4
#define MDX_MEMBER_FUNCTIONS_Type VT_I4
#define MDX_NUMERIC_FUNCTIONS_Type VT_I4
#define MDX_FORMULAS_Type VT_I4
#define AGGREGATECELL_UPDATE_Type VT_I4
//#define MDX_AGGREGATECELL_UPDATE_Type
#define MDX_OBJQUALIFICATION_Type VT_I4
#define MDX_NONMEASURE_EXPRESSONS_Type VT_I4
// DBPROP
#define ACCESSORDER_Type VT_I4
#define BOOKMARKINFO_Type VT_I4
#define INIT_CATALOG_Type VT_BSTR
#define ROW_BULKOPS_Type VT_I4
#define PROVIDERFRIENDLYNAME_Type VT_BSTR
#define LOCKMODE_Type VT_I4
#define MULTIPLECONNECTIONS_Type VT_BOOL
#define UNIQUEROWS_Type VT_BOOL
#define SERVERDATAONINSERT_Type VT_BOOL
//#define STORAGEFLAGS_Type
#define CONNECTIONSTATUS_Type VT_I4
#define ALTERCOLUMN_Type VT_I4
#define COLUMNLCID_Type VT_I4
#define RESETDATASOURCE_Type VT_I4
#define INIT_OLEDBSERVICES_Type VT_I4
#define IRowsetRefresh_Type VT_BOOL
#define SERVERNAME_Type VT_BSTR
#define IParentRowset_Type VT_BOOL
#define HIDDENCOLUMNS_Type VT_I4
#define PROVIDERMEMORY_Type VT_BOOL
#define CLIENTCURSOR_Type VT_BOOL
// 2.1
#define TRUSTEE_USERNAME_Type VT_BSTR
#define TRUSTEE_AUTHENTICATION_Type VT_BSTR
#define TRUSTEE_NEWAUTHENTICATION_Type VT_BSTR
#define IRow_Type VT_BOOL
#define IRowChange_Type VT_BOOL
#define IRowSchemaChange_Type VT_BOOL
#define IGetRow_Type VT_BOOL
#define IScopedOperations_Type VT_BOOL
#define IBindResource_Type VT_BOOL
#define ICreateRow_Type VT_BOOL
#define INIT_BINDFLAGS_Type VT_I4
#define INIT_LOCKOWNER_Type VT_BSTR
#define GENERATEURL_Type VT_I4
//#define IDBBinderProperties_Type
#define IColumnsInfo2_Type VT_BOOL
//#define IRegisterProvider_Type
#define IGetSession_Type VT_BOOL
#define IGetSourceRow_Type VT_BOOL
#define IRowsetCurrentIndex_Type VT_BOOL
#define OPENROWSETSUPPORT_Type VT_I4
#define COL_ISLONG_Type VT_BOOL
// 2.5
//#define COL_SEED_Type VT_VARIANT //!!!
//#define COL_INCREMENT_Type VT_VARIANT //!!!
#define INIT_GENERALTIMEOUT_Type VT_I4
#define COMSERVICES_Type VT_I4
// 2.6
#define OUTPUTSTREAM_Type VT_UNKNOWN
#define OUTPUTENCODING_Type VT_BSTR
#define TABLESTATISTICS_Type VT_I4
#define SKIPROWCOUNTRESULTS_Type VT_BOOL
#define IRowsetBookmark_Type VT_BOOL
#define VISUALMODE_Type VT_I4



#define ABORTPRESERVE_Value ATL_VARIANT_FALSE
#define ACTIVESESSIONS_Value 0
#define APPENDONLY_Value ATL_VARIANT_FALSE
#define ASYNCTXNABORT_Value ATL_VARIANT_FALSE
#define ASYNCTXNCOMMIT_Value ATL_VARIANT_FALSE
#define AUTH_CACHE_AUTHINFO_Value ATL_VARIANT_FALSE
#define AUTH_ENCRYPT_PASSWORD_Value ATL_VARIANT_FALSE
#define AUTH_INTEGRATED_Value OLESTR("")
#define AUTH_MASK_PASSWORD_Value ATL_VARIANT_FALSE
#define AUTH_PASSWORD_Value OLESTR("")
#define AUTH_PERSIST_ENCRYPTED_Value ATL_VARIANT_FALSE
#define AUTH_PERSIST_SENSITIVE_AUTHINFO_Value ATL_VARIANT_FALSE
#define AUTH_USERID_Value OLESTR("")
#define BLOCKINGSTORAGEOBJECTS_Value ATL_VARIANT_FALSE
#define BOOKMARKS_Value ATL_VARIANT_FALSE
#define BOOKMARKSKIPPED_Value ATL_VARIANT_FALSE
#define BOOKMARKTYPE_Value 0
#define BYREFACCESSORS_Value ATL_VARIANT_FALSE
#define CACHEDEFERRED_Value ATL_VARIANT_FALSE
#define CANFETCHBACKWARDS_Value ATL_VARIANT_TRUE
#define CANHOLDROWS_Value ATL_VARIANT_TRUE
#define CANSCROLLBACKWARDS_Value ATL_VARIANT_TRUE
#define CATALOGLOCATION_Value 0
#define CATALOGTERM_Value OLESTR("")
#define CATALOGUSAGE_Value 0
#define CHANGEINSERTEDROWS_Value ATL_VARIANT_FALSE
#define COL_AUTOINCREMENT_Value ATL_VARIANT_FALSE
#define COL_DEFAULT_Value OLESTR("")
#define COL_DESCRIPTION_Value OLESTR("")
#define COL_FIXEDLENGTH_Value ATL_VARIANT_FALSE
#define COL_NULLABLE_Value ATL_VARIANT_FALSE
#define COL_PRIMARYKEY_Value ATL_VARIANT_FALSE
#define COL_UNIQUE_Value ATL_VARIANT_FALSE
#define COLUMNDEFINITION_Value 0
#define COLUMNRESTRICT_Value ATL_VARIANT_FALSE
#define COMMANDTIMEOUT_Value 0
#define COMMITPRESERVE_Value ATL_VARIANT_FALSE
#define CONCATNULLBEHAVIOR_Value 0
#define CURRENTCATALOG_Value OLESTR("")
#define DATASOURCENAME_Value OLESTR("")
#define DATASOURCEREADONLY_Value ATL_VARIANT_TRUE
#define DBMSNAME_Value OLESTR("")
#define DBMSVER_Value OLESTR("")
#define DEFERRED_Value ATL_VARIANT_FALSE
#define DELAYSTORAGEOBJECTS_Value ATL_VARIANT_FALSE
#define DSOTHREADMODEL_Value DBPROPVAL_RT_APTMTTHREAD
#define GROUPBY_Value 0
#define HETEROGENEOUSTABLES_Value 0
#define IAccessor_Value ATL_VARIANT_TRUE
#define IColumnsInfo_Value ATL_VARIANT_TRUE
#define IColumnsRowset_Value ATL_VARIANT_FALSE
#define IConnectionPointContainer_Value ATL_VARIANT_FALSE
#define IConvertType_Value ATL_VARIANT_TRUE
#define IRowset_Value ATL_VARIANT_TRUE
#define IRowsetChange_Value ATL_VARIANT_FALSE
#define IRowsetIdentity_Value ATL_VARIANT_TRUE
#define IRowsetIndex_Value ATL_VARIANT_FALSE
#define IRowsetInfo_Value ATL_VARIANT_TRUE
#define IRowsetLocate_Value ATL_VARIANT_FALSE
#define IRowsetResynch_Value ATL_VARIANT_FALSE
#define IRowsetScroll_Value ATL_VARIANT_FALSE
#define IRowsetUpdate_Value ATL_VARIANT_FALSE
#define ISupportErrorInfo_Value ATL_VARIANT_FALSE
#define ILockBytes_Value ATL_VARIANT_FALSE
#define ISequentialStream_Value ATL_VARIANT_FALSE
#define IStorage_Value ATL_VARIANT_FALSE
#define IStream_Value ATL_VARIANT_FALSE
#define IDENTIFIERCASE_Value 0
#define IMMOBILEROWS_Value ATL_VARIANT_FALSE
#define INDEX_AUTOUPDATE_Value ATL_VARIANT_FALSE
#define INDEX_CLUSTERED_Value ATL_VARIANT_FALSE
#define INDEX_FILLFACTOR_Value 0
#define INDEX_INITIALSIZE_Value 0
#define INDEX_NULLCOLLATION_Value 0
#define INDEX_NULLS_Value 0
#define INDEX_PRIMARYKEY_Value ATL_VARIANT_FALSE
#define INDEX_SORTBOOKMARKS_Value ATL_VARIANT_FALSE
#define INDEX_TEMPINDEX_Value ATL_VARIANT_FALSE
#define INDEX_TYPE_Value 0
#define INDEX_UNIQUE_Value ATL_VARIANT_FALSE
#define INIT_DATASOURCE_Value OLESTR("")
#define INIT_HWND_Value 0
#define INIT_IMPERSONATION_LEVEL_Value 0
#define INIT_LCID_Value 0
#define INIT_LOCATION_Value OLESTR("")
#define INIT_MODE_Value DB_MODE_READ
#define INIT_PROMPT_Value DBPROMPT_NOPROMPT
#define INIT_PROTECTION_LEVEL_Value 0
#define INIT_PROVIDERSTRING_Value OLESTR("")
#define INIT_TIMEOUT_Value 0
#define LITERALBOOKMARKS_Value ATL_VARIANT_FALSE
#define LITERALIDENTITY_Value ATL_VARIANT_FALSE
#define MAXINDEXSIZE_Value 0
#define MAXOPENROWS_Value 0
#define MAXPENDINGROWS_Value 0
#define MAXROWS_Value 0
#define MAXROWSIZE_Value 0
#define MAXROWSIZEINCLUDESBLOB_Value ATL_VARIANT_FALSE
#define MAXTABLESINSELECT_Value 0
#define MAYWRITECOLUMN_Value ATL_VARIANT_FALSE
#define MEMORYUSAGE_Value 0
#define MULTIPLEPARAMSETS_Value ATL_VARIANT_FALSE
#define MULTIPLERESULTS_Value 0
#define MULTIPLESTORAGEOBJECTS_Value ATL_VARIANT_FALSE
#define MULTITABLEUPDATE_Value ATL_VARIANT_FALSE
#define NOTIFICATIONGRANULARITY_Value DBPROPVAL_NT_SINGLEROW
#define NOTIFICATIONPHASES_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER | DBPROPVAL_NP_FAILEDTODO | DBPROPVAL_NP_DIDEVENT
#define NOTIFYCOLUMNSET_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWDELETE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWFIRSTCHANGE_Value DBPROPVAL_NP_OKTODO | DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWINSERT_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWRESYNCH_Value 0
#define NOTIFYROWSETRELEASE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWSETFETCHPOSITIONCHANGE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDOCHANGE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDODELETE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUNDOINSERT_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NOTIFYROWUPDATE_Value DBPROPVAL_NP_OKTODO |	DBPROPVAL_NP_ABOUTTODO | DBPROPVAL_NP_SYNCHAFTER
#define NULLCOLLATION_Value 0
#define OLEOBJECTS_Value 0
#define ORDERBYCOLUMNSINSELECT_Value ATL_VARIANT_FALSE
#define ORDEREDBOOKMARKS_Value ATL_VARIANT_FALSE
#define OTHERINSERT_Value ATL_VARIANT_FALSE
#define OTHERUPDATEDELETE_Value ATL_VARIANT_FALSE
#define OUTPUTPARAMETERAVAILABILITY_Value 0
#define OWNINSERT_Value ATL_VARIANT_FALSE
#define OWNUPDATEDELETE_Value ATL_VARIANT_FALSE
#define PERSISTENTIDTYPE_Value 0
#define PREPAREABORTBEHAVIOR_Value 0
#define PREPARECOMMITBEHAVIOR_Value 0
#define PROCEDURETERM_Value OLESTR("")
#define PROVIDERNAME_Value OLESTR("")
#define PROVIDEROLEDBVER_Value OLESTR("02.60")
#define PROVIDERVER_Value OLESTR("01.00")
#define QUICKRESTART_Value ATL_VARIANT_FALSE
#define QUOTEDIDENTIFIERCASE_Value 0
#define REENTRANTEVENTS_Value ATL_VARIANT_FALSE
#define REMOVEDELETED_Value ATL_VARIANT_FALSE
#define REPORTMULTIPLECHANGES_Value ATL_VARIANT_FALSE
#define RETURNPENDINGINSERTS_Value ATL_VARIANT_FALSE
#define ROWRESTRICT_Value ATL_VARIANT_FALSE
#define ROWSETCONVERSIONSONCOMMAND_Value ATL_VARIANT_TRUE
#define ROWTHREADMODEL_Value 0
#define SCHEMATERM_Value OLESTR("")
#define SCHEMAUSAGE_Value 0
#define SERVERCURSOR_Value ATL_VARIANT_FALSE
#define SESS_AUTOCOMMITISOLEVELS_Value 0
#define SQLSUPPORT_Value 0
#define STRONGIDENTITY_Value ATL_VARIANT_FALSE
#define STRUCTUREDSTORAGE_Value 0
#define SUBQUERIES_Value 0
#define SUPPORTEDTXNDDL_Value 0
#define SUPPORTEDTXNISOLEVELS_Value 0
#define SUPPORTEDTXNISORETAIN_Value 0
#define TABLETERM_Value OLESTR("")
#define TBL_TEMPTABLE_Value ATL_VARIANT_FALSE
#define TRANSACTEDOBJECT_Value ATL_VARIANT_FALSE
#define UPDATABILITY_Value 0
#define USERNAME_Value OLESTR("")
// 1.5
#define FILTERCOMPAREOPS_Value 0
#define FINDCOMPAREOPS_Value 0
#define IChapteredRowset_Value ATL_VARIANT_FALSE
#define IDBAsynchStatus_Value ATL_VARIANT_FALSE
#define IRowsetFind_Value ATL_VARIANT_FALSE
#define IRowsetView_Value ATL_VARIANT_FALSE
#define IViewChapter_Value ATL_VARIANT_FALSE
#define IViewFilter_Value ATL_VARIANT_FALSE
#define IViewRowset_Value ATL_VARIANT_FALSE
#define IViewSort_Value ATL_VARIANT_FALSE
#define INIT_ASYNCH_Value 0
#define MAXOPENCHAPTERS_Value 0
#define MAXORSINFILTER_Value 0
#define MAXSORTCOLUMNS_Value 0
#define ROWSET_ASYNCH_Value 0
#define SORTONINDEX_Value ATL_VARIANT_FALSE
// 2.0
#define IMultipleResults_Value ATL_VARIANT_FALSE
#define DATASOURCE_TYPE_Value 0
//MDPROP
#define AXES_Value 0
#define FLATTENING_SUPPORT_Value 0
#define MDX_JOINCUBES_Value 0
#define NAMED_LEVELS_Value 0
//#define RANGEROWSET_Value 0
#define MDX_SLICER_Value 0
//#define MDX_CUBEQUALIFICATION_Value
#define MDX_OUTERREFERENCE_Value 0
#define MDX_QUERYBYPROPERTY_Value ATL_VARIANT_FALSE
#define MDX_CASESUPPORT_Value 0
#define MDX_STRING_COMPOP_Value 0
#define MDX_DESCFLAGS_Value 0
#define MDX_SET_FUNCTIONS_Value 0
#define MDX_MEMBER_FUNCTIONS_Value 0
#define MDX_NUMERIC_FUNCTIONS_Value 0
#define MDX_FORMULAS_Value 0
#define AGGREGATECELL_UPDATE_Value 0
//#define MDX_AGGREGATECELL_UPDATE_Value
#define MDX_OBJQUALIFICATION_Value 0
#define MDX_NONMEASURE_EXPRESSONS_Value 0
// DBPROP
#define ACCESSORDER_Value 0
#define BOOKMARKINFO_Value 0
#define INIT_CATALOG_Value OLESTR("")
#define ROW_BULKOPS_Value 0
#define PROVIDERFRIENDLYNAME_Value OLESTR("")
#define LOCKMODE_Value 0
#define MULTIPLECONNECTIONS_Value ATL_VARIANT_FALSE
#define UNIQUEROWS_Value ATL_VARIANT_FALSE
#define SERVERDATAONINSERT_Value ATL_VARIANT_FALSE
//#define STORAGEFLAGS_Value
#define CONNECTIONSTATUS_Value 0
#define ALTERCOLUMN_Value 0
#define COLUMNLCID_Value 0
#define RESETDATASOURCE_Value 0
#define INIT_OLEDBSERVICES_Value 0
#define IRowsetRefresh_Value ATL_VARIANT_FALSE
#define SERVERNAME_Value OLESTR("")
#define IParentRowset_Value ATL_VARIANT_FALSE
#define HIDDENCOLUMNS_Value 0
#define PROVIDERMEMORY_Value ATL_VARIANT_FALSE
#define CLIENTCURSOR_Value ATL_VARIANT_FALSE
// 2.1
#define TRUSTEE_USERNAME_Value OLESTR("")
#define TRUSTEE_AUTHENTICATION_Value OLESTR("")
#define TRUSTEE_NEWAUTHENTICATION_Value OLESTR("")
#define IRow_Value ATL_VARIANT_FALSE
#define IRowChange_Value ATL_VARIANT_FALSE
#define IRowSchemaChange_Value ATL_VARIANT_FALSE
#define IGetRow_Value ATL_VARIANT_FALSE
#define IScopedOperations_Value ATL_VARIANT_FALSE
#define IBindResource_Value ATL_VARIANT_FALSE
#define ICreateRow_Value ATL_VARIANT_FALSE
#define INIT_BINDFLAGS_Value 0
#define INIT_LOCKOWNER_Value OLESTR("")
#define GENERATEURL_Value 0
//#define IDBBinderProperties_Value
#define IColumnsInfo2_Value ATL_VARIANT_FALSE
//#define IRegisterProvider_Value
#define IGetSession_Value ATL_VARIANT_FALSE
#define IGetSourceRow_Value ATL_VARIANT_FALSE
#define IRowsetCurrentIndex_Value ATL_VARIANT_FALSE
#define OPENROWSETSUPPORT_Value 0
#define COL_ISLONG_Value ATL_VARIANT_FALSE
// 2.5
//#define COL_SEED_Value
//#define COL_INCREMENT_Value
#define INIT_GENERALTIMEOUT_Value 0
#define COMSERVICES_Value 0
// 2.6
#define OUTPUTSTREAM_Value NULL
#define OUTPUTENCODING_Value NULL
#define TABLESTATISTICS_Value 0
#define SKIPROWCOUNTRESULTS_Value ATL_VARIANT_FALSE
#define IRowsetBookmark_Value ATL_VARIANT_FALSE
#define VISUALMODE_Value MDPROPVAL_VISUAL_MODE_DEFAULT


#define OUT_OF_LINE virtual

#define BEGIN_PROPSET_MAP(Class) \
static ATL::UPROPSET* _GetPropSet( \
	_Out_opt_ ULONG* pNumPropSets,\
	_Out_ ULONG* pcElemPerSupported, \
	_Inout_opt_ ATL::UPROPSET* pSet = NULL, \
	_Out_opt_ GUID* pguidSet = NULL) \
{ \
	typedef Class _PropSetClass; \
	USES_ATL_SAFE_ALLOCA;\
	ULONG& cElemsMax = *pcElemPerSupported; \
	cElemsMax = 0; \
	ULONG nCurProp = 0; \
	int cRemainder = 0; \
	if (pguidSet == NULL) \
		pguidSet = (GUID*)&GUID_NULL;

#define BEGIN_PROPERTY_SET_EX(guid, flags) \
if (pNumPropSets != NULL) \
{ \
	ATLASSUME(pSet != NULL); \
	pSet[nCurProp].pPropSet = &guid; \
	pSet[nCurProp].dwFlags = flags; \
	pSet[nCurProp].bIsChained = false; \
} \
static const ATL::UPROPINFO aProperty##guid[] = \
{

#define BEGIN_PROPERTY_SET(guid) BEGIN_PROPERTY_SET_EX(guid, 0)

//DBPROP_ macros

#define PROPERTY_INFO_ENTRY_EX(dwPropID, vt, dwFlags, value, options) DBPROP_##dwPropID, IDS_DBPROP_##dwPropID, vt, dwFlags, (DWORD_PTR)value, (DBPROPOPTIONS)options,

#define PROPERTY_INFO_ENTRY_VALUE(dwPropID, value) PROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwPropID##_Flags, value, 0)

#define PROPERTY_INFO_ENTRY_VALUE_FLAGS(dwPropID, value, dwFlags) PROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwFlags, value, 0)

#define PROPERTY_INFO_ENTRY(dwPropID) PROPERTY_INFO_ENTRY_VALUE(dwPropID, dwPropID##_Value)


//MDPROP_ macros

#define MDPROPERTY_INFO_ENTRY_EX(dwPropID, vt, dwFlags, value, options) MDPROP_##dwPropID, IDS_MDPROP_##dwPropID, vt, dwFlags, (DWORD_PTR)value, (DBPROPOPTIONS)options,

#define MDPROPERTY_INFO_ENTRY_VALUE(dwPropID, value) MDPROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwPropID##_Flags, value, 0)

#define MDPROPERTY_INFO_ENTRY_VALUE_FLAGS(dwPropID, value, dwFlags) MDPROPERTY_INFO_ENTRY_EX(dwPropID, dwPropID##_Type, dwFlags, value, 0)

#define MDPROPERTY_INFO_ENTRY(dwPropID) MDPROPERTY_INFO_ENTRY_VALUE(dwPropID, dwPropID##_Value)


#define END_PROPERTY_SET(guid) \
		}; \
		if (pNumPropSets != NULL) \
		{ \
			pSet[nCurProp].pUPropInfo = (ATL::UPROPINFO*)aProperty##guid; \
			pSet[nCurProp].cUPropInfo = sizeof(aProperty##guid) / sizeof(ATL::UPROPINFO); \
			cRemainder = (pSet[nCurProp].cUPropInfo % 32) ? 1 : 0; \
			if (cElemsMax < (pSet[nCurProp].cUPropInfo / 32 + cRemainder)) \
			{ \
				cElemsMax = (pSet[nCurProp].cUPropInfo / 32 + cRemainder); \
			} \
		} \
		nCurProp++;

#define CHAIN_PROPERTY_SET(ChainClass) \
		ULONG cPropSets##ChainClass, cElsSupported##ChainClass; \
		int cSets##ChainClass = (int)(DWORD_PTR)ChainClass::_GetPropSet(NULL, &cElsSupported##ChainClass); \
		if (pNumPropSets != NULL) \
		{ \
			ATL::UPROPSET* pSetA=(ATL::UPROPSET*)_ATL_SAFE_ALLOCA(::ATL::AtlMultiplyThrow(static_cast<int>(sizeof(ATL::UPROPSET)),cSets##ChainClass),_ATL_SAFE_ALLOCA_DEF_THRESHOLD);\
			ATL::UPROPSET* pSetTemp = ChainClass::_GetPropSet(&cPropSets##ChainClass, &cElsSupported##ChainClass, pSetA); \
			cElemsMax = (cElemsMax < cElsSupported##ChainClass) ? cElsSupported##ChainClass : cElemsMax; \
			ATLENSURE(pSetTemp); \
			for (ULONG iSet = nCurProp; iSet < nCurProp+cPropSets##ChainClass; iSet++) \
			{ \
				pSet[iSet].pPropSet = pSetTemp[iSet-nCurProp].pPropSet; \
				pSet[iSet].dwFlags = pSetTemp[iSet-nCurProp].dwFlags; \
				pSet[iSet].pUPropInfo = pSetTemp[iSet-nCurProp].pUPropInfo; \
				pSet[iSet].cUPropInfo = pSetTemp[iSet-nCurProp].cUPropInfo; \
				pSet[iSet].bIsChained = true; \
			} \
		} \
		nCurProp += cSets##ChainClass;

#define END_PROPSET_MAP() \
	if (pNumPropSets != NULL) \
	{ \
		if (IsEqualGUID(*pguidSet, GUID_NULL)) \
		{ \
			*pNumPropSets = nCurProp; \
			return pSet; \
		} \
		else \
		{ \
			*pNumPropSets = 1; \
			UINT i = 0; \
			for (; i < nCurProp && IsEqualGUID(*(pSet[i].pPropSet), *pguidSet); i++); \
			return (i == nCurProp ) ? &pSet[0] : &pSet[i]; \
		} \
	} \
	return (ATL::UPROPSET*)(DWORD_PTR)nCurProp; \
	}


// For DataSource flags IDBInitialize::m_dwStatus
enum DATASOURCE_FLAGS {
	DSF_MASK_INIT			= 0xFFFFF00F,	// Mask for stuff lasting over init/uninit.
	DSF_PERSIST_DIRTY		= 0x00000001,	// Set if init string changes.
	DSF_INITIALIZED			= 0x00000010,	// Have we been initialized.
};


#define DBID_USE_GUID_OR_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_GUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID ))

#define DBID_USE_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_NAME(e) \
	((1<<(e)) & \
	( 1<<DBKIND_NAME \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_PGUID_NAME ))

#define DBID_USE_PROPID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PROPID \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_PROPID ))

// Bookmark can be either guid or pguid.
#define DBID_IS_BOOKMARK(dbid) \
	(  DBID_USE_GUID(dbid.eKind)  &&  dbid.uGuid.guid  == DBCOL_SPECIALCOL \
	|| DBID_USE_PGUID(dbid.eKind) && *dbid.uGuid.pguid == DBCOL_SPECIALCOL )

#define DivDword(dw) (dw >> 5)		// dw / 32 = dw / (sizeof(DWORD)*8)
#define ModDword(dw) (dw & (32-1))	// dw % 32
#define DwordSizeofBits(nBits) (nBits/32+1)	// Use in array declarations
#define CLEARBITARRAY( rgdwFlags ) memset( rgdwFlags, 0, sizeof(rgdwFlags) )

template <class T>
BOOL InRange(
	_In_ const T& val,
	_In_ const T& valMin,
	_In_ const T& valMax)
{
	return ( valMin <= val && val <= valMax );
}
// Implementation Class
class CBitFieldOps
{
public:
	void SETBIT(
		_In_ DWORD rgdwFlags[],
		_In_ const DWORD dwBit)
	{
		rgdwFlags[DivDword(dwBit)] |= 1 << ModDword(dwBit);
	}

	void CLEARBIT(
		_In_ DWORD rgdwFlags[],
		_In_ const DWORD dwBit)
	{
		rgdwFlags[DivDword(dwBit)] &= ~( 1 << ModDword(dwBit) );
	}

	DWORD TESTBIT(
		_In_ const DWORD rgdwFlags[],
		_In_ const DWORD dwBit)
	{
		//old//Note: Not {0,1}, but from {0...2^32-1}.
		// Note: Now returns {0,1}.
		return ( rgdwFlags[DivDword(dwBit)] & ( 1 << ModDword(dwBit) ) ) != 0;
	}
};

// Implementation Class
class CDBIDOps
{
public:
	HRESULT CompareDBIDs(
		_In_opt_ const DBID* pdbid1,
		_In_opt_ const DBID* pdbid2)
	{
		// Array of valid eKind matches, in addition to matching exactly.
		static const BYTE s_rgbKind[] =
		{
			DBKIND_PGUID_NAME,		// DBKIND_GUID_NAME
			DBKIND_PGUID_PROPID,	// DBKIND_GUID_PROPID
			DBKIND_NAME,			// DBKIND_NAME
			DBKIND_GUID_NAME,		// DBKIND_PGUID_NAME
			DBKIND_GUID_PROPID,		// DBKIND_PGUID_PROPID
			DBKIND_PROPID,			// DBKIND_PROPID
			DBKIND_GUID				// DBKIND_GUID
		};

		if( !pdbid1 || !pdbid2 )
			return S_FALSE;

		// Assume a match, and discard early if we can.
		DBKIND tmp1 = 0;
		DBKIND tmp2 = (DBKIND)(_countof(s_rgbKind) - 1);
		if (!InRange(pdbid2->eKind, tmp1, tmp2))
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Column ID out of Range\n"));
			return E_FAIL;
		}

		ATLASSUME(pdbid2->eKind < _countof(s_rgbKind));
		if (pdbid1->eKind != pdbid2->eKind &&
			pdbid1->eKind != s_rgbKind[pdbid2->eKind])
		{
			return S_FALSE;
		}

		if (DBID_USE_GUID_OR_PGUID(pdbid1->eKind))
		{
			if (!DBID_USE_GUID_OR_PGUID(pdbid2->eKind))
				return S_FALSE;
			// Compare GUIDs.
			// Note that _GUID_ is equivalent to _PGUID_.
			if (!InlineIsEqualGUID(
					DBID_USE_PGUID(pdbid1->eKind) ? *(pdbid1->uGuid.pguid) : pdbid1->uGuid.guid,
					DBID_USE_PGUID(pdbid2->eKind) ? *(pdbid2->uGuid.pguid) : pdbid2->uGuid.guid ))
				return S_FALSE;
		}
		if (DBID_USE_NAME(pdbid1->eKind))
		{
			if (!DBID_USE_NAME(pdbid2->eKind))
				return S_FALSE;
			// Compare names.
			// Need to check if 1 is null and the other is not.
			if ((pdbid1->uName.pwszName == NULL) != (pdbid2->uName.pwszName == NULL))
				 return S_FALSE;
			// Since the above check does not rule out both being null, which is
			// a valid comparison, and wcscmp will GPF if they were, we need
			// to check for valid pointers
			if( pdbid1->uName.pwszName && pdbid2->uName.pwszName )
			{
				// Assume null-terminated.
				// Assume LCID match is OK (note diff with lstrcmp(), CompareString().)
				if (wcscmp(pdbid1->uName.pwszName, pdbid2->uName.pwszName) != 0)
					return S_FALSE;
			}
		}
		if (DBID_USE_PROPID(pdbid1->eKind))
		{
			if (!DBID_USE_PROPID(pdbid2->eKind))
				return S_FALSE;
			// Compare PROPID.
			if (pdbid1->uName.ulPropid != pdbid2->uName.ulPropid)
				return S_FALSE;
		}

		// No reason to discard, so must have matched each field successfully.
		return S_OK;
	}

	static HRESULT IsValidDBID(_In_ const DBID* pdbid1)
	{
		ATLASSERT( pdbid1 );

		if( pdbid1 &&
			((pdbid1->eKind == DBKIND_GUID_NAME) ||
			(pdbid1->eKind == DBKIND_GUID_PROPID) ||
			(pdbid1->eKind == DBKIND_NAME) ||
			(pdbid1->eKind == DBKIND_PGUID_NAME) ||
			(pdbid1->eKind == DBKIND_PGUID_PROPID) ||
			(pdbid1->eKind == DBKIND_PROPID) ||
			(pdbid1->eKind == DBKIND_GUID)) )
			return S_OK;
		else
			return S_FALSE;
	}
	HRESULT CopyDBIDs(
		_Out_ DBID* pdbidDest,
		_In_ const DBID* pdbidSrc)
	{
		ULONG cwchBuffer;

		ATLASSERT( pdbidDest && pdbidSrc );

		if( !pdbidDest || !pdbidSrc )
			return S_FALSE;

		// Save eKind
		pdbidDest->eKind = pdbidSrc->eKind;

		switch( pdbidSrc->eKind )
		{

			case DBKIND_GUID_NAME:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
				cwchBuffer++;
				pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
				if( pdbidDest->uName.pwszName )
				{
					Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer * sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
				}
				else
				{
					return E_OUTOFMEMORY;
				}
				break;

			case DBKIND_GUID_PROPID:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_NAME:
				cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
				cwchBuffer++;
				pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
				if( pdbidDest->uName.pwszName )
				{
					Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer*sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
				}
				else
				{
					return E_OUTOFMEMORY;
				}
				break;
			case DBKIND_PGUID_NAME:
				pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
				if( pdbidDest->uGuid.pguid )
				{
					*(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid);
					cwchBuffer = ocslen(pdbidSrc->uName.pwszName);
					cwchBuffer++;
					pdbidDest->uName.pwszName = (PWSTR)::ATL::AtlCoTaskMemCAlloc(cwchBuffer, static_cast<ULONG>(sizeof(WCHAR)));
					if( pdbidDest->uName.pwszName )
					{
						Checked::memcpy_s(pdbidDest->uName.pwszName, cwchBuffer*sizeof(WCHAR), pdbidSrc->uName.pwszName, cwchBuffer*sizeof(WCHAR));
						break;
					}
					else
					{
						CoTaskMemFree(pdbidDest->uGuid.pguid);
						pdbidDest->uGuid.pguid = NULL;
					}
				}
				return E_OUTOFMEMORY;
			case DBKIND_PGUID_PROPID:
				pdbidDest->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
				if( pdbidDest->uGuid.pguid )
					*(pdbidDest->uGuid.pguid) = *(pdbidSrc->uGuid.pguid);
				else
					return E_OUTOFMEMORY;
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_PROPID:
				pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
				break;
			case DBKIND_GUID:
				pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
				break;
			default:
				ATLASSERT(L"Unhandled dbid1.ekind");
				return S_FALSE;
		}

		return S_OK;
	}
	static GUID* GetDBIDpGuid(_In_ DBID& dbid)
	{
		GUID* pGuid;
		switch (dbid.eKind)
		{
		case DBKIND_PGUID_NAME:
		case DBKIND_PGUID_PROPID:
			pGuid = dbid.uGuid.pguid;
			break;
		case DBKIND_GUID_NAME:
		case DBKIND_GUID_PROPID:
		case DBKIND_GUID:
			pGuid = &(dbid.uGuid.guid);
			break;
		default:
			pGuid = NULL;
		}

		return pGuid;
	}
	static ULONG GetPropIDFromDBID(_In_ DBID& dbid)
	{
		switch (dbid.eKind)
		{
		case DBKIND_GUID_PROPID:
		case DBKIND_PGUID_PROPID:
		case DBKIND_PROPID:
			return dbid.uName.ulPropid;
		default:
			return 0;
		}
	}
	void FreeDBIDs(_In_ DBID* pdbidSrc)
	{
		switch( pdbidSrc->eKind )
		{

			case DBKIND_GUID_NAME:
				CoTaskMemFree(pdbidSrc->uName.pwszName);
				break;
			case DBKIND_NAME:
				CoTaskMemFree(pdbidSrc->uName.pwszName);
				break;
			case DBKIND_PGUID_NAME:
				CoTaskMemFree(pdbidSrc->uGuid.pguid);
				CoTaskMemFree(pdbidSrc->uName.pwszName);
				break;
			case DBKIND_PGUID_PROPID:
				CoTaskMemFree(pdbidSrc->uGuid.pguid);
				break;
			case DBKIND_GUID_PROPID:
			case DBKIND_PROPID:
			case DBKIND_GUID:
				break;
			default:
				ATLASSERT(L"Unhandled dbid1.ekind");
				break;
		}
	}
};

class CConvertHelper
{
public:
	CConvertHelper() {}
	HRESULT FinalConstruct()
	{
		HRESULT hr = ::CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY, NULL,
			CLSCTX_INPROC_SERVER, __uuidof(IDataConvert), (void**)&m_spConvert);

		if (FAILED(hr))
			return hr;

		// Check to see if the data conversion routine is 2.0 capable, if so.  Initialize
		// the conversion routine to be 2.0.
		DCINFO rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0}}};
		CComPtr<IDCInfo> spIDCInfo;

		hr = m_spConvert->QueryInterface(&spIDCInfo);
		if (hr == S_OK)
		{
			V_UI4(&rgInfo->vData) = 0x200;  // OLEDB Version 02.00
			spIDCInfo->SetInfo(1, rgInfo);
		}

		return hr;
	}
	CComPtr<IDataConvert> m_spConvert;
};

// IDBCreateSessionImpl
template <class T, class SessionClass>
class ATL_NO_VTABLE IDBCreateSessionImpl :
	public IDBCreateSession
{
public:
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(CreateSession)(
		_In_opt_ IUnknown *pUnkOuter,
		_In_ REFIID riid,
		_Deref_out_ IUnknown **ppDBSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBCreateSessionImpl::CreateSession\n"));
		if (ppDBSession == NULL)
			return E_INVALIDARG;
		*ppDBSession = NULL;
		T* pT = (T*)this;
		if (!(pT->m_dwStatus & DSF_INITIALIZED))
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBCreateSessionImpl::CreateSession : Error not initialized\n"));
			*ppDBSession = NULL;
			return E_UNEXPECTED;
		}
		CComPolyObject<SessionClass> *pSession;

		// You can't QI for an interface other than IUnknown when aggregating
		// and creating the object.  You might ask for your own interface,
		// which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
		// CLASS_E_NOAGGREGATION due to OLE DB constraints.
		if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;

		HRESULT hr = CComPolyObject<SessionClass>::CreateInstance(pUnkOuter, &pSession);
		if (SUCCEEDED(hr))
		{
			ATLASSUME(pSession != NULL);
			CComPtr<IObjectWithSite> spCreator;
			hr = pSession->QueryInterface(__uuidof(IObjectWithSite), (void**)&spCreator);
			if (SUCCEEDED(hr))
			{
				CComPtr<IUnknown> spOuterUnk;
				hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
				if (SUCCEEDED(hr))
				{
					hr = spCreator->SetSite(spOuterUnk);
					if (SUCCEEDED(hr))
					{
						hr = pSession->QueryInterface(riid, (void**)ppDBSession);
					}
				}
			}
			else
			{
				delete pSession;
			}
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
};

// IDBInitializeImpl
template <class T>
class ATL_NO_VTABLE IDBInitializeImpl :
	public IDBInitialize
{
public:
	IDBInitializeImpl()
	{
		m_dwStatus = 0;
		m_pCUtlPropInfo = NULL;
		m_cSessionsOpen = 0;
	}
	virtual ~IDBInitializeImpl()
	{
		delete m_pCUtlPropInfo;
	}

	STDMETHOD(Uninitialize)(void)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBInitializeImpl::Uninitialize\n"));
		T* pT = (T*)this;
		T::ObjectLock lock(pT);
		if (pT->m_cSessionsOpen != 0)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Uninitialized called with Open Sessions\n"));
			return DB_E_OBJECTOPEN;
		}
		delete m_pCUtlPropInfo;
		m_pCUtlPropInfo = NULL;
		pT->m_dwStatus |= DSF_PERSIST_DIRTY;
		pT->m_dwStatus &= DSF_MASK_INIT;	// Clear all non-init flags.
		return S_OK;

	}

	DWORD m_dwStatus;
	CUtlPropInfo<T>* m_pCUtlPropInfo;
	LONG m_cSessionsOpen;

	STDMETHOD(Initialize)(void)
	{

		ATLTRACE(atlTraceDBProvider, 2, _T("IDBInitializeImpl::Initialize\n"));
		T *pT = (T*)(this);
		T::ObjectLock lock(pT);
		HRESULT hr;
		if (pT->m_dwStatus & DSF_INITIALIZED)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBInitializeImpl::Initialize Error : Already Initialized\n"));
			return DB_E_ALREADYINITIALIZED;
		}
		delete m_pCUtlPropInfo;
		m_pCUtlPropInfo = NULL;
		ATLTRY(m_pCUtlPropInfo = new CUtlPropInfo<T>())
		if (m_pCUtlPropInfo == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("IDBInitializeImpl::Initialize Error : OOM\n"));
			return E_OUTOFMEMORY;
		}
		hr = m_pCUtlPropInfo->FInit();
		if (hr == S_OK)
		{
			pT->m_dwStatus |= DSF_INITIALIZED;
		}
		else
		{
			delete m_pCUtlPropInfo;
			m_pCUtlPropInfo = NULL;
		}
		return hr;
	}
};


// Implementation Class

class CPropColID :
	public PROPCOLID,
	public CDBIDOps
{
public:
	CPropColID()
	{
		VariantInit(&vValue);
	}
	~CPropColID()
	{
		FreeDBIDs(&dbidProperty);
		VariantClear(&vValue);
	}
	bool operator==(_In_ const CPropColID& colId)
	{
		return (CompareDBIDs(&dbidProperty, &(colId.dbidProperty)) == S_OK) ? true : false;
	}

};

class CColumnIds :
	public CDBIDOps,
	public CAtlArray<CPropColID>
{
public:
	PPROPCOLID AddNode()
	{
		CPropColID colID;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e )
			return NULL;
		}
		return &(GetAt(GetCount()-1));
	}
	HRESULT	RemoveColumnId(_In_ const DBID* pdbidProp)
	{
		for (size_t i = 0; i < GetCount(); i++)
		{
			if (CompareDBIDs(pdbidProp, &(GetAt(i).dbidProperty)) == S_OK)
			{
				if( i < 0 || i >= GetCount() )
					return E_FAIL;
				RemoveAt(i);
				return S_OK;
			}
		}

		return E_FAIL;
	}
	HRESULT	AddColumnId(_In_ DBPROP* pProp)
	{
		CPropColID colID;
		HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pProp->colid));
		if(FAILED(hr))
			return hr;
		colID.dwOption = pProp->dwOptions;
		hr = VariantCopy(&(colID.vValue),&(pProp->vValue));
		if(FAILED(hr))
			return hr;
		//return (Add(colID)) ? S_OK : E_OUTOFMEMORY;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}
	HRESULT	AddColumnId(_In_ PPROPCOLID pPropNode)
	{
		CPropColID colID;
		HRESULT hr = CopyDBIDs(&(colID.dbidProperty),&(pPropNode->dbidProperty));
		if(FAILED(hr))
			return hr;
		colID.dwOption = pPropNode->dwOption;
		hr = VariantCopy(&(colID.vValue),&(pPropNode->vValue));
		if(FAILED(hr))
			return hr;
		//return (Add(colID)) ? S_OK : E_OUTOFMEMORY;
		_ATLTRY
		{
			Add(colID);
		}
		_ATLCATCH( e )
		{
			_ATLDELETEEXCEPTION( e );
			return E_OUTOFMEMORY;
		}
		return S_OK;
	}
	ULONG GetCountOfPropColids()
	{
		return (ULONG)GetCount();
	}
	PPROPCOLID FindColumnId(_In_ const DBID* pdbidProp)
	{
		for (size_t i = 0; i < GetCount(); i++)
		{
			if (CompareDBIDs(pdbidProp, &(GetAt(i).dbidProperty)) == S_OK)
				return &(GetAt(i));
		}

		return NULL;
	}
	HRESULT GetValue(
		_In_ size_t iColId,
		_Out_ DWORD* pdwOptions,
		_Out_ DBID* pColid,
		_Out_ VARIANT* pvValue)
	{
		ATLENSURE_RETURN(pdwOptions && pColid && pvValue);
		ATLASSERT(iColId >= 0 && iColId < GetCount());

		CPropColID& colId = GetAt(iColId);
		*pdwOptions = colId.dwOption;
		HRESULT hr = CopyDBIDs( pColid, &(colId.dbidProperty) );
		if(FAILED(hr) || hr == S_FALSE)
		{
			return hr;
		}
		if(FAILED(hr = VariantCopy(pvValue, &(colId.vValue))))
			return hr;
		return S_OK;
	}
};

const ULONG		cchDescBuffSize = 256;
const DWORD		DBINTERNFLAGS_CHANGED		= 0x00000001;
// Rules for GetPropertiesArgChk
const DWORD		ARGCHK_PROPERTIESINERROR	= 0x00000001;

// Implementation Class
template <class T>
class CUtlPropInfo :
	public CBitFieldOps,
	public CDBIDOps
{
public:
	enum EnumGetPropInfo
	{
		GETPROPINFO_ALLPROPIDS		= 0x0001,
		GETPROPINFO_NOTSUPPORTED	= 0x0002,
		GETPROPINFO_ERRORSOCCURRED	= 0x0004,
		GETPROPINFO_VALIDPROP		= 0x0008
	};

	CUtlPropInfo()
	{
		m_cUPropSet		 = 0;
		m_pUPropSet		 = NULL;
		m_cPropSetDex	= 0;
		m_cElemPerSupported = 0;
	}
	~CUtlPropInfo()
	{
		CoTaskMemFree(m_pUPropSet);
	}

	//Determine the number of description buffers needed
	ULONG CalcDescripBuffers(
		_In_ ULONG cPropInfoSet,
		_In_count_(cPropInfoSet) DBPROPINFOSET* pPropInfoSet)
	{
		ULONG	cBuffers = 0;

		ATLASSUME(m_pUPropSet);
		ATLENSURE(cPropInfoSet && pPropInfoSet);

		for(ULONG ulSet=0; ulSet<cPropInfoSet; ulSet++)
		{
			if( GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_OK)
			{
				if( pPropInfoSet[ulSet].cPropertyInfos == 0 )
				{
					for(ULONG ul=0; ul<m_cPropSetDex; ul++)
					{
						cBuffers += m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo;
					}
				}
				else
				{
					cBuffers += pPropInfoSet[ulSet].cPropertyInfos;
				}
			}
		}

		return cBuffers;
	}
	//Retrieve the property set indexes that match this property set.
	HRESULT	GetPropertySetIndex(_In_ const GUID* pPropertySet)
	{
		DWORD	dwFlag = 0;
		ULONG	ulSet;

		ATLASSUME(m_cUPropSet && m_pUPropSet);
		ATLASSUME(m_rgiPropSetDex);
		ATLASSERT(pPropertySet);

		m_cPropSetDex = 0;

		if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEALL))
		{
			dwFlag = DBPROPFLAGS_DATASOURCE;
		}
		else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_DATASOURCEINFOALL))
		{
			dwFlag = DBPROPFLAGS_DATASOURCEINFO;
		}
		else if(InlineIsEqualGUID(*pPropertySet, DBPROPSET_ROWSETALL))
		{
			dwFlag = DBPROPFLAGS_ROWSET;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_DBINITALL))
		{
			dwFlag = DBPROPFLAGS_DBINIT;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_SESSIONALL))
		{
			dwFlag = DBPROPFLAGS_SESSION;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_COLUMNALL))
		{
			dwFlag = DBPROPFLAGS_COLUMN;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_INDEXALL))
		{
			dwFlag = DBPROPFLAGS_INDEX;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_TABLEALL))
		{
			dwFlag = DBPROPFLAGS_TABLE;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_TRUSTEEALL))
		{
			dwFlag = DBPROPFLAGS_TRUSTEE;
		}
		else if(InlineIsEqualGUID(*pPropertySet,DBPROPSET_VIEWALL))
		{
			dwFlag = DBPROPFLAGS_VIEW;
		}
		else // No scan required, just look for match.
		{
			for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
			{
				if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
				{
					m_rgiPropSetDex[m_cPropSetDex] = ulSet;
					m_cPropSetDex++;
					break;
				}
			}
			goto EXIT;
		}

		// Scan through the property sets looking for matching attributes
		for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
		{
			if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
			{
				m_rgiPropSetDex[m_cPropSetDex] = ulSet;
				m_cPropSetDex++;
			}
		}

	EXIT:
		return (m_cPropSetDex) ? S_OK : S_FALSE;

	}
	//Retrieve the property id pointer
	HRESULT	GetUPropInfoPtr(
		_In_ ULONG iPropSetDex,
		_In_ DBPROPID dwPropertyId,
		_Deref_out_ UPROPINFO** ppUPropInfo)
	{
		// Scan through the property sets looking for matching attributes
		for(ULONG ulProps=0; ulProps<m_pUPropSet[iPropSetDex].cUPropInfo; ulProps++)
		{
			if( m_pUPropSet[iPropSetDex].pUPropInfo[ulProps].dwPropId == dwPropertyId )
			{
				*ppUPropInfo = &(m_pUPropSet[iPropSetDex].pUPropInfo[ulProps]);
				// Test to see if the property is supported for this
				// instantiation
				return (TESTBIT(&(m_rgdwSupported[iPropSetDex * m_cElemPerSupported]), ulProps)) ? S_OK : S_FALSE;
			}
		}
		return S_FALSE;
	}
	HRESULT	FInit(_In_ GUID* pguidSet = (GUID*)&GUID_NULL)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		HRESULT hr = InitAvailUPropSets(&m_cUPropSet, &m_pUPropSet, &m_cElemPerSupported, pguidSet);
		if (FAILED(hr))
			return hr;
		ATLASSERT((m_cUPropSet != 0) && (m_cElemPerSupported != 0));
		if(!m_cUPropSet || !m_cElemPerSupported)
			return E_FAIL;

		ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
		if(m_rgdwSupported == NULL)
		{
			m_cUPropSet=0;
			m_cElemPerSupported=0;
			return E_OUTOFMEMORY;
		}

		if(FAILED(hr = InitUPropSetsSupported()))
		{
			m_cUPropSet=0;
			m_cElemPerSupported=0;
			m_rgdwSupported.Free();
			return hr;
		}
		if(m_cUPropSet)
		{
			ATLTRY(m_rgiPropSetDex.Allocate(m_cUPropSet))
			if(m_rgiPropSetDex == NULL)
			{
				m_cUPropSet=0;
				m_cElemPerSupported=0;
				m_rgdwSupported.Free();
				return E_OUTOFMEMORY;
			}
		}
		return S_OK;
	}
	HRESULT	GetPropertyInfo(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPIDSET rgPropertySets[],
		_Out_ ULONG* pcPropertyInfoSets,
		_Out_opt_ _Deref_post_cap_(*pcPropertyInfoSets) DBPROPINFOSET**	prgPropertyInfoSets,
		_Deref_opt_out_z_ WCHAR** ppDescBuffer,
		_In_ bool bInitialized = true,
		_In_opt_ const GUID* pGuid = NULL)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		HRESULT	hr = S_OK;
		ULONG ul, ulSet, ulNext, ulEnd;
		ULONG ulOutIndex;
		ULONG cSets;
		ULONG cPropInfos;
		//ULONG ulIndex = 0;
		ULONG cBuffers = 0;
		DWORD dwStatus = 0;
		DBPROPINFO*	pPropInfo = NULL;
		DBPROPINFO*	pCurPropInfo = NULL;
		WCHAR* pDescBuffer = NULL;
		WCHAR* pDescBufferEnd = NULL;
		DBPROPINFOSET* pPropInfoSet = NULL;
		UPROPINFO* pUPropInfo = NULL;
		WCHAR wszBuff[256];
		int	cch;
		CAtlArray<ULONG> rgInitPropsetIndexes;

		// If the consumer does not restrict the property sets
		// by specify an array of property sets and a cPropertySets
		// greater than 0, then we need to make sure we
		// have some to return
		if(cPropertySets == 0)
		{
			// Determine the number of property sets supported
			// In this case, it usually the enumerator or data source asking for
			// DBPROPSET_DBINIT information.

			if (pGuid != NULL)
			{
				// Need to determine if there are any UPROPSET_USERINIT sets here
				// they should be added to DBINIT.
				ULONG ulUserInitSets = 0;
				for (ULONG l=0; l<m_cUPropSet; l++)
					if (m_pUPropSet[l].dwFlags & UPROPSET_USERINIT)
						ulUserInitSets++;

				cSets = 1 + ulUserInitSets;		// one for DBINIT which is required
			}
			else
			{
				cSets = m_cUPropSet;
			}
		}
		else
		{
			cSets = 0;

			// Determine number of property sets required
			// This is only required when any of the "special" property set GUIDs were specified
			for(ulSet=0; ulSet<cPropertySets; ulSet++)
			{
				if (GetPropertySetIndex(&(rgPropertySets[ulSet].guidPropertySet)) == S_OK)
					cSets += m_cPropSetDex;
				else
					cSets++;
			}
		}
		ATLASSERT(cSets);

		// Allocate the DBPROPINFOSET structures
		pPropInfoSet = (DBPROPINFOSET*)::ATL::AtlCoTaskMemCAlloc(cSets, static_cast<ULONG>(sizeof(DBPROPINFOSET)));
		if(pPropInfoSet == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Could not allocate DBPROPSET array for GetProperties\n"));
			hr =  E_OUTOFMEMORY;
			goto EXIT;
		}

		memset(pPropInfoSet, 0, cSets * sizeof(DBPROPINFOSET));

		ulOutIndex = 0;
		ULONG ulTempPropsetIndex = 0;
		ulEnd = cPropertySets == 0 ? cSets : cPropertySets;
		// Fill in the output array
		for(ulSet=0; ulSet<ulEnd; ulSet++)
		{
 			// Depending of if Property sets are specified store the
			// return property set.
			if (cPropertySets == 0)
			{
				if (pGuid != NULL)
				{
					// Need to change this: set the guidPropertySet to the maching
					// initialization property group (not DBINITALL).
					for (ULONG ulCurrentInitSet = ulTempPropsetIndex; ulCurrentInitSet < m_cUPropSet; ulCurrentInitSet++)
					{
						// We need to locate either the DBINIT or USERINIT property sets here
						// and set the property set index up correctly.
						if (InlineIsEqualGUID(*(m_pUPropSet[ulCurrentInitSet].pPropSet), DBPROPSET_DBINIT) ||
							(m_pUPropSet[ulCurrentInitSet].dwFlags & UPROPSET_USERINIT))
						{
							rgInitPropsetIndexes.Add(ulCurrentInitSet);
							ulTempPropsetIndex = ulCurrentInitSet + 1;
							//ulIndex = ulCurrentInitSet;
							//pPropInfoSet[ulSet].guidPropertySet = *pGuid;
							pPropInfoSet[ulSet].guidPropertySet = *(m_pUPropSet[ulCurrentInitSet].pPropSet);
							GetPropertySetIndex(&pPropInfoSet[ulSet].guidPropertySet);	// Need to set the m_cPropSetDex variable
							break;
						}
					}
					//if (ulCurrentInitSet == m_cUPropSet)
					//{
					//	ulIndex = 0;
					//}

				}
				else
				{
					pPropInfoSet[ulSet].guidPropertySet = *(m_pUPropSet[ulSet].pPropSet);
				}
			}
			else
			{
				GUID const& guidSet = rgPropertySets[ulSet].guidPropertySet;
				if( (InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_DATASOURCEINFOALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_DBINITALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_SESSIONALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_COLUMNALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_CONSTRAINTALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_INDEXALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_TABLEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_TRUSTEEALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_VIEWALL) ||
					InlineIsEqualGUID(guidSet, DBPROPSET_ROWSETALL)) &&
					GetPropertySetIndex(&guidSet) == S_OK )
				{
					for(ul=0; ul<m_cPropSetDex; ul++,ulOutIndex++)
					{
						pPropInfoSet[ulOutIndex].guidPropertySet	= *(m_pUPropSet[m_rgiPropSetDex[ul]].pPropSet);
						pPropInfoSet[ulOutIndex].cPropertyInfos		= 0;
					}
				}
				else
				{
					// Handle non-category property sets
					// Handle unknown property sets
					pPropInfoSet[ulOutIndex].guidPropertySet = guidSet;
					pPropInfoSet[ulOutIndex].cPropertyInfos	 = rgPropertySets[ulSet].cPropertyIDs;
					ulOutIndex++;
				}
			}
		}

		// Allocate a Description Buffer if needed
		if( ppDescBuffer )
		{
			cBuffers = CalcDescripBuffers(cSets, pPropInfoSet);
			if( cBuffers != 0 )
			{
				const SIZE_T uDescBuffersElementSize = cBuffers * cchDescBuffSize;
				const SIZE_T uDescBuffersByteSize = uDescBuffersElementSize * sizeof(WCHAR);
				if (uDescBuffersByteSize / (cchDescBuffSize * sizeof(WCHAR)) != cBuffers)
				{
					hr = E_FAIL;
					goto EXIT;
				}
				pDescBuffer = (WCHAR*)CoTaskMemAlloc(uDescBuffersByteSize);
				if(pDescBuffer == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;
				}
				*ppDescBuffer = pDescBuffer;
				pDescBufferEnd = pDescBuffer + uDescBuffersElementSize;
				wmemset(pDescBuffer, 0, uDescBuffersElementSize);
			}
		}

		// Process requested or derived Property sets
		dwStatus = 0;
		for(ulSet=0; ulSet<cSets; ulSet++)
		{
			ulNext=0;
			cPropInfos = 0;
			pPropInfo = NULL;
			dwStatus &= (GETPROPINFO_ERRORSOCCURRED | GETPROPINFO_VALIDPROP);

			// Calculate the number of property nodes needed for this
			// property set.
			if( cPropertySets == 0 )
			{
				ULONG ulTempSet;
				if (pGuid != NULL)
				{
					ATLASSERT( ulSet < rgInitPropsetIndexes.GetCount() );
					ulTempSet = rgInitPropsetIndexes[ulSet]; // ulIndex;
				}
				else
					ulTempSet = ulSet;

				cPropInfos = m_pUPropSet[ulTempSet].cUPropInfo;
				dwStatus |= GETPROPINFO_ALLPROPIDS;
				m_rgiPropSetDex[0] = ulTempSet;
				m_cPropSetDex = 1;
				_ATLDUMPPROPSETIID(*m_pUPropSet[ulTempSet].pPropSet, dwStatus);
			}
			else
			{
				// If the count of PROPIDs is 0 (NOTE: the above routine already determined
				// if it belonged to a category and if so set the count of properties to 0 for
				// each propset in that category.
				if( pPropInfoSet[ulSet].cPropertyInfos == 0 )
				{
					dwStatus |= GETPROPINFO_ALLPROPIDS;
					// We have to determine if the property set is supported and if so
					// the count of properties in the set.
					if( (GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_FALSE)
						|| (!bInitialized &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINIT)) &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINITALL))))
					{
						dwStatus |= GETPROPINFO_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
						goto NEXT_SET;
					}
					else
					{
						ATLASSUME( m_cPropSetDex == 1 );
						cPropInfos += m_pUPropSet[m_rgiPropSetDex[0]].cUPropInfo;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
					}
				}
				else
				{
					// We also handle the case here where the user has requested
					// a non-initialization group property info set while the
					// provider is not initialized.  In this case, properties should
					// not be set.
					cPropInfos = pPropInfoSet[ulSet].cPropertyInfos;
					if( (GetPropertySetIndex(&(pPropInfoSet[ulSet].guidPropertySet)) == S_FALSE)
						|| (!bInitialized &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINIT)) &&
						!(InlineIsEqualGUID(pPropInfoSet[ulSet].guidPropertySet, DBPROPSET_DBINITALL))))
					{
						dwStatus |= GETPROPINFO_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropInfoSet[ulSet].guidPropertySet, dwStatus);
					}
				}
			}

			// Allocate DBPROP array
			ATLASSERT( cPropInfos != 0 );
			pPropInfo = (DBPROPINFO*)::ATL::AtlCoTaskMemCAlloc(cPropInfos, static_cast<ULONG>(sizeof(DBPROPINFO)));
			if( pPropInfo )
			{
				// Initialize Buffer
				memset(pPropInfo, 0, cPropInfos * sizeof(DBPROPINFO));
				for(ULONG ulProp=0; ulProp<cPropInfos; ulProp++)
				{
					VariantInit(&(pPropInfo[ulProp].vValues));
					if( dwStatus & GETPROPINFO_NOTSUPPORTED )
					{
						// Not supported, thus we need to mark all as NOT_SUPPORTED
						pPropInfo[ulProp].dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pPropInfo[ulProp].dwFlags = DBPROPFLAGS_NOTSUPPORTED;
						dwStatus |= GETPROPINFO_ERRORSOCCURRED;
						_ATLDUMPPROPERTY(pPropInfo[ulProp].dwPropertyID, pPropInfo[ulProp].dwFlags);
					}
				}
				// Make sure we support the property set
				if( dwStatus & GETPROPINFO_NOTSUPPORTED )
				{
					ulNext = cPropInfos;
					goto NEXT_SET;
				}

				// Retrieve the property information for this property set
				for(ul=0; ul<m_cPropSetDex; ul++)
				{
					pUPropInfo = (m_pUPropSet[m_rgiPropSetDex[ul]].pUPropInfo);
					ATLENSURE_RETURN( pUPropInfo );

					// Retrieve current value of properties
					if( dwStatus & GETPROPINFO_ALLPROPIDS )
					{
						for(ULONG ulProp=0; ulProp<m_pUPropSet[m_rgiPropSetDex[ul]].cUPropInfo; ulProp++)
						{
							// Verify property is supported, if not do not return
							if( !TESTBIT(&(m_rgdwSupported[m_rgiPropSetDex[ul] * m_cElemPerSupported]), ulProp) )
								continue;

							pCurPropInfo = &(pPropInfo[ulNext]);

							// If the ppDescBuffer pointer was not NULL, then
							// we need supply description of the properties
							if( ppDescBuffer )
							{
								// Set Buffer pointer
								pCurPropInfo->pwszDescription = pDescBuffer;

								// Load the string into temp buffer
								cch = LoadDescription(pUPropInfo[ulProp].ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
								if( cch )
								{
									// Adjust for '\0'
									cch++;

									// Transfer to official buffer if room
									if (pDescBuffer > pDescBufferEnd)
									{
										return E_FAIL;
									}
									Checked::memcpy_s(pDescBuffer, (pDescBufferEnd-pDescBuffer)*sizeof(WCHAR), wszBuff, cch * sizeof(WCHAR));
									pDescBuffer += cch;
								}
								else
								{
									if(pDescBuffer > pDescBufferEnd)
									{
										return E_FAIL;
									}
									Checked::wcscpy_s(pDescBuffer, pDescBufferEnd-pDescBuffer, L"UNKNOWN");
									pDescBuffer += (wcslen(L"UNKNOWN") + 1);
									_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, ATLDB_NO_STRING);
								}
							}

							pCurPropInfo->dwPropertyID = pUPropInfo[ulProp].dwPropId;

							// Strip out any user defined flags that may be around.  Note,
							// this isn't a full-proof thing because properties change.  It
							// won't work in OLE DB 2.5 if someone does a property like 0x40000
							DWORD dwFlags = pUPropInfo[ulProp].dwFlags & 0xfffff;

							pCurPropInfo->dwFlags = dwFlags;
							pCurPropInfo->vtType = pUPropInfo[ulProp].VarType;
							pCurPropInfo->vValues.vt = VT_EMPTY;

							dwStatus |= GETPROPINFO_VALIDPROP;
							// Increment to next available buffer
							ulNext++;
							_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, pCurPropInfo->dwFlags);
						}
					}
					else
					{
						ATLASSUME( m_cPropSetDex == 1 );
						ULONG cIterations = ((cPropInfos>cBuffers) && (ppDescBuffer)) ? cBuffers : cPropInfos;

						for( ULONG ulProp = 0; ulProp < cIterations; ulProp++, ulNext++ )
						{
							pCurPropInfo = &(pPropInfo[ulNext]);

							// Process Properties based on Restriction array.
							pCurPropInfo->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];

							if( GetUPropInfoPtr(m_rgiPropSetDex[ul], pCurPropInfo->dwPropertyID, &pUPropInfo)
								== S_OK )
							{
								// If the ppDescBuffer pointer was not NULL, then
								// we need supply description of the properties
								if( ppDescBuffer )
								{
									// Set Buffer pointer
									pCurPropInfo->pwszDescription = pDescBuffer;

									// Load the string into temp buffer
									cch = LoadDescription(pUPropInfo->ulIDS, wszBuff, (sizeof(wszBuff)/sizeof(*wszBuff)));
									if( cch )
									{
										// Adjust for '\0'
										cch++;

										// Transfer to official buffer if room
										if(pDescBuffer > pDescBufferEnd)
											return E_FAIL;
										Checked::memcpy_s(pDescBuffer, (pDescBufferEnd-pDescBuffer)*sizeof(WCHAR), wszBuff, cch * sizeof(WCHAR));
										pDescBuffer += cch;
									}
									else
									{
										if(pDescBuffer > pDescBufferEnd)
										{
											return E_FAIL;
										}
										Checked::wcscpy_s(pDescBuffer, pDescBufferEnd-pDescBuffer, L"UNKNOWN");
										pDescBuffer += (wcslen(L"UNKNOWN") + 1);
										_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, ATLDB_NO_STRING);
									}
								}

								pCurPropInfo->dwPropertyID = pUPropInfo->dwPropId;

								// Strip out any user defined flags that may be around.  Note,
								// this isn't a full-proof thing because properties change.  It
								// won't work in OLE DB 2.5 if someone does a property like 0x40000
								DWORD dwFlags = pUPropInfo->dwFlags & 0xfffff;

								pCurPropInfo->dwFlags = dwFlags;
								pCurPropInfo->vtType = pUPropInfo->VarType;

								dwStatus |= GETPROPINFO_VALIDPROP;
							}
							else
							{
								// Not Supported
								pCurPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
								dwStatus |= GETPROPINFO_ERRORSOCCURRED;
							}
							_ATLDUMPPROPERTY(pCurPropInfo->dwPropertyID, pCurPropInfo->dwFlags);
						}
					}
				}
			}
			else
			{
				hr = E_OUTOFMEMORY;
				goto EXIT;
			}

NEXT_SET:
			pPropInfoSet[ulSet].cPropertyInfos = ulNext;
			pPropInfoSet[ulSet].rgPropertyInfos = pPropInfo;
		}

		// Success, set return values
		*pcPropertyInfoSets = cSets;
		*prgPropertyInfoSets = pPropInfoSet;

		// At least one propid was marked as not S_OK
		if( dwStatus & GETPROPINFO_ERRORSOCCURRED )
		{
			// If at least 1 property was set
			if( dwStatus & GETPROPINFO_VALIDPROP )
				return DB_S_ERRORSOCCURRED;
			else
			{
				// Do not free any of the rgPropertyInfoSets, but
				// do free the ppDescBuffer
				if( pDescBuffer )
				{
					ATLASSERT( ppDescBuffer );
					CoTaskMemFree(pDescBuffer);
					*ppDescBuffer = NULL;
				}
				return DB_E_ERRORSOCCURRED;
			}
		}

		return S_OK;
EXIT:
		// Check if failure and clean up any allocated memory
		if( FAILED(hr) &&
			(hr != DB_E_ERRORSOCCURRED) )
		{
			// Free Description Buffer
			if( pDescBuffer )
			{
				ATLASSERT( ppDescBuffer );

				CoTaskMemFree(pDescBuffer);
				*ppDescBuffer = NULL;
			}

			if( pPropInfoSet )
			{
				// Loop through Property Sets
				for(ulSet=0; ulSet<cSets; ulSet++)
					CoTaskMemFree(pPropInfoSet[ulSet].rgPropertyInfos);
				CoTaskMemFree(pPropInfoSet);
			}
		}

		return hr;
	}

	CComAutoCriticalSection m_oCriticalSection; // critical section to synchronize access to the class
	ULONG m_cUPropSet; //count of UPropSet items
	UPROPSET* m_pUPropSet; //Pointer to UPropset items
	ULONG m_cPropSetDex; 	//count of UPropSet Indexes
	CAutoVectorPtr<ULONG> m_rgiPropSetDex;//array of UPropSet Index values
	ULONG m_cElemPerSupported; //number of DWORDS per UPropSet to indicate supported UPropIds
	CAutoVectorPtr<DWORD> m_rgdwSupported;//array of DWORDs indicating supported UPropIds

	enum EnumUPropSetFlags
	{
		UPROPSET_HIDDEN				= 0x1,
		UPROPSET_PASSTHROUGH		= 0x2,
		UPROPSET_USERINIT			= 0x4
	};

	HRESULT	InitAvailUPropSets(
		_Out_ ULONG* pcUPropSet,
		_Out_ _Deref_post_opt_cap_(*pcUPropSet) UPROPSET** ppUPropSet,
		_Out_ ULONG* pcElemPerSupported,
		_Out_opt_ GUID* pguid)
	{
		ATLENSURE_RETURN(pcUPropSet && ppUPropSet);
		CoTaskMemFree(*ppUPropSet);
		*ppUPropSet = NULL;
		int cSets = (int)(ULONG_PTR)T::_GetPropSet(NULL, pcElemPerSupported);
		UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pSet == NULL)
		{
			*pcUPropSet=0;
			*ppUPropSet=NULL;
			*pcElemPerSupported=0;
			return E_OUTOFMEMORY;
		}
		*ppUPropSet = T::_GetPropSet(pcUPropSet, pcElemPerSupported, pSet, pguid);
		return S_OK;
	}
	OUT_OF_LINE HRESULT	InitUPropSetsSupported()
	{
		ULONG cPropSet = 0, cElemsPerSupported = 0;
		int cSets = (int)(ULONG_PTR)T::_GetPropSet(NULL, &cElemsPerSupported);
		UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pSet == NULL)
			return E_OUTOFMEMORY;
		pSet = T::_GetPropSet(&cPropSet, &cElemsPerSupported, pSet);
		memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
		CoTaskMemFree(pSet);
		return S_OK;
	}
	//Load a localized description
	int	LoadDescription(
		_In_ ULONG ids,
		_Out_z_cap_post_count_(cchBuff, return + 1) PWSTR pwszBuff,
		_In_ ULONG cchBuff)
	{
		USES_CONVERSION_EX;
		CTempBuffer<TCHAR> tmpBuffer;
		TCHAR* pszBuf = tmpBuffer.Allocate(cchBuff);
		if (pszBuf == NULL)
			return 0;
		int nTemp = LoadString(_AtlBaseModule.GetResourceInstance(), ids, pszBuf, cchBuff);
		if (nTemp != 0)
		{
			Checked::wcscpy_s(pwszBuff, cchBuff, SAL_Assume_notnull_for_opt_z_(T2W_EX_DEF(pszBuf)));
		}
		return nTemp;
	}
};

class ATL_NO_VTABLE CUtlPropsBase :
	public CBitFieldOps,
	public CDBIDOps
{
public:

	virtual ~CUtlPropsBase()
	{
	}

	CComAutoCriticalSection m_oCriticalSection; // critical section to synchronize access to the class
	ULONG m_cUPropSet; //count of UPropSet items
	UPROPSET* m_pUPropSet; //Pointer to UPropset items
	CAutoVectorPtr< UPROP > m_pUProp;
	ULONG m_cUPropSetHidden; //Count of Hidden items
	DWORD m_dwFlags; //Configuration flags
	ULONG m_cPropSetDex; //count of UPropSet Indexes
	CAutoVectorPtr< ULONG > m_rgiPropSetDex; //pointer to Array of UPropSet Index values
	ULONG m_cElemPerSupported;//number of DWORDS per UPropSet to indicate supported UPropIds
	CAutoVectorPtr< DWORD > m_rgdwSupported; //pointer to array of DWORDs indicating supported UPropIds
	CAutoVectorPtr< DWORD > m_rgdwPropsInError;//pointer to array of DWORDs indicating if property is in error

	enum EnumUPropSetFlags
	{
		UPROPSET_HIDDEN				= 0x1,
		UPROPSET_PASSTHROUGH		= 0x2,
		UPROPSET_USERINIT			= 0x4
	};
	enum EnumGetProp
	{
		GETPROP_ALLPROPIDS			= 0x0001,
		GETPROP_NOTSUPPORTED		= 0x0002,
		GETPROP_ERRORSOCCURRED		= 0x0004,
		GETPROP_VALIDPROP			= 0x0008,
		GETPROP_PROPSINERROR		= 0x0010
	};

	enum EnumSetProp
	{
		SETPROP_BADOPTION			= 0x0001,
		SETPROP_NOTSUPPORTED		= 0x0002,
		SETPROP_VALIDPROP			= 0x0004,
		SETPROP_ERRORS				= 0x0008,
		SETPROP_COLUMN_LEVEL		= 0x0010,
		SETPROP_WAS_REQUIRED		= 0x0020
	};

	HRESULT	SetPassThrough(_In_ const DBPROPSET* pPropSet)
	{
		ATLENSURE_RETURN(pPropSet);

		DBPROP*	pProp = pPropSet->rgProperties;

		//Default implementation just sets all properties as NOTSUPPORTED
		for( ULONG ul=0; ul<pPropSet->cProperties; ul++, pProp++ )
			pProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;

		return DB_E_ERRORSOCCURRED;
	}

	HRESULT	GetIndexofPropIdinPropSet(
		_In_ ULONG iCurSet,
		_In_ DBPROPID dwPropertyId,
		_Out_ ULONG* piCurPropId)
	{
		ATLENSURE_RETURN(piCurPropId);
		UPROPINFO* pUPropInfo = m_pUPropSet[iCurSet].pUPropInfo;
		for(ULONG ul=0; ul<m_pUPropSet[iCurSet].cUPropInfo; ul++)
		{
			if( dwPropertyId == pUPropInfo[ul].dwPropId )
			{
				*piCurPropId = ul;
				// Test to see if the property is supported for this
				// instantiation
				return (TESTBIT(&(m_rgdwSupported[iCurSet * m_cElemPerSupported]), ul)) ? S_OK : S_FALSE;
			}
		}

		return S_FALSE;
	}

	virtual HRESULT	IsValidValue(
		_In_ ULONG /*iCurSet*/,
		_In_ DBPROP* pDBProp)
	{
		ATLENSURE_RETURN(pDBProp != NULL);
		CComVariant var = pDBProp->vValue;
		if (var.vt == VT_BOOL)
		{
			if (var.boolVal != ATL_VARIANT_TRUE && var.boolVal != ATL_VARIANT_FALSE)
				return S_FALSE;
		}

		return S_OK;
	}

	virtual HRESULT OnInterfaceRequested(_In_ REFIID riid)
	{
		// This function exists as part of the change in the OLE DB spec.  If
		// a consumer opens an object and requests an optional interface, the
		// provider should automatically set the property representating that
		// interface to true.
		CDBPropSet propset(DBPROPSET_ROWSET);
		const GUID* ppGuid[1];
		ppGuid[0] = &DBPROPSET_ROWSET;

		if (InlineIsEqualGUID(riid, __uuidof(IRowsetChange)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetChange, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetUpdate)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetUpdate, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetLocate)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetLocate, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IConnectionPointContainer)))
		{
			if(!propset.AddProperty(DBPROP_IConnectionPointContainer, true))
			{
				return E_FAIL;
			}
		}
		else if (InlineIsEqualGUID(riid, __uuidof(IRowsetScroll)))
		{
			if(!propset.AddProperty(DBPROP_IRowsetScroll, true))
			{
				return E_FAIL;
			}
		}

		if (propset.cProperties > 0)
			return SetProperties(0, 1, &propset, 1, ppGuid);

		return S_OK;
	}

	virtual HRESULT OnPropertyChanged(
		_In_ ULONG /*iCurSet*/,
		_In_ DBPROP* /*pDBProp*/) = 0;

ATLPREFAST_SUPPRESS(6014)
	/* prefast noise VSW 498981 */
	HRESULT	SetProperty(
		_In_ ULONG iCurSet,
		_In_ ULONG iCurProp,
		_Inout_ DBPROP* pDBProp)
	{
		HRESULT	hr = S_OK;
		UPROP* pUProp;
		UPROPVAL* pUPropVal;
		UPROPINFO* pUPropInfo;
		ULONG iUProp;

		ATLENSURE_RETURN( pDBProp );

		// Set pointer to correct set
		pUProp = &(m_pUProp[iCurSet]);
		ATLENSURE_RETURN( pUProp );

		pUPropInfo = &(m_pUPropSet[iCurSet].pUPropInfo[iCurProp]);
		ATLENSURE_RETURN( pUPropInfo );

		// Determine the index within m_pUProp
		for(iUProp=0; iUProp<pUProp->cPropIds; iUProp++)
		{
			if( (pUProp->rgpUPropInfo[iUProp])->dwPropId == pDBProp->dwPropertyID )
				break;
		}

		if( iUProp >= pUProp->cPropIds )
		{
			ATLASSERT( !"Should have found index of property to set" );
			hr = E_FAIL;
			pDBProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
			goto EXIT;
		}

		//Get the UPROPVAL node pointer within that propset.
		pUPropVal = &(pUProp->pUPropVal[iUProp]);
		ATLENSURE_RETURN( pUPropVal );

		// Handle VT_EMPTY, which indicates to the provider to
		// reset this property to the providers default
		if( pDBProp->vValue.vt == VT_EMPTY )
		{
			if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
			{
				// Remove any nodes, because the default applies to
				// all columns
				delete pUPropVal->pCColumnIds;
				pUPropVal->pCColumnIds = NULL;
			}

			// Should clear here, since previous values may already
			// have been cached and need to be replaced.
			VariantClear(&(pUPropVal->vValue));

			pUPropVal->dwFlags &= ~DBINTERNFLAGS_CHANGED;
			hr = GetDefaultValue(iCurSet, pDBProp->dwPropertyID,
				&(pUPropVal->dwOption), &(pUPropVal->vValue));

			goto EXIT;
		}

		// Column Level
		if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
		{
			// Check to see if it applies to all
			if( (CompareDBIDs(&(pDBProp->colid), &DB_NULLID) == S_OK) )
			{
				// Remove the Columns Storage object
				delete pUPropVal->pCColumnIds;
				pUPropVal->pCColumnIds = NULL;
				pUPropVal->dwOption = pDBProp->dwOptions;
				if( FAILED(hr = VariantCopy(&(pUPropVal->vValue),
					&(pDBProp->vValue))) )
					goto EXIT;
				pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
			}
			else // Does not apply to all columns
			{
				if( pUPropVal->pCColumnIds == NULL )
				{
					ATLTRY(pUPropVal->pCColumnIds = new CColumnIds)
				}

				if( pUPropVal->pCColumnIds )
				{
					if( FAILED(hr = (pUPropVal->pCColumnIds)->AddColumnId(pDBProp)) )
						goto EXIT;
					pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
				}
				else
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;
				}
			}
		}
		else
		{
			// Set for non-column level properties
			pUPropVal->dwOption = pDBProp->dwOptions;

			// Our provider has no limit on the maximum number of rows
			// that can have pending changes, therefore the value of the
			// DBPROP_MAXPENDINGROWS property will always be zero (default),
			// regardless of what the user attempts to set it to.
			// In the code below, we modify the property value only if
			// this is not the DBPROP_MAXPENDINGROWS property.
			if( pDBProp->dwPropertyID != DBPROP_MAXPENDINGROWS )
			{
				if( FAILED(hr = VariantCopy(&(pUPropVal->vValue),
					&(pDBProp->vValue))) )
					goto EXIT;
			}
			if( FAILED(hr = OnPropertyChanged(iCurSet, pDBProp)))
				goto EXIT;
			pUPropVal->dwFlags |= DBINTERNFLAGS_CHANGED;
		}

EXIT:
		if( hr == S_OK )
			pDBProp->dwStatus = DBPROPSTATUS_OK;

		return hr;
	}
ATLPREFAST_UNSUPPRESS()

	HRESULT	SetProperties(
		_In_ const DWORD /*dwStatus*/,
		_In_ const ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPSET rgPropertySets[],
		_In_ const ULONG cSelectProps = 1,
		_In_count_(cSelectProps) const GUID* const ppGuid[] = NULL,
		_In_ bool bIsCreating = false)
	{
		DWORD dwState = 0;
		ULONG ulCurSet, ulCurProp, ulProp;
		DBPROP*	rgDBProp;
		UPROPINFO* pUPropInfo;
		CComVariant vDefaultValue;
		DWORD dwOption;

		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		// ppGuid specifies the property sets that the consumer can set based
		// on the interface that called this function.
		ATLENSURE_RETURN(ppGuid != NULL);

		if ((cPropertySets != 0) && (rgPropertySets == NULL))
			return E_INVALIDARG;

		// Process property sets
		for(ULONG ulSet=0; ulSet<cPropertySets; ulSet++)
		{
			if ((rgPropertySets[ulSet].cProperties != 0) && (rgPropertySets[ulSet].rgProperties == NULL))
				return E_INVALIDARG;

			bool bAvailable = false;
			for (ULONG l=0; l<cSelectProps; l++)
			{
				if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
					bAvailable |= true;
			}

			// Make sure we support the property set
			if( !bAvailable ||
				(GetIndexofPropSet(&(rgPropertySets[ulSet].guidPropertySet), &ulCurSet) == S_FALSE ))
			{
				// Not supported, thus we need to mark all as NOT_SUPPORTED
				rgDBProp = rgPropertySets[ulSet].rgProperties;
				for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
					_ATLDUMPPROPSETIID(rgPropertySets[ulSet].guidPropertySet, dwState);
				}
				continue;
			}

			// Handle property sets marked as pass through
			if( m_pUPropSet[ulCurSet].dwFlags & UPROPSET_PASSTHROUGH )
			{
				HRESULT hr = SetPassThrough(&rgPropertySets[ulSet]);
				if( hr == DB_E_ERRORSOCCURRED )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= SETPROP_WAS_REQUIRED;
				}
				else if( hr == DB_S_ERRORSOCCURRED )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= SETPROP_VALIDPROP;
				}
				else
				{
					ATLASSERT( hr == S_OK );
					dwState |= SETPROP_VALIDPROP;
				}

				continue;
			}

			// Handle properties of a supported property set
			rgDBProp = rgPropertySets[ulSet].rgProperties;
			for(ulProp=0; ulProp<rgPropertySets[ulSet].cProperties; ulProp++)
			{
				// Is this a supported PROPID for this property set
				if( GetIndexofPropIdinPropSet(ulCurSet, rgDBProp[ulProp].dwPropertyID,
					&ulCurProp) == S_FALSE)
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Set the pUPropInfo pointer
				pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
				ATLENSURE_RETURN( pUPropInfo );

				// check dwOption for a valid option
				if( (rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_REQUIRED)  &&
					(rgDBProp[ulProp].dwOptions != DBPROPOPTIONS_SETIFCHEAP) )
				{
					ATLTRACE(atlTraceDBProvider, 0, _T("SetProperties dwOptions Invalid: %u\n"), rgDBProp[ulProp].dwOptions);
					dwState |= SETPROP_ERRORS;
					dwState |= SETPROP_WAS_REQUIRED;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADOPTION;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the property is settable
				// We do not check against DBPROPFLAGS_CHANGE here
				if( (pUPropInfo->dwFlags & DBPROPFLAGS_WRITE) == 0 )
				{
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_OK;

					vDefaultValue.Clear();

					// VT_EMPTY against a read only property should be a no-op since
					// the VT_EMPTY means the default.
					if( V_VT(&rgDBProp[ulProp].vValue) == VT_EMPTY )
					{
						dwState |= SETPROP_VALIDPROP;
						continue;
					}

					if( SUCCEEDED(GetDefaultValue(ulCurSet, rgDBProp[ulProp].dwPropertyID,
							&dwOption, &(vDefaultValue))) )
					{
						if( V_VT(&rgDBProp[ulProp].vValue) ==  V_VT(&vDefaultValue) )
						{
							switch( V_VT(&vDefaultValue) )
							{
								case VT_BOOL:
									if( V_BOOL(&rgDBProp[ulProp].vValue) == V_BOOL(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_I2:
									if( V_I2(&rgDBProp[ulProp].vValue) == V_I2(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_I4:
									if( V_I4(&rgDBProp[ulProp].vValue) == V_I4(&vDefaultValue) )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
								case VT_BSTR:
									if( wcscmp(V_BSTR(&rgDBProp[ulProp].vValue), V_BSTR(&vDefaultValue)) == 0 )
									{
										dwState |= SETPROP_VALIDPROP;
										continue;
									}
									break;
							}
						}
					}

					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_OPTIONAL) ? DBPROPSTATUS_NOTSET : DBPROPSTATUS_NOTSETTABLE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the property is being set with the correct VARTYPE
				if( (rgDBProp[ulProp].vValue.vt != pUPropInfo->VarType) &&
					(rgDBProp[ulProp].vValue.vt != VT_EMPTY) )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}

				// Check that the value is legal
				if( (rgDBProp[ulProp].vValue.vt != VT_EMPTY) &&
					IsValidValue(ulCurSet, &(rgDBProp[ulProp])) == S_FALSE )
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
					rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADVALUE;
					_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
					continue;
				}


				// Check for a bad COLID, we only catch bad DBIDs
				if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
				{
					if( CDBIDOps::IsValidDBID(&(rgDBProp[ulProp].colid)) == S_FALSE )
					{
						dwState |= SETPROP_ERRORS;
						dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
						rgDBProp[ulProp].dwStatus = DBPROPSTATUS_BADCOLUMN;
						_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
						continue;
					}
					dwState |= SETPROP_COLUMN_LEVEL;

				}

				if(SetProperty(ulCurSet, ulCurProp, /*pUPropInfo,*/ &(rgDBProp[ulProp])) == S_OK)
				{
					dwState |= SETPROP_VALIDPROP;
				}
				else
				{
					dwState |= SETPROP_ERRORS;
					dwState |= (rgDBProp[ulProp].dwOptions == DBPROPOPTIONS_REQUIRED) ? SETPROP_WAS_REQUIRED : 0;
				}
				_ATLDUMPPROPERTY(rgDBProp[ulProp].dwPropertyID, rgDBProp[ulProp].dwStatus);
			}
		}

		vDefaultValue.Clear();

		// At least one propid was marked as not S_OK
		if( dwState & SETPROP_ERRORS )
		{
			if (!bIsCreating)
			{
				return (dwState & SETPROP_VALIDPROP) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED;
			}
			else
			{
				return (dwState & SETPROP_WAS_REQUIRED) ? DB_E_ERRORSOCCURRED : DB_S_ERRORSOCCURRED;
			}
		}

		return S_OK;
	}

	OUT_OF_LINE HRESULT	CopyUPropVal(
		_In_ ULONG iPropSet,
		_Inout_ UPROPVAL* rgUPropVal)
	{
		HRESULT	hr = S_OK;
		UPROP* pUProp;
		UPROPVAL* pUPropVal;
		DBPROP dbProp;

		ATLENSURE_RETURN(rgUPropVal);
		ATLASSERT(iPropSet < m_cUPropSet);

		VariantInit(&dbProp.vValue);

		pUProp = &(m_pUProp[iPropSet]);
		for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
		{
			pUPropVal = &(pUProp->pUPropVal[ul]);

			// Transfer dwOptions
			rgUPropVal[ul].dwOption = pUPropVal->dwOption;

			// Transfer Flags
			rgUPropVal[ul].dwFlags = pUPropVal->dwFlags;

			// Transfer Column Properties
			if( pUPropVal->pCColumnIds )
			{
				rgUPropVal[ul].pCColumnIds=NULL;
				ATLTRY(rgUPropVal[ul].pCColumnIds = new CColumnIds)
ATLPREFAST_SUPPRESS(6385)
				if( rgUPropVal[ul].pCColumnIds )
ATLPREFAST_UNSUPPRESS()
				{
					CColumnIds* pColIds = pUPropVal->pCColumnIds;
					for (size_t i = 0; i < pColIds->GetCount(); i++)
					{
						hr = (pUPropVal->pCColumnIds)->GetValue(i, &(dbProp.dwOptions),&(dbProp.colid), &(dbProp.vValue));
						if( FAILED(hr) )
							goto EXIT;
						if( FAILED(hr = (rgUPropVal[ul].pCColumnIds)->AddColumnId(&dbProp)) )
							goto EXIT;
					}
				}
				else
				{
					hr = E_OUTOFMEMORY;
					goto EXIT;
				}
			}
			else
			{
				rgUPropVal[ul].pCColumnIds = NULL;
			}

			// Transfer value
			VariantInit(&(rgUPropVal[ul].vValue));
			if( FAILED(hr = VariantCopy(&(rgUPropVal[ul].vValue),
				&(pUPropVal->vValue))) )
				goto EXIT;
		}

EXIT:
		VariantClear(&(dbProp.vValue));
		return hr;
	}
	void ClearPropertyInError()
	{
		ATLASSUME( m_rgdwPropsInError );
		memset(m_rgdwPropsInError, 0, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
	}

	void CopyUPropSetsSupported(_Out_ DWORD* rgdwSupported)
	{
		Checked::memcpy_s(rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD),
			m_rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
	}

	virtual HRESULT	InitUPropSetsSupported() = 0;

	virtual HRESULT	GetIndexofPropSet(
		_In_ const GUID* pPropSet,
		_Out_ ULONG* pulCurSet) = 0;

	ULONG GetCountofWritablePropsInPropSet(_In_ ULONG iPropSet)
	{
		ULONG cWritable = 0;
		UPROPINFO* pUPropInfo;

		ATLENSURE( m_pUPropSet );
		ATLASSERT( iPropSet < m_cUPropSet );

		pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

		for(ULONG ul=0; ul<m_pUPropSet[iPropSet].cUPropInfo; ul++)
		{
			if( pUPropInfo[ul].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				cWritable++;
		}

		return cWritable;
	}

	void CopyUPropInfo(
		_In_ ULONG iPropSet,
		_Deref_out_ UPROPINFO** rgpUPropInfo)
	{
		ATLASSUME( rgpUPropInfo != NULL );
		ATLASSUME( iPropSet < m_cUPropSet );
		Checked::memcpy_s(rgpUPropInfo, m_pUProp[iPropSet].cPropIds * sizeof(UPROPINFO*),
			m_pUProp[iPropSet].rgpUPropInfo, m_pUProp[iPropSet].cPropIds * sizeof(UPROPINFO*));
	}

	virtual HRESULT	GetDefaultValue(
		_In_ ULONG iPropSet,
		_In_ DBPROPID dwPropId,
		_Out_ DWORD* pdwOption,
		_Out_ VARIANT* pVar) = 0;

	typedef UPROPSET* (*PGetPropSet)(
		_Out_opt_ ULONG* pNumPropSets,
		_Out_opt_ ULONG* pcElemPerSupported,
		_Out_opt_ UPROPSET* pSet,
		_In_ GUID* pguidSet);

	HRESULT	InternalInitUPropSetsSupported(_In_ PGetPropSet pfnGetSet)
	{
		ULONG cPropSet = 0, cElemsPerSupported = 0;
		int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &cElemsPerSupported, NULL, (GUID*)&GUID_NULL);
		UPROPSET* pPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pPropSet == NULL)
			return E_OUTOFMEMORY;
		pPropSet = (*pfnGetSet)(&cPropSet, &cElemsPerSupported, pPropSet, (GUID*)&GUID_NULL);
		memset(m_rgdwSupported, 0xFFFF, cPropSet * cElemsPerSupported * sizeof(DWORD));
		CoTaskMemFree(pPropSet);
		return S_OK;
	}

	HRESULT	InternalGetDefaultValue(
		_In_ PGetPropSet pfnGetSet,
		_In_ ULONG iPropSet,
		_In_ DBPROPID dwPropId,
		_Out_ DWORD* pdwOption,
		_Out_ VARIANT* pVar)
	{
		if (pdwOption == NULL || pVar == NULL)
			return E_INVALIDARG;

		ULONG cUPropSet = 0, cElemPerSupported =0;

		int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &cElemPerSupported, NULL, (GUID*)&GUID_NULL);
		UPROPSET* pPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
		if (pPropSet == NULL)
			return E_OUTOFMEMORY;
		pPropSet = (*pfnGetSet)(&cUPropSet, &cElemPerSupported, pPropSet, (GUID*)&GUID_NULL);

		ATLASSERT(iPropSet < cUPropSet);
		for (ULONG iProp = 0; iProp < pPropSet[iPropSet].cUPropInfo; iProp++)
		{
			UPROPINFO& rInfo = pPropSet[iPropSet].pUPropInfo[iProp];
			if (rInfo.dwPropId == dwPropId)
			{
				HRESULT hr = S_OK;
				pVar->vt = rInfo.VarType;
				*pdwOption = rInfo.dwOption;
				switch(rInfo.VarType)
				{
				case VT_BSTR:
					pVar->bstrVal = SysAllocString(rInfo.szVal);
					if (pVar->bstrVal == NULL && rInfo.szVal != NULL)
						hr = E_OUTOFMEMORY;
					break;
				default:
					pVar->lVal = (DWORD)rInfo.dwVal;
					break;
				}
				CoTaskMemFree(pPropSet);
				return hr;
			}
		}
		CoTaskMemFree(pPropSet);
		return E_FAIL;
	}

	HRESULT InternalFInit(
		_In_ PGetPropSet pfnGetSet,
		_In_opt_ CUtlPropsBase* pCopyMe = NULL)
	{
		HRESULT		hr;
		ULONG		ulPropId;
		ULONG		cPropIds;
		ULONG		iPropSet;
		ULONG		iNewDex;
		UPROPINFO*	pUPropInfo;

		// If a pointer is passed in, we should copy that property object
		if( pCopyMe )
		{
			// Establish some base values
			m_cUPropSet = pCopyMe->m_cUPropSet;
			CoTaskMemFree(m_pUPropSet);
			m_pUPropSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), m_cUPropSet);
			if (m_pUPropSet == NULL)
				return E_OUTOFMEMORY;
			Checked::memcpy_s(m_pUPropSet, sizeof(UPROPSET) * m_cUPropSet, pCopyMe->m_pUPropSet, sizeof(UPROPSET) * m_cUPropSet);
			m_cElemPerSupported = pCopyMe->m_cElemPerSupported;
			ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
			// Retrieve Supported Bitmask
			ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			ATLTRY(m_rgdwPropsInError.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			if( m_rgdwSupported == NULL|| m_rgdwPropsInError == NULL)
			{
				m_rgdwSupported.Free();
				m_rgdwPropsInError.Free();
				return E_OUTOFMEMORY;
			}
			ClearPropertyInError();
			pCopyMe->CopyUPropSetsSupported(m_rgdwSupported);

		}
		else
		{
			int cSets = (int)(DWORD_PTR)(*pfnGetSet)(NULL, &m_cElemPerSupported, NULL, (GUID*)&GUID_NULL);
			UPROPSET* pSet = (UPROPSET*)::ATL::AtlCoTaskMemCAlloc(static_cast<ULONG>(sizeof(UPROPSET)), cSets);
			if (pSet == NULL)
				return E_OUTOFMEMORY;
			pSet = (*pfnGetSet)(&m_cUPropSet, &m_cElemPerSupported, pSet, (GUID*)&GUID_NULL);
			CoTaskMemFree(m_pUPropSet);
			m_pUPropSet = pSet;
			ATLASSERT( (m_cUPropSet != 0)  && (m_cElemPerSupported != 0) );
			if( !m_cUPropSet || !m_cElemPerSupported )
				return E_FAIL;

			ATLTRY(m_rgdwSupported.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			ATLTRY(m_rgdwPropsInError.Allocate(::ATL::AtlMultiplyThrow(m_cUPropSet, m_cElemPerSupported)));
			if( m_rgdwSupported == NULL || m_rgdwPropsInError == NULL)
			{
				m_rgdwSupported.Free();
				m_rgdwPropsInError.Free();
				return E_OUTOFMEMORY;
			}
			else
				ClearPropertyInError();

			if( FAILED(hr = InitUPropSetsSupported()) )
			{
				m_rgdwSupported.Free();
				return hr;
			}
		}

		// Allocate UPROPS structures for the count of Property sets
		ATLTRY(m_pUProp.Allocate(m_cUPropSet));
		if( m_pUProp)
		{
			memset(m_pUProp, 0, m_cUPropSet * sizeof(UPROP));
		}
		else
		{
			m_cUPropSet = 0;
			return E_OUTOFMEMORY;
		}

		// With in the UPROPS Structure allocate and intialize the
		// Property IDs that belong to this property set.
		for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
		{
			cPropIds = GetCountofWritablePropsInPropSet(iPropSet);

			if( cPropIds > 0 )
			{
				CAutoVectorPtr< UPROPINFO* > rgpUPropInfo;
				CAutoVectorPtr< UPROPVAL > rgUPropVal;

				rgpUPropInfo.Allocate( cPropIds );
				rgUPropVal.Allocate( cPropIds );
				if ( (rgpUPropInfo == NULL) || (rgUPropVal == NULL) )
				{
					return E_OUTOFMEMORY;
				}
				if( pCopyMe )
				{
					pCopyMe->CopyUPropInfo(iPropSet, rgpUPropInfo);
					if( FAILED(hr = pCopyMe->CopyUPropVal(iPropSet, rgUPropVal)) )
						return hr;
				}
				else
				{
					// Clear Pointer Array
					memset(rgpUPropInfo, 0, cPropIds * sizeof(UPROPINFO*));

					// Set Pointer to correct property ids with a property set
					pUPropInfo = m_pUPropSet[iPropSet].pUPropInfo;

					// Set up the writable property buffers
					iNewDex = 0;
					for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
					{
						if( pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
						{
							// Following ATLASSERT indicates that the are more
							// writable properties then space allocated
							ATLASSERT(iNewDex < cPropIds);

							rgpUPropInfo[iNewDex] = &(pUPropInfo[ulPropId]);
							rgUPropVal[iNewDex].dwOption = DBPROPOPTIONS_SETIFCHEAP;
							rgUPropVal[iNewDex].pCColumnIds = NULL;
							rgUPropVal[iNewDex].dwFlags = 0;
							VariantInit(&(rgUPropVal[iNewDex].vValue));
							GetDefaultValue(iPropSet, pUPropInfo[ulPropId].dwPropId,
								&(rgUPropVal[iNewDex].dwOption), &(rgUPropVal[iNewDex].vValue));
							iNewDex++;
						}
					}

					ATLASSERT(cPropIds == iNewDex);
				}


				m_pUProp[iPropSet].rgpUPropInfo = rgpUPropInfo.Detach();
				m_pUProp[iPropSet].pUPropVal = rgUPropVal.Detach();
				m_pUProp[iPropSet].cPropIds = cPropIds;
			}
		}

		// Finally determine if there are any hidden property sets..  Those
		// that do not show up in GetPropertyInfo and should not be returns on
		// a 0, NULL call to GetProperties
		for(iPropSet=0; iPropSet<m_cUPropSet; iPropSet++)
		{
			if( m_pUPropSet[iPropSet].dwFlags & UPROPSET_HIDDEN )
				m_cUPropSetHidden++;
		}

		return S_OK;
	}
	//Check the arguments for Set Properties
	static HRESULT SetPropertiesArgChk(
		_In_ const ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPSET rgPropertySets[])
	{
		if( cPropertySets > 0 && !rgPropertySets )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for
		// array of property ids.
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( rgPropertySets[ul].cProperties && !(rgPropertySets[ul].rgProperties) )
				return E_INVALIDARG;
		}

		return S_OK;
	}
	HRESULT	GetProperties(
		_In_ const ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPIDSET rgPropertySets[],
		_Out_ ULONG* pcProperties,
		_Out_ _Deref_post_opt_cap_(*pcProperties) DBPROPSET** prgProperties,
		_In_ const ULONG cSelectProps = 1,
		_In_count_(cSelectProps) const GUID* const ppGuid[] = NULL)
	{
		UPROPVAL*		pUPropVal;
		ULONG			ulCurProp;
		ULONG			cTmpPropertySets = cPropertySets;
		HRESULT			hr = S_OK;
		ULONG			ulSet = 0;
		ULONG			ulNext = 0;
		ULONG			cSets = 0;
		ULONG			cProps = 0;
		ULONG			ulProp = 0;
		DWORD			dwStatus = 0;
		DBPROP*			pProp = NULL;
		DBPROP*			pCurProp = NULL;
		DBPROPSET*		pPropSet = NULL;
		UPROPINFO*		pUPropInfo = NULL;
		ULONG			ulCurSet = 0;
		ULONG			iPropSet;
		CAutoVectorPtr< ULONG > piIndex;

		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		// ppGuid contains an array of GUIDs that the consumer can retrieve.
		// This is based upon the interface calling this function
		ATLENSURE_RETURN(ppGuid != NULL);

		// We need to have special handling for DBPROPSET_PROPERTIESINERROR..
		// Turn on a flags to indicate this mode and make cTmpPropertySets
		// appear to be 0
		if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
			rgPropertySets &&
			(rgPropertySets[0].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
		{
			cTmpPropertySets = 0;
			dwStatus |= GETPROP_PROPSINERROR;
		}

		// If the consumer does not restrict the property sets
		// by specify an array of property sets and a cTmpPropertySets
		// greater than 0, then we need to make sure we
		// have some to return
		if( cTmpPropertySets == 0 )
		{
			// There are times when we are called from IRowsetInfo, ISessionProperties, etc.
			// where we should return only the appropriate rowset when cTmpPropertySets is
			// zero.  This solves the problem if the user has more than one set specified in
			// their PROPSET_MAP.

			// Determine the number of property sets supported
			if (ppGuid == NULL)
			{
				cSets = m_cUPropSet;
			}
			else
			{
				ULONG ulActualProps = 0;
				CAutoVectorPtr < ULONG > piSetIndex;

				piSetIndex.Allocate( cSelectProps );
				if (piSetIndex == NULL)
					return E_OUTOFMEMORY;

				// Also, find the index for the set we are looking for
				ULONG l;
				for (l=0; l<cSelectProps; l++)
				{
					for (piSetIndex[l]=0; piSetIndex[l]<m_cUPropSet; piSetIndex[l]++)
					{
						if (InlineIsEqualGUID(*m_pUPropSet[piSetIndex[l]].pPropSet, *ppGuid[l]))
						{
							ulActualProps++;
							break;
						}
					}
				}

				cSets = ulActualProps;
				ulActualProps = 0;
				piIndex.Allocate( cSets );
				if (piIndex == NULL)
					return E_OUTOFMEMORY;
				for (l=0; l<cSelectProps; l++)
				{
					if (piSetIndex[l] != m_cUPropSet) // this is an invalid index
						piIndex[ulActualProps++] = piSetIndex[l];
				}

			}
		}
		else
		{
			// Since special property set guids are not supported by
			// GetProperties, we can just use the count of property
			// sets given to us.
			cSets = cTmpPropertySets;
		}

		// If no properties set, then return
		if( cSets == 0 )
			return S_OK;

		// Allocate the DBPROPSET structures
		pPropSet = (DBPROPSET*)::ATL::AtlCoTaskMemCAlloc(cSets, static_cast<ULONG>(sizeof(DBPROPSET)));
		if(pPropSet)
		{
			memset(pPropSet, 0, cSets * sizeof(DBPROPSET));

			// Fill in the output array
			iPropSet = 0;
			for(ulSet=0; ulSet<cSets; ulSet++)
			{
				// Depending of if Property sets are specified store the
				// return property set.
				if( cTmpPropertySets == 0 )
				{
					ULONG lSet;

					if (ppGuid[ulSet] == NULL)
						lSet = ulSet;
					else
						lSet = piIndex[ulSet];
					if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
						continue;

					pPropSet[iPropSet].guidPropertySet = *(m_pUPropSet[lSet].pPropSet);

				}
				else
				{
					pPropSet[iPropSet].guidPropertySet = rgPropertySets[ulSet].guidPropertySet;
				}
				iPropSet++;
			}
		}
		else
		{
			ATLTRACE(atlTraceDBProvider, 0,
				"Could not allocate DBPROPSET array for GetProperties\n");
			return E_OUTOFMEMORY;
		}

		// Process requested or derived Property sets
		iPropSet=0;
		for(ulSet=0; ulSet<cSets; ulSet++)
		{
			cProps	= 0;
			pProp	= NULL;
			ulNext	= 0;
			dwStatus &= (GETPROP_ERRORSOCCURRED | GETPROP_VALIDPROP | GETPROP_PROPSINERROR);

			// Calculate the number of property nodes needed for this
			// property set.
			if( cTmpPropertySets == 0 )
			{
				ULONG lSet;

				if (ppGuid[ulSet] == NULL)
					lSet = ulSet;
				else
					lSet = piIndex[ulSet];

				// If processing requesting all property sets, do not
				// return the hidden sets.
				if( m_pUPropSet[lSet].dwFlags & UPROPSET_HIDDEN )
					continue;

				cProps = m_pUPropSet[lSet].cUPropInfo;

				// Add Enough space for node that are colid specific
				cProps += GetCountofColids(&(m_pUProp[lSet]));
				dwStatus |= GETPROP_ALLPROPIDS;
				ulCurSet = lSet;
			}
			else
			{
				ATLASSERT(ulSet == iPropSet);

				// If the count of PROPIDs is 0 or It is a special property set, then
				// the consumer is requesting all propids for this property set.
				if(rgPropertySets[ulSet].cPropertyIDs == 0)
				{
					dwStatus |= GETPROP_ALLPROPIDS;
					// We have to determine if the property set is supported and if so
					// the count of properties in the set.
					BOOL bAvailable = false;
					for (ULONG l=0; l<cSelectProps; l++)
					{
						if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
							bAvailable |= true;
					}

					if (bAvailable &&
							GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) == S_OK)
					{
						cProps += m_pUPropSet[ulCurSet].cUPropInfo;
						// Add Enough space for node that are colid specific
						cProps += GetCountofColids(&m_pUProp[ulCurSet]);
						_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);
					}
					else
					{
						// Not Supported
						dwStatus |= GETPROP_ERRORSOCCURRED;
						_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);
						goto NEXT_SET;
					}
				}
				else
				{
					cProps = rgPropertySets[ulSet].cPropertyIDs;
					// Check to see if this is a supported interface based on ppGuid.
					BOOL bAvailable = false;
					for (ULONG l=0; l<cSelectProps; l++)
					{
						if (InlineIsEqualGUID(*ppGuid[l], rgPropertySets[ulSet].guidPropertySet))
							bAvailable |= true;
					}

					if (!bAvailable ||
						(GetIndexofPropSet(&(pPropSet[iPropSet].guidPropertySet), &ulCurSet) != S_OK))
					{
						dwStatus |= GETPROP_NOTSUPPORTED;
						dwStatus |= GETPROP_ERRORSOCCURRED;
					}

					_ATLDUMPPROPSETIID(pPropSet[iPropSet].guidPropertySet, dwStatus);

				}
			}

			// Allocate DBPROP array
			if( cProps == 0 )			//Possible with Hidden Passthrough sets
				goto NEXT_SET;

			pProp = (DBPROP*)::ATL::AtlCoTaskMemCAlloc(cProps, static_cast<ULONG>(sizeof(DBPROP)));
			if( pProp )
			{
				// Initialize Buffer
				memset(pProp, 0, cProps * sizeof(DBPROP));
				for(ulProp=0; ulProp<cProps; ulProp++)
				{
					VariantInit(&(pProp[ulProp].vValue));
					if( dwStatus & GETPROP_NOTSUPPORTED )
					{
						// Not supported, thus we need to mark all as NOT_SUPPORTED
						pProp[ulProp].dwPropertyID	= rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pProp[ulProp].dwStatus		= DBPROPSTATUS_NOTSUPPORTED;
						_ATLDUMPPROPERTY(pProp[ulProp].dwPropertyID, pProp[ulProp].dwStatus);
					}
				}
				// Make sure we support the property set
				if( dwStatus & GETPROP_NOTSUPPORTED )
				{
					ulNext = cProps;
					goto NEXT_SET;
				}

				// Now that we have determined we can support the property set, we
				// need to gather current property values
				for(ulProp=0; ulProp<cProps; ulProp++)
				{
					pCurProp = &(pProp[ulNext]);

					//Initialize Variant Value
					pCurProp->dwStatus = DBPROPSTATUS_OK;

					// Retrieve current value of properties
					if( dwStatus & GETPROP_ALLPROPIDS )
					{
						// Verify property is supported, if not do not return
						if(!TESTBIT(&(m_rgdwSupported[ulCurSet * m_cElemPerSupported]), ulProp) )
							continue;

						// If we are looking for properties in error, then we should ignore all
						// that are not in error.
						if( (dwStatus & GETPROP_PROPSINERROR) &&
							!TESTBIT(&(m_rgdwPropsInError[ulCurSet * m_cElemPerSupported]), ulProp) )
							continue;

						pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulProp]);

						ATLENSURE_RETURN( pUPropInfo );

						pCurProp->dwPropertyID = pUPropInfo->dwPropId;
						pCurProp->colid = DB_NULLID;

						// If the property is WRITEABLE or CHANGABLE, then the value will
						// be gotten from the UPROPVAL array, else it will be
						// derive from the GetDefaultValue
						if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
						{
							pUPropVal = &(m_pUProp[ulCurSet].
								pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
							ATLENSURE_RETURN( pUPropVal );

							// Check to see if this property supports column level,
							// if so, dump those nodes
							if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
							{
								if( pUPropVal->pCColumnIds )
								{
									RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
									continue;
								}
							}

							pCurProp->dwOptions = pUPropVal->dwOption;
							hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
						}
						else
						{
							GetDefaultValue(ulCurSet, pUPropInfo->dwPropId,
								&(pCurProp->dwOptions), &(pCurProp->vValue));
						}

						// Return all Properties in Error with CONFLICT status
						if( dwStatus & GETPROP_PROPSINERROR )
							pCurProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						dwStatus |= GETPROP_VALIDPROP;
					}
					else
					{
						// Process Properties based on Restriction array.

						pCurProp->dwPropertyID = rgPropertySets[ulSet].rgPropertyIDs[ulProp];
						pCurProp->colid = DB_NULLID;

						if( GetIndexofPropIdinPropSet(ulCurSet, pCurProp->dwPropertyID,
							&ulCurProp) == S_OK)
						{
							// Supported
							pUPropInfo = &(m_pUPropSet[ulCurSet].pUPropInfo[ulCurProp]);
							ATLENSURE_RETURN( pUPropInfo );

							// If the property is WRITEABLE, then the value will
							// be gotten from the UPROPVAL array, else it will be
							// derive from the GetDefaultValue
							if( pUPropInfo->dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
							{
								pUPropVal = &(m_pUProp[ulCurSet].
									pUPropVal[GetUPropValIndex(ulCurSet, pCurProp->dwPropertyID)]);
								ATLENSURE_RETURN( pUPropVal );

								// Check to see if this property supports column level,
								// if so, dump those nodes
								if( pUPropInfo->dwFlags & DBPROPFLAGS_COLUMNOK )
								{
									if( pUPropVal->pCColumnIds )
									{
										RetrieveColumnIdProps(pProp, pUPropVal, &ulNext);
										continue;
									}
								}
								pCurProp->dwOptions = pUPropVal->dwOption;
								hr = VariantCopy(&(pCurProp->vValue), &(pUPropVal->vValue));
							}
							else
							{
								GetDefaultValue(ulCurSet, pUPropInfo->dwPropId,
									&(pCurProp->dwOptions), &(pCurProp->vValue));

							}

							dwStatus |= GETPROP_VALIDPROP;
						}
						else
						{
							// Not Supported
							pCurProp->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
							dwStatus |= GETPROP_ERRORSOCCURRED;
						}
					}

					_ATLDUMPPROPERTY(pCurProp->dwPropertyID, pCurProp->dwStatus);
					// Increment return nodes count
					ulNext++;
				}
			}
			else
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Could not allocate DBPROP array for GetProperties\n"));
				if( pPropSet )
				{
					//Since we have no properties to return, then we
					//need to free allocated memory and return 0,NULL
					for(ulSet=0; ulSet<cSets; ulSet++)
					{
						// Need to loop through all the VARIANTS and clear them
						for(ulProp=0; ulProp<pPropSet[ulSet].cProperties; ulProp++)
							VariantClear(&(pPropSet[ulSet].rgProperties[ulProp].vValue));
						CoTaskMemFree(pPropSet[ulSet].rgProperties);
					}

					// Free DBPROPSET
					CoTaskMemFree(pPropSet);
				}
				*pcProperties = 0;
				*prgProperties = NULL;
				return E_OUTOFMEMORY;
			}

NEXT_SET:
			// It is possible that all properties are not supported,
			// thus we should delete that memory and set rgProperties
			// to NULL
			if( ulNext == 0 && pProp )
			{
				CoTaskMemFree(pProp);
				pProp = NULL;
			}

			pPropSet[iPropSet].cProperties = ulNext;
			pPropSet[iPropSet].rgProperties = pProp;
			iPropSet++;
		}

		*pcProperties = iPropSet;
		*prgProperties = pPropSet;

		piIndex.Free();

		// At least one propid was marked as not S_OK
		if( dwStatus & GETPROP_ERRORSOCCURRED )
		{
			// If at least 1 property was set
			if( dwStatus & GETPROP_VALIDPROP )
				return DB_S_ERRORSOCCURRED;
			else
			{
				// Do not free any of the memory on a DB_E_
				return DB_E_ERRORSOCCURRED;
			}
		}

		return S_OK;
	}

	ULONG GetCountofColids(_In_ UPROP* pUProp)
	{
		ULONG	cExtra=0;
		ATLENSURE(pUProp);
		for(ULONG ul=0; ul<pUProp->cPropIds; ul++)
		{
			if( pUProp->pUPropVal[ul].pCColumnIds )
				cExtra += (pUProp->pUPropVal[ul].pCColumnIds)->GetCountOfPropColids();
		}
		return cExtra;
	}

	ULONG GetUPropValIndex(
		_In_ ULONG iCurSet,
		_In_ DBPROPID dwPropId)
	{
		for(ULONG ul=0; ul<m_pUProp[iCurSet].cPropIds; ul++)
		{
			if( (m_pUProp[iCurSet].rgpUPropInfo[ul])->dwPropId == dwPropId )
				return ul;
		}
		return 0;
	}

	void RetrieveColumnIdProps(
		_In_ DBPROP* pCurProp,
		_In_ UPROPVAL* pUPropVal,
		_Inout_ ULONG* pulNext)
	{
		// Reset to first Node
		CColumnIds* pColIds = pUPropVal->pCColumnIds;
		HRESULT hr = E_FAIL;
		for (size_t i = 0; i < pColIds->GetCount(); i++)
		{
			CPropColID colId;
			hr = pColIds->GetValue(i, &(pCurProp->dwOptions), &(pCurProp->colid),&(pCurProp->vValue));
			if (SUCCEEDED(hr))
				pCurProp = &(pCurProp[++(*pulNext)]);
		}
		(*pulNext)++;
	}

	//Check the arguments for Retrieve Properties
	HRESULT	GetPropertiesArgChk(
		_In_ const ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPIDSET rgPropertySets[],
		_Out_ ULONG* pcProperties,
		_Out_ _Deref_post_opt_cap_(*pcProperties) DBPROPSET** prgProperties)
	{
		// Initialize values
		if(pcProperties)
			*pcProperties = 0;
		if(prgProperties)
			*prgProperties = NULL;

		// Check Arguments
		if( ((cPropertySets > 0) && !rgPropertySets) || !pcProperties || !prgProperties )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for
		// array of property ids.
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
				return E_INVALIDARG;

			// Check for propper formation of DBPROPSET_PROPERTIESINERROR
			if( (m_dwFlags & ARGCHK_PROPERTIESINERROR) &&
				rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR )
			{
				if( (cPropertySets > 1) ||
					(rgPropertySets[ul].cPropertyIDs != 0) ||
					(rgPropertySets[ul].rgPropertyIDs != NULL) )
					return E_INVALIDARG;
			}
		}

		return S_OK;
	}

	OUT_OF_LINE HRESULT	FInit(_In_opt_ CUtlPropsBase* pCopyMe = NULL) = 0;
};

// Implementation Class
template <class T>
class ATL_NO_VTABLE CUtlProps :
	public CUtlPropsBase
{
public:

	CUtlProps(_In_ DWORD dwFlags = 0)
	{
		ClearMemberVars();
		m_dwFlags = dwFlags;
	}
	virtual ~CUtlProps()
	{
		FreeMemory();
	}
	void FreeMemory()
	{
		// Remove Property Information
		if( m_pUProp )
		{
			for(ULONG ulPropSet=0; ulPropSet<m_cUPropSet; ulPropSet++)
			{
				UPROPVAL* pUPropVal = m_pUProp[ulPropSet].pUPropVal;
				for(ULONG ulPropId=0; ulPropId<m_pUProp[ulPropSet].cPropIds; ulPropId++)
				{
					delete pUPropVal[ulPropId].pCColumnIds;
					VariantClear(&(pUPropVal[ulPropId].vValue));
				}
				delete[] m_pUProp[ulPropSet].rgpUPropInfo;
				delete[] m_pUProp[ulPropSet].pUPropVal;
			}

		}

		m_pUProp.Free();
		m_rgdwSupported.Free();
		m_rgdwPropsInError.Free();
		m_rgiPropSetDex.Free();
		CoTaskMemFree(m_pUPropSet);
		ClearMemberVars();
	}
	void ClearMemberVars()
	{
		m_cPropSetDex		= 0;
		m_cUPropSet			= 0;
		m_cUPropSetHidden	= 0;
		m_pUPropSet			= NULL;

		m_dwFlags			= 0;

		m_cElemPerSupported	= 0;
	}

	//Retrieve the property set indexes that match this property set.
	HRESULT	GetPropertySetIndex(_In_ GUID* pPropertySet)
	{
		DWORD	dwFlag = 0;
		ULONG	ulSet;

		ATLASSUME( m_cUPropSet && m_pUPropSet );
		ATLASSUME( m_rgiPropSetDex );
		ATLASSERT( pPropertySet );

		m_cPropSetDex = 0;

		if( *pPropertySet == DBPROPSET_DATASOURCEALL )
		{
			dwFlag = DBPROPFLAGS_DATASOURCE;
		}
		else if( *pPropertySet == DBPROPSET_DATASOURCEINFOALL )
		{
			dwFlag = DBPROPFLAGS_DATASOURCEINFO;
		}
		else if( *pPropertySet == DBPROPSET_ROWSETALL )
		{
			dwFlag = DBPROPFLAGS_ROWSET;
		}
		else if( *pPropertySet == DBPROPSET_DBINITALL )
		{
			dwFlag = DBPROPFLAGS_DBINIT;
		}
		else if( *pPropertySet == DBPROPSET_SESSIONALL )
		{
			dwFlag = DBPROPFLAGS_SESSION;
		}
		else if( *pPropertySet == DBPROPSET_COLUMNALL)
		{
			dwFlag = DBPROPFLAGS_COLUMN;
		}
		else if( *pPropertySet == DBPROPSET_INDEXALL)
		{
			dwFlag = DBPROPFLAGS_INDEX;
		}
		else if( *pPropertySet == DBPROPSET_TABLEALL)
		{
			dwFlag = DBPROPFLAGS_TABLE;
		}
		else if( *pPropertySet == DBPROPSET_TRUSTEEALL)
		{
			dwFlag = DBPROPFLAGS_TRUSTEE;
		}
		else if( *pPropertySet == DBPROPSET_VIEWALL)
		{
			dwFlag = DBPROPFLAGS_VIEW;
		}
		else // No scan required, just look for match.
		{
			for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
			{
				if( *(m_pUPropSet[ulSet].pPropSet) == *pPropertySet )
				{
					m_rgiPropSetDex[m_cPropSetDex] = ulSet;
					m_cPropSetDex++;
					break;
				}
			}
			goto EXIT;
		}

		// Scan through the property sets looking for matching attributes
		for(ulSet=0; ulSet<m_cUPropSet; ulSet++)
		{
			if( m_pUPropSet[ulSet].pUPropInfo[0].dwFlags & dwFlag )
			{
				m_rgiPropSetDex[m_cPropSetDex] = ulSet;
				m_cPropSetDex++;
			}
		}

EXIT:
		return (m_cPropSetDex) ? S_OK : S_FALSE;
	}

	OUT_OF_LINE HRESULT	GetDefaultValue(
		_In_ ULONG iPropSet,
		_In_ DBPROPID dwPropId,
		_Out_ DWORD* pdwOption,
		_Out_ VARIANT* pVar)
	{
		return InternalGetDefaultValue(T::_GetPropSet, iPropSet, dwPropId, pdwOption, pVar);
	}

	OUT_OF_LINE HRESULT	FInit(_In_opt_ CUtlPropsBase* pCopyMe = NULL)
	{
		return InternalFInit(T::_GetPropSet, pCopyMe);
	}
	HRESULT	FillDefaultValues(_In_ ULONG ulPropSetTarget = ULONG_MAX)
	{
		HRESULT		hr;
		ULONG		ulPropId;
		ULONG		iPropSet;
		ULONG		iNewDex;

		// Fill in all the actual values.
		// Typically because we now have an hdbc with which to get them.
		// (Or we no longer have an hdbc, so must clear them.)
		// Note that the UPROP (with values) array may be a subset of the UPROPINFO array.
		// Only writable properties are in UPROP array.

		// Maybe restrict to a single PropSet if within valid range [0...m_cUPropSet-1].
		// Otherwise do all propsets.
		iPropSet = (ulPropSetTarget < m_cUPropSet) ? ulPropSetTarget : 0;

		for( ; iPropSet<m_cUPropSet; iPropSet++)
		{
			iNewDex = 0;
			for(ulPropId=0; ulPropId<m_pUPropSet[iPropSet].cUPropInfo; ulPropId++)
			{
				if( m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					//Initialize dwFlags element of UPropVal
					m_pUProp[iPropSet].pUPropVal[iNewDex].dwFlags = 0;

					// Don't need this since SetProperties() resets these.
					//ATLASSUME( m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption == DBPROPOPTIONS_SETIFCHEAP);
					ATLASSUME( m_pUProp[iPropSet].pUPropVal[iNewDex].pCColumnIds == NULL);

					VariantClear(&m_pUProp[iPropSet].pUPropVal[iNewDex].vValue);
					hr = GetDefaultValue(
							iPropSet,
							m_pUPropSet[iPropSet].pUPropInfo[ulPropId].dwPropId,
							&m_pUProp[iPropSet].pUPropVal[iNewDex].dwOption,
							&m_pUProp[iPropSet].pUPropVal[iNewDex].vValue );
					if (FAILED(hr))
						return hr;
					iNewDex++;
				}
			}

			// We're through if restricting to single PropSet.
			if (ulPropSetTarget < m_cUPropSet)
				break;
		}
		return NOERROR;
	}

	// Translate Rowset IIDs to PROPSET structures ready to pass to SetProperties
	HRESULT	ConvertRowsetIIDtoDBPROPSET(
		_In_ const IID* piid,
		_Inout_ DBPROPSET* pPropSet)
	{
		ATLASSUME( piid != 0 && pPropSet != 0 );
		ATLASSUME( (pPropSet->cProperties == 1) || (pPropSet->rgProperties) );

		HRESULT	hr = S_OK;
		DBPROP* pProp = &(pPropSet->rgProperties[0]);

		if(InlineIsEqualGUID(*piid, __uuidof(IAccessor)))
			pProp->dwPropertyID = DBPROP_IAccessor;
		else if(InlineIsEqualGUID(*piid,__uuidof(IColumnsInfo)))
			pProp->dwPropertyID = DBPROP_IColumnsInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowset)))
			pProp->dwPropertyID = DBPROP_IRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetInfo)))
			pProp->dwPropertyID = DBPROP_IRowsetInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetLocate)))
			pProp->dwPropertyID = DBPROP_IRowsetLocate;
		else if(InlineIsEqualGUID(*piid , __uuidof(IColumnsRowset)))
			pProp->dwPropertyID = DBPROP_IColumnsRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetResynch)))
			pProp->dwPropertyID = DBPROP_IRowsetResynch;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetScroll)))
			pProp->dwPropertyID = DBPROP_IRowsetScroll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetChange)))
			pProp->dwPropertyID = DBPROP_IRowsetChange;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetUpdate)))
			pProp->dwPropertyID = DBPROP_IRowsetUpdate;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIdentity)))
			pProp->dwPropertyID = DBPROP_IRowsetIdentity;
		else if(InlineIsEqualGUID(*piid , __uuidof(IConnectionPointContainer)))
			pProp->dwPropertyID = DBPROP_IConnectionPointContainer;
		else if(InlineIsEqualGUID(*piid , __uuidof(ISupportErrorInfo)))
			pProp->dwPropertyID = DBPROP_ISupportErrorInfo;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetIndex)))
			pProp->dwPropertyID = DBPROP_IRowsetIndex;
	#if( OLEDBVER >= 0x0200 && 0 /* These interfaces are defined nowhere */ )
		else if(InlineIsEqualGUID(*piid , __uuidof(IProvideMoniker)))
			pProp->dwPropertyID = DBPROP_IProvideMoniker;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNotify)))
			pProp->dwPropertyID = DBPROP_IRowsetNotify;
		else if(InlineIsEqualGUID(*piid , __uuidof(IReadData)))
			pProp->dwPropertyID = DBPROP_IReadData;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetExactScroll)))
			pProp->dwPropertyID = DBPROP_IRowsetExactScroll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNextRowset)))
			pProp->dwPropertyID = DBPROP_IRowsetNextRowset;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetNewRowAfter)))
			pProp->dwPropertyID = DBPROP_IRowsetNewRowAfter;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWithParameters)))
			pProp->dwPropertyID = DBPROP_IRowsetWithParameters;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetFind)))
			pProp->dwPropertyID = DBPROP_IRowsetFind;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetAsynch)))
			pProp->dwPropertyID = DBPROP_IRowsetAsynch;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetKeys)))
			pProp->dwPropertyID = DBPROP_IRowsetKeys;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchAll)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchAll;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchNotify)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchNotify;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetWatchRegion)))
			pProp->dwPropertyID = DBPROP_IRowsetWatchRegion;
		else if(InlineIsEqualGUID(*piid , __uuidof(IRowsetCopyRows)))
			pProp->dwPropertyID = DBPROP_IRowsetCopyRows;
	#endif //#if( OLEDBVER >= 0x0200 )
		else
			hr = S_FALSE;

		// If the IID can be mapped to a DBPROPID, the
		// we need to initialize the vValue to TRUE
		if(hr == S_OK)
		{
			// Set PropertySet
			pPropSet->guidPropertySet = DBPROPSET_ROWSET;

			// Set Property
			pProp->dwOptions = DBPROPOPTIONS_REQUIRED;
			pProp->dwStatus = 0;
			pProp->colid = DB_NULLID;

			VariantInit(&(pProp->vValue));
			pProp->vValue.vt = VT_BOOL;
			V_BOOL(&(pProp->vValue)) = ATL_VARIANT_TRUE;
		}

		return hr;
	}

	void SetPropertyInError(
		_In_ const ULONG iPropSet,
		_In_ const ULONG iPropId)
	{
		SETBIT(&(m_rgdwPropsInError[iPropSet * m_cElemPerSupported]), iPropId);
	}

	BOOL IsPropSet(
		_In_ const GUID* pguidPropSet,
		_In_ DBPROPID dwPropId)
	{
		HRESULT		hr;
		ULONG		iPropSet;
		ULONG		iPropId;
		VARIANT		vValue;
		DWORD		dwOptions;

		VariantInit(&vValue);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{
				if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags &
					(DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					ULONG iPropVal = GetUPropValIndex(iPropSet, dwPropId);

					dwOptions = m_pUProp[iPropSet].pUPropVal[iPropVal].dwOption;
					hr = VariantCopy(&vValue, &(m_pUProp[iPropSet].
						pUPropVal[iPropVal].vValue));
				}
				else
				{
					hr = GetDefaultValue(iPropSet, dwPropId,
						&dwOptions, &vValue);
				}

				if( dwOptions == DBPROPOPTIONS_REQUIRED )
				{
					ATLASSERT( vValue.vt == VT_BOOL );
					if( SUCCEEDED(hr) &&
						(V_BOOL(&vValue) != ATL_VARIANT_FALSE) )
					{
						VariantClear(&vValue);
						return TRUE;
					}
				}
			}
		}

		VariantClear(&vValue);
		return FALSE;
	}
	OUT_OF_LINE HRESULT	GetPropValue(
		_In_ const GUID* pguidPropSet,
		_In_ DBPROPID dwPropId,
		_Out_ VARIANT* pvValue)
	{
		HRESULT		hr = E_FAIL;
		ULONG		iPropSet;
		ULONG		iPropId;
		DWORD		dwOptions;
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{
				if( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) )
				{
					hr = VariantCopy(pvValue, &(m_pUProp[iPropSet].pUPropVal[
						GetUPropValIndex(iPropSet, dwPropId)].vValue));
				}
				else
				{
					VariantClear(pvValue);

					hr = GetDefaultValue(iPropSet, dwPropId,
						&dwOptions, pvValue);
				}
			}
		}

		return hr;
	}
	HRESULT	SetPropValue(
		_In_ const GUID* pguidPropSet,
		_In_ DBPROPID dwPropId,
		_In_ VARIANT* pvValue)
	{
		HRESULT		hr = E_FAIL;
		ULONG		iPropSet;
		ULONG		iPropId;
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);

		if( GetIndexofPropSet(pguidPropSet, &iPropSet) == S_OK )
		{
			if( GetIndexofPropIdinPropSet(iPropSet, dwPropId, &iPropId) == S_OK )
			{
				ATLASSUME( m_pUPropSet[iPropSet].pUPropInfo[iPropId].dwFlags & (DBPROPFLAGS_WRITE | DBPROPFLAGS_CHANGE) );

				hr = VariantCopy(&(m_pUProp[iPropSet].pUPropVal[
						GetUPropValIndex(iPropSet, dwPropId)].vValue), pvValue);
			}
		}

		return hr;
	}

	//Pointer to properties in error mask
	DWORD* GetPropsInErrorPtr()
	{
		return m_rgdwPropsInError;
	}
	ULONG GetUPropSetCount()
	{
		return m_cUPropSet;
	}
	void SetUPropSetCount(_In_ ULONG c)
	{
		m_cUPropSet = c;
	}

	// NOTE: The following functions depend on all prior
	// properties in the array being writable.
	// This is because the UPROP array contains only writable elements,
	// and the UPROPINFO array contains writable and read-only elements.
	// (If this is a problem, we would need to define which one it came from
	// and add the appropriate ATLASSERTs...)

	//Get DBPROPOPTIONS_xx
	DWORD GetPropOption(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return m_pUProp[iPropSet].pUPropVal[iProp].dwOption;
	}
	//Set DBPROPOPTIONS_xx
	void SetPropOption(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ DWORD dwOption)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwOption = dwOption;
	}
	//Determine if property is required and variant_true
	BOOL IsRequiredTrue(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);

		return( (m_pUProp[iPropSet].pUPropVal[iProp].dwOption == DBPROPOPTIONS_REQUIRED) &&
				(V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) != ATL_VARIANT_FALSE) );
	}
	DWORD GetInternalFlags(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return m_pUProp[iPropSet].pUPropVal[iProp].dwFlags;
	}
	void AddInternalFlags(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ DWORD dwFlags)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwFlags |= dwFlags;
	}
	void RemoveInternalFlags(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ DWORD dwFlags)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		m_pUProp[iPropSet].pUPropVal[iProp].dwFlags &= ~dwFlags;
	}
	VARIANT * GetVariant(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return & m_pUProp[iPropSet].pUPropVal[iProp].vValue;
	}
	HRESULT SetVariant(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_Out_ VARIANT *pv)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		// Does VariantClear first.
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return VariantCopy( &m_pUProp[iPropSet].pUPropVal[iProp].vValue, pv );
	}
	void SetValEmpty(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		VariantClear( &m_pUProp[iPropSet].pUPropVal[iProp].vValue );
	}
	BOOL IsEmpty(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		return ( m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_EMPTY);
	}
	void SetValBool(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ VARIANT_BOOL bVal)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		// Note that we accept any "true" value.
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_BOOL;
		V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue) = (bVal ? ATL_VARIANT_TRUE : ATL_VARIANT_FALSE);
	}
	VARIANT_BOOL GetValBool(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BOOL);
		return V_BOOL(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
	}
	void SetValShort(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ SHORT iVal)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I2;
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal = iVal;
	}
	SHORT GetValShort(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I2);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.iVal;
	}
	void SetValLong(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_ LONG lVal)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VariantClear(&m_pUProp[iPropSet].pUPropVal[iProp].vValue);
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt = VT_I4;
		m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal = lVal;
	}
	LONG GetValLong(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_I4);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.lVal;
	}
	HRESULT SetValString(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp,
		_In_z_ const WCHAR *pwsz)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		VARIANT *pv = &m_pUProp[iPropSet].pUPropVal[iProp].vValue;
		VariantClear(pv);
		pv->bstrVal = SysAllocString(pwsz);
		if (pv->bstrVal)
			pv->vt = VT_BSTR;
		else
			return E_FAIL;

		// See if this was used for non-string type.
		// Typically this is an easy way to pass integer as a string.
		if (GetExpectedVarType(iPropSet,iProp) == VT_BSTR)
			return NOERROR;
		if (pwsz[0] != L'\0')
		{
			HRESULT hr=VariantChangeType( pv, pv, 0, GetExpectedVarType(iPropSet,iProp) );
			if(FAILED(hr))
			{
				pv->vt = VT_EMPTY;
			}
			return hr;
		}

		// Set to "", which for non-string means empty.
		SysFreeString(pv->bstrVal);
		return NOERROR;
	}
	const WCHAR * GetValString(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		CComCritSecLock<CComAutoCriticalSection> lock(m_oCriticalSection);
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		ATLASSUME(m_pUProp[iPropSet].pUPropVal[iProp].vValue.vt == VT_BSTR);
		return m_pUProp[iPropSet].pUPropVal[iProp].vValue.bstrVal;
	}
	const GUID * GetGuid(_In_ ULONG iPropSet)
	{
		ATLASSERT(iPropSet < m_cUPropSet);
		return m_pUPropSet[iPropSet].pPropSet;
	}
	DWORD GetPropID(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		return m_pUPropSet[iPropSet].pUPropInfo[iProp].dwPropId;
	}
	VARTYPE GetExpectedVarType(
		_In_ ULONG iPropSet,
		_In_ ULONG iProp)
	{
		ATLASSERT((  (iPropSet < m_cUPropSet)	&& (iProp < m_pUPropSet[iPropSet].cUPropInfo) && (iProp < m_pUProp[iPropSet].cPropIds) ));
		return m_pUPropSet[iPropSet].pUPropInfo[iProp].VarType;
	}
	virtual HRESULT	GetIndexofPropSet(
		_In_ const GUID* pPropSet,
		_Out_ ULONG* pulCurSet)
	{
		ATLENSURE_RETURN(pPropSet && pulCurSet);

		for(ULONG ul=0; ul<m_cUPropSet; ul++)
		{
			if( *pPropSet == *(m_pUPropSet[ul].pPropSet) )
			{
				*pulCurSet = ul;
				return S_OK;
			}
		}
		return S_FALSE;
	}

	virtual HRESULT OnPropertyChanged(
		_In_ ULONG /*iCurSet*/,
		_Inout_ DBPROP* pDBProp)
	{
		// Prevent Level 4 warnings.
		UNREFERENCED_PARAMETER(pDBProp);
__if_exists(T::CreateAccessor)
{
		ATLENSURE_RETURN(pDBProp != NULL);
		DWORD dwPropertyID = pDBProp->dwPropertyID;
		CComVariant var = pDBProp->vValue;

		switch(dwPropertyID)
		{
		case DBPROP_IRowsetLocate:
		case DBPROP_LITERALBOOKMARKS:
		case DBPROP_ORDEREDBOOKMARKS:
			{
				CDBPropSet set(DBPROPSET_ROWSET);
				CComVariant newVar;
				bool bVal;
				if (var.boolVal == ATL_VARIANT_TRUE)
					bVal = true;
				else
					bVal = false;

				newVar = bVal;

				// Set the bookmarks property as they are chained.  We also need to
				// turn off IRowsetLocate if we're setting BOOKMARKS to false (see
				// the DBPROP_BOOKMARKS case statement.
				if (var.boolVal == ATL_VARIANT_FALSE)
					SetPropValue(&DBPROPSET_ROWSET, DBPROP_IRowsetLocate, &newVar);

				SetPropValue(&DBPROPSET_ROWSET, DBPROP_BOOKMARKS, &newVar);

				// If you set IRowsetLocate to true, then the rowset can
				// handle backward scrolling
				if (dwPropertyID == DBPROP_IRowsetLocate)
					SetPropValue(&DBPROPSET_ROWSET, DBPROP_CANSCROLLBACKWARDS, &newVar);

				return S_OK;
			}
			break;

		case DBPROP_IRowsetScroll:
			{
				CDBPropSet set(DBPROPSET_ROWSET);

				if (var.boolVal == ATL_VARIANT_TRUE)
				{
					if(!set.AddProperty(DBPROP_IRowsetLocate, true))
					{
						return E_FAIL;
					}
					if(!set.AddProperty(DBPROP_BOOKMARKS, true))
					{
						return E_FAIL;
					}
					if(!set.AddProperty(DBPROP_CANSCROLLBACKWARDS, true))
					{
						return E_FAIL;
					}
				}

				const GUID* ppGuid[1];
				ppGuid[0] = &DBPROPSET_ROWSET;

				return SetProperties(0, 1, &set, 1, ppGuid);
			}
			break;

		case DBPROP_BOOKMARKS:
			{
				if (var.boolVal == ATL_VARIANT_FALSE)
				{
					// Since we support bookmarks, if someone sets DBPROP_BOOKMARKS
					// to ATL_VARIANT_FALSE and DBPROP_IRowsetLocate is ATL_VARIANT_TRUE,
					// then we should return an error.  This is an invalid
					// combination of properties.
					CComVariant locateVar;
					HRESULT hr = GetPropValue(&DBPROPSET_ROWSET,
						DBPROP_IRowsetLocate, &locateVar);
					if (SUCCEEDED(hr) && locateVar.boolVal == ATL_VARIANT_TRUE)
					{
						// If the DBPROP_BOOKMARKS is set to required, return
						// DB_E_ERRORSOCCURRED.  Otherwise, set it to
						// DB_S_ERRORSOCCURRED.  Note, we won't reset the property
						// since setting IRowsetLocate to ATL_VARIANT_TRUE will
						// set DBPROP_BOOKMARKS to ATL_VARIANT_TRUE
						pDBProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						if (pDBProp->dwOptions == DBPROPOPTIONS_REQUIRED)
							return DB_E_ERRORSOCCURRED;
						else
							return DB_S_ERRORSOCCURRED;
					}
				}
			}
			break;

		// This code should only be included if you are a command or rowset.
		case DBPROP_UPDATABILITY:
			{
				if (var.lVal != 0)
				{
					CComVariant changeVar;
					HRESULT hr = GetPropValue(&DBPROPSET_ROWSET,
						DBPROP_IRowsetChange, &changeVar);
					if (FAILED(hr) || changeVar.boolVal == ATL_VARIANT_FALSE)
					{
						// It doesn't make sense to set DBPROP_UPDATABILITY
						// if DBPROP_IRowsetChange is FALSE (i.e. no updates)
						pDBProp->dwStatus = DBPROPSTATUS_CONFLICTING;

						if (pDBProp->dwOptions == DBPROPOPTIONS_REQUIRED)
							return DB_E_ERRORSOCCURRED;
						else
							return DB_S_ERRORSOCCURRED;
					}
				}
			}

			// Update the IAccessor::m_bIsChangeable flag as necessary

			// Hold off on this for now, it appears to be causing a GPF becuase
			// we're writing this off the session.
//			pT->m_bIsChangeable = (var.iVal & DBPROPVAL_UP_INSERT);
			break;

		case DBPROP_IRowsetUpdate:
			{
				// Set the DBPROP_IRowsetChange and DBPROP_IRowsetUpdate flags.
				// Setting DBPROP_IRowsetUpdate to true sets DBPROP_IRowsetChange
				// to true

				if (var.boolVal == ATL_VARIANT_TRUE)
				{
					CComVariant changeVar(true);
					CDBPropSet set(DBPROPSET_ROWSET);
					if(!set.AddProperty(DBPROP_IRowsetChange, changeVar))
					{
						return E_FAIL;
					}

					const GUID* ppGuid[1];
					ppGuid[0] = &DBPROPSET_ROWSET;

					return SetProperties(0, 1, &set, 1, ppGuid);
				}
			}
			break;

		default:
			break;
		}
}

		return S_OK;
	}

	virtual HRESULT	InitUPropSetsSupported()
	{
		return InternalInitUPropSetsSupported(T::_GetPropSet);
	}

	HRESULT GetIndexOfPropertyInSet(
		_In_ const GUID* pPropSet,
		_In_ DBPROPID dwPropertyId,
		_Out_ ULONG* piCurPropId,
		_Out_ ULONG* piCurSet)
	{
		HRESULT hr = GetIndexofPropSet(pPropSet, piCurSet);
		if (hr == S_FALSE)
			return hr;
		UPROPINFO* pUPropInfo = m_pUPropSet[*piCurSet].pUPropInfo;
		for(ULONG ul=0; ul<m_pUPropSet[*piCurSet].cUPropInfo; ul++)
		{
			if( dwPropertyId == pUPropInfo[ul].dwPropId )
				*piCurPropId = ul;
			return S_OK;
		}

		return S_FALSE;
	}
	HRESULT SetSupportedBit(
		_In_ const GUID* pPropSet,
		_In_ DBPROPID dwPropertyId)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			m_rgdwSupported[iCurSet * m_cElemPerSupported] |= 1 << iCurPropId;
			return S_OK;
		}
		return S_FALSE;
	}

	HRESULT ClearSupportedBit(
		_In_ const GUID* pPropSet,
		_In_ DBPROPID dwPropertyId)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			m_rgdwSupported[iCurSet * m_cElemPerSupported] &= ~( 1 << iCurPropId);
			return S_OK;
		}
		return S_FALSE;
	}

	HRESULT TestSupportedBit(
		_In_ const GUID* pPropSet,
		_In_ DBPROPID dwPropertyId,
		_Out_ bool& bSet)
	{
		ULONG iCurPropId, iCurSet;

		if (GetIndexOfPropertyInSet(pPropSet, dwPropertyId, &iCurPropId, &iCurSet) == S_OK)
		{
			bSet = (m_rgdwSupported[iCurSet * m_cElemPerSupported] & ( 1 << iCurPropId)) != 0;
			return S_OK;
		}
		return S_FALSE;
	}
	void CopyPropsInError(_Out_ DWORD* rgdwSupported)
	{
		Checked::memcpy_s(rgdwSupported, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD),
			m_rgdwPropsInError, m_cUPropSet * m_cElemPerSupported * sizeof(DWORD));
	}
};

// IDBPropertiesImpl
// IDBProperties <- IUnknown
template <class T>
class ATL_NO_VTABLE IDBPropertiesImpl :
	public IDBProperties,
	public CUtlProps<T>
{
public:
	STDMETHOD(GetProperties)(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPIDSET rgPropertySets[],
		_Out_ ULONG *pcProperties,
		_Out_ _Deref_post_opt_cap_(*pcProperties) DBPROPSET **prgProperties)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::GetProperties\n"));
		T* pT = (T*)this;

		// You can get PROPERTIESINERROR on IDBProperties::GetProperties so do the
		// appropriate argument checking for it.
		m_dwFlags |= ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertySets, rgPropertySets, pcProperties, prgProperties);
		if (FAILED(hr))
			return hr;

		if (SUCCEEDED(hr))
		{
			// To allow user defined property groups, we'll scan the property
			// sets.

			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			if (pT->m_dwStatus & DSF_INITIALIZED)
			{
				for(l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for (l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets,
							pcProperties, prgProperties, ulPropInits, ppGuid);
			}
			else
			{
				// Only pass through initialization groups
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ulPropInits++;
				}
				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::GetProperties(cPropertySets, rgPropertySets,
							pcProperties, prgProperties, ulPropInits, ppGuid);
			}
		}

		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		return hr;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetPropertyInfo)(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) const DBPROPIDSET rgPropertySets[],
		_Out_ ULONG *pcPropertyInfoSets,
		_Out_ _Deref_post_opt_cap_(*pcPropertyInfoSets) DBPROPINFOSET **prgPropertyInfoSets,
		_Deref_opt_out_z_ OLECHAR **ppDescBuffer)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::GetPropertyInfo\n"));
		T* pT = static_cast<T*>(this);
		T::ObjectLock cab(pT);

		if (pT->m_pCUtlPropInfo == NULL)
		{
			// Go ahead and create the m_pCUtlPropInfo but do not change the
			// Initialized status of the provider (see IDBInitialize::Initialize).
			ATLTRACE(atlTraceDBProvider, 2, _T("m_pCUtlPropInfo == NULL\n"));
			delete pT->m_pCUtlPropInfo;
			pT->m_pCUtlPropInfo = NULL;
			ATLTRY(pT->m_pCUtlPropInfo = new CUtlPropInfo<T>())
			if (pT->m_pCUtlPropInfo == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("IDBProperties::GetPropertyInfo Error : OOM\n"));
				return E_OUTOFMEMORY;
			}
			HRESULT hr = pT->m_pCUtlPropInfo->FInit();
			if (hr != S_OK)
			{
				delete pT->m_pCUtlPropInfo;
				pT->m_pCUtlPropInfo = NULL;
				return E_FAIL;
			}
		}

		// Initialize
		if( pcPropertyInfoSets )
			*pcPropertyInfoSets = 0;
		if( prgPropertyInfoSets )
			*prgPropertyInfoSets = NULL;
		if( ppDescBuffer )
			*ppDescBuffer = NULL;

		// Check Arguments
		if( ((cPropertySets > 0) && !rgPropertySets) ||
			!pcPropertyInfoSets || !prgPropertyInfoSets )
			return E_INVALIDARG;

		// New argument check for > 1 cPropertyIDs and NULL pointer for
		// array of property ids.
		const DWORD SPECIAL_GROUP		= 1;
		const DWORD SPECIAL_SINGLE		= 2;
		const DWORD SPECIALS			= SPECIAL_GROUP | SPECIAL_SINGLE;
		DWORD dwSpecial = 0;
		for(ULONG ul=0; ul<cPropertySets; ul++)
		{
			if( (rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_DATASOURCEINFOALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_DBINITALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_SESSIONALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_ROWSETALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_COLUMNALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_CONSTRAINTALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_INDEXALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_TABLEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_TRUSTEEALL) ||
				(rgPropertySets[ul].guidPropertySet == DBPROPSET_VIEWALL))
				dwSpecial |= SPECIAL_GROUP;
			else
				dwSpecial |= SPECIAL_SINGLE;

			// Check for property sets containing both singles and groups
			// Check for cPropertyIDs != 0 & rgPropertyIDs == NULL
			if( (dwSpecial == SPECIALS) ||
				(rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs)) )
				return E_INVALIDARG;
		}

		if (pT->m_dwStatus & DSF_INITIALIZED)
			return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets,
											  pcPropertyInfoSets, prgPropertyInfoSets,
											  ppDescBuffer, true);
		else
			return pT->m_pCUtlPropInfo->GetPropertyInfo(cPropertySets, rgPropertySets,
											  pcPropertyInfoSets, prgPropertyInfoSets,
											  ppDescBuffer, false, &DBPROPSET_DBINITALL);

	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(SetProperties)(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBPropertiesImpl::SetProperties\n"));
		HRESULT	hr;
		CAutoVectorPtr < DBPROPSET > pdbPropSet;
		ULONG iProp;
		typedef const GUID* PCGUID;
		T* pT = static_cast<T*>(this);

		// Quick return if the Count of Properties is 0
		if( cPropertySets == 0 )
			return S_OK;

		// Determine how many sets are in the current map
		T::ObjectLock lock(pT);
		UPROPSET* pSetA = NULL;
		UPROPSET* pSetTemp = NULL;
		ULONG l=0;
		ULONG ulPropSets = 0;
		ULONG ulPropElems = 0;
		ULONG ulPropInits = 0;
		ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);
		ULONG iNewSet, iSet;

		CTempBuffer<UPROPSET> tmpBuffer;
		pSetA = tmpBuffer.Allocate(cSets);
		if (pSetA == NULL)
			return E_OUTOFMEMORY;  // We shouldn't get this but...

		pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

		hr = CUtlProps<T>::SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if(SUCCEEDED(hr))
		{
			// We need to handle the DBINIT properties specially after being initialized.
			// - they should be treated as NOTSETTABLE at this point.
			if( pT->m_dwStatus & DSF_INITIALIZED )
			{
				ATLASSERT(cPropertySets);

				BOOL fFoundDBINIT = FALSE;

				// Allocate a DBPROPSET structure of equal size
				pdbPropSet.Allocate( cPropertySets );
				if( pdbPropSet == NULL )
					return E_OUTOFMEMORY;

				for(iNewSet=0,iSet=0; iSet<cPropertySets; iSet++)
				{
					// Remove any DBPROPSET_DBINIT values and mark them all
					// as not settable
					if( (rgPropertySets[iSet].guidPropertySet == DBPROPSET_DBINIT))
					{
						fFoundDBINIT = TRUE;
						for(iProp=0; iProp<rgPropertySets[iSet].cProperties; iProp++)
							rgPropertySets[iSet].rgProperties[iProp].dwStatus = DBPROPSTATUS_NOTSETTABLE;
					}
					else
					{
						// If not DBPROPSET_DBINIT then copy the DBPROPSET values
						pdbPropSet[iNewSet++] = rgPropertySets[iSet];
					}
				}

				// If we have no propertyset to pass on to the property handler, we
				// can exit
				if( iNewSet == 0 )
				{
					return DB_E_ERRORSOCCURRED;
				}

				for(l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for (l=0; l<cSets; l++)
				{
					if (pSetTemp[l].bIsChained != true)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::SetProperties(0, iNewSet, pdbPropSet, ulPropInits, ppGuid);

				// If we have determined that one of the property sets was DBINIT, we may
				// need to fixup the returned hr value.
				if( fFoundDBINIT && SUCCEEDED(hr))
					hr = DB_S_ERRORSOCCURRED;
			}
			else
			{
				// Note that m_pCUtlProps knows about initialization,
				// so we don't have to here. Only pass DBPROPSET_DBINIT or custom
				// initialization groups

				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ulPropInits++;
				}

				CTempBuffer<PCGUID> tmpBuffer2;
				PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
				if (ppGuid == NULL)
					return E_OUTOFMEMORY;

				ulPropInits = 0;
				for(l=0; l<cSets; l++)
				{
					if (IsEqualGUID(*pSetTemp[l].pPropSet, DBPROPSET_DBINIT) ||
						pSetTemp[l].dwFlags & UPROPSET_USERINIT)
						ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
				}

				hr = CUtlProps<T>::SetProperties(0, cPropertySets, rgPropertySets,
						ulPropInits, ppGuid);
			}
		}

		return hr;
	}
};

#define BEGIN_SCHEMA_MAP(SchemaClass) \
	typedef SchemaClass _SchemaClass; \
	HRESULT _SchemaSupport( \
		_Deref_opt_out_opt_ GUID** ppGuid, \
		_Inout_opt_ IUnknown *pUnkOuter, \
		_In_ REFIID rguidSchema, \
		_In_ ULONG cRestrictions, \
		_In_opt_count_(cRestrictions) const VARIANT rgRestrictions[], \
		_In_ REFIID riid, \
		_In_ ULONG cPropertySets, \
		_In_opt_count_(cPropertySets) DBPROPSET rgPropertySets[], \
		_Deref_opt_out_opt_ IUnknown **ppRowset) \
	{ \
	int cGuids = 0; \
	HRESULT hr = S_OK; \
	if (ppGuid != NULL) \
		*ppGuid = NULL;

#define SCHEMA_ENTRY(guid, rowsetClass) \
	if (ppGuid != NULL && SUCCEEDED(hr)) \
	{ \
		cGuids++; \
		*ppGuid = ATL::AtlSafeRealloc<GUID, ATL::CComAllocator>(*ppGuid, cGuids); \
		hr = (*ppGuid == NULL) ? E_OUTOFMEMORY : S_OK; \
		if (SUCCEEDED(hr)) \
			(*ppGuid)[cGuids - 1] = guid; \
		else \
			return hr; \
	} \
	else \
	{ \
		if (InlineIsEqualGUID(guid, rguidSchema)) \
		{ \
			ATLASSUME(rgRestrictions != NULL); \
			rowsetClass* pRowset = NULL; \
			hr = CheckRestrictions(rguidSchema, cRestrictions, rgRestrictions); \
			if (FAILED(hr)) \
				return E_INVALIDARG; \
			hr =  CreateSchemaRowset(pUnkOuter, cRestrictions, \
							   rgRestrictions, riid, cPropertySets, \
							   rgPropertySets, ppRowset, pRowset); \
			return hr; \
		} \
	}

#define END_SCHEMA_MAP() \
		if (ppGuid != NULL) \
			return hr; \
		return E_INVALIDARG; \
	}
	

template <class SessionClass>
class  ATL_NO_VTABLE IDBSchemaRowsetImpl:
	public IDBSchemaRowset
{
public:
	OUT_OF_LINE HRESULT InternalCreateSchemaRowset(
		_In_opt_ IUnknown *pUnkOuter,
		_In_ ULONG cRestrictions,
		_In_count_(cRestrictions) const VARIANT rgRestrictions[],
		_In_ REFIID riid,
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[],
		_Deref_opt_out_ IUnknown** ppRowset,
		_Inout_ IUnknown* pUnkThis,
		_Inout_ CUtlPropsBase* pProps,
		_Inout_opt_ IUnknown* pUnkSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::InternalCreateSchemaRowset\n"));
		UNREFERENCED_PARAMETER(cRestrictions);
		UNREFERENCED_PARAMETER(rgRestrictions);

		HRESULT hr, hrProps = S_OK;
		if (ppRowset != NULL)
			*ppRowset = NULL;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPtr<IUnknown> spUnk;
		hr = pUnkThis->QueryInterface(__uuidof(IUnknown), (void**)&spUnk);
		if (FAILED(hr))
			return hr;

		hr = pProps->FInit();
		if (FAILED(hr))
			return hr;
		hr = pProps->SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if (FAILED(hr))
			return hr;
		const GUID* ppGuid[1];
		ppGuid[0] = &DBPROPSET_ROWSET;

		// Call SetProperties.  The true in the last parameter indicates
		// the special behavior that takes place on rowset creation (i.e.
		// it succeeds as long as any of the properties were not marked
		// as DBPROPS_REQUIRED.

		hrProps = pProps->SetProperties(0, cPropertySets, rgPropertySets,
											1, ppGuid, true);
		if (FAILED(hrProps))
			return hrProps;

		CComQIPtr<IObjectWithSite> spSite = spUnk;
		ATLASSERT(spSite != NULL);
		hr = spSite->SetSite(pUnkSession);
		if (FAILED(hr))
			return hr;
		if (InlineIsEqualGUID(riid, IID_NULL))
			return E_NOINTERFACE;
		if(ppRowset)
		{
			hr = spUnk->QueryInterface(riid, (void**)ppRowset);
		}
		if (FAILED(hr))
		{
			if(ppRowset)
			{
				*ppRowset = NULL;
			}
			return hr;
		}
		return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
	}
	
ATLPREFAST_SUPPRESS(6387)
	template <class SchemaRowsetClass>
	HRESULT CreateSchemaRowset(
		_Inout_opt_ IUnknown *pUnkOuter,
		_In_ ULONG cRestrictions,
		_In_count_(cRestrictions) const VARIANT rgRestrictions[],
		_In_ REFIID riid,
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[],
		_Deref_opt_out_ IUnknown** ppRowset,
		_Inout_ SchemaRowsetClass*& pSchemaRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::CreateSchemaRowset\n"));

		HRESULT hrProps, hr = S_OK;
		CComPolyObject<SchemaRowsetClass>* pPolyObj;
		SessionClass* pT = (SessionClass*) this;
		if (FAILED(hr = CComPolyObject<SchemaRowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		pSchemaRowset = &(pPolyObj->m_contained);
		CComPtr<IUnknown> spOuterUnk;
		(pT->GetUnknown())->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		SchemaRowsetClass* myPT = (SchemaRowsetClass*) pSchemaRowset;
		hr = InternalCreateSchemaRowset(pUnkOuter, cRestrictions, rgRestrictions,
										riid, cPropertySets, rgPropertySets, ppRowset,
										pPolyObj, myPT, spOuterUnk);
		// Ref the created COM object and Auto release it on failure
		if (FAILED(hr))
		{
			delete pPolyObj;
			return hr;
		}

		hrProps = hr;
		// Get a pointer to the Rowset instance
		DBROWCOUNT cRowsAffected;
		hr = pSchemaRowset->Execute(&cRowsAffected, cRestrictions, rgRestrictions);
		if (FAILED(hr))
			return hr;

		return (hrProps == DB_S_ERRORSOCCURRED) ? hrProps : hr;
	}
ATLPREFAST_UNSUPPRESS()
	
	void SetRestrictions(
		_In_ ULONG cRestrictions,
		_In_opt_ GUID* /*rguidSchema*/,
		_In_count_(cRestrictions) ULONG* rgRestrictions)
	{
		memset(rgRestrictions, 0, sizeof(ULONG) * cRestrictions);
	}

	STDMETHOD(GetSchemas)(
		_Out_ ULONG* pcSchemas,
		_Deref_out_ GUID** prgSchemas,
		_Deref_opt_out_ ULONG** prgRest)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::GetSchemas\n"));
		if (pcSchemas != NULL)
			*pcSchemas = 0;
		if (prgSchemas != NULL)
			*prgSchemas = NULL;
		if (pcSchemas == NULL || prgSchemas == NULL)
			return E_INVALIDARG;

		SessionClass* pT = (SessionClass*)this;

		HRESULT hr = pT->_SchemaSupport(prgSchemas, NULL, GUID_NULL, 0,
										NULL, GUID_NULL, 0, NULL, NULL);
		if (FAILED(hr))
			return hr;

		CComPtr<IMalloc> spMalloc;
		hr = CoGetMalloc(1, &spMalloc);
		if (FAILED(hr))
		{
			CoTaskMemFree(*prgSchemas);
			*prgSchemas = NULL;
			return hr;
		}
		*pcSchemas = (ULONG)(spMalloc->GetSize(*prgSchemas) / sizeof(GUID));

		if (prgRest != NULL)
		{
			// The OLE DB spec states that if prgRest == NULL not to return array
			// but it also says that is E_INVALIDARG, so doing first
			size_t nBytes=0;
			if( FAILED(hr=::ATL::AtlMultiply(&nBytes, sizeof(ULONG), static_cast<size_t>(*pcSchemas))))
			{
				spMalloc->Free(*prgSchemas);
				*prgSchemas = NULL;
				return hr;
			}
			*prgRest = (ULONG*) spMalloc->Alloc(nBytes);
			if (*prgRest == NULL)
			{
				spMalloc->Free(*prgSchemas);
				*prgSchemas = NULL;
				return E_OUTOFMEMORY;
			}
			pT->SetRestrictions(*pcSchemas, *prgSchemas, *prgRest);
		}
		return hr;
	}
	STDMETHOD(GetRowset)(
		_Inout_opt_ IUnknown *pUnkOuter,
		_In_ REFGUID rguidSchema,
		_In_ ULONG cRestrictions,
		_In_count_(cRestrictions) const VARIANT rgRestrictions[],
		_In_ REFIID riid,
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[],
		_Deref_out_ IUnknown **ppRowset)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBSchemaRowsetImpl::GetRowset\n"));
		SessionClass* pT = (SessionClass*)this;

		// You must specify a rowset pointer per the specification
		if (ppRowset == NULL || (cRestrictions > 0 && rgRestrictions == NULL) ||
			(cPropertySets > 0 && rgPropertySets == NULL))
			return E_INVALIDARG;

		if (rgPropertySets != NULL)
		{
			for (ULONG ulSet = 0; ulSet < cPropertySets; ulSet++)
			{
				if (rgPropertySets[ulSet].cProperties > 0 &&
					rgPropertySets[ulSet].rgProperties == NULL)
					return E_INVALIDARG;
			}
		}

		return  pT->_SchemaSupport(NULL, pUnkOuter, rguidSchema, cRestrictions,
								   rgRestrictions, riid, cPropertySets,
								   rgPropertySets, ppRowset);

	}

	HRESULT CheckRestrictions(
		_In_ REFGUID rguidSchema,
		_In_ ULONG cRestrictions,
		_In_count_(cRestrictions) const VARIANT rgRestrictions[])
	{
		// Use this function to help check the validity of restrictions
		// against a schema rowset.
		const VARTYPE rgRestrictionTypes[3][4] = {
			{ VT_BSTR, VT_BSTR, VT_BSTR, VT_BSTR },		// DBSCHEMA_TABLES
			{ VT_BSTR, VT_BSTR, VT_BSTR, VT_BSTR },		// DBSCHEMA_COLUMNS
			{ VT_UI2, VT_BOOL, VT_EMPTY, VT_EMPTY }};	// DBSCHEMA_PROVIDER_TYPES
		const ULONG ulMaxRestrictions[3] = { 4, 4, 2};

		ULONG ulRes = 0;
		ULONG ulType = 3;

		if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_TABLES))
			ulType = 0;
		else if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_COLUMNS))
			ulType = 1;
		else if (InlineIsEqualGUID(rguidSchema, DBSCHEMA_PROVIDER_TYPES))
			ulType = 2;

		if (ulType < 3)		// I.E. we found one of our supported rowsets
		{
			ULONG ulCurrentRestrictions = 0x00;
			ULONG ulCurrentMask = 0x01;

			// Ask the provider's session object for its list of restrictions
			SessionClass* pT = (SessionClass*)this;
			pT->SetRestrictions(1, (GUID*)&rguidSchema, &ulCurrentRestrictions);

			ATLASSERT(ulType >= 0 && ulType < 3);
			// We allow VT_EMPTY through in case the consumer wanted to ignore this
			// restriction (basically a way to pass in 'NULL').
			if (cRestrictions > ulMaxRestrictions[ulType])
				return E_INVALIDARG;

			for (ulRes = 0; ulRes < cRestrictions; ulRes++)
			{
				// Check for obviously invalid types
				if (rgRestrictions[ulRes].vt != rgRestrictionTypes[ulType][ulRes] &&
					rgRestrictions[ulRes].vt != DBTYPE_EMPTY &&
					rgRestrictions[ulRes].vt != VT_NULL )
					return E_INVALIDARG;

				// Check for restrictions the provider doesn't support.
				if (!(ulCurrentMask & ulCurrentRestrictions) &&
					(rgRestrictions[ulRes].vt != DBTYPE_EMPTY))
					return E_INVALIDARG;

				ulCurrentMask <<= 1;		// Increase mask by * 2;
			}
		}

		return S_OK;
	}
};

// IDBCreateCommandImpl
template <class T, class CommandClass>
class ATL_NO_VTABLE IDBCreateCommandImpl :
	public IDBCreateCommand
{
public:
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(CreateCommand)(
		_Inout_opt_ IUnknown *pUnkOuter,
		_In_ REFIID riid,
		_Deref_out_ IUnknown** ppvCommand)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IDBCreateCommandImpl::CreateCommand\n"));
		T* pT = (T*) this;

		if (ppvCommand == NULL)
			return E_INVALIDARG;
		else
			*ppvCommand = NULL;

		HRESULT hr;
		CComPolyObject<CommandClass>* pCommand;

		// You can't QI for an interface other than IUnknown when aggregating
		// and creating the object.  You might ask for your own interface,
		// which would be bad.  Note, we return DB_E_NOAGGREGATION instead of
		// CLASS_E_NOAGGREGATION due to OLE DB constraints.
		if (pUnkOuter != NULL && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;

		hr = CComPolyObject<CommandClass>::CreateInstance(pUnkOuter, &pCommand);
		if (FAILED(hr))
			return hr;

		ATLASSUME(pCommand != NULL);
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pCommand->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pCommand; // must hand delete as it is not ref'd
			return hr;
		}
		ATLASSERT(pCommand->m_contained.m_spUnkSite == NULL);
		CComPtr<IUnknown> spOuterUnk;
		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (SUCCEEDED(hr))
		{
			hr = pCommand->m_contained.SetSite(spOuterUnk);
			if (SUCCEEDED(hr))
			{
				hr = pCommand->QueryInterface(riid, (void**)ppvCommand);
			}
		}
		return hr;
	}
ATLPREFAST_UNSUPPRESS()
};

// IGetDataSourceImpl
template <class T>
class ATL_NO_VTABLE IGetDataSourceImpl :
	public IGetDataSource
{
public:
	STDMETHOD(GetDataSource)(
		_In_ REFIID riid,
		_Deref_out_ IUnknown **ppDataSource)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IGetDataSourceImpl::GetDataSource\n"));
		if (ppDataSource == NULL)
			return E_INVALIDARG;
		T* pT = (T*) this;
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**)ppDataSource);
	}
};


// IOpenRowsetImpl
template <class SessionClass>
class IOpenRowsetImpl :
	public IOpenRowset
{
public:
ATLPREFAST_SUPPRESS(6387)
	template <class RowsetClass>
	HRESULT CreateRowset(
		_Inout_opt_ IUnknown* pUnkOuter,
		_In_opt_ DBID *pTableID,
		_In_opt_ DBID *pIndexID,
		_In_ REFIID riid,
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[],
		_Deref_out_ IUnknown** ppRowset,
		_In_ RowsetClass*& pRowsetObj)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IOpenRowsetImpl::CreateRowset\n"));

		HRESULT hr, hrProps = S_OK;
		if (ppRowset != NULL)
			*ppRowset = NULL;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPolyObject<RowsetClass>* pPolyObj;
		if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pPolyObj->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pPolyObj; // must hand delete as it is not ref'd
			return hr;
		}
		// Get a pointer to the Rowset instance
		pRowsetObj = &(pPolyObj->m_contained);
		hr = pRowsetObj->FInit();
		if (FAILED(hr))
			return hr;
		hr = pRowsetObj->SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if (FAILED(hr))
			return hr;

		const GUID* ppGuid[1];
		ppGuid[0] = &DBPROPSET_ROWSET;

		// Call SetProperties.  The true in the last parameter indicates
		// the special behavior that takes place on rowset creation (i.e.
		// it succeeds as long as any of the properties were not marked
		// as DBPROPS_REQUIRED.

		hrProps = pRowsetObj->SetProperties(0, cPropertySets, rgPropertySets,
											1, ppGuid, true);
		if (FAILED(hrProps))
			return hrProps;
		CComPtr<IUnknown> spOuterUnk;
		hr = ((SessionClass*)this)->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}

		hr = pRowsetObj->SetSite(spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}

		hr = pRowsetObj->SetCommandText(pTableID, pIndexID);
		if (FAILED(hr))
			return hr;
		DBROWCOUNT cRowsAffected;

		// Check to make sure we set any 'post' properties based on the riid
		// requested.
		if (FAILED(pRowsetObj->OnInterfaceRequested(riid)))
			return hr;

		HRESULT hrExecute;
		if (FAILED(hrExecute = pRowsetObj->Execute(NULL, &cRowsAffected)))
			return hrExecute;
/*
		CComVariant varMaxRows;
		if (SUCCEEDED(pRowsetObj->GetPropValue(&DBPROPSET_ROWSET, DBPROP_MAXROWS, &varMaxRows)))
		{
			if( varMaxRows.lVal > 0 )
			{
				if( pRowsetObj->m_rgRowData.GetCount() > (size_t)varMaxRows.lVal )
				{
					pRowsetObj->m_rgRowData.RemoveAt( varMaxRows.lVal,
														pRowsetObj->m_rgRowData.GetCount() - varMaxRows.lVal );
				}
			}
		}
*/
		if (InlineIsEqualGUID(riid, IID_NULL))
		{
			return E_NOINTERFACE;
		}
		else
		{
			if (ppRowset == NULL)
				//return (hrProps == DB_S_ERRORSOCCURRED) ? DB_E_ERRORSOCCURRED : hr;
				return hrProps;
			hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);

		}

		if (FAILED(hr))
		{
			*ppRowset = NULL;
			return hr;
		}

		return (hrProps == DB_S_ERRORSOCCURRED && hrExecute != DB_S_STOPLIMITREACHED) ? hrProps : hrExecute;
	}
ATLPREFAST_UNSUPPRESS()
};


// IColumnsInfoImpl
template <class T>
class ATL_NO_VTABLE IColumnsInfoImpl :
	public IColumnsInfo,
	public CDBIDOps
{
public:

	HRESULT CheckCommandText(_Inout_ IUnknown* pUnkThis)
	{
		HRESULT hr = E_FAIL;
		CComPtr<ICommandText> spText;
		if (SUCCEEDED(hr = pUnkThis->QueryInterface(__uuidof(ICommandText), (void**)&spText)))
		{
			LPOLESTR szCommand;
			hr = spText->GetCommandText(NULL, &szCommand);
			if (SUCCEEDED(hr))
				CoTaskMemFree(szCommand);
		}
		return hr;
	}
	OUT_OF_LINE HRESULT InternalGetColumnInfo(
		_Out_ DBORDINAL *pcColumns,
		_Out_ _Deref_post_cap_(*pcColumns) ATLCOLUMNINFO** ppInfo)
	{
		ATLENSURE_RETURN(ppInfo != NULL);
		T* pT = (T*) this;
		if (pT->CheckCommandText(pT->GetUnknown()) == DB_E_NOCOMMAND)
			return DB_E_NOCOMMAND;
		*ppInfo = T::GetColumnInfo(pT, pcColumns);
		return S_OK;
	}
	
ATLPREFAST_SUPPRESS(6387)
	STDMETHOD(GetColumnInfo)(
		_Out_ DBORDINAL *pcColumns,
		_Deref_out_ DBCOLUMNINFO **prgInfo,
		_Deref_out_z_ OLECHAR **ppStringsBuffer)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IColumnsInfoImpl::GetColumnInfo\n"));
		if (pcColumns == NULL || prgInfo == NULL || ppStringsBuffer == NULL)
		{
			if (prgInfo != NULL)
				*prgInfo = NULL;
			if (ppStringsBuffer != NULL)
				*ppStringsBuffer = NULL;
			if (pcColumns != NULL)
				*pcColumns = NULL;
			return E_INVALIDARG;
		}

		// NULL out pointers in case of an error
		*prgInfo = NULL;
		*ppStringsBuffer = NULL;
		*pcColumns = 0;

		ATLCOLUMNINFO* pInfo;
		HRESULT hr = InternalGetColumnInfo(pcColumns, &pInfo);
		if (FAILED(hr))
			return hr;
		*prgInfo = (DBCOLUMNINFO*)::ATL::AtlCoTaskMemCAlloc(*pcColumns, static_cast<ULONG>(sizeof(DBCOLUMNINFO)));
		if (*prgInfo != NULL)
		{
			ULONG cwRequired;
			DBORDINAL iCol;
			for (iCol = 0, cwRequired = 0; iCol < *pcColumns; iCol++)
			{
				(*prgInfo)[iCol].pwszName = pInfo[iCol].pwszName;
				(*prgInfo)[iCol].pTypeInfo = pInfo[iCol].pTypeInfo;
				(*prgInfo)[iCol].iOrdinal = pInfo[iCol].iOrdinal;
				(*prgInfo)[iCol].dwFlags = pInfo[iCol].dwFlags;
				(*prgInfo)[iCol].ulColumnSize = pInfo[iCol].ulColumnSize;
				(*prgInfo)[iCol].wType = pInfo[iCol].wType;
				(*prgInfo)[iCol].bPrecision = pInfo[iCol].bPrecision;
				(*prgInfo)[iCol].bScale = pInfo[iCol].bScale;
				(*prgInfo)[iCol].columnid = pInfo[iCol].columnid;

				if (pInfo[iCol].pwszName)
				{
					cwRequired += static_cast<ULONG>(wcslen(pInfo[iCol].pwszName) + 1);
				}
			}
			*ppStringsBuffer = (OLECHAR*)::ATL::AtlCoTaskMemCAlloc(cwRequired, static_cast<ULONG>(sizeof(OLECHAR)));
			if (*ppStringsBuffer)
			{
				DBORDINAL iColStrings;
				size_t iOffset;
				for (iColStrings = 0, iOffset = 0; iColStrings < *pcColumns; iColStrings++)
				{
					if (pInfo[iColStrings].pwszName)
					{
						if(!ocscpy_s(*ppStringsBuffer + iOffset, cwRequired-iOffset, pInfo[iColStrings].pwszName))
						{
							return E_FAIL;
						}
						(*prgInfo)[iColStrings].pwszName = *ppStringsBuffer + iOffset;
						if ((pInfo[iColStrings].columnid.eKind == DBKIND_GUID_NAME ||
							 pInfo[iColStrings].columnid.eKind == DBKIND_NAME ||
							 pInfo[iColStrings].columnid.eKind == DBKIND_PGUID_NAME))
						{
							(*prgInfo)[iColStrings].columnid.uName.pwszName  = *ppStringsBuffer + iOffset;
						}
						iOffset += wcslen(*ppStringsBuffer + iOffset) + 1;
					}
				}
				return S_OK;
			}
			else
			{
				ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate string buffer\n"));
				CoTaskMemFree(*prgInfo);
				*prgInfo = NULL;
				*pcColumns = 0;
				return E_OUTOFMEMORY;
			}
		}
		else
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate ColumnInfo array\n"));
			*prgInfo = NULL;
			*pcColumns = 0;
			return E_OUTOFMEMORY;
		}
	}
ATLPREFAST_UNSUPPRESS()
	
	STDMETHOD(MapColumnIDs)(
		_In_ DBORDINAL cColumnIDs,
		_In_count_(cColumnIDs) const DBID rgColumnIDs[],
		_Out_cap_(cColumnIDs) DBORDINAL rgColumns[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IColumnsInfoImpl::MapColumnIDs\n"));
		if ((cColumnIDs != 0 && rgColumnIDs == NULL) || rgColumns == NULL)
			return E_INVALIDARG;
		DBORDINAL cCols = 0;
		DBORDINAL cColsInError = 0;
		HRESULT hr = S_OK;
		ATLCOLUMNINFO* pInfo;
		for (DBORDINAL iColId = 0; iColId < cColumnIDs; iColId++)
		{
			hr = InternalGetColumnInfo(&cCols, &pInfo);
			if (hr == DB_E_NOCOMMAND)
				return hr;
			DBORDINAL iColMapCur = 0;
			BOOL bDone = FALSE;
			while(iColMapCur < cCols && !bDone)
			{
				hr = CompareDBIDs(&(pInfo[iColMapCur].columnid), &(rgColumnIDs[iColId]));
				bDone = (hr == S_OK || FAILED(hr));
				if (hr == S_OK)
					rgColumns[iColId] = pInfo[iColMapCur].iOrdinal;
				iColMapCur++;
			}
			if (!bDone || FAILED(hr))
			{
				rgColumns[iColId] = DB_INVALIDCOLUMN;
				cColsInError++;
			}

		}
		if (cColsInError > 0 && cColumnIDs == cColsInError)
			return DB_E_ERRORSOCCURRED;
		if (cColsInError > 0 && cColsInError < cColumnIDs)
			return DB_S_ERRORSOCCURRED;
		return S_OK;
	}
};

//IConvertTypeImpl
template <class T>
class ATL_NO_VTABLE IConvertTypeImpl :
	public IConvertType,
	public CConvertHelper
{
public:
	HRESULT InternalCanConvert(
		_In_ DBTYPE wFromType,
		_In_ DBTYPE wToType,
		_In_ DBCONVERTFLAGS dwConvertFlags,
		_In_ bool bIsCommand,
		_In_ bool bHasParamaters,
		_Inout_ IObjectWithSite* pSite)
	{

		// Determine if new 2.x flags are valid
		if((dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_COLUMN
			&& (dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_PARAMETER )
			return DB_E_BADCONVERTFLAG;

		// If the convert flags are for DBCONVERTFLAGS_FROMVARIANT, check to see
		// that the type is a variant type
		if (dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT)
		{
			if ((wFromType == DBTYPE_BYTES) ||
				(wFromType == DBTYPE_STR) ||
				(wFromType == DBTYPE_WSTR) ||
				(wFromType == DBTYPE_NUMERIC) ||
				(wFromType == DBTYPE_UDT) ||
				(wFromType == DBTYPE_DBDATE) ||
				(wFromType == DBTYPE_DBTIME) ||
				(wFromType == DBTYPE_DBTIMESTAMP) ||
				(wFromType == DBTYPE_HCHAPTER) ||
				(wFromType == DBTYPE_PROPVARIANT) ||
				(wFromType == DBTYPE_VARNUMERIC))
				return DB_E_BADTYPE;
		}

		// Note, if the convert flag is either ISLONG or ISFIXEDLENGTH, then we should
		// make sure we are not dealing with an OLE DB 1.x provider.  However, since
		// we default to 2.x providers, we don't check this.  If you, change the
		// DBPROP_PROVIDEROLEDBVER property in the DATASOURCEINFO group, you need to
		// check the property value and return a DB_E_BADCONVERTFLAG if it is a 1.x
		// provider.

		// Do we have ISLONG on a fixed length data type?
		DBTYPE dbtype = (DBTYPE) (wFromType & ~(DBTYPE_BYREF|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED));
		if ((dwConvertFlags & DBCONVERTFLAGS_ISLONG) &&
			(dbtype != DBTYPE_WSTR && dbtype != DBTYPE_STR && dbtype != DBTYPE_BYTES && dbtype != DBTYPE_VARNUMERIC))
			return DB_E_BADCONVERTFLAG;

		DBCONVERTFLAGS dwBaseFlags = (DBCONVERTFLAGS)(dwConvertFlags & ~(DBCONVERTFLAGS_ISLONG | DBCONVERTFLAGS_ISFIXEDLENGTH | DBCONVERTFLAGS_FROMVARIANT));

		// Check if this should be an & or an ==
		if (dwBaseFlags == DBCONVERTFLAGS_PARAMETER)
		{
			// In the case where we are a rowset and ask for a parameter
			// conversion, return DB_E_BADCONVERTFLAG
			if (!bIsCommand)
				return DB_E_BADCONVERTFLAG;

			// In the case where we are a command and ask for a parameter
			// conversion and ICommandWithParameters is not supported, return
			// DB_E_BADCONVERTFLAG.  We used to return S_FALSE, but spec says
			// return DB_E_BADCONVERTFLAG if not supported.
			if (!bHasParamaters)
				return DB_E_BADCONVERTFLAG;
		}

		// If we deal with a command and the user asks for a conversion on a rowset
		// the DBPROP_ROWSETCONVERSIONSONCOMMAND must be supported and set to TRUE.
		if (bIsCommand && (dwBaseFlags == DBCONVERTFLAGS_COLUMN))
		{
			CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
			if(!set.AddPropertyID(DBPROP_ROWSETCONVERSIONSONCOMMAND))
			{
				return E_FAIL;
			}
			DBPROPSET* pPropSet = NULL;
			ULONG ulPropSet = 0;

			// Get a pointer into the session
			CComPtr<IGetDataSource> spDataSource;
			CComPtr<IDBProperties> spProps;

			// if any of these calls fail, we're either unable to retrieve the
			// property or it is unsupported.  Since the property is only on
			// the data source object, we use the IObjectWithSite interface to
			// get the session object and then the GetDataSource method to get
			// the data source object itself.
			if (FAILED(pSite->GetSite(__uuidof(IGetDataSource), (void**)&spDataSource)))
				return DB_E_BADCONVERTFLAG;
			if (FAILED(spDataSource->GetDataSource(__uuidof(IDBProperties),
				(IUnknown**)&spProps)))
				return DB_E_BADCONVERTFLAG;
			if (FAILED(spProps->GetProperties(1, &set, &ulPropSet, &pPropSet)))
				return DB_E_BADCONVERTFLAG;

			if (pPropSet != NULL)
			{
				CComVariant var = pPropSet->rgProperties[0].vValue;
				CoTaskMemFree(pPropSet->rgProperties);
				CoTaskMemFree(pPropSet);

				if (var.boolVal == ATL_VARIANT_FALSE)
					return DB_E_BADCONVERTFLAG;
			}
		}
		HRESULT hr = E_FAIL;
		if (m_spConvert != NULL)
		{
			hr = m_spConvert->CanConvert(wFromType, wToType);
			if (hr == E_INVALIDARG)
			{
				// Data Conversion library said the types specified were invalid
				// however, in OLE DB 2.X, the value for this changed from
				// E_INVALIDARG to S_FALSE
				hr = S_FALSE;
			}
		}
		return hr;
	}
	STDMETHOD(CanConvert)(
		_In_ DBTYPE wFromType,
		_In_ DBTYPE wToType,
		_In_ DBCONVERTFLAGS dwConvertFlags)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("IConvertTypeImpl::CanConvert\n"));
		T* pT = (T*)this;
		return pT->InternalCanConvert(wFromType, wToType, dwConvertFlags, pT->m_bIsCommand, pT->m_bHasParamaters, pT);
	}
};

template <class T, class PropClass = T>
class ATL_NO_VTABLE ICommandPropertiesImpl :
	public ICommandProperties,
	public CUtlProps<PropClass>
{
public:
	typedef PropClass _PropClass;

	STDMETHOD(GetProperties)(
		_In_ const ULONG cPropertyIDSets,
		_In_count_(cPropertyIDSets) const DBPROPIDSET rgPropertyIDSets[],
		_Out_ ULONG *pcPropertySets,
		_Out_ _Deref_post_opt_cap_(*pcPropertySets) DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandPropertiesImpl::GetProperties\n"));

		T* pT;
		pT = static_cast<T*>(this);
		m_dwFlags |= ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets, pcPropertySets, prgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
					rgPropertyIDSets, pcPropertySets, prgPropertySets,
					ulPropInits, ppGuid);
		}
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		return hr;

	}

	STDMETHOD(SetProperties)(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandPropertiesImpl::SetProperties\n"));
		T* pT = (T*)this;

		if (pT->m_cRowsetsOpen > 0)
			return DB_E_OBJECTOPEN;	// Don't allow property sets on an open rowset

		HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);
		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets,
					rgPropertySets, ulPropInits, ppGuid);
		}
		return hr;
	}
};

template <class T, class CommandBase = ICommand>
class ATL_NO_VTABLE ICommandImpl :
	public CommandBase
{
public:
	ICommandImpl()
	{
		m_bIsExecuting = FALSE;
		m_bCancelWhenExecuting = TRUE;
		m_bCancel = FALSE;
	}
	HRESULT CancelExecution()
	{
		T* pT = (T*)this;
		pT->Lock();
		m_bCancel = TRUE;
		pT->Unlock();
		return S_OK;
	}
	STDMETHOD(Cancel)()
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::Cancel\n"));
		HRESULT hr = S_OK;
		T* pT = (T*)this;

		if (m_bIsExecuting && m_bCancelWhenExecuting)
		{
			hr = pT->CancelExecution();
			return hr;
		}
		if (m_bIsExecuting && !m_bCancelWhenExecuting)
			hr = DB_E_CANTCANCEL;
		return hr;
	}
	STDMETHOD(GetDBSession)(
		_In_ REFIID riid,
		_Deref_out_ IUnknown** ppSession)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::GetDBSession\n"));
		if( ppSession == NULL )
			return E_INVALIDARG;
		T* pT = (T*)this;
		ATLASSERT(pT->m_spUnkSite != NULL);
		return pT->m_spUnkSite->QueryInterface(riid, (void**) ppSession);
	}
	
ATLPREFAST_SUPPRESS(6387)
	template <class RowsetClass>
	HRESULT CreateRowset(
		_Inout_opt_ IUnknown* pUnkOuter,
		_In_ REFIID riid,
		_In_ DBPARAMS* pParams,
		_Out_ DBROWCOUNT* pcRowsAffected,
		_Deref_opt_out_ IUnknown** ppRowset,
		_Inout_ RowsetClass*& pRowsetObj)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::CreateRowset\n"));

		HRESULT hr;
		T* pT = (T*)this;

		if (pT->m_strCommandText.Length() == 0)
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("ICommandImpl::No command text specified.\n"));
			return DB_E_NOCOMMAND;
		}
		if (InlineIsEqualGUID(IID_NULL, riid))
		{
			ATLTRACE(atlTraceDBProvider, 2, _T("IID_NULL was specified in Execute, returning S_OK"));
			return S_OK;
		}
		if (ppRowset != NULL)
			*ppRowset = NULL;
		else
			return E_INVALIDARG;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return DB_E_NOAGGREGATION;
		CComPolyObject<RowsetClass>* pPolyObj;
		if (FAILED(hr = CComPolyObject<RowsetClass>::CreateInstance(pUnkOuter, &pPolyObj)))
			return hr;
		// Ref the created COM object and Auto release it on failure
		CComPtr<IUnknown> spUnk;
		hr = pPolyObj->QueryInterface(&spUnk);
		if (FAILED(hr))
		{
			delete pPolyObj; // must hand delete as it is not ref'd
			return hr;
		}
		// Get a pointer to the Rowset instance
		pRowsetObj = &(pPolyObj->m_contained);

		if (FAILED(hr = pRowsetObj->FInit(pT)))
			return hr;
		CComPtr<IUnknown> spOuterUnk;
		hr = pT->QueryInterface(__uuidof(IUnknown), (void**)&spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}
		hr = pRowsetObj->SetSite(spOuterUnk);
		if (FAILED(hr))
		{
			return hr;
		}
		pRowsetObj->m_strCommandText = pT->m_strCommandText;

		// Check to make sure we set any 'post' properties based on the riid
		// requested.  Do this before calling Execute in case provider has
		// property specific processing.
		if (FAILED(pRowsetObj->OnInterfaceRequested(riid)))
			return hr;

		POSITION pos = pT->m_rgBindings.GetStartPosition();
		while( pos != NULL )
		{
			T::_BindingVector::CPair *pPair = pT->m_rgBindings.GetNext(pos);
			ATLENSURE_RETURN( pPair != NULL );
			T::_BindType* pBind = NULL;
			T::_BindType* pBindSrc = NULL;
			ATLTRY(pBind = new T::_BindType);
			CAutoPtr<T::_BindType> amr(pBind);
			if (pBind == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 2, _T("Failed to allocate memory for new Binding\n"));
				return E_OUTOFMEMORY;
			}
			pBindSrc = pPair->m_value;
			if (pBindSrc == NULL)
			{
				ATLTRACE(atlTraceDBProvider, 2, _T("The map appears to be corrupted, failing!!\n"));
				return E_FAIL;
			}
			_ATLTRY
			{
				pRowsetObj->m_rgBindings.SetAt(pPair->m_key, pBind);
			}
			_ATLCATCH( e )
			{
				_ATLDELETEEXCEPTION( e );
				ATLTRACE(atlTraceDBProvider, 2, _T("Failed to add hAccessor to Map\n"));
				return E_OUTOFMEMORY;
			}
			if (pBindSrc->cBindings)
			{
				pBind->pBindings =NULL;
				ATLTRY(pBind->pBindings = new DBBINDING[pBindSrc->cBindings])
				if (pBind->pBindings == NULL)
				{
					ATLTRACE(atlTraceDBProvider, 2, _T("Failed to Allocate dbbinding Array\n"));
					// We added it, must now remove on failure
					pRowsetObj->m_rgBindings.RemoveKey(pPair->m_key);
					return E_OUTOFMEMORY;
				}
			}
			else
			{
				pBind->pBindings = NULL; // NULL Accessor
			}

			pBind->dwAccessorFlags = pBindSrc->dwAccessorFlags;
			pBind->cBindings = pBindSrc->cBindings;
			pBind->dwRef = 1;
			if (pBind->pBindings != NULL)
				Checked::memcpy_s(pBind->pBindings, pBind->cBindings*sizeof(DBBINDING), pBindSrc->pBindings, pBindSrc->cBindings*sizeof(DBBINDING));
			amr.Detach();
		}

		// Execute the command.
		// By default, we'll always return a rowset.  If you do not wish to
		// return a rowset, set this value to false in your Execute function.
		// If you return false, we will not return a rowset pointer, regardless
		// of whether the user requests one.
		m_bRowsetReturned = true;

		HRESULT hrExecute;
		if (FAILED(hrExecute = pRowsetObj->Execute(pParams, pcRowsAffected)))
			return hrExecute;
		if (InlineIsEqualGUID(riid, IID_NULL) || ppRowset == NULL)
		{
			if (ppRowset != NULL)
				*ppRowset = NULL;
			return hrExecute;
		}

		if (m_bRowsetReturned != false)
			hr = pPolyObj->QueryInterface(riid, (void**)ppRowset);
		else
			return hr;

		if (FAILED(hr))
			return hr;

		return hrExecute;
	}
ATLPREFAST_UNSUPPRESS()
	
	unsigned m_bIsExecuting:1;
	unsigned m_bCancelWhenExecuting:1;
	unsigned m_bCancel:1;
	unsigned m_bRowsetReturned:1;
};


template <class T>
class ATL_NO_VTABLE ICommandTextImpl :
	public ICommandImpl<T, ICommandText>
{
public:

	ICommandTextImpl()
	{
		m_guidDialect = DBGUID_DEFAULT;
		m_cRowsetsOpen = 0;
	}

	STDMETHOD(GetCommandText)(
		_Inout_opt_ GUID* pguidDialect,
		_Deref_out_z_ LPOLESTR* ppwszCommand)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ICommandTextImpl::GetCommandText\n"));

		T* pT = (T*)this;
		T::ObjectLock cab(pT);

		GUID guidOrig = IID_NULL;

		if (pguidDialect != NULL)
		{
			guidOrig = *pguidDialect;
			*pguidDialect = GUID_NULL;
		}
		if (ppwszCommand == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("ICommandTextImpl::GetCommandText Bad Command buffer\n"));
			return E_INVALIDARG;
		}
		if (m_strCommandText.m_str == NULL || *(m_strCommandText.m_str) == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("ICommandTextImpl::GetCommandText Bad Command buffer\n"));
			return DB_E_NOCOMMAND;
		}

		*ppwszCommand = AtlAllocTaskWideString(m_strCommandText.m_str);
		if( ppwszCommand != NULL )
		{
			HRESULT hrDialect = S_OK;
			if ( pguidDialect != NULL)
			{
				if(!InlineIsEqualGUID(guidOrig, m_guidDialect))
					hrDialect = DB_S_DIALECTIGNORED;
				*pguidDialect = m_guidDialect;
			}
			return hrDialect;
		}
		else
			return E_OUTOFMEMORY;
	}

	STDMETHOD(SetCommandText)(
		_In_ REFGUID rguidDialect,
		_In_z_ LPCOLESTR pwszCommand)
	{
		_ATLTRY
		{
			T* pT = (T*)this;
			T::ObjectLock cab(pT);

			ATLTRACE(atlTraceDBProvider, 2, _T("ICommandTextImpl::SetCommandText\n"));

			if (m_cRowsetsOpen > 0)
				return DB_E_OBJECTOPEN;

			if (InlineIsEqualGUID(rguidDialect, DBGUID_SQL))
			{
				// Get a pointer into the session
				CComPtr<IGetDataSource> spDataSource;
				CComPtr<IDBProperties> spProps;
				if( SUCCEEDED( pT->GetSite( __uuidof(IGetDataSource), (void**)&spDataSource ) ) &&
					SUCCEEDED( spDataSource->GetDataSource( __uuidof(IDBProperties), (IUnknown**)&spProps ) ) )
				{
					CDBPropIDSet set(DBPROPSET_DATASOURCEINFO);
					if(!set.AddPropertyID(DBPROP_SQLSUPPORT))
					{
						return E_FAIL;
					}
					DBPROPSET* pPropSet = NULL;
					ULONG ulPropSet = 0;
					HRESULT hr = spProps->GetProperties(1, &set, &ulPropSet, &pPropSet);
					if( SUCCEEDED(hr) && pPropSet != NULL )
					{
						CComVariant var = pPropSet->rgProperties[0].vValue;
						CoTaskMemFree(pPropSet->rgProperties);
						CoTaskMemFree(pPropSet);

						if( var.lVal == DBPROPVAL_SQL_NONE )
							return DB_E_BADCONVERTFLAG;
					}
					else
						return DB_E_BADCONVERTFLAG;
				}
				return DB_E_BADCONVERTFLAG;
			}
			if (InlineIsEqualGUID(rguidDialect, GUID_NULL))
				return DB_E_DIALECTNOTSUPPORTED;
			m_guidDialect = rguidDialect;
			m_strCommandText = pwszCommand;
		}
		_ATLCATCHALL()
		{
			return E_FAIL;
		}
		return S_OK;
	}

	LONG m_cRowsetsOpen;
	CComBSTR m_strCommandText;
	GUID m_guidDialect;
};

// ISessionPropertiesImpl
template <class T, class PropClass = T>
class ATL_NO_VTABLE ISessionPropertiesImpl :
	public ISessionProperties,
	public CUtlProps<PropClass>
{
public:
	typedef PropClass _PropClass;

	STDMETHOD(GetProperties)(
		_In_ ULONG cPropertyIDSets,
		_In_count_(cPropertyIDSets) const DBPROPIDSET rgPropertyIDSets[],
		_Out_ ULONG *pcPropertySets,
		_Out_ _Deref_post_opt_cap_(*pcPropertySets) DBPROPSET **prgPropertySets)
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ISessionPropertiesImpl::GetProperties\n"));
		T* pT;
		pT = static_cast<T*>(this);

		// You can't retrieve PROPERTIESINERROR here (it would be processed
		// like any other property set.  Therefore, turn checking off
		m_dwFlags |= ~ARGCHK_PROPERTIESINERROR;
		HRESULT hr = GetPropertiesArgChk(cPropertyIDSets, rgPropertyIDSets,
			pcPropertySets, prgPropertySets);

		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::GetProperties(cPropertyIDSets,
					rgPropertyIDSets, pcPropertySets, prgPropertySets,
					ulPropInits, ppGuid);
		}
		return hr;

	}

	STDMETHOD(SetProperties)(
		_In_ ULONG cPropertySets,
		_In_count_(cPropertySets) DBPROPSET rgPropertySets[])
	{
		ATLTRACE(atlTraceDBProvider, 2, _T("ISessionPropertiesImpl::SetProperties"));
		T* pT;
		pT = static_cast<T*>(this);
		HRESULT hr = SetPropertiesArgChk(cPropertySets, rgPropertySets);

		if(SUCCEEDED(hr))
		{
			// Scan property sets to allow user defined properies
			ULONG ulPropSets = 0;
			ULONG ulPropElems = 0;
			ULONG ulPropInits = 0;
			UPROPSET* pSetA = NULL;
			UPROPSET* pSetTemp = NULL;
			ULONG l=0;
			ULONG cSets = (ULONG)(ULONG_PTR)pT->_GetPropSet(NULL, &ulPropElems);

			CTempBuffer<UPROPSET> tmpBuffer;
			pSetA = tmpBuffer.Allocate(cSets);
			if (pSetA == NULL)
				return E_OUTOFMEMORY;  // We shouldn't get this but...
			pSetTemp = pT->_GetPropSet(&ulPropSets, &ulPropElems, pSetA);

			typedef const GUID* PCGUID;

			for(l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ulPropInits++;
			}

			CTempBuffer<PCGUID> tmpBuffer2;
			PCGUID* ppGuid = tmpBuffer2.Allocate(ulPropInits);
			if (ppGuid == NULL)
				return E_OUTOFMEMORY;
			ulPropInits = 0;
			for (l=0; l<cSets; l++)
			{
				if (pSetTemp[l].bIsChained != true)
					ppGuid[ulPropInits++] = pSetTemp[l].pPropSet;
			}

			hr = CUtlProps<PropClass>::SetProperties(0, cPropertySets, rgPropertySets,
					ulPropInits, ppGuid);
		}
		return hr;
	}
};

// Implementation Class
template <class BindType>
class ATL_NO_VTABLE IAccessorImplBase :
	public IAccessor
{
public:

	STDMETHOD(CreateAccessor)(
		_In_ DBACCESSORFLAGS dwAccessorFlags,
		_In_ DBCOUNTITEM cBindings,
		_In_count_(cBindings) const DBBINDING rgBindings[],
		_In_ DBLENGTH /*cbRowSize*/,
		_Out_ HACCESSOR *phAccessor,
		_Out_cap_(cBindings) DBBINDSTATUS rgStatus[])
	{
		if (!(dwAccessorFlags & DBACCESSOR_PARAMETERDATA) && !(dwAccessorFlags & DBACCESSOR_ROWDATA))
			return DB_E_BADACCESSORFLAGS;
		if (dwAccessorFlags == DBACCESSOR_INVALID)
			return DB_E_BADACCESSORFLAGS;
		if (dwAccessorFlags > 0x000F)
			return DB_E_BADACCESSORFLAGS;
		CAutoPtr<BindType> pBind;
		ATLTRY(pBind . Attach ( new BindType ) )
		if (pBind == NULL)
		{
			ATLTRACE(atlTraceDBProvider, 0, _T("Failed to allocate ATL Binding struct\n"));
			return E_OUTOFMEMORY;
		}
		if (cBindings)
		{
			pBind->pBindings =NULL;
			ATLTRY(pBind->pBindings = new DBBINDING[cBindings])
			if (pBind->pBindings == NULL)
			{
				return E_OUTOFMEMORY;
			}
		}
		else
			pBind->pBindings = NULL; // NULL Accessor

		pBind->dwAccessorFlags = dwAccessorFlags;
		pBind->cBindings = cBindings;
		pBind->dwRef = 1;
		if (pBind->pBindings)
			Checked::memcpy_s(pBind->pBindings, pBind->cBindings*sizeof(DBBINDING), rgBindings, cBindings*sizeof(DBBINDING));
		DBBINDSTATUS status = DBBINDSTATUS_OK;
		memset (rgStatus, status, sizeof(DBBINDSTATUS)*cBindings);
		*phAccessor = (ULONG_PTR)pBind.Detach();
		return S_OK;
	}
	BOOL HasFlag(
		_In_ DBTYPE dbToCheck,
		_In_ DBTYPE dbCombo)
	{
		return ( (dbToCheck & dbCombo) == dbCombo );
	}
	HRESULT ValidateBindings(
		_In_ DBCOUNTITEM cBindings,
		_In_count_(cBindings) const DBBINDING rgBindings[],
		_Out_cap_(cBindings) DBBINDSTATUS rgStatus[],
		_In_ bool bHasBookmarks)
	{
		HRESULT hr = S_OK;

		for (ULONG iBinding = 0; iBinding < cBindings; iBinding++)
		{
			const DBBINDING& rBindCur = rgBindings[iBinding];
			if (rBindCur.iOrdinal == 0)
			{
				if (!m_bIsCommand && !bHasBookmarks)
				{
					hr = DB_E_ERRORSOCCURRED;
					rgStatus[iBinding] = DBBINDSTATUS_BADORDINAL;
					continue;
				}
			}
			if (rBindCur.dwPart == 0) // nothing to bind to
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINFO;
				continue;
			}
			if (HasFlag(rBindCur.wType, (DBTYPE_BYREF | DBTYPE_ARRAY)))
			{
				hr = DB_E_ERRORSOCCURRED;
				rgStatus[iBinding] = DBBINDSTATUS_BADBINDINF